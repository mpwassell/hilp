/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/rbush/rbush.min.js":
/*!*****************************************!*\
  !*** ./node_modules/rbush/rbush.min.js ***!
  \*****************************************/
/***/ (function(module) {

!function(t,i){ true?module.exports=i():0}(this,function(){"use strict";function t(t,r,e,a,h){!function t(n,r,e,a,h){for(;a>e;){if(a-e>600){var o=a-e+1,s=r-e+1,l=Math.log(o),f=.5*Math.exp(2*l/3),u=.5*Math.sqrt(l*f*(o-f)/o)*(s-o/2<0?-1:1),m=Math.max(e,Math.floor(r-s*f/o+u)),c=Math.min(a,Math.floor(r+(o-s)*f/o+u));t(n,r,m,c,h)}var p=n[r],d=e,x=a;for(i(n,e,r),h(n[a],p)>0&&i(n,e,a);d<x;){for(i(n,d,x),d++,x--;h(n[d],p)<0;)d++;for(;h(n[x],p)>0;)x--}0===h(n[e],p)?i(n,e,x):i(n,++x,a),x<=r&&(e=x+1),r<=x&&(a=x-1)}}(t,r,e||0,a||t.length-1,h||n)}function i(t,i,n){var r=t[i];t[i]=t[n],t[n]=r}function n(t,i){return t<i?-1:t>i?1:0}var r=function(t){void 0===t&&(t=9),this._maxEntries=Math.max(4,t),this._minEntries=Math.max(2,Math.ceil(.4*this._maxEntries)),this.clear()};function e(t,i,n){if(!n)return i.indexOf(t);for(var r=0;r<i.length;r++)if(n(t,i[r]))return r;return-1}function a(t,i){h(t,0,t.children.length,i,t)}function h(t,i,n,r,e){e||(e=p(null)),e.minX=1/0,e.minY=1/0,e.maxX=-1/0,e.maxY=-1/0;for(var a=i;a<n;a++){var h=t.children[a];o(e,t.leaf?r(h):h)}return e}function o(t,i){return t.minX=Math.min(t.minX,i.minX),t.minY=Math.min(t.minY,i.minY),t.maxX=Math.max(t.maxX,i.maxX),t.maxY=Math.max(t.maxY,i.maxY),t}function s(t,i){return t.minX-i.minX}function l(t,i){return t.minY-i.minY}function f(t){return(t.maxX-t.minX)*(t.maxY-t.minY)}function u(t){return t.maxX-t.minX+(t.maxY-t.minY)}function m(t,i){return t.minX<=i.minX&&t.minY<=i.minY&&i.maxX<=t.maxX&&i.maxY<=t.maxY}function c(t,i){return i.minX<=t.maxX&&i.minY<=t.maxY&&i.maxX>=t.minX&&i.maxY>=t.minY}function p(t){return{children:t,height:1,leaf:!0,minX:1/0,minY:1/0,maxX:-1/0,maxY:-1/0}}function d(i,n,r,e,a){for(var h=[n,r];h.length;)if(!((r=h.pop())-(n=h.pop())<=e)){var o=n+Math.ceil((r-n)/e/2)*e;t(i,o,n,r,a),h.push(n,o,o,r)}}return r.prototype.all=function(){return this._all(this.data,[])},r.prototype.search=function(t){var i=this.data,n=[];if(!c(t,i))return n;for(var r=this.toBBox,e=[];i;){for(var a=0;a<i.children.length;a++){var h=i.children[a],o=i.leaf?r(h):h;c(t,o)&&(i.leaf?n.push(h):m(t,o)?this._all(h,n):e.push(h))}i=e.pop()}return n},r.prototype.collides=function(t){var i=this.data;if(!c(t,i))return!1;for(var n=[];i;){for(var r=0;r<i.children.length;r++){var e=i.children[r],a=i.leaf?this.toBBox(e):e;if(c(t,a)){if(i.leaf||m(t,a))return!0;n.push(e)}}i=n.pop()}return!1},r.prototype.load=function(t){if(!t||!t.length)return this;if(t.length<this._minEntries){for(var i=0;i<t.length;i++)this.insert(t[i]);return this}var n=this._build(t.slice(),0,t.length-1,0);if(this.data.children.length)if(this.data.height===n.height)this._splitRoot(this.data,n);else{if(this.data.height<n.height){var r=this.data;this.data=n,n=r}this._insert(n,this.data.height-n.height-1,!0)}else this.data=n;return this},r.prototype.insert=function(t){return t&&this._insert(t,this.data.height-1),this},r.prototype.clear=function(){return this.data=p([]),this},r.prototype.remove=function(t,i){if(!t)return this;for(var n,r,a,h=this.data,o=this.toBBox(t),s=[],l=[];h||s.length;){if(h||(h=s.pop(),r=s[s.length-1],n=l.pop(),a=!0),h.leaf){var f=e(t,h.children,i);if(-1!==f)return h.children.splice(f,1),s.push(h),this._condense(s),this}a||h.leaf||!m(h,o)?r?(n++,h=r.children[n],a=!1):h=null:(s.push(h),l.push(n),n=0,r=h,h=h.children[0])}return this},r.prototype.toBBox=function(t){return t},r.prototype.compareMinX=function(t,i){return t.minX-i.minX},r.prototype.compareMinY=function(t,i){return t.minY-i.minY},r.prototype.toJSON=function(){return this.data},r.prototype.fromJSON=function(t){return this.data=t,this},r.prototype._all=function(t,i){for(var n=[];t;)t.leaf?i.push.apply(i,t.children):n.push.apply(n,t.children),t=n.pop();return i},r.prototype._build=function(t,i,n,r){var e,h=n-i+1,o=this._maxEntries;if(h<=o)return a(e=p(t.slice(i,n+1)),this.toBBox),e;r||(r=Math.ceil(Math.log(h)/Math.log(o)),o=Math.ceil(h/Math.pow(o,r-1))),(e=p([])).leaf=!1,e.height=r;var s=Math.ceil(h/o),l=s*Math.ceil(Math.sqrt(o));d(t,i,n,l,this.compareMinX);for(var f=i;f<=n;f+=l){var u=Math.min(f+l-1,n);d(t,f,u,s,this.compareMinY);for(var m=f;m<=u;m+=s){var c=Math.min(m+s-1,u);e.children.push(this._build(t,m,c,r-1))}}return a(e,this.toBBox),e},r.prototype._chooseSubtree=function(t,i,n,r){for(;r.push(i),!i.leaf&&r.length-1!==n;){for(var e=1/0,a=1/0,h=void 0,o=0;o<i.children.length;o++){var s=i.children[o],l=f(s),u=(m=t,c=s,(Math.max(c.maxX,m.maxX)-Math.min(c.minX,m.minX))*(Math.max(c.maxY,m.maxY)-Math.min(c.minY,m.minY))-l);u<a?(a=u,e=l<e?l:e,h=s):u===a&&l<e&&(e=l,h=s)}i=h||i.children[0]}var m,c;return i},r.prototype._insert=function(t,i,n){var r=n?t:this.toBBox(t),e=[],a=this._chooseSubtree(r,this.data,i,e);for(a.children.push(t),o(a,r);i>=0&&e[i].children.length>this._maxEntries;)this._split(e,i),i--;this._adjustParentBBoxes(r,e,i)},r.prototype._split=function(t,i){var n=t[i],r=n.children.length,e=this._minEntries;this._chooseSplitAxis(n,e,r);var h=this._chooseSplitIndex(n,e,r),o=p(n.children.splice(h,n.children.length-h));o.height=n.height,o.leaf=n.leaf,a(n,this.toBBox),a(o,this.toBBox),i?t[i-1].children.push(o):this._splitRoot(n,o)},r.prototype._splitRoot=function(t,i){this.data=p([t,i]),this.data.height=t.height+1,this.data.leaf=!1,a(this.data,this.toBBox)},r.prototype._chooseSplitIndex=function(t,i,n){for(var r,e,a,o,s,l,u,m=1/0,c=1/0,p=i;p<=n-i;p++){var d=h(t,0,p,this.toBBox),x=h(t,p,n,this.toBBox),v=(e=d,a=x,o=void 0,s=void 0,l=void 0,u=void 0,o=Math.max(e.minX,a.minX),s=Math.max(e.minY,a.minY),l=Math.min(e.maxX,a.maxX),u=Math.min(e.maxY,a.maxY),Math.max(0,l-o)*Math.max(0,u-s)),M=f(d)+f(x);v<m?(m=v,r=p,c=M<c?M:c):v===m&&M<c&&(c=M,r=p)}return r||n-i},r.prototype._chooseSplitAxis=function(t,i,n){var r=t.leaf?this.compareMinX:s,e=t.leaf?this.compareMinY:l;this._allDistMargin(t,i,n,r)<this._allDistMargin(t,i,n,e)&&t.children.sort(r)},r.prototype._allDistMargin=function(t,i,n,r){t.children.sort(r);for(var e=this.toBBox,a=h(t,0,i,e),s=h(t,n-i,n,e),l=u(a)+u(s),f=i;f<n-i;f++){var m=t.children[f];o(a,t.leaf?e(m):m),l+=u(a)}for(var c=n-i-1;c>=i;c--){var p=t.children[c];o(s,t.leaf?e(p):p),l+=u(s)}return l},r.prototype._adjustParentBBoxes=function(t,i,n){for(var r=n;r>=0;r--)o(i[r],t)},r.prototype._condense=function(t){for(var i=t.length-1,n=void 0;i>=0;i--)0===t[i].children.length?i>0?(n=t[i-1].children).splice(n.indexOf(t[i]),1):this.clear():a(t[i],this.toBBox)},r});


/***/ }),

/***/ "./src/data.js":
/*!*********************!*\
  !*** ./src/data.js ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    'type': 'FeatureCollection',
    'crs': {
      'type': 'name',
      'properties': {
        'name': 'EPSG:4326',
      },
    },
    'features': [
        { "type": "Feature", "properties": { "fid": 8, "name": "Community Orchard" }, "geometry": { "type": "Polygon", "coordinates": [ [ [ 0.0987227, 52.2494998 ], [ 0.0995305, 52.2489587 ], [ 0.1002949, 52.2495819 ], [ 0.0999308, 52.249716 ], [ 0.0995052, 52.2497471 ], [ 0.0990234, 52.2496562 ], [ 0.0987227, 52.2494998 ] ] ] } },
        { "type": "Feature", "properties": { "fid": 9, "name": "Holiday Inn Field" }, "geometry": { "type": "Polygon", "coordinates": [ [ [ 0.1135207, 52.2410769 ], [ 0.1131657, 52.2402074 ], [ 0.1137525, 52.2401142 ], [ 0.1136366, 52.2393911 ], [ 0.1150132, 52.2390672 ], [ 0.114477, 52.2379181 ], [ 0.1206063, 52.2366225 ], [ 0.1213888, 52.2384283 ], [ 0.1158681, 52.2403227 ], [ 0.1135207, 52.2410769 ] ] ] } },
        { "type": "Feature", "properties": { "fid": 10, "name": "WI Woods" }, "geometry": { "type": "Polygon", "coordinates": [ [ [ 0.0960493, 52.2510777 ], [ 0.0947089, 52.2499866 ], [ 0.0970998, 52.249033 ], [ 0.0981431, 52.248687 ], [ 0.0992371, 52.248545 ], [ 0.0994037, 52.2487757 ], [ 0.0960493, 52.2510777 ] ] ] } },
        { "type": "Feature", "properties": { "fid": 11, "name": "Croft Close Set-Aside" }, "geometry": { "type": "Polygon", "coordinates": [ [ [ 0.0999688, 52.2607149 ], [ 0.0994834, 52.25991 ], [ 0.099382, 52.2581982 ], [ 0.1019322, 52.2577016 ], [ 0.1028234, 52.2584954 ], [ 0.1017077, 52.2591096 ], [ 0.0999688, 52.2607149 ] ] ] } },
        { "type": "Feature", "properties": { "fid": 14, "name": "Long Meadow" }, "geometry": { "type": "Polygon", "coordinates": [ [ [ 0.0936127, 52.2559706 ], [ 0.0932287, 52.2552344 ], [ 0.0965687, 52.254201 ], [ 0.0968947, 52.2546978 ], [ 0.0952356, 52.2551723 ], [ 0.0936127, 52.2559706 ] ] ] } },
        { "type": "Feature", "properties": { "fid": 15, "name": "Rec" }, "geometry": { "type": "Polygon", "coordinates": [ [ [ 0.1123592, 52.2445935 ], [ 0.1119173, 52.2438749 ], [ 0.112975, 52.2425351 ], [ 0.114127, 52.2427348 ], [ 0.1154311, 52.242422 ], [ 0.114482, 52.2412153 ], [ 0.1154673, 52.2408915 ], [ 0.1163005, 52.2415791 ], [ 0.1164744, 52.2421758 ], [ 0.1169236, 52.2434534 ], [ 0.1123592, 52.2445935 ] ] ] } },
        { "type": "Feature", "properties": { "fid": 16, "name": "Manor Field" }, "geometry": { "type": "Polygon", "coordinates": [ [ [ 0.097842, 52.2507537 ], [ 0.0976572, 52.2501616 ], [ 0.0986878, 52.2495051 ], [ 0.0990066, 52.2496737 ], [ 0.0994884, 52.2497557 ], [ 0.0999412, 52.2497269 ], [ 0.1003134, 52.2495938 ], [ 0.1007699, 52.2499708 ], [ 0.1003397, 52.2500817 ], [ 0.0995029, 52.2502946 ], [ 0.0991642, 52.250461 ], [ 0.097842, 52.2507537 ] ] ] } },
        { "type": "Feature", "properties": { "fid": 1, "name": "Busway" }, "geometry": { "type": "LineString", "coordinates": [ [ 0.0795759, 52.2622695 ], [ 0.0827148, 52.2600496 ], [ 0.090981, 52.254574 ], [ 0.097655, 52.2501493 ], [ 0.1062045, 52.2444673 ], [ 0.1088863, 52.2428234 ], [ 0.1104166, 52.2421546 ], [ 0.1119389, 52.2417387 ], [ 0.1245322, 52.2375506 ], [ 0.130052, 52.2357736 ] ] } },
{ "type": "Feature", "properties": { "fid": 2, "name": "Girton Bridle Path" }, "geometry": { "type": "LineString", "coordinates": [ [ 0.094785, 52.2503333 ], [ 0.0917726, 52.2509097 ], [ 0.0917079, 52.2509166 ], [ 0.091639, 52.2508883 ], [ 0.0895634, 52.2494563 ], [ 0.0884851, 52.2487374 ], [ 0.088414, 52.2487049 ], [ 0.0883334, 52.248711 ], [ 0.088135, 52.2487911 ], [ 0.0868373, 52.2493209 ], [ 0.0867449, 52.2493453 ], [ 0.0865755, 52.249317 ], [ 0.0865131, 52.2492727 ], [ 0.0864236, 52.2491776 ], [ 0.0863639, 52.2491199 ], [ 0.0863684, 52.2489647 ], [ 0.0863376, 52.2488937 ], [ 0.0861854, 52.2487959 ], [ 0.0860906, 52.2487432 ], [ 0.0860462, 52.2484393 ], [ 0.0857682, 52.248265 ], [ 0.0857147, 52.2482212 ], [ 0.0854743, 52.2479917 ], [ 0.0852959, 52.2479141 ], [ 0.0851153, 52.2478373 ], [ 0.084793, 52.2476579 ], [ 0.0847686, 52.2476435 ], [ 0.0847695, 52.2476435 ] ] } },
{ "type": "Feature", "properties": { "fid": 3, "name": "Histon-Girton Footpath" }, "geometry": { "type": "LineString", "coordinates": [ [ 0.0959703, 52.2511465 ], [ 0.0948274, 52.2503226 ], [ 0.094668, 52.2503448 ], [ 0.0943329, 52.2500532 ], [ 0.0930193, 52.2488716 ], [ 0.0910734, 52.2485002 ], [ 0.0902366, 52.2477272 ], [ 0.0901695, 52.2476662 ], [ 0.0900559, 52.2476174 ], [ 0.089585, 52.2476219 ], [ 0.0894491, 52.2476019 ], [ 0.0893241, 52.2475138 ], [ 0.087944, 52.2465437 ], [ 0.0877424, 52.2463912 ] ] } },
{ "type": "Feature", "properties": { "fid": 4, "name": "Girton Wood East" }, "geometry": { "type": "LineString", "coordinates": [ [ 0.0967119, 52.2491266 ], [ 0.0965933, 52.2490051 ], [ 0.094907, 52.247344 ], [ 0.0944768, 52.246917 ], [ 0.0934788, 52.2472604 ], [ 0.0933412, 52.2471947 ], [ 0.0931148, 52.2470792 ], [ 0.0931247, 52.2469499 ], [ 0.0930455, 52.2468681 ], [ 0.0922372, 52.2460312 ], [ 0.0921484, 52.2458832 ], [ 0.0919669, 52.2457021 ], [ 0.0916508, 52.2453974 ], [ 0.0901411, 52.2439382 ], [ 0.0891775, 52.2430113 ], [ 0.0884988, 52.2423759 ] ] } },
{ "type": "Feature", "properties": { "fid": 5, "name": "Mere Way Bridle Path" }, "geometry": { "type": "LineString", "coordinates": [ [ 0.1300327, 52.2357758 ], [ 0.1303624, 52.2361607 ], [ 0.1305924, 52.2364447 ], [ 0.130712, 52.2364879 ], [ 0.131595, 52.2366011 ], [ 0.131499, 52.2370714 ], [ 0.1316131, 52.2372577 ], [ 0.1317254, 52.2376082 ], [ 0.1319119, 52.2378445 ], [ 0.132285, 52.2383281 ], [ 0.1334334, 52.2396569 ], [ 0.1338445, 52.2401133 ], [ 0.1371764, 52.2438803 ], [ 0.1423249, 52.249342 ], [ 0.1424598, 52.249587 ], [ 0.1428003, 52.2501298 ], [ 0.1435092, 52.2508911 ], [ 0.1446897, 52.2521556 ], [ 0.1448618, 52.2523452 ], [ 0.1453888, 52.2529024 ], [ 0.1459784, 52.2535261 ] ] } },
{ "type": "Feature", "properties": { "fid": 6, "name": "Cambridge Rd to Girton" }, "geometry": { "type": "LineString", "coordinates": [ [ 0.1113435, 52.2307577 ], [ 0.1108164, 52.230872 ], [ 0.1078351, 52.2306446 ], [ 0.1076703, 52.2305142 ], [ 0.1076612, 52.2304122 ], [ 0.107462, 52.23038 ], [ 0.1064585, 52.2297881 ], [ 0.1058192, 52.2293976 ], [ 0.1053337, 52.229112 ], [ 0.1046346, 52.228747 ], [ 0.1027147, 52.2277612 ], [ 0.1011986, 52.2270784 ], [ 0.1011316, 52.2269785 ], [ 0.1000095, 52.2264759 ], [ 0.0993493, 52.2261825 ] ] } },
{ "type": "Feature", "properties": { "fid": 7, "name": "Gatehouse - Westwick Bridle Way" }, "geometry": { "type": "LineString", "coordinates": [ [ 0.0835642, 52.2523678 ], [ 0.0834863, 52.2525884 ], [ 0.0835769, 52.2526749 ], [ 0.0835515, 52.2527836 ], [ 0.0831186, 52.2532016 ], [ 0.0826749, 52.2536451 ], [ 0.082261, 52.2542489 ], [ 0.0819459, 52.2544462 ], [ 0.0817149, 52.2546397 ], [ 0.0811063, 52.2553177 ], [ 0.0799163, 52.2566532 ], [ 0.0786322, 52.2566077 ], [ 0.0767937, 52.2568982 ], [ 0.0766416, 52.2571621 ], [ 0.0767937, 52.2575545 ], [ 0.0769857, 52.2578472 ], [ 0.0772773, 52.2581848 ], [ 0.0777754, 52.2585596 ], [ 0.0782939, 52.2589373 ], [ 0.0784307, 52.2590842 ], [ 0.0784252, 52.2591236 ], [ 0.0779932, 52.2596255 ], [ 0.0780267, 52.2596871 ], [ 0.0791887, 52.2602295 ], [ 0.0792412, 52.2602899 ], [ 0.0790601, 52.2605895 ], [ 0.0788744, 52.2608506 ], [ 0.0786371, 52.2611272 ], [ 0.078494, 52.2612954 ], [ 0.0783555, 52.2614113 ], [ 0.0781644, 52.2614639 ], [ 0.0780462, 52.2615243 ], [ 0.0779756, 52.2616452 ], [ 0.0780353, 52.2616895 ], [ 0.0780353, 52.2616895 ] ] } },
{ "type": "Feature", "properties": { "fid": 8, "name": "St Audrey's to New School Rd" }, "geometry": { "type": "LineString", "coordinates": [ [ 0.0975281, 52.2523376 ], [ 0.0974203, 52.2521687 ], [ 0.0973053, 52.2519806 ], [ 0.0967744, 52.2511097 ], [ 0.0972951, 52.2509275 ], [ 0.0976669, 52.2508022 ], [ 0.0976932, 52.2507701 ], [ 0.0986531, 52.2505694 ], [ 0.0991232, 52.2504654 ], [ 0.0995402, 52.2502892 ], [ 0.099758, 52.2501959 ], [ 0.1002178, 52.2500848 ], [ 0.1005826, 52.2499959 ], [ 0.1008568, 52.249932 ], [ 0.1011366, 52.2498688 ], [ 0.1019086, 52.2496993 ], [ 0.1023678, 52.2495967 ], [ 0.1029775, 52.249456 ], [ 0.1041032, 52.2492162 ], [ 0.1041209, 52.2491921 ], [ 0.1041209, 52.2491608 ], [ 0.1039796, 52.2489824 ], [ 0.1038424, 52.2488043 ], [ 0.1035539, 52.24843 ], [ 0.1036164, 52.2484095 ] ] } },
{ "type": "Feature", "properties": { "fid": 9, "name": "Croft Close Set-aside to Westwick" }, "geometry": { "type": "LineString", "coordinates": [ [ 0.099278, 52.2586041 ], [ 0.0965294, 52.2590952 ], [ 0.0942246, 52.2595226 ], [ 0.0926896, 52.2598258 ], [ 0.092014, 52.2592948 ], [ 0.0914172, 52.2588358 ], [ 0.0903766, 52.2592332 ], [ 0.0899387, 52.2594268 ], [ 0.0890711, 52.2598099 ], [ 0.0884046, 52.2600405 ], [ 0.0857905, 52.2609096 ], [ 0.084075, 52.2615144 ], [ 0.0836819, 52.2615825 ], [ 0.0832418, 52.2617086 ], [ 0.0823221, 52.26198 ], [ 0.082175, 52.262026 ], [ 0.0818707, 52.2621291 ], [ 0.0814251, 52.2623441 ], [ 0.080507, 52.2628028 ], [ 0.0800547, 52.2630307 ] ] } },
{ "type": "Feature", "properties": { "fid": 10, "name": "Gunns Way - Bridle Path" }, "geometry": { "type": "LineString", "coordinates": [ [ 0.1034928, 52.2579912 ], [ 0.1033099, 52.2582119 ], [ 0.1029888, 52.2584591 ], [ 0.1023522, 52.2588092 ], [ 0.1018989, 52.2590766 ], [ 0.1015539, 52.2594053 ], [ 0.1006129, 52.2603527 ], [ 0.1003086, 52.2605846 ], [ 0.0999418, 52.2607831 ], [ 0.0997693, 52.2608854 ], [ 0.0994569, 52.2610239 ], [ 0.0986395, 52.2614926 ], [ 0.0981442, 52.2617066 ], [ 0.0969958, 52.2623678 ], [ 0.0966363, 52.2625462 ], [ 0.0963295, 52.2627522 ], [ 0.0958477, 52.2632893 ], [ 0.0956501, 52.2633944 ], [ 0.0953127, 52.2638116 ], [ 0.0953562, 52.2640034 ], [ 0.0952618, 52.2641951 ], [ 0.0942479, 52.2651654 ], [ 0.093998, 52.2653576 ], [ 0.0930862, 52.2658866 ] ] } }
            ]        
});


/***/ }),

/***/ "./node_modules/ol/Collection.js":
/*!***************************************!*\
  !*** ./node_modules/ol/Collection.js ***!
  \***************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CollectionEvent: () => (/* binding */ CollectionEvent),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Object_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Object.js */ "./node_modules/ol/Object.js");
/* harmony import */ var _CollectionEventType_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./CollectionEventType.js */ "./node_modules/ol/CollectionEventType.js");
/* harmony import */ var _events_Event_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./events/Event.js */ "./node_modules/ol/events/Event.js");
/**
 * @module ol/Collection
 */




/**
 * @enum {string}
 * @private
 */
const Property = {
  LENGTH: 'length',
};

/**
 * @classdesc
 * Events emitted by {@link module:ol/Collection~Collection} instances are instances of this
 * type.
 * @template T
 */
class CollectionEvent extends _events_Event_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {import("./CollectionEventType.js").default} type Type.
   * @param {T} element Element.
   * @param {number} index The index of the added or removed element.
   */
  constructor(type, element, index) {
    super(type);

    /**
     * The element that is added to or removed from the collection.
     * @type {T}
     * @api
     */
    this.element = element;

    /**
     * The index of the added or removed element.
     * @type {number}
     * @api
     */
    this.index = index;
  }
}

/***
 * @template T
 * @template Return
 * @typedef {import("./Observable").OnSignature<import("./Observable").EventTypes, import("./events/Event.js").default, Return> &
 *   import("./Observable").OnSignature<import("./ObjectEventType").Types|'change:length', import("./Object").ObjectEvent, Return> &
 *   import("./Observable").OnSignature<'add'|'remove', CollectionEvent<T>, Return> &
 *   import("./Observable").CombinedOnSignature<import("./Observable").EventTypes|import("./ObjectEventType").Types|
 *     'change:length'|'add'|'remove',Return>} CollectionOnSignature
 */

/**
 * @typedef {Object} Options
 * @property {boolean} [unique=false] Disallow the same item from being added to
 * the collection twice.
 */

/**
 * @classdesc
 * An expanded version of standard JS Array, adding convenience methods for
 * manipulation. Add and remove changes to the Collection trigger a Collection
 * event. Note that this does not cover changes to the objects _within_ the
 * Collection; they trigger events on the appropriate object, not on the
 * Collection as a whole.
 *
 * @fires CollectionEvent
 *
 * @template T
 * @api
 */
class Collection extends _Object_js__WEBPACK_IMPORTED_MODULE_1__["default"] {
  /**
   * @param {Array<T>} [array] Array.
   * @param {Options} [options] Collection options.
   */
  constructor(array, options) {
    super();

    /***
     * @type {CollectionOnSignature<T, import("./events").EventsKey>}
     */
    this.on;

    /***
     * @type {CollectionOnSignature<T, import("./events").EventsKey>}
     */
    this.once;

    /***
     * @type {CollectionOnSignature<T, void>}
     */
    this.un;

    options = options || {};

    /**
     * @private
     * @type {boolean}
     */
    this.unique_ = !!options.unique;

    /**
     * @private
     * @type {!Array<T>}
     */
    this.array_ = array ? array : [];

    if (this.unique_) {
      for (let i = 0, ii = this.array_.length; i < ii; ++i) {
        this.assertUnique_(this.array_[i], i);
      }
    }

    this.updateLength_();
  }

  /**
   * Remove all elements from the collection.
   * @api
   */
  clear() {
    while (this.getLength() > 0) {
      this.pop();
    }
  }

  /**
   * Add elements to the collection.  This pushes each item in the provided array
   * to the end of the collection.
   * @param {!Array<T>} arr Array.
   * @return {Collection<T>} This collection.
   * @api
   */
  extend(arr) {
    for (let i = 0, ii = arr.length; i < ii; ++i) {
      this.push(arr[i]);
    }
    return this;
  }

  /**
   * Iterate over each element, calling the provided callback.
   * @param {function(T, number, Array<T>): *} f The function to call
   *     for every element. This function takes 3 arguments (the element, the
   *     index and the array). The return value is ignored.
   * @api
   */
  forEach(f) {
    const array = this.array_;
    for (let i = 0, ii = array.length; i < ii; ++i) {
      f(array[i], i, array);
    }
  }

  /**
   * Get a reference to the underlying Array object. Warning: if the array
   * is mutated, no events will be dispatched by the collection, and the
   * collection's "length" property won't be in sync with the actual length
   * of the array.
   * @return {!Array<T>} Array.
   * @api
   */
  getArray() {
    return this.array_;
  }

  /**
   * Get the element at the provided index.
   * @param {number} index Index.
   * @return {T} Element.
   * @api
   */
  item(index) {
    return this.array_[index];
  }

  /**
   * Get the length of this collection.
   * @return {number} The length of the array.
   * @observable
   * @api
   */
  getLength() {
    return this.get(Property.LENGTH);
  }

  /**
   * Insert an element at the provided index.
   * @param {number} index Index.
   * @param {T} elem Element.
   * @api
   */
  insertAt(index, elem) {
    if (index < 0 || index > this.getLength()) {
      throw new Error('Index out of bounds: ' + index);
    }
    if (this.unique_) {
      this.assertUnique_(elem);
    }
    this.array_.splice(index, 0, elem);
    this.updateLength_();
    this.dispatchEvent(
      new CollectionEvent(_CollectionEventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].ADD, elem, index)
    );
  }

  /**
   * Remove the last element of the collection and return it.
   * Return `undefined` if the collection is empty.
   * @return {T|undefined} Element.
   * @api
   */
  pop() {
    return this.removeAt(this.getLength() - 1);
  }

  /**
   * Insert the provided element at the end of the collection.
   * @param {T} elem Element.
   * @return {number} New length of the collection.
   * @api
   */
  push(elem) {
    if (this.unique_) {
      this.assertUnique_(elem);
    }
    const n = this.getLength();
    this.insertAt(n, elem);
    return this.getLength();
  }

  /**
   * Remove the first occurrence of an element from the collection.
   * @param {T} elem Element.
   * @return {T|undefined} The removed element or undefined if none found.
   * @api
   */
  remove(elem) {
    const arr = this.array_;
    for (let i = 0, ii = arr.length; i < ii; ++i) {
      if (arr[i] === elem) {
        return this.removeAt(i);
      }
    }
    return undefined;
  }

  /**
   * Remove the element at the provided index and return it.
   * Return `undefined` if the collection does not contain this index.
   * @param {number} index Index.
   * @return {T|undefined} Value.
   * @api
   */
  removeAt(index) {
    if (index < 0 || index >= this.getLength()) {
      return undefined;
    }
    const prev = this.array_[index];
    this.array_.splice(index, 1);
    this.updateLength_();
    this.dispatchEvent(
      /** @type {CollectionEvent<T>} */ (
        new CollectionEvent(_CollectionEventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].REMOVE, prev, index)
      )
    );
    return prev;
  }

  /**
   * Set the element at the provided index.
   * @param {number} index Index.
   * @param {T} elem Element.
   * @api
   */
  setAt(index, elem) {
    const n = this.getLength();
    if (index >= n) {
      this.insertAt(index, elem);
      return;
    }
    if (index < 0) {
      throw new Error('Index out of bounds: ' + index);
    }
    if (this.unique_) {
      this.assertUnique_(elem, index);
    }
    const prev = this.array_[index];
    this.array_[index] = elem;
    this.dispatchEvent(
      /** @type {CollectionEvent<T>} */ (
        new CollectionEvent(_CollectionEventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].REMOVE, prev, index)
      )
    );
    this.dispatchEvent(
      /** @type {CollectionEvent<T>} */ (
        new CollectionEvent(_CollectionEventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].ADD, elem, index)
      )
    );
  }

  /**
   * @private
   */
  updateLength_() {
    this.set(Property.LENGTH, this.array_.length);
  }

  /**
   * @private
   * @param {T} elem Element.
   * @param {number} [except] Optional index to ignore.
   */
  assertUnique_(elem, except) {
    for (let i = 0, ii = this.array_.length; i < ii; ++i) {
      if (this.array_[i] === elem && i !== except) {
        throw new Error('Duplicate item added to a unique collection');
      }
    }
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Collection);


/***/ }),

/***/ "./node_modules/ol/CollectionEventType.js":
/*!************************************************!*\
  !*** ./node_modules/ol/CollectionEventType.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * @module ol/CollectionEventType
 */

/**
 * @enum {string}
 */
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  /**
   * Triggered when an item is added to the collection.
   * @event module:ol/Collection.CollectionEvent#add
   * @api
   */
  ADD: 'add',
  /**
   * Triggered when an item is removed from the collection.
   * @event module:ol/Collection.CollectionEvent#remove
   * @api
   */
  REMOVE: 'remove',
});


/***/ }),

/***/ "./node_modules/ol/Disposable.js":
/*!***************************************!*\
  !*** ./node_modules/ol/Disposable.js ***!
  \***************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * @module ol/Disposable
 */

/**
 * @classdesc
 * Objects that need to clean up after themselves.
 */
class Disposable {
  constructor() {
    /**
     * The object has already been disposed.
     * @type {boolean}
     * @protected
     */
    this.disposed = false;
  }

  /**
   * Clean up.
   */
  dispose() {
    if (!this.disposed) {
      this.disposed = true;
      this.disposeInternal();
    }
  }

  /**
   * Extension point for disposable objects.
   * @protected
   */
  disposeInternal() {}
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Disposable);


/***/ }),

/***/ "./node_modules/ol/Feature.js":
/*!************************************!*\
  !*** ./node_modules/ol/Feature.js ***!
  \************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createStyleFunction: () => (/* binding */ createStyleFunction),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Object_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Object.js */ "./node_modules/ol/Object.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./events/EventType.js */ "./node_modules/ol/events/EventType.js");
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./asserts.js */ "./node_modules/ol/asserts.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./events.js */ "./node_modules/ol/events.js");
/**
 * @module ol/Feature
 */





/**
 * @typedef {typeof Feature|typeof import("./render/Feature.js").default} FeatureClass
 */

/**
 * @typedef {Feature|import("./render/Feature.js").default} FeatureLike
 */

/***
 * @template Return
 * @typedef {import("./Observable").OnSignature<import("./Observable").EventTypes, import("./events/Event.js").default, Return> &
 *   import("./Observable").OnSignature<import("./ObjectEventType").Types|'change:geometry', import("./Object").ObjectEvent, Return> &
 *   import("./Observable").CombinedOnSignature<import("./Observable").EventTypes|import("./ObjectEventType").Types
 *     |'change:geometry', Return>} FeatureOnSignature
 */

/***
 * @template Geometry
 * @typedef {Object<string, *> & { geometry?: Geometry }} ObjectWithGeometry
 */

/**
 * @classdesc
 * A vector object for geographic features with a geometry and other
 * attribute properties, similar to the features in vector file formats like
 * GeoJSON.
 *
 * Features can be styled individually with `setStyle`; otherwise they use the
 * style of their vector layer.
 *
 * Note that attribute properties are set as {@link module:ol/Object~BaseObject} properties on
 * the feature object, so they are observable, and have get/set accessors.
 *
 * Typically, a feature has a single geometry property. You can set the
 * geometry using the `setGeometry` method and get it with `getGeometry`.
 * It is possible to store more than one geometry on a feature using attribute
 * properties. By default, the geometry used for rendering is identified by
 * the property name `geometry`. If you want to use another geometry property
 * for rendering, use the `setGeometryName` method to change the attribute
 * property associated with the geometry for the feature.  For example:
 *
 * ```js
 *
 * import Feature from 'ol/Feature.js';
 * import Polygon from 'ol/geom/Polygon.js';
 * import Point from 'ol/geom/Point.js';
 *
 * const feature = new Feature({
 *   geometry: new Polygon(polyCoords),
 *   labelPoint: new Point(labelCoords),
 *   name: 'My Polygon',
 * });
 *
 * // get the polygon geometry
 * const poly = feature.getGeometry();
 *
 * // Render the feature as a point using the coordinates from labelPoint
 * feature.setGeometryName('labelPoint');
 *
 * // get the point geometry
 * const point = feature.getGeometry();
 * ```
 *
 * @api
 * @template {import("./geom/Geometry.js").default} [Geometry=import("./geom/Geometry.js").default]
 */
class Feature extends _Object_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {Geometry|ObjectWithGeometry<Geometry>} [geometryOrProperties]
   *     You may pass a Geometry object directly, or an object literal containing
   *     properties. If you pass an object literal, you may include a Geometry
   *     associated with a `geometry` key.
   */
  constructor(geometryOrProperties) {
    super();

    /***
     * @type {FeatureOnSignature<import("./events").EventsKey>}
     */
    this.on;

    /***
     * @type {FeatureOnSignature<import("./events").EventsKey>}
     */
    this.once;

    /***
     * @type {FeatureOnSignature<void>}
     */
    this.un;

    /**
     * @private
     * @type {number|string|undefined}
     */
    this.id_ = undefined;

    /**
     * @type {string}
     * @private
     */
    this.geometryName_ = 'geometry';

    /**
     * User provided style.
     * @private
     * @type {import("./style/Style.js").StyleLike}
     */
    this.style_ = null;

    /**
     * @private
     * @type {import("./style/Style.js").StyleFunction|undefined}
     */
    this.styleFunction_ = undefined;

    /**
     * @private
     * @type {?import("./events.js").EventsKey}
     */
    this.geometryChangeKey_ = null;

    this.addChangeListener(this.geometryName_, this.handleGeometryChanged_);

    if (geometryOrProperties) {
      if (
        typeof (
          /** @type {?} */ (geometryOrProperties).getSimplifiedGeometry
        ) === 'function'
      ) {
        const geometry = /** @type {Geometry} */ (geometryOrProperties);
        this.setGeometry(geometry);
      } else {
        /** @type {Object<string, *>} */
        const properties = geometryOrProperties;
        this.setProperties(properties);
      }
    }
  }

  /**
   * Clone this feature. If the original feature has a geometry it
   * is also cloned. The feature id is not set in the clone.
   * @return {Feature<Geometry>} The clone.
   * @api
   */
  clone() {
    const clone = /** @type {Feature<Geometry>} */ (
      new Feature(this.hasProperties() ? this.getProperties() : null)
    );
    clone.setGeometryName(this.getGeometryName());
    const geometry = this.getGeometry();
    if (geometry) {
      clone.setGeometry(/** @type {Geometry} */ (geometry.clone()));
    }
    const style = this.getStyle();
    if (style) {
      clone.setStyle(style);
    }
    return clone;
  }

  /**
   * Get the feature's default geometry.  A feature may have any number of named
   * geometries.  The "default" geometry (the one that is rendered by default) is
   * set when calling {@link module:ol/Feature~Feature#setGeometry}.
   * @return {Geometry|undefined} The default geometry for the feature.
   * @api
   * @observable
   */
  getGeometry() {
    return /** @type {Geometry|undefined} */ (this.get(this.geometryName_));
  }

  /**
   * Get the feature identifier.  This is a stable identifier for the feature and
   * is either set when reading data from a remote source or set explicitly by
   * calling {@link module:ol/Feature~Feature#setId}.
   * @return {number|string|undefined} Id.
   * @api
   */
  getId() {
    return this.id_;
  }

  /**
   * Get the name of the feature's default geometry.  By default, the default
   * geometry is named `geometry`.
   * @return {string} Get the property name associated with the default geometry
   *     for this feature.
   * @api
   */
  getGeometryName() {
    return this.geometryName_;
  }

  /**
   * Get the feature's style. Will return what was provided to the
   * {@link module:ol/Feature~Feature#setStyle} method.
   * @return {import("./style/Style.js").StyleLike|undefined} The feature style.
   * @api
   */
  getStyle() {
    return this.style_;
  }

  /**
   * Get the feature's style function.
   * @return {import("./style/Style.js").StyleFunction|undefined} Return a function
   * representing the current style of this feature.
   * @api
   */
  getStyleFunction() {
    return this.styleFunction_;
  }

  /**
   * @private
   */
  handleGeometryChange_() {
    this.changed();
  }

  /**
   * @private
   */
  handleGeometryChanged_() {
    if (this.geometryChangeKey_) {
      (0,_events_js__WEBPACK_IMPORTED_MODULE_1__.unlistenByKey)(this.geometryChangeKey_);
      this.geometryChangeKey_ = null;
    }
    const geometry = this.getGeometry();
    if (geometry) {
      this.geometryChangeKey_ = (0,_events_js__WEBPACK_IMPORTED_MODULE_1__.listen)(
        geometry,
        _events_EventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].CHANGE,
        this.handleGeometryChange_,
        this
      );
    }
    this.changed();
  }

  /**
   * Set the default geometry for the feature.  This will update the property
   * with the name returned by {@link module:ol/Feature~Feature#getGeometryName}.
   * @param {Geometry|undefined} geometry The new geometry.
   * @api
   * @observable
   */
  setGeometry(geometry) {
    this.set(this.geometryName_, geometry);
  }

  /**
   * Set the style for the feature to override the layer style.  This can be a
   * single style object, an array of styles, or a function that takes a
   * resolution and returns an array of styles. To unset the feature style, call
   * `setStyle()` without arguments or a falsey value.
   * @param {import("./style/Style.js").StyleLike} [style] Style for this feature.
   * @api
   * @fires module:ol/events/Event~BaseEvent#event:change
   */
  setStyle(style) {
    this.style_ = style;
    this.styleFunction_ = !style ? undefined : createStyleFunction(style);
    this.changed();
  }

  /**
   * Set the feature id.  The feature id is considered stable and may be used when
   * requesting features or comparing identifiers returned from a remote source.
   * The feature id can be used with the
   * {@link module:ol/source/Vector~VectorSource#getFeatureById} method.
   * @param {number|string|undefined} id The feature id.
   * @api
   * @fires module:ol/events/Event~BaseEvent#event:change
   */
  setId(id) {
    this.id_ = id;
    this.changed();
  }

  /**
   * Set the property name to be used when getting the feature's default geometry.
   * When calling {@link module:ol/Feature~Feature#getGeometry}, the value of the property with
   * this name will be returned.
   * @param {string} name The property name of the default geometry.
   * @api
   */
  setGeometryName(name) {
    this.removeChangeListener(this.geometryName_, this.handleGeometryChanged_);
    this.geometryName_ = name;
    this.addChangeListener(this.geometryName_, this.handleGeometryChanged_);
    this.handleGeometryChanged_();
  }
}

/**
 * Convert the provided object into a feature style function.  Functions passed
 * through unchanged.  Arrays of Style or single style objects wrapped
 * in a new feature style function.
 * @param {!import("./style/Style.js").StyleFunction|!Array<import("./style/Style.js").default>|!import("./style/Style.js").default} obj
 *     A feature style function, a single style, or an array of styles.
 * @return {import("./style/Style.js").StyleFunction} A style function.
 */
function createStyleFunction(obj) {
  if (typeof obj === 'function') {
    return obj;
  }
  /**
   * @type {Array<import("./style/Style.js").default>}
   */
  let styles;
  if (Array.isArray(obj)) {
    styles = obj;
  } else {
    (0,_asserts_js__WEBPACK_IMPORTED_MODULE_3__.assert)(
      typeof (/** @type {?} */ (obj).getZIndex) === 'function',
      'Expected an `ol/style/Style` or an array of `ol/style/Style.js`'
    );
    const style = /** @type {import("./style/Style.js").default} */ (obj);
    styles = [style];
  }
  return function () {
    return styles;
  };
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Feature);


/***/ }),

/***/ "./node_modules/ol/Image.js":
/*!**********************************!*\
  !*** ./node_modules/ol/Image.js ***!
  \**********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   decode: () => (/* binding */ decode),
/* harmony export */   decodeFallback: () => (/* binding */ decodeFallback),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   listenImage: () => (/* binding */ listenImage),
/* harmony export */   load: () => (/* binding */ load)
/* harmony export */ });
/* harmony import */ var _events_Target_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./events/Target.js */ "./node_modules/ol/events/Target.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./events/EventType.js */ "./node_modules/ol/events/EventType.js");
/* harmony import */ var _ImageState_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ImageState.js */ "./node_modules/ol/ImageState.js");
/* harmony import */ var _has_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./has.js */ "./node_modules/ol/has.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./functions.js */ "./node_modules/ol/functions.js");
/**
 * @module ol/Image
 */







/**
 * A function that takes an {@link module:ol/Image~ImageWrapper} for the image and a
 * `{string}` for the src as arguments. It is supposed to make it so the
 * underlying image {@link module:ol/Image~ImageWrapper#getImage} is assigned the
 * content specified by the src. If not specified, the default is
 *
 *     function(image, src) {
 *       image.getImage().src = src;
 *     }
 *
 * Providing a custom `imageLoadFunction` can be useful to load images with
 * post requests or - in general - through XHR requests, where the src of the
 * image element would be set to a data URI when the content is loaded.
 *
 * @typedef {function(import("./Image.js").default, string): void} LoadFunction
 * @api
 */

/**
 * @typedef {Object} ImageObject
 * @property {import("./extent.js").Extent} [extent] Extent, if different from the requested one.
 * @property {import("./resolution.js").ResolutionLike} [resolution] Resolution, if different from the requested one.
 * When x and y resolution are different, use the array type (`[xResolution, yResolution]`).
 * @property {number} [pixelRatio] Pixel ratio, if different from the requested one.
 * @property {import('./DataTile.js').ImageLike} image Image.
 */

/**
 * Loader function used for image sources. Receives extent, resolution and pixel ratio as arguments.
 * For images that cover any extent and resolution (static images), the loader function should not accept
 * any arguments. The function returns an {@link import("./DataTile.js").ImageLike image}, an
 * {@link import("./Image.js").ImageObject image object}, or a promise for the same.
 * For loaders that generate images, the promise should not resolve until the image is loaded.
 * If the returned image does not match the extent, resolution or pixel ratio passed to the loader,
 * it has to return an {@link import("./Image.js").ImageObject image object} with the `image` and the
 * correct `extent`, `resolution` and `pixelRatio`.
 *
 * @typedef {function(import("./extent.js").Extent, number, number, (function(HTMLImageElement, string): void)=): import("./DataTile.js").ImageLike|ImageObject|Promise<import("./DataTile.js").ImageLike|ImageObject>} Loader
 * @api
 */

/**
 * Loader function used for image sources. Receives extent, resolution and pixel ratio as arguments.
 * The function returns a promise for an  {@link import("./Image.js").ImageObject image object}.
 *
 * @typedef {function(import("./extent.js").Extent, number, number, (function(HTMLImageElement, string): void)=): import("./DataTile.js").ImageLike|ImageObject|Promise<import("./DataTile.js").ImageLike|ImageObject>} ImageObjectPromiseLoader
 */

class ImageWrapper extends _events_Target_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {import("./extent.js").Extent} extent Extent.
   * @param {number|Array<number>|undefined} resolution Resolution. If provided as array, x and y
   * resolution will be assumed.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("./ImageState.js").default|import("./Image.js").Loader} stateOrLoader State.
   */
  constructor(extent, resolution, pixelRatio, stateOrLoader) {
    super();

    /**
     * @protected
     * @type {import("./extent.js").Extent}
     */
    this.extent = extent;

    /**
     * @private
     * @type {number}
     */
    this.pixelRatio_ = pixelRatio;

    /**
     * @protected
     * @type {number|Array<number>|undefined}
     */
    this.resolution = resolution;

    /**
     * @protected
     * @type {import("./ImageState.js").default}
     */
    this.state =
      typeof stateOrLoader === 'function' ? _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].IDLE : stateOrLoader;

    /**
     * @private
     * @type {import('./DataTile.js').ImageLike|null}
     */
    this.image_ = null;

    /**
     * @protected
     * @type {import("./Image.js").Loader}
     */
    this.loader = typeof stateOrLoader === 'function' ? stateOrLoader : null;
  }

  /**
   * @protected
   */
  changed() {
    this.dispatchEvent(_events_EventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].CHANGE);
  }

  /**
   * @return {import("./extent.js").Extent} Extent.
   */
  getExtent() {
    return this.extent;
  }

  /**
   * @return {import('./DataTile.js').ImageLike} Image.
   */
  getImage() {
    return this.image_;
  }

  /**
   * @return {number} PixelRatio.
   */
  getPixelRatio() {
    return this.pixelRatio_;
  }

  /**
   * @return {number|Array<number>} Resolution.
   */
  getResolution() {
    return /** @type {number} */ (this.resolution);
  }

  /**
   * @return {import("./ImageState.js").default} State.
   */
  getState() {
    return this.state;
  }

  /**
   * Load not yet loaded URI.
   */
  load() {
    if (this.state == _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].IDLE) {
      if (this.loader) {
        this.state = _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADING;
        this.changed();
        const resolution = this.getResolution();
        const requestResolution = Array.isArray(resolution)
          ? resolution[0]
          : resolution;
        (0,_functions_js__WEBPACK_IMPORTED_MODULE_3__.toPromise)(() =>
          this.loader(this.getExtent(), requestResolution, this.getPixelRatio())
        )
          .then((image) => {
            if ('image' in image) {
              this.image_ = image.image;
            }
            if ('extent' in image) {
              this.extent = image.extent;
            }
            if ('resolution' in image) {
              this.resolution = image.resolution;
            }
            if ('pixelRatio' in image) {
              this.pixelRatio_ = image.pixelRatio;
            }
            if (
              image instanceof HTMLImageElement ||
              image instanceof ImageBitmap ||
              image instanceof HTMLCanvasElement ||
              image instanceof HTMLVideoElement
            ) {
              this.image_ = image;
            }
            this.state = _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADED;
          })
          .catch((error) => {
            this.state = _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].ERROR;
            console.error(error); // eslint-disable-line no-console
          })
          .finally(() => this.changed());
      }
    }
  }

  /**
   * @param {import('./DataTile.js').ImageLike} image The image.
   */
  setImage(image) {
    this.image_ = image;
  }

  /**
   * @param {number|Array<number>} resolution Resolution.
   */
  setResolution(resolution) {
    this.resolution = resolution;
  }
}

/**
 * @param {import('./DataTile.js').ImageLike} image Image element.
 * @param {function():any} loadHandler Load callback function.
 * @param {function():any} errorHandler Error callback function.
 * @return {function():void} Callback to stop listening.
 */
function listenImage(image, loadHandler, errorHandler) {
  const img = /** @type {HTMLImageElement} */ (image);
  let listening = true;
  let decoding = false;
  let loaded = false;

  const listenerKeys = [
    (0,_events_js__WEBPACK_IMPORTED_MODULE_4__.listenOnce)(img, _events_EventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOAD, function () {
      loaded = true;
      if (!decoding) {
        loadHandler();
      }
    }),
  ];

  if (img.src && _has_js__WEBPACK_IMPORTED_MODULE_5__.IMAGE_DECODE) {
    decoding = true;
    img
      .decode()
      .then(function () {
        if (listening) {
          loadHandler();
        }
      })
      .catch(function (error) {
        if (listening) {
          if (loaded) {
            loadHandler();
          } else {
            errorHandler();
          }
        }
      });
  } else {
    listenerKeys.push((0,_events_js__WEBPACK_IMPORTED_MODULE_4__.listenOnce)(img, _events_EventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].ERROR, errorHandler));
  }

  return function unlisten() {
    listening = false;
    listenerKeys.forEach(_events_js__WEBPACK_IMPORTED_MODULE_4__.unlistenByKey);
  };
}

/**
 * Loads an image.
 * @param {HTMLImageElement} image Image, not yet loaded.
 * @param {string} [src] `src` attribute of the image. Optional, not required if already present.
 * @return {Promise<HTMLImageElement>} Promise resolving to an `HTMLImageElement`.
 * @api
 */
function load(image, src) {
  return new Promise((resolve, reject) => {
    function handleLoad() {
      unlisten();
      resolve(image);
    }
    function handleError() {
      unlisten();
      reject(new Error('Image load error'));
    }
    function unlisten() {
      image.removeEventListener('load', handleLoad);
      image.removeEventListener('error', handleError);
    }
    image.addEventListener('load', handleLoad);
    image.addEventListener('error', handleError);
    if (src) {
      image.src = src;
    }
  });
}

/**
 * @param {HTMLImageElement} image Image, not yet loaded.
 * @param {string} [src] `src` attribute of the image. Optional, not required if already present.
 * @return {Promise<HTMLImageElement>} Promise resolving to an `HTMLImageElement`.
 */
function decodeFallback(image, src) {
  if (src) {
    image.src = src;
  }
  return _has_js__WEBPACK_IMPORTED_MODULE_5__.IMAGE_DECODE
    ? new Promise((resolve, reject) =>
        image.decode().then(() => resolve(image), reject)
      )
    : load(image);
}

/**
 * Loads an image and decodes it to an `ImageBitmap` if `createImageBitmap()` is supported. Returns
 * the loaded image otherwise.
 * @param {HTMLImageElement} image Image, not yet loaded.
 * @param {string} [src] `src` attribute of the image. Optional, not required if already present.
 * @return {Promise<ImageBitmap|HTMLImageElement>} Promise resolving to an `ImageBitmap` or an
 * `HTMLImageElement` if `createImageBitmap()` is not supported.
 * @api
 */
function decode(image, src) {
  if (src) {
    image.src = src;
  }
  return _has_js__WEBPACK_IMPORTED_MODULE_5__.IMAGE_DECODE && _has_js__WEBPACK_IMPORTED_MODULE_5__.CREATE_IMAGE_BITMAP
    ? image.decode().then(() => createImageBitmap(image))
    : decodeFallback(image);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ImageWrapper);


/***/ }),

/***/ "./node_modules/ol/ImageState.js":
/*!***************************************!*\
  !*** ./node_modules/ol/ImageState.js ***!
  \***************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * @module ol/ImageState
 */

/**
 * @enum {number}
 */
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  IDLE: 0,
  LOADING: 1,
  LOADED: 2,
  ERROR: 3,
  EMPTY: 4,
});


/***/ }),

/***/ "./node_modules/ol/ImageTile.js":
/*!**************************************!*\
  !*** ./node_modules/ol/ImageTile.js ***!
  \**************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Tile_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Tile.js */ "./node_modules/ol/Tile.js");
/* harmony import */ var _TileState_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./TileState.js */ "./node_modules/ol/TileState.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./dom.js */ "./node_modules/ol/dom.js");
/* harmony import */ var _Image_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Image.js */ "./node_modules/ol/Image.js");
/**
 * @module ol/ImageTile
 */





class ImageTile extends _Tile_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("./TileState.js").default} state State.
   * @param {string} src Image source URI.
   * @param {?string} crossOrigin Cross origin.
   * @param {import("./Tile.js").LoadFunction} tileLoadFunction Tile load function.
   * @param {import("./Tile.js").Options} [options] Tile options.
   */
  constructor(tileCoord, state, src, crossOrigin, tileLoadFunction, options) {
    super(tileCoord, state, options);

    /**
     * @private
     * @type {?string}
     */
    this.crossOrigin_ = crossOrigin;

    /**
     * Image URI
     *
     * @private
     * @type {string}
     */
    this.src_ = src;

    this.key = src;

    /**
     * @private
     * @type {HTMLImageElement|HTMLCanvasElement}
     */
    this.image_ = new Image();
    if (crossOrigin !== null) {
      this.image_.crossOrigin = crossOrigin;
    }

    /**
     * @private
     * @type {?function():void}
     */
    this.unlisten_ = null;

    /**
     * @private
     * @type {import("./Tile.js").LoadFunction}
     */
    this.tileLoadFunction_ = tileLoadFunction;
  }

  /**
   * Get the HTML image element for this tile (may be a Canvas, Image, or Video).
   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.
   * @api
   */
  getImage() {
    return this.image_;
  }

  /**
   * Sets an HTML image element for this tile (may be a Canvas or preloaded Image).
   * @param {HTMLCanvasElement|HTMLImageElement} element Element.
   */
  setImage(element) {
    this.image_ = element;
    this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADED;
    this.unlistenImage_();
    this.changed();
  }

  /**
   * Tracks loading or read errors.
   *
   * @private
   */
  handleImageError_() {
    this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].ERROR;
    this.unlistenImage_();
    this.image_ = getBlankImage();
    this.changed();
  }

  /**
   * Tracks successful image load.
   *
   * @private
   */
  handleImageLoad_() {
    const image = /** @type {HTMLImageElement} */ (this.image_);
    if (image.naturalWidth && image.naturalHeight) {
      this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADED;
    } else {
      this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].EMPTY;
    }
    this.unlistenImage_();
    this.changed();
  }

  /**
   * Load the image or retry if loading previously failed.
   * Loading is taken care of by the tile queue, and calling this method is
   * only needed for preloading or for reloading in case of an error.
   *
   * To retry loading tiles on failed requests, use a custom `tileLoadFunction`
   * that checks for error status codes and reloads only when the status code is
   * 408, 429, 500, 502, 503 and 504, and only when not too many retries have been
   * made already:
   *
   * ```js
   * const retryCodes = [408, 429, 500, 502, 503, 504];
   * const retries = {};
   * source.setTileLoadFunction((tile, src) => {
   *   const image = tile.getImage();
   *   fetch(src)
   *     .then((response) => {
   *       if (retryCodes.includes(response.status)) {
   *         retries[src] = (retries[src] || 0) + 1;
   *         if (retries[src] <= 3) {
   *           setTimeout(() => tile.load(), retries[src] * 1000);
   *         }
   *         return Promise.reject();
   *       }
   *       return response.blob();
   *     })
   *     .then((blob) => {
   *       const imageUrl = URL.createObjectURL(blob);
   *       image.src = imageUrl;
   *       setTimeout(() => URL.revokeObjectURL(imageUrl), 5000);
   *     })
   *     .catch(() => tile.setState(3)); // error
   * });
   * ```
   *
   * @api
   */
  load() {
    if (this.state == _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].ERROR) {
      this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].IDLE;
      this.image_ = new Image();
      if (this.crossOrigin_ !== null) {
        this.image_.crossOrigin = this.crossOrigin_;
      }
    }
    if (this.state == _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].IDLE) {
      this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADING;
      this.changed();
      this.tileLoadFunction_(this, this.src_);
      this.unlisten_ = (0,_Image_js__WEBPACK_IMPORTED_MODULE_2__.listenImage)(
        this.image_,
        this.handleImageLoad_.bind(this),
        this.handleImageError_.bind(this)
      );
    }
  }

  /**
   * Discards event handlers which listen for load completion or errors.
   *
   * @private
   */
  unlistenImage_() {
    if (this.unlisten_) {
      this.unlisten_();
      this.unlisten_ = null;
    }
  }
}

/**
 * Get a 1-pixel blank image.
 * @return {HTMLCanvasElement} Blank image.
 */
function getBlankImage() {
  const ctx = (0,_dom_js__WEBPACK_IMPORTED_MODULE_3__.createCanvasContext2D)(1, 1);
  ctx.fillStyle = 'rgba(0,0,0,0)';
  ctx.fillRect(0, 0, 1, 1);
  return ctx.canvas;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ImageTile);


/***/ }),

/***/ "./node_modules/ol/Kinetic.js":
/*!************************************!*\
  !*** ./node_modules/ol/Kinetic.js ***!
  \************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * @module ol/Kinetic
 */

/**
 * @classdesc
 * Implementation of inertial deceleration for map movement.
 *
 * @api
 */
class Kinetic {
  /**
   * @param {number} decay Rate of decay (must be negative).
   * @param {number} minVelocity Minimum velocity (pixels/millisecond).
   * @param {number} delay Delay to consider to calculate the kinetic
   *     initial values (milliseconds).
   */
  constructor(decay, minVelocity, delay) {
    /**
     * @private
     * @type {number}
     */
    this.decay_ = decay;

    /**
     * @private
     * @type {number}
     */
    this.minVelocity_ = minVelocity;

    /**
     * @private
     * @type {number}
     */
    this.delay_ = delay;

    /**
     * @private
     * @type {Array<number>}
     */
    this.points_ = [];

    /**
     * @private
     * @type {number}
     */
    this.angle_ = 0;

    /**
     * @private
     * @type {number}
     */
    this.initialVelocity_ = 0;
  }

  /**
   * FIXME empty description for jsdoc
   */
  begin() {
    this.points_.length = 0;
    this.angle_ = 0;
    this.initialVelocity_ = 0;
  }

  /**
   * @param {number} x X.
   * @param {number} y Y.
   */
  update(x, y) {
    this.points_.push(x, y, Date.now());
  }

  /**
   * @return {boolean} Whether we should do kinetic animation.
   */
  end() {
    if (this.points_.length < 6) {
      // at least 2 points are required (i.e. there must be at least 6 elements
      // in the array)
      return false;
    }
    const delay = Date.now() - this.delay_;
    const lastIndex = this.points_.length - 3;
    if (this.points_[lastIndex + 2] < delay) {
      // the last tracked point is too old, which means that the user stopped
      // panning before releasing the map
      return false;
    }

    // get the first point which still falls into the delay time
    let firstIndex = lastIndex - 3;
    while (firstIndex > 0 && this.points_[firstIndex + 2] > delay) {
      firstIndex -= 3;
    }

    const duration = this.points_[lastIndex + 2] - this.points_[firstIndex + 2];
    // we don't want a duration of 0 (divide by zero)
    // we also make sure the user panned for a duration of at least one frame
    // (1/60s) to compute sane displacement values
    if (duration < 1000 / 60) {
      return false;
    }

    const dx = this.points_[lastIndex] - this.points_[firstIndex];
    const dy = this.points_[lastIndex + 1] - this.points_[firstIndex + 1];
    this.angle_ = Math.atan2(dy, dx);
    this.initialVelocity_ = Math.sqrt(dx * dx + dy * dy) / duration;
    return this.initialVelocity_ > this.minVelocity_;
  }

  /**
   * @return {number} Total distance travelled (pixels).
   */
  getDistance() {
    return (this.minVelocity_ - this.initialVelocity_) / this.decay_;
  }

  /**
   * @return {number} Angle of the kinetic panning animation (radians).
   */
  getAngle() {
    return this.angle_;
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Kinetic);


/***/ }),

/***/ "./node_modules/ol/Map.js":
/*!********************************!*\
  !*** ./node_modules/ol/Map.js ***!
  \********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Object_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Object.js */ "./node_modules/ol/Object.js");
/* harmony import */ var _Collection_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./Collection.js */ "./node_modules/ol/Collection.js");
/* harmony import */ var _CollectionEventType_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./CollectionEventType.js */ "./node_modules/ol/CollectionEventType.js");
/* harmony import */ var _renderer_Composite_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./renderer/Composite.js */ "./node_modules/ol/renderer/Composite.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./events/EventType.js */ "./node_modules/ol/events/EventType.js");
/* harmony import */ var _layer_Layer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./layer/Layer.js */ "./node_modules/ol/layer/Layer.js");
/* harmony import */ var _layer_Group_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./layer/Group.js */ "./node_modules/ol/layer/Group.js");
/* harmony import */ var _MapBrowserEvent_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./MapBrowserEvent.js */ "./node_modules/ol/MapBrowserEvent.js");
/* harmony import */ var _MapBrowserEventHandler_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./MapBrowserEventHandler.js */ "./node_modules/ol/MapBrowserEventHandler.js");
/* harmony import */ var _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./MapBrowserEventType.js */ "./node_modules/ol/MapBrowserEventType.js");
/* harmony import */ var _MapEvent_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./MapEvent.js */ "./node_modules/ol/MapEvent.js");
/* harmony import */ var _MapEventType_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./MapEventType.js */ "./node_modules/ol/MapEventType.js");
/* harmony import */ var _MapProperty_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./MapProperty.js */ "./node_modules/ol/MapProperty.js");
/* harmony import */ var _ObjectEventType_js__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./ObjectEventType.js */ "./node_modules/ol/ObjectEventType.js");
/* harmony import */ var _pointer_EventType_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./pointer/EventType.js */ "./node_modules/ol/pointer/EventType.js");
/* harmony import */ var _render_EventType_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./render/EventType.js */ "./node_modules/ol/render/EventType.js");
/* harmony import */ var _TileQueue_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./TileQueue.js */ "./node_modules/ol/TileQueue.js");
/* harmony import */ var _View_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./View.js */ "./node_modules/ol/View.js");
/* harmony import */ var _ViewHint_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./ViewHint.js */ "./node_modules/ol/ViewHint.js");
/* harmony import */ var _has_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./has.js */ "./node_modules/ol/has.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./functions.js */ "./node_modules/ol/functions.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./transform.js */ "./node_modules/ol/transform.js");
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./asserts.js */ "./node_modules/ol/asserts.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _control_defaults_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./control/defaults.js */ "./node_modules/ol/control/defaults.js");
/* harmony import */ var _interaction_defaults_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./interaction/defaults.js */ "./node_modules/ol/interaction/defaults.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./proj.js */ "./node_modules/ol/proj.js");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./util.js */ "./node_modules/ol/util.js");
/* harmony import */ var _size_js__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./size.js */ "./node_modules/ol/size.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./dom.js */ "./node_modules/ol/dom.js");
/* harmony import */ var _console_js__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./console.js */ "./node_modules/ol/console.js");
/**
 * @module ol/Map
 */


































/**
 * State of the current frame. Only `pixelRatio`, `time` and `viewState` should
 * be used in applications.
 * @typedef {Object} FrameState
 * @property {number} pixelRatio The pixel ratio of the frame.
 * @property {number} time The time when rendering of the frame was requested.
 * @property {import("./View.js").State} viewState The state of the current view.
 * @property {boolean} animate Animate.
 * @property {import("./transform.js").Transform} coordinateToPixelTransform CoordinateToPixelTransform.
 * @property {import("rbush").default} declutterTree DeclutterTree.
 * @property {null|import("./extent.js").Extent} extent Extent (in view projection coordinates).
 * @property {import("./extent.js").Extent} [nextExtent] Next extent during an animation series.
 * @property {number} index Index.
 * @property {Array<import("./layer/Layer.js").State>} layerStatesArray LayerStatesArray.
 * @property {number} layerIndex LayerIndex.
 * @property {import("./transform.js").Transform} pixelToCoordinateTransform PixelToCoordinateTransform.
 * @property {Array<PostRenderFunction>} postRenderFunctions PostRenderFunctions.
 * @property {import("./size.js").Size} size Size.
 * @property {TileQueue} tileQueue TileQueue.
 * @property {!Object<string, Object<string, boolean>>} usedTiles UsedTiles.
 * @property {Array<number>} viewHints ViewHints.
 * @property {!Object<string, Object<string, boolean>>} wantedTiles WantedTiles.
 * @property {string} mapId The id of the map.
 * @property {Object<string, boolean>} renderTargets Identifiers of previously rendered elements.
 */

/**
 * @typedef {function(Map, ?FrameState): any} PostRenderFunction
 */

/**
 * @typedef {Object} AtPixelOptions
 * @property {undefined|function(import("./layer/Layer.js").default<import("./source/Source").default>): boolean} [layerFilter] Layer filter
 * function. The filter function will receive one argument, the
 * {@link module:ol/layer/Layer~Layer layer-candidate} and it should return a boolean value.
 * Only layers which are visible and for which this function returns `true`
 * will be tested for features. By default, all visible layers will be tested.
 * @property {number} [hitTolerance=0] Hit-detection tolerance in css pixels. Pixels
 * inside the radius around the given position will be checked for features.
 * @property {boolean} [checkWrapped=true] Check-Wrapped Will check for wrapped geometries inside the range of
 *   +/- 1 world width. Works only if a projection is used that can be wrapped.
 */

/**
 * @typedef {Object} MapOptionsInternal
 * @property {Collection<import("./control/Control.js").default>} [controls] Controls.
 * @property {Collection<import("./interaction/Interaction.js").default>} [interactions] Interactions.
 * @property {HTMLElement|Document} keyboardEventTarget KeyboardEventTarget.
 * @property {Collection<import("./Overlay.js").default>} overlays Overlays.
 * @property {Object<string, *>} values Values.
 */

/**
 * @typedef {import("./ObjectEventType").Types|'change:layergroup'|'change:size'|'change:target'|'change:view'} MapObjectEventTypes
 */

/***
 * @template Return
 * @typedef {import("./Observable").OnSignature<import("./Observable").EventTypes, import("./events/Event.js").default, Return> &
 *    import("./Observable").OnSignature<MapObjectEventTypes, import("./Object").ObjectEvent, Return> &
 *    import("./Observable").OnSignature<import("./MapBrowserEventType").Types, import("./MapBrowserEvent").default, Return> &
 *    import("./Observable").OnSignature<import("./MapEventType").Types, import("./MapEvent").default, Return> &
 *    import("./Observable").OnSignature<import("./render/EventType").MapRenderEventTypes, import("./render/Event").default, Return> &
 *    import("./Observable").CombinedOnSignature<import("./Observable").EventTypes|MapObjectEventTypes|
 *      import("./MapBrowserEventType").Types|import("./MapEventType").Types|
 *      import("./render/EventType").MapRenderEventTypes, Return>} MapEventHandler
 */

/**
 * Object literal with config options for the map.
 * @typedef {Object} MapOptions
 * @property {Collection<import("./control/Control.js").default>|Array<import("./control/Control.js").default>} [controls]
 * Controls initially added to the map. If not specified,
 * {@link module:ol/control/defaults.defaults} is used.
 * @property {number} [pixelRatio=window.devicePixelRatio] The ratio between
 * physical pixels and device-independent pixels (dips) on the device.
 * @property {Collection<import("./interaction/Interaction.js").default>|Array<import("./interaction/Interaction.js").default>} [interactions]
 * Interactions that are initially added to the map. If not specified,
 * {@link module:ol/interaction/defaults.defaults} is used.
 * @property {HTMLElement|Document|string} [keyboardEventTarget] The element to
 * listen to keyboard events on. This determines when the `KeyboardPan` and
 * `KeyboardZoom` interactions trigger. For example, if this option is set to
 * `document` the keyboard interactions will always trigger. If this option is
 * not specified, the element the library listens to keyboard events on is the
 * map target (i.e. the user-provided div for the map). If this is not
 * `document`, the target element needs to be focused for key events to be
 * emitted, requiring that the target element has a `tabindex` attribute.
 * @property {Array<import("./layer/Base.js").default>|Collection<import("./layer/Base.js").default>|LayerGroup} [layers]
 * Layers. If this is not defined, a map with no layers will be rendered. Note
 * that layers are rendered in the order supplied, so if you want, for example,
 * a vector layer to appear on top of a tile layer, it must come after the tile
 * layer.
 * @property {number} [maxTilesLoading=16] Maximum number tiles to load
 * simultaneously.
 * @property {number} [moveTolerance=1] The minimum distance in pixels the
 * cursor must move to be detected as a map move event instead of a click.
 * Increasing this value can make it easier to click on the map.
 * @property {Collection<import("./Overlay.js").default>|Array<import("./Overlay.js").default>} [overlays]
 * Overlays initially added to the map. By default, no overlays are added.
 * @property {HTMLElement|string} [target] The container for the map, either the
 * element itself or the `id` of the element. If not specified at construction
 * time, {@link module:ol/Map~Map#setTarget} must be called for the map to be
 * rendered. If passed by element, the container can be in a secondary document.
 * **Note:** CSS `transform` support for the target element is limited to `scale`.
 * @property {View|Promise<import("./View.js").ViewOptions>} [view] The map's view.  No layer sources will be
 * fetched unless this is specified at construction time or through
 * {@link module:ol/Map~Map#setView}.
 */

/**
 * @param {import("./layer/Base.js").default} layer Layer.
 */
function removeLayerMapProperty(layer) {
  if (layer instanceof _layer_Layer_js__WEBPACK_IMPORTED_MODULE_1__["default"]) {
    layer.setMapInternal(null);
    return;
  }
  if (layer instanceof _layer_Group_js__WEBPACK_IMPORTED_MODULE_2__["default"]) {
    layer.getLayers().forEach(removeLayerMapProperty);
  }
}

/**
 * @param {import("./layer/Base.js").default} layer Layer.
 * @param {Map} map Map.
 */
function setLayerMapProperty(layer, map) {
  if (layer instanceof _layer_Layer_js__WEBPACK_IMPORTED_MODULE_1__["default"]) {
    layer.setMapInternal(map);
    return;
  }
  if (layer instanceof _layer_Group_js__WEBPACK_IMPORTED_MODULE_2__["default"]) {
    const layers = layer.getLayers().getArray();
    for (let i = 0, ii = layers.length; i < ii; ++i) {
      setLayerMapProperty(layers[i], map);
    }
  }
}

/**
 * @classdesc
 * The map is the core component of OpenLayers. For a map to render, a view,
 * one or more layers, and a target container are needed:
 *
 *     import Map from 'ol/Map.js';
 *     import View from 'ol/View.js';
 *     import TileLayer from 'ol/layer/Tile.js';
 *     import OSM from 'ol/source/OSM.js';
 *
 *     const map = new Map({
 *       view: new View({
 *         center: [0, 0],
 *         zoom: 1,
 *       }),
 *       layers: [
 *         new TileLayer({
 *           source: new OSM(),
 *         }),
 *       ],
 *       target: 'map',
 *     });
 *
 * The above snippet creates a map using a {@link module:ol/layer/Tile~TileLayer} to
 * display {@link module:ol/source/OSM~OSM} OSM data and render it to a DOM
 * element with the id `map`.
 *
 * The constructor places a viewport container (with CSS class name
 * `ol-viewport`) in the target element (see `getViewport()`), and then two
 * further elements within the viewport: one with CSS class name
 * `ol-overlaycontainer-stopevent` for controls and some overlays, and one with
 * CSS class name `ol-overlaycontainer` for other overlays (see the `stopEvent`
 * option of {@link module:ol/Overlay~Overlay} for the difference). The map
 * itself is placed in a further element within the viewport.
 *
 * Layers are stored as a {@link module:ol/Collection~Collection} in
 * layerGroups. A top-level group is provided by the library. This is what is
 * accessed by `getLayerGroup` and `setLayerGroup`. Layers entered in the
 * options are added to this group, and `addLayer` and `removeLayer` change the
 * layer collection in the group. `getLayers` is a convenience function for
 * `getLayerGroup().getLayers()`. Note that {@link module:ol/layer/Group~LayerGroup}
 * is a subclass of {@link module:ol/layer/Base~BaseLayer}, so layers entered in the
 * options or added with `addLayer` can be groups, which can contain further
 * groups, and so on.
 *
 * @fires import("./MapBrowserEvent.js").MapBrowserEvent
 * @fires import("./MapEvent.js").MapEvent
 * @fires import("./render/Event.js").default#precompose
 * @fires import("./render/Event.js").default#postcompose
 * @fires import("./render/Event.js").default#rendercomplete
 * @api
 */
class Map extends _Object_js__WEBPACK_IMPORTED_MODULE_3__["default"] {
  /**
   * @param {MapOptions} [options] Map options.
   */
  constructor(options) {
    super();

    options = options || {};

    /***
     * @type {MapEventHandler<import("./events").EventsKey>}
     */
    this.on;

    /***
     * @type {MapEventHandler<import("./events").EventsKey>}
     */
    this.once;

    /***
     * @type {MapEventHandler<void>}
     */
    this.un;

    const optionsInternal = createOptionsInternal(options);

    /**
     * @private
     * @type {boolean|undefined}
     */
    this.renderComplete_;

    /**
     * @private
     * @type {boolean}
     */
    this.loaded_ = true;

    /** @private */
    this.boundHandleBrowserEvent_ = this.handleBrowserEvent.bind(this);

    /**
     * @type {number}
     * @private
     */
    this.maxTilesLoading_ =
      options.maxTilesLoading !== undefined ? options.maxTilesLoading : 16;

    /**
     * @private
     * @type {number}
     */
    this.pixelRatio_ =
      options.pixelRatio !== undefined
        ? options.pixelRatio
        : _has_js__WEBPACK_IMPORTED_MODULE_4__.DEVICE_PIXEL_RATIO;

    /**
     * @private
     * @type {ReturnType<typeof setTimeout>}
     */
    this.postRenderTimeoutHandle_;

    /**
     * @private
     * @type {number|undefined}
     */
    this.animationDelayKey_;

    /**
     * @private
     */
    this.animationDelay_ = this.animationDelay_.bind(this);

    /**
     * @private
     * @type {import("./transform.js").Transform}
     */
    this.coordinateToPixelTransform_ = (0,_transform_js__WEBPACK_IMPORTED_MODULE_5__.create)();

    /**
     * @private
     * @type {import("./transform.js").Transform}
     */
    this.pixelToCoordinateTransform_ = (0,_transform_js__WEBPACK_IMPORTED_MODULE_5__.create)();

    /**
     * @private
     * @type {number}
     */
    this.frameIndex_ = 0;

    /**
     * @private
     * @type {?FrameState}
     */
    this.frameState_ = null;

    /**
     * The extent at the previous 'moveend' event.
     * @private
     * @type {import("./extent.js").Extent}
     */
    this.previousExtent_ = null;

    /**
     * @private
     * @type {?import("./events.js").EventsKey}
     */
    this.viewPropertyListenerKey_ = null;

    /**
     * @private
     * @type {?import("./events.js").EventsKey}
     */
    this.viewChangeListenerKey_ = null;

    /**
     * @private
     * @type {?Array<import("./events.js").EventsKey>}
     */
    this.layerGroupPropertyListenerKeys_ = null;

    /**
     * @private
     * @type {!HTMLElement}
     */
    this.viewport_ = document.createElement('div');
    this.viewport_.className =
      'ol-viewport' + ('ontouchstart' in window ? ' ol-touch' : '');
    this.viewport_.style.position = 'relative';
    this.viewport_.style.overflow = 'hidden';
    this.viewport_.style.width = '100%';
    this.viewport_.style.height = '100%';

    /**
     * @private
     * @type {!HTMLElement}
     */
    this.overlayContainer_ = document.createElement('div');
    this.overlayContainer_.style.position = 'absolute';
    this.overlayContainer_.style.zIndex = '0';
    this.overlayContainer_.style.width = '100%';
    this.overlayContainer_.style.height = '100%';
    this.overlayContainer_.style.pointerEvents = 'none';
    this.overlayContainer_.className = 'ol-overlaycontainer';
    this.viewport_.appendChild(this.overlayContainer_);

    /**
     * @private
     * @type {!HTMLElement}
     */
    this.overlayContainerStopEvent_ = document.createElement('div');
    this.overlayContainerStopEvent_.style.position = 'absolute';
    this.overlayContainerStopEvent_.style.zIndex = '0';
    this.overlayContainerStopEvent_.style.width = '100%';
    this.overlayContainerStopEvent_.style.height = '100%';
    this.overlayContainerStopEvent_.style.pointerEvents = 'none';
    this.overlayContainerStopEvent_.className = 'ol-overlaycontainer-stopevent';
    this.viewport_.appendChild(this.overlayContainerStopEvent_);

    /**
     * @private
     * @type {MapBrowserEventHandler}
     */
    this.mapBrowserEventHandler_ = null;

    /**
     * @private
     * @type {number}
     */
    this.moveTolerance_ = options.moveTolerance;

    /**
     * @private
     * @type {HTMLElement|Document}
     */
    this.keyboardEventTarget_ = optionsInternal.keyboardEventTarget;

    /**
     * @private
     * @type {?Array<import("./events.js").EventsKey>}
     */
    this.targetChangeHandlerKeys_ = null;

    /**
     * @private
     * @type {HTMLElement|null}
     */
    this.targetElement_ = null;

    /**
     * @type {ResizeObserver}
     */
    this.resizeObserver_ = new ResizeObserver(() => this.updateSize());

    /**
     * @type {Collection<import("./control/Control.js").default>}
     * @protected
     */
    this.controls = optionsInternal.controls || (0,_control_defaults_js__WEBPACK_IMPORTED_MODULE_6__.defaults)();

    /**
     * @type {Collection<import("./interaction/Interaction.js").default>}
     * @protected
     */
    this.interactions =
      optionsInternal.interactions ||
      (0,_interaction_defaults_js__WEBPACK_IMPORTED_MODULE_7__.defaults)({
        onFocusOnly: true,
      });

    /**
     * @type {Collection<import("./Overlay.js").default>}
     * @private
     */
    this.overlays_ = optionsInternal.overlays;

    /**
     * A lookup of overlays by id.
     * @private
     * @type {Object<string, import("./Overlay.js").default>}
     */
    this.overlayIdIndex_ = {};

    /**
     * @type {import("./renderer/Map.js").default|null}
     * @private
     */
    this.renderer_ = null;

    /**
     * @private
     * @type {!Array<PostRenderFunction>}
     */
    this.postRenderFunctions_ = [];

    /**
     * @private
     * @type {TileQueue}
     */
    this.tileQueue_ = new _TileQueue_js__WEBPACK_IMPORTED_MODULE_8__["default"](
      this.getTilePriority.bind(this),
      this.handleTileChange_.bind(this)
    );

    this.addChangeListener(
      _MapProperty_js__WEBPACK_IMPORTED_MODULE_9__["default"].LAYERGROUP,
      this.handleLayerGroupChanged_
    );
    this.addChangeListener(_MapProperty_js__WEBPACK_IMPORTED_MODULE_9__["default"].VIEW, this.handleViewChanged_);
    this.addChangeListener(_MapProperty_js__WEBPACK_IMPORTED_MODULE_9__["default"].SIZE, this.handleSizeChanged_);
    this.addChangeListener(_MapProperty_js__WEBPACK_IMPORTED_MODULE_9__["default"].TARGET, this.handleTargetChanged_);

    // setProperties will trigger the rendering of the map if the map
    // is "defined" already.
    this.setProperties(optionsInternal.values);

    const map = this;
    if (options.view && !(options.view instanceof _View_js__WEBPACK_IMPORTED_MODULE_10__["default"])) {
      options.view.then(function (viewOptions) {
        map.setView(new _View_js__WEBPACK_IMPORTED_MODULE_10__["default"](viewOptions));
      });
    }

    this.controls.addEventListener(
      _CollectionEventType_js__WEBPACK_IMPORTED_MODULE_11__["default"].ADD,
      /**
       * @param {import("./Collection.js").CollectionEvent<import("./control/Control.js").default>} event CollectionEvent
       */
      (event) => {
        event.element.setMap(this);
      }
    );

    this.controls.addEventListener(
      _CollectionEventType_js__WEBPACK_IMPORTED_MODULE_11__["default"].REMOVE,
      /**
       * @param {import("./Collection.js").CollectionEvent<import("./control/Control.js").default>} event CollectionEvent.
       */
      (event) => {
        event.element.setMap(null);
      }
    );

    this.interactions.addEventListener(
      _CollectionEventType_js__WEBPACK_IMPORTED_MODULE_11__["default"].ADD,
      /**
       * @param {import("./Collection.js").CollectionEvent<import("./interaction/Interaction.js").default>} event CollectionEvent.
       */
      (event) => {
        event.element.setMap(this);
      }
    );

    this.interactions.addEventListener(
      _CollectionEventType_js__WEBPACK_IMPORTED_MODULE_11__["default"].REMOVE,
      /**
       * @param {import("./Collection.js").CollectionEvent<import("./interaction/Interaction.js").default>} event CollectionEvent.
       */
      (event) => {
        event.element.setMap(null);
      }
    );

    this.overlays_.addEventListener(
      _CollectionEventType_js__WEBPACK_IMPORTED_MODULE_11__["default"].ADD,
      /**
       * @param {import("./Collection.js").CollectionEvent<import("./Overlay.js").default>} event CollectionEvent.
       */
      (event) => {
        this.addOverlayInternal_(event.element);
      }
    );

    this.overlays_.addEventListener(
      _CollectionEventType_js__WEBPACK_IMPORTED_MODULE_11__["default"].REMOVE,
      /**
       * @param {import("./Collection.js").CollectionEvent<import("./Overlay.js").default>} event CollectionEvent.
       */
      (event) => {
        const id = event.element.getId();
        if (id !== undefined) {
          delete this.overlayIdIndex_[id.toString()];
        }
        event.element.setMap(null);
      }
    );

    this.controls.forEach(
      /**
       * @param {import("./control/Control.js").default} control Control.
       */
      (control) => {
        control.setMap(this);
      }
    );

    this.interactions.forEach(
      /**
       * @param {import("./interaction/Interaction.js").default} interaction Interaction.
       */
      (interaction) => {
        interaction.setMap(this);
      }
    );

    this.overlays_.forEach(this.addOverlayInternal_.bind(this));
  }

  /**
   * Add the given control to the map.
   * @param {import("./control/Control.js").default} control Control.
   * @api
   */
  addControl(control) {
    this.getControls().push(control);
  }

  /**
   * Add the given interaction to the map. If you want to add an interaction
   * at another point of the collection use `getInteractions()` and the methods
   * available on {@link module:ol/Collection~Collection}. This can be used to
   * stop the event propagation from the handleEvent function. The interactions
   * get to handle the events in the reverse order of this collection.
   * @param {import("./interaction/Interaction.js").default} interaction Interaction to add.
   * @api
   */
  addInteraction(interaction) {
    this.getInteractions().push(interaction);
  }

  /**
   * Adds the given layer to the top of this map. If you want to add a layer
   * elsewhere in the stack, use `getLayers()` and the methods available on
   * {@link module:ol/Collection~Collection}.
   * @param {import("./layer/Base.js").default} layer Layer.
   * @api
   */
  addLayer(layer) {
    const layers = this.getLayerGroup().getLayers();
    layers.push(layer);
  }

  /**
   * @param {import("./layer/Group.js").GroupEvent} event The layer add event.
   * @private
   */
  handleLayerAdd_(event) {
    setLayerMapProperty(event.layer, this);
  }

  /**
   * Add the given overlay to the map.
   * @param {import("./Overlay.js").default} overlay Overlay.
   * @api
   */
  addOverlay(overlay) {
    this.getOverlays().push(overlay);
  }

  /**
   * This deals with map's overlay collection changes.
   * @param {import("./Overlay.js").default} overlay Overlay.
   * @private
   */
  addOverlayInternal_(overlay) {
    const id = overlay.getId();
    if (id !== undefined) {
      this.overlayIdIndex_[id.toString()] = overlay;
    }
    overlay.setMap(this);
  }

  /**
   *
   * Clean up.
   */
  disposeInternal() {
    this.controls.clear();
    this.interactions.clear();
    this.overlays_.clear();
    this.resizeObserver_.disconnect();
    this.setTarget(null);
    super.disposeInternal();
  }

  /**
   * Detect features that intersect a pixel on the viewport, and execute a
   * callback with each intersecting feature. Layers included in the detection can
   * be configured through the `layerFilter` option in `options`.
   * @param {import("./pixel.js").Pixel} pixel Pixel.
   * @param {function(import("./Feature.js").FeatureLike, import("./layer/Layer.js").default<import("./source/Source").default>, import("./geom/SimpleGeometry.js").default): T} callback Feature callback. The callback will be
   *     called with two arguments. The first argument is one
   *     {@link module:ol/Feature~Feature feature} or
   *     {@link module:ol/render/Feature~RenderFeature render feature} at the pixel, the second is
   *     the {@link module:ol/layer/Layer~Layer layer} of the feature and will be null for
   *     unmanaged layers. To stop detection, callback functions can return a
   *     truthy value.
   * @param {AtPixelOptions} [options] Optional options.
   * @return {T|undefined} Callback result, i.e. the return value of last
   * callback execution, or the first truthy callback return value.
   * @template T
   * @api
   */
  forEachFeatureAtPixel(pixel, callback, options) {
    if (!this.frameState_ || !this.renderer_) {
      return;
    }
    const coordinate = this.getCoordinateFromPixelInternal(pixel);
    options = options !== undefined ? options : {};
    const hitTolerance =
      options.hitTolerance !== undefined ? options.hitTolerance : 0;
    const layerFilter =
      options.layerFilter !== undefined ? options.layerFilter : _functions_js__WEBPACK_IMPORTED_MODULE_12__.TRUE;
    const checkWrapped = options.checkWrapped !== false;
    return this.renderer_.forEachFeatureAtCoordinate(
      coordinate,
      this.frameState_,
      hitTolerance,
      checkWrapped,
      callback,
      null,
      layerFilter,
      null
    );
  }

  /**
   * Get all features that intersect a pixel on the viewport.
   * @param {import("./pixel.js").Pixel} pixel Pixel.
   * @param {AtPixelOptions} [options] Optional options.
   * @return {Array<import("./Feature.js").FeatureLike>} The detected features or
   * an empty array if none were found.
   * @api
   */
  getFeaturesAtPixel(pixel, options) {
    const features = [];
    this.forEachFeatureAtPixel(
      pixel,
      function (feature) {
        features.push(feature);
      },
      options
    );
    return features;
  }

  /**
   * Get all layers from all layer groups.
   * @return {Array<import("./layer/Layer.js").default>} Layers.
   * @api
   */
  getAllLayers() {
    const layers = [];
    function addLayersFrom(layerGroup) {
      layerGroup.forEach(function (layer) {
        if (layer instanceof _layer_Group_js__WEBPACK_IMPORTED_MODULE_2__["default"]) {
          addLayersFrom(layer.getLayers());
        } else {
          layers.push(layer);
        }
      });
    }
    addLayersFrom(this.getLayers());
    return layers;
  }

  /**
   * Detect if features intersect a pixel on the viewport. Layers included in the
   * detection can be configured through the `layerFilter` option.
   * @param {import("./pixel.js").Pixel} pixel Pixel.
   * @param {AtPixelOptions} [options] Optional options.
   * @return {boolean} Is there a feature at the given pixel?
   * @api
   */
  hasFeatureAtPixel(pixel, options) {
    if (!this.frameState_ || !this.renderer_) {
      return false;
    }
    const coordinate = this.getCoordinateFromPixelInternal(pixel);
    options = options !== undefined ? options : {};
    const layerFilter =
      options.layerFilter !== undefined ? options.layerFilter : _functions_js__WEBPACK_IMPORTED_MODULE_12__.TRUE;
    const hitTolerance =
      options.hitTolerance !== undefined ? options.hitTolerance : 0;
    const checkWrapped = options.checkWrapped !== false;
    return this.renderer_.hasFeatureAtCoordinate(
      coordinate,
      this.frameState_,
      hitTolerance,
      checkWrapped,
      layerFilter,
      null
    );
  }

  /**
   * Returns the coordinate in user projection for a browser event.
   * @param {MouseEvent} event Event.
   * @return {import("./coordinate.js").Coordinate} Coordinate.
   * @api
   */
  getEventCoordinate(event) {
    return this.getCoordinateFromPixel(this.getEventPixel(event));
  }

  /**
   * Returns the coordinate in view projection for a browser event.
   * @param {MouseEvent} event Event.
   * @return {import("./coordinate.js").Coordinate} Coordinate.
   */
  getEventCoordinateInternal(event) {
    return this.getCoordinateFromPixelInternal(this.getEventPixel(event));
  }

  /**
   * Returns the map pixel position for a browser event relative to the viewport.
   * @param {UIEvent|{clientX: number, clientY: number}} event Event.
   * @return {import("./pixel.js").Pixel} Pixel.
   * @api
   */
  getEventPixel(event) {
    const viewport = this.viewport_;
    const viewportPosition = viewport.getBoundingClientRect();
    const viewportSize = this.getSize();
    const scaleX = viewportPosition.width / viewportSize[0];
    const scaleY = viewportPosition.height / viewportSize[1];
    const eventPosition =
      //FIXME Are we really calling this with a TouchEvent anywhere?
      'changedTouches' in event
        ? /** @type {TouchEvent} */ (event).changedTouches[0]
        : /** @type {MouseEvent} */ (event);

    return [
      (eventPosition.clientX - viewportPosition.left) / scaleX,
      (eventPosition.clientY - viewportPosition.top) / scaleY,
    ];
  }

  /**
   * Get the target in which this map is rendered.
   * Note that this returns what is entered as an option or in setTarget:
   * if that was an element, it returns an element; if a string, it returns that.
   * @return {HTMLElement|string|undefined} The Element or id of the Element that the
   *     map is rendered in.
   * @observable
   * @api
   */
  getTarget() {
    return /** @type {HTMLElement|string|undefined} */ (
      this.get(_MapProperty_js__WEBPACK_IMPORTED_MODULE_9__["default"].TARGET)
    );
  }

  /**
   * Get the DOM element into which this map is rendered. In contrast to
   * `getTarget` this method always return an `Element`, or `null` if the
   * map has no target.
   * @return {HTMLElement} The element that the map is rendered in.
   * @api
   */
  getTargetElement() {
    return this.targetElement_;
  }

  /**
   * Get the coordinate for a given pixel.  This returns a coordinate in the
   * user projection.
   * @param {import("./pixel.js").Pixel} pixel Pixel position in the map viewport.
   * @return {import("./coordinate.js").Coordinate} The coordinate for the pixel position.
   * @api
   */
  getCoordinateFromPixel(pixel) {
    return (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.toUserCoordinate)(
      this.getCoordinateFromPixelInternal(pixel),
      this.getView().getProjection()
    );
  }

  /**
   * Get the coordinate for a given pixel.  This returns a coordinate in the
   * map view projection.
   * @param {import("./pixel.js").Pixel} pixel Pixel position in the map viewport.
   * @return {import("./coordinate.js").Coordinate} The coordinate for the pixel position.
   */
  getCoordinateFromPixelInternal(pixel) {
    const frameState = this.frameState_;
    if (!frameState) {
      return null;
    }
    return (0,_transform_js__WEBPACK_IMPORTED_MODULE_5__.apply)(frameState.pixelToCoordinateTransform, pixel.slice());
  }

  /**
   * Get the map controls. Modifying this collection changes the controls
   * associated with the map.
   * @return {Collection<import("./control/Control.js").default>} Controls.
   * @api
   */
  getControls() {
    return this.controls;
  }

  /**
   * Get the map overlays. Modifying this collection changes the overlays
   * associated with the map.
   * @return {Collection<import("./Overlay.js").default>} Overlays.
   * @api
   */
  getOverlays() {
    return this.overlays_;
  }

  /**
   * Get an overlay by its identifier (the value returned by overlay.getId()).
   * Note that the index treats string and numeric identifiers as the same. So
   * `map.getOverlayById(2)` will return an overlay with id `'2'` or `2`.
   * @param {string|number} id Overlay identifier.
   * @return {import("./Overlay.js").default} Overlay.
   * @api
   */
  getOverlayById(id) {
    const overlay = this.overlayIdIndex_[id.toString()];
    return overlay !== undefined ? overlay : null;
  }

  /**
   * Get the map interactions. Modifying this collection changes the interactions
   * associated with the map.
   *
   * Interactions are used for e.g. pan, zoom and rotate.
   * @return {Collection<import("./interaction/Interaction.js").default>} Interactions.
   * @api
   */
  getInteractions() {
    return this.interactions;
  }

  /**
   * Get the layergroup associated with this map.
   * @return {LayerGroup} A layer group containing the layers in this map.
   * @observable
   * @api
   */
  getLayerGroup() {
    return /** @type {LayerGroup} */ (this.get(_MapProperty_js__WEBPACK_IMPORTED_MODULE_9__["default"].LAYERGROUP));
  }

  /**
   * Clear any existing layers and add layers to the map.
   * @param {Array<import("./layer/Base.js").default>|Collection<import("./layer/Base.js").default>} layers The layers to be added to the map.
   * @api
   */
  setLayers(layers) {
    const group = this.getLayerGroup();
    if (layers instanceof _Collection_js__WEBPACK_IMPORTED_MODULE_13__["default"]) {
      group.setLayers(layers);
      return;
    }

    const collection = group.getLayers();
    collection.clear();
    collection.extend(layers);
  }

  /**
   * Get the collection of layers associated with this map.
   * @return {!Collection<import("./layer/Base.js").default>} Layers.
   * @api
   */
  getLayers() {
    const layers = this.getLayerGroup().getLayers();
    return layers;
  }

  /**
   * @return {boolean} Layers have sources that are still loading.
   */
  getLoadingOrNotReady() {
    const layerStatesArray = this.getLayerGroup().getLayerStatesArray();
    for (let i = 0, ii = layerStatesArray.length; i < ii; ++i) {
      const state = layerStatesArray[i];
      if (!state.visible) {
        continue;
      }
      const renderer = state.layer.getRenderer();
      if (renderer && !renderer.ready) {
        return true;
      }
      const source = state.layer.getSource();
      if (source && source.loading) {
        return true;
      }
    }
    return false;
  }

  /**
   * Get the pixel for a coordinate.  This takes a coordinate in the user
   * projection and returns the corresponding pixel.
   * @param {import("./coordinate.js").Coordinate} coordinate A map coordinate.
   * @return {import("./pixel.js").Pixel} A pixel position in the map viewport.
   * @api
   */
  getPixelFromCoordinate(coordinate) {
    const viewCoordinate = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.fromUserCoordinate)(
      coordinate,
      this.getView().getProjection()
    );
    return this.getPixelFromCoordinateInternal(viewCoordinate);
  }

  /**
   * Get the pixel for a coordinate.  This takes a coordinate in the map view
   * projection and returns the corresponding pixel.
   * @param {import("./coordinate.js").Coordinate} coordinate A map coordinate.
   * @return {import("./pixel.js").Pixel} A pixel position in the map viewport.
   */
  getPixelFromCoordinateInternal(coordinate) {
    const frameState = this.frameState_;
    if (!frameState) {
      return null;
    }
    return (0,_transform_js__WEBPACK_IMPORTED_MODULE_5__.apply)(
      frameState.coordinateToPixelTransform,
      coordinate.slice(0, 2)
    );
  }

  /**
   * Get the map renderer.
   * @return {import("./renderer/Map.js").default|null} Renderer
   */
  getRenderer() {
    return this.renderer_;
  }

  /**
   * Get the size of this map.
   * @return {import("./size.js").Size|undefined} The size in pixels of the map in the DOM.
   * @observable
   * @api
   */
  getSize() {
    return /** @type {import("./size.js").Size|undefined} */ (
      this.get(_MapProperty_js__WEBPACK_IMPORTED_MODULE_9__["default"].SIZE)
    );
  }

  /**
   * Get the view associated with this map. A view manages properties such as
   * center and resolution.
   * @return {View} The view that controls this map.
   * @observable
   * @api
   */
  getView() {
    return /** @type {View} */ (this.get(_MapProperty_js__WEBPACK_IMPORTED_MODULE_9__["default"].VIEW));
  }

  /**
   * Get the element that serves as the map viewport.
   * @return {HTMLElement} Viewport.
   * @api
   */
  getViewport() {
    return this.viewport_;
  }

  /**
   * Get the element that serves as the container for overlays.  Elements added to
   * this container will let mousedown and touchstart events through to the map,
   * so clicks and gestures on an overlay will trigger {@link module:ol/MapBrowserEvent~MapBrowserEvent}
   * events.
   * @return {!HTMLElement} The map's overlay container.
   */
  getOverlayContainer() {
    return this.overlayContainer_;
  }

  /**
   * Get the element that serves as a container for overlays that don't allow
   * event propagation. Elements added to this container won't let mousedown and
   * touchstart events through to the map, so clicks and gestures on an overlay
   * don't trigger any {@link module:ol/MapBrowserEvent~MapBrowserEvent}.
   * @return {!HTMLElement} The map's overlay container that stops events.
   */
  getOverlayContainerStopEvent() {
    return this.overlayContainerStopEvent_;
  }

  /**
   * @return {!Document} The document where the map is displayed.
   */
  getOwnerDocument() {
    const targetElement = this.getTargetElement();
    return targetElement ? targetElement.ownerDocument : document;
  }

  /**
   * @param {import("./Tile.js").default} tile Tile.
   * @param {string} tileSourceKey Tile source key.
   * @param {import("./coordinate.js").Coordinate} tileCenter Tile center.
   * @param {number} tileResolution Tile resolution.
   * @return {number} Tile priority.
   */
  getTilePriority(tile, tileSourceKey, tileCenter, tileResolution) {
    return (0,_TileQueue_js__WEBPACK_IMPORTED_MODULE_8__.getTilePriority)(
      this.frameState_,
      tile,
      tileSourceKey,
      tileCenter,
      tileResolution
    );
  }

  /**
   * @param {UIEvent} browserEvent Browser event.
   * @param {string} [type] Type.
   */
  handleBrowserEvent(browserEvent, type) {
    type = type || browserEvent.type;
    const mapBrowserEvent = new _MapBrowserEvent_js__WEBPACK_IMPORTED_MODULE_14__["default"](type, this, browserEvent);
    this.handleMapBrowserEvent(mapBrowserEvent);
  }

  /**
   * @param {MapBrowserEvent} mapBrowserEvent The event to handle.
   */
  handleMapBrowserEvent(mapBrowserEvent) {
    if (!this.frameState_) {
      // With no view defined, we cannot translate pixels into geographical
      // coordinates so interactions cannot be used.
      return;
    }
    const originalEvent = /** @type {PointerEvent} */ (
      mapBrowserEvent.originalEvent
    );
    const eventType = originalEvent.type;
    if (
      eventType === _pointer_EventType_js__WEBPACK_IMPORTED_MODULE_15__["default"].POINTERDOWN ||
      eventType === _events_EventType_js__WEBPACK_IMPORTED_MODULE_16__["default"].WHEEL ||
      eventType === _events_EventType_js__WEBPACK_IMPORTED_MODULE_16__["default"].KEYDOWN
    ) {
      const doc = this.getOwnerDocument();
      const rootNode = this.viewport_.getRootNode
        ? this.viewport_.getRootNode()
        : doc;
      const target = /** @type {Node} */ (originalEvent.target);
      if (
        // Abort if the target is a child of the container for elements whose events are not meant
        // to be handled by map interactions.
        this.overlayContainerStopEvent_.contains(target) ||
        // Abort if the event target is a child of the container that is no longer in the page.
        // It's possible for the target to no longer be in the page if it has been removed in an
        // event listener, this might happen in a Control that recreates it's content based on
        // user interaction either manually or via a render in something like https://reactjs.org/
        !(rootNode === doc ? doc.documentElement : rootNode).contains(target)
      ) {
        return;
      }
    }
    mapBrowserEvent.frameState = this.frameState_;
    if (this.dispatchEvent(mapBrowserEvent) !== false) {
      const interactionsArray = this.getInteractions().getArray().slice();
      for (let i = interactionsArray.length - 1; i >= 0; i--) {
        const interaction = interactionsArray[i];
        if (
          interaction.getMap() !== this ||
          !interaction.getActive() ||
          !this.getTargetElement()
        ) {
          continue;
        }
        const cont = interaction.handleEvent(mapBrowserEvent);
        if (!cont || mapBrowserEvent.propagationStopped) {
          break;
        }
      }
    }
  }

  /**
   * @protected
   */
  handlePostRender() {
    const frameState = this.frameState_;

    // Manage the tile queue
    // Image loads are expensive and a limited resource, so try to use them
    // efficiently:
    // * When the view is static we allow a large number of parallel tile loads
    //   to complete the frame as quickly as possible.
    // * When animating or interacting, image loads can cause janks, so we reduce
    //   the maximum number of loads per frame and limit the number of parallel
    //   tile loads to remain reactive to view changes and to reduce the chance of
    //   loading tiles that will quickly disappear from view.
    const tileQueue = this.tileQueue_;
    if (!tileQueue.isEmpty()) {
      let maxTotalLoading = this.maxTilesLoading_;
      let maxNewLoads = maxTotalLoading;
      if (frameState) {
        const hints = frameState.viewHints;
        if (hints[_ViewHint_js__WEBPACK_IMPORTED_MODULE_17__["default"].ANIMATING] || hints[_ViewHint_js__WEBPACK_IMPORTED_MODULE_17__["default"].INTERACTING]) {
          const lowOnFrameBudget = Date.now() - frameState.time > 8;
          maxTotalLoading = lowOnFrameBudget ? 0 : 8;
          maxNewLoads = lowOnFrameBudget ? 0 : 2;
        }
      }
      if (tileQueue.getTilesLoading() < maxTotalLoading) {
        tileQueue.reprioritize(); // FIXME only call if view has changed
        tileQueue.loadMoreTiles(maxTotalLoading, maxNewLoads);
      }
    }

    if (frameState && this.renderer_ && !frameState.animate) {
      if (this.renderComplete_ === true) {
        if (this.hasListener(_render_EventType_js__WEBPACK_IMPORTED_MODULE_18__["default"].RENDERCOMPLETE)) {
          this.renderer_.dispatchRenderEvent(
            _render_EventType_js__WEBPACK_IMPORTED_MODULE_18__["default"].RENDERCOMPLETE,
            frameState
          );
        }
        if (this.loaded_ === false) {
          this.loaded_ = true;
          this.dispatchEvent(
            new _MapEvent_js__WEBPACK_IMPORTED_MODULE_19__["default"](_MapEventType_js__WEBPACK_IMPORTED_MODULE_20__["default"].LOADEND, this, frameState)
          );
        }
      } else if (this.loaded_ === true) {
        this.loaded_ = false;
        this.dispatchEvent(
          new _MapEvent_js__WEBPACK_IMPORTED_MODULE_19__["default"](_MapEventType_js__WEBPACK_IMPORTED_MODULE_20__["default"].LOADSTART, this, frameState)
        );
      }
    }

    const postRenderFunctions = this.postRenderFunctions_;
    for (let i = 0, ii = postRenderFunctions.length; i < ii; ++i) {
      postRenderFunctions[i](this, frameState);
    }
    postRenderFunctions.length = 0;
  }

  /**
   * @private
   */
  handleSizeChanged_() {
    if (this.getView() && !this.getView().getAnimating()) {
      this.getView().resolveConstraints(0);
    }

    this.render();
  }

  /**
   * @private
   */
  handleTargetChanged_() {
    if (this.mapBrowserEventHandler_) {
      for (let i = 0, ii = this.targetChangeHandlerKeys_.length; i < ii; ++i) {
        (0,_events_js__WEBPACK_IMPORTED_MODULE_21__.unlistenByKey)(this.targetChangeHandlerKeys_[i]);
      }
      this.targetChangeHandlerKeys_ = null;
      this.viewport_.removeEventListener(
        _events_EventType_js__WEBPACK_IMPORTED_MODULE_16__["default"].CONTEXTMENU,
        this.boundHandleBrowserEvent_
      );
      this.viewport_.removeEventListener(
        _events_EventType_js__WEBPACK_IMPORTED_MODULE_16__["default"].WHEEL,
        this.boundHandleBrowserEvent_
      );
      this.mapBrowserEventHandler_.dispose();
      this.mapBrowserEventHandler_ = null;
      (0,_dom_js__WEBPACK_IMPORTED_MODULE_22__.removeNode)(this.viewport_);
    }

    if (this.targetElement_) {
      this.resizeObserver_.unobserve(this.targetElement_);
      const rootNode = this.targetElement_.getRootNode();
      if (rootNode instanceof ShadowRoot) {
        this.resizeObserver_.unobserve(rootNode.host);
      }
      this.setSize(undefined);
    }

    // target may be undefined, null, a string or an Element.
    // If it's a string we convert it to an Element before proceeding.
    // If it's not now an Element we remove the viewport from the DOM.
    // If it's an Element we append the viewport element to it.

    const target = this.getTarget();
    const targetElement =
      typeof target === 'string' ? document.getElementById(target) : target;
    this.targetElement_ = targetElement;
    if (!targetElement) {
      if (this.renderer_) {
        clearTimeout(this.postRenderTimeoutHandle_);
        this.postRenderTimeoutHandle_ = undefined;
        this.postRenderFunctions_.length = 0;
        this.renderer_.dispose();
        this.renderer_ = null;
      }
      if (this.animationDelayKey_) {
        cancelAnimationFrame(this.animationDelayKey_);
        this.animationDelayKey_ = undefined;
      }
    } else {
      targetElement.appendChild(this.viewport_);
      if (!this.renderer_) {
        this.renderer_ = new _renderer_Composite_js__WEBPACK_IMPORTED_MODULE_23__["default"](this);
      }

      this.mapBrowserEventHandler_ = new _MapBrowserEventHandler_js__WEBPACK_IMPORTED_MODULE_24__["default"](
        this,
        this.moveTolerance_
      );
      for (const key in _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_25__["default"]) {
        this.mapBrowserEventHandler_.addEventListener(
          _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_25__["default"][key],
          this.handleMapBrowserEvent.bind(this)
        );
      }
      this.viewport_.addEventListener(
        _events_EventType_js__WEBPACK_IMPORTED_MODULE_16__["default"].CONTEXTMENU,
        this.boundHandleBrowserEvent_,
        false
      );
      this.viewport_.addEventListener(
        _events_EventType_js__WEBPACK_IMPORTED_MODULE_16__["default"].WHEEL,
        this.boundHandleBrowserEvent_,
        _has_js__WEBPACK_IMPORTED_MODULE_4__.PASSIVE_EVENT_LISTENERS ? {passive: false} : false
      );

      const keyboardEventTarget = !this.keyboardEventTarget_
        ? targetElement
        : this.keyboardEventTarget_;
      this.targetChangeHandlerKeys_ = [
        (0,_events_js__WEBPACK_IMPORTED_MODULE_21__.listen)(
          keyboardEventTarget,
          _events_EventType_js__WEBPACK_IMPORTED_MODULE_16__["default"].KEYDOWN,
          this.handleBrowserEvent,
          this
        ),
        (0,_events_js__WEBPACK_IMPORTED_MODULE_21__.listen)(
          keyboardEventTarget,
          _events_EventType_js__WEBPACK_IMPORTED_MODULE_16__["default"].KEYPRESS,
          this.handleBrowserEvent,
          this
        ),
      ];
      const rootNode = targetElement.getRootNode();
      if (rootNode instanceof ShadowRoot) {
        this.resizeObserver_.observe(rootNode.host);
      }
      this.resizeObserver_.observe(targetElement);
    }

    this.updateSize();
    // updateSize calls setSize, so no need to call this.render
    // ourselves here.
  }

  /**
   * @private
   */
  handleTileChange_() {
    this.render();
  }

  /**
   * @private
   */
  handleViewPropertyChanged_() {
    this.render();
  }

  /**
   * @private
   */
  handleViewChanged_() {
    if (this.viewPropertyListenerKey_) {
      (0,_events_js__WEBPACK_IMPORTED_MODULE_21__.unlistenByKey)(this.viewPropertyListenerKey_);
      this.viewPropertyListenerKey_ = null;
    }
    if (this.viewChangeListenerKey_) {
      (0,_events_js__WEBPACK_IMPORTED_MODULE_21__.unlistenByKey)(this.viewChangeListenerKey_);
      this.viewChangeListenerKey_ = null;
    }
    const view = this.getView();
    if (view) {
      this.updateViewportSize_();

      this.viewPropertyListenerKey_ = (0,_events_js__WEBPACK_IMPORTED_MODULE_21__.listen)(
        view,
        _ObjectEventType_js__WEBPACK_IMPORTED_MODULE_26__["default"].PROPERTYCHANGE,
        this.handleViewPropertyChanged_,
        this
      );
      this.viewChangeListenerKey_ = (0,_events_js__WEBPACK_IMPORTED_MODULE_21__.listen)(
        view,
        _events_EventType_js__WEBPACK_IMPORTED_MODULE_16__["default"].CHANGE,
        this.handleViewPropertyChanged_,
        this
      );

      view.resolveConstraints(0);
    }
    this.render();
  }

  /**
   * @private
   */
  handleLayerGroupChanged_() {
    if (this.layerGroupPropertyListenerKeys_) {
      this.layerGroupPropertyListenerKeys_.forEach(_events_js__WEBPACK_IMPORTED_MODULE_21__.unlistenByKey);
      this.layerGroupPropertyListenerKeys_ = null;
    }
    const layerGroup = this.getLayerGroup();
    if (layerGroup) {
      this.handleLayerAdd_(new _layer_Group_js__WEBPACK_IMPORTED_MODULE_2__.GroupEvent('addlayer', layerGroup));
      this.layerGroupPropertyListenerKeys_ = [
        (0,_events_js__WEBPACK_IMPORTED_MODULE_21__.listen)(layerGroup, _ObjectEventType_js__WEBPACK_IMPORTED_MODULE_26__["default"].PROPERTYCHANGE, this.render, this),
        (0,_events_js__WEBPACK_IMPORTED_MODULE_21__.listen)(layerGroup, _events_EventType_js__WEBPACK_IMPORTED_MODULE_16__["default"].CHANGE, this.render, this),
        (0,_events_js__WEBPACK_IMPORTED_MODULE_21__.listen)(layerGroup, 'addlayer', this.handleLayerAdd_, this),
        (0,_events_js__WEBPACK_IMPORTED_MODULE_21__.listen)(layerGroup, 'removelayer', this.handleLayerRemove_, this),
      ];
    }
    this.render();
  }

  /**
   * @return {boolean} Is rendered.
   */
  isRendered() {
    return !!this.frameState_;
  }

  /**
   * @private
   */
  animationDelay_() {
    this.animationDelayKey_ = undefined;
    this.renderFrame_(Date.now());
  }

  /**
   * Requests an immediate render in a synchronous manner.
   * @api
   */
  renderSync() {
    if (this.animationDelayKey_) {
      cancelAnimationFrame(this.animationDelayKey_);
    }
    this.animationDelay_();
  }

  /**
   * Redraws all text after new fonts have loaded
   */
  redrawText() {
    const layerStates = this.getLayerGroup().getLayerStatesArray();
    for (let i = 0, ii = layerStates.length; i < ii; ++i) {
      const layer = layerStates[i].layer;
      if (layer.hasRenderer()) {
        layer.getRenderer().handleFontsChanged();
      }
    }
  }

  /**
   * Request a map rendering (at the next animation frame).
   * @api
   */
  render() {
    if (this.renderer_ && this.animationDelayKey_ === undefined) {
      this.animationDelayKey_ = requestAnimationFrame(this.animationDelay_);
    }
  }

  /**
   * This method is meant to be called in a layer's `prerender` listener. It causes all collected
   * declutter items to be decluttered and rendered on the map immediately. This is useful for
   * layers that need to appear entirely above the decluttered items of layers lower in the layer
   * stack.
   * @api
   */
  flushDeclutterItems() {
    const frameState = this.frameState_;
    if (!frameState) {
      return;
    }
    this.renderer_.flushDeclutterItems(frameState);
  }

  /**
   * Remove the given control from the map.
   * @param {import("./control/Control.js").default} control Control.
   * @return {import("./control/Control.js").default|undefined} The removed control (or undefined
   *     if the control was not found).
   * @api
   */
  removeControl(control) {
    return this.getControls().remove(control);
  }

  /**
   * Remove the given interaction from the map.
   * @param {import("./interaction/Interaction.js").default} interaction Interaction to remove.
   * @return {import("./interaction/Interaction.js").default|undefined} The removed interaction (or
   *     undefined if the interaction was not found).
   * @api
   */
  removeInteraction(interaction) {
    return this.getInteractions().remove(interaction);
  }

  /**
   * Removes the given layer from the map.
   * @param {import("./layer/Base.js").default} layer Layer.
   * @return {import("./layer/Base.js").default|undefined} The removed layer (or undefined if the
   *     layer was not found).
   * @api
   */
  removeLayer(layer) {
    const layers = this.getLayerGroup().getLayers();
    return layers.remove(layer);
  }

  /**
   * @param {import("./layer/Group.js").GroupEvent} event The layer remove event.
   * @private
   */
  handleLayerRemove_(event) {
    removeLayerMapProperty(event.layer);
  }

  /**
   * Remove the given overlay from the map.
   * @param {import("./Overlay.js").default} overlay Overlay.
   * @return {import("./Overlay.js").default|undefined} The removed overlay (or undefined
   *     if the overlay was not found).
   * @api
   */
  removeOverlay(overlay) {
    return this.getOverlays().remove(overlay);
  }

  /**
   * @param {number} time Time.
   * @private
   */
  renderFrame_(time) {
    const size = this.getSize();
    const view = this.getView();
    const previousFrameState = this.frameState_;
    /** @type {?FrameState} */
    let frameState = null;
    if (size !== undefined && (0,_size_js__WEBPACK_IMPORTED_MODULE_27__.hasArea)(size) && view && view.isDef()) {
      const viewHints = view.getHints(
        this.frameState_ ? this.frameState_.viewHints : undefined
      );
      const viewState = view.getState();
      frameState = {
        animate: false,
        coordinateToPixelTransform: this.coordinateToPixelTransform_,
        declutterTree: null,
        extent: (0,_extent_js__WEBPACK_IMPORTED_MODULE_28__.getForViewAndSize)(
          viewState.center,
          viewState.resolution,
          viewState.rotation,
          size
        ),
        index: this.frameIndex_++,
        layerIndex: 0,
        layerStatesArray: this.getLayerGroup().getLayerStatesArray(),
        pixelRatio: this.pixelRatio_,
        pixelToCoordinateTransform: this.pixelToCoordinateTransform_,
        postRenderFunctions: [],
        size: size,
        tileQueue: this.tileQueue_,
        time: time,
        usedTiles: {},
        viewState: viewState,
        viewHints: viewHints,
        wantedTiles: {},
        mapId: (0,_util_js__WEBPACK_IMPORTED_MODULE_29__.getUid)(this),
        renderTargets: {},
      };
      if (viewState.nextCenter && viewState.nextResolution) {
        const rotation = isNaN(viewState.nextRotation)
          ? viewState.rotation
          : viewState.nextRotation;

        frameState.nextExtent = (0,_extent_js__WEBPACK_IMPORTED_MODULE_28__.getForViewAndSize)(
          viewState.nextCenter,
          viewState.nextResolution,
          rotation,
          size
        );
      }
    }

    this.frameState_ = frameState;
    this.renderer_.renderFrame(frameState);

    if (frameState) {
      if (frameState.animate) {
        this.render();
      }
      Array.prototype.push.apply(
        this.postRenderFunctions_,
        frameState.postRenderFunctions
      );

      if (previousFrameState) {
        const moveStart =
          !this.previousExtent_ ||
          (!(0,_extent_js__WEBPACK_IMPORTED_MODULE_28__.isEmpty)(this.previousExtent_) &&
            !(0,_extent_js__WEBPACK_IMPORTED_MODULE_28__.equals)(frameState.extent, this.previousExtent_));
        if (moveStart) {
          this.dispatchEvent(
            new _MapEvent_js__WEBPACK_IMPORTED_MODULE_19__["default"](_MapEventType_js__WEBPACK_IMPORTED_MODULE_20__["default"].MOVESTART, this, previousFrameState)
          );
          this.previousExtent_ = (0,_extent_js__WEBPACK_IMPORTED_MODULE_28__.createOrUpdateEmpty)(this.previousExtent_);
        }
      }

      const idle =
        this.previousExtent_ &&
        !frameState.viewHints[_ViewHint_js__WEBPACK_IMPORTED_MODULE_17__["default"].ANIMATING] &&
        !frameState.viewHints[_ViewHint_js__WEBPACK_IMPORTED_MODULE_17__["default"].INTERACTING] &&
        !(0,_extent_js__WEBPACK_IMPORTED_MODULE_28__.equals)(frameState.extent, this.previousExtent_);

      if (idle) {
        this.dispatchEvent(
          new _MapEvent_js__WEBPACK_IMPORTED_MODULE_19__["default"](_MapEventType_js__WEBPACK_IMPORTED_MODULE_20__["default"].MOVEEND, this, frameState)
        );
        (0,_extent_js__WEBPACK_IMPORTED_MODULE_28__.clone)(frameState.extent, this.previousExtent_);
      }
    }

    this.dispatchEvent(new _MapEvent_js__WEBPACK_IMPORTED_MODULE_19__["default"](_MapEventType_js__WEBPACK_IMPORTED_MODULE_20__["default"].POSTRENDER, this, frameState));

    this.renderComplete_ =
      this.hasListener(_MapEventType_js__WEBPACK_IMPORTED_MODULE_20__["default"].LOADSTART) ||
      this.hasListener(_MapEventType_js__WEBPACK_IMPORTED_MODULE_20__["default"].LOADEND) ||
      this.hasListener(_render_EventType_js__WEBPACK_IMPORTED_MODULE_18__["default"].RENDERCOMPLETE)
        ? !this.tileQueue_.getTilesLoading() &&
          !this.tileQueue_.getCount() &&
          !this.getLoadingOrNotReady()
        : undefined;

    if (!this.postRenderTimeoutHandle_) {
      this.postRenderTimeoutHandle_ = setTimeout(() => {
        this.postRenderTimeoutHandle_ = undefined;
        this.handlePostRender();
      }, 0);
    }
  }

  /**
   * Sets the layergroup of this map.
   * @param {LayerGroup} layerGroup A layer group containing the layers in this map.
   * @observable
   * @api
   */
  setLayerGroup(layerGroup) {
    const oldLayerGroup = this.getLayerGroup();
    if (oldLayerGroup) {
      this.handleLayerRemove_(new _layer_Group_js__WEBPACK_IMPORTED_MODULE_2__.GroupEvent('removelayer', oldLayerGroup));
    }
    this.set(_MapProperty_js__WEBPACK_IMPORTED_MODULE_9__["default"].LAYERGROUP, layerGroup);
  }

  /**
   * Set the size of this map.
   * @param {import("./size.js").Size|undefined} size The size in pixels of the map in the DOM.
   * @observable
   * @api
   */
  setSize(size) {
    this.set(_MapProperty_js__WEBPACK_IMPORTED_MODULE_9__["default"].SIZE, size);
  }

  /**
   * Set the target element to render this map into.
   * @param {HTMLElement|string} [target] The Element or id of the Element
   *     that the map is rendered in.
   * @observable
   * @api
   */
  setTarget(target) {
    this.set(_MapProperty_js__WEBPACK_IMPORTED_MODULE_9__["default"].TARGET, target);
  }

  /**
   * Set the view for this map.
   * @param {View|Promise<import("./View.js").ViewOptions>} view The view that controls this map.
   * It is also possible to pass a promise that resolves to options for constructing a view.  This
   * alternative allows view properties to be resolved by sources or other components that load
   * view-related metadata.
   * @observable
   * @api
   */
  setView(view) {
    if (!view || view instanceof _View_js__WEBPACK_IMPORTED_MODULE_10__["default"]) {
      this.set(_MapProperty_js__WEBPACK_IMPORTED_MODULE_9__["default"].VIEW, view);
      return;
    }
    this.set(_MapProperty_js__WEBPACK_IMPORTED_MODULE_9__["default"].VIEW, new _View_js__WEBPACK_IMPORTED_MODULE_10__["default"]());

    const map = this;
    view.then(function (viewOptions) {
      map.setView(new _View_js__WEBPACK_IMPORTED_MODULE_10__["default"](viewOptions));
    });
  }

  /**
   * Force a recalculation of the map viewport size.  This should be called when
   * third-party code changes the size of the map viewport.
   * @api
   */
  updateSize() {
    const targetElement = this.getTargetElement();

    let size = undefined;
    if (targetElement) {
      const computedStyle = getComputedStyle(targetElement);
      const width =
        targetElement.offsetWidth -
        parseFloat(computedStyle['borderLeftWidth']) -
        parseFloat(computedStyle['paddingLeft']) -
        parseFloat(computedStyle['paddingRight']) -
        parseFloat(computedStyle['borderRightWidth']);
      const height =
        targetElement.offsetHeight -
        parseFloat(computedStyle['borderTopWidth']) -
        parseFloat(computedStyle['paddingTop']) -
        parseFloat(computedStyle['paddingBottom']) -
        parseFloat(computedStyle['borderBottomWidth']);
      if (!isNaN(width) && !isNaN(height)) {
        size = [width, height];
        if (
          !(0,_size_js__WEBPACK_IMPORTED_MODULE_27__.hasArea)(size) &&
          !!(
            targetElement.offsetWidth ||
            targetElement.offsetHeight ||
            targetElement.getClientRects().length
          )
        ) {
          (0,_console_js__WEBPACK_IMPORTED_MODULE_30__.warn)(
            "No map visible because the map container's width or height are 0."
          );
        }
      }
    }

    const oldSize = this.getSize();
    if (size && (!oldSize || !(0,_array_js__WEBPACK_IMPORTED_MODULE_31__.equals)(size, oldSize))) {
      this.setSize(size);
      this.updateViewportSize_();
    }
  }

  /**
   * Recomputes the viewport size and save it on the view object (if any)
   * @private
   */
  updateViewportSize_() {
    const view = this.getView();
    if (view) {
      let size = undefined;
      const computedStyle = getComputedStyle(this.viewport_);
      if (computedStyle.width && computedStyle.height) {
        size = [
          parseInt(computedStyle.width, 10),
          parseInt(computedStyle.height, 10),
        ];
      }
      view.setViewportSize(size);
    }
  }
}

/**
 * @param {MapOptions} options Map options.
 * @return {MapOptionsInternal} Internal map options.
 */
function createOptionsInternal(options) {
  /**
   * @type {HTMLElement|Document}
   */
  let keyboardEventTarget = null;
  if (options.keyboardEventTarget !== undefined) {
    keyboardEventTarget =
      typeof options.keyboardEventTarget === 'string'
        ? document.getElementById(options.keyboardEventTarget)
        : options.keyboardEventTarget;
  }

  /**
   * @type {Object<string, *>}
   */
  const values = {};

  const layerGroup =
    options.layers &&
    typeof (/** @type {?} */ (options.layers).getLayers) === 'function'
      ? /** @type {LayerGroup} */ (options.layers)
      : new _layer_Group_js__WEBPACK_IMPORTED_MODULE_2__["default"]({
          layers:
            /** @type {Collection<import("./layer/Base.js").default>|Array<import("./layer/Base.js").default>} */ (
              options.layers
            ),
        });
  values[_MapProperty_js__WEBPACK_IMPORTED_MODULE_9__["default"].LAYERGROUP] = layerGroup;

  values[_MapProperty_js__WEBPACK_IMPORTED_MODULE_9__["default"].TARGET] = options.target;

  values[_MapProperty_js__WEBPACK_IMPORTED_MODULE_9__["default"].VIEW] =
    options.view instanceof _View_js__WEBPACK_IMPORTED_MODULE_10__["default"] ? options.view : new _View_js__WEBPACK_IMPORTED_MODULE_10__["default"]();

  /** @type {Collection<import("./control/Control.js").default>} */
  let controls;
  if (options.controls !== undefined) {
    if (Array.isArray(options.controls)) {
      controls = new _Collection_js__WEBPACK_IMPORTED_MODULE_13__["default"](options.controls.slice());
    } else {
      (0,_asserts_js__WEBPACK_IMPORTED_MODULE_32__.assert)(
        typeof (/** @type {?} */ (options.controls).getArray) === 'function',
        'Expected `controls` to be an array or an `ol/Collection.js`'
      );
      controls = options.controls;
    }
  }

  /** @type {Collection<import("./interaction/Interaction").default>} */
  let interactions;
  if (options.interactions !== undefined) {
    if (Array.isArray(options.interactions)) {
      interactions = new _Collection_js__WEBPACK_IMPORTED_MODULE_13__["default"](options.interactions.slice());
    } else {
      (0,_asserts_js__WEBPACK_IMPORTED_MODULE_32__.assert)(
        typeof (/** @type {?} */ (options.interactions).getArray) ===
          'function',
        'Expected `interactions` to be an array or an `ol/Collection.js`'
      );
      interactions = options.interactions;
    }
  }

  /** @type {Collection<import("./Overlay.js").default>} */
  let overlays;
  if (options.overlays !== undefined) {
    if (Array.isArray(options.overlays)) {
      overlays = new _Collection_js__WEBPACK_IMPORTED_MODULE_13__["default"](options.overlays.slice());
    } else {
      (0,_asserts_js__WEBPACK_IMPORTED_MODULE_32__.assert)(
        typeof (/** @type {?} */ (options.overlays).getArray) === 'function',
        'Expected `overlays` to be an array or an `ol/Collection.js`'
      );
      overlays = options.overlays;
    }
  } else {
    overlays = new _Collection_js__WEBPACK_IMPORTED_MODULE_13__["default"]();
  }

  return {
    controls: controls,
    interactions: interactions,
    keyboardEventTarget: keyboardEventTarget,
    overlays: overlays,
    values: values,
  };
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Map);


/***/ }),

/***/ "./node_modules/ol/MapBrowserEvent.js":
/*!********************************************!*\
  !*** ./node_modules/ol/MapBrowserEvent.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _MapEvent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./MapEvent.js */ "./node_modules/ol/MapEvent.js");
/**
 * @module ol/MapBrowserEvent
 */


/**
 * @classdesc
 * Events emitted as map browser events are instances of this type.
 * See {@link module:ol/Map~Map} for which events trigger a map browser event.
 * @template {UIEvent} EVENT
 */
class MapBrowserEvent extends _MapEvent_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {string} type Event type.
   * @param {import("./Map.js").default} map Map.
   * @param {EVENT} originalEvent Original event.
   * @param {boolean} [dragging] Is the map currently being dragged?
   * @param {import("./Map.js").FrameState} [frameState] Frame state.
   * @param {Array<PointerEvent>} [activePointers] Active pointers.
   */
  constructor(type, map, originalEvent, dragging, frameState, activePointers) {
    super(type, map, frameState);

    /**
     * The original browser event.
     * @const
     * @type {EVENT}
     * @api
     */
    this.originalEvent = originalEvent;

    /**
     * The map pixel relative to the viewport corresponding to the original browser event.
     * @type {?import("./pixel.js").Pixel}
     */
    this.pixel_ = null;

    /**
     * The coordinate in the user projection corresponding to the original browser event.
     * @type {?import("./coordinate.js").Coordinate}
     */
    this.coordinate_ = null;

    /**
     * Indicates if the map is currently being dragged. Only set for
     * `POINTERDRAG` and `POINTERMOVE` events. Default is `false`.
     *
     * @type {boolean}
     * @api
     */
    this.dragging = dragging !== undefined ? dragging : false;

    /**
     * @type {Array<PointerEvent>|undefined}
     */
    this.activePointers = activePointers;
  }

  /**
   * The map pixel relative to the viewport corresponding to the original event.
   * @type {import("./pixel.js").Pixel}
   * @api
   */
  get pixel() {
    if (!this.pixel_) {
      this.pixel_ = this.map.getEventPixel(this.originalEvent);
    }
    return this.pixel_;
  }
  set pixel(pixel) {
    this.pixel_ = pixel;
  }

  /**
   * The coordinate corresponding to the original browser event.  This will be in the user
   * projection if one is set.  Otherwise it will be in the view projection.
   * @type {import("./coordinate.js").Coordinate}
   * @api
   */
  get coordinate() {
    if (!this.coordinate_) {
      this.coordinate_ = this.map.getCoordinateFromPixel(this.pixel);
    }
    return this.coordinate_;
  }
  set coordinate(coordinate) {
    this.coordinate_ = coordinate;
  }

  /**
   * Prevents the default browser action.
   * See https://developer.mozilla.org/en-US/docs/Web/API/event.preventDefault.
   * @api
   */
  preventDefault() {
    super.preventDefault();
    if ('preventDefault' in this.originalEvent) {
      /** @type {UIEvent} */ (this.originalEvent).preventDefault();
    }
  }

  /**
   * Prevents further propagation of the current event.
   * See https://developer.mozilla.org/en-US/docs/Web/API/event.stopPropagation.
   * @api
   */
  stopPropagation() {
    super.stopPropagation();
    if ('stopPropagation' in this.originalEvent) {
      /** @type {UIEvent} */ (this.originalEvent).stopPropagation();
    }
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (MapBrowserEvent);


/***/ }),

/***/ "./node_modules/ol/MapBrowserEventHandler.js":
/*!***************************************************!*\
  !*** ./node_modules/ol/MapBrowserEventHandler.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./events/EventType.js */ "./node_modules/ol/events/EventType.js");
/* harmony import */ var _MapBrowserEvent_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./MapBrowserEvent.js */ "./node_modules/ol/MapBrowserEvent.js");
/* harmony import */ var _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./MapBrowserEventType.js */ "./node_modules/ol/MapBrowserEventType.js");
/* harmony import */ var _pointer_EventType_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./pointer/EventType.js */ "./node_modules/ol/pointer/EventType.js");
/* harmony import */ var _events_Target_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./events/Target.js */ "./node_modules/ol/events/Target.js");
/* harmony import */ var _has_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./has.js */ "./node_modules/ol/has.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./events.js */ "./node_modules/ol/events.js");
/**
 * @module ol/MapBrowserEventHandler
 */









class MapBrowserEventHandler extends _events_Target_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {import("./Map.js").default} map The map with the viewport to listen to events on.
   * @param {number} [moveTolerance] The minimal distance the pointer must travel to trigger a move.
   */
  constructor(map, moveTolerance) {
    super(map);

    /**
     * This is the element that we will listen to the real events on.
     * @type {import("./Map.js").default}
     * @private
     */
    this.map_ = map;

    /**
     * @type {ReturnType<typeof setTimeout>}
     * @private
     */
    this.clickTimeoutId_;

    /**
     * Emulate dblclick and singleclick. Will be true when only one pointer is active.
     * @type {boolean}
     */
    this.emulateClicks_ = false;

    /**
     * @type {boolean}
     * @private
     */
    this.dragging_ = false;

    /**
     * @type {!Array<import("./events.js").EventsKey>}
     * @private
     */
    this.dragListenerKeys_ = [];

    /**
     * @type {number}
     * @private
     */
    this.moveTolerance_ = moveTolerance === undefined ? 1 : moveTolerance;

    /**
     * The most recent "down" type event (or null if none have occurred).
     * Set on pointerdown.
     * @type {PointerEvent|null}
     * @private
     */
    this.down_ = null;

    const element = this.map_.getViewport();

    /**
     * @type {Array<PointerEvent>}
     * @private
     */
    this.activePointers_ = [];

    /**
     * @type {!Object<number, Event>}
     * @private
     */
    this.trackedTouches_ = {};

    this.element_ = element;

    /**
     * @type {?import("./events.js").EventsKey}
     * @private
     */
    this.pointerdownListenerKey_ = (0,_events_js__WEBPACK_IMPORTED_MODULE_1__.listen)(
      element,
      _pointer_EventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].POINTERDOWN,
      this.handlePointerDown_,
      this
    );

    /**
     * @type {PointerEvent}
     * @private
     */
    this.originalPointerMoveEvent_;

    /**
     * @type {?import("./events.js").EventsKey}
     * @private
     */
    this.relayedListenerKey_ = (0,_events_js__WEBPACK_IMPORTED_MODULE_1__.listen)(
      element,
      _pointer_EventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].POINTERMOVE,
      this.relayMoveEvent_,
      this
    );

    /**
     * @private
     */
    this.boundHandleTouchMove_ = this.handleTouchMove_.bind(this);

    this.element_.addEventListener(
      _events_EventType_js__WEBPACK_IMPORTED_MODULE_3__["default"].TOUCHMOVE,
      this.boundHandleTouchMove_,
      _has_js__WEBPACK_IMPORTED_MODULE_4__.PASSIVE_EVENT_LISTENERS ? {passive: false} : false
    );
  }

  /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */
  emulateClick_(pointerEvent) {
    let newEvent = new _MapBrowserEvent_js__WEBPACK_IMPORTED_MODULE_5__["default"](
      _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_6__["default"].CLICK,
      this.map_,
      pointerEvent
    );
    this.dispatchEvent(newEvent);
    if (this.clickTimeoutId_ !== undefined) {
      // double-click
      clearTimeout(this.clickTimeoutId_);
      this.clickTimeoutId_ = undefined;
      newEvent = new _MapBrowserEvent_js__WEBPACK_IMPORTED_MODULE_5__["default"](
        _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_6__["default"].DBLCLICK,
        this.map_,
        pointerEvent
      );
      this.dispatchEvent(newEvent);
    } else {
      // click
      this.clickTimeoutId_ = setTimeout(() => {
        this.clickTimeoutId_ = undefined;
        const newEvent = new _MapBrowserEvent_js__WEBPACK_IMPORTED_MODULE_5__["default"](
          _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_6__["default"].SINGLECLICK,
          this.map_,
          pointerEvent
        );
        this.dispatchEvent(newEvent);
      }, 250);
    }
  }

  /**
   * Keeps track on how many pointers are currently active.
   *
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */
  updateActivePointers_(pointerEvent) {
    const event = pointerEvent;
    const id = event.pointerId;

    if (
      event.type == _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_6__["default"].POINTERUP ||
      event.type == _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_6__["default"].POINTERCANCEL
    ) {
      delete this.trackedTouches_[id];
      for (const pointerId in this.trackedTouches_) {
        if (this.trackedTouches_[pointerId].target !== event.target) {
          // Some platforms assign a new pointerId when the target changes.
          // If this happens, delete one tracked pointer. If there is more
          // than one tracked pointer for the old target, it will be cleared
          // by subsequent POINTERUP events from other pointers.
          delete this.trackedTouches_[pointerId];
          break;
        }
      }
    } else if (
      event.type == _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_6__["default"].POINTERDOWN ||
      event.type == _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_6__["default"].POINTERMOVE
    ) {
      this.trackedTouches_[id] = event;
    }
    this.activePointers_ = Object.values(this.trackedTouches_);
  }

  /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */
  handlePointerUp_(pointerEvent) {
    this.updateActivePointers_(pointerEvent);
    const newEvent = new _MapBrowserEvent_js__WEBPACK_IMPORTED_MODULE_5__["default"](
      _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_6__["default"].POINTERUP,
      this.map_,
      pointerEvent,
      undefined,
      undefined,
      this.activePointers_
    );
    this.dispatchEvent(newEvent);

    // We emulate click events on left mouse button click, touch contact, and pen
    // contact. isMouseActionButton returns true in these cases (evt.button is set
    // to 0).
    // See http://www.w3.org/TR/pointerevents/#button-states
    // We only fire click, singleclick, and doubleclick if nobody has called
    // event.preventDefault().
    if (
      this.emulateClicks_ &&
      !newEvent.defaultPrevented &&
      !this.dragging_ &&
      this.isMouseActionButton_(pointerEvent)
    ) {
      this.emulateClick_(this.down_);
    }

    if (this.activePointers_.length === 0) {
      this.dragListenerKeys_.forEach(_events_js__WEBPACK_IMPORTED_MODULE_1__.unlistenByKey);
      this.dragListenerKeys_.length = 0;
      this.dragging_ = false;
      this.down_ = null;
    }
  }

  /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @return {boolean} If the left mouse button was pressed.
   * @private
   */
  isMouseActionButton_(pointerEvent) {
    return pointerEvent.button === 0;
  }

  /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */
  handlePointerDown_(pointerEvent) {
    this.emulateClicks_ = this.activePointers_.length === 0;
    this.updateActivePointers_(pointerEvent);
    const newEvent = new _MapBrowserEvent_js__WEBPACK_IMPORTED_MODULE_5__["default"](
      _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_6__["default"].POINTERDOWN,
      this.map_,
      pointerEvent,
      undefined,
      undefined,
      this.activePointers_
    );
    this.dispatchEvent(newEvent);

    this.down_ = new PointerEvent(pointerEvent.type, pointerEvent);
    Object.defineProperty(this.down_, 'target', {
      writable: false,
      value: pointerEvent.target,
    });

    if (this.dragListenerKeys_.length === 0) {
      const doc = this.map_.getOwnerDocument();
      this.dragListenerKeys_.push(
        (0,_events_js__WEBPACK_IMPORTED_MODULE_1__.listen)(
          doc,
          _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_6__["default"].POINTERMOVE,
          this.handlePointerMove_,
          this
        ),
        (0,_events_js__WEBPACK_IMPORTED_MODULE_1__.listen)(doc, _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_6__["default"].POINTERUP, this.handlePointerUp_, this),
        /* Note that the listener for `pointercancel is set up on
         * `pointerEventHandler_` and not `documentPointerEventHandler_` like
         * the `pointerup` and `pointermove` listeners.
         *
         * The reason for this is the following: `TouchSource.vacuumTouches_()`
         * issues `pointercancel` events, when there was no `touchend` for a
         * `touchstart`. Now, let's say a first `touchstart` is registered on
         * `pointerEventHandler_`. The `documentPointerEventHandler_` is set up.
         * But `documentPointerEventHandler_` doesn't know about the first
         * `touchstart`. If there is no `touchend` for the `touchstart`, we can
         * only receive a `touchcancel` from `pointerEventHandler_`, because it is
         * only registered there.
         */
        (0,_events_js__WEBPACK_IMPORTED_MODULE_1__.listen)(
          this.element_,
          _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_6__["default"].POINTERCANCEL,
          this.handlePointerUp_,
          this
        )
      );
      if (this.element_.getRootNode && this.element_.getRootNode() !== doc) {
        this.dragListenerKeys_.push(
          (0,_events_js__WEBPACK_IMPORTED_MODULE_1__.listen)(
            this.element_.getRootNode(),
            _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_6__["default"].POINTERUP,
            this.handlePointerUp_,
            this
          )
        );
      }
    }
  }

  /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */
  handlePointerMove_(pointerEvent) {
    // Between pointerdown and pointerup, pointermove events are triggered.
    // To avoid a 'false' touchmove event to be dispatched, we test if the pointer
    // moved a significant distance.
    if (this.isMoving_(pointerEvent)) {
      this.updateActivePointers_(pointerEvent);
      this.dragging_ = true;
      const newEvent = new _MapBrowserEvent_js__WEBPACK_IMPORTED_MODULE_5__["default"](
        _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_6__["default"].POINTERDRAG,
        this.map_,
        pointerEvent,
        this.dragging_,
        undefined,
        this.activePointers_
      );
      this.dispatchEvent(newEvent);
    }
  }

  /**
   * Wrap and relay a pointermove event.
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */
  relayMoveEvent_(pointerEvent) {
    this.originalPointerMoveEvent_ = pointerEvent;
    const dragging = !!(this.down_ && this.isMoving_(pointerEvent));
    this.dispatchEvent(
      new _MapBrowserEvent_js__WEBPACK_IMPORTED_MODULE_5__["default"](
        _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_6__["default"].POINTERMOVE,
        this.map_,
        pointerEvent,
        dragging
      )
    );
  }

  /**
   * Flexible handling of a `touch-action: none` css equivalent: because calling
   * `preventDefault()` on a `pointermove` event does not stop native page scrolling
   * and zooming, we also listen for `touchmove` and call `preventDefault()` on it
   * when an interaction (currently `DragPan` handles the event.
   * @param {TouchEvent} event Event.
   * @private
   */
  handleTouchMove_(event) {
    // Due to https://github.com/mpizenberg/elm-pep/issues/2, `this.originalPointerMoveEvent_`
    // may not be initialized yet when we get here on a platform without native pointer events,
    // when elm-pep is used as pointer events polyfill.
    const originalEvent = this.originalPointerMoveEvent_;
    if (
      (!originalEvent || originalEvent.defaultPrevented) &&
      (typeof event.cancelable !== 'boolean' || event.cancelable === true)
    ) {
      event.preventDefault();
    }
  }

  /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @return {boolean} Is moving.
   * @private
   */
  isMoving_(pointerEvent) {
    return (
      this.dragging_ ||
      Math.abs(pointerEvent.clientX - this.down_.clientX) >
        this.moveTolerance_ ||
      Math.abs(pointerEvent.clientY - this.down_.clientY) > this.moveTolerance_
    );
  }

  /**
   * Clean up.
   */
  disposeInternal() {
    if (this.relayedListenerKey_) {
      (0,_events_js__WEBPACK_IMPORTED_MODULE_1__.unlistenByKey)(this.relayedListenerKey_);
      this.relayedListenerKey_ = null;
    }
    this.element_.removeEventListener(
      _events_EventType_js__WEBPACK_IMPORTED_MODULE_3__["default"].TOUCHMOVE,
      this.boundHandleTouchMove_
    );

    if (this.pointerdownListenerKey_) {
      (0,_events_js__WEBPACK_IMPORTED_MODULE_1__.unlistenByKey)(this.pointerdownListenerKey_);
      this.pointerdownListenerKey_ = null;
    }

    this.dragListenerKeys_.forEach(_events_js__WEBPACK_IMPORTED_MODULE_1__.unlistenByKey);
    this.dragListenerKeys_.length = 0;

    this.element_ = null;
    super.disposeInternal();
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (MapBrowserEventHandler);


/***/ }),

/***/ "./node_modules/ol/MapBrowserEventType.js":
/*!************************************************!*\
  !*** ./node_modules/ol/MapBrowserEventType.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./events/EventType.js */ "./node_modules/ol/events/EventType.js");
/**
 * @module ol/MapBrowserEventType
 */


/**
 * Constants for event names.
 * @enum {string}
 */
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  /**
   * A true single click with no dragging and no double click. Note that this
   * event is delayed by 250 ms to ensure that it is not a double click.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#singleclick
   * @api
   */
  SINGLECLICK: 'singleclick',

  /**
   * A click with no dragging. A double click will fire two of this.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#click
   * @api
   */
  CLICK: _events_EventType_js__WEBPACK_IMPORTED_MODULE_0__["default"].CLICK,

  /**
   * A true double click, with no dragging.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#dblclick
   * @api
   */
  DBLCLICK: _events_EventType_js__WEBPACK_IMPORTED_MODULE_0__["default"].DBLCLICK,

  /**
   * Triggered when a pointer is dragged.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#pointerdrag
   * @api
   */
  POINTERDRAG: 'pointerdrag',

  /**
   * Triggered when a pointer is moved. Note that on touch devices this is
   * triggered when the map is panned, so is not the same as mousemove.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#pointermove
   * @api
   */
  POINTERMOVE: 'pointermove',

  POINTERDOWN: 'pointerdown',
  POINTERUP: 'pointerup',
  POINTEROVER: 'pointerover',
  POINTEROUT: 'pointerout',
  POINTERENTER: 'pointerenter',
  POINTERLEAVE: 'pointerleave',
  POINTERCANCEL: 'pointercancel',
});

/***
 * @typedef {'singleclick'|'click'|'dblclick'|'pointerdrag'|'pointermove'} Types
 */


/***/ }),

/***/ "./node_modules/ol/MapEvent.js":
/*!*************************************!*\
  !*** ./node_modules/ol/MapEvent.js ***!
  \*************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _events_Event_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./events/Event.js */ "./node_modules/ol/events/Event.js");
/**
 * @module ol/MapEvent
 */


/**
 * @classdesc
 * Events emitted as map events are instances of this type.
 * See {@link module:ol/Map~Map} for which events trigger a map event.
 */
class MapEvent extends _events_Event_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {string} type Event type.
   * @param {import("./Map.js").default} map Map.
   * @param {?import("./Map.js").FrameState} [frameState] Frame state.
   */
  constructor(type, map, frameState) {
    super(type);

    /**
     * The map where the event occurred.
     * @type {import("./Map.js").default}
     * @api
     */
    this.map = map;

    /**
     * The frame state at the time of the event.
     * @type {?import("./Map.js").FrameState}
     * @api
     */
    this.frameState = frameState !== undefined ? frameState : null;
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (MapEvent);


/***/ }),

/***/ "./node_modules/ol/MapEventType.js":
/*!*****************************************!*\
  !*** ./node_modules/ol/MapEventType.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * @module ol/MapEventType
 */

/**
 * @enum {string}
 */
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  /**
   * Triggered after a map frame is rendered.
   * @event module:ol/MapEvent~MapEvent#postrender
   * @api
   */
  POSTRENDER: 'postrender',

  /**
   * Triggered when the map starts moving.
   * @event module:ol/MapEvent~MapEvent#movestart
   * @api
   */
  MOVESTART: 'movestart',

  /**
   * Triggered after the map is moved.
   * @event module:ol/MapEvent~MapEvent#moveend
   * @api
   */
  MOVEEND: 'moveend',

  /**
   * Triggered when loading of additional map data (tiles, images, features) starts.
   * @event module:ol/MapEvent~MapEvent#loadstart
   * @api
   */
  LOADSTART: 'loadstart',

  /**
   * Triggered when loading of additional map data has completed.
   * @event module:ol/MapEvent~MapEvent#loadend
   * @api
   */
  LOADEND: 'loadend',
});

/***
 * @typedef {'postrender'|'movestart'|'moveend'|'loadstart'|'loadend'} Types
 */


/***/ }),

/***/ "./node_modules/ol/MapProperty.js":
/*!****************************************!*\
  !*** ./node_modules/ol/MapProperty.js ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * @module ol/MapProperty
 */

/**
 * @enum {string}
 */
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  LAYERGROUP: 'layergroup',
  SIZE: 'size',
  TARGET: 'target',
  VIEW: 'view',
});


/***/ }),

/***/ "./node_modules/ol/Object.js":
/*!***********************************!*\
  !*** ./node_modules/ol/Object.js ***!
  \***********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ObjectEvent: () => (/* binding */ ObjectEvent),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _events_Event_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./events/Event.js */ "./node_modules/ol/events/Event.js");
/* harmony import */ var _ObjectEventType_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ObjectEventType.js */ "./node_modules/ol/ObjectEventType.js");
/* harmony import */ var _Observable_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Observable.js */ "./node_modules/ol/Observable.js");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./util.js */ "./node_modules/ol/util.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./obj.js */ "./node_modules/ol/obj.js");
/**
 * @module ol/Object
 */






/**
 * @classdesc
 * Events emitted by {@link module:ol/Object~BaseObject} instances are instances of this type.
 */
class ObjectEvent extends _events_Event_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {string} type The event type.
   * @param {string} key The property name.
   * @param {*} oldValue The old value for `key`.
   */
  constructor(type, key, oldValue) {
    super(type);

    /**
     * The name of the property whose value is changing.
     * @type {string}
     * @api
     */
    this.key = key;

    /**
     * The old value. To get the new value use `e.target.get(e.key)` where
     * `e` is the event object.
     * @type {*}
     * @api
     */
    this.oldValue = oldValue;
  }
}

/***
 * @template Return
 * @typedef {import("./Observable").OnSignature<import("./Observable").EventTypes, import("./events/Event.js").default, Return> &
 *    import("./Observable").OnSignature<import("./ObjectEventType").Types, ObjectEvent, Return> &
 *    import("./Observable").CombinedOnSignature<import("./Observable").EventTypes|import("./ObjectEventType").Types, Return>} ObjectOnSignature
 */

/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Most non-trivial classes inherit from this.
 *
 * This extends {@link module:ol/Observable~Observable} with observable
 * properties, where each property is observable as well as the object as a
 * whole.
 *
 * Classes that inherit from this have pre-defined properties, to which you can
 * add your owns. The pre-defined properties are listed in this documentation as
 * 'Observable Properties', and have their own accessors; for example,
 * {@link module:ol/Map~Map} has a `target` property, accessed with
 * `getTarget()` and changed with `setTarget()`. Not all properties are however
 * settable. There are also general-purpose accessors `get()` and `set()`. For
 * example, `get('target')` is equivalent to `getTarget()`.
 *
 * The `set` accessors trigger a change event, and you can monitor this by
 * registering a listener. For example, {@link module:ol/View~View} has a
 * `center` property, so `view.on('change:center', function(evt) {...});` would
 * call the function whenever the value of the center property changes. Within
 * the function, `evt.target` would be the view, so `evt.target.getCenter()`
 * would return the new center.
 *
 * You can add your own observable properties with
 * `object.set('prop', 'value')`, and retrieve that with `object.get('prop')`.
 * You can listen for changes on that property value with
 * `object.on('change:prop', listener)`. You can get a list of all
 * properties with {@link module:ol/Object~BaseObject#getProperties}.
 *
 * Note that the observable properties are separate from standard JS properties.
 * You can, for example, give your map object a title with
 * `map.title='New title'` and with `map.set('title', 'Another title')`. The
 * first will be a `hasOwnProperty`; the second will appear in
 * `getProperties()`. Only the second is observable.
 *
 * Properties can be deleted by using the unset method. E.g.
 * object.unset('foo').
 *
 * @fires ObjectEvent
 * @api
 */
class BaseObject extends _Observable_js__WEBPACK_IMPORTED_MODULE_1__["default"] {
  /**
   * @param {Object<string, *>} [values] An object with key-value pairs.
   */
  constructor(values) {
    super();

    /***
     * @type {ObjectOnSignature<import("./events").EventsKey>}
     */
    this.on;

    /***
     * @type {ObjectOnSignature<import("./events").EventsKey>}
     */
    this.once;

    /***
     * @type {ObjectOnSignature<void>}
     */
    this.un;

    // Call {@link module:ol/util.getUid} to ensure that the order of objects' ids is
    // the same as the order in which they were created.  This also helps to
    // ensure that object properties are always added in the same order, which
    // helps many JavaScript engines generate faster code.
    (0,_util_js__WEBPACK_IMPORTED_MODULE_2__.getUid)(this);

    /**
     * @private
     * @type {Object<string, *>}
     */
    this.values_ = null;

    if (values !== undefined) {
      this.setProperties(values);
    }
  }

  /**
   * Gets a value.
   * @param {string} key Key name.
   * @return {*} Value.
   * @api
   */
  get(key) {
    let value;
    if (this.values_ && this.values_.hasOwnProperty(key)) {
      value = this.values_[key];
    }
    return value;
  }

  /**
   * Get a list of object property names.
   * @return {Array<string>} List of property names.
   * @api
   */
  getKeys() {
    return (this.values_ && Object.keys(this.values_)) || [];
  }

  /**
   * Get an object of all property names and values.
   * @return {Object<string, *>} Object.
   * @api
   */
  getProperties() {
    return (this.values_ && Object.assign({}, this.values_)) || {};
  }

  /**
   * Get an object of all property names and values.
   * @return {Object<string, *>?} Object.
   */
  getPropertiesInternal() {
    return this.values_;
  }

  /**
   * @return {boolean} The object has properties.
   */
  hasProperties() {
    return !!this.values_;
  }

  /**
   * @param {string} key Key name.
   * @param {*} oldValue Old value.
   */
  notify(key, oldValue) {
    let eventType;
    eventType = `change:${key}`;
    if (this.hasListener(eventType)) {
      this.dispatchEvent(new ObjectEvent(eventType, key, oldValue));
    }
    eventType = _ObjectEventType_js__WEBPACK_IMPORTED_MODULE_3__["default"].PROPERTYCHANGE;
    if (this.hasListener(eventType)) {
      this.dispatchEvent(new ObjectEvent(eventType, key, oldValue));
    }
  }

  /**
   * @param {string} key Key name.
   * @param {import("./events.js").Listener} listener Listener.
   */
  addChangeListener(key, listener) {
    this.addEventListener(`change:${key}`, listener);
  }

  /**
   * @param {string} key Key name.
   * @param {import("./events.js").Listener} listener Listener.
   */
  removeChangeListener(key, listener) {
    this.removeEventListener(`change:${key}`, listener);
  }

  /**
   * Sets a value.
   * @param {string} key Key name.
   * @param {*} value Value.
   * @param {boolean} [silent] Update without triggering an event.
   * @api
   */
  set(key, value, silent) {
    const values = this.values_ || (this.values_ = {});
    if (silent) {
      values[key] = value;
    } else {
      const oldValue = values[key];
      values[key] = value;
      if (oldValue !== value) {
        this.notify(key, oldValue);
      }
    }
  }

  /**
   * Sets a collection of key-value pairs.  Note that this changes any existing
   * properties and adds new ones (it does not remove any existing properties).
   * @param {Object<string, *>} values Values.
   * @param {boolean} [silent] Update without triggering an event.
   * @api
   */
  setProperties(values, silent) {
    for (const key in values) {
      this.set(key, values[key], silent);
    }
  }

  /**
   * Apply any properties from another object without triggering events.
   * @param {BaseObject} source The source object.
   * @protected
   */
  applyProperties(source) {
    if (!source.values_) {
      return;
    }
    Object.assign(this.values_ || (this.values_ = {}), source.values_);
  }

  /**
   * Unsets a property.
   * @param {string} key Key name.
   * @param {boolean} [silent] Unset without triggering an event.
   * @api
   */
  unset(key, silent) {
    if (this.values_ && key in this.values_) {
      const oldValue = this.values_[key];
      delete this.values_[key];
      if ((0,_obj_js__WEBPACK_IMPORTED_MODULE_4__.isEmpty)(this.values_)) {
        this.values_ = null;
      }
      if (!silent) {
        this.notify(key, oldValue);
      }
    }
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (BaseObject);


/***/ }),

/***/ "./node_modules/ol/ObjectEventType.js":
/*!********************************************!*\
  !*** ./node_modules/ol/ObjectEventType.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * @module ol/ObjectEventType
 */

/**
 * @enum {string}
 */
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  /**
   * Triggered when a property is changed.
   * @event module:ol/Object.ObjectEvent#propertychange
   * @api
   */
  PROPERTYCHANGE: 'propertychange',
});

/**
 * @typedef {'propertychange'} Types
 */


/***/ }),

/***/ "./node_modules/ol/Observable.js":
/*!***************************************!*\
  !*** ./node_modules/ol/Observable.js ***!
  \***************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   unByKey: () => (/* binding */ unByKey)
/* harmony export */ });
/* harmony import */ var _events_Target_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./events/Target.js */ "./node_modules/ol/events/Target.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./events/EventType.js */ "./node_modules/ol/events/EventType.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./events.js */ "./node_modules/ol/events.js");
/**
 * @module ol/Observable
 */




/***
 * @template {string} Type
 * @template {Event|import("./events/Event.js").default} EventClass
 * @template Return
 * @typedef {(type: Type, listener: (event: EventClass) => ?) => Return} OnSignature
 */

/***
 * @template {string} Type
 * @template Return
 * @typedef {(type: Type[], listener: (event: Event|import("./events/Event").default) => ?) => Return extends void ? void : Return[]} CombinedOnSignature
 */

/**
 * @typedef {'change'|'error'} EventTypes
 */

/***
 * @template Return
 * @typedef {OnSignature<EventTypes, import("./events/Event.js").default, Return> & CombinedOnSignature<EventTypes, Return>} ObservableOnSignature
 */

/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * An event target providing convenient methods for listener registration
 * and unregistration. A generic `change` event is always available through
 * {@link module:ol/Observable~Observable#changed}.
 *
 * @fires import("./events/Event.js").default
 * @api
 */
class Observable extends _events_Target_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  constructor() {
    super();

    this.on =
      /** @type {ObservableOnSignature<import("./events").EventsKey>} */ (
        this.onInternal
      );

    this.once =
      /** @type {ObservableOnSignature<import("./events").EventsKey>} */ (
        this.onceInternal
      );

    this.un = /** @type {ObservableOnSignature<void>} */ (this.unInternal);

    /**
     * @private
     * @type {number}
     */
    this.revision_ = 0;
  }

  /**
   * Increases the revision counter and dispatches a 'change' event.
   * @api
   */
  changed() {
    ++this.revision_;
    this.dispatchEvent(_events_EventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].CHANGE);
  }

  /**
   * Get the version number for this object.  Each time the object is modified,
   * its version number will be incremented.
   * @return {number} Revision.
   * @api
   */
  getRevision() {
    return this.revision_;
  }

  /**
   * @param {string|Array<string>} type Type.
   * @param {function((Event|import("./events/Event").default)): ?} listener Listener.
   * @return {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} Event key.
   * @protected
   */
  onInternal(type, listener) {
    if (Array.isArray(type)) {
      const len = type.length;
      const keys = new Array(len);
      for (let i = 0; i < len; ++i) {
        keys[i] = (0,_events_js__WEBPACK_IMPORTED_MODULE_2__.listen)(this, type[i], listener);
      }
      return keys;
    }
    return (0,_events_js__WEBPACK_IMPORTED_MODULE_2__.listen)(this, /** @type {string} */ (type), listener);
  }

  /**
   * @param {string|Array<string>} type Type.
   * @param {function((Event|import("./events/Event").default)): ?} listener Listener.
   * @return {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} Event key.
   * @protected
   */
  onceInternal(type, listener) {
    let key;
    if (Array.isArray(type)) {
      const len = type.length;
      key = new Array(len);
      for (let i = 0; i < len; ++i) {
        key[i] = (0,_events_js__WEBPACK_IMPORTED_MODULE_2__.listenOnce)(this, type[i], listener);
      }
    } else {
      key = (0,_events_js__WEBPACK_IMPORTED_MODULE_2__.listenOnce)(this, /** @type {string} */ (type), listener);
    }
    /** @type {Object} */ (listener).ol_key = key;
    return key;
  }

  /**
   * Unlisten for a certain type of event.
   * @param {string|Array<string>} type Type.
   * @param {function((Event|import("./events/Event").default)): ?} listener Listener.
   * @protected
   */
  unInternal(type, listener) {
    const key = /** @type {Object} */ (listener).ol_key;
    if (key) {
      unByKey(key);
    } else if (Array.isArray(type)) {
      for (let i = 0, ii = type.length; i < ii; ++i) {
        this.removeEventListener(type[i], listener);
      }
    } else {
      this.removeEventListener(type, listener);
    }
  }
}

/**
 * Listen for a certain type of event.
 * @function
 * @param {string|Array<string>} type The event type or array of event types.
 * @param {function((Event|import("./events/Event").default)): ?} listener The listener function.
 * @return {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} Unique key for the listener. If
 *     called with an array of event types as the first argument, the return
 *     will be an array of keys.
 * @api
 */
Observable.prototype.on;

/**
 * Listen once for a certain type of event.
 * @function
 * @param {string|Array<string>} type The event type or array of event types.
 * @param {function((Event|import("./events/Event").default)): ?} listener The listener function.
 * @return {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} Unique key for the listener. If
 *     called with an array of event types as the first argument, the return
 *     will be an array of keys.
 * @api
 */
Observable.prototype.once;

/**
 * Unlisten for a certain type of event.
 * @function
 * @param {string|Array<string>} type The event type or array of event types.
 * @param {function((Event|import("./events/Event").default)): ?} listener The listener function.
 * @api
 */
Observable.prototype.un;

/**
 * Removes an event listener using the key returned by `on()` or `once()`.
 * @param {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} key The key returned by `on()`
 *     or `once()` (or an array of keys).
 * @api
 */
function unByKey(key) {
  if (Array.isArray(key)) {
    for (let i = 0, ii = key.length; i < ii; ++i) {
      (0,_events_js__WEBPACK_IMPORTED_MODULE_2__.unlistenByKey)(key[i]);
    }
  } else {
    (0,_events_js__WEBPACK_IMPORTED_MODULE_2__.unlistenByKey)(/** @type {import("./events.js").EventsKey} */ (key));
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Observable);


/***/ }),

/***/ "./node_modules/ol/Tile.js":
/*!*********************************!*\
  !*** ./node_modules/ol/Tile.js ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _events_Target_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./events/Target.js */ "./node_modules/ol/events/Target.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./events/EventType.js */ "./node_modules/ol/events/EventType.js");
/* harmony import */ var _TileState_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./TileState.js */ "./node_modules/ol/TileState.js");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./util.js */ "./node_modules/ol/util.js");
/* harmony import */ var _easing_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./easing.js */ "./node_modules/ol/easing.js");
/**
 * @module ol/Tile
 */






/**
 * A function that takes an {@link module:ol/Tile~Tile} for the tile and a
 * `{string}` for the url as arguments. The default is
 * ```js
 * source.setTileLoadFunction(function(tile, src) {
 *   tile.getImage().src = src;
 * });
 * ```
 * For more fine grained control, the load function can use fetch or XMLHttpRequest and involve
 * error handling:
 *
 * ```js
 * import TileState from 'ol/TileState.js';
 *
 * source.setTileLoadFunction(function(tile, src) {
 *   const xhr = new XMLHttpRequest();
 *   xhr.responseType = 'blob';
 *   xhr.addEventListener('loadend', function (evt) {
 *     const data = this.response;
 *     if (data !== undefined) {
 *       tile.getImage().src = URL.createObjectURL(data);
 *     } else {
 *       tile.setState(TileState.ERROR);
 *     }
 *   });
 *   xhr.addEventListener('error', function () {
 *     tile.setState(TileState.ERROR);
 *   });
 *   xhr.open('GET', src);
 *   xhr.send();
 * });
 * ```
 *
 * @typedef {function(Tile, string): void} LoadFunction
 * @api
 */

/**
 * {@link module:ol/source/Tile~TileSource} sources use a function of this type to get
 * the url that provides a tile for a given tile coordinate.
 *
 * This function takes an {@link module:ol/tilecoord~TileCoord} for the tile
 * coordinate, a `{number}` representing the pixel ratio and a
 * {@link module:ol/proj/Projection~Projection} for the projection  as arguments
 * and returns a `{string}` representing the tile URL, or undefined if no tile
 * should be requested for the passed tile coordinate.
 *
 * @typedef {function(import("./tilecoord.js").TileCoord, number,
 *           import("./proj/Projection.js").default): (string|undefined)} UrlFunction
 * @api
 */

/**
 * @typedef {Object} Options
 * @property {number} [transition=250] A duration for tile opacity
 * transitions in milliseconds. A duration of 0 disables the opacity transition.
 * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,
 * the nearest neighbor is used when resampling.
 * @api
 */

/**
 * @classdesc
 * Base class for tiles.
 *
 * @abstract
 */
class Tile extends _events_Target_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("./TileState.js").default} state State.
   * @param {Options} [options] Tile options.
   */
  constructor(tileCoord, state, options) {
    super();

    options = options ? options : {};

    /**
     * @type {import("./tilecoord.js").TileCoord}
     */
    this.tileCoord = tileCoord;

    /**
     * @protected
     * @type {import("./TileState.js").default}
     */
    this.state = state;

    /**
     * An "interim" tile for this tile. The interim tile may be used while this
     * one is loading, for "smooth" transitions when changing params/dimensions
     * on the source.
     * @type {Tile}
     */
    this.interimTile = null;

    /**
     * A key assigned to the tile. This is used by the tile source to determine
     * if this tile can effectively be used, or if a new tile should be created
     * and this one be used as an interim tile for this new tile.
     * @type {string}
     */
    this.key = '';

    /**
     * The duration for the opacity transition.
     * @type {number}
     */
    this.transition_ =
      options.transition === undefined ? 250 : options.transition;

    /**
     * Lookup of start times for rendering transitions.  If the start time is
     * equal to -1, the transition is complete.
     * @type {Object<string, number>}
     */
    this.transitionStarts_ = {};

    /**
     * @type {boolean}
     */
    this.interpolate = !!options.interpolate;
  }

  /**
   * @protected
   */
  changed() {
    this.dispatchEvent(_events_EventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].CHANGE);
  }

  /**
   * Called by the tile cache when the tile is removed from the cache due to expiry
   */
  release() {
    if (this.state === _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].ERROR) {
      // to remove the `change` listener on this tile in `ol/TileQueue#handleTileChange`
      this.setState(_TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].EMPTY);
    }
  }

  /**
   * @return {string} Key.
   */
  getKey() {
    return this.key + '/' + this.tileCoord;
  }

  /**
   * Get the interim tile most suitable for rendering using the chain of interim
   * tiles. This corresponds to the  most recent tile that has been loaded, if no
   * such tile exists, the original tile is returned.
   * @return {!Tile} Best tile for rendering.
   */
  getInterimTile() {
    if (!this.interimTile) {
      //empty chain
      return this;
    }
    let tile = this.interimTile;

    // find the first loaded tile and return it. Since the chain is sorted in
    // decreasing order of creation time, there is no need to search the remainder
    // of the list (all those tiles correspond to older requests and will be
    // cleaned up by refreshInterimChain)
    do {
      if (tile.getState() == _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADED) {
        // Show tile immediately instead of fading it in after loading, because
        // the interim tile is in place already
        this.transition_ = 0;
        return tile;
      }
      tile = tile.interimTile;
    } while (tile);

    // we can not find a better tile
    return this;
  }

  /**
   * Goes through the chain of interim tiles and discards sections of the chain
   * that are no longer relevant.
   */
  refreshInterimChain() {
    if (!this.interimTile) {
      return;
    }

    let tile = this.interimTile;

    /**
     * @type {Tile}
     */
    let prev = this;

    do {
      if (tile.getState() == _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADED) {
        //we have a loaded tile, we can discard the rest of the list
        //we would could abort any LOADING tile request
        //older than this tile (i.e. any LOADING tile following this entry in the chain)
        tile.interimTile = null;
        break;
      } else if (tile.getState() == _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADING) {
        //keep this LOADING tile any loaded tiles later in the chain are
        //older than this tile, so we're still interested in the request
        prev = tile;
      } else if (tile.getState() == _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].IDLE) {
        //the head of the list is the most current tile, we don't need
        //to start any other requests for this chain
        prev.interimTile = tile.interimTile;
      } else {
        prev = tile;
      }
      tile = prev.interimTile;
    } while (tile);
  }

  /**
   * Get the tile coordinate for this tile.
   * @return {import("./tilecoord.js").TileCoord} The tile coordinate.
   * @api
   */
  getTileCoord() {
    return this.tileCoord;
  }

  /**
   * @return {import("./TileState.js").default} State.
   */
  getState() {
    return this.state;
  }

  /**
   * Sets the state of this tile. If you write your own {@link module:ol/Tile~LoadFunction tileLoadFunction} ,
   * it is important to set the state correctly to {@link module:ol/TileState~ERROR}
   * when the tile cannot be loaded. Otherwise the tile cannot be removed from
   * the tile queue and will block other requests.
   * @param {import("./TileState.js").default} state State.
   * @api
   */
  setState(state) {
    if (this.state !== _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].ERROR && this.state > state) {
      throw new Error('Tile load sequence violation');
    }
    this.state = state;
    this.changed();
  }

  /**
   * Load the image or retry if loading previously failed.
   * Loading is taken care of by the tile queue, and calling this method is
   * only needed for preloading or for reloading in case of an error.
   * @abstract
   * @api
   */
  load() {
    (0,_util_js__WEBPACK_IMPORTED_MODULE_3__.abstract)();
  }

  /**
   * Get the alpha value for rendering.
   * @param {string} id An id for the renderer.
   * @param {number} time The render frame time.
   * @return {number} A number between 0 and 1.
   */
  getAlpha(id, time) {
    if (!this.transition_) {
      return 1;
    }

    let start = this.transitionStarts_[id];
    if (!start) {
      start = time;
      this.transitionStarts_[id] = start;
    } else if (start === -1) {
      return 1;
    }

    const delta = time - start + 1000 / 60; // avoid rendering at 0
    if (delta >= this.transition_) {
      return 1;
    }
    return (0,_easing_js__WEBPACK_IMPORTED_MODULE_4__.easeIn)(delta / this.transition_);
  }

  /**
   * Determine if a tile is in an alpha transition.  A tile is considered in
   * transition if tile.getAlpha() has not yet been called or has been called
   * and returned 1.
   * @param {string} id An id for the renderer.
   * @return {boolean} The tile is in transition.
   */
  inTransition(id) {
    if (!this.transition_) {
      return false;
    }
    return this.transitionStarts_[id] !== -1;
  }

  /**
   * Mark a transition as complete.
   * @param {string} id An id for the renderer.
   */
  endTransition(id) {
    if (this.transition_) {
      this.transitionStarts_[id] = -1;
    }
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Tile);


/***/ }),

/***/ "./node_modules/ol/TileCache.js":
/*!**************************************!*\
  !*** ./node_modules/ol/TileCache.js ***!
  \**************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _structs_LRUCache_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./structs/LRUCache.js */ "./node_modules/ol/structs/LRUCache.js");
/* harmony import */ var _tilecoord_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./tilecoord.js */ "./node_modules/ol/tilecoord.js");
/**
 * @module ol/TileCache
 */



class TileCache extends _structs_LRUCache_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  clear() {
    while (this.getCount() > 0) {
      this.pop().release();
    }
    super.clear();
  }

  /**
   * @param {!Object<string, boolean>} usedTiles Used tiles.
   */
  expireCache(usedTiles) {
    while (this.canExpireCache()) {
      const tile = this.peekLast();
      if (tile.getKey() in usedTiles) {
        break;
      } else {
        this.pop().release();
      }
    }
  }

  /**
   * Prune all tiles from the cache that don't have the same z as the newest tile.
   */
  pruneExceptNewestZ() {
    if (this.getCount() === 0) {
      return;
    }
    const key = this.peekFirstKey();
    const tileCoord = (0,_tilecoord_js__WEBPACK_IMPORTED_MODULE_1__.fromKey)(key);
    const z = tileCoord[0];
    this.forEach((tile) => {
      if (tile.tileCoord[0] !== z) {
        this.remove((0,_tilecoord_js__WEBPACK_IMPORTED_MODULE_1__.getKey)(tile.tileCoord));
        tile.release();
      }
    });
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (TileCache);


/***/ }),

/***/ "./node_modules/ol/TileQueue.js":
/*!**************************************!*\
  !*** ./node_modules/ol/TileQueue.js ***!
  \**************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   getTilePriority: () => (/* binding */ getTilePriority)
/* harmony export */ });
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./events/EventType.js */ "./node_modules/ol/events/EventType.js");
/* harmony import */ var _structs_PriorityQueue_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./structs/PriorityQueue.js */ "./node_modules/ol/structs/PriorityQueue.js");
/* harmony import */ var _TileState_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./TileState.js */ "./node_modules/ol/TileState.js");
/**
 * @module ol/TileQueue
 */




/**
 * @typedef {function(import("./Tile.js").default, string, import("./coordinate.js").Coordinate, number): number} PriorityFunction
 */

class TileQueue extends _structs_PriorityQueue_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {PriorityFunction} tilePriorityFunction Tile priority function.
   * @param {function(): ?} tileChangeCallback Function called on each tile change event.
   */
  constructor(tilePriorityFunction, tileChangeCallback) {
    super(
      /**
       * @param {Array} element Element.
       * @return {number} Priority.
       */
      function (element) {
        return tilePriorityFunction.apply(null, element);
      },
      /**
       * @param {Array} element Element.
       * @return {string} Key.
       */
      function (element) {
        return /** @type {import("./Tile.js").default} */ (element[0]).getKey();
      }
    );

    /** @private */
    this.boundHandleTileChange_ = this.handleTileChange.bind(this);

    /**
     * @private
     * @type {function(): ?}
     */
    this.tileChangeCallback_ = tileChangeCallback;

    /**
     * @private
     * @type {number}
     */
    this.tilesLoading_ = 0;

    /**
     * @private
     * @type {!Object<string,boolean>}
     */
    this.tilesLoadingKeys_ = {};
  }

  /**
   * @param {Array} element Element.
   * @return {boolean} The element was added to the queue.
   */
  enqueue(element) {
    const added = super.enqueue(element);
    if (added) {
      const tile = element[0];
      tile.addEventListener(_events_EventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].CHANGE, this.boundHandleTileChange_);
    }
    return added;
  }

  /**
   * @return {number} Number of tiles loading.
   */
  getTilesLoading() {
    return this.tilesLoading_;
  }

  /**
   * @param {import("./events/Event.js").default} event Event.
   * @protected
   */
  handleTileChange(event) {
    const tile = /** @type {import("./Tile.js").default} */ (event.target);
    const state = tile.getState();
    if (
      state === _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADED ||
      state === _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].ERROR ||
      state === _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].EMPTY
    ) {
      if (state !== _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].ERROR) {
        tile.removeEventListener(_events_EventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].CHANGE, this.boundHandleTileChange_);
      }
      const tileKey = tile.getKey();
      if (tileKey in this.tilesLoadingKeys_) {
        delete this.tilesLoadingKeys_[tileKey];
        --this.tilesLoading_;
      }
      this.tileChangeCallback_();
    }
  }

  /**
   * @param {number} maxTotalLoading Maximum number tiles to load simultaneously.
   * @param {number} maxNewLoads Maximum number of new tiles to load.
   */
  loadMoreTiles(maxTotalLoading, maxNewLoads) {
    let newLoads = 0;
    let state, tile, tileKey;
    while (
      this.tilesLoading_ < maxTotalLoading &&
      newLoads < maxNewLoads &&
      this.getCount() > 0
    ) {
      tile = /** @type {import("./Tile.js").default} */ (this.dequeue()[0]);
      tileKey = tile.getKey();
      state = tile.getState();
      if (state === _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].IDLE && !(tileKey in this.tilesLoadingKeys_)) {
        this.tilesLoadingKeys_[tileKey] = true;
        ++this.tilesLoading_;
        ++newLoads;
        tile.load();
      }
    }
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (TileQueue);

/**
 * @param {import('./Map.js').FrameState} frameState Frame state.
 * @param {import("./Tile.js").default} tile Tile.
 * @param {string} tileSourceKey Tile source key.
 * @param {import("./coordinate.js").Coordinate} tileCenter Tile center.
 * @param {number} tileResolution Tile resolution.
 * @return {number} Tile priority.
 */
function getTilePriority(
  frameState,
  tile,
  tileSourceKey,
  tileCenter,
  tileResolution
) {
  // Filter out tiles at higher zoom levels than the current zoom level, or that
  // are outside the visible extent.
  if (!frameState || !(tileSourceKey in frameState.wantedTiles)) {
    return _structs_PriorityQueue_js__WEBPACK_IMPORTED_MODULE_0__.DROP;
  }
  if (!frameState.wantedTiles[tileSourceKey][tile.getKey()]) {
    return _structs_PriorityQueue_js__WEBPACK_IMPORTED_MODULE_0__.DROP;
  }
  // Prioritize the highest zoom level tiles closest to the focus.
  // Tiles at higher zoom levels are prioritized using Math.log(tileResolution).
  // Within a zoom level, tiles are prioritized by the distance in pixels between
  // the center of the tile and the center of the viewport.  The factor of 65536
  // means that the prioritization should behave as desired for tiles up to
  // 65536 * Math.log(2) = 45426 pixels from the focus.
  const center = frameState.viewState.center;
  const deltaX = tileCenter[0] - center[0];
  const deltaY = tileCenter[1] - center[1];
  return (
    65536 * Math.log(tileResolution) +
    Math.sqrt(deltaX * deltaX + deltaY * deltaY) / tileResolution
  );
}


/***/ }),

/***/ "./node_modules/ol/TileRange.js":
/*!**************************************!*\
  !*** ./node_modules/ol/TileRange.js ***!
  \**************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createOrUpdate: () => (/* binding */ createOrUpdate),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * @module ol/TileRange
 */

/**
 * A representation of a contiguous block of tiles.  A tile range is specified
 * by its min/max tile coordinates and is inclusive of coordinates.
 */
class TileRange {
  /**
   * @param {number} minX Minimum X.
   * @param {number} maxX Maximum X.
   * @param {number} minY Minimum Y.
   * @param {number} maxY Maximum Y.
   */
  constructor(minX, maxX, minY, maxY) {
    /**
     * @type {number}
     */
    this.minX = minX;

    /**
     * @type {number}
     */
    this.maxX = maxX;

    /**
     * @type {number}
     */
    this.minY = minY;

    /**
     * @type {number}
     */
    this.maxY = maxY;
  }

  /**
   * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @return {boolean} Contains tile coordinate.
   */
  contains(tileCoord) {
    return this.containsXY(tileCoord[1], tileCoord[2]);
  }

  /**
   * @param {TileRange} tileRange Tile range.
   * @return {boolean} Contains.
   */
  containsTileRange(tileRange) {
    return (
      this.minX <= tileRange.minX &&
      tileRange.maxX <= this.maxX &&
      this.minY <= tileRange.minY &&
      tileRange.maxY <= this.maxY
    );
  }

  /**
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @return {boolean} Contains coordinate.
   */
  containsXY(x, y) {
    return this.minX <= x && x <= this.maxX && this.minY <= y && y <= this.maxY;
  }

  /**
   * @param {TileRange} tileRange Tile range.
   * @return {boolean} Equals.
   */
  equals(tileRange) {
    return (
      this.minX == tileRange.minX &&
      this.minY == tileRange.minY &&
      this.maxX == tileRange.maxX &&
      this.maxY == tileRange.maxY
    );
  }

  /**
   * @param {TileRange} tileRange Tile range.
   */
  extend(tileRange) {
    if (tileRange.minX < this.minX) {
      this.minX = tileRange.minX;
    }
    if (tileRange.maxX > this.maxX) {
      this.maxX = tileRange.maxX;
    }
    if (tileRange.minY < this.minY) {
      this.minY = tileRange.minY;
    }
    if (tileRange.maxY > this.maxY) {
      this.maxY = tileRange.maxY;
    }
  }

  /**
   * @return {number} Height.
   */
  getHeight() {
    return this.maxY - this.minY + 1;
  }

  /**
   * @return {import("./size.js").Size} Size.
   */
  getSize() {
    return [this.getWidth(), this.getHeight()];
  }

  /**
   * @return {number} Width.
   */
  getWidth() {
    return this.maxX - this.minX + 1;
  }

  /**
   * @param {TileRange} tileRange Tile range.
   * @return {boolean} Intersects.
   */
  intersects(tileRange) {
    return (
      this.minX <= tileRange.maxX &&
      this.maxX >= tileRange.minX &&
      this.minY <= tileRange.maxY &&
      this.maxY >= tileRange.minY
    );
  }
}

/**
 * @param {number} minX Minimum X.
 * @param {number} maxX Maximum X.
 * @param {number} minY Minimum Y.
 * @param {number} maxY Maximum Y.
 * @param {TileRange} [tileRange] TileRange.
 * @return {TileRange} Tile range.
 */
function createOrUpdate(minX, maxX, minY, maxY, tileRange) {
  if (tileRange !== undefined) {
    tileRange.minX = minX;
    tileRange.maxX = maxX;
    tileRange.minY = minY;
    tileRange.maxY = maxY;
    return tileRange;
  }
  return new TileRange(minX, maxX, minY, maxY);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (TileRange);


/***/ }),

/***/ "./node_modules/ol/TileState.js":
/*!**************************************!*\
  !*** ./node_modules/ol/TileState.js ***!
  \**************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * @module ol/TileState
 */

/**
 * @enum {number}
 */
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  IDLE: 0,
  LOADING: 1,
  LOADED: 2,
  /**
   * Indicates that tile loading failed
   * @type {number}
   */
  ERROR: 3,
  EMPTY: 4,
});


/***/ }),

/***/ "./node_modules/ol/View.js":
/*!*********************************!*\
  !*** ./node_modules/ol/View.js ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createCenterConstraint: () => (/* binding */ createCenterConstraint),
/* harmony export */   createResolutionConstraint: () => (/* binding */ createResolutionConstraint),
/* harmony export */   createRotationConstraint: () => (/* binding */ createRotationConstraint),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   isNoopAnimation: () => (/* binding */ isNoopAnimation)
/* harmony export */ });
/* harmony import */ var _Object_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Object.js */ "./node_modules/ol/Object.js");
/* harmony import */ var _ViewHint_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ViewHint.js */ "./node_modules/ol/ViewHint.js");
/* harmony import */ var _ViewProperty_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ViewProperty.js */ "./node_modules/ol/ViewProperty.js");
/* harmony import */ var _tilegrid_common_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./tilegrid/common.js */ "./node_modules/ol/tilegrid/common.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./proj.js */ "./node_modules/ol/proj.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./functions.js */ "./node_modules/ol/functions.js");
/* harmony import */ var _coordinate_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./coordinate.js */ "./node_modules/ol/coordinate.js");
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./asserts.js */ "./node_modules/ol/asserts.js");
/* harmony import */ var _centerconstraint_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./centerconstraint.js */ "./node_modules/ol/centerconstraint.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./math.js */ "./node_modules/ol/math.js");
/* harmony import */ var _resolutionconstraint_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./resolutionconstraint.js */ "./node_modules/ol/resolutionconstraint.js");
/* harmony import */ var _rotationconstraint_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./rotationconstraint.js */ "./node_modules/ol/rotationconstraint.js");
/* harmony import */ var _easing_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./easing.js */ "./node_modules/ol/easing.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _geom_Polygon_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./geom/Polygon.js */ "./node_modules/ol/geom/Polygon.js");
/**
 * @module ol/View
 */

















/**
 * An animation configuration
 *
 * @typedef {Object} Animation
 * @property {import("./coordinate.js").Coordinate} [sourceCenter] Source center.
 * @property {import("./coordinate.js").Coordinate} [targetCenter] Target center.
 * @property {number} [sourceResolution] Source resolution.
 * @property {number} [targetResolution] Target resolution.
 * @property {number} [sourceRotation] Source rotation.
 * @property {number} [targetRotation] Target rotation.
 * @property {import("./coordinate.js").Coordinate} [anchor] Anchor.
 * @property {number} start Start.
 * @property {number} duration Duration.
 * @property {boolean} complete Complete.
 * @property {function(number):number} easing Easing.
 * @property {function(boolean):void} callback Callback.
 */

/**
 * @typedef {Object} Constraints
 * @property {import("./centerconstraint.js").Type} center Center.
 * @property {import("./resolutionconstraint.js").Type} resolution Resolution.
 * @property {import("./rotationconstraint.js").Type} rotation Rotation.
 */

/**
 * @typedef {Object} FitOptions
 * @property {import("./size.js").Size} [size] The size in pixels of the box to fit
 * the extent into. Default is the current size of the first map in the DOM that
 * uses this view, or `[100, 100]` if no such map is found.
 * @property {!Array<number>} [padding=[0, 0, 0, 0]] Padding (in pixels) to be
 * cleared inside the view. Values in the array are top, right, bottom and left
 * padding.
 * @property {boolean} [nearest=false] If the view `constrainResolution` option is `true`,
 * get the nearest extent instead of the closest that actually fits the view.
 * @property {number} [minResolution=0] Minimum resolution that we zoom to.
 * @property {number} [maxZoom] Maximum zoom level that we zoom to. If
 * `minResolution` is given, this property is ignored.
 * @property {number} [duration] The duration of the animation in milliseconds.
 * By default, there is no animation to the target extent.
 * @property {function(number):number} [easing] The easing function used during
 * the animation (defaults to {@link module:ol/easing.inAndOut}).
 * The function will be called for each frame with a number representing a
 * fraction of the animation's duration.  The function should return a number
 * between 0 and 1 representing the progress toward the destination state.
 * @property {function(boolean):void} [callback] Function called when the view is in
 * its final position. The callback will be called with `true` if the animation
 * series completed on its own or `false` if it was cancelled.
 */

/**
 * @typedef {Object} ViewOptions
 * @property {import("./coordinate.js").Coordinate} [center] The initial center for
 * the view. If a user projection is not set, the coordinate system for the center is
 * specified with the `projection` option. Layer sources will not be fetched if this
 * is not set, but the center can be set later with {@link #setCenter}.
 * @property {boolean|number} [constrainRotation=true] Rotation constraint.
 * `false` means no constraint. `true` means no constraint, but snap to zero
 * near zero. A number constrains the rotation to that number of values. For
 * example, `4` will constrain the rotation to 0, 90, 180, and 270 degrees.
 * @property {boolean} [enableRotation=true] Enable rotation.
 * If `false`, a rotation constraint that always sets the rotation to zero is
 * used. The `constrainRotation` option has no effect if `enableRotation` is
 * `false`.
 * @property {import("./extent.js").Extent} [extent] The extent that constrains the
 * view, in other words, nothing outside of this extent can be visible on the map.
 * @property {boolean} [constrainOnlyCenter=false] If true, the extent
 * constraint will only apply to the view center and not the whole extent.
 * @property {boolean} [smoothExtentConstraint=true] If true, the extent
 * constraint will be applied smoothly, i.e. allow the view to go slightly outside
 * of the given `extent`.
 * @property {number} [maxResolution] The maximum resolution used to determine
 * the resolution constraint. It is used together with `minResolution` (or
 * `maxZoom`) and `zoomFactor`. If unspecified it is calculated in such a way
 * that the projection's validity extent fits in a 256x256 px tile. If the
 * projection is Spherical Mercator (the default) then `maxResolution` defaults
 * to `40075016.68557849 / 256 = 156543.03392804097`.
 * @property {number} [minResolution] The minimum resolution used to determine
 * the resolution constraint.  It is used together with `maxResolution` (or
 * `minZoom`) and `zoomFactor`.  If unspecified it is calculated assuming 29
 * zoom levels (with a factor of 2). If the projection is Spherical Mercator
 * (the default) then `minResolution` defaults to
 * `40075016.68557849 / 256 / Math.pow(2, 28) = 0.0005831682455839253`.
 * @property {number} [maxZoom=28] The maximum zoom level used to determine the
 * resolution constraint. It is used together with `minZoom` (or
 * `maxResolution`) and `zoomFactor`.  Note that if `minResolution` is also
 * provided, it is given precedence over `maxZoom`.
 * @property {number} [minZoom=0] The minimum zoom level used to determine the
 * resolution constraint. It is used together with `maxZoom` (or
 * `minResolution`) and `zoomFactor`.  Note that if `maxResolution` is also
 * provided, it is given precedence over `minZoom`.
 * @property {boolean} [multiWorld=false] If `false` the view is constrained so
 * only one world is visible, and you cannot pan off the edge.  If `true` the map
 * may show multiple worlds at low zoom levels.  Only used if the `projection` is
 * global.  Note that if `extent` is also provided it is given precedence.
 * @property {boolean} [constrainResolution=false] If true, the view will always
 * animate to the closest zoom level after an interaction; false means
 * intermediary zoom levels are allowed.
 * @property {boolean} [smoothResolutionConstraint=true] If true, the resolution
 * min/max values will be applied smoothly, i. e. allow the view to exceed slightly
 * the given resolution or zoom bounds.
 * @property {boolean} [showFullExtent=false] Allow the view to be zoomed out to
 * show the full configured extent. By default, when a view is configured with an
 * extent, users will not be able to zoom out so the viewport exceeds the extent in
 * either dimension. This means the full extent may not be visible if the viewport
 * is taller or wider than the aspect ratio of the configured extent. If
 * showFullExtent is true, the user will be able to zoom out so that the viewport
 * exceeds the height or width of the configured extent, but not both, allowing the
 * full extent to be shown.
 * @property {import("./proj.js").ProjectionLike} [projection='EPSG:3857'] The
 * projection. The default is Spherical Mercator.
 * @property {number} [resolution] The initial resolution for the view. The
 * units are `projection` units per pixel (e.g. meters per pixel). An
 * alternative to setting this is to set `zoom`. Layer sources will not be
 * fetched if neither this nor `zoom` are defined, but they can be set later
 * with {@link #setZoom} or {@link #setResolution}.
 * @property {Array<number>} [resolutions] Resolutions that determine the
 * zoom levels if specified. The index in the array corresponds to the zoom level,
 * therefore the resolution values have to be in descending order. It also constrains
 * the resolution by the minimum and maximum value. If set the `maxResolution`,
 * `minResolution`, `minZoom`, `maxZoom`, and `zoomFactor` options are ignored.
 * @property {number} [rotation=0] The initial rotation for the view in radians
 * (positive rotation clockwise, 0 means North).
 * @property {number} [zoom] Only used if `resolution` is not defined. Zoom
 * level used to calculate the initial resolution for the view.
 * @property {number} [zoomFactor=2] The zoom factor used to compute the
 * corresponding resolution.
 * @property {!Array<number>} [padding=[0, 0, 0, 0]] Padding (in css pixels).
 * If the map viewport is partially covered with other content (overlays) along
 * its edges, this setting allows to shift the center of the viewport away from
 * that content. The order of the values is top, right, bottom, left.
 */

/**
 * @typedef {Object} AnimationOptions
 * @property {import("./coordinate.js").Coordinate} [center] The center of the view at the end of
 * the animation.
 * @property {number} [zoom] The zoom level of the view at the end of the
 * animation. This takes precedence over `resolution`.
 * @property {number} [resolution] The resolution of the view at the end
 * of the animation.  If `zoom` is also provided, this option will be ignored.
 * @property {number} [rotation] The rotation of the view at the end of
 * the animation.
 * @property {import("./coordinate.js").Coordinate} [anchor] Optional anchor to remain fixed
 * during a rotation or resolution animation.
 * @property {number} [duration=1000] The duration of the animation in milliseconds.
 * @property {function(number):number} [easing] The easing function used
 * during the animation (defaults to {@link module:ol/easing.inAndOut}).
 * The function will be called for each frame with a number representing a
 * fraction of the animation's duration.  The function should return a number
 * between 0 and 1 representing the progress toward the destination state.
 */

/**
 * @typedef {Object} State
 * @property {import("./coordinate.js").Coordinate} center Center (in view projection coordinates).
 * @property {import("./proj/Projection.js").default} projection Projection.
 * @property {number} resolution Resolution.
 * @property {import("./coordinate.js").Coordinate} [nextCenter] The next center during an animation series.
 * @property {number} [nextResolution] The next resolution during an animation series.
 * @property {number} [nextRotation] The next rotation during an animation series.
 * @property {number} rotation Rotation.
 * @property {number} zoom Zoom.
 */

/**
 * Like {@link import("./Map.js").FrameState}, but just `viewState` and `extent`.
 * @typedef {Object} ViewStateLayerStateExtent
 * @property {State} viewState View state.
 * @property {import("./extent.js").Extent} extent Extent (in user projection coordinates).
 * @property {Array<import("./layer/Layer.js").State>} [layerStatesArray] Layer states.
 */

/**
 * Default min zoom level for the map view.
 * @type {number}
 */
const DEFAULT_MIN_ZOOM = 0;

/**
 * @typedef {import("./ObjectEventType").Types|'change:center'|'change:resolution'|'change:rotation'} ViewObjectEventTypes
 */

/***
 * @template Return
 * @typedef {import("./Observable").OnSignature<import("./Observable").EventTypes, import("./events/Event.js").default, Return> &
 *   import("./Observable").OnSignature<ViewObjectEventTypes, import("./Object").ObjectEvent, Return> &
 *   import("./Observable").CombinedOnSignature<import("./Observable").EventTypes|ViewObjectEventTypes, Return>} ViewOnSignature
 */

/**
 * @classdesc
 * A View object represents a simple 2D view of the map.
 *
 * This is the object to act upon to change the center, resolution,
 * and rotation of the map.
 *
 * A View has a `projection`. The projection determines the
 * coordinate system of the center, and its units determine the units of the
 * resolution (projection units per pixel). The default projection is
 * Web Mercator (EPSG:3857).
 *
 * ### The view states
 *
 * A View is determined by three states: `center`, `resolution`,
 * and `rotation`. Each state has a corresponding getter and setter, e.g.
 * `getCenter` and `setCenter` for the `center` state.
 *
 * The `zoom` state is actually not saved on the view: all computations
 * internally use the `resolution` state. Still, the `setZoom` and `getZoom`
 * methods are available, as well as `getResolutionForZoom` and
 * `getZoomForResolution` to switch from one system to the other.
 *
 * ### The constraints
 *
 * `setCenter`, `setResolution` and `setRotation` can be used to change the
 * states of the view, but any constraint defined in the constructor will
 * be applied along the way.
 *
 * A View object can have a *resolution constraint*, a *rotation constraint*
 * and a *center constraint*.
 *
 * The *resolution constraint* typically restricts min/max values and
 * snaps to specific resolutions. It is determined by the following
 * options: `resolutions`, `maxResolution`, `maxZoom` and `zoomFactor`.
 * If `resolutions` is set, the other three options are ignored. See
 * documentation for each option for more information. By default, the view
 * only has a min/max restriction and allow intermediary zoom levels when
 * pinch-zooming for example.
 *
 * The *rotation constraint* snaps to specific angles. It is determined
 * by the following options: `enableRotation` and `constrainRotation`.
 * By default rotation is allowed and its value is snapped to zero when approaching the
 * horizontal.
 *
 * The *center constraint* is determined by the `extent` option. By
 * default the view center is not constrained at all.
 *
 * ### Changing the view state
 *
 * It is important to note that `setZoom`, `setResolution`, `setCenter` and
 * `setRotation` are subject to the above mentioned constraints. As such, it
 * may sometimes not be possible to know in advance the resulting state of the
 * View. For example, calling `setResolution(10)` does not guarantee that
 * `getResolution()` will return `10`.
 *
 * A consequence of this is that, when applying a delta on the view state, one
 * should use `adjustCenter`, `adjustRotation`, `adjustZoom` and `adjustResolution`
 * rather than the corresponding setters. This will let view do its internal
 * computations. Besides, the `adjust*` methods also take an `anchor`
 * argument which allows specifying an origin for the transformation.
 *
 * ### Interacting with the view
 *
 * View constraints are usually only applied when the view is *at rest*, meaning that
 * no interaction or animation is ongoing. As such, if the user puts the view in a
 * state that is not equivalent to a constrained one (e.g. rotating the view when
 * the snap angle is 0), an animation will be triggered at the interaction end to
 * put back the view to a stable state;
 *
 * @api
 */
class View extends _Object_js__WEBPACK_IMPORTED_MODULE_1__["default"] {
  /**
   * @param {ViewOptions} [options] View options.
   */
  constructor(options) {
    super();

    /***
     * @type {ViewOnSignature<import("./events").EventsKey>}
     */
    this.on;

    /***
     * @type {ViewOnSignature<import("./events").EventsKey>}
     */
    this.once;

    /***
     * @type {ViewOnSignature<void>}
     */
    this.un;

    options = Object.assign({}, options);

    /**
     * @private
     * @type {Array<number>}
     */
    this.hints_ = [0, 0];

    /**
     * @private
     * @type {Array<Array<Animation>>}
     */
    this.animations_ = [];

    /**
     * @private
     * @type {number|undefined}
     */
    this.updateAnimationKey_;

    /**
     * @private
     * @const
     * @type {import("./proj/Projection.js").default}
     */
    this.projection_ = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.createProjection)(options.projection, 'EPSG:3857');

    /**
     * @private
     * @type {import("./size.js").Size}
     */
    this.viewportSize_ = [100, 100];

    /**
     * @private
     * @type {import("./coordinate.js").Coordinate|undefined}
     */
    this.targetCenter_ = null;

    /**
     * @private
     * @type {number|undefined}
     */
    this.targetResolution_;

    /**
     * @private
     * @type {number|undefined}
     */
    this.targetRotation_;

    /**
     * @private
     * @type {import("./coordinate.js").Coordinate}
     */
    this.nextCenter_ = null;

    /**
     * @private
     * @type {number}
     */
    this.nextResolution_;

    /**
     * @private
     * @type {number}
     */
    this.nextRotation_;

    /**
     * @private
     * @type {import("./coordinate.js").Coordinate|undefined}
     */
    this.cancelAnchor_ = undefined;

    if (options.projection) {
      (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.disableCoordinateWarning)();
    }
    if (options.center) {
      options.center = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.fromUserCoordinate)(options.center, this.projection_);
    }
    if (options.extent) {
      options.extent = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.fromUserExtent)(options.extent, this.projection_);
    }

    this.applyOptions_(options);
  }

  /**
   * Set up the view with the given options.
   * @param {ViewOptions} options View options.
   */
  applyOptions_(options) {
    const properties = Object.assign({}, options);
    for (const key in _ViewProperty_js__WEBPACK_IMPORTED_MODULE_2__["default"]) {
      delete properties[key];
    }
    this.setProperties(properties, true);

    const resolutionConstraintInfo = createResolutionConstraint(options);

    /**
     * @private
     * @type {number}
     */
    this.maxResolution_ = resolutionConstraintInfo.maxResolution;

    /**
     * @private
     * @type {number}
     */
    this.minResolution_ = resolutionConstraintInfo.minResolution;

    /**
     * @private
     * @type {number}
     */
    this.zoomFactor_ = resolutionConstraintInfo.zoomFactor;

    /**
     * @private
     * @type {Array<number>|undefined}
     */
    this.resolutions_ = options.resolutions;

    /**
     * @type {Array<number>|undefined}
     * @private
     */
    this.padding_ = options.padding;

    /**
     * @private
     * @type {number}
     */
    this.minZoom_ = resolutionConstraintInfo.minZoom;

    const centerConstraint = createCenterConstraint(options);
    const resolutionConstraint = resolutionConstraintInfo.constraint;
    const rotationConstraint = createRotationConstraint(options);

    /**
     * @private
     * @type {Constraints}
     */
    this.constraints_ = {
      center: centerConstraint,
      resolution: resolutionConstraint,
      rotation: rotationConstraint,
    };

    this.setRotation(options.rotation !== undefined ? options.rotation : 0);
    this.setCenterInternal(
      options.center !== undefined ? options.center : null
    );
    if (options.resolution !== undefined) {
      this.setResolution(options.resolution);
    } else if (options.zoom !== undefined) {
      this.setZoom(options.zoom);
    }
  }

  /**
   * Padding (in css pixels).
   * If the map viewport is partially covered with other content (overlays) along
   * its edges, this setting allows to shift the center of the viewport away from that
   * content. The order of the values in the array is top, right, bottom, left.
   * The default is no padding, which is equivalent to `[0, 0, 0, 0]`.
   * @type {Array<number>|undefined}
   * @api
   */
  get padding() {
    return this.padding_;
  }
  set padding(padding) {
    let oldPadding = this.padding_;
    this.padding_ = padding;
    const center = this.getCenterInternal();
    if (center) {
      const newPadding = padding || [0, 0, 0, 0];
      oldPadding = oldPadding || [0, 0, 0, 0];
      const resolution = this.getResolution();
      const offsetX =
        (resolution / 2) *
        (newPadding[3] - oldPadding[3] + oldPadding[1] - newPadding[1]);
      const offsetY =
        (resolution / 2) *
        (newPadding[0] - oldPadding[0] + oldPadding[2] - newPadding[2]);
      this.setCenterInternal([center[0] + offsetX, center[1] - offsetY]);
    }
  }

  /**
   * Get an updated version of the view options used to construct the view.  The
   * current resolution (or zoom), center, and rotation are applied to any stored
   * options.  The provided options can be used to apply new min/max zoom or
   * resolution limits.
   * @param {ViewOptions} newOptions New options to be applied.
   * @return {ViewOptions} New options updated with the current view state.
   */
  getUpdatedOptions_(newOptions) {
    const options = this.getProperties();

    // preserve resolution (or zoom)
    if (options.resolution !== undefined) {
      options.resolution = this.getResolution();
    } else {
      options.zoom = this.getZoom();
    }

    // preserve center
    options.center = this.getCenterInternal();

    // preserve rotation
    options.rotation = this.getRotation();

    return Object.assign({}, options, newOptions);
  }

  /**
   * Animate the view.  The view's center, zoom (or resolution), and rotation
   * can be animated for smooth transitions between view states.  For example,
   * to animate the view to a new zoom level:
   *
   *     view.animate({zoom: view.getZoom() + 1});
   *
   * By default, the animation lasts one second and uses in-and-out easing.  You
   * can customize this behavior by including `duration` (in milliseconds) and
   * `easing` options (see {@link module:ol/easing}).
   *
   * To chain together multiple animations, call the method with multiple
   * animation objects.  For example, to first zoom and then pan:
   *
   *     view.animate({zoom: 10}, {center: [0, 0]});
   *
   * If you provide a function as the last argument to the animate method, it
   * will get called at the end of an animation series.  The callback will be
   * called with `true` if the animation series completed on its own or `false`
   * if it was cancelled.
   *
   * Animations are cancelled by user interactions (e.g. dragging the map) or by
   * calling `view.setCenter()`, `view.setResolution()`, or `view.setRotation()`
   * (or another method that calls one of these).
   *
   * @param {...(AnimationOptions|function(boolean): void)} var_args Animation
   *     options.  Multiple animations can be run in series by passing multiple
   *     options objects.  To run multiple animations in parallel, call the method
   *     multiple times.  An optional callback can be provided as a final
   *     argument.  The callback will be called with a boolean indicating whether
   *     the animation completed without being cancelled.
   * @api
   */
  animate(var_args) {
    if (this.isDef() && !this.getAnimating()) {
      this.resolveConstraints(0);
    }
    const args = new Array(arguments.length);
    for (let i = 0; i < args.length; ++i) {
      let options = arguments[i];
      if (options.center) {
        options = Object.assign({}, options);
        options.center = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.fromUserCoordinate)(
          options.center,
          this.getProjection()
        );
      }
      if (options.anchor) {
        options = Object.assign({}, options);
        options.anchor = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.fromUserCoordinate)(
          options.anchor,
          this.getProjection()
        );
      }
      args[i] = options;
    }
    this.animateInternal.apply(this, args);
  }

  /**
   * @param {...(AnimationOptions|function(boolean): void)} var_args Animation options.
   */
  animateInternal(var_args) {
    let animationCount = arguments.length;
    let callback;
    if (
      animationCount > 1 &&
      typeof arguments[animationCount - 1] === 'function'
    ) {
      callback = arguments[animationCount - 1];
      --animationCount;
    }

    let i = 0;
    for (; i < animationCount && !this.isDef(); ++i) {
      // if view properties are not yet set, shortcut to the final state
      const state = arguments[i];
      if (state.center) {
        this.setCenterInternal(state.center);
      }
      if (state.zoom !== undefined) {
        this.setZoom(state.zoom);
      } else if (state.resolution) {
        this.setResolution(state.resolution);
      }
      if (state.rotation !== undefined) {
        this.setRotation(state.rotation);
      }
    }
    if (i === animationCount) {
      if (callback) {
        animationCallback(callback, true);
      }
      return;
    }

    let start = Date.now();
    let center = this.targetCenter_.slice();
    let resolution = this.targetResolution_;
    let rotation = this.targetRotation_;
    const series = [];
    for (; i < animationCount; ++i) {
      const options = /** @type {AnimationOptions} */ (arguments[i]);

      const animation = {
        start: start,
        complete: false,
        anchor: options.anchor,
        duration: options.duration !== undefined ? options.duration : 1000,
        easing: options.easing || _easing_js__WEBPACK_IMPORTED_MODULE_3__.inAndOut,
        callback: callback,
      };

      if (options.center) {
        animation.sourceCenter = center;
        animation.targetCenter = options.center.slice();
        center = animation.targetCenter;
      }

      if (options.zoom !== undefined) {
        animation.sourceResolution = resolution;
        animation.targetResolution = this.getResolutionForZoom(options.zoom);
        resolution = animation.targetResolution;
      } else if (options.resolution) {
        animation.sourceResolution = resolution;
        animation.targetResolution = options.resolution;
        resolution = animation.targetResolution;
      }

      if (options.rotation !== undefined) {
        animation.sourceRotation = rotation;
        const delta =
          (0,_math_js__WEBPACK_IMPORTED_MODULE_4__.modulo)(options.rotation - rotation + Math.PI, 2 * Math.PI) - Math.PI;
        animation.targetRotation = rotation + delta;
        rotation = animation.targetRotation;
      }

      // check if animation is a no-op
      if (isNoopAnimation(animation)) {
        animation.complete = true;
        // we still push it onto the series for callback handling
      } else {
        start += animation.duration;
      }
      series.push(animation);
    }
    this.animations_.push(series);
    this.setHint(_ViewHint_js__WEBPACK_IMPORTED_MODULE_5__["default"].ANIMATING, 1);
    this.updateAnimations_();
  }

  /**
   * Determine if the view is being animated.
   * @return {boolean} The view is being animated.
   * @api
   */
  getAnimating() {
    return this.hints_[_ViewHint_js__WEBPACK_IMPORTED_MODULE_5__["default"].ANIMATING] > 0;
  }

  /**
   * Determine if the user is interacting with the view, such as panning or zooming.
   * @return {boolean} The view is being interacted with.
   * @api
   */
  getInteracting() {
    return this.hints_[_ViewHint_js__WEBPACK_IMPORTED_MODULE_5__["default"].INTERACTING] > 0;
  }

  /**
   * Cancel any ongoing animations.
   * @api
   */
  cancelAnimations() {
    this.setHint(_ViewHint_js__WEBPACK_IMPORTED_MODULE_5__["default"].ANIMATING, -this.hints_[_ViewHint_js__WEBPACK_IMPORTED_MODULE_5__["default"].ANIMATING]);
    let anchor;
    for (let i = 0, ii = this.animations_.length; i < ii; ++i) {
      const series = this.animations_[i];
      if (series[0].callback) {
        animationCallback(series[0].callback, false);
      }
      if (!anchor) {
        for (let j = 0, jj = series.length; j < jj; ++j) {
          const animation = series[j];
          if (!animation.complete) {
            anchor = animation.anchor;
            break;
          }
        }
      }
    }
    this.animations_.length = 0;
    this.cancelAnchor_ = anchor;
    this.nextCenter_ = null;
    this.nextResolution_ = NaN;
    this.nextRotation_ = NaN;
  }

  /**
   * Update all animations.
   */
  updateAnimations_() {
    if (this.updateAnimationKey_ !== undefined) {
      cancelAnimationFrame(this.updateAnimationKey_);
      this.updateAnimationKey_ = undefined;
    }
    if (!this.getAnimating()) {
      return;
    }
    const now = Date.now();
    let more = false;
    for (let i = this.animations_.length - 1; i >= 0; --i) {
      const series = this.animations_[i];
      let seriesComplete = true;
      for (let j = 0, jj = series.length; j < jj; ++j) {
        const animation = series[j];
        if (animation.complete) {
          continue;
        }
        const elapsed = now - animation.start;
        let fraction =
          animation.duration > 0 ? elapsed / animation.duration : 1;
        if (fraction >= 1) {
          animation.complete = true;
          fraction = 1;
        } else {
          seriesComplete = false;
        }
        const progress = animation.easing(fraction);
        if (animation.sourceCenter) {
          const x0 = animation.sourceCenter[0];
          const y0 = animation.sourceCenter[1];
          const x1 = animation.targetCenter[0];
          const y1 = animation.targetCenter[1];
          this.nextCenter_ = animation.targetCenter;
          const x = x0 + progress * (x1 - x0);
          const y = y0 + progress * (y1 - y0);
          this.targetCenter_ = [x, y];
        }
        if (animation.sourceResolution && animation.targetResolution) {
          const resolution =
            progress === 1
              ? animation.targetResolution
              : animation.sourceResolution +
                progress *
                  (animation.targetResolution - animation.sourceResolution);
          if (animation.anchor) {
            const size = this.getViewportSize_(this.getRotation());
            const constrainedResolution = this.constraints_.resolution(
              resolution,
              0,
              size,
              true
            );
            this.targetCenter_ = this.calculateCenterZoom(
              constrainedResolution,
              animation.anchor
            );
          }
          this.nextResolution_ = animation.targetResolution;
          this.targetResolution_ = resolution;
          this.applyTargetState_(true);
        }
        if (
          animation.sourceRotation !== undefined &&
          animation.targetRotation !== undefined
        ) {
          const rotation =
            progress === 1
              ? (0,_math_js__WEBPACK_IMPORTED_MODULE_4__.modulo)(animation.targetRotation + Math.PI, 2 * Math.PI) -
                Math.PI
              : animation.sourceRotation +
                progress *
                  (animation.targetRotation - animation.sourceRotation);
          if (animation.anchor) {
            const constrainedRotation = this.constraints_.rotation(
              rotation,
              true
            );
            this.targetCenter_ = this.calculateCenterRotate(
              constrainedRotation,
              animation.anchor
            );
          }
          this.nextRotation_ = animation.targetRotation;
          this.targetRotation_ = rotation;
        }
        this.applyTargetState_(true);
        more = true;
        if (!animation.complete) {
          break;
        }
      }
      if (seriesComplete) {
        this.animations_[i] = null;
        this.setHint(_ViewHint_js__WEBPACK_IMPORTED_MODULE_5__["default"].ANIMATING, -1);
        this.nextCenter_ = null;
        this.nextResolution_ = NaN;
        this.nextRotation_ = NaN;
        const callback = series[0].callback;
        if (callback) {
          animationCallback(callback, true);
        }
      }
    }
    // prune completed series
    this.animations_ = this.animations_.filter(Boolean);
    if (more && this.updateAnimationKey_ === undefined) {
      this.updateAnimationKey_ = requestAnimationFrame(
        this.updateAnimations_.bind(this)
      );
    }
  }

  /**
   * @param {number} rotation Target rotation.
   * @param {import("./coordinate.js").Coordinate} anchor Rotation anchor.
   * @return {import("./coordinate.js").Coordinate|undefined} Center for rotation and anchor.
   */
  calculateCenterRotate(rotation, anchor) {
    let center;
    const currentCenter = this.getCenterInternal();
    if (currentCenter !== undefined) {
      center = [currentCenter[0] - anchor[0], currentCenter[1] - anchor[1]];
      (0,_coordinate_js__WEBPACK_IMPORTED_MODULE_6__.rotate)(center, rotation - this.getRotation());
      (0,_coordinate_js__WEBPACK_IMPORTED_MODULE_6__.add)(center, anchor);
    }
    return center;
  }

  /**
   * @param {number} resolution Target resolution.
   * @param {import("./coordinate.js").Coordinate} anchor Zoom anchor.
   * @return {import("./coordinate.js").Coordinate|undefined} Center for resolution and anchor.
   */
  calculateCenterZoom(resolution, anchor) {
    let center;
    const currentCenter = this.getCenterInternal();
    const currentResolution = this.getResolution();
    if (currentCenter !== undefined && currentResolution !== undefined) {
      const x =
        anchor[0] -
        (resolution * (anchor[0] - currentCenter[0])) / currentResolution;
      const y =
        anchor[1] -
        (resolution * (anchor[1] - currentCenter[1])) / currentResolution;
      center = [x, y];
    }
    return center;
  }

  /**
   * Returns the current viewport size.
   * @private
   * @param {number} [rotation] Take into account the rotation of the viewport when giving the size
   * @return {import("./size.js").Size} Viewport size or `[100, 100]` when no viewport is found.
   */
  getViewportSize_(rotation) {
    const size = this.viewportSize_;
    if (rotation) {
      const w = size[0];
      const h = size[1];
      return [
        Math.abs(w * Math.cos(rotation)) + Math.abs(h * Math.sin(rotation)),
        Math.abs(w * Math.sin(rotation)) + Math.abs(h * Math.cos(rotation)),
      ];
    }
    return size;
  }

  /**
   * Stores the viewport size on the view. The viewport size is not read every time from the DOM
   * to avoid performance hit and layout reflow.
   * This should be done on map size change.
   * Note: the constraints are not resolved during an animation to avoid stopping it
   * @param {import("./size.js").Size} [size] Viewport size; if undefined, [100, 100] is assumed
   */
  setViewportSize(size) {
    this.viewportSize_ = Array.isArray(size) ? size.slice() : [100, 100];
    if (!this.getAnimating()) {
      this.resolveConstraints(0);
    }
  }

  /**
   * Get the view center.
   * @return {import("./coordinate.js").Coordinate|undefined} The center of the view.
   * @observable
   * @api
   */
  getCenter() {
    const center = this.getCenterInternal();
    if (!center) {
      return center;
    }
    return (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.toUserCoordinate)(center, this.getProjection());
  }

  /**
   * Get the view center without transforming to user projection.
   * @return {import("./coordinate.js").Coordinate|undefined} The center of the view.
   */
  getCenterInternal() {
    return /** @type {import("./coordinate.js").Coordinate|undefined} */ (
      this.get(_ViewProperty_js__WEBPACK_IMPORTED_MODULE_2__["default"].CENTER)
    );
  }

  /**
   * @return {Constraints} Constraints.
   */
  getConstraints() {
    return this.constraints_;
  }

  /**
   * @return {boolean} Resolution constraint is set
   */
  getConstrainResolution() {
    return this.get('constrainResolution');
  }

  /**
   * @param {Array<number>} [hints] Destination array.
   * @return {Array<number>} Hint.
   */
  getHints(hints) {
    if (hints !== undefined) {
      hints[0] = this.hints_[0];
      hints[1] = this.hints_[1];
      return hints;
    }
    return this.hints_.slice();
  }

  /**
   * Calculate the extent for the current view state and the passed size.
   * The size is the pixel dimensions of the box into which the calculated extent
   * should fit. In most cases you want to get the extent of the entire map,
   * that is `map.getSize()`.
   * @param {import("./size.js").Size} [size] Box pixel size. If not provided, the size
   * of the map that uses this view will be used.
   * @return {import("./extent.js").Extent} Extent.
   * @api
   */
  calculateExtent(size) {
    const extent = this.calculateExtentInternal(size);
    return (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.toUserExtent)(extent, this.getProjection());
  }

  /**
   * @param {import("./size.js").Size} [size] Box pixel size. If not provided,
   * the map's last known viewport size will be used.
   * @return {import("./extent.js").Extent} Extent.
   */
  calculateExtentInternal(size) {
    size = size || this.getViewportSizeMinusPadding_();
    const center = /** @type {!import("./coordinate.js").Coordinate} */ (
      this.getCenterInternal()
    );
    (0,_asserts_js__WEBPACK_IMPORTED_MODULE_7__.assert)(center, 'The view center is not defined');
    const resolution = /** @type {!number} */ (this.getResolution());
    (0,_asserts_js__WEBPACK_IMPORTED_MODULE_7__.assert)(resolution !== undefined, 'The view resolution is not defined');
    const rotation = /** @type {!number} */ (this.getRotation());
    (0,_asserts_js__WEBPACK_IMPORTED_MODULE_7__.assert)(rotation !== undefined, 'The view rotation is not defined');

    return (0,_extent_js__WEBPACK_IMPORTED_MODULE_8__.getForViewAndSize)(center, resolution, rotation, size);
  }

  /**
   * Get the maximum resolution of the view.
   * @return {number} The maximum resolution of the view.
   * @api
   */
  getMaxResolution() {
    return this.maxResolution_;
  }

  /**
   * Get the minimum resolution of the view.
   * @return {number} The minimum resolution of the view.
   * @api
   */
  getMinResolution() {
    return this.minResolution_;
  }

  /**
   * Get the maximum zoom level for the view.
   * @return {number} The maximum zoom level.
   * @api
   */
  getMaxZoom() {
    return /** @type {number} */ (
      this.getZoomForResolution(this.minResolution_)
    );
  }

  /**
   * Set a new maximum zoom level for the view.
   * @param {number} zoom The maximum zoom level.
   * @api
   */
  setMaxZoom(zoom) {
    this.applyOptions_(this.getUpdatedOptions_({maxZoom: zoom}));
  }

  /**
   * Get the minimum zoom level for the view.
   * @return {number} The minimum zoom level.
   * @api
   */
  getMinZoom() {
    return /** @type {number} */ (
      this.getZoomForResolution(this.maxResolution_)
    );
  }

  /**
   * Set a new minimum zoom level for the view.
   * @param {number} zoom The minimum zoom level.
   * @api
   */
  setMinZoom(zoom) {
    this.applyOptions_(this.getUpdatedOptions_({minZoom: zoom}));
  }

  /**
   * Set whether the view should allow intermediary zoom levels.
   * @param {boolean} enabled Whether the resolution is constrained.
   * @api
   */
  setConstrainResolution(enabled) {
    this.applyOptions_(this.getUpdatedOptions_({constrainResolution: enabled}));
  }

  /**
   * Get the view projection.
   * @return {import("./proj/Projection.js").default} The projection of the view.
   * @api
   */
  getProjection() {
    return this.projection_;
  }

  /**
   * Get the view resolution.
   * @return {number|undefined} The resolution of the view.
   * @observable
   * @api
   */
  getResolution() {
    return /** @type {number|undefined} */ (this.get(_ViewProperty_js__WEBPACK_IMPORTED_MODULE_2__["default"].RESOLUTION));
  }

  /**
   * Get the resolutions for the view. This returns the array of resolutions
   * passed to the constructor of the View, or undefined if none were given.
   * @return {Array<number>|undefined} The resolutions of the view.
   * @api
   */
  getResolutions() {
    return this.resolutions_;
  }

  /**
   * Get the resolution for a provided extent (in map units) and size (in pixels).
   * @param {import("./extent.js").Extent} extent Extent.
   * @param {import("./size.js").Size} [size] Box pixel size.
   * @return {number} The resolution at which the provided extent will render at
   *     the given size.
   * @api
   */
  getResolutionForExtent(extent, size) {
    return this.getResolutionForExtentInternal(
      (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.fromUserExtent)(extent, this.getProjection()),
      size
    );
  }

  /**
   * Get the resolution for a provided extent (in map units) and size (in pixels).
   * @param {import("./extent.js").Extent} extent Extent.
   * @param {import("./size.js").Size} [size] Box pixel size.
   * @return {number} The resolution at which the provided extent will render at
   *     the given size.
   */
  getResolutionForExtentInternal(extent, size) {
    size = size || this.getViewportSizeMinusPadding_();
    const xResolution = (0,_extent_js__WEBPACK_IMPORTED_MODULE_8__.getWidth)(extent) / size[0];
    const yResolution = (0,_extent_js__WEBPACK_IMPORTED_MODULE_8__.getHeight)(extent) / size[1];
    return Math.max(xResolution, yResolution);
  }

  /**
   * Return a function that returns a value between 0 and 1 for a
   * resolution. Exponential scaling is assumed.
   * @param {number} [power] Power.
   * @return {function(number): number} Resolution for value function.
   */
  getResolutionForValueFunction(power) {
    power = power || 2;
    const maxResolution = this.getConstrainedResolution(this.maxResolution_);
    const minResolution = this.minResolution_;
    const max = Math.log(maxResolution / minResolution) / Math.log(power);
    return (
      /**
       * @param {number} value Value.
       * @return {number} Resolution.
       */
      function (value) {
        const resolution = maxResolution / Math.pow(power, value * max);
        return resolution;
      }
    );
  }

  /**
   * Get the view rotation.
   * @return {number} The rotation of the view in radians.
   * @observable
   * @api
   */
  getRotation() {
    return /** @type {number} */ (this.get(_ViewProperty_js__WEBPACK_IMPORTED_MODULE_2__["default"].ROTATION));
  }

  /**
   * Return a function that returns a resolution for a value between
   * 0 and 1. Exponential scaling is assumed.
   * @param {number} [power] Power.
   * @return {function(number): number} Value for resolution function.
   */
  getValueForResolutionFunction(power) {
    const logPower = Math.log(power || 2);
    const maxResolution = this.getConstrainedResolution(this.maxResolution_);
    const minResolution = this.minResolution_;
    const max = Math.log(maxResolution / minResolution) / logPower;
    return (
      /**
       * @param {number} resolution Resolution.
       * @return {number} Value.
       */
      function (resolution) {
        const value = Math.log(maxResolution / resolution) / logPower / max;
        return value;
      }
    );
  }

  /**
   * Returns the size of the viewport minus padding.
   * @private
   * @param {number} [rotation] Take into account the rotation of the viewport when giving the size
   * @return {import("./size.js").Size} Viewport size reduced by the padding.
   */
  getViewportSizeMinusPadding_(rotation) {
    let size = this.getViewportSize_(rotation);
    const padding = this.padding_;
    if (padding) {
      size = [
        size[0] - padding[1] - padding[3],
        size[1] - padding[0] - padding[2],
      ];
    }
    return size;
  }

  /**
   * @return {State} View state.
   */
  getState() {
    const projection = this.getProjection();
    const resolution = this.getResolution();
    const rotation = this.getRotation();
    let center = /** @type {import("./coordinate.js").Coordinate} */ (
      this.getCenterInternal()
    );
    const padding = this.padding_;
    if (padding) {
      const reducedSize = this.getViewportSizeMinusPadding_();
      center = calculateCenterOn(
        center,
        this.getViewportSize_(),
        [reducedSize[0] / 2 + padding[3], reducedSize[1] / 2 + padding[0]],
        resolution,
        rotation
      );
    }
    return {
      center: center.slice(0),
      projection: projection !== undefined ? projection : null,
      resolution: resolution,
      nextCenter: this.nextCenter_,
      nextResolution: this.nextResolution_,
      nextRotation: this.nextRotation_,
      rotation: rotation,
      zoom: this.getZoom(),
    };
  }

  /**
   * @return {ViewStateLayerStateExtent} Like `FrameState`, but just `viewState` and `extent`.
   */
  getViewStateAndExtent() {
    return {
      viewState: this.getState(),
      extent: this.calculateExtent(),
    };
  }

  /**
   * Get the current zoom level. This method may return non-integer zoom levels
   * if the view does not constrain the resolution, or if an interaction or
   * animation is underway.
   * @return {number|undefined} Zoom.
   * @api
   */
  getZoom() {
    let zoom;
    const resolution = this.getResolution();
    if (resolution !== undefined) {
      zoom = this.getZoomForResolution(resolution);
    }
    return zoom;
  }

  /**
   * Get the zoom level for a resolution.
   * @param {number} resolution The resolution.
   * @return {number|undefined} The zoom level for the provided resolution.
   * @api
   */
  getZoomForResolution(resolution) {
    let offset = this.minZoom_ || 0;
    let max, zoomFactor;
    if (this.resolutions_) {
      const nearest = (0,_array_js__WEBPACK_IMPORTED_MODULE_9__.linearFindNearest)(this.resolutions_, resolution, 1);
      offset = nearest;
      max = this.resolutions_[nearest];
      if (nearest == this.resolutions_.length - 1) {
        zoomFactor = 2;
      } else {
        zoomFactor = max / this.resolutions_[nearest + 1];
      }
    } else {
      max = this.maxResolution_;
      zoomFactor = this.zoomFactor_;
    }
    return offset + Math.log(max / resolution) / Math.log(zoomFactor);
  }

  /**
   * Get the resolution for a zoom level.
   * @param {number} zoom Zoom level.
   * @return {number} The view resolution for the provided zoom level.
   * @api
   */
  getResolutionForZoom(zoom) {
    if (this.resolutions_) {
      if (this.resolutions_.length <= 1) {
        return 0;
      }
      const baseLevel = (0,_math_js__WEBPACK_IMPORTED_MODULE_4__.clamp)(
        Math.floor(zoom),
        0,
        this.resolutions_.length - 2
      );
      const zoomFactor =
        this.resolutions_[baseLevel] / this.resolutions_[baseLevel + 1];
      return (
        this.resolutions_[baseLevel] /
        Math.pow(zoomFactor, (0,_math_js__WEBPACK_IMPORTED_MODULE_4__.clamp)(zoom - baseLevel, 0, 1))
      );
    }
    return (
      this.maxResolution_ / Math.pow(this.zoomFactor_, zoom - this.minZoom_)
    );
  }

  /**
   * Fit the given geometry or extent based on the given map size and border.
   * The size is pixel dimensions of the box to fit the extent into.
   * In most cases you will want to use the map size, that is `map.getSize()`.
   * Takes care of the map angle.
   * @param {import("./geom/SimpleGeometry.js").default|import("./extent.js").Extent} geometryOrExtent The geometry or
   *     extent to fit the view to.
   * @param {FitOptions} [options] Options.
   * @api
   */
  fit(geometryOrExtent, options) {
    /** @type {import("./geom/SimpleGeometry.js").default} */
    let geometry;
    (0,_asserts_js__WEBPACK_IMPORTED_MODULE_7__.assert)(
      Array.isArray(geometryOrExtent) ||
        typeof (/** @type {?} */ (geometryOrExtent).getSimplifiedGeometry) ===
          'function',
      'Invalid extent or geometry provided as `geometry`'
    );
    if (Array.isArray(geometryOrExtent)) {
      (0,_asserts_js__WEBPACK_IMPORTED_MODULE_7__.assert)(
        !(0,_extent_js__WEBPACK_IMPORTED_MODULE_8__.isEmpty)(geometryOrExtent),
        'Cannot fit empty extent provided as `geometry`'
      );
      const extent = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.fromUserExtent)(geometryOrExtent, this.getProjection());
      geometry = (0,_geom_Polygon_js__WEBPACK_IMPORTED_MODULE_10__.fromExtent)(extent);
    } else if (geometryOrExtent.getType() === 'Circle') {
      const extent = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.fromUserExtent)(
        geometryOrExtent.getExtent(),
        this.getProjection()
      );
      geometry = (0,_geom_Polygon_js__WEBPACK_IMPORTED_MODULE_10__.fromExtent)(extent);
      geometry.rotate(this.getRotation(), (0,_extent_js__WEBPACK_IMPORTED_MODULE_8__.getCenter)(extent));
    } else {
      const userProjection = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.getUserProjection)();
      if (userProjection) {
        geometry = /** @type {import("./geom/SimpleGeometry.js").default} */ (
          geometryOrExtent
            .clone()
            .transform(userProjection, this.getProjection())
        );
      } else {
        geometry = geometryOrExtent;
      }
    }

    this.fitInternal(geometry, options);
  }

  /**
   * Calculate rotated extent
   * @param {import("./geom/SimpleGeometry.js").default} geometry The geometry.
   * @return {import("./extent").Extent} The rotated extent for the geometry.
   */
  rotatedExtentForGeometry(geometry) {
    const rotation = this.getRotation();
    const cosAngle = Math.cos(rotation);
    const sinAngle = Math.sin(-rotation);
    const coords = geometry.getFlatCoordinates();
    const stride = geometry.getStride();
    let minRotX = +Infinity;
    let minRotY = +Infinity;
    let maxRotX = -Infinity;
    let maxRotY = -Infinity;
    for (let i = 0, ii = coords.length; i < ii; i += stride) {
      const rotX = coords[i] * cosAngle - coords[i + 1] * sinAngle;
      const rotY = coords[i] * sinAngle + coords[i + 1] * cosAngle;
      minRotX = Math.min(minRotX, rotX);
      minRotY = Math.min(minRotY, rotY);
      maxRotX = Math.max(maxRotX, rotX);
      maxRotY = Math.max(maxRotY, rotY);
    }
    return [minRotX, minRotY, maxRotX, maxRotY];
  }

  /**
   * @param {import("./geom/SimpleGeometry.js").default} geometry The geometry.
   * @param {FitOptions} [options] Options.
   */
  fitInternal(geometry, options) {
    options = options || {};
    let size = options.size;
    if (!size) {
      size = this.getViewportSizeMinusPadding_();
    }
    const padding =
      options.padding !== undefined ? options.padding : [0, 0, 0, 0];
    const nearest = options.nearest !== undefined ? options.nearest : false;
    let minResolution;
    if (options.minResolution !== undefined) {
      minResolution = options.minResolution;
    } else if (options.maxZoom !== undefined) {
      minResolution = this.getResolutionForZoom(options.maxZoom);
    } else {
      minResolution = 0;
    }

    const rotatedExtent = this.rotatedExtentForGeometry(geometry);

    // calculate resolution
    let resolution = this.getResolutionForExtentInternal(rotatedExtent, [
      size[0] - padding[1] - padding[3],
      size[1] - padding[0] - padding[2],
    ]);
    resolution = isNaN(resolution)
      ? minResolution
      : Math.max(resolution, minResolution);
    resolution = this.getConstrainedResolution(resolution, nearest ? 0 : 1);

    // calculate center
    const rotation = this.getRotation();
    const sinAngle = Math.sin(rotation);
    const cosAngle = Math.cos(rotation);
    const centerRot = (0,_extent_js__WEBPACK_IMPORTED_MODULE_8__.getCenter)(rotatedExtent);
    centerRot[0] += ((padding[1] - padding[3]) / 2) * resolution;
    centerRot[1] += ((padding[0] - padding[2]) / 2) * resolution;
    const centerX = centerRot[0] * cosAngle - centerRot[1] * sinAngle;
    const centerY = centerRot[1] * cosAngle + centerRot[0] * sinAngle;
    const center = this.getConstrainedCenter([centerX, centerY], resolution);
    const callback = options.callback ? options.callback : _functions_js__WEBPACK_IMPORTED_MODULE_11__.VOID;

    if (options.duration !== undefined) {
      this.animateInternal(
        {
          resolution: resolution,
          center: center,
          duration: options.duration,
          easing: options.easing,
        },
        callback
      );
    } else {
      this.targetResolution_ = resolution;
      this.targetCenter_ = center;
      this.applyTargetState_(false, true);
      animationCallback(callback, true);
    }
  }

  /**
   * Center on coordinate and view position.
   * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("./size.js").Size} size Box pixel size.
   * @param {import("./pixel.js").Pixel} position Position on the view to center on.
   * @api
   */
  centerOn(coordinate, size, position) {
    this.centerOnInternal(
      (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.fromUserCoordinate)(coordinate, this.getProjection()),
      size,
      position
    );
  }

  /**
   * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("./size.js").Size} size Box pixel size.
   * @param {import("./pixel.js").Pixel} position Position on the view to center on.
   */
  centerOnInternal(coordinate, size, position) {
    this.setCenterInternal(
      calculateCenterOn(
        coordinate,
        size,
        position,
        this.getResolution(),
        this.getRotation()
      )
    );
  }

  /**
   * Calculates the shift between map and viewport center.
   * @param {import("./coordinate.js").Coordinate} center Center.
   * @param {number} resolution Resolution.
   * @param {number} rotation Rotation.
   * @param {import("./size.js").Size} size Size.
   * @return {Array<number>|undefined} Center shift.
   */
  calculateCenterShift(center, resolution, rotation, size) {
    let centerShift;
    const padding = this.padding_;
    if (padding && center) {
      const reducedSize = this.getViewportSizeMinusPadding_(-rotation);
      const shiftedCenter = calculateCenterOn(
        center,
        size,
        [reducedSize[0] / 2 + padding[3], reducedSize[1] / 2 + padding[0]],
        resolution,
        rotation
      );
      centerShift = [
        center[0] - shiftedCenter[0],
        center[1] - shiftedCenter[1],
      ];
    }
    return centerShift;
  }

  /**
   * @return {boolean} Is defined.
   */
  isDef() {
    return !!this.getCenterInternal() && this.getResolution() !== undefined;
  }

  /**
   * Adds relative coordinates to the center of the view. Any extent constraint will apply.
   * @param {import("./coordinate.js").Coordinate} deltaCoordinates Relative value to add.
   * @api
   */
  adjustCenter(deltaCoordinates) {
    const center = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.toUserCoordinate)(this.targetCenter_, this.getProjection());
    this.setCenter([
      center[0] + deltaCoordinates[0],
      center[1] + deltaCoordinates[1],
    ]);
  }

  /**
   * Adds relative coordinates to the center of the view. Any extent constraint will apply.
   * @param {import("./coordinate.js").Coordinate} deltaCoordinates Relative value to add.
   */
  adjustCenterInternal(deltaCoordinates) {
    const center = this.targetCenter_;
    this.setCenterInternal([
      center[0] + deltaCoordinates[0],
      center[1] + deltaCoordinates[1],
    ]);
  }

  /**
   * Multiply the view resolution by a ratio, optionally using an anchor. Any resolution
   * constraint will apply.
   * @param {number} ratio The ratio to apply on the view resolution.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   * @api
   */
  adjustResolution(ratio, anchor) {
    anchor = anchor && (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.fromUserCoordinate)(anchor, this.getProjection());
    this.adjustResolutionInternal(ratio, anchor);
  }

  /**
   * Multiply the view resolution by a ratio, optionally using an anchor. Any resolution
   * constraint will apply.
   * @param {number} ratio The ratio to apply on the view resolution.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   */
  adjustResolutionInternal(ratio, anchor) {
    const isMoving = this.getAnimating() || this.getInteracting();
    const size = this.getViewportSize_(this.getRotation());
    const newResolution = this.constraints_.resolution(
      this.targetResolution_ * ratio,
      0,
      size,
      isMoving
    );

    if (anchor) {
      this.targetCenter_ = this.calculateCenterZoom(newResolution, anchor);
    }

    this.targetResolution_ *= ratio;
    this.applyTargetState_();
  }

  /**
   * Adds a value to the view zoom level, optionally using an anchor. Any resolution
   * constraint will apply.
   * @param {number} delta Relative value to add to the zoom level.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   * @api
   */
  adjustZoom(delta, anchor) {
    this.adjustResolution(Math.pow(this.zoomFactor_, -delta), anchor);
  }

  /**
   * Adds a value to the view rotation, optionally using an anchor. Any rotation
   * constraint will apply.
   * @param {number} delta Relative value to add to the zoom rotation, in radians.
   * @param {import("./coordinate.js").Coordinate} [anchor] The rotation center.
   * @api
   */
  adjustRotation(delta, anchor) {
    if (anchor) {
      anchor = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.fromUserCoordinate)(anchor, this.getProjection());
    }
    this.adjustRotationInternal(delta, anchor);
  }

  /**
   * @param {number} delta Relative value to add to the zoom rotation, in radians.
   * @param {import("./coordinate.js").Coordinate} [anchor] The rotation center.
   */
  adjustRotationInternal(delta, anchor) {
    const isMoving = this.getAnimating() || this.getInteracting();
    const newRotation = this.constraints_.rotation(
      this.targetRotation_ + delta,
      isMoving
    );
    if (anchor) {
      this.targetCenter_ = this.calculateCenterRotate(newRotation, anchor);
    }
    this.targetRotation_ += delta;
    this.applyTargetState_();
  }

  /**
   * Set the center of the current view. Any extent constraint will apply.
   * @param {import("./coordinate.js").Coordinate|undefined} center The center of the view.
   * @observable
   * @api
   */
  setCenter(center) {
    this.setCenterInternal(
      center ? (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.fromUserCoordinate)(center, this.getProjection()) : center
    );
  }

  /**
   * Set the center using the view projection (not the user projection).
   * @param {import("./coordinate.js").Coordinate|undefined} center The center of the view.
   */
  setCenterInternal(center) {
    this.targetCenter_ = center;
    this.applyTargetState_();
  }

  /**
   * @param {import("./ViewHint.js").default} hint Hint.
   * @param {number} delta Delta.
   * @return {number} New value.
   */
  setHint(hint, delta) {
    this.hints_[hint] += delta;
    this.changed();
    return this.hints_[hint];
  }

  /**
   * Set the resolution for this view. Any resolution constraint will apply.
   * @param {number|undefined} resolution The resolution of the view.
   * @observable
   * @api
   */
  setResolution(resolution) {
    this.targetResolution_ = resolution;
    this.applyTargetState_();
  }

  /**
   * Set the rotation for this view. Any rotation constraint will apply.
   * @param {number} rotation The rotation of the view in radians.
   * @observable
   * @api
   */
  setRotation(rotation) {
    this.targetRotation_ = rotation;
    this.applyTargetState_();
  }

  /**
   * Zoom to a specific zoom level. Any resolution constrain will apply.
   * @param {number} zoom Zoom level.
   * @api
   */
  setZoom(zoom) {
    this.setResolution(this.getResolutionForZoom(zoom));
  }

  /**
   * Recompute rotation/resolution/center based on target values.
   * Note: we have to compute rotation first, then resolution and center considering that
   * parameters can influence one another in case a view extent constraint is present.
   * @param {boolean} [doNotCancelAnims] Do not cancel animations.
   * @param {boolean} [forceMoving] Apply constraints as if the view is moving.
   * @private
   */
  applyTargetState_(doNotCancelAnims, forceMoving) {
    const isMoving =
      this.getAnimating() || this.getInteracting() || forceMoving;

    // compute rotation
    const newRotation = this.constraints_.rotation(
      this.targetRotation_,
      isMoving
    );
    const size = this.getViewportSize_(newRotation);
    const newResolution = this.constraints_.resolution(
      this.targetResolution_,
      0,
      size,
      isMoving
    );
    const newCenter = this.constraints_.center(
      this.targetCenter_,
      newResolution,
      size,
      isMoving,
      this.calculateCenterShift(
        this.targetCenter_,
        newResolution,
        newRotation,
        size
      )
    );

    if (this.get(_ViewProperty_js__WEBPACK_IMPORTED_MODULE_2__["default"].ROTATION) !== newRotation) {
      this.set(_ViewProperty_js__WEBPACK_IMPORTED_MODULE_2__["default"].ROTATION, newRotation);
    }
    if (this.get(_ViewProperty_js__WEBPACK_IMPORTED_MODULE_2__["default"].RESOLUTION) !== newResolution) {
      this.set(_ViewProperty_js__WEBPACK_IMPORTED_MODULE_2__["default"].RESOLUTION, newResolution);
      this.set('zoom', this.getZoom(), true);
    }
    if (
      !newCenter ||
      !this.get(_ViewProperty_js__WEBPACK_IMPORTED_MODULE_2__["default"].CENTER) ||
      !(0,_coordinate_js__WEBPACK_IMPORTED_MODULE_6__.equals)(this.get(_ViewProperty_js__WEBPACK_IMPORTED_MODULE_2__["default"].CENTER), newCenter)
    ) {
      this.set(_ViewProperty_js__WEBPACK_IMPORTED_MODULE_2__["default"].CENTER, newCenter);
    }

    if (this.getAnimating() && !doNotCancelAnims) {
      this.cancelAnimations();
    }
    this.cancelAnchor_ = undefined;
  }

  /**
   * If any constraints need to be applied, an animation will be triggered.
   * This is typically done on interaction end.
   * Note: calling this with a duration of 0 will apply the constrained values straight away,
   * without animation.
   * @param {number} [duration] The animation duration in ms.
   * @param {number} [resolutionDirection] Which direction to zoom.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   */
  resolveConstraints(duration, resolutionDirection, anchor) {
    duration = duration !== undefined ? duration : 200;
    const direction = resolutionDirection || 0;

    const newRotation = this.constraints_.rotation(this.targetRotation_);
    const size = this.getViewportSize_(newRotation);
    const newResolution = this.constraints_.resolution(
      this.targetResolution_,
      direction,
      size
    );
    const newCenter = this.constraints_.center(
      this.targetCenter_,
      newResolution,
      size,
      false,
      this.calculateCenterShift(
        this.targetCenter_,
        newResolution,
        newRotation,
        size
      )
    );

    if (duration === 0 && !this.cancelAnchor_) {
      this.targetResolution_ = newResolution;
      this.targetRotation_ = newRotation;
      this.targetCenter_ = newCenter;
      this.applyTargetState_();
      return;
    }

    anchor = anchor || (duration === 0 ? this.cancelAnchor_ : undefined);
    this.cancelAnchor_ = undefined;

    if (
      this.getResolution() !== newResolution ||
      this.getRotation() !== newRotation ||
      !this.getCenterInternal() ||
      !(0,_coordinate_js__WEBPACK_IMPORTED_MODULE_6__.equals)(this.getCenterInternal(), newCenter)
    ) {
      if (this.getAnimating()) {
        this.cancelAnimations();
      }

      this.animateInternal({
        rotation: newRotation,
        center: newCenter,
        resolution: newResolution,
        duration: duration,
        easing: _easing_js__WEBPACK_IMPORTED_MODULE_3__.easeOut,
        anchor: anchor,
      });
    }
  }

  /**
   * Notify the View that an interaction has started.
   * The view state will be resolved to a stable one if needed
   * (depending on its constraints).
   * @api
   */
  beginInteraction() {
    this.resolveConstraints(0);

    this.setHint(_ViewHint_js__WEBPACK_IMPORTED_MODULE_5__["default"].INTERACTING, 1);
  }

  /**
   * Notify the View that an interaction has ended. The view state will be resolved
   * to a stable one if needed (depending on its constraints).
   * @param {number} [duration] Animation duration in ms.
   * @param {number} [resolutionDirection] Which direction to zoom.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   * @api
   */
  endInteraction(duration, resolutionDirection, anchor) {
    anchor = anchor && (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.fromUserCoordinate)(anchor, this.getProjection());
    this.endInteractionInternal(duration, resolutionDirection, anchor);
  }

  /**
   * Notify the View that an interaction has ended. The view state will be resolved
   * to a stable one if needed (depending on its constraints).
   * @param {number} [duration] Animation duration in ms.
   * @param {number} [resolutionDirection] Which direction to zoom.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   */
  endInteractionInternal(duration, resolutionDirection, anchor) {
    if (!this.getInteracting()) {
      return;
    }
    this.setHint(_ViewHint_js__WEBPACK_IMPORTED_MODULE_5__["default"].INTERACTING, -1);
    this.resolveConstraints(duration, resolutionDirection, anchor);
  }

  /**
   * Get a valid position for the view center according to the current constraints.
   * @param {import("./coordinate.js").Coordinate|undefined} targetCenter Target center position.
   * @param {number} [targetResolution] Target resolution. If not supplied, the current one will be used.
   * This is useful to guess a valid center position at a different zoom level.
   * @return {import("./coordinate.js").Coordinate|undefined} Valid center position.
   */
  getConstrainedCenter(targetCenter, targetResolution) {
    const size = this.getViewportSize_(this.getRotation());
    return this.constraints_.center(
      targetCenter,
      targetResolution || this.getResolution(),
      size
    );
  }

  /**
   * Get a valid zoom level according to the current view constraints.
   * @param {number|undefined} targetZoom Target zoom.
   * @param {number} [direction=0] Indicate which resolution should be used
   * by a renderer if the view resolution does not match any resolution of the tile source.
   * If 0, the nearest resolution will be used. If 1, the nearest lower resolution
   * will be used. If -1, the nearest higher resolution will be used.
   * @return {number|undefined} Valid zoom level.
   */
  getConstrainedZoom(targetZoom, direction) {
    const targetRes = this.getResolutionForZoom(targetZoom);
    return this.getZoomForResolution(
      this.getConstrainedResolution(targetRes, direction)
    );
  }

  /**
   * Get a valid resolution according to the current view constraints.
   * @param {number|undefined} targetResolution Target resolution.
   * @param {number} [direction=0] Indicate which resolution should be used
   * by a renderer if the view resolution does not match any resolution of the tile source.
   * If 0, the nearest resolution will be used. If 1, the nearest lower resolution
   * will be used. If -1, the nearest higher resolution will be used.
   * @return {number|undefined} Valid resolution.
   */
  getConstrainedResolution(targetResolution, direction) {
    direction = direction || 0;
    const size = this.getViewportSize_(this.getRotation());

    return this.constraints_.resolution(targetResolution, direction, size);
  }
}

/**
 * @param {Function} callback Callback.
 * @param {*} returnValue Return value.
 */
function animationCallback(callback, returnValue) {
  setTimeout(function () {
    callback(returnValue);
  }, 0);
}

/**
 * @param {ViewOptions} options View options.
 * @return {import("./centerconstraint.js").Type} The constraint.
 */
function createCenterConstraint(options) {
  if (options.extent !== undefined) {
    const smooth =
      options.smoothExtentConstraint !== undefined
        ? options.smoothExtentConstraint
        : true;
    return (0,_centerconstraint_js__WEBPACK_IMPORTED_MODULE_12__.createExtent)(options.extent, options.constrainOnlyCenter, smooth);
  }

  const projection = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.createProjection)(options.projection, 'EPSG:3857');
  if (options.multiWorld !== true && projection.isGlobal()) {
    const extent = projection.getExtent().slice();
    extent[0] = -Infinity;
    extent[2] = Infinity;
    return (0,_centerconstraint_js__WEBPACK_IMPORTED_MODULE_12__.createExtent)(extent, false, false);
  }

  return _centerconstraint_js__WEBPACK_IMPORTED_MODULE_12__.none;
}

/**
 * @param {ViewOptions} options View options.
 * @return {{constraint: import("./resolutionconstraint.js").Type, maxResolution: number,
 *     minResolution: number, minZoom: number, zoomFactor: number}} The constraint.
 */
function createResolutionConstraint(options) {
  let resolutionConstraint;
  let maxResolution;
  let minResolution;

  // TODO: move these to be ol constants
  // see https://github.com/openlayers/openlayers/issues/2076
  const defaultMaxZoom = 28;
  const defaultZoomFactor = 2;

  let minZoom =
    options.minZoom !== undefined ? options.minZoom : DEFAULT_MIN_ZOOM;

  let maxZoom =
    options.maxZoom !== undefined ? options.maxZoom : defaultMaxZoom;

  const zoomFactor =
    options.zoomFactor !== undefined ? options.zoomFactor : defaultZoomFactor;

  const multiWorld =
    options.multiWorld !== undefined ? options.multiWorld : false;

  const smooth =
    options.smoothResolutionConstraint !== undefined
      ? options.smoothResolutionConstraint
      : true;

  const showFullExtent =
    options.showFullExtent !== undefined ? options.showFullExtent : false;

  const projection = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.createProjection)(options.projection, 'EPSG:3857');
  const projExtent = projection.getExtent();
  let constrainOnlyCenter = options.constrainOnlyCenter;
  let extent = options.extent;
  if (!multiWorld && !extent && projection.isGlobal()) {
    constrainOnlyCenter = false;
    extent = projExtent;
  }

  if (options.resolutions !== undefined) {
    const resolutions = options.resolutions;
    maxResolution = resolutions[minZoom];
    minResolution =
      resolutions[maxZoom] !== undefined
        ? resolutions[maxZoom]
        : resolutions[resolutions.length - 1];

    if (options.constrainResolution) {
      resolutionConstraint = (0,_resolutionconstraint_js__WEBPACK_IMPORTED_MODULE_13__.createSnapToResolutions)(
        resolutions,
        smooth,
        !constrainOnlyCenter && extent,
        showFullExtent
      );
    } else {
      resolutionConstraint = (0,_resolutionconstraint_js__WEBPACK_IMPORTED_MODULE_13__.createMinMaxResolution)(
        maxResolution,
        minResolution,
        smooth,
        !constrainOnlyCenter && extent,
        showFullExtent
      );
    }
  } else {
    // calculate the default min and max resolution
    const size = !projExtent
      ? // use an extent that can fit the whole world if need be
        (360 * _proj_js__WEBPACK_IMPORTED_MODULE_0__.METERS_PER_UNIT.degrees) / projection.getMetersPerUnit()
      : Math.max((0,_extent_js__WEBPACK_IMPORTED_MODULE_8__.getWidth)(projExtent), (0,_extent_js__WEBPACK_IMPORTED_MODULE_8__.getHeight)(projExtent));

    const defaultMaxResolution =
      size / _tilegrid_common_js__WEBPACK_IMPORTED_MODULE_14__.DEFAULT_TILE_SIZE / Math.pow(defaultZoomFactor, DEFAULT_MIN_ZOOM);

    const defaultMinResolution =
      defaultMaxResolution /
      Math.pow(defaultZoomFactor, defaultMaxZoom - DEFAULT_MIN_ZOOM);

    // user provided maxResolution takes precedence
    maxResolution = options.maxResolution;
    if (maxResolution !== undefined) {
      minZoom = 0;
    } else {
      maxResolution = defaultMaxResolution / Math.pow(zoomFactor, minZoom);
    }

    // user provided minResolution takes precedence
    minResolution = options.minResolution;
    if (minResolution === undefined) {
      if (options.maxZoom !== undefined) {
        if (options.maxResolution !== undefined) {
          minResolution = maxResolution / Math.pow(zoomFactor, maxZoom);
        } else {
          minResolution = defaultMaxResolution / Math.pow(zoomFactor, maxZoom);
        }
      } else {
        minResolution = defaultMinResolution;
      }
    }

    // given discrete zoom levels, minResolution may be different than provided
    maxZoom =
      minZoom +
      Math.floor(
        Math.log(maxResolution / minResolution) / Math.log(zoomFactor)
      );
    minResolution = maxResolution / Math.pow(zoomFactor, maxZoom - minZoom);

    if (options.constrainResolution) {
      resolutionConstraint = (0,_resolutionconstraint_js__WEBPACK_IMPORTED_MODULE_13__.createSnapToPower)(
        zoomFactor,
        maxResolution,
        minResolution,
        smooth,
        !constrainOnlyCenter && extent,
        showFullExtent
      );
    } else {
      resolutionConstraint = (0,_resolutionconstraint_js__WEBPACK_IMPORTED_MODULE_13__.createMinMaxResolution)(
        maxResolution,
        minResolution,
        smooth,
        !constrainOnlyCenter && extent,
        showFullExtent
      );
    }
  }
  return {
    constraint: resolutionConstraint,
    maxResolution: maxResolution,
    minResolution: minResolution,
    minZoom: minZoom,
    zoomFactor: zoomFactor,
  };
}

/**
 * @param {ViewOptions} options View options.
 * @return {import("./rotationconstraint.js").Type} Rotation constraint.
 */
function createRotationConstraint(options) {
  const enableRotation =
    options.enableRotation !== undefined ? options.enableRotation : true;
  if (enableRotation) {
    const constrainRotation = options.constrainRotation;
    if (constrainRotation === undefined || constrainRotation === true) {
      return (0,_rotationconstraint_js__WEBPACK_IMPORTED_MODULE_15__.createSnapToZero)();
    }
    if (constrainRotation === false) {
      return _rotationconstraint_js__WEBPACK_IMPORTED_MODULE_15__.none;
    }
    if (typeof constrainRotation === 'number') {
      return (0,_rotationconstraint_js__WEBPACK_IMPORTED_MODULE_15__.createSnapToN)(constrainRotation);
    }
    return _rotationconstraint_js__WEBPACK_IMPORTED_MODULE_15__.none;
  }
  return _rotationconstraint_js__WEBPACK_IMPORTED_MODULE_15__.disable;
}

/**
 * Determine if an animation involves no view change.
 * @param {Animation} animation The animation.
 * @return {boolean} The animation involves no view change.
 */
function isNoopAnimation(animation) {
  if (animation.sourceCenter && animation.targetCenter) {
    if (!(0,_coordinate_js__WEBPACK_IMPORTED_MODULE_6__.equals)(animation.sourceCenter, animation.targetCenter)) {
      return false;
    }
  }
  if (animation.sourceResolution !== animation.targetResolution) {
    return false;
  }
  if (animation.sourceRotation !== animation.targetRotation) {
    return false;
  }
  return true;
}

/**
 * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
 * @param {import("./size.js").Size} size Box pixel size.
 * @param {import("./pixel.js").Pixel} position Position on the view to center on.
 * @param {number} resolution Resolution.
 * @param {number} rotation Rotation.
 * @return {import("./coordinate.js").Coordinate} Shifted center.
 */
function calculateCenterOn(coordinate, size, position, resolution, rotation) {
  // calculate rotated position
  const cosAngle = Math.cos(-rotation);
  let sinAngle = Math.sin(-rotation);
  let rotX = coordinate[0] * cosAngle - coordinate[1] * sinAngle;
  let rotY = coordinate[1] * cosAngle + coordinate[0] * sinAngle;
  rotX += (size[0] / 2 - position[0]) * resolution;
  rotY += (position[1] - size[1] / 2) * resolution;

  // go back to original angle
  sinAngle = -sinAngle; // go back to original rotation
  const centerX = rotX * cosAngle - rotY * sinAngle;
  const centerY = rotY * cosAngle + rotX * sinAngle;

  return [centerX, centerY];
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (View);


/***/ }),

/***/ "./node_modules/ol/ViewHint.js":
/*!*************************************!*\
  !*** ./node_modules/ol/ViewHint.js ***!
  \*************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * @module ol/ViewHint
 */

/**
 * @enum {number}
 */
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  ANIMATING: 0,
  INTERACTING: 1,
});


/***/ }),

/***/ "./node_modules/ol/ViewProperty.js":
/*!*****************************************!*\
  !*** ./node_modules/ol/ViewProperty.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * @module ol/ViewProperty
 */

/**
 * @enum {string}
 */
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  CENTER: 'center',
  RESOLUTION: 'resolution',
  ROTATION: 'rotation',
});


/***/ }),

/***/ "./node_modules/ol/array.js":
/*!**********************************!*\
  !*** ./node_modules/ol/array.js ***!
  \**********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ascending: () => (/* binding */ ascending),
/* harmony export */   binarySearch: () => (/* binding */ binarySearch),
/* harmony export */   descending: () => (/* binding */ descending),
/* harmony export */   equals: () => (/* binding */ equals),
/* harmony export */   extend: () => (/* binding */ extend),
/* harmony export */   isSorted: () => (/* binding */ isSorted),
/* harmony export */   linearFindNearest: () => (/* binding */ linearFindNearest),
/* harmony export */   remove: () => (/* binding */ remove),
/* harmony export */   reverseSubArray: () => (/* binding */ reverseSubArray),
/* harmony export */   stableSort: () => (/* binding */ stableSort)
/* harmony export */ });
/**
 * @module ol/array
 */

/**
 * Performs a binary search on the provided sorted list and returns the index of the item if found. If it can't be found it'll return -1.
 * https://github.com/darkskyapp/binary-search
 *
 * @param {Array<*>} haystack Items to search through.
 * @param {*} needle The item to look for.
 * @param {Function} [comparator] Comparator function.
 * @return {number} The index of the item if found, -1 if not.
 */
function binarySearch(haystack, needle, comparator) {
  let mid, cmp;
  comparator = comparator || ascending;
  let low = 0;
  let high = haystack.length;
  let found = false;

  while (low < high) {
    /* Note that "(low + high) >>> 1" may overflow, and results in a typecast
     * to double (which gives the wrong results). */
    mid = low + ((high - low) >> 1);
    cmp = +comparator(haystack[mid], needle);

    if (cmp < 0.0) {
      /* Too low. */
      low = mid + 1;
    } else {
      /* Key found or too high */
      high = mid;
      found = !cmp;
    }
  }

  /* Key not found. */
  return found ? low : ~low;
}

/**
 * Compare function sorting arrays in ascending order.  Safe to use for numeric values.
 * @param {*} a The first object to be compared.
 * @param {*} b The second object to be compared.
 * @return {number} A negative number, zero, or a positive number as the first
 *     argument is less than, equal to, or greater than the second.
 */
function ascending(a, b) {
  return a > b ? 1 : a < b ? -1 : 0;
}

/**
 * Compare function sorting arrays in descending order.  Safe to use for numeric values.
 * @param {*} a The first object to be compared.
 * @param {*} b The second object to be compared.
 * @return {number} A negative number, zero, or a positive number as the first
 *     argument is greater than, equal to, or less than the second.
 */
function descending(a, b) {
  return a < b ? 1 : a > b ? -1 : 0;
}

/**
 * {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution} can use a function
 * of this type to determine which nearest resolution to use.
 *
 * This function takes a `{number}` representing a value between two array entries,
 * a `{number}` representing the value of the nearest higher entry and
 * a `{number}` representing the value of the nearest lower entry
 * as arguments and returns a `{number}`. If a negative number or zero is returned
 * the lower value will be used, if a positive number is returned the higher value
 * will be used.
 * @typedef {function(number, number, number): number} NearestDirectionFunction
 * @api
 */

/**
 * @param {Array<number>} arr Array in descending order.
 * @param {number} target Target.
 * @param {number|NearestDirectionFunction} direction
 *    0 means return the nearest,
 *    > 0 means return the largest nearest,
 *    < 0 means return the smallest nearest.
 * @return {number} Index.
 */
function linearFindNearest(arr, target, direction) {
  if (arr[0] <= target) {
    return 0;
  }

  const n = arr.length;
  if (target <= arr[n - 1]) {
    return n - 1;
  }

  if (typeof direction === 'function') {
    for (let i = 1; i < n; ++i) {
      const candidate = arr[i];
      if (candidate === target) {
        return i;
      }
      if (candidate < target) {
        if (direction(target, arr[i - 1], candidate) > 0) {
          return i - 1;
        }
        return i;
      }
    }
    return n - 1;
  }

  if (direction > 0) {
    for (let i = 1; i < n; ++i) {
      if (arr[i] < target) {
        return i - 1;
      }
    }
    return n - 1;
  }

  if (direction < 0) {
    for (let i = 1; i < n; ++i) {
      if (arr[i] <= target) {
        return i;
      }
    }
    return n - 1;
  }

  for (let i = 1; i < n; ++i) {
    if (arr[i] == target) {
      return i;
    }
    if (arr[i] < target) {
      if (arr[i - 1] - target < target - arr[i]) {
        return i - 1;
      }
      return i;
    }
  }
  return n - 1;
}

/**
 * @param {Array<*>} arr Array.
 * @param {number} begin Begin index.
 * @param {number} end End index.
 */
function reverseSubArray(arr, begin, end) {
  while (begin < end) {
    const tmp = arr[begin];
    arr[begin] = arr[end];
    arr[end] = tmp;
    ++begin;
    --end;
  }
}

/**
 * @param {Array<VALUE>} arr The array to modify.
 * @param {!Array<VALUE>|VALUE} data The elements or arrays of elements to add to arr.
 * @template VALUE
 */
function extend(arr, data) {
  const extension = Array.isArray(data) ? data : [data];
  const length = extension.length;
  for (let i = 0; i < length; i++) {
    arr[arr.length] = extension[i];
  }
}

/**
 * @param {Array<VALUE>} arr The array to modify.
 * @param {VALUE} obj The element to remove.
 * @template VALUE
 * @return {boolean} If the element was removed.
 */
function remove(arr, obj) {
  const i = arr.indexOf(obj);
  const found = i > -1;
  if (found) {
    arr.splice(i, 1);
  }
  return found;
}

/**
 * @param {Array|Uint8ClampedArray} arr1 The first array to compare.
 * @param {Array|Uint8ClampedArray} arr2 The second array to compare.
 * @return {boolean} Whether the two arrays are equal.
 */
function equals(arr1, arr2) {
  const len1 = arr1.length;
  if (len1 !== arr2.length) {
    return false;
  }
  for (let i = 0; i < len1; i++) {
    if (arr1[i] !== arr2[i]) {
      return false;
    }
  }
  return true;
}

/**
 * Sort the passed array such that the relative order of equal elements is preserved.
 * See https://en.wikipedia.org/wiki/Sorting_algorithm#Stability for details.
 * @param {Array<*>} arr The array to sort (modifies original).
 * @param {!function(*, *): number} compareFnc Comparison function.
 * @api
 */
function stableSort(arr, compareFnc) {
  const length = arr.length;
  const tmp = Array(arr.length);
  let i;
  for (i = 0; i < length; i++) {
    tmp[i] = {index: i, value: arr[i]};
  }
  tmp.sort(function (a, b) {
    return compareFnc(a.value, b.value) || a.index - b.index;
  });
  for (i = 0; i < arr.length; i++) {
    arr[i] = tmp[i].value;
  }
}

/**
 * @param {Array<*>} arr The array to test.
 * @param {Function} [func] Comparison function.
 * @param {boolean} [strict] Strictly sorted (default false).
 * @return {boolean} Return index.
 */
function isSorted(arr, func, strict) {
  const compare = func || ascending;
  return arr.every(function (currentVal, index) {
    if (index === 0) {
      return true;
    }
    const res = compare(arr[index - 1], currentVal);
    return !(res > 0 || (strict && res === 0));
  });
}


/***/ }),

/***/ "./node_modules/ol/asserts.js":
/*!************************************!*\
  !*** ./node_modules/ol/asserts.js ***!
  \************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   assert: () => (/* binding */ assert)
/* harmony export */ });
/**
 * @module ol/asserts
 */

/**
 * @param {*} assertion Assertion we expected to be truthy.
 * @param {string} errorMessage Error message.
 */
function assert(assertion, errorMessage) {
  if (!assertion) {
    throw new Error(errorMessage);
  }
}


/***/ }),

/***/ "./node_modules/ol/centerconstraint.js":
/*!*********************************************!*\
  !*** ./node_modules/ol/centerconstraint.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createExtent: () => (/* binding */ createExtent),
/* harmony export */   none: () => (/* binding */ none)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.js */ "./node_modules/ol/math.js");
/**
 * @module ol/centerconstraint
 */


/**
 * @typedef {function((import("./coordinate.js").Coordinate|undefined), number, import("./size.js").Size, boolean=, Array<number>=): (import("./coordinate.js").Coordinate|undefined)} Type
 */

/**
 * @param {import("./extent.js").Extent} extent Extent.
 * @param {boolean} onlyCenter If true, the constraint will only apply to the view center.
 * @param {boolean} smooth If true, the view will be able to go slightly out of the given extent
 * (only during interaction and animation).
 * @return {Type} The constraint.
 */
function createExtent(extent, onlyCenter, smooth) {
  return (
    /**
     * @param {import("./coordinate.js").Coordinate|undefined} center Center.
     * @param {number|undefined} resolution Resolution.
     * @param {import("./size.js").Size} size Viewport size; unused if `onlyCenter` was specified.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @param {Array<number>} [centerShift] Shift between map center and viewport center.
     * @return {import("./coordinate.js").Coordinate|undefined} Center.
     */
    function (center, resolution, size, isMoving, centerShift) {
      if (!center) {
        return undefined;
      }
      if (!resolution && !onlyCenter) {
        return center;
      }
      const viewWidth = onlyCenter ? 0 : size[0] * resolution;
      const viewHeight = onlyCenter ? 0 : size[1] * resolution;
      const shiftX = centerShift ? centerShift[0] : 0;
      const shiftY = centerShift ? centerShift[1] : 0;
      let minX = extent[0] + viewWidth / 2 + shiftX;
      let maxX = extent[2] - viewWidth / 2 + shiftX;
      let minY = extent[1] + viewHeight / 2 + shiftY;
      let maxY = extent[3] - viewHeight / 2 + shiftY;

      // note: when zooming out of bounds, min and max values for x and y may
      // end up inverted (min > max); this has to be accounted for
      if (minX > maxX) {
        minX = (maxX + minX) / 2;
        maxX = minX;
      }
      if (minY > maxY) {
        minY = (maxY + minY) / 2;
        maxY = minY;
      }

      let x = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.clamp)(center[0], minX, maxX);
      let y = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.clamp)(center[1], minY, maxY);

      // during an interaction, allow some overscroll
      if (isMoving && smooth && resolution) {
        const ratio = 30 * resolution;
        x +=
          -ratio * Math.log(1 + Math.max(0, minX - center[0]) / ratio) +
          ratio * Math.log(1 + Math.max(0, center[0] - maxX) / ratio);
        y +=
          -ratio * Math.log(1 + Math.max(0, minY - center[1]) / ratio) +
          ratio * Math.log(1 + Math.max(0, center[1] - maxY) / ratio);
      }

      return [x, y];
    }
  );
}

/**
 * @param {import("./coordinate.js").Coordinate} [center] Center.
 * @return {import("./coordinate.js").Coordinate|undefined} Center.
 */
function none(center) {
  return center;
}


/***/ }),

/***/ "./node_modules/ol/color.js":
/*!**********************************!*\
  !*** ./node_modules/ol/color.js ***!
  \**********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   asArray: () => (/* binding */ asArray),
/* harmony export */   asString: () => (/* binding */ asString),
/* harmony export */   fromString: () => (/* binding */ fromString),
/* harmony export */   isStringColor: () => (/* binding */ isStringColor),
/* harmony export */   normalize: () => (/* binding */ normalize),
/* harmony export */   toString: () => (/* binding */ toString)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.js */ "./node_modules/ol/math.js");
/**
 * @module ol/color
 */


/**
 * A color represented as a short array [red, green, blue, alpha].
 * red, green, and blue should be integers in the range 0..255 inclusive.
 * alpha should be a float in the range 0..1 inclusive. If no alpha value is
 * given then `1` will be used.
 * @typedef {Array<number>} Color
 * @api
 */

/**
 * This RegExp matches # followed by 3, 4, 6, or 8 hex digits.
 * @const
 * @type {RegExp}
 * @private
 */
const HEX_COLOR_RE_ = /^#([a-f0-9]{3}|[a-f0-9]{4}(?:[a-f0-9]{2}){0,2})$/i;

/**
 * Regular expression for matching potential named color style strings.
 * @const
 * @type {RegExp}
 * @private
 */
const NAMED_COLOR_RE_ = /^([a-z]*)$|^hsla?\(.*\)$/i;

/**
 * Return the color as an rgba string.
 * @param {Color|string} color Color.
 * @return {string} Rgba string.
 * @api
 */
function asString(color) {
  if (typeof color === 'string') {
    return color;
  }
  return toString(color);
}

/**
 * Return named color as an rgba string.
 * @param {string} color Named color.
 * @return {string} Rgb string.
 */
function fromNamed(color) {
  const el = document.createElement('div');
  el.style.color = color;
  if (el.style.color !== '') {
    document.body.appendChild(el);
    const rgb = getComputedStyle(el).color;
    document.body.removeChild(el);
    return rgb;
  }
  return '';
}

/**
 * @param {string} s String.
 * @return {Color} Color.
 */
const fromString = (function () {
  // We maintain a small cache of parsed strings.  To provide cheap LRU-like
  // semantics, whenever the cache grows too large we simply delete an
  // arbitrary 25% of the entries.

  /**
   * @const
   * @type {number}
   */
  const MAX_CACHE_SIZE = 1024;

  /**
   * @type {Object<string, Color>}
   */
  const cache = {};

  /**
   * @type {number}
   */
  let cacheSize = 0;

  return (
    /**
     * @param {string} s String.
     * @return {Color} Color.
     */
    function (s) {
      let color;
      if (cache.hasOwnProperty(s)) {
        color = cache[s];
      } else {
        if (cacheSize >= MAX_CACHE_SIZE) {
          let i = 0;
          for (const key in cache) {
            if ((i++ & 3) === 0) {
              delete cache[key];
              --cacheSize;
            }
          }
        }
        color = fromStringInternal_(s);
        cache[s] = color;
        ++cacheSize;
      }
      return color;
    }
  );
})();

/**
 * Return the color as an array. This function maintains a cache of calculated
 * arrays which means the result should not be modified.
 * @param {Color|string} color Color.
 * @return {Color} Color.
 * @api
 */
function asArray(color) {
  if (Array.isArray(color)) {
    return color;
  }
  return fromString(color);
}

/**
 * @param {string} s String.
 * @private
 * @return {Color} Color.
 */
function fromStringInternal_(s) {
  let r, g, b, a, color;

  if (NAMED_COLOR_RE_.exec(s)) {
    s = fromNamed(s);
  }

  if (HEX_COLOR_RE_.exec(s)) {
    // hex
    const n = s.length - 1; // number of hex digits
    let d; // number of digits per channel
    if (n <= 4) {
      d = 1;
    } else {
      d = 2;
    }
    const hasAlpha = n === 4 || n === 8;
    r = parseInt(s.substr(1 + 0 * d, d), 16);
    g = parseInt(s.substr(1 + 1 * d, d), 16);
    b = parseInt(s.substr(1 + 2 * d, d), 16);
    if (hasAlpha) {
      a = parseInt(s.substr(1 + 3 * d, d), 16);
    } else {
      a = 255;
    }
    if (d == 1) {
      r = (r << 4) + r;
      g = (g << 4) + g;
      b = (b << 4) + b;
      if (hasAlpha) {
        a = (a << 4) + a;
      }
    }
    color = [r, g, b, a / 255];
  } else if (s.startsWith('rgba(')) {
    // rgba()
    color = s.slice(5, -1).split(',').map(Number);
    normalize(color);
  } else if (s.startsWith('rgb(')) {
    // rgb()
    color = s.slice(4, -1).split(',').map(Number);
    color.push(1);
    normalize(color);
  } else {
    throw new Error('Invalid color');
  }
  return color;
}

/**
 * TODO this function is only used in the test, we probably shouldn't export it
 * @param {Color} color Color.
 * @return {Color} Clamped color.
 */
function normalize(color) {
  color[0] = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.clamp)((color[0] + 0.5) | 0, 0, 255);
  color[1] = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.clamp)((color[1] + 0.5) | 0, 0, 255);
  color[2] = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.clamp)((color[2] + 0.5) | 0, 0, 255);
  color[3] = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.clamp)(color[3], 0, 1);
  return color;
}

/**
 * @param {Color} color Color.
 * @return {string} String.
 */
function toString(color) {
  let r = color[0];
  if (r != (r | 0)) {
    r = (r + 0.5) | 0;
  }
  let g = color[1];
  if (g != (g | 0)) {
    g = (g + 0.5) | 0;
  }
  let b = color[2];
  if (b != (b | 0)) {
    b = (b + 0.5) | 0;
  }
  const a = color[3] === undefined ? 1 : Math.round(color[3] * 100) / 100;
  return 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';
}

/**
 * @param {string} s String.
 * @return {boolean} Whether the string is actually a valid color
 */
function isStringColor(s) {
  if (NAMED_COLOR_RE_.test(s)) {
    s = fromNamed(s);
  }
  return HEX_COLOR_RE_.test(s) || s.startsWith('rgba(') || s.startsWith('rgb(');
}


/***/ }),

/***/ "./node_modules/ol/colorlike.js":
/*!**************************************!*\
  !*** ./node_modules/ol/colorlike.js ***!
  \**************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   asColorLike: () => (/* binding */ asColorLike)
/* harmony export */ });
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./color.js */ "./node_modules/ol/color.js");
/**
 * @module ol/colorlike
 */


/**
 * A type accepted by CanvasRenderingContext2D.fillStyle
 * or CanvasRenderingContext2D.strokeStyle.
 * Represents a color, pattern, or gradient. The origin for patterns and
 * gradients as fill style is an increment of 512 css pixels from map coordinate
 * `[0, 0]`. For seamless repeat patterns, width and height of the pattern image
 * must be a factor of two (2, 4, 8, ..., 512).
 *
 * @typedef {string|CanvasPattern|CanvasGradient} ColorLike
 * @api
 */

/**
 * @param {import("./color.js").Color|ColorLike} color Color.
 * @return {ColorLike} The color as an {@link ol/colorlike~ColorLike}.
 * @api
 */
function asColorLike(color) {
  if (Array.isArray(color)) {
    return (0,_color_js__WEBPACK_IMPORTED_MODULE_0__.toString)(color);
  }
  return color;
}


/***/ }),

/***/ "./node_modules/ol/console.js":
/*!************************************!*\
  !*** ./node_modules/ol/console.js ***!
  \************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   error: () => (/* binding */ error),
/* harmony export */   log: () => (/* binding */ log),
/* harmony export */   setLevel: () => (/* binding */ setLevel),
/* harmony export */   warn: () => (/* binding */ warn)
/* harmony export */ });
/**
 * @module ol/console
 */

/**
 * @typedef {'info'|'warn'|'error'|'none'} Level
 */

/**
 * @type {Object<Level, number>}
 */
const levels = {
  info: 1,
  warn: 2,
  error: 3,
  none: 4,
};

/**
 * @type {number}
 */
let level = levels.info;

/**
 * Set the logging level.  By default, the level is set to 'info' and all
 * messages will be logged.  Set to 'warn' to only display warnings and errors.
 * Set to 'error' to only display errors.  Set to 'none' to silence all messages.
 *
 * @param {Level} l The new level.
 */
function setLevel(l) {
  level = levels[l];
}

function log(...args) {
  if (level > levels.info) {
    return;
  }
  console.log(...args); // eslint-disable-line no-console
}

function warn(...args) {
  if (level > levels.warn) {
    return;
  }
  console.warn(...args); // eslint-disable-line no-console
}

function error(...args) {
  if (level > levels.error) {
    return;
  }
  console.error(...args); // eslint-disable-line no-console
}


/***/ }),

/***/ "./node_modules/ol/control/Attribution.js":
/*!************************************************!*\
  !*** ./node_modules/ol/control/Attribution.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Control_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Control.js */ "./node_modules/ol/control/Control.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../events/EventType.js */ "./node_modules/ol/events/EventType.js");
/* harmony import */ var _css_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../css.js */ "./node_modules/ol/css.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../dom.js */ "./node_modules/ol/dom.js");
/**
 * @module ol/control/Attribution
 */






/**
 * @typedef {Object} Options
 * @property {string} [className='ol-attribution'] CSS class name.
 * @property {HTMLElement|string} [target] Specify a target if you
 * want the control to be rendered outside of the map's
 * viewport.
 * @property {boolean} [collapsible] Specify if attributions can
 * be collapsed. If not specified, sources control this behavior with their
 * `attributionsCollapsible` setting.
 * @property {boolean} [collapsed=true] Specify if attributions should
 * be collapsed at startup.
 * @property {string} [tipLabel='Attributions'] Text label to use for the button tip.
 * @property {string|HTMLElement} [label='i'] Text label to use for the
 * collapsed attributions button.
 * Instead of text, also an element (e.g. a `span` element) can be used.
 * @property {string} [expandClassName=className + '-expand'] CSS class name for the
 * collapsed attributions button.
 * @property {string|HTMLElement} [collapseLabel='›'] Text label to use
 * for the expanded attributions button.
 * Instead of text, also an element (e.g. a `span` element) can be used.
 * @property {string} [collapseClassName=className + '-collapse'] CSS class name for the
 * expanded attributions button.
 * @property {function(import("../MapEvent.js").default):void} [render] Function called when
 * the control should be re-rendered. This is called in a `requestAnimationFrame`
 * callback.
 */

/**
 * @classdesc
 * Control to show all the attributions associated with the layer sources
 * in the map. This control is one of the default controls included in maps.
 * By default it will show in the bottom right portion of the map, but this can
 * be changed by using a css selector for `.ol-attribution`.
 *
 * @api
 */
class Attribution extends _Control_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {Options} [options] Attribution options.
   */
  constructor(options) {
    options = options ? options : {};

    super({
      element: document.createElement('div'),
      render: options.render,
      target: options.target,
    });

    /**
     * @private
     * @type {HTMLElement}
     */
    this.ulElement_ = document.createElement('ul');

    /**
     * @private
     * @type {boolean}
     */
    this.collapsed_ =
      options.collapsed !== undefined ? options.collapsed : true;

    /**
     * @private
     * @type {boolean}
     */
    this.userCollapsed_ = this.collapsed_;

    /**
     * @private
     * @type {boolean}
     */
    this.overrideCollapsible_ = options.collapsible !== undefined;

    /**
     * @private
     * @type {boolean}
     */
    this.collapsible_ =
      options.collapsible !== undefined ? options.collapsible : true;

    if (!this.collapsible_) {
      this.collapsed_ = false;
    }

    const className =
      options.className !== undefined ? options.className : 'ol-attribution';

    const tipLabel =
      options.tipLabel !== undefined ? options.tipLabel : 'Attributions';

    const expandClassName =
      options.expandClassName !== undefined
        ? options.expandClassName
        : className + '-expand';

    const collapseLabel =
      options.collapseLabel !== undefined ? options.collapseLabel : '\u203A';

    const collapseClassName =
      options.collapseClassName !== undefined
        ? options.collapseClassName
        : className + '-collapse';

    if (typeof collapseLabel === 'string') {
      /**
       * @private
       * @type {HTMLElement}
       */
      this.collapseLabel_ = document.createElement('span');
      this.collapseLabel_.textContent = collapseLabel;
      this.collapseLabel_.className = collapseClassName;
    } else {
      this.collapseLabel_ = collapseLabel;
    }

    const label = options.label !== undefined ? options.label : 'i';

    if (typeof label === 'string') {
      /**
       * @private
       * @type {HTMLElement}
       */
      this.label_ = document.createElement('span');
      this.label_.textContent = label;
      this.label_.className = expandClassName;
    } else {
      this.label_ = label;
    }

    const activeLabel =
      this.collapsible_ && !this.collapsed_ ? this.collapseLabel_ : this.label_;

    /**
     * @private
     * @type {HTMLElement}
     */
    this.toggleButton_ = document.createElement('button');
    this.toggleButton_.setAttribute('type', 'button');
    this.toggleButton_.setAttribute('aria-expanded', String(!this.collapsed_));
    this.toggleButton_.title = tipLabel;
    this.toggleButton_.appendChild(activeLabel);

    this.toggleButton_.addEventListener(
      _events_EventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].CLICK,
      this.handleClick_.bind(this),
      false
    );

    const cssClasses =
      className +
      ' ' +
      _css_js__WEBPACK_IMPORTED_MODULE_2__.CLASS_UNSELECTABLE +
      ' ' +
      _css_js__WEBPACK_IMPORTED_MODULE_2__.CLASS_CONTROL +
      (this.collapsed_ && this.collapsible_ ? ' ' + _css_js__WEBPACK_IMPORTED_MODULE_2__.CLASS_COLLAPSED : '') +
      (this.collapsible_ ? '' : ' ol-uncollapsible');
    const element = this.element;
    element.className = cssClasses;
    element.appendChild(this.toggleButton_);
    element.appendChild(this.ulElement_);

    /**
     * A list of currently rendered resolutions.
     * @type {Array<string>}
     * @private
     */
    this.renderedAttributions_ = [];

    /**
     * @private
     * @type {boolean}
     */
    this.renderedVisible_ = true;
  }

  /**
   * Collect a list of visible attributions and set the collapsible state.
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @return {Array<string>} Attributions.
   * @private
   */
  collectSourceAttributions_(frameState) {
    const visibleAttributions = Array.from(
      new Set(
        this.getMap()
          .getAllLayers()
          .flatMap((layer) => layer.getAttributions(frameState))
      )
    );

    const collapsible = !this.getMap()
      .getAllLayers()
      .some(
        (layer) =>
          layer.getSource() &&
          layer.getSource().getAttributionsCollapsible() === false
      );
    if (!this.overrideCollapsible_) {
      this.setCollapsible(collapsible);
    }
    return visibleAttributions;
  }

  /**
   * @private
   * @param {?import("../Map.js").FrameState} frameState Frame state.
   */
  updateElement_(frameState) {
    if (!frameState) {
      if (this.renderedVisible_) {
        this.element.style.display = 'none';
        this.renderedVisible_ = false;
      }
      return;
    }

    const attributions = this.collectSourceAttributions_(frameState);

    const visible = attributions.length > 0;
    if (this.renderedVisible_ != visible) {
      this.element.style.display = visible ? '' : 'none';
      this.renderedVisible_ = visible;
    }

    if ((0,_array_js__WEBPACK_IMPORTED_MODULE_3__.equals)(attributions, this.renderedAttributions_)) {
      return;
    }

    (0,_dom_js__WEBPACK_IMPORTED_MODULE_4__.removeChildren)(this.ulElement_);

    // append the attributions
    for (let i = 0, ii = attributions.length; i < ii; ++i) {
      const element = document.createElement('li');
      element.innerHTML = attributions[i];
      this.ulElement_.appendChild(element);
    }

    this.renderedAttributions_ = attributions;
  }

  /**
   * @param {MouseEvent} event The event to handle
   * @private
   */
  handleClick_(event) {
    event.preventDefault();
    this.handleToggle_();
    this.userCollapsed_ = this.collapsed_;
  }

  /**
   * @private
   */
  handleToggle_() {
    this.element.classList.toggle(_css_js__WEBPACK_IMPORTED_MODULE_2__.CLASS_COLLAPSED);
    if (this.collapsed_) {
      (0,_dom_js__WEBPACK_IMPORTED_MODULE_4__.replaceNode)(this.collapseLabel_, this.label_);
    } else {
      (0,_dom_js__WEBPACK_IMPORTED_MODULE_4__.replaceNode)(this.label_, this.collapseLabel_);
    }
    this.collapsed_ = !this.collapsed_;
    this.toggleButton_.setAttribute('aria-expanded', String(!this.collapsed_));
  }

  /**
   * Return `true` if the attribution is collapsible, `false` otherwise.
   * @return {boolean} True if the widget is collapsible.
   * @api
   */
  getCollapsible() {
    return this.collapsible_;
  }

  /**
   * Set whether the attribution should be collapsible.
   * @param {boolean} collapsible True if the widget is collapsible.
   * @api
   */
  setCollapsible(collapsible) {
    if (this.collapsible_ === collapsible) {
      return;
    }
    this.collapsible_ = collapsible;
    this.element.classList.toggle('ol-uncollapsible');
    if (this.userCollapsed_) {
      this.handleToggle_();
    }
  }

  /**
   * Collapse or expand the attribution according to the passed parameter. Will
   * not do anything if the attribution isn't collapsible or if the current
   * collapsed state is already the one requested.
   * @param {boolean} collapsed True if the widget is collapsed.
   * @api
   */
  setCollapsed(collapsed) {
    this.userCollapsed_ = collapsed;
    if (!this.collapsible_ || this.collapsed_ === collapsed) {
      return;
    }
    this.handleToggle_();
  }

  /**
   * Return `true` when the attribution is currently collapsed or `false`
   * otherwise.
   * @return {boolean} True if the widget is collapsed.
   * @api
   */
  getCollapsed() {
    return this.collapsed_;
  }

  /**
   * Update the attribution element.
   * @param {import("../MapEvent.js").default} mapEvent Map event.
   * @override
   */
  render(mapEvent) {
    this.updateElement_(mapEvent.frameState);
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Attribution);


/***/ }),

/***/ "./node_modules/ol/control/Control.js":
/*!********************************************!*\
  !*** ./node_modules/ol/control/Control.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Object_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Object.js */ "./node_modules/ol/Object.js");
/* harmony import */ var _MapEventType_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../MapEventType.js */ "./node_modules/ol/MapEventType.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../functions.js */ "./node_modules/ol/functions.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../dom.js */ "./node_modules/ol/dom.js");
/**
 * @module ol/control/Control
 */






/**
 * @typedef {Object} Options
 * @property {HTMLElement} [element] The element is the control's
 * container element. This only needs to be specified if you're developing
 * a custom control.
 * @property {function(import("../MapEvent.js").default):void} [render] Function called when
 * the control should be re-rendered. This is called in a `requestAnimationFrame`
 * callback.
 * @property {HTMLElement|string} [target] Specify a target if you want
 * the control to be rendered outside of the map's viewport.
 */

/**
 * @classdesc
 * A control is a visible widget with a DOM element in a fixed position on the
 * screen. They can involve user input (buttons), or be informational only;
 * the position is determined using CSS. By default these are placed in the
 * container with CSS class name `ol-overlaycontainer-stopevent`, but can use
 * any outside DOM element.
 *
 * This is the base class for controls. You can use it for simple custom
 * controls by creating the element with listeners, creating an instance:
 * ```js
 * const myControl = new Control({element: myElement});
 * ```
 * and then adding this to the map.
 *
 * The main advantage of having this as a control rather than a simple separate
 * DOM element is that preventing propagation is handled for you. Controls
 * will also be objects in a {@link module:ol/Collection~Collection}, so you can use their methods.
 *
 * You can also extend this base for your own control class. See
 * examples/custom-controls for an example of how to do this.
 *
 * @api
 */
class Control extends _Object_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {Options} options Control options.
   */
  constructor(options) {
    super();

    const element = options.element;
    if (element && !options.target && !element.style.pointerEvents) {
      element.style.pointerEvents = 'auto';
    }

    /**
     * @protected
     * @type {HTMLElement}
     */
    this.element = element ? element : null;

    /**
     * @private
     * @type {HTMLElement}
     */
    this.target_ = null;

    /**
     * @private
     * @type {import("../Map.js").default|null}
     */
    this.map_ = null;

    /**
     * @protected
     * @type {!Array<import("../events.js").EventsKey>}
     */
    this.listenerKeys = [];

    if (options.render) {
      this.render = options.render;
    }

    if (options.target) {
      this.setTarget(options.target);
    }
  }

  /**
   * Clean up.
   */
  disposeInternal() {
    (0,_dom_js__WEBPACK_IMPORTED_MODULE_1__.removeNode)(this.element);
    super.disposeInternal();
  }

  /**
   * Get the map associated with this control.
   * @return {import("../Map.js").default|null} Map.
   * @api
   */
  getMap() {
    return this.map_;
  }

  /**
   * Remove the control from its current map and attach it to the new map.
   * Pass `null` to just remove the control from the current map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {import("../Map.js").default|null} map Map.
   * @api
   */
  setMap(map) {
    if (this.map_) {
      (0,_dom_js__WEBPACK_IMPORTED_MODULE_1__.removeNode)(this.element);
    }
    for (let i = 0, ii = this.listenerKeys.length; i < ii; ++i) {
      (0,_events_js__WEBPACK_IMPORTED_MODULE_2__.unlistenByKey)(this.listenerKeys[i]);
    }
    this.listenerKeys.length = 0;
    this.map_ = map;
    if (map) {
      const target = this.target_
        ? this.target_
        : map.getOverlayContainerStopEvent();
      target.appendChild(this.element);
      if (this.render !== _functions_js__WEBPACK_IMPORTED_MODULE_3__.VOID) {
        this.listenerKeys.push(
          (0,_events_js__WEBPACK_IMPORTED_MODULE_2__.listen)(map, _MapEventType_js__WEBPACK_IMPORTED_MODULE_4__["default"].POSTRENDER, this.render, this)
        );
      }
      map.render();
    }
  }

  /**
   * Renders the control.
   * @param {import("../MapEvent.js").default} mapEvent Map event.
   * @api
   */
  render(mapEvent) {}

  /**
   * This function is used to set a target element for the control. It has no
   * effect if it is called after the control has been added to the map (i.e.
   * after `setMap` is called on the control). If no `target` is set in the
   * options passed to the control constructor and if `setTarget` is not called
   * then the control is added to the map's overlay container.
   * @param {HTMLElement|string} target Target.
   * @api
   */
  setTarget(target) {
    this.target_ =
      typeof target === 'string' ? document.getElementById(target) : target;
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Control);


/***/ }),

/***/ "./node_modules/ol/control/Rotate.js":
/*!*******************************************!*\
  !*** ./node_modules/ol/control/Rotate.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Control_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Control.js */ "./node_modules/ol/control/Control.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../events/EventType.js */ "./node_modules/ol/events/EventType.js");
/* harmony import */ var _css_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../css.js */ "./node_modules/ol/css.js");
/* harmony import */ var _easing_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../easing.js */ "./node_modules/ol/easing.js");
/**
 * @module ol/control/Rotate
 */





/**
 * @typedef {Object} Options
 * @property {string} [className='ol-rotate'] CSS class name.
 * @property {string|HTMLElement} [label='⇧'] Text label to use for the rotate button.
 * Instead of text, also an element (e.g. a `span` element) can be used.
 * @property {string} [tipLabel='Reset rotation'] Text label to use for the rotate tip.
 * @property {string} [compassClassName='ol-compass'] CSS class name for the compass.
 * @property {number} [duration=250] Animation duration in milliseconds.
 * @property {boolean} [autoHide=true] Hide the control when rotation is 0.
 * @property {function(import("../MapEvent.js").default):void} [render] Function called when the control should
 * be re-rendered. This is called in a `requestAnimationFrame` callback.
 * @property {function():void} [resetNorth] Function called when the control is clicked.
 * This will override the default `resetNorth`.
 * @property {HTMLElement|string} [target] Specify a target if you want the control to be
 * rendered outside of the map's viewport.
 */

/**
 * @classdesc
 * A button control to reset rotation to 0.
 * To style this control use css selector `.ol-rotate`. A `.ol-hidden` css
 * selector is added to the button when the rotation is 0.
 *
 * @api
 */
class Rotate extends _Control_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {Options} [options] Rotate options.
   */
  constructor(options) {
    options = options ? options : {};

    super({
      element: document.createElement('div'),
      render: options.render,
      target: options.target,
    });

    const className =
      options.className !== undefined ? options.className : 'ol-rotate';

    const label = options.label !== undefined ? options.label : '\u21E7';

    const compassClassName =
      options.compassClassName !== undefined
        ? options.compassClassName
        : 'ol-compass';

    /**
     * @type {HTMLElement}
     * @private
     */
    this.label_ = null;

    if (typeof label === 'string') {
      this.label_ = document.createElement('span');
      this.label_.className = compassClassName;
      this.label_.textContent = label;
    } else {
      this.label_ = label;
      this.label_.classList.add(compassClassName);
    }

    const tipLabel = options.tipLabel ? options.tipLabel : 'Reset rotation';

    const button = document.createElement('button');
    button.className = className + '-reset';
    button.setAttribute('type', 'button');
    button.title = tipLabel;
    button.appendChild(this.label_);

    button.addEventListener(
      _events_EventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].CLICK,
      this.handleClick_.bind(this),
      false
    );

    const cssClasses =
      className + ' ' + _css_js__WEBPACK_IMPORTED_MODULE_2__.CLASS_UNSELECTABLE + ' ' + _css_js__WEBPACK_IMPORTED_MODULE_2__.CLASS_CONTROL;
    const element = this.element;
    element.className = cssClasses;
    element.appendChild(button);

    this.callResetNorth_ = options.resetNorth ? options.resetNorth : undefined;

    /**
     * @type {number}
     * @private
     */
    this.duration_ = options.duration !== undefined ? options.duration : 250;

    /**
     * @type {boolean}
     * @private
     */
    this.autoHide_ = options.autoHide !== undefined ? options.autoHide : true;

    /**
     * @private
     * @type {number|undefined}
     */
    this.rotation_ = undefined;

    if (this.autoHide_) {
      this.element.classList.add(_css_js__WEBPACK_IMPORTED_MODULE_2__.CLASS_HIDDEN);
    }
  }

  /**
   * @param {MouseEvent} event The event to handle
   * @private
   */
  handleClick_(event) {
    event.preventDefault();
    if (this.callResetNorth_ !== undefined) {
      this.callResetNorth_();
    } else {
      this.resetNorth_();
    }
  }

  /**
   * @private
   */
  resetNorth_() {
    const map = this.getMap();
    const view = map.getView();
    if (!view) {
      // the map does not have a view, so we can't act
      // upon it
      return;
    }
    const rotation = view.getRotation();
    if (rotation !== undefined) {
      if (this.duration_ > 0 && rotation % (2 * Math.PI) !== 0) {
        view.animate({
          rotation: 0,
          duration: this.duration_,
          easing: _easing_js__WEBPACK_IMPORTED_MODULE_3__.easeOut,
        });
      } else {
        view.setRotation(0);
      }
    }
  }

  /**
   * Update the rotate control element.
   * @param {import("../MapEvent.js").default} mapEvent Map event.
   * @override
   */
  render(mapEvent) {
    const frameState = mapEvent.frameState;
    if (!frameState) {
      return;
    }
    const rotation = frameState.viewState.rotation;
    if (rotation != this.rotation_) {
      const transform = 'rotate(' + rotation + 'rad)';
      if (this.autoHide_) {
        const contains = this.element.classList.contains(_css_js__WEBPACK_IMPORTED_MODULE_2__.CLASS_HIDDEN);
        if (!contains && rotation === 0) {
          this.element.classList.add(_css_js__WEBPACK_IMPORTED_MODULE_2__.CLASS_HIDDEN);
        } else if (contains && rotation !== 0) {
          this.element.classList.remove(_css_js__WEBPACK_IMPORTED_MODULE_2__.CLASS_HIDDEN);
        }
      }
      this.label_.style.transform = transform;
    }
    this.rotation_ = rotation;
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Rotate);


/***/ }),

/***/ "./node_modules/ol/control/Zoom.js":
/*!*****************************************!*\
  !*** ./node_modules/ol/control/Zoom.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Control_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Control.js */ "./node_modules/ol/control/Control.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../events/EventType.js */ "./node_modules/ol/events/EventType.js");
/* harmony import */ var _css_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../css.js */ "./node_modules/ol/css.js");
/* harmony import */ var _easing_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../easing.js */ "./node_modules/ol/easing.js");
/**
 * @module ol/control/Zoom
 */





/**
 * @typedef {Object} Options
 * @property {number} [duration=250] Animation duration in milliseconds.
 * @property {string} [className='ol-zoom'] CSS class name.
 * @property {string} [zoomInClassName=className + '-in'] CSS class name for the zoom-in button.
 * @property {string} [zoomOutClassName=className + '-out'] CSS class name for the zoom-out button.
 * @property {string|HTMLElement} [zoomInLabel='+'] Text label to use for the zoom-in
 * button. Instead of text, also an element (e.g. a `span` element) can be used.
 * @property {string|HTMLElement} [zoomOutLabel='–'] Text label to use for the zoom-out button.
 * Instead of text, also an element (e.g. a `span` element) can be used.
 * @property {string} [zoomInTipLabel='Zoom in'] Text label to use for the button tip.
 * @property {string} [zoomOutTipLabel='Zoom out'] Text label to use for the button tip.
 * @property {number} [delta=1] The zoom delta applied on each click.
 * @property {HTMLElement|string} [target] Specify a target if you want the control to be
 * rendered outside of the map's viewport.
 */

/**
 * @classdesc
 * A control with 2 buttons, one for zoom in and one for zoom out.
 * This control is one of the default controls of a map. To style this control
 * use css selectors `.ol-zoom-in` and `.ol-zoom-out`.
 *
 * @api
 */
class Zoom extends _Control_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {Options} [options] Zoom options.
   */
  constructor(options) {
    options = options ? options : {};

    super({
      element: document.createElement('div'),
      target: options.target,
    });

    const className =
      options.className !== undefined ? options.className : 'ol-zoom';

    const delta = options.delta !== undefined ? options.delta : 1;

    const zoomInClassName =
      options.zoomInClassName !== undefined
        ? options.zoomInClassName
        : className + '-in';

    const zoomOutClassName =
      options.zoomOutClassName !== undefined
        ? options.zoomOutClassName
        : className + '-out';

    const zoomInLabel =
      options.zoomInLabel !== undefined ? options.zoomInLabel : '+';
    const zoomOutLabel =
      options.zoomOutLabel !== undefined ? options.zoomOutLabel : '\u2013';

    const zoomInTipLabel =
      options.zoomInTipLabel !== undefined ? options.zoomInTipLabel : 'Zoom in';
    const zoomOutTipLabel =
      options.zoomOutTipLabel !== undefined
        ? options.zoomOutTipLabel
        : 'Zoom out';

    const inElement = document.createElement('button');
    inElement.className = zoomInClassName;
    inElement.setAttribute('type', 'button');
    inElement.title = zoomInTipLabel;
    inElement.appendChild(
      typeof zoomInLabel === 'string'
        ? document.createTextNode(zoomInLabel)
        : zoomInLabel
    );

    inElement.addEventListener(
      _events_EventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].CLICK,
      this.handleClick_.bind(this, delta),
      false
    );

    const outElement = document.createElement('button');
    outElement.className = zoomOutClassName;
    outElement.setAttribute('type', 'button');
    outElement.title = zoomOutTipLabel;
    outElement.appendChild(
      typeof zoomOutLabel === 'string'
        ? document.createTextNode(zoomOutLabel)
        : zoomOutLabel
    );

    outElement.addEventListener(
      _events_EventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].CLICK,
      this.handleClick_.bind(this, -delta),
      false
    );

    const cssClasses =
      className + ' ' + _css_js__WEBPACK_IMPORTED_MODULE_2__.CLASS_UNSELECTABLE + ' ' + _css_js__WEBPACK_IMPORTED_MODULE_2__.CLASS_CONTROL;
    const element = this.element;
    element.className = cssClasses;
    element.appendChild(inElement);
    element.appendChild(outElement);

    /**
     * @type {number}
     * @private
     */
    this.duration_ = options.duration !== undefined ? options.duration : 250;
  }

  /**
   * @param {number} delta Zoom delta.
   * @param {MouseEvent} event The event to handle
   * @private
   */
  handleClick_(delta, event) {
    event.preventDefault();
    this.zoomByDelta_(delta);
  }

  /**
   * @param {number} delta Zoom delta.
   * @private
   */
  zoomByDelta_(delta) {
    const map = this.getMap();
    const view = map.getView();
    if (!view) {
      // the map does not have a view, so we can't act
      // upon it
      return;
    }
    const currentZoom = view.getZoom();
    if (currentZoom !== undefined) {
      const newZoom = view.getConstrainedZoom(currentZoom + delta);
      if (this.duration_ > 0) {
        if (view.getAnimating()) {
          view.cancelAnimations();
        }
        view.animate({
          zoom: newZoom,
          duration: this.duration_,
          easing: _easing_js__WEBPACK_IMPORTED_MODULE_3__.easeOut,
        });
      } else {
        view.setZoom(newZoom);
      }
    }
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Zoom);


/***/ }),

/***/ "./node_modules/ol/control/defaults.js":
/*!*********************************************!*\
  !*** ./node_modules/ol/control/defaults.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   defaults: () => (/* binding */ defaults)
/* harmony export */ });
/* harmony import */ var _Attribution_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Attribution.js */ "./node_modules/ol/control/Attribution.js");
/* harmony import */ var _Collection_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Collection.js */ "./node_modules/ol/Collection.js");
/* harmony import */ var _Rotate_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Rotate.js */ "./node_modules/ol/control/Rotate.js");
/* harmony import */ var _Zoom_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Zoom.js */ "./node_modules/ol/control/Zoom.js");
/**
 * @module ol/control/defaults
 */





/**
 * @typedef {Object} DefaultsOptions
 * @property {boolean} [attribution=true] Include
 * {@link module:ol/control/Attribution~Attribution}.
 * @property {import("./Attribution.js").Options} [attributionOptions]
 * Options for {@link module:ol/control/Attribution~Attribution}.
 * @property {boolean} [rotate=true] Include
 * {@link module:ol/control/Rotate~Rotate}.
 * @property {import("./Rotate.js").Options} [rotateOptions] Options
 * for {@link module:ol/control/Rotate~Rotate}.
 * @property {boolean} [zoom] Include {@link module:ol/control/Zoom~Zoom}.
 * @property {import("./Zoom.js").Options} [zoomOptions] Options for
 * {@link module:ol/control/Zoom~Zoom}.
 */

/**
 * Set of controls included in maps by default. Unless configured otherwise,
 * this returns a collection containing an instance of each of the following
 * controls:
 * * {@link module:ol/control/Zoom~Zoom}
 * * {@link module:ol/control/Rotate~Rotate}
 * * {@link module:ol/control/Attribution~Attribution}
 *
 * @param {DefaultsOptions} [options] Options for the default controls.
 * @return {Collection<import("./Control.js").default>} A collection of controls
 * to be used with the {@link module:ol/Map~Map} constructor's `controls` option.
 * @api
 */
function defaults(options) {
  options = options ? options : {};

  /** @type {Collection<import("./Control.js").default>} */
  const controls = new _Collection_js__WEBPACK_IMPORTED_MODULE_0__["default"]();

  const zoomControl = options.zoom !== undefined ? options.zoom : true;
  if (zoomControl) {
    controls.push(new _Zoom_js__WEBPACK_IMPORTED_MODULE_1__["default"](options.zoomOptions));
  }

  const rotateControl = options.rotate !== undefined ? options.rotate : true;
  if (rotateControl) {
    controls.push(new _Rotate_js__WEBPACK_IMPORTED_MODULE_2__["default"](options.rotateOptions));
  }

  const attributionControl =
    options.attribution !== undefined ? options.attribution : true;
  if (attributionControl) {
    controls.push(new _Attribution_js__WEBPACK_IMPORTED_MODULE_3__["default"](options.attributionOptions));
  }

  return controls;
}


/***/ }),

/***/ "./node_modules/ol/coordinate.js":
/*!***************************************!*\
  !*** ./node_modules/ol/coordinate.js ***!
  \***************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   add: () => (/* binding */ add),
/* harmony export */   closestOnCircle: () => (/* binding */ closestOnCircle),
/* harmony export */   closestOnSegment: () => (/* binding */ closestOnSegment),
/* harmony export */   createStringXY: () => (/* binding */ createStringXY),
/* harmony export */   degreesToStringHDMS: () => (/* binding */ degreesToStringHDMS),
/* harmony export */   distance: () => (/* binding */ distance),
/* harmony export */   equals: () => (/* binding */ equals),
/* harmony export */   format: () => (/* binding */ format),
/* harmony export */   getWorldsAway: () => (/* binding */ getWorldsAway),
/* harmony export */   rotate: () => (/* binding */ rotate),
/* harmony export */   scale: () => (/* binding */ scale),
/* harmony export */   squaredDistance: () => (/* binding */ squaredDistance),
/* harmony export */   squaredDistanceToSegment: () => (/* binding */ squaredDistanceToSegment),
/* harmony export */   toStringHDMS: () => (/* binding */ toStringHDMS),
/* harmony export */   toStringXY: () => (/* binding */ toStringXY),
/* harmony export */   wrapX: () => (/* binding */ wrapX)
/* harmony export */ });
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.js */ "./node_modules/ol/math.js");
/* harmony import */ var _string_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./string.js */ "./node_modules/ol/string.js");
/**
 * @module ol/coordinate
 */




/**
 * An array of numbers representing an `xy`, `xyz` or `xyzm` coordinate.
 * Example: `[16, 48]`.
 * @typedef {Array<number>} Coordinate
 * @api
 */

/**
 * A function that takes a {@link module:ol/coordinate~Coordinate} and
 * transforms it into a `{string}`.
 *
 * @typedef {function((Coordinate|undefined)): string} CoordinateFormat
 * @api
 */

/**
 * Add `delta` to `coordinate`. `coordinate` is modified in place and returned
 * by the function.
 *
 * Example:
 *
 *     import {add} from 'ol/coordinate.js';
 *
 *     const coord = [7.85, 47.983333];
 *     add(coord, [-2, 4]);
 *     // coord is now [5.85, 51.983333]
 *
 * @param {Coordinate} coordinate Coordinate.
 * @param {Coordinate} delta Delta.
 * @return {Coordinate} The input coordinate adjusted by
 * the given delta.
 * @api
 */
function add(coordinate, delta) {
  coordinate[0] += +delta[0];
  coordinate[1] += +delta[1];
  return coordinate;
}

/**
 * Calculates the point closest to the passed coordinate on the passed circle.
 *
 * @param {Coordinate} coordinate The coordinate.
 * @param {import("./geom/Circle.js").default} circle The circle.
 * @return {Coordinate} Closest point on the circumference.
 */
function closestOnCircle(coordinate, circle) {
  const r = circle.getRadius();
  const center = circle.getCenter();
  const x0 = center[0];
  const y0 = center[1];
  const x1 = coordinate[0];
  const y1 = coordinate[1];

  let dx = x1 - x0;
  const dy = y1 - y0;
  if (dx === 0 && dy === 0) {
    dx = 1;
  }
  const d = Math.sqrt(dx * dx + dy * dy);

  const x = x0 + (r * dx) / d;
  const y = y0 + (r * dy) / d;

  return [x, y];
}

/**
 * Calculates the point closest to the passed coordinate on the passed segment.
 * This is the foot of the perpendicular of the coordinate to the segment when
 * the foot is on the segment, or the closest segment coordinate when the foot
 * is outside the segment.
 *
 * @param {Coordinate} coordinate The coordinate.
 * @param {Array<Coordinate>} segment The two coordinates
 * of the segment.
 * @return {Coordinate} The foot of the perpendicular of
 * the coordinate to the segment.
 */
function closestOnSegment(coordinate, segment) {
  const x0 = coordinate[0];
  const y0 = coordinate[1];
  const start = segment[0];
  const end = segment[1];
  const x1 = start[0];
  const y1 = start[1];
  const x2 = end[0];
  const y2 = end[1];
  const dx = x2 - x1;
  const dy = y2 - y1;
  const along =
    dx === 0 && dy === 0
      ? 0
      : (dx * (x0 - x1) + dy * (y0 - y1)) / (dx * dx + dy * dy || 0);
  let x, y;
  if (along <= 0) {
    x = x1;
    y = y1;
  } else if (along >= 1) {
    x = x2;
    y = y2;
  } else {
    x = x1 + along * dx;
    y = y1 + along * dy;
  }
  return [x, y];
}

/**
 * Returns a {@link module:ol/coordinate~CoordinateFormat} function that can be
 * used to format
 * a {Coordinate} to a string.
 *
 * Example without specifying the fractional digits:
 *
 *     import {createStringXY} from 'ol/coordinate.js';
 *
 *     const coord = [7.85, 47.983333];
 *     const stringifyFunc = createStringXY();
 *     const out = stringifyFunc(coord);
 *     // out is now '8, 48'
 *
 * Example with explicitly specifying 2 fractional digits:
 *
 *     import {createStringXY} from 'ol/coordinate.js';
 *
 *     const coord = [7.85, 47.983333];
 *     const stringifyFunc = createStringXY(2);
 *     const out = stringifyFunc(coord);
 *     // out is now '7.85, 47.98'
 *
 * @param {number} [fractionDigits] The number of digits to include
 *    after the decimal point. Default is `0`.
 * @return {CoordinateFormat} Coordinate format.
 * @api
 */
function createStringXY(fractionDigits) {
  return (
    /**
     * @param {Coordinate} coordinate Coordinate.
     * @return {string} String XY.
     */
    function (coordinate) {
      return toStringXY(coordinate, fractionDigits);
    }
  );
}

/**
 * @param {string} hemispheres Hemispheres.
 * @param {number} degrees Degrees.
 * @param {number} [fractionDigits] The number of digits to include
 *    after the decimal point. Default is `0`.
 * @return {string} String.
 */
function degreesToStringHDMS(hemispheres, degrees, fractionDigits) {
  const normalizedDegrees = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.modulo)(degrees + 180, 360) - 180;
  const x = Math.abs(3600 * normalizedDegrees);
  const decimals = fractionDigits || 0;

  let deg = Math.floor(x / 3600);
  let min = Math.floor((x - deg * 3600) / 60);
  let sec = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.toFixed)(x - deg * 3600 - min * 60, decimals);

  if (sec >= 60) {
    sec = 0;
    min += 1;
  }

  if (min >= 60) {
    min = 0;
    deg += 1;
  }

  let hdms = deg + '\u00b0';
  if (min !== 0 || sec !== 0) {
    hdms += ' ' + (0,_string_js__WEBPACK_IMPORTED_MODULE_1__.padNumber)(min, 2) + '\u2032';
  }
  if (sec !== 0) {
    hdms += ' ' + (0,_string_js__WEBPACK_IMPORTED_MODULE_1__.padNumber)(sec, 2, decimals) + '\u2033';
  }
  if (normalizedDegrees !== 0) {
    hdms += ' ' + hemispheres.charAt(normalizedDegrees < 0 ? 1 : 0);
  }

  return hdms;
}

/**
 * Transforms the given {@link module:ol/coordinate~Coordinate} to a string
 * using the given string template. The strings `{x}` and `{y}` in the template
 * will be replaced with the first and second coordinate values respectively.
 *
 * Example without specifying the fractional digits:
 *
 *     import {format} from 'ol/coordinate.js';
 *
 *     const coord = [7.85, 47.983333];
 *     const template = 'Coordinate is ({x}|{y}).';
 *     const out = format(coord, template);
 *     // out is now 'Coordinate is (8|48).'
 *
 * Example explicitly specifying the fractional digits:
 *
 *     import {format} from 'ol/coordinate.js';
 *
 *     const coord = [7.85, 47.983333];
 *     const template = 'Coordinate is ({x}|{y}).';
 *     const out = format(coord, template, 2);
 *     // out is now 'Coordinate is (7.85|47.98).'
 *
 * @param {Coordinate} coordinate Coordinate.
 * @param {string} template A template string with `{x}` and `{y}` placeholders
 *     that will be replaced by first and second coordinate values.
 * @param {number} [fractionDigits] The number of digits to include
 *    after the decimal point. Default is `0`.
 * @return {string} Formatted coordinate.
 * @api
 */
function format(coordinate, template, fractionDigits) {
  if (coordinate) {
    return template
      .replace('{x}', coordinate[0].toFixed(fractionDigits))
      .replace('{y}', coordinate[1].toFixed(fractionDigits));
  }
  return '';
}

/**
 * @param {Coordinate} coordinate1 First coordinate.
 * @param {Coordinate} coordinate2 Second coordinate.
 * @return {boolean} The two coordinates are equal.
 */
function equals(coordinate1, coordinate2) {
  let equals = true;
  for (let i = coordinate1.length - 1; i >= 0; --i) {
    if (coordinate1[i] != coordinate2[i]) {
      equals = false;
      break;
    }
  }
  return equals;
}

/**
 * Rotate `coordinate` by `angle`. `coordinate` is modified in place and
 * returned by the function.
 *
 * Example:
 *
 *     import {rotate} from 'ol/coordinate.js';
 *
 *     const coord = [7.85, 47.983333];
 *     const rotateRadians = Math.PI / 2; // 90 degrees
 *     rotate(coord, rotateRadians);
 *     // coord is now [-47.983333, 7.85]
 *
 * @param {Coordinate} coordinate Coordinate.
 * @param {number} angle Angle in radian.
 * @return {Coordinate} Coordinate.
 * @api
 */
function rotate(coordinate, angle) {
  const cosAngle = Math.cos(angle);
  const sinAngle = Math.sin(angle);
  const x = coordinate[0] * cosAngle - coordinate[1] * sinAngle;
  const y = coordinate[1] * cosAngle + coordinate[0] * sinAngle;
  coordinate[0] = x;
  coordinate[1] = y;
  return coordinate;
}

/**
 * Scale `coordinate` by `scale`. `coordinate` is modified in place and returned
 * by the function.
 *
 * Example:
 *
 *     import {scale as scaleCoordinate} from 'ol/coordinate.js';
 *
 *     const coord = [7.85, 47.983333];
 *     const scale = 1.2;
 *     scaleCoordinate(coord, scale);
 *     // coord is now [9.42, 57.5799996]
 *
 * @param {Coordinate} coordinate Coordinate.
 * @param {number} scale Scale factor.
 * @return {Coordinate} Coordinate.
 */
function scale(coordinate, scale) {
  coordinate[0] *= scale;
  coordinate[1] *= scale;
  return coordinate;
}

/**
 * @param {Coordinate} coord1 First coordinate.
 * @param {Coordinate} coord2 Second coordinate.
 * @return {number} Squared distance between coord1 and coord2.
 */
function squaredDistance(coord1, coord2) {
  const dx = coord1[0] - coord2[0];
  const dy = coord1[1] - coord2[1];
  return dx * dx + dy * dy;
}

/**
 * @param {Coordinate} coord1 First coordinate.
 * @param {Coordinate} coord2 Second coordinate.
 * @return {number} Distance between coord1 and coord2.
 */
function distance(coord1, coord2) {
  return Math.sqrt(squaredDistance(coord1, coord2));
}

/**
 * Calculate the squared distance from a coordinate to a line segment.
 *
 * @param {Coordinate} coordinate Coordinate of the point.
 * @param {Array<Coordinate>} segment Line segment (2
 * coordinates).
 * @return {number} Squared distance from the point to the line segment.
 */
function squaredDistanceToSegment(coordinate, segment) {
  return squaredDistance(coordinate, closestOnSegment(coordinate, segment));
}

/**
 * Format a geographic coordinate with the hemisphere, degrees, minutes, and
 * seconds.
 *
 * Example without specifying fractional digits:
 *
 *     import {toStringHDMS} from 'ol/coordinate.js';
 *
 *     const coord = [7.85, 47.983333];
 *     const out = toStringHDMS(coord);
 *     // out is now '47° 58′ 60″ N 7° 50′ 60″ E'
 *
 * Example explicitly specifying 1 fractional digit:
 *
 *     import {toStringHDMS} from 'ol/coordinate.js';
 *
 *     const coord = [7.85, 47.983333];
 *     const out = toStringHDMS(coord, 1);
 *     // out is now '47° 58′ 60.0″ N 7° 50′ 60.0″ E'
 *
 * @param {Coordinate} coordinate Coordinate.
 * @param {number} [fractionDigits] The number of digits to include
 *    after the decimal point. Default is `0`.
 * @return {string} Hemisphere, degrees, minutes and seconds.
 * @api
 */
function toStringHDMS(coordinate, fractionDigits) {
  if (coordinate) {
    return (
      degreesToStringHDMS('NS', coordinate[1], fractionDigits) +
      ' ' +
      degreesToStringHDMS('EW', coordinate[0], fractionDigits)
    );
  }
  return '';
}

/**
 * Format a coordinate as a comma delimited string.
 *
 * Example without specifying fractional digits:
 *
 *     import {toStringXY} from 'ol/coordinate.js';
 *
 *     const coord = [7.85, 47.983333];
 *     const out = toStringXY(coord);
 *     // out is now '8, 48'
 *
 * Example explicitly specifying 1 fractional digit:
 *
 *     import {toStringXY} from 'ol/coordinate.js';
 *
 *     const coord = [7.85, 47.983333];
 *     const out = toStringXY(coord, 1);
 *     // out is now '7.8, 48.0'
 *
 * @param {Coordinate} coordinate Coordinate.
 * @param {number} [fractionDigits] The number of digits to include
 *    after the decimal point. Default is `0`.
 * @return {string} XY.
 * @api
 */
function toStringXY(coordinate, fractionDigits) {
  return format(coordinate, '{x}, {y}', fractionDigits);
}

/**
 * Modifies the provided coordinate in-place to be within the real world
 * extent. The lower projection extent boundary is inclusive, the upper one
 * exclusive.
 *
 * @param {Coordinate} coordinate Coordinate.
 * @param {import("./proj/Projection.js").default} projection Projection.
 * @return {Coordinate} The coordinate within the real world extent.
 */
function wrapX(coordinate, projection) {
  if (projection.canWrapX()) {
    const worldWidth = (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.getWidth)(projection.getExtent());
    const worldsAway = getWorldsAway(coordinate, projection, worldWidth);
    if (worldsAway) {
      coordinate[0] -= worldsAway * worldWidth;
    }
  }
  return coordinate;
}
/**
 * @param {Coordinate} coordinate Coordinate.
 * @param {import("./proj/Projection.js").default} projection Projection.
 * @param {number} [sourceExtentWidth] Width of the source extent.
 * @return {number} Offset in world widths.
 */
function getWorldsAway(coordinate, projection, sourceExtentWidth) {
  const projectionExtent = projection.getExtent();
  let worldsAway = 0;
  if (
    projection.canWrapX() &&
    (coordinate[0] < projectionExtent[0] || coordinate[0] > projectionExtent[2])
  ) {
    sourceExtentWidth = sourceExtentWidth || (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.getWidth)(projectionExtent);
    worldsAway = Math.floor(
      (coordinate[0] - projectionExtent[0]) / sourceExtentWidth
    );
  }
  return worldsAway;
}


/***/ }),

/***/ "./node_modules/ol/css.js":
/*!********************************!*\
  !*** ./node_modules/ol/css.js ***!
  \********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CLASS_COLLAPSED: () => (/* binding */ CLASS_COLLAPSED),
/* harmony export */   CLASS_CONTROL: () => (/* binding */ CLASS_CONTROL),
/* harmony export */   CLASS_HIDDEN: () => (/* binding */ CLASS_HIDDEN),
/* harmony export */   CLASS_SELECTABLE: () => (/* binding */ CLASS_SELECTABLE),
/* harmony export */   CLASS_UNSELECTABLE: () => (/* binding */ CLASS_UNSELECTABLE),
/* harmony export */   CLASS_UNSUPPORTED: () => (/* binding */ CLASS_UNSUPPORTED),
/* harmony export */   getFontParameters: () => (/* binding */ getFontParameters)
/* harmony export */ });
/**
 * @module ol/css
 */

/**
 * @typedef {Object} FontParameters
 * @property {string} style Style.
 * @property {string} variant Variant.
 * @property {string} weight Weight.
 * @property {string} size Size.
 * @property {string} lineHeight LineHeight.
 * @property {string} family Family.
 * @property {Array<string>} families Families.
 */

/**
 * The CSS class for hidden feature.
 *
 * @const
 * @type {string}
 */
const CLASS_HIDDEN = 'ol-hidden';

/**
 * The CSS class that we'll give the DOM elements to have them selectable.
 *
 * @const
 * @type {string}
 */
const CLASS_SELECTABLE = 'ol-selectable';

/**
 * The CSS class that we'll give the DOM elements to have them unselectable.
 *
 * @const
 * @type {string}
 */
const CLASS_UNSELECTABLE = 'ol-unselectable';

/**
 * The CSS class for unsupported feature.
 *
 * @const
 * @type {string}
 */
const CLASS_UNSUPPORTED = 'ol-unsupported';

/**
 * The CSS class for controls.
 *
 * @const
 * @type {string}
 */
const CLASS_CONTROL = 'ol-control';

/**
 * The CSS class that we'll give the DOM elements that are collapsed, i.e.
 * to those elements which usually can be expanded.
 *
 * @const
 * @type {string}
 */
const CLASS_COLLAPSED = 'ol-collapsed';

/**
 * From https://stackoverflow.com/questions/10135697/regex-to-parse-any-css-font
 * @type {RegExp}
 */
const fontRegEx = new RegExp(
  [
    '^\\s*(?=(?:(?:[-a-z]+\\s*){0,2}(italic|oblique))?)',
    '(?=(?:(?:[-a-z]+\\s*){0,2}(small-caps))?)',
    '(?=(?:(?:[-a-z]+\\s*){0,2}(bold(?:er)?|lighter|[1-9]00 ))?)',
    '(?:(?:normal|\\1|\\2|\\3)\\s*){0,3}((?:xx?-)?',
    '(?:small|large)|medium|smaller|larger|[\\.\\d]+(?:\\%|in|[cem]m|ex|p[ctx]))',
    '(?:\\s*\\/\\s*(normal|[\\.\\d]+(?:\\%|in|[cem]m|ex|p[ctx])?))',
    '?\\s*([-,\\"\\\'\\sa-z]+?)\\s*$',
  ].join(''),
  'i'
);
const fontRegExMatchIndex = [
  'style',
  'variant',
  'weight',
  'size',
  'lineHeight',
  'family',
];

/**
 * Get the list of font families from a font spec.  Note that this doesn't work
 * for font families that have commas in them.
 * @param {string} fontSpec The CSS font property.
 * @return {FontParameters|null} The font parameters (or null if the input spec is invalid).
 */
const getFontParameters = function (fontSpec) {
  const match = fontSpec.match(fontRegEx);
  if (!match) {
    return null;
  }
  const style = /** @type {FontParameters} */ ({
    lineHeight: 'normal',
    size: '1.2em',
    style: 'normal',
    weight: 'normal',
    variant: 'normal',
  });
  for (let i = 0, ii = fontRegExMatchIndex.length; i < ii; ++i) {
    const value = match[i + 1];
    if (value !== undefined) {
      style[fontRegExMatchIndex[i]] = value;
    }
  }
  style.families = style.family.split(/,\s?/);
  return style;
};


/***/ }),

/***/ "./node_modules/ol/dom.js":
/*!********************************!*\
  !*** ./node_modules/ol/dom.js ***!
  \********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createCanvasContext2D: () => (/* binding */ createCanvasContext2D),
/* harmony export */   outerHeight: () => (/* binding */ outerHeight),
/* harmony export */   outerWidth: () => (/* binding */ outerWidth),
/* harmony export */   releaseCanvas: () => (/* binding */ releaseCanvas),
/* harmony export */   removeChildren: () => (/* binding */ removeChildren),
/* harmony export */   removeNode: () => (/* binding */ removeNode),
/* harmony export */   replaceChildren: () => (/* binding */ replaceChildren),
/* harmony export */   replaceNode: () => (/* binding */ replaceNode)
/* harmony export */ });
/* harmony import */ var _has_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./has.js */ "./node_modules/ol/has.js");


/**
 * @module ol/dom
 */

//FIXME Move this function to the canvas module
/**
 * Create an html canvas element and returns its 2d context.
 * @param {number} [width] Canvas width.
 * @param {number} [height] Canvas height.
 * @param {Array<HTMLCanvasElement>} [canvasPool] Canvas pool to take existing canvas from.
 * @param {CanvasRenderingContext2DSettings} [settings] CanvasRenderingContext2DSettings
 * @return {CanvasRenderingContext2D} The context.
 */
function createCanvasContext2D(width, height, canvasPool, settings) {
  /** @type {HTMLCanvasElement|OffscreenCanvas} */
  let canvas;
  if (canvasPool && canvasPool.length) {
    canvas = canvasPool.shift();
  } else if (_has_js__WEBPACK_IMPORTED_MODULE_0__.WORKER_OFFSCREEN_CANVAS) {
    canvas = new OffscreenCanvas(width || 300, height || 300);
  } else {
    canvas = document.createElement('canvas');
  }
  if (width) {
    canvas.width = width;
  }
  if (height) {
    canvas.height = height;
  }
  //FIXME Allow OffscreenCanvasRenderingContext2D as return type
  return /** @type {CanvasRenderingContext2D} */ (
    canvas.getContext('2d', settings)
  );
}

/**
 * Releases canvas memory to avoid exceeding memory limits in Safari.
 * See https://pqina.nl/blog/total-canvas-memory-use-exceeds-the-maximum-limit/
 * @param {CanvasRenderingContext2D} context Context.
 */
function releaseCanvas(context) {
  const canvas = context.canvas;
  canvas.width = 1;
  canvas.height = 1;
  context.clearRect(0, 0, 1, 1);
}

/**
 * Get the current computed width for the given element including margin,
 * padding and border.
 * Equivalent to jQuery's `$(el).outerWidth(true)`.
 * @param {!HTMLElement} element Element.
 * @return {number} The width.
 */
function outerWidth(element) {
  let width = element.offsetWidth;
  const style = getComputedStyle(element);
  width += parseInt(style.marginLeft, 10) + parseInt(style.marginRight, 10);

  return width;
}

/**
 * Get the current computed height for the given element including margin,
 * padding and border.
 * Equivalent to jQuery's `$(el).outerHeight(true)`.
 * @param {!HTMLElement} element Element.
 * @return {number} The height.
 */
function outerHeight(element) {
  let height = element.offsetHeight;
  const style = getComputedStyle(element);
  height += parseInt(style.marginTop, 10) + parseInt(style.marginBottom, 10);

  return height;
}

/**
 * @param {Node} newNode Node to replace old node
 * @param {Node} oldNode The node to be replaced
 */
function replaceNode(newNode, oldNode) {
  const parent = oldNode.parentNode;
  if (parent) {
    parent.replaceChild(newNode, oldNode);
  }
}

/**
 * @param {Node} node The node to remove.
 * @return {Node|null} The node that was removed or null.
 */
function removeNode(node) {
  return node && node.parentNode ? node.parentNode.removeChild(node) : null;
}

/**
 * @param {Node} node The node to remove the children from.
 */
function removeChildren(node) {
  while (node.lastChild) {
    node.removeChild(node.lastChild);
  }
}

/**
 * Transform the children of a parent node so they match the
 * provided list of children.  This function aims to efficiently
 * remove, add, and reorder child nodes while maintaining a simple
 * implementation (it is not guaranteed to minimize DOM operations).
 * @param {Node} node The parent node whose children need reworking.
 * @param {Array<Node>} children The desired children.
 */
function replaceChildren(node, children) {
  const oldChildren = node.childNodes;

  for (let i = 0; true; ++i) {
    const oldChild = oldChildren[i];
    const newChild = children[i];

    // check if our work is done
    if (!oldChild && !newChild) {
      break;
    }

    // check if children match
    if (oldChild === newChild) {
      continue;
    }

    // check if a new child needs to be added
    if (!oldChild) {
      node.appendChild(newChild);
      continue;
    }

    // check if an old child needs to be removed
    if (!newChild) {
      node.removeChild(oldChild);
      --i;
      continue;
    }

    // reorder
    node.insertBefore(newChild, oldChild);
  }
}


/***/ }),

/***/ "./node_modules/ol/easing.js":
/*!***********************************!*\
  !*** ./node_modules/ol/easing.js ***!
  \***********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   easeIn: () => (/* binding */ easeIn),
/* harmony export */   easeOut: () => (/* binding */ easeOut),
/* harmony export */   inAndOut: () => (/* binding */ inAndOut),
/* harmony export */   linear: () => (/* binding */ linear),
/* harmony export */   upAndDown: () => (/* binding */ upAndDown)
/* harmony export */ });
/**
 * @module ol/easing
 */

/**
 * Start slow and speed up.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @api
 */
function easeIn(t) {
  return Math.pow(t, 3);
}

/**
 * Start fast and slow down.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @api
 */
function easeOut(t) {
  return 1 - easeIn(1 - t);
}

/**
 * Start slow, speed up, and then slow down again.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @api
 */
function inAndOut(t) {
  return 3 * t * t - 2 * t * t * t;
}

/**
 * Maintain a constant speed over time.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @api
 */
function linear(t) {
  return t;
}

/**
 * Start slow, speed up, and at the very end slow down again.  This has the
 * same general behavior as {@link module:ol/easing.inAndOut}, but the final
 * slowdown is delayed.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @api
 */
function upAndDown(t) {
  if (t < 0.5) {
    return inAndOut(2 * t);
  }
  return 1 - inAndOut(2 * (t - 0.5));
}


/***/ }),

/***/ "./node_modules/ol/events.js":
/*!***********************************!*\
  !*** ./node_modules/ol/events.js ***!
  \***********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   listen: () => (/* binding */ listen),
/* harmony export */   listenOnce: () => (/* binding */ listenOnce),
/* harmony export */   unlistenByKey: () => (/* binding */ unlistenByKey)
/* harmony export */ });
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./obj.js */ "./node_modules/ol/obj.js");
/**
 * @module ol/events
 */


/**
 * Key to use with {@link module:ol/Observable.unByKey}.
 * @typedef {Object} EventsKey
 * @property {ListenerFunction} listener Listener.
 * @property {import("./events/Target.js").EventTargetLike} target Target.
 * @property {string} type Type.
 * @api
 */

/**
 * Listener function. This function is called with an event object as argument.
 * When the function returns `false`, event propagation will stop.
 *
 * @typedef {function((Event|import("./events/Event.js").default)): (void|boolean)} ListenerFunction
 * @api
 */

/**
 * @typedef {Object} ListenerObject
 * @property {ListenerFunction} handleEvent HandleEvent listener function.
 */

/**
 * @typedef {ListenerFunction|ListenerObject} Listener
 */

/**
 * Registers an event listener on an event target. Inspired by
 * https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html
 *
 * This function efficiently binds a `listener` to a `this` object, and returns
 * a key for use with {@link module:ol/events.unlistenByKey}.
 *
 * @param {import("./events/Target.js").EventTargetLike} target Event target.
 * @param {string} type Event type.
 * @param {ListenerFunction} listener Listener.
 * @param {Object} [thisArg] Object referenced by the `this` keyword in the
 *     listener. Default is the `target`.
 * @param {boolean} [once] If true, add the listener as one-off listener.
 * @return {EventsKey} Unique key for the listener.
 */
function listen(target, type, listener, thisArg, once) {
  if (thisArg && thisArg !== target) {
    listener = listener.bind(thisArg);
  }
  if (once) {
    const originalListener = listener;
    listener = function () {
      target.removeEventListener(type, listener);
      originalListener.apply(this, arguments);
    };
  }
  const eventsKey = {
    target: target,
    type: type,
    listener: listener,
  };
  target.addEventListener(type, listener);
  return eventsKey;
}

/**
 * Registers a one-off event listener on an event target. Inspired by
 * https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html
 *
 * This function efficiently binds a `listener` as self-unregistering listener
 * to a `this` object, and returns a key for use with
 * {@link module:ol/events.unlistenByKey} in case the listener needs to be
 * unregistered before it is called.
 *
 * When {@link module:ol/events.listen} is called with the same arguments after this
 * function, the self-unregistering listener will be turned into a permanent
 * listener.
 *
 * @param {import("./events/Target.js").EventTargetLike} target Event target.
 * @param {string} type Event type.
 * @param {ListenerFunction} listener Listener.
 * @param {Object} [thisArg] Object referenced by the `this` keyword in the
 *     listener. Default is the `target`.
 * @return {EventsKey} Key for unlistenByKey.
 */
function listenOnce(target, type, listener, thisArg) {
  return listen(target, type, listener, thisArg, true);
}

/**
 * Unregisters event listeners on an event target. Inspired by
 * https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html
 *
 * The argument passed to this function is the key returned from
 * {@link module:ol/events.listen} or {@link module:ol/events.listenOnce}.
 *
 * @param {EventsKey} key The key.
 */
function unlistenByKey(key) {
  if (key && key.target) {
    key.target.removeEventListener(key.type, key.listener);
    (0,_obj_js__WEBPACK_IMPORTED_MODULE_0__.clear)(key);
  }
}


/***/ }),

/***/ "./node_modules/ol/events/Event.js":
/*!*****************************************!*\
  !*** ./node_modules/ol/events/Event.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   preventDefault: () => (/* binding */ preventDefault),
/* harmony export */   stopPropagation: () => (/* binding */ stopPropagation)
/* harmony export */ });
/**
 * @module ol/events/Event
 */

/**
 * @classdesc
 * Stripped down implementation of the W3C DOM Level 2 Event interface.
 * See https://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-interface.
 *
 * This implementation only provides `type` and `target` properties, and
 * `stopPropagation` and `preventDefault` methods. It is meant as base class
 * for higher level events defined in the library, and works with
 * {@link module:ol/events/Target~Target}.
 */
class BaseEvent {
  /**
   * @param {string} type Type.
   */
  constructor(type) {
    /**
     * @type {boolean}
     */
    this.propagationStopped;

    /**
     * @type {boolean}
     */
    this.defaultPrevented;

    /**
     * The event type.
     * @type {string}
     * @api
     */
    this.type = type;

    /**
     * The event target.
     * @type {Object}
     * @api
     */
    this.target = null;
  }

  /**
   * Prevent default. This means that no emulated `click`, `singleclick` or `doubleclick` events
   * will be fired.
   * @api
   */
  preventDefault() {
    this.defaultPrevented = true;
  }

  /**
   * Stop event propagation.
   * @api
   */
  stopPropagation() {
    this.propagationStopped = true;
  }
}

/**
 * @param {Event|import("./Event.js").default} evt Event
 */
function stopPropagation(evt) {
  evt.stopPropagation();
}

/**
 * @param {Event|import("./Event.js").default} evt Event
 */
function preventDefault(evt) {
  evt.preventDefault();
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (BaseEvent);


/***/ }),

/***/ "./node_modules/ol/events/EventType.js":
/*!*********************************************!*\
  !*** ./node_modules/ol/events/EventType.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * @module ol/events/EventType
 */

/**
 * @enum {string}
 * @const
 */
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  /**
   * Generic change event. Triggered when the revision counter is increased.
   * @event module:ol/events/Event~BaseEvent#change
   * @api
   */
  CHANGE: 'change',

  /**
   * Generic error event. Triggered when an error occurs.
   * @event module:ol/events/Event~BaseEvent#error
   * @api
   */
  ERROR: 'error',

  BLUR: 'blur',
  CLEAR: 'clear',
  CONTEXTMENU: 'contextmenu',
  CLICK: 'click',
  DBLCLICK: 'dblclick',
  DRAGENTER: 'dragenter',
  DRAGOVER: 'dragover',
  DROP: 'drop',
  FOCUS: 'focus',
  KEYDOWN: 'keydown',
  KEYPRESS: 'keypress',
  LOAD: 'load',
  RESIZE: 'resize',
  TOUCHMOVE: 'touchmove',
  WHEEL: 'wheel',
});


/***/ }),

/***/ "./node_modules/ol/events/Key.js":
/*!***************************************!*\
  !*** ./node_modules/ol/events/Key.js ***!
  \***************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * @module ol/events/Key
 */

/**
 * @enum {string}
 * @const
 */
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  LEFT: 'ArrowLeft',
  UP: 'ArrowUp',
  RIGHT: 'ArrowRight',
  DOWN: 'ArrowDown',
});


/***/ }),

/***/ "./node_modules/ol/events/Target.js":
/*!******************************************!*\
  !*** ./node_modules/ol/events/Target.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Disposable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Disposable.js */ "./node_modules/ol/Disposable.js");
/* harmony import */ var _Event_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Event.js */ "./node_modules/ol/events/Event.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../functions.js */ "./node_modules/ol/functions.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../obj.js */ "./node_modules/ol/obj.js");
/**
 * @module ol/events/Target
 */





/**
 * @typedef {EventTarget|Target} EventTargetLike
 */

/**
 * @classdesc
 * A simplified implementation of the W3C DOM Level 2 EventTarget interface.
 * See https://www.w3.org/TR/2000/REC-DOM-Level-2-Events-20001113/events.html#Events-EventTarget.
 *
 * There are two important simplifications compared to the specification:
 *
 * 1. The handling of `useCapture` in `addEventListener` and
 *    `removeEventListener`. There is no real capture model.
 * 2. The handling of `stopPropagation` and `preventDefault` on `dispatchEvent`.
 *    There is no event target hierarchy. When a listener calls
 *    `stopPropagation` or `preventDefault` on an event object, it means that no
 *    more listeners after this one will be called. Same as when the listener
 *    returns false.
 */
class Target extends _Disposable_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {*} [target] Default event target for dispatched events.
   */
  constructor(target) {
    super();

    /**
     * @private
     * @type {*}
     */
    this.eventTarget_ = target;

    /**
     * @private
     * @type {Object<string, number>}
     */
    this.pendingRemovals_ = null;

    /**
     * @private
     * @type {Object<string, number>}
     */
    this.dispatching_ = null;

    /**
     * @private
     * @type {Object<string, Array<import("../events.js").Listener>>}
     */
    this.listeners_ = null;
  }

  /**
   * @param {string} type Type.
   * @param {import("../events.js").Listener} listener Listener.
   */
  addEventListener(type, listener) {
    if (!type || !listener) {
      return;
    }
    const listeners = this.listeners_ || (this.listeners_ = {});
    const listenersForType = listeners[type] || (listeners[type] = []);
    if (!listenersForType.includes(listener)) {
      listenersForType.push(listener);
    }
  }

  /**
   * Dispatches an event and calls all listeners listening for events
   * of this type. The event parameter can either be a string or an
   * Object with a `type` property.
   *
   * @param {import("./Event.js").default|string} event Event object.
   * @return {boolean|undefined} `false` if anyone called preventDefault on the
   *     event object or if any of the listeners returned false.
   * @api
   */
  dispatchEvent(event) {
    const isString = typeof event === 'string';
    const type = isString ? event : event.type;
    const listeners = this.listeners_ && this.listeners_[type];
    if (!listeners) {
      return;
    }

    const evt = isString ? new _Event_js__WEBPACK_IMPORTED_MODULE_1__["default"](event) : /** @type {Event} */ (event);
    if (!evt.target) {
      evt.target = this.eventTarget_ || this;
    }
    const dispatching = this.dispatching_ || (this.dispatching_ = {});
    const pendingRemovals =
      this.pendingRemovals_ || (this.pendingRemovals_ = {});
    if (!(type in dispatching)) {
      dispatching[type] = 0;
      pendingRemovals[type] = 0;
    }
    ++dispatching[type];
    let propagate;
    for (let i = 0, ii = listeners.length; i < ii; ++i) {
      if ('handleEvent' in listeners[i]) {
        propagate = /** @type {import("../events.js").ListenerObject} */ (
          listeners[i]
        ).handleEvent(evt);
      } else {
        propagate = /** @type {import("../events.js").ListenerFunction} */ (
          listeners[i]
        ).call(this, evt);
      }
      if (propagate === false || evt.propagationStopped) {
        propagate = false;
        break;
      }
    }
    if (--dispatching[type] === 0) {
      let pr = pendingRemovals[type];
      delete pendingRemovals[type];
      while (pr--) {
        this.removeEventListener(type, _functions_js__WEBPACK_IMPORTED_MODULE_2__.VOID);
      }
      delete dispatching[type];
    }
    return propagate;
  }

  /**
   * Clean up.
   */
  disposeInternal() {
    this.listeners_ && (0,_obj_js__WEBPACK_IMPORTED_MODULE_3__.clear)(this.listeners_);
  }

  /**
   * Get the listeners for a specified event type. Listeners are returned in the
   * order that they will be called in.
   *
   * @param {string} type Type.
   * @return {Array<import("../events.js").Listener>|undefined} Listeners.
   */
  getListeners(type) {
    return (this.listeners_ && this.listeners_[type]) || undefined;
  }

  /**
   * @param {string} [type] Type. If not provided,
   *     `true` will be returned if this event target has any listeners.
   * @return {boolean} Has listeners.
   */
  hasListener(type) {
    if (!this.listeners_) {
      return false;
    }
    return type
      ? type in this.listeners_
      : Object.keys(this.listeners_).length > 0;
  }

  /**
   * @param {string} type Type.
   * @param {import("../events.js").Listener} listener Listener.
   */
  removeEventListener(type, listener) {
    const listeners = this.listeners_ && this.listeners_[type];
    if (listeners) {
      const index = listeners.indexOf(listener);
      if (index !== -1) {
        if (this.pendingRemovals_ && type in this.pendingRemovals_) {
          // make listener a no-op, and remove later in #dispatchEvent()
          listeners[index] = _functions_js__WEBPACK_IMPORTED_MODULE_2__.VOID;
          ++this.pendingRemovals_[type];
        } else {
          listeners.splice(index, 1);
          if (listeners.length === 0) {
            delete this.listeners_[type];
          }
        }
      }
    }
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Target);


/***/ }),

/***/ "./node_modules/ol/events/condition.js":
/*!*********************************************!*\
  !*** ./node_modules/ol/events/condition.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   all: () => (/* binding */ all),
/* harmony export */   altKeyOnly: () => (/* binding */ altKeyOnly),
/* harmony export */   altShiftKeysOnly: () => (/* binding */ altShiftKeysOnly),
/* harmony export */   always: () => (/* binding */ always),
/* harmony export */   click: () => (/* binding */ click),
/* harmony export */   doubleClick: () => (/* binding */ doubleClick),
/* harmony export */   focus: () => (/* binding */ focus),
/* harmony export */   focusWithTabindex: () => (/* binding */ focusWithTabindex),
/* harmony export */   mouseActionButton: () => (/* binding */ mouseActionButton),
/* harmony export */   mouseOnly: () => (/* binding */ mouseOnly),
/* harmony export */   never: () => (/* binding */ never),
/* harmony export */   noModifierKeys: () => (/* binding */ noModifierKeys),
/* harmony export */   penOnly: () => (/* binding */ penOnly),
/* harmony export */   platformModifierKey: () => (/* binding */ platformModifierKey),
/* harmony export */   platformModifierKeyOnly: () => (/* binding */ platformModifierKeyOnly),
/* harmony export */   pointerMove: () => (/* binding */ pointerMove),
/* harmony export */   primaryAction: () => (/* binding */ primaryAction),
/* harmony export */   shiftKeyOnly: () => (/* binding */ shiftKeyOnly),
/* harmony export */   singleClick: () => (/* binding */ singleClick),
/* harmony export */   targetNotEditable: () => (/* binding */ targetNotEditable),
/* harmony export */   touchOnly: () => (/* binding */ touchOnly)
/* harmony export */ });
/* harmony import */ var _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../MapBrowserEventType.js */ "./node_modules/ol/MapBrowserEventType.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../functions.js */ "./node_modules/ol/functions.js");
/* harmony import */ var _has_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../has.js */ "./node_modules/ol/has.js");
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../asserts.js */ "./node_modules/ol/asserts.js");
/**
 * @module ol/events/condition
 */





/**
 * A function that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * `{boolean}`. If the condition is met, true should be returned.
 *
 * @typedef {function(this: ?, import("../MapBrowserEvent.js").default): boolean} Condition
 */

/**
 * Creates a condition function that passes when all provided conditions pass.
 * @param {...Condition} var_args Conditions to check.
 * @return {Condition} Condition function.
 */
function all(var_args) {
  const conditions = arguments;
  /**
   * @param {import("../MapBrowserEvent.js").default} event Event.
   * @return {boolean} All conditions passed.
   */
  return function (event) {
    let pass = true;
    for (let i = 0, ii = conditions.length; i < ii; ++i) {
      pass = pass && conditions[i](event);
      if (!pass) {
        break;
      }
    }
    return pass;
  };
}

/**
 * Return `true` if only the alt-key is pressed, `false` otherwise (e.g. when
 * additionally the shift-key is pressed).
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True if only the alt key is pressed.
 * @api
 */
const altKeyOnly = function (mapBrowserEvent) {
  const originalEvent = /** @type {KeyboardEvent|MouseEvent|TouchEvent} */ (
    mapBrowserEvent.originalEvent
  );
  return (
    originalEvent.altKey &&
    !(originalEvent.metaKey || originalEvent.ctrlKey) &&
    !originalEvent.shiftKey
  );
};

/**
 * Return `true` if only the alt-key and shift-key is pressed, `false` otherwise
 * (e.g. when additionally the platform-modifier-key is pressed).
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True if only the alt and shift keys are pressed.
 * @api
 */
const altShiftKeysOnly = function (mapBrowserEvent) {
  const originalEvent = /** @type {KeyboardEvent|MouseEvent|TouchEvent} */ (
    mapBrowserEvent.originalEvent
  );
  return (
    originalEvent.altKey &&
    !(originalEvent.metaKey || originalEvent.ctrlKey) &&
    originalEvent.shiftKey
  );
};

/**
 * Return `true` if the map has the focus. This condition requires a map target
 * element with a `tabindex` attribute, e.g. `<div id="map" tabindex="1">`.
 *
 * @param {import("../MapBrowserEvent.js").default} event Map browser event.
 * @return {boolean} The map has the focus.
 * @api
 */
const focus = function (event) {
  const targetElement = event.map.getTargetElement();
  const activeElement = event.map.getOwnerDocument().activeElement;
  return targetElement.contains(activeElement);
};

/**
 * Return `true` if the map has the focus or no 'tabindex' attribute set.
 *
 * @param {import("../MapBrowserEvent.js").default} event Map browser event.
 * @return {boolean} The map container has the focus or no 'tabindex' attribute.
 */
const focusWithTabindex = function (event) {
  return event.map.getTargetElement().hasAttribute('tabindex')
    ? focus(event)
    : true;
};

/**
 * Return always true.
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True.
 * @api
 */
const always = _functions_js__WEBPACK_IMPORTED_MODULE_0__.TRUE;

/**
 * Return `true` if the event is a `click` event, `false` otherwise.
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True if the event is a map `click` event.
 * @api
 */
const click = function (mapBrowserEvent) {
  return mapBrowserEvent.type == _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].CLICK;
};

/**
 * Return `true` if the event has an "action"-producing mouse button.
 *
 * By definition, this includes left-click on windows/linux, and left-click
 * without the ctrl key on Macs.
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} The result.
 */
const mouseActionButton = function (mapBrowserEvent) {
  const originalEvent = /** @type {MouseEvent} */ (
    mapBrowserEvent.originalEvent
  );
  return originalEvent.button == 0 && !(_has_js__WEBPACK_IMPORTED_MODULE_2__.WEBKIT && _has_js__WEBPACK_IMPORTED_MODULE_2__.MAC && originalEvent.ctrlKey);
};

/**
 * Return always false.
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} False.
 * @api
 */
const never = _functions_js__WEBPACK_IMPORTED_MODULE_0__.FALSE;

/**
 * Return `true` if the browser event is a `pointermove` event, `false`
 * otherwise.
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True if the browser event is a `pointermove` event.
 * @api
 */
const pointerMove = function (mapBrowserEvent) {
  return mapBrowserEvent.type == 'pointermove';
};

/**
 * Return `true` if the event is a map `singleclick` event, `false` otherwise.
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True if the event is a map `singleclick` event.
 * @api
 */
const singleClick = function (mapBrowserEvent) {
  return mapBrowserEvent.type == _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].SINGLECLICK;
};

/**
 * Return `true` if the event is a map `dblclick` event, `false` otherwise.
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True if the event is a map `dblclick` event.
 * @api
 */
const doubleClick = function (mapBrowserEvent) {
  return mapBrowserEvent.type == _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].DBLCLICK;
};

/**
 * Return `true` if no modifier key (alt-, shift- or platform-modifier-key) is
 * pressed.
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True only if there no modifier keys are pressed.
 * @api
 */
const noModifierKeys = function (mapBrowserEvent) {
  const originalEvent = /** @type {KeyboardEvent|MouseEvent|TouchEvent} */ (
    mapBrowserEvent.originalEvent
  );
  return (
    !originalEvent.altKey &&
    !(originalEvent.metaKey || originalEvent.ctrlKey) &&
    !originalEvent.shiftKey
  );
};

/**
 * Return `true` if only the platform-modifier-key (the meta-key on Mac,
 * ctrl-key otherwise) is pressed, `false` otherwise (e.g. when additionally
 * the shift-key is pressed).
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True if only the platform modifier key is pressed.
 * @api
 */
const platformModifierKeyOnly = function (mapBrowserEvent) {
  const originalEvent = /** @type {KeyboardEvent|MouseEvent|TouchEvent} */ (
    mapBrowserEvent.originalEvent
  );
  return (
    !originalEvent.altKey &&
    (_has_js__WEBPACK_IMPORTED_MODULE_2__.MAC ? originalEvent.metaKey : originalEvent.ctrlKey) &&
    !originalEvent.shiftKey
  );
};

/**
 * Return `true` if the platform-modifier-key (the meta-key on Mac,
 * ctrl-key otherwise) is pressed.
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True if the platform modifier key is pressed.
 * @api
 */
const platformModifierKey = function (mapBrowserEvent) {
  const originalEvent = /** @type {KeyboardEvent|MouseEvent|TouchEvent} */ (
    mapBrowserEvent.originalEvent
  );
  return _has_js__WEBPACK_IMPORTED_MODULE_2__.MAC ? originalEvent.metaKey : originalEvent.ctrlKey;
};

/**
 * Return `true` if only the shift-key is pressed, `false` otherwise (e.g. when
 * additionally the alt-key is pressed).
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True if only the shift key is pressed.
 * @api
 */
const shiftKeyOnly = function (mapBrowserEvent) {
  const originalEvent = /** @type {KeyboardEvent|MouseEvent|TouchEvent} */ (
    mapBrowserEvent.originalEvent
  );
  return (
    !originalEvent.altKey &&
    !(originalEvent.metaKey || originalEvent.ctrlKey) &&
    originalEvent.shiftKey
  );
};

/**
 * Return `true` if the target element is not editable, i.e. not an `input`,
 * `select`, or `textarea` element and no `contenteditable` attribute is
 * set or inherited, `false` otherwise.
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True only if the target element is not editable.
 * @api
 */
const targetNotEditable = function (mapBrowserEvent) {
  const originalEvent = /** @type {KeyboardEvent|MouseEvent|TouchEvent} */ (
    mapBrowserEvent.originalEvent
  );
  const tagName = /** @type {Element} */ (originalEvent.target).tagName;
  return (
    tagName !== 'INPUT' &&
    tagName !== 'SELECT' &&
    tagName !== 'TEXTAREA' &&
    // `isContentEditable` is only available on `HTMLElement`, but it may also be a
    // different type like `SVGElement`.
    // @ts-ignore
    !originalEvent.target.isContentEditable
  );
};

/**
 * Return `true` if the event originates from a mouse device.
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True if the event originates from a mouse device.
 * @api
 */
const mouseOnly = function (mapBrowserEvent) {
  const pointerEvent = /** @type {import("../MapBrowserEvent").default} */ (
    mapBrowserEvent
  ).originalEvent;
  (0,_asserts_js__WEBPACK_IMPORTED_MODULE_3__.assert)(
    pointerEvent !== undefined,
    'mapBrowserEvent must originate from a pointer event'
  );
  // see https://www.w3.org/TR/pointerevents/#widl-PointerEvent-pointerType
  return pointerEvent.pointerType == 'mouse';
};

/**
 * Return `true` if the event originates from a touchable device.
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True if the event originates from a touchable device.
 * @api
 */
const touchOnly = function (mapBrowserEvent) {
  const pointerEvt = /** @type {import("../MapBrowserEvent").default} */ (
    mapBrowserEvent
  ).originalEvent;
  (0,_asserts_js__WEBPACK_IMPORTED_MODULE_3__.assert)(
    pointerEvt !== undefined,
    'mapBrowserEvent must originate from a pointer event'
  );
  // see https://www.w3.org/TR/pointerevents/#widl-PointerEvent-pointerType
  return pointerEvt.pointerType === 'touch';
};

/**
 * Return `true` if the event originates from a digital pen.
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True if the event originates from a digital pen.
 * @api
 */
const penOnly = function (mapBrowserEvent) {
  const pointerEvt = /** @type {import("../MapBrowserEvent").default} */ (
    mapBrowserEvent
  ).originalEvent;
  (0,_asserts_js__WEBPACK_IMPORTED_MODULE_3__.assert)(
    pointerEvt !== undefined,
    'mapBrowserEvent must originate from a pointer event'
  );
  // see https://www.w3.org/TR/pointerevents/#widl-PointerEvent-pointerType
  return pointerEvt.pointerType === 'pen';
};

/**
 * Return `true` if the event originates from a primary pointer in
 * contact with the surface or if the left mouse button is pressed.
 * See https://www.w3.org/TR/pointerevents/#button-states.
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True if the event originates from a primary pointer.
 * @api
 */
const primaryAction = function (mapBrowserEvent) {
  const pointerEvent = /** @type {import("../MapBrowserEvent").default} */ (
    mapBrowserEvent
  ).originalEvent;
  (0,_asserts_js__WEBPACK_IMPORTED_MODULE_3__.assert)(
    pointerEvent !== undefined,
    'mapBrowserEvent must originate from a pointer event'
  );
  return pointerEvent.isPrimary && pointerEvent.button === 0;
};


/***/ }),

/***/ "./node_modules/ol/expr/cpu.js":
/*!*************************************!*\
  !*** ./node_modules/ol/expr/cpu.js ***!
  \*************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   buildExpression: () => (/* binding */ buildExpression),
/* harmony export */   newEvaluationContext: () => (/* binding */ newEvaluationContext)
/* harmony export */ });
/* harmony import */ var _expression_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./expression.js */ "./node_modules/ol/expr/expression.js");
/**
 * @module ol/expr/cpu
 */



/**
 * @fileoverview This module includes functions to build expressions for evaluation on the CPU.
 * Building is composed of two steps: parsing and compiling.  The parsing step takes an encoded
 * expression and returns an instance of one of the expression classes.  The compiling step takes
 * the expression instance and returns a function that can be evaluated in to return a literal
 * value.  The evaluator function should do as little allocation and work as possible.
 */

/**
 * @typedef {Object} EvaluationContext
 * @property {Object} properties The values for properties used in 'get' expressions.
 * @property {Object} variables The values for variables used in 'var' expressions.
 * @property {number} resolution The map resolution.
 */

/**
 * @return {EvaluationContext} A new evaluation context.
 */
function newEvaluationContext() {
  return {
    variables: {},
    properties: {},
    resolution: NaN,
  };
}

/**
 * @typedef {function(EvaluationContext):import("./expression.js").LiteralValue} ExpressionEvaluator
 */

/**
 * @typedef {function(EvaluationContext):boolean} BooleanEvaluator
 */

/**
 * @typedef {function(EvaluationContext):number} NumberEvaluator
 */

/**
 * @typedef {function(EvaluationContext):string} StringEvaluator
 */

/**
 * @typedef {function(EvaluationContext):(Array<number>|string)} ColorLikeEvaluator
 */

/**
 * @typedef {function(EvaluationContext):Array<number>} NumberArrayEvaluator
 */

/**
 * @typedef {function(EvaluationContext):Array<number>} CoordinateEvaluator
 */

/**
 * @typedef {function(EvaluationContext):(Array<number>|number)} SizeLikeEvaluator
 */

/**
 * @param {import('./expression.js').EncodedExpression} encoded The encoded expression.
 * @param {number} type The expected type.
 * @param {import('./expression.js').ParsingContext} context The parsing context.
 * @return {ExpressionEvaluator} The expression evaluator.
 */
function buildExpression(encoded, type, context) {
  const expression = (0,_expression_js__WEBPACK_IMPORTED_MODULE_0__.parse)(encoded, context);
  if (!(0,_expression_js__WEBPACK_IMPORTED_MODULE_0__.overlapsType)(type, expression.type)) {
    const expected = (0,_expression_js__WEBPACK_IMPORTED_MODULE_0__.typeName)(type);
    const actual = (0,_expression_js__WEBPACK_IMPORTED_MODULE_0__.typeName)(expression.type);
    throw new Error(
      `Expected expression to be of type ${expected}, got ${actual}`
    );
  }
  return compileExpression(expression, context);
}

/**
 * @param {import("./expression.js").Expression} expression The expression.
 * @param {import('./expression.js').ParsingContext} context The parsing context.
 * @return {ExpressionEvaluator} The evaluator function.
 */
function compileExpression(expression, context) {
  if (expression instanceof _expression_js__WEBPACK_IMPORTED_MODULE_0__.LiteralExpression) {
    return function () {
      return expression.value;
    };
  }
  const operator = expression.operator;
  switch (operator) {
    case _expression_js__WEBPACK_IMPORTED_MODULE_0__.Ops.Number:
    case _expression_js__WEBPACK_IMPORTED_MODULE_0__.Ops.String: {
      return compileAssertionExpression(expression, context);
    }
    case _expression_js__WEBPACK_IMPORTED_MODULE_0__.Ops.Get:
    case _expression_js__WEBPACK_IMPORTED_MODULE_0__.Ops.Var: {
      return compileAccessorExpression(expression, context);
    }
    case _expression_js__WEBPACK_IMPORTED_MODULE_0__.Ops.Resolution: {
      return (context) => context.resolution;
    }
    case _expression_js__WEBPACK_IMPORTED_MODULE_0__.Ops.Any:
    case _expression_js__WEBPACK_IMPORTED_MODULE_0__.Ops.All:
    case _expression_js__WEBPACK_IMPORTED_MODULE_0__.Ops.Not: {
      return compileLogicalExpression(expression, context);
    }
    case _expression_js__WEBPACK_IMPORTED_MODULE_0__.Ops.Equal:
    case _expression_js__WEBPACK_IMPORTED_MODULE_0__.Ops.NotEqual:
    case _expression_js__WEBPACK_IMPORTED_MODULE_0__.Ops.LessThan:
    case _expression_js__WEBPACK_IMPORTED_MODULE_0__.Ops.LessThanOrEqualTo:
    case _expression_js__WEBPACK_IMPORTED_MODULE_0__.Ops.GreaterThan:
    case _expression_js__WEBPACK_IMPORTED_MODULE_0__.Ops.GreaterThanOrEqualTo: {
      return compileComparisonExpression(expression, context);
    }
    case _expression_js__WEBPACK_IMPORTED_MODULE_0__.Ops.Multiply:
    case _expression_js__WEBPACK_IMPORTED_MODULE_0__.Ops.Divide:
    case _expression_js__WEBPACK_IMPORTED_MODULE_0__.Ops.Add:
    case _expression_js__WEBPACK_IMPORTED_MODULE_0__.Ops.Subtract:
    case _expression_js__WEBPACK_IMPORTED_MODULE_0__.Ops.Clamp:
    case _expression_js__WEBPACK_IMPORTED_MODULE_0__.Ops.Mod:
    case _expression_js__WEBPACK_IMPORTED_MODULE_0__.Ops.Pow:
    case _expression_js__WEBPACK_IMPORTED_MODULE_0__.Ops.Abs:
    case _expression_js__WEBPACK_IMPORTED_MODULE_0__.Ops.Floor:
    case _expression_js__WEBPACK_IMPORTED_MODULE_0__.Ops.Ceil:
    case _expression_js__WEBPACK_IMPORTED_MODULE_0__.Ops.Round:
    case _expression_js__WEBPACK_IMPORTED_MODULE_0__.Ops.Sin:
    case _expression_js__WEBPACK_IMPORTED_MODULE_0__.Ops.Cos:
    case _expression_js__WEBPACK_IMPORTED_MODULE_0__.Ops.Atan:
    case _expression_js__WEBPACK_IMPORTED_MODULE_0__.Ops.Sqrt: {
      return compileNumericExpression(expression, context);
    }
    case _expression_js__WEBPACK_IMPORTED_MODULE_0__.Ops.Match: {
      return compileMatchExpression(expression, context);
    }
    default: {
      throw new Error(`Unsupported operator ${operator}`);
    }
  }
}

/**
 * @param {import('./expression.js').CallExpression} expression The call expression.
 * @param {import('./expression.js').ParsingContext} context The parsing context.
 * @return {ExpressionEvaluator} The evaluator function.
 */
function compileAssertionExpression(expression, context) {
  const type = expression.operator;
  const length = expression.args.length;

  const args = new Array(length);
  for (let i = 0; i < length; ++i) {
    args[i] = compileExpression(expression.args[i], context);
  }
  switch (type) {
    case _expression_js__WEBPACK_IMPORTED_MODULE_0__.Ops.Number:
    case _expression_js__WEBPACK_IMPORTED_MODULE_0__.Ops.String: {
      return (context) => {
        for (let i = 0; i < length; ++i) {
          const value = args[i](context);
          if (typeof value === type) {
            return value;
          }
        }
        throw new Error(`Expected one of the values to be a ${type}`);
      };
    }
    default: {
      throw new Error(`Unsupported assertion operator ${type}`);
    }
  }
}

/**
 * @param {import('./expression.js').CallExpression} expression The call expression.
 * @param {import('./expression.js').ParsingContext} context The parsing context.
 * @return {ExpressionEvaluator} The evaluator function.
 */
function compileAccessorExpression(expression, context) {
  const nameExpression = expression.args[0];
  if (!(nameExpression instanceof _expression_js__WEBPACK_IMPORTED_MODULE_0__.LiteralExpression)) {
    throw new Error('Expected literal name');
  }
  const name = nameExpression.value;
  if (typeof name !== 'string') {
    throw new Error('Expected string name');
  }
  switch (expression.operator) {
    case _expression_js__WEBPACK_IMPORTED_MODULE_0__.Ops.Get: {
      return (context) => context.properties[name];
    }
    case _expression_js__WEBPACK_IMPORTED_MODULE_0__.Ops.Var: {
      return (context) => context.variables[name];
    }
    default: {
      throw new Error(`Unsupported accessor operator ${expression.operator}`);
    }
  }
}

/**
 * @param {import('./expression.js').CallExpression} expression The call expression.
 * @param {import('./expression.js').ParsingContext} context The parsing context.
 * @return {BooleanEvaluator} The evaluator function.
 */
function compileComparisonExpression(expression, context) {
  const op = expression.operator;
  const left = compileExpression(expression.args[0], context);
  const right = compileExpression(expression.args[1], context);
  switch (op) {
    case _expression_js__WEBPACK_IMPORTED_MODULE_0__.Ops.Equal: {
      return (context) => left(context) === right(context);
    }
    case _expression_js__WEBPACK_IMPORTED_MODULE_0__.Ops.NotEqual: {
      return (context) => left(context) !== right(context);
    }
    case _expression_js__WEBPACK_IMPORTED_MODULE_0__.Ops.LessThan: {
      return (context) => left(context) < right(context);
    }
    case _expression_js__WEBPACK_IMPORTED_MODULE_0__.Ops.LessThanOrEqualTo: {
      return (context) => left(context) <= right(context);
    }
    case _expression_js__WEBPACK_IMPORTED_MODULE_0__.Ops.GreaterThan: {
      return (context) => left(context) > right(context);
    }
    case _expression_js__WEBPACK_IMPORTED_MODULE_0__.Ops.GreaterThanOrEqualTo: {
      return (context) => left(context) >= right(context);
    }
    default: {
      throw new Error(`Unsupported comparison operator ${op}`);
    }
  }
}

/**
 * @param {import('./expression.js').CallExpression} expression The call expression.
 * @param {import('./expression.js').ParsingContext} context The parsing context.
 * @return {BooleanEvaluator} The evaluator function.
 */
function compileLogicalExpression(expression, context) {
  const op = expression.operator;
  const length = expression.args.length;

  const args = new Array(length);
  for (let i = 0; i < length; ++i) {
    args[i] = compileExpression(expression.args[i], context);
  }
  switch (op) {
    case _expression_js__WEBPACK_IMPORTED_MODULE_0__.Ops.Any: {
      return (context) => {
        for (let i = 0; i < length; ++i) {
          if (args[i](context)) {
            return true;
          }
        }
        return false;
      };
    }
    case _expression_js__WEBPACK_IMPORTED_MODULE_0__.Ops.All: {
      return (context) => {
        for (let i = 0; i < length; ++i) {
          if (!args[i](context)) {
            return false;
          }
        }
        return true;
      };
    }
    case _expression_js__WEBPACK_IMPORTED_MODULE_0__.Ops.Not: {
      return (context) => !args[0](context);
    }
    default: {
      throw new Error(`Unsupported logical operator ${op}`);
    }
  }
}

/**
 * @param {import('./expression.js').CallExpression} expression The call expression.
 * @param {import('./expression.js').ParsingContext} context The parsing context.
 * @return {NumberEvaluator} The evaluator function.
 */
function compileNumericExpression(expression, context) {
  const op = expression.operator;
  const length = expression.args.length;

  const args = new Array(length);
  for (let i = 0; i < length; ++i) {
    args[i] = compileExpression(expression.args[i], context);
  }
  switch (op) {
    case _expression_js__WEBPACK_IMPORTED_MODULE_0__.Ops.Multiply: {
      return (context) => {
        let value = 1;
        for (let i = 0; i < length; ++i) {
          value *= args[i](context);
        }
        return value;
      };
    }
    case _expression_js__WEBPACK_IMPORTED_MODULE_0__.Ops.Divide: {
      return (context) => args[0](context) / args[1](context);
    }
    case _expression_js__WEBPACK_IMPORTED_MODULE_0__.Ops.Add: {
      return (context) => {
        let value = 0;
        for (let i = 0; i < length; ++i) {
          value += args[i](context);
        }
        return value;
      };
    }
    case _expression_js__WEBPACK_IMPORTED_MODULE_0__.Ops.Subtract: {
      return (context) => args[0](context) - args[1](context);
    }
    case _expression_js__WEBPACK_IMPORTED_MODULE_0__.Ops.Clamp: {
      return (context) => {
        const value = args[0](context);
        const min = args[1](context);
        if (value < min) {
          return min;
        }
        const max = args[2](context);
        if (value > max) {
          return max;
        }
        return value;
      };
    }
    case _expression_js__WEBPACK_IMPORTED_MODULE_0__.Ops.Mod: {
      return (context) => args[0](context) % args[1](context);
    }
    case _expression_js__WEBPACK_IMPORTED_MODULE_0__.Ops.Pow: {
      return (context) => Math.pow(args[0](context), args[1](context));
    }
    case _expression_js__WEBPACK_IMPORTED_MODULE_0__.Ops.Abs: {
      return (context) => Math.abs(args[0](context));
    }
    case _expression_js__WEBPACK_IMPORTED_MODULE_0__.Ops.Floor: {
      return (context) => Math.floor(args[0](context));
    }
    case _expression_js__WEBPACK_IMPORTED_MODULE_0__.Ops.Ceil: {
      return (context) => Math.ceil(args[0](context));
    }
    case _expression_js__WEBPACK_IMPORTED_MODULE_0__.Ops.Round: {
      return (context) => Math.round(args[0](context));
    }
    case _expression_js__WEBPACK_IMPORTED_MODULE_0__.Ops.Sin: {
      return (context) => Math.sin(args[0](context));
    }
    case _expression_js__WEBPACK_IMPORTED_MODULE_0__.Ops.Cos: {
      return (context) => Math.cos(args[0](context));
    }
    case _expression_js__WEBPACK_IMPORTED_MODULE_0__.Ops.Atan: {
      if (length === 2) {
        return (context) => Math.atan2(args[0](context), args[1](context));
      }
      return (context) => Math.atan(args[0](context));
    }
    case _expression_js__WEBPACK_IMPORTED_MODULE_0__.Ops.Sqrt: {
      return (context) => Math.sqrt(args[0](context));
    }
    default: {
      throw new Error(`Unsupported numeric operator ${op}`);
    }
  }
}

/**
 * @param {import('./expression.js').CallExpression} expression The call expression.
 * @param {import('./expression.js').ParsingContext} context The parsing context.
 * @return {ExpressionEvaluator} The evaluator function.
 */
function compileMatchExpression(expression, context) {
  const length = expression.args.length;
  const args = new Array(length);
  for (let i = 0; i < length; ++i) {
    args[i] = compileExpression(expression.args[i], context);
  }
  return (context) => {
    const value = args[0](context);
    for (let i = 1; i < length; i += 2) {
      if (value === args[i](context)) {
        return args[i + 1](context);
      }
    }
    return args[length - 1](context);
  };
}


/***/ }),

/***/ "./node_modules/ol/expr/expression.js":
/*!********************************************!*\
  !*** ./node_modules/ol/expr/expression.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AnyType: () => (/* binding */ AnyType),
/* harmony export */   BooleanType: () => (/* binding */ BooleanType),
/* harmony export */   CallExpression: () => (/* binding */ CallExpression),
/* harmony export */   ColorType: () => (/* binding */ ColorType),
/* harmony export */   LiteralExpression: () => (/* binding */ LiteralExpression),
/* harmony export */   NoneType: () => (/* binding */ NoneType),
/* harmony export */   NumberArrayType: () => (/* binding */ NumberArrayType),
/* harmony export */   NumberType: () => (/* binding */ NumberType),
/* harmony export */   Ops: () => (/* binding */ Ops),
/* harmony export */   StringType: () => (/* binding */ StringType),
/* harmony export */   includesType: () => (/* binding */ includesType),
/* harmony export */   isType: () => (/* binding */ isType),
/* harmony export */   newParsingContext: () => (/* binding */ newParsingContext),
/* harmony export */   overlapsType: () => (/* binding */ overlapsType),
/* harmony export */   parse: () => (/* binding */ parse),
/* harmony export */   typeName: () => (/* binding */ typeName)
/* harmony export */ });
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../array.js */ "./node_modules/ol/array.js");
/**
 * @module ol/expr/expression
 */



/**
 * @fileoverview This module includes types and functions for parsing array encoded expressions.
 * The result of parsing an encoded expression is one of the specific expression classes.
 * During parsing, information is added to the parsing context about the data accessed by the
 * expression.
 */

let numTypes = 0;
const NoneType = 0;
const BooleanType = 1 << numTypes++;
const NumberType = 1 << numTypes++;
const StringType = 1 << numTypes++;
const ColorType = 1 << numTypes++;
const NumberArrayType = 1 << numTypes++;
const AnyType = Math.pow(2, numTypes) - 1;

const typeNames = {
  [BooleanType]: 'boolean',
  [NumberType]: 'number',
  [StringType]: 'string',
  [ColorType]: 'color',
  [NumberArrayType]: 'number[]',
};

const namedTypes = Object.keys(typeNames).map(Number).sort(_array_js__WEBPACK_IMPORTED_MODULE_0__.ascending);

/**
 * Get a string representation for a type.
 * @param {number} type The type.
 * @return {string} The type name.
 */
function typeName(type) {
  const names = [];
  for (const namedType of namedTypes) {
    if (includesType(type, namedType)) {
      names.push(typeNames[namedType]);
    }
  }
  if (names.length === 0) {
    return 'untyped';
  }
  if (names.length < 3) {
    return names.join(' or ');
  }
  return names.slice(0, -1).join(', ') + ', or ' + names[names.length - 1];
}

/**
 * @param {number} broad The broad type.
 * @param {number} specific The specific type.
 * @return {boolean} The broad type includes the specific type.
 */
function includesType(broad, specific) {
  return (broad & specific) === specific;
}

/**
 * @param {number} oneType One type.
 * @param {number} otherType Another type.
 * @return {boolean} The set of types overlap (share a common specific type)
 */
function overlapsType(oneType, otherType) {
  return !!(oneType & otherType);
}

/**
 * @param {number} type The type.
 * @param {number} expected The expected type.
 * @return {boolean} The given type is exactly the expected type.
 */
function isType(type, expected) {
  return type === expected;
}

/**
 * @typedef {boolean|number|string|Array<number>} LiteralValue
 */

class LiteralExpression {
  /**
   * @param {number} type The value type.
   * @param {LiteralValue} value The literal value.
   */
  constructor(type, value) {
    this.type = type;
    this.value = value;
  }
}

class CallExpression {
  /**
   * @param {number} type The return type.
   * @param {string} operator The operator.
   * @param {...Expression} args The arguments.
   */
  constructor(type, operator, ...args) {
    this.type = type;
    this.operator = operator;
    this.args = args;
  }
}

/**
 * @typedef {LiteralExpression|CallExpression} Expression
 */

/**
 * @typedef {Object} ParsingContext
 * @property {Set<string>} variables Variables referenced with the 'var' operator.
 * @property {Set<string>} properties Properties referenced with the 'get' operator.
 */

/**
 * @return {ParsingContext} A new parsing context.
 */
function newParsingContext() {
  return {
    variables: new Set(),
    properties: new Set(),
  };
}

/**
 * @typedef {LiteralValue|Array} EncodedExpression
 */

/**
 * @param {EncodedExpression} encoded The encoded expression.
 * @param {ParsingContext} context The parsing context.
 * @return {Expression} The parsed expression result.
 */
function parse(encoded, context) {
  switch (typeof encoded) {
    case 'boolean': {
      return new LiteralExpression(BooleanType, encoded);
    }
    case 'number': {
      return new LiteralExpression(NumberType, encoded);
    }
    case 'string': {
      return new LiteralExpression(StringType, encoded);
    }
    default: {
      // pass
    }
  }

  if (!Array.isArray(encoded)) {
    throw new Error('Expression must be an array or a primitive value');
  }

  if (encoded.length === 0) {
    throw new Error('Empty expression');
  }

  if (typeof encoded[0] === 'string') {
    return parseCallExpression(encoded, context);
  }

  for (const item of encoded) {
    if (typeof item !== 'number') {
      throw new Error('Expected an array of numbers');
    }
  }

  let type = NumberArrayType;
  if (encoded.length === 3 || encoded.length === 4) {
    type |= ColorType;
  }

  return new LiteralExpression(type, encoded);
}

/**
 * @type {Object<string, string>}
 */
const Ops = {
  Number: 'number',
  String: 'string',
  Get: 'get',
  Var: 'var',
  Any: 'any',
  All: 'all',
  Not: '!',
  Resolution: 'resolution',
  Equal: '==',
  NotEqual: '!=',
  GreaterThan: '>',
  GreaterThanOrEqualTo: '>=',
  LessThan: '<',
  LessThanOrEqualTo: '<=',
  Multiply: '*',
  Divide: '/',
  Add: '+',
  Subtract: '-',
  Clamp: 'clamp',
  Mod: '%',
  Pow: '^',
  Abs: 'abs',
  Floor: 'floor',
  Ceil: 'ceil',
  Round: 'round',
  Sin: 'sin',
  Cos: 'cos',
  Atan: 'atan',
  Sqrt: 'sqrt',
  Match: 'match',
};

/**
 * @typedef {function(Array, ParsingContext):Expression} Parser
 */

/**
 * @type {Object<string, Parser>}
 */
const parsers = {
  [Ops.Number]: createParser(withArgs(1, Infinity, AnyType), NumberType),
  [Ops.String]: createParser(withArgs(1, Infinity, AnyType), StringType),
  [Ops.Get]: createParser(withGetArgs, AnyType),
  [Ops.Var]: createParser(withVarArgs, AnyType),
  [Ops.Resolution]: createParser(withNoArgs, NumberType),
  [Ops.Any]: createParser(withArgs(2, Infinity, BooleanType), BooleanType),
  [Ops.All]: createParser(withArgs(2, Infinity, BooleanType), BooleanType),
  [Ops.Not]: createParser(withArgs(1, 1, BooleanType), BooleanType),
  [Ops.Equal]: createParser(withArgs(2, 2, AnyType), BooleanType),
  [Ops.NotEqual]: createParser(withArgs(2, 2, AnyType), BooleanType),
  [Ops.GreaterThan]: createParser(withArgs(2, 2, AnyType), BooleanType),
  [Ops.GreaterThanOrEqualTo]: createParser(
    withArgs(2, 2, AnyType),
    BooleanType
  ),
  [Ops.LessThan]: createParser(withArgs(2, 2, AnyType), BooleanType),
  [Ops.LessThanOrEqualTo]: createParser(withArgs(2, 2, AnyType), BooleanType),
  [Ops.Multiply]: createParser(withArgs(2, Infinity, NumberType), NumberType),
  [Ops.Divide]: createParser(withArgs(2, 2, NumberType), NumberType),
  [Ops.Add]: createParser(withArgs(2, Infinity, NumberType), NumberType),
  [Ops.Subtract]: createParser(withArgs(2, 2, NumberType), NumberType),
  [Ops.Clamp]: createParser(withArgs(3, 3, NumberType), NumberType),
  [Ops.Mod]: createParser(withArgs(2, 2, NumberType), NumberType),
  [Ops.Pow]: createParser(withArgs(2, 2, NumberType), NumberType),
  [Ops.Abs]: createParser(withArgs(1, 1, NumberType), NumberType),
  [Ops.Floor]: createParser(withArgs(1, 1, NumberType), NumberType),
  [Ops.Ceil]: createParser(withArgs(1, 1, NumberType), NumberType),
  [Ops.Round]: createParser(withArgs(1, 1, NumberType), NumberType),
  [Ops.Sin]: createParser(withArgs(1, 1, NumberType), NumberType),
  [Ops.Cos]: createParser(withArgs(1, 1, NumberType), NumberType),
  [Ops.Atan]: createParser(withArgs(1, 2, NumberType), NumberType),
  [Ops.Sqrt]: createParser(withArgs(1, 1, NumberType), NumberType),
  [Ops.Match]: createParser(
    withArgs(4, Infinity, StringType | NumberType),
    AnyType
  ),
};

/**
 * @typedef {function(Array, ParsingContext):Array<Expression>} ArgValidator
 */

/**
 * @type ArgValidator
 */
function withGetArgs(encoded, context) {
  if (encoded.length !== 2) {
    throw new Error('Expected 1 argument for get operation');
  }
  const arg = parse(encoded[1], context);
  if (!(arg instanceof LiteralExpression)) {
    throw new Error('Expected a literal argument for get operation');
  }
  if (typeof arg.value !== 'string') {
    throw new Error('Expected a string argument for get operation');
  }
  context.properties.add(arg.value);
  return [arg];
}

/**
 * @type ArgValidator
 */
function withVarArgs(encoded, context) {
  if (encoded.length !== 2) {
    throw new Error('Expected 1 argument for var operation');
  }
  const arg = parse(encoded[1], context);
  if (!(arg instanceof LiteralExpression)) {
    throw new Error('Expected a literal argument for var operation');
  }
  if (typeof arg.value !== 'string') {
    throw new Error('Expected a string argument for get operation');
  }
  context.variables.add(arg.value);
  return [arg];
}

/**
 * @type ArgValidator
 */
function withNoArgs(encoded, context) {
  const operation = encoded[0];
  if (encoded.length !== 1) {
    throw new Error(`Expected no arguments for ${operation} operation`);
  }
  return [];
}

/**
 * @param {number} minArgs The minimum number of arguments.
 * @param {number} maxArgs The maximum number of arguments.
 * @param {number} argType The argument type.
 * @return {ArgValidator} The argument validator
 */
function withArgs(minArgs, maxArgs, argType) {
  return function (encoded, context) {
    const operation = encoded[0];
    const argCount = encoded.length - 1;
    if (minArgs === maxArgs) {
      if (argCount !== minArgs) {
        const plural = minArgs === 1 ? '' : 's';
        throw new Error(
          `Expected ${minArgs} argument${plural} for operation ${operation}, got ${argCount}`
        );
      }
    } else if (argCount < minArgs || argCount > maxArgs) {
      throw new Error(
        `Expected ${minArgs} to ${maxArgs} arguments for operation ${operation}, got ${argCount}`
      );
    }

    /**
     * @type {Array<Expression>}
     */
    const args = new Array(argCount);
    for (let i = 0; i < argCount; ++i) {
      const expression = parse(encoded[i + 1], context);
      if (!overlapsType(argType, expression.type)) {
        const gotType = typeName(argType);
        const expectedType = typeName(expression.type);
        throw new Error(
          `Unexpected type for argument ${i} of ${operation} operation` +
            ` : got ${gotType} but expected ${expectedType}`
        );
      }
      args[i] = expression;
    }

    return args;
  };
}

/**
 * @param {ArgValidator} argValidator The argument validator.
 * @param {number} returnType The return type.
 * @return {Parser} The parser.
 */
function createParser(argValidator, returnType) {
  return function (encoded, context) {
    const operator = encoded[0];
    const args = argValidator(encoded, context);
    return new CallExpression(returnType, operator, ...args);
  };
}

/**
 * @param {Array} encoded The encoded expression.
 * @param {ParsingContext} context The parsing context.
 * @return {Expression} The parsed expression.
 */
function parseCallExpression(encoded, context) {
  const operator = encoded[0];

  const parser = parsers[operator];
  if (!parser) {
    throw new Error(`Unknown operator: ${operator}`);
  }
  return parser(encoded, context);
}


/***/ }),

/***/ "./node_modules/ol/extent.js":
/*!***********************************!*\
  !*** ./node_modules/ol/extent.js ***!
  \***********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   applyTransform: () => (/* binding */ applyTransform),
/* harmony export */   approximatelyEquals: () => (/* binding */ approximatelyEquals),
/* harmony export */   boundingExtent: () => (/* binding */ boundingExtent),
/* harmony export */   buffer: () => (/* binding */ buffer),
/* harmony export */   clone: () => (/* binding */ clone),
/* harmony export */   closestSquaredDistanceXY: () => (/* binding */ closestSquaredDistanceXY),
/* harmony export */   containsCoordinate: () => (/* binding */ containsCoordinate),
/* harmony export */   containsExtent: () => (/* binding */ containsExtent),
/* harmony export */   containsXY: () => (/* binding */ containsXY),
/* harmony export */   coordinateRelationship: () => (/* binding */ coordinateRelationship),
/* harmony export */   createEmpty: () => (/* binding */ createEmpty),
/* harmony export */   createOrUpdate: () => (/* binding */ createOrUpdate),
/* harmony export */   createOrUpdateEmpty: () => (/* binding */ createOrUpdateEmpty),
/* harmony export */   createOrUpdateFromCoordinate: () => (/* binding */ createOrUpdateFromCoordinate),
/* harmony export */   createOrUpdateFromCoordinates: () => (/* binding */ createOrUpdateFromCoordinates),
/* harmony export */   createOrUpdateFromFlatCoordinates: () => (/* binding */ createOrUpdateFromFlatCoordinates),
/* harmony export */   createOrUpdateFromRings: () => (/* binding */ createOrUpdateFromRings),
/* harmony export */   equals: () => (/* binding */ equals),
/* harmony export */   extend: () => (/* binding */ extend),
/* harmony export */   extendCoordinate: () => (/* binding */ extendCoordinate),
/* harmony export */   extendCoordinates: () => (/* binding */ extendCoordinates),
/* harmony export */   extendFlatCoordinates: () => (/* binding */ extendFlatCoordinates),
/* harmony export */   extendRings: () => (/* binding */ extendRings),
/* harmony export */   extendXY: () => (/* binding */ extendXY),
/* harmony export */   forEachCorner: () => (/* binding */ forEachCorner),
/* harmony export */   getArea: () => (/* binding */ getArea),
/* harmony export */   getBottomLeft: () => (/* binding */ getBottomLeft),
/* harmony export */   getBottomRight: () => (/* binding */ getBottomRight),
/* harmony export */   getCenter: () => (/* binding */ getCenter),
/* harmony export */   getCorner: () => (/* binding */ getCorner),
/* harmony export */   getEnlargedArea: () => (/* binding */ getEnlargedArea),
/* harmony export */   getForViewAndSize: () => (/* binding */ getForViewAndSize),
/* harmony export */   getHeight: () => (/* binding */ getHeight),
/* harmony export */   getIntersection: () => (/* binding */ getIntersection),
/* harmony export */   getIntersectionArea: () => (/* binding */ getIntersectionArea),
/* harmony export */   getMargin: () => (/* binding */ getMargin),
/* harmony export */   getRotatedViewport: () => (/* binding */ getRotatedViewport),
/* harmony export */   getSize: () => (/* binding */ getSize),
/* harmony export */   getTopLeft: () => (/* binding */ getTopLeft),
/* harmony export */   getTopRight: () => (/* binding */ getTopRight),
/* harmony export */   getWidth: () => (/* binding */ getWidth),
/* harmony export */   intersects: () => (/* binding */ intersects),
/* harmony export */   intersectsSegment: () => (/* binding */ intersectsSegment),
/* harmony export */   isEmpty: () => (/* binding */ isEmpty),
/* harmony export */   returnOrUpdate: () => (/* binding */ returnOrUpdate),
/* harmony export */   scaleFromCenter: () => (/* binding */ scaleFromCenter),
/* harmony export */   wrapAndSliceX: () => (/* binding */ wrapAndSliceX),
/* harmony export */   wrapX: () => (/* binding */ wrapX)
/* harmony export */ });
/* harmony import */ var _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./extent/Relationship.js */ "./node_modules/ol/extent/Relationship.js");
/**
 * @module ol/extent
 */


/**
 * An array of numbers representing an extent: `[minx, miny, maxx, maxy]`.
 * @typedef {Array<number>} Extent
 * @api
 */

/**
 * Extent corner.
 * @typedef {'bottom-left' | 'bottom-right' | 'top-left' | 'top-right'} Corner
 */

/**
 * Build an extent that includes all given coordinates.
 *
 * @param {Array<import("./coordinate.js").Coordinate>} coordinates Coordinates.
 * @return {Extent} Bounding extent.
 * @api
 */
function boundingExtent(coordinates) {
  const extent = createEmpty();
  for (let i = 0, ii = coordinates.length; i < ii; ++i) {
    extendCoordinate(extent, coordinates[i]);
  }
  return extent;
}

/**
 * @param {Array<number>} xs Xs.
 * @param {Array<number>} ys Ys.
 * @param {Extent} [dest] Destination extent.
 * @private
 * @return {Extent} Extent.
 */
function _boundingExtentXYs(xs, ys, dest) {
  const minX = Math.min.apply(null, xs);
  const minY = Math.min.apply(null, ys);
  const maxX = Math.max.apply(null, xs);
  const maxY = Math.max.apply(null, ys);
  return createOrUpdate(minX, minY, maxX, maxY, dest);
}

/**
 * Return extent increased by the provided value.
 * @param {Extent} extent Extent.
 * @param {number} value The amount by which the extent should be buffered.
 * @param {Extent} [dest] Extent.
 * @return {Extent} Extent.
 * @api
 */
function buffer(extent, value, dest) {
  if (dest) {
    dest[0] = extent[0] - value;
    dest[1] = extent[1] - value;
    dest[2] = extent[2] + value;
    dest[3] = extent[3] + value;
    return dest;
  }
  return [
    extent[0] - value,
    extent[1] - value,
    extent[2] + value,
    extent[3] + value,
  ];
}

/**
 * Creates a clone of an extent.
 *
 * @param {Extent} extent Extent to clone.
 * @param {Extent} [dest] Extent.
 * @return {Extent} The clone.
 */
function clone(extent, dest) {
  if (dest) {
    dest[0] = extent[0];
    dest[1] = extent[1];
    dest[2] = extent[2];
    dest[3] = extent[3];
    return dest;
  }
  return extent.slice();
}

/**
 * @param {Extent} extent Extent.
 * @param {number} x X.
 * @param {number} y Y.
 * @return {number} Closest squared distance.
 */
function closestSquaredDistanceXY(extent, x, y) {
  let dx, dy;
  if (x < extent[0]) {
    dx = extent[0] - x;
  } else if (extent[2] < x) {
    dx = x - extent[2];
  } else {
    dx = 0;
  }
  if (y < extent[1]) {
    dy = extent[1] - y;
  } else if (extent[3] < y) {
    dy = y - extent[3];
  } else {
    dy = 0;
  }
  return dx * dx + dy * dy;
}

/**
 * Check if the passed coordinate is contained or on the edge of the extent.
 *
 * @param {Extent} extent Extent.
 * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
 * @return {boolean} The coordinate is contained in the extent.
 * @api
 */
function containsCoordinate(extent, coordinate) {
  return containsXY(extent, coordinate[0], coordinate[1]);
}

/**
 * Check if one extent contains another.
 *
 * An extent is deemed contained if it lies completely within the other extent,
 * including if they share one or more edges.
 *
 * @param {Extent} extent1 Extent 1.
 * @param {Extent} extent2 Extent 2.
 * @return {boolean} The second extent is contained by or on the edge of the
 *     first.
 * @api
 */
function containsExtent(extent1, extent2) {
  return (
    extent1[0] <= extent2[0] &&
    extent2[2] <= extent1[2] &&
    extent1[1] <= extent2[1] &&
    extent2[3] <= extent1[3]
  );
}

/**
 * Check if the passed coordinate is contained or on the edge of the extent.
 *
 * @param {Extent} extent Extent.
 * @param {number} x X coordinate.
 * @param {number} y Y coordinate.
 * @return {boolean} The x, y values are contained in the extent.
 * @api
 */
function containsXY(extent, x, y) {
  return extent[0] <= x && x <= extent[2] && extent[1] <= y && y <= extent[3];
}

/**
 * Get the relationship between a coordinate and extent.
 * @param {Extent} extent The extent.
 * @param {import("./coordinate.js").Coordinate} coordinate The coordinate.
 * @return {import("./extent/Relationship.js").default} The relationship (bitwise compare with
 *     import("./extent/Relationship.js").Relationship).
 */
function coordinateRelationship(extent, coordinate) {
  const minX = extent[0];
  const minY = extent[1];
  const maxX = extent[2];
  const maxY = extent[3];
  const x = coordinate[0];
  const y = coordinate[1];
  let relationship = _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_0__["default"].UNKNOWN;
  if (x < minX) {
    relationship = relationship | _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_0__["default"].LEFT;
  } else if (x > maxX) {
    relationship = relationship | _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_0__["default"].RIGHT;
  }
  if (y < minY) {
    relationship = relationship | _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_0__["default"].BELOW;
  } else if (y > maxY) {
    relationship = relationship | _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_0__["default"].ABOVE;
  }
  if (relationship === _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_0__["default"].UNKNOWN) {
    relationship = _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_0__["default"].INTERSECTING;
  }
  return relationship;
}

/**
 * Create an empty extent.
 * @return {Extent} Empty extent.
 * @api
 */
function createEmpty() {
  return [Infinity, Infinity, -Infinity, -Infinity];
}

/**
 * Create a new extent or update the provided extent.
 * @param {number} minX Minimum X.
 * @param {number} minY Minimum Y.
 * @param {number} maxX Maximum X.
 * @param {number} maxY Maximum Y.
 * @param {Extent} [dest] Destination extent.
 * @return {Extent} Extent.
 */
function createOrUpdate(minX, minY, maxX, maxY, dest) {
  if (dest) {
    dest[0] = minX;
    dest[1] = minY;
    dest[2] = maxX;
    dest[3] = maxY;
    return dest;
  }
  return [minX, minY, maxX, maxY];
}

/**
 * Create a new empty extent or make the provided one empty.
 * @param {Extent} [dest] Extent.
 * @return {Extent} Extent.
 */
function createOrUpdateEmpty(dest) {
  return createOrUpdate(Infinity, Infinity, -Infinity, -Infinity, dest);
}

/**
 * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
 * @param {Extent} [dest] Extent.
 * @return {Extent} Extent.
 */
function createOrUpdateFromCoordinate(coordinate, dest) {
  const x = coordinate[0];
  const y = coordinate[1];
  return createOrUpdate(x, y, x, y, dest);
}

/**
 * @param {Array<import("./coordinate.js").Coordinate>} coordinates Coordinates.
 * @param {Extent} [dest] Extent.
 * @return {Extent} Extent.
 */
function createOrUpdateFromCoordinates(coordinates, dest) {
  const extent = createOrUpdateEmpty(dest);
  return extendCoordinates(extent, coordinates);
}

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {Extent} [dest] Extent.
 * @return {Extent} Extent.
 */
function createOrUpdateFromFlatCoordinates(
  flatCoordinates,
  offset,
  end,
  stride,
  dest
) {
  const extent = createOrUpdateEmpty(dest);
  return extendFlatCoordinates(extent, flatCoordinates, offset, end, stride);
}

/**
 * @param {Array<Array<import("./coordinate.js").Coordinate>>} rings Rings.
 * @param {Extent} [dest] Extent.
 * @return {Extent} Extent.
 */
function createOrUpdateFromRings(rings, dest) {
  const extent = createOrUpdateEmpty(dest);
  return extendRings(extent, rings);
}

/**
 * Determine if two extents are equivalent.
 * @param {Extent} extent1 Extent 1.
 * @param {Extent} extent2 Extent 2.
 * @return {boolean} The two extents are equivalent.
 * @api
 */
function equals(extent1, extent2) {
  return (
    extent1[0] == extent2[0] &&
    extent1[2] == extent2[2] &&
    extent1[1] == extent2[1] &&
    extent1[3] == extent2[3]
  );
}

/**
 * Determine if two extents are approximately equivalent.
 * @param {Extent} extent1 Extent 1.
 * @param {Extent} extent2 Extent 2.
 * @param {number} tolerance Tolerance in extent coordinate units.
 * @return {boolean} The two extents differ by less than the tolerance.
 */
function approximatelyEquals(extent1, extent2, tolerance) {
  return (
    Math.abs(extent1[0] - extent2[0]) < tolerance &&
    Math.abs(extent1[2] - extent2[2]) < tolerance &&
    Math.abs(extent1[1] - extent2[1]) < tolerance &&
    Math.abs(extent1[3] - extent2[3]) < tolerance
  );
}

/**
 * Modify an extent to include another extent.
 * @param {Extent} extent1 The extent to be modified.
 * @param {Extent} extent2 The extent that will be included in the first.
 * @return {Extent} A reference to the first (extended) extent.
 * @api
 */
function extend(extent1, extent2) {
  if (extent2[0] < extent1[0]) {
    extent1[0] = extent2[0];
  }
  if (extent2[2] > extent1[2]) {
    extent1[2] = extent2[2];
  }
  if (extent2[1] < extent1[1]) {
    extent1[1] = extent2[1];
  }
  if (extent2[3] > extent1[3]) {
    extent1[3] = extent2[3];
  }
  return extent1;
}

/**
 * @param {Extent} extent Extent.
 * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
 */
function extendCoordinate(extent, coordinate) {
  if (coordinate[0] < extent[0]) {
    extent[0] = coordinate[0];
  }
  if (coordinate[0] > extent[2]) {
    extent[2] = coordinate[0];
  }
  if (coordinate[1] < extent[1]) {
    extent[1] = coordinate[1];
  }
  if (coordinate[1] > extent[3]) {
    extent[3] = coordinate[1];
  }
}

/**
 * @param {Extent} extent Extent.
 * @param {Array<import("./coordinate.js").Coordinate>} coordinates Coordinates.
 * @return {Extent} Extent.
 */
function extendCoordinates(extent, coordinates) {
  for (let i = 0, ii = coordinates.length; i < ii; ++i) {
    extendCoordinate(extent, coordinates[i]);
  }
  return extent;
}

/**
 * @param {Extent} extent Extent.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {Extent} Extent.
 */
function extendFlatCoordinates(
  extent,
  flatCoordinates,
  offset,
  end,
  stride
) {
  for (; offset < end; offset += stride) {
    extendXY(extent, flatCoordinates[offset], flatCoordinates[offset + 1]);
  }
  return extent;
}

/**
 * @param {Extent} extent Extent.
 * @param {Array<Array<import("./coordinate.js").Coordinate>>} rings Rings.
 * @return {Extent} Extent.
 */
function extendRings(extent, rings) {
  for (let i = 0, ii = rings.length; i < ii; ++i) {
    extendCoordinates(extent, rings[i]);
  }
  return extent;
}

/**
 * @param {Extent} extent Extent.
 * @param {number} x X.
 * @param {number} y Y.
 */
function extendXY(extent, x, y) {
  extent[0] = Math.min(extent[0], x);
  extent[1] = Math.min(extent[1], y);
  extent[2] = Math.max(extent[2], x);
  extent[3] = Math.max(extent[3], y);
}

/**
 * This function calls `callback` for each corner of the extent. If the
 * callback returns a truthy value the function returns that value
 * immediately. Otherwise the function returns `false`.
 * @param {Extent} extent Extent.
 * @param {function(import("./coordinate.js").Coordinate): S} callback Callback.
 * @return {S|boolean} Value.
 * @template S
 */
function forEachCorner(extent, callback) {
  let val;
  val = callback(getBottomLeft(extent));
  if (val) {
    return val;
  }
  val = callback(getBottomRight(extent));
  if (val) {
    return val;
  }
  val = callback(getTopRight(extent));
  if (val) {
    return val;
  }
  val = callback(getTopLeft(extent));
  if (val) {
    return val;
  }
  return false;
}

/**
 * Get the size of an extent.
 * @param {Extent} extent Extent.
 * @return {number} Area.
 * @api
 */
function getArea(extent) {
  let area = 0;
  if (!isEmpty(extent)) {
    area = getWidth(extent) * getHeight(extent);
  }
  return area;
}

/**
 * Get the bottom left coordinate of an extent.
 * @param {Extent} extent Extent.
 * @return {import("./coordinate.js").Coordinate} Bottom left coordinate.
 * @api
 */
function getBottomLeft(extent) {
  return [extent[0], extent[1]];
}

/**
 * Get the bottom right coordinate of an extent.
 * @param {Extent} extent Extent.
 * @return {import("./coordinate.js").Coordinate} Bottom right coordinate.
 * @api
 */
function getBottomRight(extent) {
  return [extent[2], extent[1]];
}

/**
 * Get the center coordinate of an extent.
 * @param {Extent} extent Extent.
 * @return {import("./coordinate.js").Coordinate} Center.
 * @api
 */
function getCenter(extent) {
  return [(extent[0] + extent[2]) / 2, (extent[1] + extent[3]) / 2];
}

/**
 * Get a corner coordinate of an extent.
 * @param {Extent} extent Extent.
 * @param {Corner} corner Corner.
 * @return {import("./coordinate.js").Coordinate} Corner coordinate.
 */
function getCorner(extent, corner) {
  let coordinate;
  if (corner === 'bottom-left') {
    coordinate = getBottomLeft(extent);
  } else if (corner === 'bottom-right') {
    coordinate = getBottomRight(extent);
  } else if (corner === 'top-left') {
    coordinate = getTopLeft(extent);
  } else if (corner === 'top-right') {
    coordinate = getTopRight(extent);
  } else {
    throw new Error('Invalid corner');
  }
  return coordinate;
}

/**
 * @param {Extent} extent1 Extent 1.
 * @param {Extent} extent2 Extent 2.
 * @return {number} Enlarged area.
 */
function getEnlargedArea(extent1, extent2) {
  const minX = Math.min(extent1[0], extent2[0]);
  const minY = Math.min(extent1[1], extent2[1]);
  const maxX = Math.max(extent1[2], extent2[2]);
  const maxY = Math.max(extent1[3], extent2[3]);
  return (maxX - minX) * (maxY - minY);
}

/**
 * @param {import("./coordinate.js").Coordinate} center Center.
 * @param {number} resolution Resolution.
 * @param {number} rotation Rotation.
 * @param {import("./size.js").Size} size Size.
 * @param {Extent} [dest] Destination extent.
 * @return {Extent} Extent.
 */
function getForViewAndSize(center, resolution, rotation, size, dest) {
  const [x0, y0, x1, y1, x2, y2, x3, y3] = getRotatedViewport(
    center,
    resolution,
    rotation,
    size
  );
  return createOrUpdate(
    Math.min(x0, x1, x2, x3),
    Math.min(y0, y1, y2, y3),
    Math.max(x0, x1, x2, x3),
    Math.max(y0, y1, y2, y3),
    dest
  );
}

/**
 * @param {import("./coordinate.js").Coordinate} center Center.
 * @param {number} resolution Resolution.
 * @param {number} rotation Rotation.
 * @param {import("./size.js").Size} size Size.
 * @return {Array<number>} Linear ring representing the viewport.
 */
function getRotatedViewport(center, resolution, rotation, size) {
  const dx = (resolution * size[0]) / 2;
  const dy = (resolution * size[1]) / 2;
  const cosRotation = Math.cos(rotation);
  const sinRotation = Math.sin(rotation);
  const xCos = dx * cosRotation;
  const xSin = dx * sinRotation;
  const yCos = dy * cosRotation;
  const ySin = dy * sinRotation;
  const x = center[0];
  const y = center[1];
  return [
    x - xCos + ySin,
    y - xSin - yCos,
    x - xCos - ySin,
    y - xSin + yCos,
    x + xCos - ySin,
    y + xSin + yCos,
    x + xCos + ySin,
    y + xSin - yCos,
    x - xCos + ySin,
    y - xSin - yCos,
  ];
}

/**
 * Get the height of an extent.
 * @param {Extent} extent Extent.
 * @return {number} Height.
 * @api
 */
function getHeight(extent) {
  return extent[3] - extent[1];
}

/**
 * @param {Extent} extent1 Extent 1.
 * @param {Extent} extent2 Extent 2.
 * @return {number} Intersection area.
 */
function getIntersectionArea(extent1, extent2) {
  const intersection = getIntersection(extent1, extent2);
  return getArea(intersection);
}

/**
 * Get the intersection of two extents.
 * @param {Extent} extent1 Extent 1.
 * @param {Extent} extent2 Extent 2.
 * @param {Extent} [dest] Optional extent to populate with intersection.
 * @return {Extent} Intersecting extent.
 * @api
 */
function getIntersection(extent1, extent2, dest) {
  const intersection = dest ? dest : createEmpty();
  if (intersects(extent1, extent2)) {
    if (extent1[0] > extent2[0]) {
      intersection[0] = extent1[0];
    } else {
      intersection[0] = extent2[0];
    }
    if (extent1[1] > extent2[1]) {
      intersection[1] = extent1[1];
    } else {
      intersection[1] = extent2[1];
    }
    if (extent1[2] < extent2[2]) {
      intersection[2] = extent1[2];
    } else {
      intersection[2] = extent2[2];
    }
    if (extent1[3] < extent2[3]) {
      intersection[3] = extent1[3];
    } else {
      intersection[3] = extent2[3];
    }
  } else {
    createOrUpdateEmpty(intersection);
  }
  return intersection;
}

/**
 * @param {Extent} extent Extent.
 * @return {number} Margin.
 */
function getMargin(extent) {
  return getWidth(extent) + getHeight(extent);
}

/**
 * Get the size (width, height) of an extent.
 * @param {Extent} extent The extent.
 * @return {import("./size.js").Size} The extent size.
 * @api
 */
function getSize(extent) {
  return [extent[2] - extent[0], extent[3] - extent[1]];
}

/**
 * Get the top left coordinate of an extent.
 * @param {Extent} extent Extent.
 * @return {import("./coordinate.js").Coordinate} Top left coordinate.
 * @api
 */
function getTopLeft(extent) {
  return [extent[0], extent[3]];
}

/**
 * Get the top right coordinate of an extent.
 * @param {Extent} extent Extent.
 * @return {import("./coordinate.js").Coordinate} Top right coordinate.
 * @api
 */
function getTopRight(extent) {
  return [extent[2], extent[3]];
}

/**
 * Get the width of an extent.
 * @param {Extent} extent Extent.
 * @return {number} Width.
 * @api
 */
function getWidth(extent) {
  return extent[2] - extent[0];
}

/**
 * Determine if one extent intersects another.
 * @param {Extent} extent1 Extent 1.
 * @param {Extent} extent2 Extent.
 * @return {boolean} The two extents intersect.
 * @api
 */
function intersects(extent1, extent2) {
  return (
    extent1[0] <= extent2[2] &&
    extent1[2] >= extent2[0] &&
    extent1[1] <= extent2[3] &&
    extent1[3] >= extent2[1]
  );
}

/**
 * Determine if an extent is empty.
 * @param {Extent} extent Extent.
 * @return {boolean} Is empty.
 * @api
 */
function isEmpty(extent) {
  return extent[2] < extent[0] || extent[3] < extent[1];
}

/**
 * @param {Extent} extent Extent.
 * @param {Extent} [dest] Extent.
 * @return {Extent} Extent.
 */
function returnOrUpdate(extent, dest) {
  if (dest) {
    dest[0] = extent[0];
    dest[1] = extent[1];
    dest[2] = extent[2];
    dest[3] = extent[3];
    return dest;
  }
  return extent;
}

/**
 * @param {Extent} extent Extent.
 * @param {number} value Value.
 */
function scaleFromCenter(extent, value) {
  const deltaX = ((extent[2] - extent[0]) / 2) * (value - 1);
  const deltaY = ((extent[3] - extent[1]) / 2) * (value - 1);
  extent[0] -= deltaX;
  extent[2] += deltaX;
  extent[1] -= deltaY;
  extent[3] += deltaY;
}

/**
 * Determine if the segment between two coordinates intersects (crosses,
 * touches, or is contained by) the provided extent.
 * @param {Extent} extent The extent.
 * @param {import("./coordinate.js").Coordinate} start Segment start coordinate.
 * @param {import("./coordinate.js").Coordinate} end Segment end coordinate.
 * @return {boolean} The segment intersects the extent.
 */
function intersectsSegment(extent, start, end) {
  let intersects = false;
  const startRel = coordinateRelationship(extent, start);
  const endRel = coordinateRelationship(extent, end);
  if (
    startRel === _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_0__["default"].INTERSECTING ||
    endRel === _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_0__["default"].INTERSECTING
  ) {
    intersects = true;
  } else {
    const minX = extent[0];
    const minY = extent[1];
    const maxX = extent[2];
    const maxY = extent[3];
    const startX = start[0];
    const startY = start[1];
    const endX = end[0];
    const endY = end[1];
    const slope = (endY - startY) / (endX - startX);
    let x, y;
    if (!!(endRel & _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_0__["default"].ABOVE) && !(startRel & _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_0__["default"].ABOVE)) {
      // potentially intersects top
      x = endX - (endY - maxY) / slope;
      intersects = x >= minX && x <= maxX;
    }
    if (
      !intersects &&
      !!(endRel & _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_0__["default"].RIGHT) &&
      !(startRel & _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_0__["default"].RIGHT)
    ) {
      // potentially intersects right
      y = endY - (endX - maxX) * slope;
      intersects = y >= minY && y <= maxY;
    }
    if (
      !intersects &&
      !!(endRel & _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_0__["default"].BELOW) &&
      !(startRel & _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_0__["default"].BELOW)
    ) {
      // potentially intersects bottom
      x = endX - (endY - minY) / slope;
      intersects = x >= minX && x <= maxX;
    }
    if (
      !intersects &&
      !!(endRel & _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_0__["default"].LEFT) &&
      !(startRel & _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_0__["default"].LEFT)
    ) {
      // potentially intersects left
      y = endY - (endX - minX) * slope;
      intersects = y >= minY && y <= maxY;
    }
  }
  return intersects;
}

/**
 * Apply a transform function to the extent.
 * @param {Extent} extent Extent.
 * @param {import("./proj.js").TransformFunction} transformFn Transform function.
 * Called with `[minX, minY, maxX, maxY]` extent coordinates.
 * @param {Extent} [dest] Destination extent.
 * @param {number} [stops] Number of stops per side used for the transform.
 * By default only the corners are used.
 * @return {Extent} Extent.
 * @api
 */
function applyTransform(extent, transformFn, dest, stops) {
  if (isEmpty(extent)) {
    return createOrUpdateEmpty(dest);
  }
  let coordinates = [];
  if (stops > 1) {
    const width = extent[2] - extent[0];
    const height = extent[3] - extent[1];
    for (let i = 0; i < stops; ++i) {
      coordinates.push(
        extent[0] + (width * i) / stops,
        extent[1],
        extent[2],
        extent[1] + (height * i) / stops,
        extent[2] - (width * i) / stops,
        extent[3],
        extent[0],
        extent[3] - (height * i) / stops
      );
    }
  } else {
    coordinates = [
      extent[0],
      extent[1],
      extent[2],
      extent[1],
      extent[2],
      extent[3],
      extent[0],
      extent[3],
    ];
  }
  transformFn(coordinates, coordinates, 2);
  const xs = [];
  const ys = [];
  for (let i = 0, l = coordinates.length; i < l; i += 2) {
    xs.push(coordinates[i]);
    ys.push(coordinates[i + 1]);
  }
  return _boundingExtentXYs(xs, ys, dest);
}

/**
 * Modifies the provided extent in-place to be within the real world
 * extent.
 *
 * @param {Extent} extent Extent.
 * @param {import("./proj/Projection.js").default} projection Projection
 * @return {Extent} The extent within the real world extent.
 */
function wrapX(extent, projection) {
  const projectionExtent = projection.getExtent();
  const center = getCenter(extent);
  if (
    projection.canWrapX() &&
    (center[0] < projectionExtent[0] || center[0] >= projectionExtent[2])
  ) {
    const worldWidth = getWidth(projectionExtent);
    const worldsAway = Math.floor(
      (center[0] - projectionExtent[0]) / worldWidth
    );
    const offset = worldsAway * worldWidth;
    extent[0] -= offset;
    extent[2] -= offset;
  }
  return extent;
}

/**
 * Fits the extent to the real world
 *
 * If the extent does not cross the anti meridian, this will return the extent in an array
 * If the extent crosses the anti meridian, the extent will be sliced, so each part fits within the
 * real world
 *
 *
 * @param {Extent} extent Extent.
 * @param {import("./proj/Projection.js").default} projection Projection
 * @return {Array<Extent>} The extent within the real world extent.
 */
function wrapAndSliceX(extent, projection) {
  if (projection.canWrapX()) {
    const projectionExtent = projection.getExtent();

    if (!isFinite(extent[0]) || !isFinite(extent[2])) {
      return [[projectionExtent[0], extent[1], projectionExtent[2], extent[3]]];
    }

    wrapX(extent, projection);
    const worldWidth = getWidth(projectionExtent);

    if (getWidth(extent) > worldWidth) {
      // the extent wraps around on itself
      return [[projectionExtent[0], extent[1], projectionExtent[2], extent[3]]];
    }
    if (extent[0] < projectionExtent[0]) {
      // the extent crosses the anti meridian, so it needs to be sliced
      return [
        [extent[0] + worldWidth, extent[1], projectionExtent[2], extent[3]],
        [projectionExtent[0], extent[1], extent[2], extent[3]],
      ];
    }
    if (extent[2] > projectionExtent[2]) {
      // the extent crosses the anti meridian, so it needs to be sliced
      return [
        [extent[0], extent[1], projectionExtent[2], extent[3]],
        [projectionExtent[0], extent[1], extent[2] - worldWidth, extent[3]],
      ];
    }
  }

  return [extent];
}


/***/ }),

/***/ "./node_modules/ol/extent/Relationship.js":
/*!************************************************!*\
  !*** ./node_modules/ol/extent/Relationship.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * @module ol/extent/Relationship
 */

/**
 * Relationship to an extent.
 * @enum {number}
 */
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  UNKNOWN: 0,
  INTERSECTING: 1,
  ABOVE: 2,
  RIGHT: 4,
  BELOW: 8,
  LEFT: 16,
});


/***/ }),

/***/ "./node_modules/ol/featureloader.js":
/*!******************************************!*\
  !*** ./node_modules/ol/featureloader.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   loadFeaturesXhr: () => (/* binding */ loadFeaturesXhr),
/* harmony export */   setWithCredentials: () => (/* binding */ setWithCredentials),
/* harmony export */   xhr: () => (/* binding */ xhr)
/* harmony export */ });
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./functions.js */ "./node_modules/ol/functions.js");
/**
 * @module ol/featureloader
 */


/**
 *
 * @type {boolean}
 * @private
 */
let withCredentials = false;

/**
 * {@link module:ol/source/Vector~VectorSource} sources use a function of this type to
 * load features.
 *
 * This function takes up to 5 arguments. These are an {@link module:ol/extent~Extent} representing
 * the area to be loaded, a `{number}` representing the resolution (map units per pixel), an
 * {@link module:ol/proj/Projection~Projection} for the projection, an optional success callback that should get
 * the loaded features passed as an argument and an optional failure callback with no arguments. If
 * the callbacks are not used, the corresponding vector source will not fire `'featuresloadend'` and
 * `'featuresloaderror'` events. `this` within the function is bound to the
 * {@link module:ol/source/Vector~VectorSource} it's called from.
 *
 * The function is responsible for loading the features and adding them to the
 * source.
 * @typedef {function(this:(import("./source/Vector").default|import("./VectorTile.js").default),
 *           import("./extent.js").Extent,
 *           number,
 *           import("./proj/Projection.js").default,
 *           function(Array<import("./Feature.js").default>): void=,
 *           function(): void=): void} FeatureLoader
 * @api
 */

/**
 * {@link module:ol/source/Vector~VectorSource} sources use a function of this type to
 * get the url to load features from.
 *
 * This function takes an {@link module:ol/extent~Extent} representing the area
 * to be loaded, a `{number}` representing the resolution (map units per pixel)
 * and an {@link module:ol/proj/Projection~Projection} for the projection  as
 * arguments and returns a `{string}` representing the URL.
 * @typedef {function(import("./extent.js").Extent, number, import("./proj/Projection.js").default): string} FeatureUrlFunction
 * @api
 */

/**
 * @param {string|FeatureUrlFunction} url Feature URL service.
 * @param {import("./format/Feature.js").default} format Feature format.
 * @param {import("./extent.js").Extent} extent Extent.
 * @param {number} resolution Resolution.
 * @param {import("./proj/Projection.js").default} projection Projection.
 * @param {function(Array<import("./Feature.js").default>, import("./proj/Projection.js").default): void} success Success
 *      Function called with the loaded features and optionally with the data projection.
 * @param {function(): void} failure Failure
 *      Function called when loading failed.
 */
function loadFeaturesXhr(
  url,
  format,
  extent,
  resolution,
  projection,
  success,
  failure
) {
  const xhr = new XMLHttpRequest();
  xhr.open(
    'GET',
    typeof url === 'function' ? url(extent, resolution, projection) : url,
    true
  );
  if (format.getType() == 'arraybuffer') {
    xhr.responseType = 'arraybuffer';
  }
  xhr.withCredentials = withCredentials;
  /**
   * @param {Event} event Event.
   * @private
   */
  xhr.onload = function (event) {
    // status will be 0 for file:// urls
    if (!xhr.status || (xhr.status >= 200 && xhr.status < 300)) {
      const type = format.getType();
      /** @type {Document|Node|Object|string|undefined} */
      let source;
      if (type == 'json' || type == 'text') {
        source = xhr.responseText;
      } else if (type == 'xml') {
        source = xhr.responseXML;
        if (!source) {
          source = new DOMParser().parseFromString(
            xhr.responseText,
            'application/xml'
          );
        }
      } else if (type == 'arraybuffer') {
        source = /** @type {ArrayBuffer} */ (xhr.response);
      }
      if (source) {
        success(
          /** @type {Array<import("./Feature.js").default>} */
          (
            format.readFeatures(source, {
              extent: extent,
              featureProjection: projection,
            })
          ),
          format.readProjection(source)
        );
      } else {
        failure();
      }
    } else {
      failure();
    }
  };
  /**
   * @private
   */
  xhr.onerror = failure;
  xhr.send();
}

/**
 * Create an XHR feature loader for a `url` and `format`. The feature loader
 * loads features (with XHR), parses the features, and adds them to the
 * vector source.
 * @param {string|FeatureUrlFunction} url Feature URL service.
 * @param {import("./format/Feature.js").default} format Feature format.
 * @return {FeatureLoader} The feature loader.
 * @api
 */
function xhr(url, format) {
  /**
   * @param {import("./extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @param {import("./proj/Projection.js").default} projection Projection.
   * @param {function(Array<import("./Feature.js").default>): void} [success] Success
   *      Function called when loading succeeded.
   * @param {function(): void} [failure] Failure
   *      Function called when loading failed.
   */
  return function (extent, resolution, projection, success, failure) {
    const source = /** @type {import("./source/Vector").default} */ (this);
    loadFeaturesXhr(
      url,
      format,
      extent,
      resolution,
      projection,
      /**
       * @param {Array<import("./Feature.js").default>} features The loaded features.
       * @param {import("./proj/Projection.js").default} dataProjection Data
       * projection.
       */
      function (features, dataProjection) {
        source.addFeatures(features);
        if (success !== undefined) {
          success(features);
        }
      },
      /* FIXME handle error */ failure ? failure : _functions_js__WEBPACK_IMPORTED_MODULE_0__.VOID
    );
  };
}

/**
 * Setter for the withCredentials configuration for the XHR.
 *
 * @param {boolean} xhrWithCredentials The value of withCredentials to set.
 * Compare https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/
 * @api
 */
function setWithCredentials(xhrWithCredentials) {
  withCredentials = xhrWithCredentials;
}


/***/ }),

/***/ "./node_modules/ol/format/Feature.js":
/*!*******************************************!*\
  !*** ./node_modules/ol/format/Feature.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   transformExtentWithOptions: () => (/* binding */ transformExtentWithOptions),
/* harmony export */   transformGeometryWithOptions: () => (/* binding */ transformGeometryWithOptions)
/* harmony export */ });
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util.js */ "./node_modules/ol/util.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../proj.js */ "./node_modules/ol/proj.js");
/**
 * @module ol/format/Feature
 */



/**
 * @typedef {Object} ReadOptions
 * @property {import("../proj.js").ProjectionLike} [dataProjection] Projection of the data we are reading.
 * If not provided, the projection will be derived from the data (where possible) or
 * the `dataProjection` of the format is assigned (where set). If the projection
 * can not be derived from the data and if no `dataProjection` is set for a format,
 * the features will not be reprojected.
 * @property {import("../extent.js").Extent} [extent] Tile extent in map units of the tile being read.
 * This is only required when reading data with tile pixels as geometry units. When configured,
 * a `dataProjection` with `TILE_PIXELS` as `units` and the tile's pixel extent as `extent` needs to be
 * provided.
 * @property {import("../proj.js").ProjectionLike} [featureProjection] Projection of the feature geometries
 * created by the format reader. If not provided, features will be returned in the
 * `dataProjection`.
 */

/**
 * @typedef {Object} WriteOptions
 * @property {import("../proj.js").ProjectionLike} [dataProjection] Projection of the data we are writing.
 * If not provided, the `dataProjection` of the format is assigned (where set).
 * If no `dataProjection` is set for a format, the features will be returned
 * in the `featureProjection`.
 * @property {import("../proj.js").ProjectionLike} [featureProjection] Projection of the feature geometries
 * that will be serialized by the format writer. If not provided, geometries are assumed
 * to be in the `dataProjection` if that is set; in other words, they are not transformed.
 * @property {boolean} [rightHanded] When writing geometries, follow the right-hand
 * rule for linear ring orientation.  This means that polygons will have counter-clockwise
 * exterior rings and clockwise interior rings.  By default, coordinates are serialized
 * as they are provided at construction.  If `true`, the right-hand rule will
 * be applied.  If `false`, the left-hand rule will be applied (clockwise for
 * exterior and counter-clockwise for interior rings).  Note that not all
 * formats support this.  The GeoJSON format does use this property when writing
 * geometries.
 * @property {number} [decimals] Maximum number of decimal places for coordinates.
 * Coordinates are stored internally as floats, but floating-point arithmetic can create
 * coordinates with a large number of decimal places, not generally wanted on output.
 * Set a number here to round coordinates. Can also be used to ensure that
 * coordinates read in can be written back out with the same number of decimals.
 * Default is no rounding.
 */

/**
 * @typedef {'arraybuffer' | 'json' | 'text' | 'xml'} Type
 */

/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Base class for feature formats.
 * {@link module:ol/format/Feature~FeatureFormat} subclasses provide the ability to decode and encode
 * {@link module:ol/Feature~Feature} objects from a variety of commonly used geospatial
 * file formats.  See the documentation for each format for more details.
 *
 * @abstract
 * @api
 */
class FeatureFormat {
  constructor() {
    /**
     * @protected
     * @type {import("../proj/Projection.js").default|undefined}
     */
    this.dataProjection = undefined;

    /**
     * @protected
     * @type {import("../proj/Projection.js").default|undefined}
     */
    this.defaultFeatureProjection = undefined;

    /**
     * A list media types supported by the format in descending order of preference.
     * @type {Array<string>}
     */
    this.supportedMediaTypes = null;
  }

  /**
   * Adds the data projection to the read options.
   * @param {Document|Element|Object|string} source Source.
   * @param {ReadOptions} [options] Options.
   * @return {ReadOptions|undefined} Options.
   * @protected
   */
  getReadOptions(source, options) {
    if (options) {
      let dataProjection = options.dataProjection
        ? (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.get)(options.dataProjection)
        : this.readProjection(source);
      if (
        options.extent &&
        dataProjection &&
        dataProjection.getUnits() === 'tile-pixels'
      ) {
        dataProjection = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.get)(dataProjection);
        dataProjection.setWorldExtent(options.extent);
      }
      options = {
        dataProjection: dataProjection,
        featureProjection: options.featureProjection,
      };
    }
    return this.adaptOptions(options);
  }

  /**
   * Sets the `dataProjection` on the options, if no `dataProjection`
   * is set.
   * @param {WriteOptions|ReadOptions|undefined} options
   *     Options.
   * @protected
   * @return {WriteOptions|ReadOptions|undefined}
   *     Updated options.
   */
  adaptOptions(options) {
    return Object.assign(
      {
        dataProjection: this.dataProjection,
        featureProjection: this.defaultFeatureProjection,
      },
      options
    );
  }

  /**
   * @abstract
   * @return {Type} The format type.
   */
  getType() {
    return (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.abstract)();
  }

  /**
   * Read a single feature from a source.
   *
   * @abstract
   * @param {Document|Element|Object|string} source Source.
   * @param {ReadOptions} [options] Read options.
   * @return {import("../Feature.js").FeatureLike} Feature.
   */
  readFeature(source, options) {
    return (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.abstract)();
  }

  /**
   * Read all features from a source.
   *
   * @abstract
   * @param {Document|Element|ArrayBuffer|Object|string} source Source.
   * @param {ReadOptions} [options] Read options.
   * @return {Array<import("../Feature.js").FeatureLike>} Features.
   */
  readFeatures(source, options) {
    return (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.abstract)();
  }

  /**
   * Read a single geometry from a source.
   *
   * @abstract
   * @param {Document|Element|Object|string} source Source.
   * @param {ReadOptions} [options] Read options.
   * @return {import("../geom/Geometry.js").default} Geometry.
   */
  readGeometry(source, options) {
    return (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.abstract)();
  }

  /**
   * Read the projection from a source.
   *
   * @abstract
   * @param {Document|Element|Object|string} source Source.
   * @return {import("../proj/Projection.js").default|undefined} Projection.
   */
  readProjection(source) {
    return (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.abstract)();
  }

  /**
   * Encode a feature in this format.
   *
   * @abstract
   * @param {import("../Feature.js").default} feature Feature.
   * @param {WriteOptions} [options] Write options.
   * @return {string|ArrayBuffer} Result.
   */
  writeFeature(feature, options) {
    return (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.abstract)();
  }

  /**
   * Encode an array of features in this format.
   *
   * @abstract
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {WriteOptions} [options] Write options.
   * @return {string|ArrayBuffer} Result.
   */
  writeFeatures(features, options) {
    return (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.abstract)();
  }

  /**
   * Write a single geometry in this format.
   *
   * @abstract
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {WriteOptions} [options] Write options.
   * @return {string|ArrayBuffer} Result.
   */
  writeGeometry(geometry, options) {
    return (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.abstract)();
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (FeatureFormat);

/**
 * @param {import("../geom/Geometry.js").default} geometry Geometry.
 * @param {boolean} write Set to true for writing, false for reading.
 * @param {WriteOptions|ReadOptions} [options] Options.
 * @return {import("../geom/Geometry.js").default} Transformed geometry.
 */
function transformGeometryWithOptions(geometry, write, options) {
  const featureProjection = options
    ? (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.get)(options.featureProjection)
    : null;
  const dataProjection = options ? (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.get)(options.dataProjection) : null;

  let transformed;
  if (
    featureProjection &&
    dataProjection &&
    !(0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.equivalent)(featureProjection, dataProjection)
  ) {
    transformed = (write ? geometry.clone() : geometry).transform(
      write ? featureProjection : dataProjection,
      write ? dataProjection : featureProjection
    );
  } else {
    transformed = geometry;
  }
  if (
    write &&
    options &&
    /** @type {WriteOptions} */ (options).decimals !== undefined
  ) {
    const power = Math.pow(10, /** @type {WriteOptions} */ (options).decimals);
    // if decimals option on write, round each coordinate appropriately
    /**
     * @param {Array<number>} coordinates Coordinates.
     * @return {Array<number>} Transformed coordinates.
     */
    const transform = function (coordinates) {
      for (let i = 0, ii = coordinates.length; i < ii; ++i) {
        coordinates[i] = Math.round(coordinates[i] * power) / power;
      }
      return coordinates;
    };
    if (transformed === geometry) {
      transformed = geometry.clone();
    }
    transformed.applyTransform(transform);
  }
  return transformed;
}

/**
 * @param {import("../extent.js").Extent} extent Extent.
 * @param {ReadOptions} [options] Read options.
 * @return {import("../extent.js").Extent} Transformed extent.
 */
function transformExtentWithOptions(extent, options) {
  const featureProjection = options
    ? (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.get)(options.featureProjection)
    : null;
  const dataProjection = options ? (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.get)(options.dataProjection) : null;

  if (
    featureProjection &&
    dataProjection &&
    !(0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.equivalent)(featureProjection, dataProjection)
  ) {
    return (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.transformExtent)(extent, dataProjection, featureProjection);
  }
  return extent;
}


/***/ }),

/***/ "./node_modules/ol/format/GeoJSON.js":
/*!*******************************************!*\
  !*** ./node_modules/ol/format/GeoJSON.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Feature_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Feature.js */ "./node_modules/ol/Feature.js");
/* harmony import */ var _geom_GeometryCollection_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../geom/GeometryCollection.js */ "./node_modules/ol/geom/GeometryCollection.js");
/* harmony import */ var _JSONFeature_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./JSONFeature.js */ "./node_modules/ol/format/JSONFeature.js");
/* harmony import */ var _geom_LineString_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../geom/LineString.js */ "./node_modules/ol/geom/LineString.js");
/* harmony import */ var _geom_MultiLineString_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../geom/MultiLineString.js */ "./node_modules/ol/geom/MultiLineString.js");
/* harmony import */ var _geom_MultiPoint_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../geom/MultiPoint.js */ "./node_modules/ol/geom/MultiPoint.js");
/* harmony import */ var _geom_MultiPolygon_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../geom/MultiPolygon.js */ "./node_modules/ol/geom/MultiPolygon.js");
/* harmony import */ var _geom_Point_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../geom/Point.js */ "./node_modules/ol/geom/Point.js");
/* harmony import */ var _geom_Polygon_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../geom/Polygon.js */ "./node_modules/ol/geom/Polygon.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../proj.js */ "./node_modules/ol/proj.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../obj.js */ "./node_modules/ol/obj.js");
/* harmony import */ var _Feature_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Feature.js */ "./node_modules/ol/format/Feature.js");
/**
 * @module ol/format/GeoJSON
 */














/**
 * @typedef {import("geojson").GeoJSON} GeoJSONObject
 * @typedef {import("geojson").Feature} GeoJSONFeature
 * @typedef {import("geojson").FeatureCollection} GeoJSONFeatureCollection
 * @typedef {import("geojson").Geometry} GeoJSONGeometry
 * @typedef {import("geojson").Point} GeoJSONPoint
 * @typedef {import("geojson").LineString} GeoJSONLineString
 * @typedef {import("geojson").Polygon} GeoJSONPolygon
 * @typedef {import("geojson").MultiPoint} GeoJSONMultiPoint
 * @typedef {import("geojson").MultiLineString} GeoJSONMultiLineString
 * @typedef {import("geojson").MultiPolygon} GeoJSONMultiPolygon
 * @typedef {import("geojson").GeometryCollection} GeoJSONGeometryCollection
 */

/**
 * @typedef {Object} Options
 * @property {import("../proj.js").ProjectionLike} [dataProjection='EPSG:4326'] Default data projection.
 * @property {import("../proj.js").ProjectionLike} [featureProjection] Projection for features read or
 * written by the format.  Options passed to read or write methods will take precedence.
 * @property {string} [geometryName] Geometry name to use when creating features.
 * @property {boolean} [extractGeometryName=false] Certain GeoJSON providers include
 * the geometry_name field in the feature GeoJSON. If set to `true` the GeoJSON reader
 * will look for that field to set the geometry name. If both this field is set to `true`
 * and a `geometryName` is provided, the `geometryName` will take precedence.
 */

/**
 * @classdesc
 * Feature format for reading and writing data in the GeoJSON format.
 *
 * @api
 */
class GeoJSON extends _JSONFeature_js__WEBPACK_IMPORTED_MODULE_1__["default"] {
  /**
   * @param {Options} [options] Options.
   */
  constructor(options) {
    options = options ? options : {};

    super();

    /**
     * @type {import("../proj/Projection.js").default}
     */
    this.dataProjection = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.get)(
      options.dataProjection ? options.dataProjection : 'EPSG:4326'
    );

    if (options.featureProjection) {
      /**
       * @type {import("../proj/Projection.js").default}
       */
      this.defaultFeatureProjection = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.get)(options.featureProjection);
    }

    /**
     * Name of the geometry attribute for features.
     * @type {string|undefined}
     * @private
     */
    this.geometryName_ = options.geometryName;

    /**
     * Look for the geometry name in the feature GeoJSON
     * @type {boolean|undefined}
     * @private
     */
    this.extractGeometryName_ = options.extractGeometryName;

    this.supportedMediaTypes = [
      'application/geo+json',
      'application/vnd.geo+json',
    ];
  }

  /**
   * @param {Object} object Object.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {import("../Feature.js").default} Feature.
   */
  readFeatureFromObject(object, options) {
    /**
     * @type {GeoJSONFeature}
     */
    let geoJSONFeature = null;
    if (object['type'] === 'Feature') {
      geoJSONFeature = /** @type {GeoJSONFeature} */ (object);
    } else {
      geoJSONFeature = {
        'type': 'Feature',
        'geometry': /** @type {GeoJSONGeometry} */ (object),
        'properties': null,
      };
    }

    const geometry = readGeometry(geoJSONFeature['geometry'], options);
    const feature = new _Feature_js__WEBPACK_IMPORTED_MODULE_2__["default"]();
    if (this.geometryName_) {
      feature.setGeometryName(this.geometryName_);
    } else if (
      this.extractGeometryName_ &&
      'geometry_name' in geoJSONFeature !== undefined
    ) {
      feature.setGeometryName(geoJSONFeature['geometry_name']);
    }
    feature.setGeometry(geometry);

    if ('id' in geoJSONFeature) {
      feature.setId(geoJSONFeature['id']);
    }

    if (geoJSONFeature['properties']) {
      feature.setProperties(geoJSONFeature['properties'], true);
    }
    return feature;
  }

  /**
   * @param {Object} object Object.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {Array<Feature>} Features.
   */
  readFeaturesFromObject(object, options) {
    const geoJSONObject = /** @type {GeoJSONObject} */ (object);
    /** @type {Array<import("../Feature.js").default>} */
    let features = null;
    if (geoJSONObject['type'] === 'FeatureCollection') {
      const geoJSONFeatureCollection = /** @type {GeoJSONFeatureCollection} */ (
        object
      );
      features = [];
      const geoJSONFeatures = geoJSONFeatureCollection['features'];
      for (let i = 0, ii = geoJSONFeatures.length; i < ii; ++i) {
        features.push(this.readFeatureFromObject(geoJSONFeatures[i], options));
      }
    } else {
      features = [this.readFeatureFromObject(object, options)];
    }
    return features;
  }

  /**
   * @param {GeoJSONGeometry} object Object.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {import("../geom/Geometry.js").default} Geometry.
   */
  readGeometryFromObject(object, options) {
    return readGeometry(object, options);
  }

  /**
   * @param {Object} object Object.
   * @protected
   * @return {import("../proj/Projection.js").default} Projection.
   */
  readProjectionFromObject(object) {
    const crs = object['crs'];
    let projection;
    if (crs) {
      if (crs['type'] == 'name') {
        projection = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.get)(crs['properties']['name']);
      } else if (crs['type'] === 'EPSG') {
        projection = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.get)('EPSG:' + crs['properties']['code']);
      } else {
        throw new Error('Unknown SRS type');
      }
    } else {
      projection = this.dataProjection;
    }
    return /** @type {import("../proj/Projection.js").default} */ (projection);
  }

  /**
   * Encode a feature as a GeoJSON Feature object.
   *
   * @param {import("../Feature.js").default} feature Feature.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {GeoJSONFeature} Object.
   * @api
   */
  writeFeatureObject(feature, options) {
    options = this.adaptOptions(options);

    /** @type {GeoJSONFeature} */
    const object = {
      'type': 'Feature',
      geometry: null,
      properties: null,
    };

    const id = feature.getId();
    if (id !== undefined) {
      object.id = id;
    }

    if (!feature.hasProperties()) {
      return object;
    }

    const properties = feature.getProperties();
    const geometry = feature.getGeometry();
    if (geometry) {
      object.geometry = writeGeometry(geometry, options);

      delete properties[feature.getGeometryName()];
    }

    if (!(0,_obj_js__WEBPACK_IMPORTED_MODULE_3__.isEmpty)(properties)) {
      object.properties = properties;
    }

    return object;
  }

  /**
   * Encode an array of features as a GeoJSON object.
   *
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {GeoJSONFeatureCollection} GeoJSON Object.
   * @api
   */
  writeFeaturesObject(features, options) {
    options = this.adaptOptions(options);
    const objects = [];
    for (let i = 0, ii = features.length; i < ii; ++i) {
      objects.push(this.writeFeatureObject(features[i], options));
    }
    return {
      type: 'FeatureCollection',
      features: objects,
    };
  }

  /**
   * Encode a geometry as a GeoJSON object.
   *
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {GeoJSONGeometry|GeoJSONGeometryCollection} Object.
   * @api
   */
  writeGeometryObject(geometry, options) {
    return writeGeometry(geometry, this.adaptOptions(options));
  }
}

/**
 * @param {GeoJSONGeometry|GeoJSONGeometryCollection} object Object.
 * @param {import("./Feature.js").ReadOptions} [options] Read options.
 * @return {import("../geom/Geometry.js").default} Geometry.
 */
function readGeometry(object, options) {
  if (!object) {
    return null;
  }

  /**
   * @type {import("../geom/Geometry.js").default}
   */
  let geometry;
  switch (object['type']) {
    case 'Point': {
      geometry = readPointGeometry(/** @type {GeoJSONPoint} */ (object));
      break;
    }
    case 'LineString': {
      geometry = readLineStringGeometry(
        /** @type {GeoJSONLineString} */ (object)
      );
      break;
    }
    case 'Polygon': {
      geometry = readPolygonGeometry(/** @type {GeoJSONPolygon} */ (object));
      break;
    }
    case 'MultiPoint': {
      geometry = readMultiPointGeometry(
        /** @type {GeoJSONMultiPoint} */ (object)
      );
      break;
    }
    case 'MultiLineString': {
      geometry = readMultiLineStringGeometry(
        /** @type {GeoJSONMultiLineString} */ (object)
      );
      break;
    }
    case 'MultiPolygon': {
      geometry = readMultiPolygonGeometry(
        /** @type {GeoJSONMultiPolygon} */ (object)
      );
      break;
    }
    case 'GeometryCollection': {
      geometry = readGeometryCollectionGeometry(
        /** @type {GeoJSONGeometryCollection} */ (object)
      );
      break;
    }
    default: {
      throw new Error('Unsupported GeoJSON type: ' + object['type']);
    }
  }
  return (0,_Feature_js__WEBPACK_IMPORTED_MODULE_4__.transformGeometryWithOptions)(geometry, false, options);
}

/**
 * @param {GeoJSONGeometryCollection} object Object.
 * @param {import("./Feature.js").ReadOptions} [options] Read options.
 * @return {GeometryCollection} Geometry collection.
 */
function readGeometryCollectionGeometry(object, options) {
  const geometries = object['geometries'].map(
    /**
     * @param {GeoJSONGeometry} geometry Geometry.
     * @return {import("../geom/Geometry.js").default} geometry Geometry.
     */
    function (geometry) {
      return readGeometry(geometry, options);
    }
  );
  return new _geom_GeometryCollection_js__WEBPACK_IMPORTED_MODULE_5__["default"](geometries);
}

/**
 * @param {GeoJSONPoint} object Object.
 * @return {Point} Point.
 */
function readPointGeometry(object) {
  return new _geom_Point_js__WEBPACK_IMPORTED_MODULE_6__["default"](object['coordinates']);
}

/**
 * @param {GeoJSONLineString} object Object.
 * @return {LineString} LineString.
 */
function readLineStringGeometry(object) {
  return new _geom_LineString_js__WEBPACK_IMPORTED_MODULE_7__["default"](object['coordinates']);
}

/**
 * @param {GeoJSONMultiLineString} object Object.
 * @return {MultiLineString} MultiLineString.
 */
function readMultiLineStringGeometry(object) {
  return new _geom_MultiLineString_js__WEBPACK_IMPORTED_MODULE_8__["default"](object['coordinates']);
}

/**
 * @param {GeoJSONMultiPoint} object Object.
 * @return {MultiPoint} MultiPoint.
 */
function readMultiPointGeometry(object) {
  return new _geom_MultiPoint_js__WEBPACK_IMPORTED_MODULE_9__["default"](object['coordinates']);
}

/**
 * @param {GeoJSONMultiPolygon} object Object.
 * @return {MultiPolygon} MultiPolygon.
 */
function readMultiPolygonGeometry(object) {
  return new _geom_MultiPolygon_js__WEBPACK_IMPORTED_MODULE_10__["default"](object['coordinates']);
}

/**
 * @param {GeoJSONPolygon} object Object.
 * @return {Polygon} Polygon.
 */
function readPolygonGeometry(object) {
  return new _geom_Polygon_js__WEBPACK_IMPORTED_MODULE_11__["default"](object['coordinates']);
}

/**
 * @param {import("../geom/Geometry.js").default} geometry Geometry.
 * @param {import("./Feature.js").WriteOptions} [options] Write options.
 * @return {GeoJSONGeometry} GeoJSON geometry.
 */
function writeGeometry(geometry, options) {
  geometry = (0,_Feature_js__WEBPACK_IMPORTED_MODULE_4__.transformGeometryWithOptions)(geometry, true, options);
  const type = geometry.getType();

  /** @type {GeoJSONGeometry} */
  let geoJSON;
  switch (type) {
    case 'Point': {
      geoJSON = writePointGeometry(/** @type {Point} */ (geometry), options);
      break;
    }
    case 'LineString': {
      geoJSON = writeLineStringGeometry(
        /** @type {LineString} */ (geometry),
        options
      );
      break;
    }
    case 'Polygon': {
      geoJSON = writePolygonGeometry(
        /** @type {Polygon} */ (geometry),
        options
      );
      break;
    }
    case 'MultiPoint': {
      geoJSON = writeMultiPointGeometry(
        /** @type {MultiPoint} */ (geometry),
        options
      );
      break;
    }
    case 'MultiLineString': {
      geoJSON = writeMultiLineStringGeometry(
        /** @type {MultiLineString} */ (geometry),
        options
      );
      break;
    }
    case 'MultiPolygon': {
      geoJSON = writeMultiPolygonGeometry(
        /** @type {MultiPolygon} */ (geometry),
        options
      );
      break;
    }
    case 'GeometryCollection': {
      geoJSON = writeGeometryCollectionGeometry(
        /** @type {GeometryCollection} */ (geometry),
        options
      );
      break;
    }
    case 'Circle': {
      geoJSON = {
        type: 'GeometryCollection',
        geometries: [],
      };
      break;
    }
    default: {
      throw new Error('Unsupported geometry type: ' + type);
    }
  }
  return geoJSON;
}

/**
 * @param {GeometryCollection} geometry Geometry.
 * @param {import("./Feature.js").WriteOptions} [options] Write options.
 * @return {GeoJSONGeometryCollection} GeoJSON geometry collection.
 */
function writeGeometryCollectionGeometry(geometry, options) {
  options = Object.assign({}, options);
  delete options.featureProjection;
  const geometries = geometry.getGeometriesArray().map(function (geometry) {
    return writeGeometry(geometry, options);
  });
  return {
    type: 'GeometryCollection',
    geometries: geometries,
  };
}

/**
 * @param {LineString} geometry Geometry.
 * @param {import("./Feature.js").WriteOptions} [options] Write options.
 * @return {GeoJSONGeometry} GeoJSON geometry.
 */
function writeLineStringGeometry(geometry, options) {
  return {
    type: 'LineString',
    coordinates: geometry.getCoordinates(),
  };
}

/**
 * @param {MultiLineString} geometry Geometry.
 * @param {import("./Feature.js").WriteOptions} [options] Write options.
 * @return {GeoJSONGeometry} GeoJSON geometry.
 */
function writeMultiLineStringGeometry(geometry, options) {
  return {
    type: 'MultiLineString',
    coordinates: geometry.getCoordinates(),
  };
}

/**
 * @param {MultiPoint} geometry Geometry.
 * @param {import("./Feature.js").WriteOptions} [options] Write options.
 * @return {GeoJSONGeometry} GeoJSON geometry.
 */
function writeMultiPointGeometry(geometry, options) {
  return {
    type: 'MultiPoint',
    coordinates: geometry.getCoordinates(),
  };
}

/**
 * @param {MultiPolygon} geometry Geometry.
 * @param {import("./Feature.js").WriteOptions} [options] Write options.
 * @return {GeoJSONGeometry} GeoJSON geometry.
 */
function writeMultiPolygonGeometry(geometry, options) {
  let right;
  if (options) {
    right = options.rightHanded;
  }
  return {
    type: 'MultiPolygon',
    coordinates: geometry.getCoordinates(right),
  };
}

/**
 * @param {Point} geometry Geometry.
 * @param {import("./Feature.js").WriteOptions} [options] Write options.
 * @return {GeoJSONGeometry} GeoJSON geometry.
 */
function writePointGeometry(geometry, options) {
  return {
    type: 'Point',
    coordinates: geometry.getCoordinates(),
  };
}

/**
 * @param {Polygon} geometry Geometry.
 * @param {import("./Feature.js").WriteOptions} [options] Write options.
 * @return {GeoJSONGeometry} GeoJSON geometry.
 */
function writePolygonGeometry(geometry, options) {
  let right;
  if (options) {
    right = options.rightHanded;
  }
  return {
    type: 'Polygon',
    coordinates: geometry.getCoordinates(right),
  };
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (GeoJSON);


/***/ }),

/***/ "./node_modules/ol/format/JSONFeature.js":
/*!***********************************************!*\
  !*** ./node_modules/ol/format/JSONFeature.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Feature_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Feature.js */ "./node_modules/ol/format/Feature.js");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util.js */ "./node_modules/ol/util.js");
/**
 * @module ol/format/JSONFeature
 */



/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Base class for JSON feature formats.
 *
 * @abstract
 */
class JSONFeature extends _Feature_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  constructor() {
    super();
  }

  /**
   * @return {import("./Feature.js").Type} Format.
   */
  getType() {
    return 'json';
  }

  /**
   * Read a feature.  Only works for a single feature. Use `readFeatures` to
   * read a feature collection.
   *
   * @param {ArrayBuffer|Document|Element|Object|string} source Source.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @return {import("../Feature.js").default} Feature.
   * @api
   */
  readFeature(source, options) {
    return this.readFeatureFromObject(
      getObject(source),
      this.getReadOptions(source, options)
    );
  }

  /**
   * Read all features.  Works with both a single feature and a feature
   * collection.
   *
   * @param {ArrayBuffer|Document|Element|Object|string} source Source.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @return {Array<import("../Feature.js").default>} Features.
   * @api
   */
  readFeatures(source, options) {
    return this.readFeaturesFromObject(
      getObject(source),
      this.getReadOptions(source, options)
    );
  }

  /**
   * @abstract
   * @param {Object} object Object.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {import("../Feature.js").default} Feature.
   */
  readFeatureFromObject(object, options) {
    return (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.abstract)();
  }

  /**
   * @abstract
   * @param {Object} object Object.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {Array<import("../Feature.js").default>} Features.
   */
  readFeaturesFromObject(object, options) {
    return (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.abstract)();
  }

  /**
   * Read a geometry.
   *
   * @param {ArrayBuffer|Document|Element|Object|string} source Source.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @return {import("../geom/Geometry.js").default} Geometry.
   * @api
   */
  readGeometry(source, options) {
    return this.readGeometryFromObject(
      getObject(source),
      this.getReadOptions(source, options)
    );
  }

  /**
   * @abstract
   * @param {Object} object Object.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {import("../geom/Geometry.js").default} Geometry.
   */
  readGeometryFromObject(object, options) {
    return (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.abstract)();
  }

  /**
   * Read the projection.
   *
   * @param {ArrayBuffer|Document|Element|Object|string} source Source.
   * @return {import("../proj/Projection.js").default} Projection.
   * @api
   */
  readProjection(source) {
    return this.readProjectionFromObject(getObject(source));
  }

  /**
   * @abstract
   * @param {Object} object Object.
   * @protected
   * @return {import("../proj/Projection.js").default} Projection.
   */
  readProjectionFromObject(object) {
    return (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.abstract)();
  }

  /**
   * Encode a feature as string.
   *
   * @param {import("../Feature.js").default} feature Feature.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {string} Encoded feature.
   * @api
   */
  writeFeature(feature, options) {
    return JSON.stringify(this.writeFeatureObject(feature, options));
  }

  /**
   * @abstract
   * @param {import("../Feature.js").default} feature Feature.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {Object} Object.
   */
  writeFeatureObject(feature, options) {
    return (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.abstract)();
  }

  /**
   * Encode an array of features as string.
   *
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {string} Encoded features.
   * @api
   */
  writeFeatures(features, options) {
    return JSON.stringify(this.writeFeaturesObject(features, options));
  }

  /**
   * @abstract
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {Object} Object.
   */
  writeFeaturesObject(features, options) {
    return (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.abstract)();
  }

  /**
   * Encode a geometry as string.
   *
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {string} Encoded geometry.
   * @api
   */
  writeGeometry(geometry, options) {
    return JSON.stringify(this.writeGeometryObject(geometry, options));
  }

  /**
   * @abstract
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {Object} Object.
   */
  writeGeometryObject(geometry, options) {
    return (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.abstract)();
  }
}

/**
 * @param {Document|Element|Object|string} source Source.
 * @return {Object} Object.
 */
function getObject(source) {
  if (typeof source === 'string') {
    const object = JSON.parse(source);
    return object ? /** @type {Object} */ (object) : null;
  }
  if (source !== null) {
    return source;
  }
  return null;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (JSONFeature);


/***/ }),

/***/ "./node_modules/ol/functions.js":
/*!**************************************!*\
  !*** ./node_modules/ol/functions.js ***!
  \**************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FALSE: () => (/* binding */ FALSE),
/* harmony export */   TRUE: () => (/* binding */ TRUE),
/* harmony export */   VOID: () => (/* binding */ VOID),
/* harmony export */   memoizeOne: () => (/* binding */ memoizeOne),
/* harmony export */   toPromise: () => (/* binding */ toPromise)
/* harmony export */ });
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./array.js */ "./node_modules/ol/array.js");
/**
 * @module ol/functions
 */



/**
 * Always returns true.
 * @return {boolean} true.
 */
function TRUE() {
  return true;
}

/**
 * Always returns false.
 * @return {boolean} false.
 */
function FALSE() {
  return false;
}

/**
 * A reusable function, used e.g. as a default for callbacks.
 *
 * @return {void} Nothing.
 */
function VOID() {}

/**
 * Wrap a function in another function that remembers the last return.  If the
 * returned function is called twice in a row with the same arguments and the same
 * this object, it will return the value from the first call in the second call.
 *
 * @param {function(...any): ReturnType} fn The function to memoize.
 * @return {function(...any): ReturnType} The memoized function.
 * @template ReturnType
 */
function memoizeOne(fn) {
  let called = false;

  /** @type {ReturnType} */
  let lastResult;

  /** @type {Array<any>} */
  let lastArgs;

  let lastThis;

  return function () {
    const nextArgs = Array.prototype.slice.call(arguments);
    if (!called || this !== lastThis || !(0,_array_js__WEBPACK_IMPORTED_MODULE_0__.equals)(nextArgs, lastArgs)) {
      called = true;
      lastThis = this;
      lastArgs = nextArgs;
      lastResult = fn.apply(this, arguments);
    }
    return lastResult;
  };
}

/**
 * @template T
 * @param {function(): (T | Promise<T>)} getter A function that returns a value or a promise for a value.
 * @return {Promise<T>} A promise for the value.
 */
function toPromise(getter) {
  function promiseGetter() {
    let value;
    try {
      value = getter();
    } catch (err) {
      return Promise.reject(err);
    }
    if (value instanceof Promise) {
      return value;
    }
    return Promise.resolve(value);
  }
  return promiseGetter();
}


/***/ }),

/***/ "./node_modules/ol/geom/Circle.js":
/*!****************************************!*\
  !*** ./node_modules/ol/geom/Circle.js ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SimpleGeometry.js */ "./node_modules/ol/geom/SimpleGeometry.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _flat_deflate_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./flat/deflate.js */ "./node_modules/ol/geom/flat/deflate.js");
/* harmony import */ var _flat_transform_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./flat/transform.js */ "./node_modules/ol/geom/flat/transform.js");
/**
 * @module ol/geom/Circle
 */





/**
 * @classdesc
 * Circle geometry.
 *
 * @api
 */
class Circle extends _SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {!import("../coordinate.js").Coordinate} center Center.
   *     For internal use, flat coordinates in combination with `layout` and no
   *     `radius` are also accepted.
   * @param {number} [radius] Radius in units of the projection.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   */
  constructor(center, radius, layout) {
    super();
    if (layout !== undefined && radius === undefined) {
      this.setFlatCoordinates(layout, center);
    } else {
      radius = radius ? radius : 0;
      this.setCenterAndRadius(center, radius, layout);
    }
  }

  /**
   * Make a complete copy of the geometry.
   * @return {!Circle} Clone.
   * @api
   */
  clone() {
    const circle = new Circle(
      this.flatCoordinates.slice(),
      undefined,
      this.layout
    );
    circle.applyProperties(this);
    return circle;
  }

  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */
  closestPointXY(x, y, closestPoint, minSquaredDistance) {
    const flatCoordinates = this.flatCoordinates;
    const dx = x - flatCoordinates[0];
    const dy = y - flatCoordinates[1];
    const squaredDistance = dx * dx + dy * dy;
    if (squaredDistance < minSquaredDistance) {
      if (squaredDistance === 0) {
        for (let i = 0; i < this.stride; ++i) {
          closestPoint[i] = flatCoordinates[i];
        }
      } else {
        const delta = this.getRadius() / Math.sqrt(squaredDistance);
        closestPoint[0] = flatCoordinates[0] + delta * dx;
        closestPoint[1] = flatCoordinates[1] + delta * dy;
        for (let i = 2; i < this.stride; ++i) {
          closestPoint[i] = flatCoordinates[i];
        }
      }
      closestPoint.length = this.stride;
      return squaredDistance;
    }
    return minSquaredDistance;
  }

  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @return {boolean} Contains (x, y).
   */
  containsXY(x, y) {
    const flatCoordinates = this.flatCoordinates;
    const dx = x - flatCoordinates[0];
    const dy = y - flatCoordinates[1];
    return dx * dx + dy * dy <= this.getRadiusSquared_();
  }

  /**
   * Return the center of the circle as {@link module:ol/coordinate~Coordinate coordinate}.
   * @return {import("../coordinate.js").Coordinate} Center.
   * @api
   */
  getCenter() {
    return this.flatCoordinates.slice(0, this.stride);
  }

  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @protected
   * @return {import("../extent.js").Extent} extent Extent.
   */
  computeExtent(extent) {
    const flatCoordinates = this.flatCoordinates;
    const radius = flatCoordinates[this.stride] - flatCoordinates[0];
    return (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.createOrUpdate)(
      flatCoordinates[0] - radius,
      flatCoordinates[1] - radius,
      flatCoordinates[0] + radius,
      flatCoordinates[1] + radius,
      extent
    );
  }

  /**
   * Return the radius of the circle.
   * @return {number} Radius.
   * @api
   */
  getRadius() {
    return Math.sqrt(this.getRadiusSquared_());
  }

  /**
   * @private
   * @return {number} Radius squared.
   */
  getRadiusSquared_() {
    const dx = this.flatCoordinates[this.stride] - this.flatCoordinates[0];
    const dy = this.flatCoordinates[this.stride + 1] - this.flatCoordinates[1];
    return dx * dx + dy * dy;
  }

  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   */
  getType() {
    return 'Circle';
  }

  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */
  intersectsExtent(extent) {
    const circleExtent = this.getExtent();
    if ((0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.intersects)(extent, circleExtent)) {
      const center = this.getCenter();

      if (extent[0] <= center[0] && extent[2] >= center[0]) {
        return true;
      }
      if (extent[1] <= center[1] && extent[3] >= center[1]) {
        return true;
      }

      return (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.forEachCorner)(extent, this.intersectsCoordinate.bind(this));
    }
    return false;
  }

  /**
   * Set the center of the circle as {@link module:ol/coordinate~Coordinate coordinate}.
   * @param {import("../coordinate.js").Coordinate} center Center.
   * @api
   */
  setCenter(center) {
    const stride = this.stride;
    const radius = this.flatCoordinates[stride] - this.flatCoordinates[0];
    const flatCoordinates = center.slice();
    flatCoordinates[stride] = flatCoordinates[0] + radius;
    for (let i = 1; i < stride; ++i) {
      flatCoordinates[stride + i] = center[i];
    }
    this.setFlatCoordinates(this.layout, flatCoordinates);
    this.changed();
  }

  /**
   * Set the center (as {@link module:ol/coordinate~Coordinate coordinate}) and the radius (as
   * number) of the circle.
   * @param {!import("../coordinate.js").Coordinate} center Center.
   * @param {number} radius Radius.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   */
  setCenterAndRadius(center, radius, layout) {
    this.setLayout(layout, center, 0);
    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }
    /** @type {Array<number>} */
    const flatCoordinates = this.flatCoordinates;
    let offset = (0,_flat_deflate_js__WEBPACK_IMPORTED_MODULE_2__.deflateCoordinate)(flatCoordinates, 0, center, this.stride);
    flatCoordinates[offset++] = flatCoordinates[0] + radius;
    for (let i = 1, ii = this.stride; i < ii; ++i) {
      flatCoordinates[offset++] = flatCoordinates[i];
    }
    flatCoordinates.length = offset;
    this.changed();
  }

  getCoordinates() {
    return null;
  }

  setCoordinates(coordinates, layout) {}

  /**
   * Set the radius of the circle. The radius is in the units of the projection.
   * @param {number} radius Radius.
   * @api
   */
  setRadius(radius) {
    this.flatCoordinates[this.stride] = this.flatCoordinates[0] + radius;
    this.changed();
  }

  /**
   * Rotate the geometry around a given coordinate. This modifies the geometry
   * coordinates in place.
   * @param {number} angle Rotation angle in counter-clockwise radians.
   * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
   * @api
   */
  rotate(angle, anchor) {
    const center = this.getCenter();
    const stride = this.getStride();
    this.setCenter(
      (0,_flat_transform_js__WEBPACK_IMPORTED_MODULE_3__.rotate)(center, 0, center.length, stride, angle, anchor, center)
    );
    this.changed();
  }
}

/**
 * Transform each coordinate of the circle from one coordinate reference system
 * to another. The geometry is modified in place.
 * If you do not want the geometry modified in place, first clone() it and
 * then use this function on the clone.
 *
 * Internally a circle is currently represented by two points: the center of
 * the circle `[cx, cy]`, and the point to the right of the circle
 * `[cx + r, cy]`. This `transform` function just transforms these two points.
 * So the resulting geometry is also a circle, and that circle does not
 * correspond to the shape that would be obtained by transforming every point
 * of the original circle.
 *
 * @param {import("../proj.js").ProjectionLike} source The current projection.  Can be a
 *     string identifier or a {@link module:ol/proj/Projection~Projection} object.
 * @param {import("../proj.js").ProjectionLike} destination The desired projection.  Can be a
 *     string identifier or a {@link module:ol/proj/Projection~Projection} object.
 * @return {Circle} This geometry.  Note that original geometry is
 *     modified in place.
 * @function
 * @api
 */
Circle.prototype.transform;
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Circle);


/***/ }),

/***/ "./node_modules/ol/geom/Geometry.js":
/*!******************************************!*\
  !*** ./node_modules/ol/geom/Geometry.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Object_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Object.js */ "./node_modules/ol/Object.js");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../util.js */ "./node_modules/ol/util.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../transform.js */ "./node_modules/ol/transform.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../proj.js */ "./node_modules/ol/proj.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../functions.js */ "./node_modules/ol/functions.js");
/* harmony import */ var _flat_transform_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./flat/transform.js */ "./node_modules/ol/geom/flat/transform.js");
/**
 * @module ol/geom/Geometry
 */








/**
 * @typedef {'XY' | 'XYZ' | 'XYM' | 'XYZM'} GeometryLayout
 * The coordinate layout for geometries, indicating whether a 3rd or 4th z ('Z')
 * or measure ('M') coordinate is available.
 */

/**
 * @typedef {'Point' | 'LineString' | 'LinearRing' | 'Polygon' | 'MultiPoint' | 'MultiLineString' | 'MultiPolygon' | 'GeometryCollection' | 'Circle'} Type
 * The geometry type.  One of `'Point'`, `'LineString'`, `'LinearRing'`,
 * `'Polygon'`, `'MultiPoint'`, `'MultiLineString'`, `'MultiPolygon'`,
 * `'GeometryCollection'`, or `'Circle'`.
 */

/**
 * @type {import("../transform.js").Transform}
 */
const tmpTransform = (0,_transform_js__WEBPACK_IMPORTED_MODULE_1__.create)();

/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Base class for vector geometries.
 *
 * To get notified of changes to the geometry, register a listener for the
 * generic `change` event on your geometry instance.
 *
 * @abstract
 * @api
 */
class Geometry extends _Object_js__WEBPACK_IMPORTED_MODULE_2__["default"] {
  constructor() {
    super();

    /**
     * @private
     * @type {import("../extent.js").Extent}
     */
    this.extent_ = (0,_extent_js__WEBPACK_IMPORTED_MODULE_3__.createEmpty)();

    /**
     * @private
     * @type {number}
     */
    this.extentRevision_ = -1;

    /**
     * @protected
     * @type {number}
     */
    this.simplifiedGeometryMaxMinSquaredTolerance = 0;

    /**
     * @protected
     * @type {number}
     */
    this.simplifiedGeometryRevision = 0;

    /**
     * Get a transformed and simplified version of the geometry.
     * @abstract
     * @param {number} revision The geometry revision.
     * @param {number} squaredTolerance Squared tolerance.
     * @param {import("../proj.js").TransformFunction} [transform] Optional transform function.
     * @return {Geometry} Simplified geometry.
     */
    this.simplifyTransformedInternal = (0,_functions_js__WEBPACK_IMPORTED_MODULE_4__.memoizeOne)(function (
      revision,
      squaredTolerance,
      transform
    ) {
      if (!transform) {
        return this.getSimplifiedGeometry(squaredTolerance);
      }
      const clone = this.clone();
      clone.applyTransform(transform);
      return clone.getSimplifiedGeometry(squaredTolerance);
    });
  }

  /**
   * Get a transformed and simplified version of the geometry.
   * @abstract
   * @param {number} squaredTolerance Squared tolerance.
   * @param {import("../proj.js").TransformFunction} [transform] Optional transform function.
   * @return {Geometry} Simplified geometry.
   */
  simplifyTransformed(squaredTolerance, transform) {
    return this.simplifyTransformedInternal(
      this.getRevision(),
      squaredTolerance,
      transform
    );
  }

  /**
   * Make a complete copy of the geometry.
   * @abstract
   * @return {!Geometry} Clone.
   */
  clone() {
    return (0,_util_js__WEBPACK_IMPORTED_MODULE_5__.abstract)();
  }

  /**
   * @abstract
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */
  closestPointXY(x, y, closestPoint, minSquaredDistance) {
    return (0,_util_js__WEBPACK_IMPORTED_MODULE_5__.abstract)();
  }

  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @return {boolean} Contains (x, y).
   */
  containsXY(x, y) {
    const coord = this.getClosestPoint([x, y]);
    return coord[0] === x && coord[1] === y;
  }

  /**
   * Return the closest point of the geometry to the passed point as
   * {@link module:ol/coordinate~Coordinate coordinate}.
   * @param {import("../coordinate.js").Coordinate} point Point.
   * @param {import("../coordinate.js").Coordinate} [closestPoint] Closest point.
   * @return {import("../coordinate.js").Coordinate} Closest point.
   * @api
   */
  getClosestPoint(point, closestPoint) {
    closestPoint = closestPoint ? closestPoint : [NaN, NaN];
    this.closestPointXY(point[0], point[1], closestPoint, Infinity);
    return closestPoint;
  }

  /**
   * Returns true if this geometry includes the specified coordinate. If the
   * coordinate is on the boundary of the geometry, returns false.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @return {boolean} Contains coordinate.
   * @api
   */
  intersectsCoordinate(coordinate) {
    return this.containsXY(coordinate[0], coordinate[1]);
  }

  /**
   * @abstract
   * @param {import("../extent.js").Extent} extent Extent.
   * @protected
   * @return {import("../extent.js").Extent} extent Extent.
   */
  computeExtent(extent) {
    return (0,_util_js__WEBPACK_IMPORTED_MODULE_5__.abstract)();
  }

  /**
   * Get the extent of the geometry.
   * @param {import("../extent.js").Extent} [extent] Extent.
   * @return {import("../extent.js").Extent} extent Extent.
   * @api
   */
  getExtent(extent) {
    if (this.extentRevision_ != this.getRevision()) {
      const extent = this.computeExtent(this.extent_);
      if (isNaN(extent[0]) || isNaN(extent[1])) {
        (0,_extent_js__WEBPACK_IMPORTED_MODULE_3__.createOrUpdateEmpty)(extent);
      }
      this.extentRevision_ = this.getRevision();
    }
    return (0,_extent_js__WEBPACK_IMPORTED_MODULE_3__.returnOrUpdate)(this.extent_, extent);
  }

  /**
   * Rotate the geometry around a given coordinate. This modifies the geometry
   * coordinates in place.
   * @abstract
   * @param {number} angle Rotation angle in radians.
   * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
   * @api
   */
  rotate(angle, anchor) {
    (0,_util_js__WEBPACK_IMPORTED_MODULE_5__.abstract)();
  }

  /**
   * Scale the geometry (with an optional origin).  This modifies the geometry
   * coordinates in place.
   * @abstract
   * @param {number} sx The scaling factor in the x-direction.
   * @param {number} [sy] The scaling factor in the y-direction (defaults to sx).
   * @param {import("../coordinate.js").Coordinate} [anchor] The scale origin (defaults to the center
   *     of the geometry extent).
   * @api
   */
  scale(sx, sy, anchor) {
    (0,_util_js__WEBPACK_IMPORTED_MODULE_5__.abstract)();
  }

  /**
   * Create a simplified version of this geometry.  For linestrings, this uses
   * the [Douglas Peucker](https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm)
   * algorithm.  For polygons, a quantization-based
   * simplification is used to preserve topology.
   * @param {number} tolerance The tolerance distance for simplification.
   * @return {Geometry} A new, simplified version of the original geometry.
   * @api
   */
  simplify(tolerance) {
    return this.getSimplifiedGeometry(tolerance * tolerance);
  }

  /**
   * Create a simplified version of this geometry using the Douglas Peucker
   * algorithm.
   * See https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm.
   * @abstract
   * @param {number} squaredTolerance Squared tolerance.
   * @return {Geometry} Simplified geometry.
   */
  getSimplifiedGeometry(squaredTolerance) {
    return (0,_util_js__WEBPACK_IMPORTED_MODULE_5__.abstract)();
  }

  /**
   * Get the type of this geometry.
   * @abstract
   * @return {Type} Geometry type.
   */
  getType() {
    return (0,_util_js__WEBPACK_IMPORTED_MODULE_5__.abstract)();
  }

  /**
   * Apply a transform function to the coordinates of the geometry.
   * The geometry is modified in place.
   * If you do not want the geometry modified in place, first `clone()` it and
   * then use this function on the clone.
   * @abstract
   * @param {import("../proj.js").TransformFunction} transformFn Transform function.
   * Called with a flat array of geometry coordinates.
   */
  applyTransform(transformFn) {
    (0,_util_js__WEBPACK_IMPORTED_MODULE_5__.abstract)();
  }

  /**
   * Test if the geometry and the passed extent intersect.
   * @abstract
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   */
  intersectsExtent(extent) {
    return (0,_util_js__WEBPACK_IMPORTED_MODULE_5__.abstract)();
  }

  /**
   * Translate the geometry.  This modifies the geometry coordinates in place.  If
   * instead you want a new geometry, first `clone()` this geometry.
   * @abstract
   * @param {number} deltaX Delta X.
   * @param {number} deltaY Delta Y.
   * @api
   */
  translate(deltaX, deltaY) {
    (0,_util_js__WEBPACK_IMPORTED_MODULE_5__.abstract)();
  }

  /**
   * Transform each coordinate of the geometry from one coordinate reference
   * system to another. The geometry is modified in place.
   * For example, a line will be transformed to a line and a circle to a circle.
   * If you do not want the geometry modified in place, first `clone()` it and
   * then use this function on the clone.
   *
   * @param {import("../proj.js").ProjectionLike} source The current projection.  Can be a
   *     string identifier or a {@link module:ol/proj/Projection~Projection} object.
   * @param {import("../proj.js").ProjectionLike} destination The desired projection.  Can be a
   *     string identifier or a {@link module:ol/proj/Projection~Projection} object.
   * @return {Geometry} This geometry.  Note that original geometry is
   *     modified in place.
   * @api
   */
  transform(source, destination) {
    /** @type {import("../proj/Projection.js").default} */
    const sourceProj = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.get)(source);
    const transformFn =
      sourceProj.getUnits() == 'tile-pixels'
        ? function (inCoordinates, outCoordinates, stride) {
            const pixelExtent = sourceProj.getExtent();
            const projectedExtent = sourceProj.getWorldExtent();
            const scale = (0,_extent_js__WEBPACK_IMPORTED_MODULE_3__.getHeight)(projectedExtent) / (0,_extent_js__WEBPACK_IMPORTED_MODULE_3__.getHeight)(pixelExtent);
            (0,_transform_js__WEBPACK_IMPORTED_MODULE_1__.compose)(
              tmpTransform,
              projectedExtent[0],
              projectedExtent[3],
              scale,
              -scale,
              0,
              0,
              0
            );
            (0,_flat_transform_js__WEBPACK_IMPORTED_MODULE_6__.transform2D)(
              inCoordinates,
              0,
              inCoordinates.length,
              stride,
              tmpTransform,
              outCoordinates
            );
            return (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.getTransform)(sourceProj, destination)(
              inCoordinates,
              outCoordinates,
              stride
            );
          }
        : (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.getTransform)(sourceProj, destination);
    this.applyTransform(transformFn);
    return this;
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Geometry);


/***/ }),

/***/ "./node_modules/ol/geom/GeometryCollection.js":
/*!****************************************************!*\
  !*** ./node_modules/ol/geom/GeometryCollection.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../events/EventType.js */ "./node_modules/ol/events/EventType.js");
/* harmony import */ var _Geometry_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Geometry.js */ "./node_modules/ol/geom/Geometry.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../events.js */ "./node_modules/ol/events.js");
/**
 * @module ol/geom/GeometryCollection
 */





/**
 * @classdesc
 * An array of {@link module:ol/geom/Geometry~Geometry} objects.
 *
 * @api
 */
class GeometryCollection extends _Geometry_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {Array<Geometry>} [geometries] Geometries.
   */
  constructor(geometries) {
    super();

    /**
     * @private
     * @type {Array<Geometry>}
     */
    this.geometries_ = geometries ? geometries : null;

    /**
     * @type {Array<import("../events.js").EventsKey>}
     */
    this.changeEventsKeys_ = [];

    this.listenGeometriesChange_();
  }

  /**
   * @private
   */
  unlistenGeometriesChange_() {
    this.changeEventsKeys_.forEach(_events_js__WEBPACK_IMPORTED_MODULE_1__.unlistenByKey);
    this.changeEventsKeys_.length = 0;
  }

  /**
   * @private
   */
  listenGeometriesChange_() {
    if (!this.geometries_) {
      return;
    }
    for (let i = 0, ii = this.geometries_.length; i < ii; ++i) {
      this.changeEventsKeys_.push(
        (0,_events_js__WEBPACK_IMPORTED_MODULE_1__.listen)(this.geometries_[i], _events_EventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].CHANGE, this.changed, this)
      );
    }
  }

  /**
   * Make a complete copy of the geometry.
   * @return {!GeometryCollection} Clone.
   * @api
   */
  clone() {
    const geometryCollection = new GeometryCollection(null);
    geometryCollection.setGeometries(this.geometries_);
    geometryCollection.applyProperties(this);
    return geometryCollection;
  }

  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */
  closestPointXY(x, y, closestPoint, minSquaredDistance) {
    if (minSquaredDistance < (0,_extent_js__WEBPACK_IMPORTED_MODULE_3__.closestSquaredDistanceXY)(this.getExtent(), x, y)) {
      return minSquaredDistance;
    }
    const geometries = this.geometries_;
    for (let i = 0, ii = geometries.length; i < ii; ++i) {
      minSquaredDistance = geometries[i].closestPointXY(
        x,
        y,
        closestPoint,
        minSquaredDistance
      );
    }
    return minSquaredDistance;
  }

  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @return {boolean} Contains (x, y).
   */
  containsXY(x, y) {
    const geometries = this.geometries_;
    for (let i = 0, ii = geometries.length; i < ii; ++i) {
      if (geometries[i].containsXY(x, y)) {
        return true;
      }
    }
    return false;
  }

  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @protected
   * @return {import("../extent.js").Extent} extent Extent.
   */
  computeExtent(extent) {
    (0,_extent_js__WEBPACK_IMPORTED_MODULE_3__.createOrUpdateEmpty)(extent);
    const geometries = this.geometries_;
    for (let i = 0, ii = geometries.length; i < ii; ++i) {
      (0,_extent_js__WEBPACK_IMPORTED_MODULE_3__.extend)(extent, geometries[i].getExtent());
    }
    return extent;
  }

  /**
   * Return the geometries that make up this geometry collection.
   * @return {Array<Geometry>} Geometries.
   * @api
   */
  getGeometries() {
    return cloneGeometries(this.geometries_);
  }

  /**
   * @return {Array<Geometry>} Geometries.
   */
  getGeometriesArray() {
    return this.geometries_;
  }

  /**
   * @return {Array<Geometry>} Geometries.
   */
  getGeometriesArrayRecursive() {
    /** @type {Array<Geometry>} */
    let geometriesArray = [];
    const geometries = this.geometries_;
    for (let i = 0, ii = geometries.length; i < ii; ++i) {
      if (geometries[i].getType() === this.getType()) {
        geometriesArray = geometriesArray.concat(
          /** @type {GeometryCollection} */ (
            geometries[i]
          ).getGeometriesArrayRecursive()
        );
      } else {
        geometriesArray.push(geometries[i]);
      }
    }
    return geometriesArray;
  }

  /**
   * Create a simplified version of this geometry using the Douglas Peucker algorithm.
   * @param {number} squaredTolerance Squared tolerance.
   * @return {GeometryCollection} Simplified GeometryCollection.
   */
  getSimplifiedGeometry(squaredTolerance) {
    if (this.simplifiedGeometryRevision !== this.getRevision()) {
      this.simplifiedGeometryMaxMinSquaredTolerance = 0;
      this.simplifiedGeometryRevision = this.getRevision();
    }
    if (
      squaredTolerance < 0 ||
      (this.simplifiedGeometryMaxMinSquaredTolerance !== 0 &&
        squaredTolerance < this.simplifiedGeometryMaxMinSquaredTolerance)
    ) {
      return this;
    }

    const simplifiedGeometries = [];
    const geometries = this.geometries_;
    let simplified = false;
    for (let i = 0, ii = geometries.length; i < ii; ++i) {
      const geometry = geometries[i];
      const simplifiedGeometry =
        geometry.getSimplifiedGeometry(squaredTolerance);
      simplifiedGeometries.push(simplifiedGeometry);
      if (simplifiedGeometry !== geometry) {
        simplified = true;
      }
    }
    if (simplified) {
      const simplifiedGeometryCollection = new GeometryCollection(null);
      simplifiedGeometryCollection.setGeometriesArray(simplifiedGeometries);
      return simplifiedGeometryCollection;
    }
    this.simplifiedGeometryMaxMinSquaredTolerance = squaredTolerance;
    return this;
  }

  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   */
  getType() {
    return 'GeometryCollection';
  }

  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */
  intersectsExtent(extent) {
    const geometries = this.geometries_;
    for (let i = 0, ii = geometries.length; i < ii; ++i) {
      if (geometries[i].intersectsExtent(extent)) {
        return true;
      }
    }
    return false;
  }

  /**
   * @return {boolean} Is empty.
   */
  isEmpty() {
    return this.geometries_.length === 0;
  }

  /**
   * Rotate the geometry around a given coordinate. This modifies the geometry
   * coordinates in place.
   * @param {number} angle Rotation angle in radians.
   * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
   * @api
   */
  rotate(angle, anchor) {
    const geometries = this.geometries_;
    for (let i = 0, ii = geometries.length; i < ii; ++i) {
      geometries[i].rotate(angle, anchor);
    }
    this.changed();
  }

  /**
   * Scale the geometry (with an optional origin).  This modifies the geometry
   * coordinates in place.
   * @abstract
   * @param {number} sx The scaling factor in the x-direction.
   * @param {number} [sy] The scaling factor in the y-direction (defaults to sx).
   * @param {import("../coordinate.js").Coordinate} [anchor] The scale origin (defaults to the center
   *     of the geometry extent).
   * @api
   */
  scale(sx, sy, anchor) {
    if (!anchor) {
      anchor = (0,_extent_js__WEBPACK_IMPORTED_MODULE_3__.getCenter)(this.getExtent());
    }
    const geometries = this.geometries_;
    for (let i = 0, ii = geometries.length; i < ii; ++i) {
      geometries[i].scale(sx, sy, anchor);
    }
    this.changed();
  }

  /**
   * Set the geometries that make up this geometry collection.
   * @param {Array<Geometry>} geometries Geometries.
   * @api
   */
  setGeometries(geometries) {
    this.setGeometriesArray(cloneGeometries(geometries));
  }

  /**
   * @param {Array<Geometry>} geometries Geometries.
   */
  setGeometriesArray(geometries) {
    this.unlistenGeometriesChange_();
    this.geometries_ = geometries;
    this.listenGeometriesChange_();
    this.changed();
  }

  /**
   * Apply a transform function to the coordinates of the geometry.
   * The geometry is modified in place.
   * If you do not want the geometry modified in place, first `clone()` it and
   * then use this function on the clone.
   * @param {import("../proj.js").TransformFunction} transformFn Transform function.
   * Called with a flat array of geometry coordinates.
   * @api
   */
  applyTransform(transformFn) {
    const geometries = this.geometries_;
    for (let i = 0, ii = geometries.length; i < ii; ++i) {
      geometries[i].applyTransform(transformFn);
    }
    this.changed();
  }

  /**
   * Translate the geometry.  This modifies the geometry coordinates in place.  If
   * instead you want a new geometry, first `clone()` this geometry.
   * @param {number} deltaX Delta X.
   * @param {number} deltaY Delta Y.
   * @api
   */
  translate(deltaX, deltaY) {
    const geometries = this.geometries_;
    for (let i = 0, ii = geometries.length; i < ii; ++i) {
      geometries[i].translate(deltaX, deltaY);
    }
    this.changed();
  }

  /**
   * Clean up.
   */
  disposeInternal() {
    this.unlistenGeometriesChange_();
    super.disposeInternal();
  }
}

/**
 * @param {Array<Geometry>} geometries Geometries.
 * @return {Array<Geometry>} Cloned geometries.
 */
function cloneGeometries(geometries) {
  const clonedGeometries = [];
  for (let i = 0, ii = geometries.length; i < ii; ++i) {
    clonedGeometries.push(geometries[i].clone());
  }
  return clonedGeometries;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (GeometryCollection);


/***/ }),

/***/ "./node_modules/ol/geom/LineString.js":
/*!********************************************!*\
  !*** ./node_modules/ol/geom/LineString.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SimpleGeometry.js */ "./node_modules/ol/geom/SimpleGeometry.js");
/* harmony import */ var _flat_closest_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./flat/closest.js */ "./node_modules/ol/geom/flat/closest.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _flat_deflate_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./flat/deflate.js */ "./node_modules/ol/geom/flat/deflate.js");
/* harmony import */ var _flat_simplify_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./flat/simplify.js */ "./node_modules/ol/geom/flat/simplify.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _flat_segments_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./flat/segments.js */ "./node_modules/ol/geom/flat/segments.js");
/* harmony import */ var _flat_inflate_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./flat/inflate.js */ "./node_modules/ol/geom/flat/inflate.js");
/* harmony import */ var _flat_interpolate_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./flat/interpolate.js */ "./node_modules/ol/geom/flat/interpolate.js");
/* harmony import */ var _flat_intersectsextent_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./flat/intersectsextent.js */ "./node_modules/ol/geom/flat/intersectsextent.js");
/* harmony import */ var _flat_length_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./flat/length.js */ "./node_modules/ol/geom/flat/length.js");
/**
 * @module ol/geom/LineString
 */












/**
 * @classdesc
 * Linestring geometry.
 *
 * @api
 */
class LineString extends _SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {Array<import("../coordinate.js").Coordinate>|Array<number>} coordinates Coordinates.
   *     For internal use, flat coordinates in combination with `layout` are also accepted.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   */
  constructor(coordinates, layout) {
    super();

    /**
     * @private
     * @type {import("../coordinate.js").Coordinate}
     */
    this.flatMidpoint_ = null;

    /**
     * @private
     * @type {number}
     */
    this.flatMidpointRevision_ = -1;

    /**
     * @private
     * @type {number}
     */
    this.maxDelta_ = -1;

    /**
     * @private
     * @type {number}
     */
    this.maxDeltaRevision_ = -1;

    if (layout !== undefined && !Array.isArray(coordinates[0])) {
      this.setFlatCoordinates(
        layout,
        /** @type {Array<number>} */ (coordinates)
      );
    } else {
      this.setCoordinates(
        /** @type {Array<import("../coordinate.js").Coordinate>} */ (
          coordinates
        ),
        layout
      );
    }
  }

  /**
   * Append the passed coordinate to the coordinates of the linestring.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @api
   */
  appendCoordinate(coordinate) {
    if (!this.flatCoordinates) {
      this.flatCoordinates = coordinate.slice();
    } else {
      (0,_array_js__WEBPACK_IMPORTED_MODULE_1__.extend)(this.flatCoordinates, coordinate);
    }
    this.changed();
  }

  /**
   * Make a complete copy of the geometry.
   * @return {!LineString} Clone.
   * @api
   */
  clone() {
    const lineString = new LineString(
      this.flatCoordinates.slice(),
      this.layout
    );
    lineString.applyProperties(this);
    return lineString;
  }

  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */
  closestPointXY(x, y, closestPoint, minSquaredDistance) {
    if (minSquaredDistance < (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.closestSquaredDistanceXY)(this.getExtent(), x, y)) {
      return minSquaredDistance;
    }
    if (this.maxDeltaRevision_ != this.getRevision()) {
      this.maxDelta_ = Math.sqrt(
        (0,_flat_closest_js__WEBPACK_IMPORTED_MODULE_3__.maxSquaredDelta)(
          this.flatCoordinates,
          0,
          this.flatCoordinates.length,
          this.stride,
          0
        )
      );
      this.maxDeltaRevision_ = this.getRevision();
    }
    return (0,_flat_closest_js__WEBPACK_IMPORTED_MODULE_3__.assignClosestPoint)(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      this.maxDelta_,
      false,
      x,
      y,
      closestPoint,
      minSquaredDistance
    );
  }

  /**
   * Iterate over each segment, calling the provided callback.
   * If the callback returns a truthy value the function returns that
   * value immediately. Otherwise the function returns `false`.
   *
   * @param {function(this: S, import("../coordinate.js").Coordinate, import("../coordinate.js").Coordinate): T} callback Function
   *     called for each segment. The function will receive two arguments, the start and end coordinates of the segment.
   * @return {T|boolean} Value.
   * @template T,S
   * @api
   */
  forEachSegment(callback) {
    return (0,_flat_segments_js__WEBPACK_IMPORTED_MODULE_4__.forEach)(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      callback
    );
  }

  /**
   * Returns the coordinate at `m` using linear interpolation, or `null` if no
   * such coordinate exists.
   *
   * `extrapolate` controls extrapolation beyond the range of Ms in the
   * MultiLineString. If `extrapolate` is `true` then Ms less than the first
   * M will return the first coordinate and Ms greater than the last M will
   * return the last coordinate.
   *
   * @param {number} m M.
   * @param {boolean} [extrapolate] Extrapolate. Default is `false`.
   * @return {import("../coordinate.js").Coordinate|null} Coordinate.
   * @api
   */
  getCoordinateAtM(m, extrapolate) {
    if (this.layout != 'XYM' && this.layout != 'XYZM') {
      return null;
    }
    extrapolate = extrapolate !== undefined ? extrapolate : false;
    return (0,_flat_interpolate_js__WEBPACK_IMPORTED_MODULE_5__.lineStringCoordinateAtM)(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      m,
      extrapolate
    );
  }

  /**
   * Return the coordinates of the linestring.
   * @return {Array<import("../coordinate.js").Coordinate>} Coordinates.
   * @api
   */
  getCoordinates() {
    return (0,_flat_inflate_js__WEBPACK_IMPORTED_MODULE_6__.inflateCoordinates)(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride
    );
  }

  /**
   * Return the coordinate at the provided fraction along the linestring.
   * The `fraction` is a number between 0 and 1, where 0 is the start of the
   * linestring and 1 is the end.
   * @param {number} fraction Fraction.
   * @param {import("../coordinate.js").Coordinate} [dest] Optional coordinate whose values will
   *     be modified. If not provided, a new coordinate will be returned.
   * @return {import("../coordinate.js").Coordinate} Coordinate of the interpolated point.
   * @api
   */
  getCoordinateAt(fraction, dest) {
    return (0,_flat_interpolate_js__WEBPACK_IMPORTED_MODULE_5__.interpolatePoint)(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      fraction,
      dest,
      this.stride
    );
  }

  /**
   * Return the length of the linestring on projected plane.
   * @return {number} Length (on projected plane).
   * @api
   */
  getLength() {
    return (0,_flat_length_js__WEBPACK_IMPORTED_MODULE_7__.lineStringLength)(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride
    );
  }

  /**
   * @return {Array<number>} Flat midpoint.
   */
  getFlatMidpoint() {
    if (this.flatMidpointRevision_ != this.getRevision()) {
      this.flatMidpoint_ = this.getCoordinateAt(0.5, this.flatMidpoint_);
      this.flatMidpointRevision_ = this.getRevision();
    }
    return this.flatMidpoint_;
  }

  /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {LineString} Simplified LineString.
   * @protected
   */
  getSimplifiedGeometryInternal(squaredTolerance) {
    const simplifiedFlatCoordinates = [];
    simplifiedFlatCoordinates.length = (0,_flat_simplify_js__WEBPACK_IMPORTED_MODULE_8__.douglasPeucker)(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      squaredTolerance,
      simplifiedFlatCoordinates,
      0
    );
    return new LineString(simplifiedFlatCoordinates, 'XY');
  }

  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   */
  getType() {
    return 'LineString';
  }

  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */
  intersectsExtent(extent) {
    return (0,_flat_intersectsextent_js__WEBPACK_IMPORTED_MODULE_9__.intersectsLineString)(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      extent
    );
  }

  /**
   * Set the coordinates of the linestring.
   * @param {!Array<import("../coordinate.js").Coordinate>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   */
  setCoordinates(coordinates, layout) {
    this.setLayout(layout, coordinates, 1);
    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }
    this.flatCoordinates.length = (0,_flat_deflate_js__WEBPACK_IMPORTED_MODULE_10__.deflateCoordinates)(
      this.flatCoordinates,
      0,
      coordinates,
      this.stride
    );
    this.changed();
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (LineString);


/***/ }),

/***/ "./node_modules/ol/geom/LinearRing.js":
/*!********************************************!*\
  !*** ./node_modules/ol/geom/LinearRing.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SimpleGeometry.js */ "./node_modules/ol/geom/SimpleGeometry.js");
/* harmony import */ var _flat_closest_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./flat/closest.js */ "./node_modules/ol/geom/flat/closest.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _flat_deflate_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./flat/deflate.js */ "./node_modules/ol/geom/flat/deflate.js");
/* harmony import */ var _flat_simplify_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./flat/simplify.js */ "./node_modules/ol/geom/flat/simplify.js");
/* harmony import */ var _flat_inflate_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./flat/inflate.js */ "./node_modules/ol/geom/flat/inflate.js");
/* harmony import */ var _flat_area_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./flat/area.js */ "./node_modules/ol/geom/flat/area.js");
/**
 * @module ol/geom/LinearRing
 */








/**
 * @classdesc
 * Linear ring geometry. Only used as part of polygon; cannot be rendered
 * on its own.
 *
 * @api
 */
class LinearRing extends _SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {Array<import("../coordinate.js").Coordinate>|Array<number>} coordinates Coordinates.
   *     For internal use, flat coordinates in combination with `layout` are also accepted.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   */
  constructor(coordinates, layout) {
    super();

    /**
     * @private
     * @type {number}
     */
    this.maxDelta_ = -1;

    /**
     * @private
     * @type {number}
     */
    this.maxDeltaRevision_ = -1;

    if (layout !== undefined && !Array.isArray(coordinates[0])) {
      this.setFlatCoordinates(
        layout,
        /** @type {Array<number>} */ (coordinates)
      );
    } else {
      this.setCoordinates(
        /** @type {Array<import("../coordinate.js").Coordinate>} */ (
          coordinates
        ),
        layout
      );
    }
  }

  /**
   * Make a complete copy of the geometry.
   * @return {!LinearRing} Clone.
   * @api
   */
  clone() {
    return new LinearRing(this.flatCoordinates.slice(), this.layout);
  }

  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */
  closestPointXY(x, y, closestPoint, minSquaredDistance) {
    if (minSquaredDistance < (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.closestSquaredDistanceXY)(this.getExtent(), x, y)) {
      return minSquaredDistance;
    }
    if (this.maxDeltaRevision_ != this.getRevision()) {
      this.maxDelta_ = Math.sqrt(
        (0,_flat_closest_js__WEBPACK_IMPORTED_MODULE_2__.maxSquaredDelta)(
          this.flatCoordinates,
          0,
          this.flatCoordinates.length,
          this.stride,
          0
        )
      );
      this.maxDeltaRevision_ = this.getRevision();
    }
    return (0,_flat_closest_js__WEBPACK_IMPORTED_MODULE_2__.assignClosestPoint)(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      this.maxDelta_,
      true,
      x,
      y,
      closestPoint,
      minSquaredDistance
    );
  }

  /**
   * Return the area of the linear ring on projected plane.
   * @return {number} Area (on projected plane).
   * @api
   */
  getArea() {
    return (0,_flat_area_js__WEBPACK_IMPORTED_MODULE_3__.linearRing)(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride
    );
  }

  /**
   * Return the coordinates of the linear ring.
   * @return {Array<import("../coordinate.js").Coordinate>} Coordinates.
   * @api
   */
  getCoordinates() {
    return (0,_flat_inflate_js__WEBPACK_IMPORTED_MODULE_4__.inflateCoordinates)(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride
    );
  }

  /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {LinearRing} Simplified LinearRing.
   * @protected
   */
  getSimplifiedGeometryInternal(squaredTolerance) {
    const simplifiedFlatCoordinates = [];
    simplifiedFlatCoordinates.length = (0,_flat_simplify_js__WEBPACK_IMPORTED_MODULE_5__.douglasPeucker)(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      squaredTolerance,
      simplifiedFlatCoordinates,
      0
    );
    return new LinearRing(simplifiedFlatCoordinates, 'XY');
  }

  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   */
  getType() {
    return 'LinearRing';
  }

  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */
  intersectsExtent(extent) {
    return false;
  }

  /**
   * Set the coordinates of the linear ring.
   * @param {!Array<import("../coordinate.js").Coordinate>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   */
  setCoordinates(coordinates, layout) {
    this.setLayout(layout, coordinates, 1);
    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }
    this.flatCoordinates.length = (0,_flat_deflate_js__WEBPACK_IMPORTED_MODULE_6__.deflateCoordinates)(
      this.flatCoordinates,
      0,
      coordinates,
      this.stride
    );
    this.changed();
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (LinearRing);


/***/ }),

/***/ "./node_modules/ol/geom/MultiLineString.js":
/*!*************************************************!*\
  !*** ./node_modules/ol/geom/MultiLineString.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _LineString_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./LineString.js */ "./node_modules/ol/geom/LineString.js");
/* harmony import */ var _SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SimpleGeometry.js */ "./node_modules/ol/geom/SimpleGeometry.js");
/* harmony import */ var _flat_closest_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./flat/closest.js */ "./node_modules/ol/geom/flat/closest.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _flat_deflate_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./flat/deflate.js */ "./node_modules/ol/geom/flat/deflate.js");
/* harmony import */ var _flat_simplify_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./flat/simplify.js */ "./node_modules/ol/geom/flat/simplify.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _flat_inflate_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./flat/inflate.js */ "./node_modules/ol/geom/flat/inflate.js");
/* harmony import */ var _flat_interpolate_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./flat/interpolate.js */ "./node_modules/ol/geom/flat/interpolate.js");
/* harmony import */ var _flat_intersectsextent_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./flat/intersectsextent.js */ "./node_modules/ol/geom/flat/intersectsextent.js");
/**
 * @module ol/geom/MultiLineString
 */











/**
 * @classdesc
 * Multi-linestring geometry.
 *
 * @api
 */
class MultiLineString extends _SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {Array<Array<import("../coordinate.js").Coordinate>|LineString>|Array<number>} coordinates
   *     Coordinates or LineString geometries. (For internal use, flat coordinates in
   *     combination with `layout` and `ends` are also accepted.)
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @param {Array<number>} [ends] Flat coordinate ends for internal use.
   */
  constructor(coordinates, layout, ends) {
    super();

    /**
     * @type {Array<number>}
     * @private
     */
    this.ends_ = [];

    /**
     * @private
     * @type {number}
     */
    this.maxDelta_ = -1;

    /**
     * @private
     * @type {number}
     */
    this.maxDeltaRevision_ = -1;

    if (Array.isArray(coordinates[0])) {
      this.setCoordinates(
        /** @type {Array<Array<import("../coordinate.js").Coordinate>>} */ (
          coordinates
        ),
        layout
      );
    } else if (layout !== undefined && ends) {
      this.setFlatCoordinates(
        layout,
        /** @type {Array<number>} */ (coordinates)
      );
      this.ends_ = ends;
    } else {
      let layout = this.getLayout();
      const lineStrings = /** @type {Array<LineString>} */ (coordinates);
      const flatCoordinates = [];
      const ends = [];
      for (let i = 0, ii = lineStrings.length; i < ii; ++i) {
        const lineString = lineStrings[i];
        if (i === 0) {
          layout = lineString.getLayout();
        }
        (0,_array_js__WEBPACK_IMPORTED_MODULE_1__.extend)(flatCoordinates, lineString.getFlatCoordinates());
        ends.push(flatCoordinates.length);
      }
      this.setFlatCoordinates(layout, flatCoordinates);
      this.ends_ = ends;
    }
  }

  /**
   * Append the passed linestring to the multilinestring.
   * @param {LineString} lineString LineString.
   * @api
   */
  appendLineString(lineString) {
    if (!this.flatCoordinates) {
      this.flatCoordinates = lineString.getFlatCoordinates().slice();
    } else {
      (0,_array_js__WEBPACK_IMPORTED_MODULE_1__.extend)(this.flatCoordinates, lineString.getFlatCoordinates().slice());
    }
    this.ends_.push(this.flatCoordinates.length);
    this.changed();
  }

  /**
   * Make a complete copy of the geometry.
   * @return {!MultiLineString} Clone.
   * @api
   */
  clone() {
    const multiLineString = new MultiLineString(
      this.flatCoordinates.slice(),
      this.layout,
      this.ends_.slice()
    );
    multiLineString.applyProperties(this);
    return multiLineString;
  }

  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */
  closestPointXY(x, y, closestPoint, minSquaredDistance) {
    if (minSquaredDistance < (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.closestSquaredDistanceXY)(this.getExtent(), x, y)) {
      return minSquaredDistance;
    }
    if (this.maxDeltaRevision_ != this.getRevision()) {
      this.maxDelta_ = Math.sqrt(
        (0,_flat_closest_js__WEBPACK_IMPORTED_MODULE_3__.arrayMaxSquaredDelta)(
          this.flatCoordinates,
          0,
          this.ends_,
          this.stride,
          0
        )
      );
      this.maxDeltaRevision_ = this.getRevision();
    }
    return (0,_flat_closest_js__WEBPACK_IMPORTED_MODULE_3__.assignClosestArrayPoint)(
      this.flatCoordinates,
      0,
      this.ends_,
      this.stride,
      this.maxDelta_,
      false,
      x,
      y,
      closestPoint,
      minSquaredDistance
    );
  }

  /**
   * Returns the coordinate at `m` using linear interpolation, or `null` if no
   * such coordinate exists.
   *
   * `extrapolate` controls extrapolation beyond the range of Ms in the
   * MultiLineString. If `extrapolate` is `true` then Ms less than the first
   * M will return the first coordinate and Ms greater than the last M will
   * return the last coordinate.
   *
   * `interpolate` controls interpolation between consecutive LineStrings
   * within the MultiLineString. If `interpolate` is `true` the coordinates
   * will be linearly interpolated between the last coordinate of one LineString
   * and the first coordinate of the next LineString.  If `interpolate` is
   * `false` then the function will return `null` for Ms falling between
   * LineStrings.
   *
   * @param {number} m M.
   * @param {boolean} [extrapolate] Extrapolate. Default is `false`.
   * @param {boolean} [interpolate] Interpolate. Default is `false`.
   * @return {import("../coordinate.js").Coordinate|null} Coordinate.
   * @api
   */
  getCoordinateAtM(m, extrapolate, interpolate) {
    if (
      (this.layout != 'XYM' && this.layout != 'XYZM') ||
      this.flatCoordinates.length === 0
    ) {
      return null;
    }
    extrapolate = extrapolate !== undefined ? extrapolate : false;
    interpolate = interpolate !== undefined ? interpolate : false;
    return (0,_flat_interpolate_js__WEBPACK_IMPORTED_MODULE_4__.lineStringsCoordinateAtM)(
      this.flatCoordinates,
      0,
      this.ends_,
      this.stride,
      m,
      extrapolate,
      interpolate
    );
  }

  /**
   * Return the coordinates of the multilinestring.
   * @return {Array<Array<import("../coordinate.js").Coordinate>>} Coordinates.
   * @api
   */
  getCoordinates() {
    return (0,_flat_inflate_js__WEBPACK_IMPORTED_MODULE_5__.inflateCoordinatesArray)(
      this.flatCoordinates,
      0,
      this.ends_,
      this.stride
    );
  }

  /**
   * @return {Array<number>} Ends.
   */
  getEnds() {
    return this.ends_;
  }

  /**
   * Return the linestring at the specified index.
   * @param {number} index Index.
   * @return {LineString} LineString.
   * @api
   */
  getLineString(index) {
    if (index < 0 || this.ends_.length <= index) {
      return null;
    }
    return new _LineString_js__WEBPACK_IMPORTED_MODULE_6__["default"](
      this.flatCoordinates.slice(
        index === 0 ? 0 : this.ends_[index - 1],
        this.ends_[index]
      ),
      this.layout
    );
  }

  /**
   * Return the linestrings of this multilinestring.
   * @return {Array<LineString>} LineStrings.
   * @api
   */
  getLineStrings() {
    const flatCoordinates = this.flatCoordinates;
    const ends = this.ends_;
    const layout = this.layout;
    /** @type {Array<LineString>} */
    const lineStrings = [];
    let offset = 0;
    for (let i = 0, ii = ends.length; i < ii; ++i) {
      const end = ends[i];
      const lineString = new _LineString_js__WEBPACK_IMPORTED_MODULE_6__["default"](
        flatCoordinates.slice(offset, end),
        layout
      );
      lineStrings.push(lineString);
      offset = end;
    }
    return lineStrings;
  }

  /**
   * @return {Array<number>} Flat midpoints.
   */
  getFlatMidpoints() {
    const midpoints = [];
    const flatCoordinates = this.flatCoordinates;
    let offset = 0;
    const ends = this.ends_;
    const stride = this.stride;
    for (let i = 0, ii = ends.length; i < ii; ++i) {
      const end = ends[i];
      const midpoint = (0,_flat_interpolate_js__WEBPACK_IMPORTED_MODULE_4__.interpolatePoint)(
        flatCoordinates,
        offset,
        end,
        stride,
        0.5
      );
      (0,_array_js__WEBPACK_IMPORTED_MODULE_1__.extend)(midpoints, midpoint);
      offset = end;
    }
    return midpoints;
  }

  /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {MultiLineString} Simplified MultiLineString.
   * @protected
   */
  getSimplifiedGeometryInternal(squaredTolerance) {
    const simplifiedFlatCoordinates = [];
    const simplifiedEnds = [];
    simplifiedFlatCoordinates.length = (0,_flat_simplify_js__WEBPACK_IMPORTED_MODULE_7__.douglasPeuckerArray)(
      this.flatCoordinates,
      0,
      this.ends_,
      this.stride,
      squaredTolerance,
      simplifiedFlatCoordinates,
      0,
      simplifiedEnds
    );
    return new MultiLineString(simplifiedFlatCoordinates, 'XY', simplifiedEnds);
  }

  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   */
  getType() {
    return 'MultiLineString';
  }

  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */
  intersectsExtent(extent) {
    return (0,_flat_intersectsextent_js__WEBPACK_IMPORTED_MODULE_8__.intersectsLineStringArray)(
      this.flatCoordinates,
      0,
      this.ends_,
      this.stride,
      extent
    );
  }

  /**
   * Set the coordinates of the multilinestring.
   * @param {!Array<Array<import("../coordinate.js").Coordinate>>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   */
  setCoordinates(coordinates, layout) {
    this.setLayout(layout, coordinates, 2);
    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }
    const ends = (0,_flat_deflate_js__WEBPACK_IMPORTED_MODULE_9__.deflateCoordinatesArray)(
      this.flatCoordinates,
      0,
      coordinates,
      this.stride,
      this.ends_
    );
    this.flatCoordinates.length = ends.length === 0 ? 0 : ends[ends.length - 1];
    this.changed();
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (MultiLineString);


/***/ }),

/***/ "./node_modules/ol/geom/MultiPoint.js":
/*!********************************************!*\
  !*** ./node_modules/ol/geom/MultiPoint.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Point_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Point.js */ "./node_modules/ol/geom/Point.js");
/* harmony import */ var _SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SimpleGeometry.js */ "./node_modules/ol/geom/SimpleGeometry.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _flat_deflate_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./flat/deflate.js */ "./node_modules/ol/geom/flat/deflate.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _flat_inflate_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./flat/inflate.js */ "./node_modules/ol/geom/flat/inflate.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../math.js */ "./node_modules/ol/math.js");
/**
 * @module ol/geom/MultiPoint
 */








/**
 * @classdesc
 * Multi-point geometry.
 *
 * @api
 */
class MultiPoint extends _SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {Array<import("../coordinate.js").Coordinate>|Array<number>} coordinates Coordinates.
   *     For internal use, flat coordinates in combination with `layout` are also accepted.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   */
  constructor(coordinates, layout) {
    super();
    if (layout && !Array.isArray(coordinates[0])) {
      this.setFlatCoordinates(
        layout,
        /** @type {Array<number>} */ (coordinates)
      );
    } else {
      this.setCoordinates(
        /** @type {Array<import("../coordinate.js").Coordinate>} */ (
          coordinates
        ),
        layout
      );
    }
  }

  /**
   * Append the passed point to this multipoint.
   * @param {Point} point Point.
   * @api
   */
  appendPoint(point) {
    if (!this.flatCoordinates) {
      this.flatCoordinates = point.getFlatCoordinates().slice();
    } else {
      (0,_array_js__WEBPACK_IMPORTED_MODULE_1__.extend)(this.flatCoordinates, point.getFlatCoordinates());
    }
    this.changed();
  }

  /**
   * Make a complete copy of the geometry.
   * @return {!MultiPoint} Clone.
   * @api
   */
  clone() {
    const multiPoint = new MultiPoint(
      this.flatCoordinates.slice(),
      this.layout
    );
    multiPoint.applyProperties(this);
    return multiPoint;
  }

  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */
  closestPointXY(x, y, closestPoint, minSquaredDistance) {
    if (minSquaredDistance < (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.closestSquaredDistanceXY)(this.getExtent(), x, y)) {
      return minSquaredDistance;
    }
    const flatCoordinates = this.flatCoordinates;
    const stride = this.stride;
    for (let i = 0, ii = flatCoordinates.length; i < ii; i += stride) {
      const squaredDistance = (0,_math_js__WEBPACK_IMPORTED_MODULE_3__.squaredDistance)(
        x,
        y,
        flatCoordinates[i],
        flatCoordinates[i + 1]
      );
      if (squaredDistance < minSquaredDistance) {
        minSquaredDistance = squaredDistance;
        for (let j = 0; j < stride; ++j) {
          closestPoint[j] = flatCoordinates[i + j];
        }
        closestPoint.length = stride;
      }
    }
    return minSquaredDistance;
  }

  /**
   * Return the coordinates of the multipoint.
   * @return {Array<import("../coordinate.js").Coordinate>} Coordinates.
   * @api
   */
  getCoordinates() {
    return (0,_flat_inflate_js__WEBPACK_IMPORTED_MODULE_4__.inflateCoordinates)(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride
    );
  }

  /**
   * Return the point at the specified index.
   * @param {number} index Index.
   * @return {Point} Point.
   * @api
   */
  getPoint(index) {
    const n = !this.flatCoordinates
      ? 0
      : this.flatCoordinates.length / this.stride;
    if (index < 0 || n <= index) {
      return null;
    }
    return new _Point_js__WEBPACK_IMPORTED_MODULE_5__["default"](
      this.flatCoordinates.slice(
        index * this.stride,
        (index + 1) * this.stride
      ),
      this.layout
    );
  }

  /**
   * Return the points of this multipoint.
   * @return {Array<Point>} Points.
   * @api
   */
  getPoints() {
    const flatCoordinates = this.flatCoordinates;
    const layout = this.layout;
    const stride = this.stride;
    /** @type {Array<Point>} */
    const points = [];
    for (let i = 0, ii = flatCoordinates.length; i < ii; i += stride) {
      const point = new _Point_js__WEBPACK_IMPORTED_MODULE_5__["default"](flatCoordinates.slice(i, i + stride), layout);
      points.push(point);
    }
    return points;
  }

  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   */
  getType() {
    return 'MultiPoint';
  }

  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */
  intersectsExtent(extent) {
    const flatCoordinates = this.flatCoordinates;
    const stride = this.stride;
    for (let i = 0, ii = flatCoordinates.length; i < ii; i += stride) {
      const x = flatCoordinates[i];
      const y = flatCoordinates[i + 1];
      if ((0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.containsXY)(extent, x, y)) {
        return true;
      }
    }
    return false;
  }

  /**
   * Set the coordinates of the multipoint.
   * @param {!Array<import("../coordinate.js").Coordinate>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   */
  setCoordinates(coordinates, layout) {
    this.setLayout(layout, coordinates, 1);
    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }
    this.flatCoordinates.length = (0,_flat_deflate_js__WEBPACK_IMPORTED_MODULE_6__.deflateCoordinates)(
      this.flatCoordinates,
      0,
      coordinates,
      this.stride
    );
    this.changed();
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (MultiPoint);


/***/ }),

/***/ "./node_modules/ol/geom/MultiPolygon.js":
/*!**********************************************!*\
  !*** ./node_modules/ol/geom/MultiPolygon.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _MultiPoint_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./MultiPoint.js */ "./node_modules/ol/geom/MultiPoint.js");
/* harmony import */ var _Polygon_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./Polygon.js */ "./node_modules/ol/geom/Polygon.js");
/* harmony import */ var _SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SimpleGeometry.js */ "./node_modules/ol/geom/SimpleGeometry.js");
/* harmony import */ var _flat_closest_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./flat/closest.js */ "./node_modules/ol/geom/flat/closest.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _flat_deflate_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./flat/deflate.js */ "./node_modules/ol/geom/flat/deflate.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _flat_interiorpoint_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./flat/interiorpoint.js */ "./node_modules/ol/geom/flat/interiorpoint.js");
/* harmony import */ var _flat_inflate_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./flat/inflate.js */ "./node_modules/ol/geom/flat/inflate.js");
/* harmony import */ var _flat_intersectsextent_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./flat/intersectsextent.js */ "./node_modules/ol/geom/flat/intersectsextent.js");
/* harmony import */ var _flat_orient_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./flat/orient.js */ "./node_modules/ol/geom/flat/orient.js");
/* harmony import */ var _flat_area_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./flat/area.js */ "./node_modules/ol/geom/flat/area.js");
/* harmony import */ var _flat_center_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./flat/center.js */ "./node_modules/ol/geom/flat/center.js");
/* harmony import */ var _flat_contains_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./flat/contains.js */ "./node_modules/ol/geom/flat/contains.js");
/* harmony import */ var _flat_simplify_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./flat/simplify.js */ "./node_modules/ol/geom/flat/simplify.js");
/**
 * @module ol/geom/MultiPolygon
 */
















/**
 * @classdesc
 * Multi-polygon geometry.
 *
 * @api
 */
class MultiPolygon extends _SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {Array<Array<Array<import("../coordinate.js").Coordinate>>|Polygon>|Array<number>} coordinates Coordinates.
   *     For internal use, flat coordinates in combination with `layout` and `endss` are also accepted.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @param {Array<Array<number>>} [endss] Array of ends for internal use with flat coordinates.
   */
  constructor(coordinates, layout, endss) {
    super();

    /**
     * @type {Array<Array<number>>}
     * @private
     */
    this.endss_ = [];

    /**
     * @private
     * @type {number}
     */
    this.flatInteriorPointsRevision_ = -1;

    /**
     * @private
     * @type {Array<number>}
     */
    this.flatInteriorPoints_ = null;

    /**
     * @private
     * @type {number}
     */
    this.maxDelta_ = -1;

    /**
     * @private
     * @type {number}
     */
    this.maxDeltaRevision_ = -1;

    /**
     * @private
     * @type {number}
     */
    this.orientedRevision_ = -1;

    /**
     * @private
     * @type {Array<number>}
     */
    this.orientedFlatCoordinates_ = null;

    if (!endss && !Array.isArray(coordinates[0])) {
      let thisLayout = this.getLayout();
      const polygons = /** @type {Array<Polygon>} */ (coordinates);
      const flatCoordinates = [];
      const thisEndss = [];
      for (let i = 0, ii = polygons.length; i < ii; ++i) {
        const polygon = polygons[i];
        if (i === 0) {
          thisLayout = polygon.getLayout();
        }
        const offset = flatCoordinates.length;
        const ends = polygon.getEnds();
        for (let j = 0, jj = ends.length; j < jj; ++j) {
          ends[j] += offset;
        }
        (0,_array_js__WEBPACK_IMPORTED_MODULE_1__.extend)(flatCoordinates, polygon.getFlatCoordinates());
        thisEndss.push(ends);
      }
      layout = thisLayout;
      coordinates = flatCoordinates;
      endss = thisEndss;
    }
    if (layout !== undefined && endss) {
      this.setFlatCoordinates(
        layout,
        /** @type {Array<number>} */ (coordinates)
      );
      this.endss_ = endss;
    } else {
      this.setCoordinates(
        /** @type {Array<Array<Array<import("../coordinate.js").Coordinate>>>} */ (
          coordinates
        ),
        layout
      );
    }
  }

  /**
   * Append the passed polygon to this multipolygon.
   * @param {Polygon} polygon Polygon.
   * @api
   */
  appendPolygon(polygon) {
    /** @type {Array<number>} */
    let ends;
    if (!this.flatCoordinates) {
      this.flatCoordinates = polygon.getFlatCoordinates().slice();
      ends = polygon.getEnds().slice();
      this.endss_.push();
    } else {
      const offset = this.flatCoordinates.length;
      (0,_array_js__WEBPACK_IMPORTED_MODULE_1__.extend)(this.flatCoordinates, polygon.getFlatCoordinates());
      ends = polygon.getEnds().slice();
      for (let i = 0, ii = ends.length; i < ii; ++i) {
        ends[i] += offset;
      }
    }
    this.endss_.push(ends);
    this.changed();
  }

  /**
   * Make a complete copy of the geometry.
   * @return {!MultiPolygon} Clone.
   * @api
   */
  clone() {
    const len = this.endss_.length;
    const newEndss = new Array(len);
    for (let i = 0; i < len; ++i) {
      newEndss[i] = this.endss_[i].slice();
    }

    const multiPolygon = new MultiPolygon(
      this.flatCoordinates.slice(),
      this.layout,
      newEndss
    );
    multiPolygon.applyProperties(this);

    return multiPolygon;
  }

  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */
  closestPointXY(x, y, closestPoint, minSquaredDistance) {
    if (minSquaredDistance < (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.closestSquaredDistanceXY)(this.getExtent(), x, y)) {
      return minSquaredDistance;
    }
    if (this.maxDeltaRevision_ != this.getRevision()) {
      this.maxDelta_ = Math.sqrt(
        (0,_flat_closest_js__WEBPACK_IMPORTED_MODULE_3__.multiArrayMaxSquaredDelta)(
          this.flatCoordinates,
          0,
          this.endss_,
          this.stride,
          0
        )
      );
      this.maxDeltaRevision_ = this.getRevision();
    }
    return (0,_flat_closest_js__WEBPACK_IMPORTED_MODULE_3__.assignClosestMultiArrayPoint)(
      this.getOrientedFlatCoordinates(),
      0,
      this.endss_,
      this.stride,
      this.maxDelta_,
      true,
      x,
      y,
      closestPoint,
      minSquaredDistance
    );
  }

  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @return {boolean} Contains (x, y).
   */
  containsXY(x, y) {
    return (0,_flat_contains_js__WEBPACK_IMPORTED_MODULE_4__.linearRingssContainsXY)(
      this.getOrientedFlatCoordinates(),
      0,
      this.endss_,
      this.stride,
      x,
      y
    );
  }

  /**
   * Return the area of the multipolygon on projected plane.
   * @return {number} Area (on projected plane).
   * @api
   */
  getArea() {
    return (0,_flat_area_js__WEBPACK_IMPORTED_MODULE_5__.linearRingss)(
      this.getOrientedFlatCoordinates(),
      0,
      this.endss_,
      this.stride
    );
  }

  /**
   * Get the coordinate array for this geometry.  This array has the structure
   * of a GeoJSON coordinate array for multi-polygons.
   *
   * @param {boolean} [right] Orient coordinates according to the right-hand
   *     rule (counter-clockwise for exterior and clockwise for interior rings).
   *     If `false`, coordinates will be oriented according to the left-hand rule
   *     (clockwise for exterior and counter-clockwise for interior rings).
   *     By default, coordinate orientation will depend on how the geometry was
   *     constructed.
   * @return {Array<Array<Array<import("../coordinate.js").Coordinate>>>} Coordinates.
   * @api
   */
  getCoordinates(right) {
    let flatCoordinates;
    if (right !== undefined) {
      flatCoordinates = this.getOrientedFlatCoordinates().slice();
      (0,_flat_orient_js__WEBPACK_IMPORTED_MODULE_6__.orientLinearRingsArray)(
        flatCoordinates,
        0,
        this.endss_,
        this.stride,
        right
      );
    } else {
      flatCoordinates = this.flatCoordinates;
    }

    return (0,_flat_inflate_js__WEBPACK_IMPORTED_MODULE_7__.inflateMultiCoordinatesArray)(
      flatCoordinates,
      0,
      this.endss_,
      this.stride
    );
  }

  /**
   * @return {Array<Array<number>>} Endss.
   */
  getEndss() {
    return this.endss_;
  }

  /**
   * @return {Array<number>} Flat interior points.
   */
  getFlatInteriorPoints() {
    if (this.flatInteriorPointsRevision_ != this.getRevision()) {
      const flatCenters = (0,_flat_center_js__WEBPACK_IMPORTED_MODULE_8__.linearRingss)(
        this.flatCoordinates,
        0,
        this.endss_,
        this.stride
      );
      this.flatInteriorPoints_ = (0,_flat_interiorpoint_js__WEBPACK_IMPORTED_MODULE_9__.getInteriorPointsOfMultiArray)(
        this.getOrientedFlatCoordinates(),
        0,
        this.endss_,
        this.stride,
        flatCenters
      );
      this.flatInteriorPointsRevision_ = this.getRevision();
    }
    return this.flatInteriorPoints_;
  }

  /**
   * Return the interior points as {@link module:ol/geom/MultiPoint~MultiPoint multipoint}.
   * @return {MultiPoint} Interior points as XYM coordinates, where M is
   * the length of the horizontal intersection that the point belongs to.
   * @api
   */
  getInteriorPoints() {
    return new _MultiPoint_js__WEBPACK_IMPORTED_MODULE_10__["default"](this.getFlatInteriorPoints().slice(), 'XYM');
  }

  /**
   * @return {Array<number>} Oriented flat coordinates.
   */
  getOrientedFlatCoordinates() {
    if (this.orientedRevision_ != this.getRevision()) {
      const flatCoordinates = this.flatCoordinates;
      if (
        (0,_flat_orient_js__WEBPACK_IMPORTED_MODULE_6__.linearRingssAreOriented)(flatCoordinates, 0, this.endss_, this.stride)
      ) {
        this.orientedFlatCoordinates_ = flatCoordinates;
      } else {
        this.orientedFlatCoordinates_ = flatCoordinates.slice();
        this.orientedFlatCoordinates_.length = (0,_flat_orient_js__WEBPACK_IMPORTED_MODULE_6__.orientLinearRingsArray)(
          this.orientedFlatCoordinates_,
          0,
          this.endss_,
          this.stride
        );
      }
      this.orientedRevision_ = this.getRevision();
    }
    return this.orientedFlatCoordinates_;
  }

  /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {MultiPolygon} Simplified MultiPolygon.
   * @protected
   */
  getSimplifiedGeometryInternal(squaredTolerance) {
    const simplifiedFlatCoordinates = [];
    const simplifiedEndss = [];
    simplifiedFlatCoordinates.length = (0,_flat_simplify_js__WEBPACK_IMPORTED_MODULE_11__.quantizeMultiArray)(
      this.flatCoordinates,
      0,
      this.endss_,
      this.stride,
      Math.sqrt(squaredTolerance),
      simplifiedFlatCoordinates,
      0,
      simplifiedEndss
    );
    return new MultiPolygon(simplifiedFlatCoordinates, 'XY', simplifiedEndss);
  }

  /**
   * Return the polygon at the specified index.
   * @param {number} index Index.
   * @return {Polygon} Polygon.
   * @api
   */
  getPolygon(index) {
    if (index < 0 || this.endss_.length <= index) {
      return null;
    }
    let offset;
    if (index === 0) {
      offset = 0;
    } else {
      const prevEnds = this.endss_[index - 1];
      offset = prevEnds[prevEnds.length - 1];
    }
    const ends = this.endss_[index].slice();
    const end = ends[ends.length - 1];
    if (offset !== 0) {
      for (let i = 0, ii = ends.length; i < ii; ++i) {
        ends[i] -= offset;
      }
    }
    return new _Polygon_js__WEBPACK_IMPORTED_MODULE_12__["default"](
      this.flatCoordinates.slice(offset, end),
      this.layout,
      ends
    );
  }

  /**
   * Return the polygons of this multipolygon.
   * @return {Array<Polygon>} Polygons.
   * @api
   */
  getPolygons() {
    const layout = this.layout;
    const flatCoordinates = this.flatCoordinates;
    const endss = this.endss_;
    const polygons = [];
    let offset = 0;
    for (let i = 0, ii = endss.length; i < ii; ++i) {
      const ends = endss[i].slice();
      const end = ends[ends.length - 1];
      if (offset !== 0) {
        for (let j = 0, jj = ends.length; j < jj; ++j) {
          ends[j] -= offset;
        }
      }
      const polygon = new _Polygon_js__WEBPACK_IMPORTED_MODULE_12__["default"](
        flatCoordinates.slice(offset, end),
        layout,
        ends
      );
      polygons.push(polygon);
      offset = end;
    }
    return polygons;
  }

  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   */
  getType() {
    return 'MultiPolygon';
  }

  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */
  intersectsExtent(extent) {
    return (0,_flat_intersectsextent_js__WEBPACK_IMPORTED_MODULE_13__.intersectsLinearRingMultiArray)(
      this.getOrientedFlatCoordinates(),
      0,
      this.endss_,
      this.stride,
      extent
    );
  }

  /**
   * Set the coordinates of the multipolygon.
   * @param {!Array<Array<Array<import("../coordinate.js").Coordinate>>>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   */
  setCoordinates(coordinates, layout) {
    this.setLayout(layout, coordinates, 3);
    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }
    const endss = (0,_flat_deflate_js__WEBPACK_IMPORTED_MODULE_14__.deflateMultiCoordinatesArray)(
      this.flatCoordinates,
      0,
      coordinates,
      this.stride,
      this.endss_
    );
    if (endss.length === 0) {
      this.flatCoordinates.length = 0;
    } else {
      const lastEnds = endss[endss.length - 1];
      this.flatCoordinates.length =
        lastEnds.length === 0 ? 0 : lastEnds[lastEnds.length - 1];
    }
    this.changed();
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (MultiPolygon);


/***/ }),

/***/ "./node_modules/ol/geom/Point.js":
/*!***************************************!*\
  !*** ./node_modules/ol/geom/Point.js ***!
  \***************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SimpleGeometry.js */ "./node_modules/ol/geom/SimpleGeometry.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _flat_deflate_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./flat/deflate.js */ "./node_modules/ol/geom/flat/deflate.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math.js */ "./node_modules/ol/math.js");
/**
 * @module ol/geom/Point
 */





/**
 * @classdesc
 * Point geometry.
 *
 * @api
 */
class Point extends _SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {import("../coordinate.js").Coordinate} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   */
  constructor(coordinates, layout) {
    super();
    this.setCoordinates(coordinates, layout);
  }

  /**
   * Make a complete copy of the geometry.
   * @return {!Point} Clone.
   * @api
   */
  clone() {
    const point = new Point(this.flatCoordinates.slice(), this.layout);
    point.applyProperties(this);
    return point;
  }

  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */
  closestPointXY(x, y, closestPoint, minSquaredDistance) {
    const flatCoordinates = this.flatCoordinates;
    const squaredDistance = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.squaredDistance)(
      x,
      y,
      flatCoordinates[0],
      flatCoordinates[1]
    );
    if (squaredDistance < minSquaredDistance) {
      const stride = this.stride;
      for (let i = 0; i < stride; ++i) {
        closestPoint[i] = flatCoordinates[i];
      }
      closestPoint.length = stride;
      return squaredDistance;
    }
    return minSquaredDistance;
  }

  /**
   * Return the coordinate of the point.
   * @return {import("../coordinate.js").Coordinate} Coordinates.
   * @api
   */
  getCoordinates() {
    return !this.flatCoordinates ? [] : this.flatCoordinates.slice();
  }

  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @protected
   * @return {import("../extent.js").Extent} extent Extent.
   */
  computeExtent(extent) {
    return (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.createOrUpdateFromCoordinate)(this.flatCoordinates, extent);
  }

  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   */
  getType() {
    return 'Point';
  }

  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */
  intersectsExtent(extent) {
    return (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.containsXY)(extent, this.flatCoordinates[0], this.flatCoordinates[1]);
  }

  /**
   * @param {!Array<*>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   */
  setCoordinates(coordinates, layout) {
    this.setLayout(layout, coordinates, 0);
    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }
    this.flatCoordinates.length = (0,_flat_deflate_js__WEBPACK_IMPORTED_MODULE_3__.deflateCoordinate)(
      this.flatCoordinates,
      0,
      coordinates,
      this.stride
    );
    this.changed();
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Point);


/***/ }),

/***/ "./node_modules/ol/geom/Polygon.js":
/*!*****************************************!*\
  !*** ./node_modules/ol/geom/Polygon.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   circular: () => (/* binding */ circular),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   fromCircle: () => (/* binding */ fromCircle),
/* harmony export */   fromExtent: () => (/* binding */ fromExtent),
/* harmony export */   makeRegular: () => (/* binding */ makeRegular)
/* harmony export */ });
/* harmony import */ var _LinearRing_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./LinearRing.js */ "./node_modules/ol/geom/LinearRing.js");
/* harmony import */ var _Point_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./Point.js */ "./node_modules/ol/geom/Point.js");
/* harmony import */ var _SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SimpleGeometry.js */ "./node_modules/ol/geom/SimpleGeometry.js");
/* harmony import */ var _flat_closest_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./flat/closest.js */ "./node_modules/ol/geom/flat/closest.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _flat_deflate_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./flat/deflate.js */ "./node_modules/ol/geom/flat/deflate.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _flat_interiorpoint_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./flat/interiorpoint.js */ "./node_modules/ol/geom/flat/interiorpoint.js");
/* harmony import */ var _flat_inflate_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./flat/inflate.js */ "./node_modules/ol/geom/flat/inflate.js");
/* harmony import */ var _flat_intersectsextent_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./flat/intersectsextent.js */ "./node_modules/ol/geom/flat/intersectsextent.js");
/* harmony import */ var _flat_orient_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./flat/orient.js */ "./node_modules/ol/geom/flat/orient.js");
/* harmony import */ var _flat_area_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./flat/area.js */ "./node_modules/ol/geom/flat/area.js");
/* harmony import */ var _flat_contains_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./flat/contains.js */ "./node_modules/ol/geom/flat/contains.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../math.js */ "./node_modules/ol/math.js");
/* harmony import */ var _flat_simplify_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./flat/simplify.js */ "./node_modules/ol/geom/flat/simplify.js");
/* harmony import */ var _sphere_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../sphere.js */ "./node_modules/ol/sphere.js");
/**
 * @module ol/geom/Polygon
 */

















/**
 * @classdesc
 * Polygon geometry.
 *
 * @api
 */
class Polygon extends _SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {!Array<Array<import("../coordinate.js").Coordinate>>|!Array<number>} coordinates
   *     Array of linear rings that define the polygon. The first linear ring of the
   *     array defines the outer-boundary or surface of the polygon. Each subsequent
   *     linear ring defines a hole in the surface of the polygon. A linear ring is
   *     an array of vertices' coordinates where the first coordinate and the last are
   *     equivalent. (For internal use, flat coordinates in combination with
   *     `layout` and `ends` are also accepted.)
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @param {Array<number>} [ends] Ends (for internal use with flat coordinates).
   */
  constructor(coordinates, layout, ends) {
    super();

    /**
     * @type {Array<number>}
     * @private
     */
    this.ends_ = [];

    /**
     * @private
     * @type {number}
     */
    this.flatInteriorPointRevision_ = -1;

    /**
     * @private
     * @type {import("../coordinate.js").Coordinate}
     */
    this.flatInteriorPoint_ = null;

    /**
     * @private
     * @type {number}
     */
    this.maxDelta_ = -1;

    /**
     * @private
     * @type {number}
     */
    this.maxDeltaRevision_ = -1;

    /**
     * @private
     * @type {number}
     */
    this.orientedRevision_ = -1;

    /**
     * @private
     * @type {Array<number>}
     */
    this.orientedFlatCoordinates_ = null;

    if (layout !== undefined && ends) {
      this.setFlatCoordinates(
        layout,
        /** @type {Array<number>} */ (coordinates)
      );
      this.ends_ = ends;
    } else {
      this.setCoordinates(
        /** @type {Array<Array<import("../coordinate.js").Coordinate>>} */ (
          coordinates
        ),
        layout
      );
    }
  }

  /**
   * Append the passed linear ring to this polygon.
   * @param {LinearRing} linearRing Linear ring.
   * @api
   */
  appendLinearRing(linearRing) {
    if (!this.flatCoordinates) {
      this.flatCoordinates = linearRing.getFlatCoordinates().slice();
    } else {
      (0,_array_js__WEBPACK_IMPORTED_MODULE_1__.extend)(this.flatCoordinates, linearRing.getFlatCoordinates());
    }
    this.ends_.push(this.flatCoordinates.length);
    this.changed();
  }

  /**
   * Make a complete copy of the geometry.
   * @return {!Polygon} Clone.
   * @api
   */
  clone() {
    const polygon = new Polygon(
      this.flatCoordinates.slice(),
      this.layout,
      this.ends_.slice()
    );
    polygon.applyProperties(this);
    return polygon;
  }

  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */
  closestPointXY(x, y, closestPoint, minSquaredDistance) {
    if (minSquaredDistance < (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.closestSquaredDistanceXY)(this.getExtent(), x, y)) {
      return minSquaredDistance;
    }
    if (this.maxDeltaRevision_ != this.getRevision()) {
      this.maxDelta_ = Math.sqrt(
        (0,_flat_closest_js__WEBPACK_IMPORTED_MODULE_3__.arrayMaxSquaredDelta)(
          this.flatCoordinates,
          0,
          this.ends_,
          this.stride,
          0
        )
      );
      this.maxDeltaRevision_ = this.getRevision();
    }
    return (0,_flat_closest_js__WEBPACK_IMPORTED_MODULE_3__.assignClosestArrayPoint)(
      this.flatCoordinates,
      0,
      this.ends_,
      this.stride,
      this.maxDelta_,
      true,
      x,
      y,
      closestPoint,
      minSquaredDistance
    );
  }

  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @return {boolean} Contains (x, y).
   */
  containsXY(x, y) {
    return (0,_flat_contains_js__WEBPACK_IMPORTED_MODULE_4__.linearRingsContainsXY)(
      this.getOrientedFlatCoordinates(),
      0,
      this.ends_,
      this.stride,
      x,
      y
    );
  }

  /**
   * Return the area of the polygon on projected plane.
   * @return {number} Area (on projected plane).
   * @api
   */
  getArea() {
    return (0,_flat_area_js__WEBPACK_IMPORTED_MODULE_5__.linearRings)(
      this.getOrientedFlatCoordinates(),
      0,
      this.ends_,
      this.stride
    );
  }

  /**
   * Get the coordinate array for this geometry.  This array has the structure
   * of a GeoJSON coordinate array for polygons.
   *
   * @param {boolean} [right] Orient coordinates according to the right-hand
   *     rule (counter-clockwise for exterior and clockwise for interior rings).
   *     If `false`, coordinates will be oriented according to the left-hand rule
   *     (clockwise for exterior and counter-clockwise for interior rings).
   *     By default, coordinate orientation will depend on how the geometry was
   *     constructed.
   * @return {Array<Array<import("../coordinate.js").Coordinate>>} Coordinates.
   * @api
   */
  getCoordinates(right) {
    let flatCoordinates;
    if (right !== undefined) {
      flatCoordinates = this.getOrientedFlatCoordinates().slice();
      (0,_flat_orient_js__WEBPACK_IMPORTED_MODULE_6__.orientLinearRings)(flatCoordinates, 0, this.ends_, this.stride, right);
    } else {
      flatCoordinates = this.flatCoordinates;
    }

    return (0,_flat_inflate_js__WEBPACK_IMPORTED_MODULE_7__.inflateCoordinatesArray)(flatCoordinates, 0, this.ends_, this.stride);
  }

  /**
   * @return {Array<number>} Ends.
   */
  getEnds() {
    return this.ends_;
  }

  /**
   * @return {Array<number>} Interior point.
   */
  getFlatInteriorPoint() {
    if (this.flatInteriorPointRevision_ != this.getRevision()) {
      const flatCenter = (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.getCenter)(this.getExtent());
      this.flatInteriorPoint_ = (0,_flat_interiorpoint_js__WEBPACK_IMPORTED_MODULE_8__.getInteriorPointOfArray)(
        this.getOrientedFlatCoordinates(),
        0,
        this.ends_,
        this.stride,
        flatCenter,
        0
      );
      this.flatInteriorPointRevision_ = this.getRevision();
    }
    return this.flatInteriorPoint_;
  }

  /**
   * Return an interior point of the polygon.
   * @return {Point} Interior point as XYM coordinate, where M is the
   * length of the horizontal intersection that the point belongs to.
   * @api
   */
  getInteriorPoint() {
    return new _Point_js__WEBPACK_IMPORTED_MODULE_9__["default"](this.getFlatInteriorPoint(), 'XYM');
  }

  /**
   * Return the number of rings of the polygon,  this includes the exterior
   * ring and any interior rings.
   *
   * @return {number} Number of rings.
   * @api
   */
  getLinearRingCount() {
    return this.ends_.length;
  }

  /**
   * Return the Nth linear ring of the polygon geometry. Return `null` if the
   * given index is out of range.
   * The exterior linear ring is available at index `0` and the interior rings
   * at index `1` and beyond.
   *
   * @param {number} index Index.
   * @return {LinearRing|null} Linear ring.
   * @api
   */
  getLinearRing(index) {
    if (index < 0 || this.ends_.length <= index) {
      return null;
    }
    return new _LinearRing_js__WEBPACK_IMPORTED_MODULE_10__["default"](
      this.flatCoordinates.slice(
        index === 0 ? 0 : this.ends_[index - 1],
        this.ends_[index]
      ),
      this.layout
    );
  }

  /**
   * Return the linear rings of the polygon.
   * @return {Array<LinearRing>} Linear rings.
   * @api
   */
  getLinearRings() {
    const layout = this.layout;
    const flatCoordinates = this.flatCoordinates;
    const ends = this.ends_;
    const linearRings = [];
    let offset = 0;
    for (let i = 0, ii = ends.length; i < ii; ++i) {
      const end = ends[i];
      const linearRing = new _LinearRing_js__WEBPACK_IMPORTED_MODULE_10__["default"](
        flatCoordinates.slice(offset, end),
        layout
      );
      linearRings.push(linearRing);
      offset = end;
    }
    return linearRings;
  }

  /**
   * @return {Array<number>} Oriented flat coordinates.
   */
  getOrientedFlatCoordinates() {
    if (this.orientedRevision_ != this.getRevision()) {
      const flatCoordinates = this.flatCoordinates;
      if ((0,_flat_orient_js__WEBPACK_IMPORTED_MODULE_6__.linearRingsAreOriented)(flatCoordinates, 0, this.ends_, this.stride)) {
        this.orientedFlatCoordinates_ = flatCoordinates;
      } else {
        this.orientedFlatCoordinates_ = flatCoordinates.slice();
        this.orientedFlatCoordinates_.length = (0,_flat_orient_js__WEBPACK_IMPORTED_MODULE_6__.orientLinearRings)(
          this.orientedFlatCoordinates_,
          0,
          this.ends_,
          this.stride
        );
      }
      this.orientedRevision_ = this.getRevision();
    }
    return this.orientedFlatCoordinates_;
  }

  /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {Polygon} Simplified Polygon.
   * @protected
   */
  getSimplifiedGeometryInternal(squaredTolerance) {
    const simplifiedFlatCoordinates = [];
    const simplifiedEnds = [];
    simplifiedFlatCoordinates.length = (0,_flat_simplify_js__WEBPACK_IMPORTED_MODULE_11__.quantizeArray)(
      this.flatCoordinates,
      0,
      this.ends_,
      this.stride,
      Math.sqrt(squaredTolerance),
      simplifiedFlatCoordinates,
      0,
      simplifiedEnds
    );
    return new Polygon(simplifiedFlatCoordinates, 'XY', simplifiedEnds);
  }

  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   */
  getType() {
    return 'Polygon';
  }

  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */
  intersectsExtent(extent) {
    return (0,_flat_intersectsextent_js__WEBPACK_IMPORTED_MODULE_12__.intersectsLinearRingArray)(
      this.getOrientedFlatCoordinates(),
      0,
      this.ends_,
      this.stride,
      extent
    );
  }

  /**
   * Set the coordinates of the polygon.
   * @param {!Array<Array<import("../coordinate.js").Coordinate>>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   */
  setCoordinates(coordinates, layout) {
    this.setLayout(layout, coordinates, 2);
    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }
    const ends = (0,_flat_deflate_js__WEBPACK_IMPORTED_MODULE_13__.deflateCoordinatesArray)(
      this.flatCoordinates,
      0,
      coordinates,
      this.stride,
      this.ends_
    );
    this.flatCoordinates.length = ends.length === 0 ? 0 : ends[ends.length - 1];
    this.changed();
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Polygon);

/**
 * Create an approximation of a circle on the surface of a sphere.
 * @param {import("../coordinate.js").Coordinate} center Center (`[lon, lat]` in degrees).
 * @param {number} radius The great-circle distance from the center to
 *     the polygon vertices in meters.
 * @param {number} [n] Optional number of vertices for the resulting
 *     polygon. Default is `32`.
 * @param {number} [sphereRadius] Optional radius for the sphere (defaults to
 *     the Earth's mean radius using the WGS84 ellipsoid).
 * @return {Polygon} The "circular" polygon.
 * @api
 */
function circular(center, radius, n, sphereRadius) {
  n = n ? n : 32;
  /** @type {Array<number>} */
  const flatCoordinates = [];
  for (let i = 0; i < n; ++i) {
    (0,_array_js__WEBPACK_IMPORTED_MODULE_1__.extend)(
      flatCoordinates,
      (0,_sphere_js__WEBPACK_IMPORTED_MODULE_14__.offset)(center, radius, (2 * Math.PI * i) / n, sphereRadius)
    );
  }
  flatCoordinates.push(flatCoordinates[0], flatCoordinates[1]);
  return new Polygon(flatCoordinates, 'XY', [flatCoordinates.length]);
}

/**
 * Create a polygon from an extent. The layout used is `XY`.
 * @param {import("../extent.js").Extent} extent The extent.
 * @return {Polygon} The polygon.
 * @api
 */
function fromExtent(extent) {
  if ((0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.isEmpty)(extent)) {
    throw new Error('Cannot create polygon from empty extent');
  }
  const minX = extent[0];
  const minY = extent[1];
  const maxX = extent[2];
  const maxY = extent[3];
  const flatCoordinates = [
    minX,
    minY,
    minX,
    maxY,
    maxX,
    maxY,
    maxX,
    minY,
    minX,
    minY,
  ];
  return new Polygon(flatCoordinates, 'XY', [flatCoordinates.length]);
}

/**
 * Create a regular polygon from a circle.
 * @param {import("./Circle.js").default} circle Circle geometry.
 * @param {number} [sides] Number of sides of the polygon. Default is 32.
 * @param {number} [angle] Start angle for the first vertex of the polygon in
 *     counter-clockwise radians. 0 means East. Default is 0.
 * @return {Polygon} Polygon geometry.
 * @api
 */
function fromCircle(circle, sides, angle) {
  sides = sides ? sides : 32;
  const stride = circle.getStride();
  const layout = circle.getLayout();
  const center = circle.getCenter();
  const arrayLength = stride * (sides + 1);
  const flatCoordinates = new Array(arrayLength);
  for (let i = 0; i < arrayLength; i += stride) {
    flatCoordinates[i] = 0;
    flatCoordinates[i + 1] = 0;
    for (let j = 2; j < stride; j++) {
      flatCoordinates[i + j] = center[j];
    }
  }
  const ends = [flatCoordinates.length];
  const polygon = new Polygon(flatCoordinates, layout, ends);
  makeRegular(polygon, center, circle.getRadius(), angle);
  return polygon;
}

/**
 * Modify the coordinates of a polygon to make it a regular polygon.
 * @param {Polygon} polygon Polygon geometry.
 * @param {import("../coordinate.js").Coordinate} center Center of the regular polygon.
 * @param {number} radius Radius of the regular polygon.
 * @param {number} [angle] Start angle for the first vertex of the polygon in
 *     counter-clockwise radians. 0 means East. Default is 0.
 */
function makeRegular(polygon, center, radius, angle) {
  const flatCoordinates = polygon.getFlatCoordinates();
  const stride = polygon.getStride();
  const sides = flatCoordinates.length / stride - 1;
  const startAngle = angle ? angle : 0;
  for (let i = 0; i <= sides; ++i) {
    const offset = i * stride;
    const angle = startAngle + ((0,_math_js__WEBPACK_IMPORTED_MODULE_15__.modulo)(i, sides) * 2 * Math.PI) / sides;
    flatCoordinates[offset] = center[0] + radius * Math.cos(angle);
    flatCoordinates[offset + 1] = center[1] + radius * Math.sin(angle);
  }
  polygon.changed();
}


/***/ }),

/***/ "./node_modules/ol/geom/SimpleGeometry.js":
/*!************************************************!*\
  !*** ./node_modules/ol/geom/SimpleGeometry.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   getStrideForLayout: () => (/* binding */ getStrideForLayout),
/* harmony export */   transformGeom2D: () => (/* binding */ transformGeom2D)
/* harmony export */ });
/* harmony import */ var _Geometry_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Geometry.js */ "./node_modules/ol/geom/Geometry.js");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util.js */ "./node_modules/ol/util.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _flat_transform_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./flat/transform.js */ "./node_modules/ol/geom/flat/transform.js");
/**
 * @module ol/geom/SimpleGeometry
 */





/**
 * @classdesc
 * Abstract base class; only used for creating subclasses; do not instantiate
 * in apps, as cannot be rendered.
 *
 * @abstract
 * @api
 */
class SimpleGeometry extends _Geometry_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  constructor() {
    super();

    /**
     * @protected
     * @type {import("./Geometry.js").GeometryLayout}
     */
    this.layout = 'XY';

    /**
     * @protected
     * @type {number}
     */
    this.stride = 2;

    /**
     * @protected
     * @type {Array<number>}
     */
    this.flatCoordinates = null;
  }

  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @protected
   * @return {import("../extent.js").Extent} extent Extent.
   */
  computeExtent(extent) {
    return (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.createOrUpdateFromFlatCoordinates)(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      extent
    );
  }

  /**
   * @abstract
   * @return {Array<*> | null} Coordinates.
   */
  getCoordinates() {
    return (0,_util_js__WEBPACK_IMPORTED_MODULE_2__.abstract)();
  }

  /**
   * Return the first coordinate of the geometry.
   * @return {import("../coordinate.js").Coordinate} First coordinate.
   * @api
   */
  getFirstCoordinate() {
    return this.flatCoordinates.slice(0, this.stride);
  }

  /**
   * @return {Array<number>} Flat coordinates.
   */
  getFlatCoordinates() {
    return this.flatCoordinates;
  }

  /**
   * Return the last coordinate of the geometry.
   * @return {import("../coordinate.js").Coordinate} Last point.
   * @api
   */
  getLastCoordinate() {
    return this.flatCoordinates.slice(
      this.flatCoordinates.length - this.stride
    );
  }

  /**
   * Return the {@link import("./Geometry.js").GeometryLayout layout} of the geometry.
   * @return {import("./Geometry.js").GeometryLayout} Layout.
   * @api
   */
  getLayout() {
    return this.layout;
  }

  /**
   * Create a simplified version of this geometry using the Douglas Peucker algorithm.
   * @param {number} squaredTolerance Squared tolerance.
   * @return {SimpleGeometry} Simplified geometry.
   */
  getSimplifiedGeometry(squaredTolerance) {
    if (this.simplifiedGeometryRevision !== this.getRevision()) {
      this.simplifiedGeometryMaxMinSquaredTolerance = 0;
      this.simplifiedGeometryRevision = this.getRevision();
    }
    // If squaredTolerance is negative or if we know that simplification will not
    // have any effect then just return this.
    if (
      squaredTolerance < 0 ||
      (this.simplifiedGeometryMaxMinSquaredTolerance !== 0 &&
        squaredTolerance <= this.simplifiedGeometryMaxMinSquaredTolerance)
    ) {
      return this;
    }

    const simplifiedGeometry =
      this.getSimplifiedGeometryInternal(squaredTolerance);
    const simplifiedFlatCoordinates = simplifiedGeometry.getFlatCoordinates();
    if (simplifiedFlatCoordinates.length < this.flatCoordinates.length) {
      return simplifiedGeometry;
    }
    // Simplification did not actually remove any coordinates.  We now know
    // that any calls to getSimplifiedGeometry with a squaredTolerance less
    // than or equal to the current squaredTolerance will also not have any
    // effect.  This allows us to short circuit simplification (saving CPU
    // cycles) and prevents the cache of simplified geometries from filling
    // up with useless identical copies of this geometry (saving memory).
    this.simplifiedGeometryMaxMinSquaredTolerance = squaredTolerance;
    return this;
  }

  /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {SimpleGeometry} Simplified geometry.
   * @protected
   */
  getSimplifiedGeometryInternal(squaredTolerance) {
    return this;
  }

  /**
   * @return {number} Stride.
   */
  getStride() {
    return this.stride;
  }

  /**
   * @param {import("./Geometry.js").GeometryLayout} layout Layout.
   * @param {Array<number>} flatCoordinates Flat coordinates.
   */
  setFlatCoordinates(layout, flatCoordinates) {
    this.stride = getStrideForLayout(layout);
    this.layout = layout;
    this.flatCoordinates = flatCoordinates;
  }

  /**
   * @abstract
   * @param {!Array<*>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   */
  setCoordinates(coordinates, layout) {
    (0,_util_js__WEBPACK_IMPORTED_MODULE_2__.abstract)();
  }

  /**
   * @param {import("./Geometry.js").GeometryLayout|undefined} layout Layout.
   * @param {Array<*>} coordinates Coordinates.
   * @param {number} nesting Nesting.
   * @protected
   */
  setLayout(layout, coordinates, nesting) {
    /** @type {number} */
    let stride;
    if (layout) {
      stride = getStrideForLayout(layout);
    } else {
      for (let i = 0; i < nesting; ++i) {
        if (coordinates.length === 0) {
          this.layout = 'XY';
          this.stride = 2;
          return;
        }
        coordinates = /** @type {Array} */ (coordinates[0]);
      }
      stride = coordinates.length;
      layout = getLayoutForStride(stride);
    }
    this.layout = layout;
    this.stride = stride;
  }

  /**
   * Apply a transform function to the coordinates of the geometry.
   * The geometry is modified in place.
   * If you do not want the geometry modified in place, first `clone()` it and
   * then use this function on the clone.
   * @param {import("../proj.js").TransformFunction} transformFn Transform function.
   * Called with a flat array of geometry coordinates.
   * @api
   */
  applyTransform(transformFn) {
    if (this.flatCoordinates) {
      transformFn(this.flatCoordinates, this.flatCoordinates, this.stride);
      this.changed();
    }
  }

  /**
   * Rotate the geometry around a given coordinate. This modifies the geometry
   * coordinates in place.
   * @param {number} angle Rotation angle in counter-clockwise radians.
   * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
   * @api
   */
  rotate(angle, anchor) {
    const flatCoordinates = this.getFlatCoordinates();
    if (flatCoordinates) {
      const stride = this.getStride();
      (0,_flat_transform_js__WEBPACK_IMPORTED_MODULE_3__.rotate)(
        flatCoordinates,
        0,
        flatCoordinates.length,
        stride,
        angle,
        anchor,
        flatCoordinates
      );
      this.changed();
    }
  }

  /**
   * Scale the geometry (with an optional origin).  This modifies the geometry
   * coordinates in place.
   * @param {number} sx The scaling factor in the x-direction.
   * @param {number} [sy] The scaling factor in the y-direction (defaults to sx).
   * @param {import("../coordinate.js").Coordinate} [anchor] The scale origin (defaults to the center
   *     of the geometry extent).
   * @api
   */
  scale(sx, sy, anchor) {
    if (sy === undefined) {
      sy = sx;
    }
    if (!anchor) {
      anchor = (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.getCenter)(this.getExtent());
    }
    const flatCoordinates = this.getFlatCoordinates();
    if (flatCoordinates) {
      const stride = this.getStride();
      (0,_flat_transform_js__WEBPACK_IMPORTED_MODULE_3__.scale)(
        flatCoordinates,
        0,
        flatCoordinates.length,
        stride,
        sx,
        sy,
        anchor,
        flatCoordinates
      );
      this.changed();
    }
  }

  /**
   * Translate the geometry.  This modifies the geometry coordinates in place.  If
   * instead you want a new geometry, first `clone()` this geometry.
   * @param {number} deltaX Delta X.
   * @param {number} deltaY Delta Y.
   * @api
   */
  translate(deltaX, deltaY) {
    const flatCoordinates = this.getFlatCoordinates();
    if (flatCoordinates) {
      const stride = this.getStride();
      (0,_flat_transform_js__WEBPACK_IMPORTED_MODULE_3__.translate)(
        flatCoordinates,
        0,
        flatCoordinates.length,
        stride,
        deltaX,
        deltaY,
        flatCoordinates
      );
      this.changed();
    }
  }
}

/**
 * @param {number} stride Stride.
 * @return {import("./Geometry.js").GeometryLayout} layout Layout.
 */
function getLayoutForStride(stride) {
  let layout;
  if (stride == 2) {
    layout = 'XY';
  } else if (stride == 3) {
    layout = 'XYZ';
  } else if (stride == 4) {
    layout = 'XYZM';
  }
  return /** @type {import("./Geometry.js").GeometryLayout} */ (layout);
}

/**
 * @param {import("./Geometry.js").GeometryLayout} layout Layout.
 * @return {number} Stride.
 */
function getStrideForLayout(layout) {
  let stride;
  if (layout == 'XY') {
    stride = 2;
  } else if (layout == 'XYZ' || layout == 'XYM') {
    stride = 3;
  } else if (layout == 'XYZM') {
    stride = 4;
  }
  return /** @type {number} */ (stride);
}

/**
 * @param {SimpleGeometry} simpleGeometry Simple geometry.
 * @param {import("../transform.js").Transform} transform Transform.
 * @param {Array<number>} [dest] Destination.
 * @return {Array<number>} Transformed flat coordinates.
 */
function transformGeom2D(simpleGeometry, transform, dest) {
  const flatCoordinates = simpleGeometry.getFlatCoordinates();
  if (!flatCoordinates) {
    return null;
  }
  const stride = simpleGeometry.getStride();
  return (0,_flat_transform_js__WEBPACK_IMPORTED_MODULE_3__.transform2D)(
    flatCoordinates,
    0,
    flatCoordinates.length,
    stride,
    transform,
    dest
  );
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SimpleGeometry);


/***/ }),

/***/ "./node_modules/ol/geom/flat/area.js":
/*!*******************************************!*\
  !*** ./node_modules/ol/geom/flat/area.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   linearRing: () => (/* binding */ linearRing),
/* harmony export */   linearRings: () => (/* binding */ linearRings),
/* harmony export */   linearRingss: () => (/* binding */ linearRingss)
/* harmony export */ });
/**
 * @module ol/geom/flat/area
 */

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {number} Area.
 */
function linearRing(flatCoordinates, offset, end, stride) {
  let twiceArea = 0;
  let x1 = flatCoordinates[end - stride];
  let y1 = flatCoordinates[end - stride + 1];
  for (; offset < end; offset += stride) {
    const x2 = flatCoordinates[offset];
    const y2 = flatCoordinates[offset + 1];
    twiceArea += y1 * x2 - x1 * y2;
    x1 = x2;
    y1 = y2;
  }
  return twiceArea / 2;
}

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @return {number} Area.
 */
function linearRings(flatCoordinates, offset, ends, stride) {
  let area = 0;
  for (let i = 0, ii = ends.length; i < ii; ++i) {
    const end = ends[i];
    area += linearRing(flatCoordinates, offset, end, stride);
    offset = end;
  }
  return area;
}

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @return {number} Area.
 */
function linearRingss(flatCoordinates, offset, endss, stride) {
  let area = 0;
  for (let i = 0, ii = endss.length; i < ii; ++i) {
    const ends = endss[i];
    area += linearRings(flatCoordinates, offset, ends, stride);
    offset = ends[ends.length - 1];
  }
  return area;
}


/***/ }),

/***/ "./node_modules/ol/geom/flat/center.js":
/*!*********************************************!*\
  !*** ./node_modules/ol/geom/flat/center.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   linearRingss: () => (/* binding */ linearRingss)
/* harmony export */ });
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../extent.js */ "./node_modules/ol/extent.js");
/**
 * @module ol/geom/flat/center
 */


/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @return {Array<number>} Flat centers.
 */
function linearRingss(flatCoordinates, offset, endss, stride) {
  const flatCenters = [];
  let extent = (0,_extent_js__WEBPACK_IMPORTED_MODULE_0__.createEmpty)();
  for (let i = 0, ii = endss.length; i < ii; ++i) {
    const ends = endss[i];
    extent = (0,_extent_js__WEBPACK_IMPORTED_MODULE_0__.createOrUpdateFromFlatCoordinates)(
      flatCoordinates,
      offset,
      ends[0],
      stride
    );
    flatCenters.push((extent[0] + extent[2]) / 2, (extent[1] + extent[3]) / 2);
    offset = ends[ends.length - 1];
  }
  return flatCenters;
}


/***/ }),

/***/ "./node_modules/ol/geom/flat/closest.js":
/*!**********************************************!*\
  !*** ./node_modules/ol/geom/flat/closest.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   arrayMaxSquaredDelta: () => (/* binding */ arrayMaxSquaredDelta),
/* harmony export */   assignClosestArrayPoint: () => (/* binding */ assignClosestArrayPoint),
/* harmony export */   assignClosestMultiArrayPoint: () => (/* binding */ assignClosestMultiArrayPoint),
/* harmony export */   assignClosestPoint: () => (/* binding */ assignClosestPoint),
/* harmony export */   maxSquaredDelta: () => (/* binding */ maxSquaredDelta),
/* harmony export */   multiArrayMaxSquaredDelta: () => (/* binding */ multiArrayMaxSquaredDelta)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../math.js */ "./node_modules/ol/math.js");
/**
 * @module ol/geom/flat/closest
 */


/**
 * Returns the point on the 2D line segment flatCoordinates[offset1] to
 * flatCoordinates[offset2] that is closest to the point (x, y).  Extra
 * dimensions are linearly interpolated.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset1 Offset 1.
 * @param {number} offset2 Offset 2.
 * @param {number} stride Stride.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {Array<number>} closestPoint Closest point.
 */
function assignClosest(
  flatCoordinates,
  offset1,
  offset2,
  stride,
  x,
  y,
  closestPoint
) {
  const x1 = flatCoordinates[offset1];
  const y1 = flatCoordinates[offset1 + 1];
  const dx = flatCoordinates[offset2] - x1;
  const dy = flatCoordinates[offset2 + 1] - y1;
  let offset;
  if (dx === 0 && dy === 0) {
    offset = offset1;
  } else {
    const t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);
    if (t > 1) {
      offset = offset2;
    } else if (t > 0) {
      for (let i = 0; i < stride; ++i) {
        closestPoint[i] = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.lerp)(
          flatCoordinates[offset1 + i],
          flatCoordinates[offset2 + i],
          t
        );
      }
      closestPoint.length = stride;
      return;
    } else {
      offset = offset1;
    }
  }
  for (let i = 0; i < stride; ++i) {
    closestPoint[i] = flatCoordinates[offset + i];
  }
  closestPoint.length = stride;
}

/**
 * Return the squared of the largest distance between any pair of consecutive
 * coordinates.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} max Max squared delta.
 * @return {number} Max squared delta.
 */
function maxSquaredDelta(flatCoordinates, offset, end, stride, max) {
  let x1 = flatCoordinates[offset];
  let y1 = flatCoordinates[offset + 1];
  for (offset += stride; offset < end; offset += stride) {
    const x2 = flatCoordinates[offset];
    const y2 = flatCoordinates[offset + 1];
    const squaredDelta = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.squaredDistance)(x1, y1, x2, y2);
    if (squaredDelta > max) {
      max = squaredDelta;
    }
    x1 = x2;
    y1 = y2;
  }
  return max;
}

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {number} max Max squared delta.
 * @return {number} Max squared delta.
 */
function arrayMaxSquaredDelta(
  flatCoordinates,
  offset,
  ends,
  stride,
  max
) {
  for (let i = 0, ii = ends.length; i < ii; ++i) {
    const end = ends[i];
    max = maxSquaredDelta(flatCoordinates, offset, end, stride, max);
    offset = end;
  }
  return max;
}

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {number} max Max squared delta.
 * @return {number} Max squared delta.
 */
function multiArrayMaxSquaredDelta(
  flatCoordinates,
  offset,
  endss,
  stride,
  max
) {
  for (let i = 0, ii = endss.length; i < ii; ++i) {
    const ends = endss[i];
    max = arrayMaxSquaredDelta(flatCoordinates, offset, ends, stride, max);
    offset = ends[ends.length - 1];
  }
  return max;
}

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} maxDelta Max delta.
 * @param {boolean} isRing Is ring.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {Array<number>} closestPoint Closest point.
 * @param {number} minSquaredDistance Minimum squared distance.
 * @param {Array<number>} [tmpPoint] Temporary point object.
 * @return {number} Minimum squared distance.
 */
function assignClosestPoint(
  flatCoordinates,
  offset,
  end,
  stride,
  maxDelta,
  isRing,
  x,
  y,
  closestPoint,
  minSquaredDistance,
  tmpPoint
) {
  if (offset == end) {
    return minSquaredDistance;
  }
  let i, squaredDistance;
  if (maxDelta === 0) {
    // All points are identical, so just test the first point.
    squaredDistance = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.squaredDistance)(
      x,
      y,
      flatCoordinates[offset],
      flatCoordinates[offset + 1]
    );
    if (squaredDistance < minSquaredDistance) {
      for (i = 0; i < stride; ++i) {
        closestPoint[i] = flatCoordinates[offset + i];
      }
      closestPoint.length = stride;
      return squaredDistance;
    }
    return minSquaredDistance;
  }
  tmpPoint = tmpPoint ? tmpPoint : [NaN, NaN];
  let index = offset + stride;
  while (index < end) {
    assignClosest(
      flatCoordinates,
      index - stride,
      index,
      stride,
      x,
      y,
      tmpPoint
    );
    squaredDistance = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.squaredDistance)(x, y, tmpPoint[0], tmpPoint[1]);
    if (squaredDistance < minSquaredDistance) {
      minSquaredDistance = squaredDistance;
      for (i = 0; i < stride; ++i) {
        closestPoint[i] = tmpPoint[i];
      }
      closestPoint.length = stride;
      index += stride;
    } else {
      // Skip ahead multiple points, because we know that all the skipped
      // points cannot be any closer than the closest point we have found so
      // far.  We know this because we know how close the current point is, how
      // close the closest point we have found so far is, and the maximum
      // distance between consecutive points.  For example, if we're currently
      // at distance 10, the best we've found so far is 3, and that the maximum
      // distance between consecutive points is 2, then we'll need to skip at
      // least (10 - 3) / 2 == 3 (rounded down) points to have any chance of
      // finding a closer point.  We use Math.max(..., 1) to ensure that we
      // always advance at least one point, to avoid an infinite loop.
      index +=
        stride *
        Math.max(
          ((Math.sqrt(squaredDistance) - Math.sqrt(minSquaredDistance)) /
            maxDelta) |
            0,
          1
        );
    }
  }
  if (isRing) {
    // Check the closing segment.
    assignClosest(
      flatCoordinates,
      end - stride,
      offset,
      stride,
      x,
      y,
      tmpPoint
    );
    squaredDistance = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.squaredDistance)(x, y, tmpPoint[0], tmpPoint[1]);
    if (squaredDistance < minSquaredDistance) {
      minSquaredDistance = squaredDistance;
      for (i = 0; i < stride; ++i) {
        closestPoint[i] = tmpPoint[i];
      }
      closestPoint.length = stride;
    }
  }
  return minSquaredDistance;
}

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {number} maxDelta Max delta.
 * @param {boolean} isRing Is ring.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {Array<number>} closestPoint Closest point.
 * @param {number} minSquaredDistance Minimum squared distance.
 * @param {Array<number>} [tmpPoint] Temporary point object.
 * @return {number} Minimum squared distance.
 */
function assignClosestArrayPoint(
  flatCoordinates,
  offset,
  ends,
  stride,
  maxDelta,
  isRing,
  x,
  y,
  closestPoint,
  minSquaredDistance,
  tmpPoint
) {
  tmpPoint = tmpPoint ? tmpPoint : [NaN, NaN];
  for (let i = 0, ii = ends.length; i < ii; ++i) {
    const end = ends[i];
    minSquaredDistance = assignClosestPoint(
      flatCoordinates,
      offset,
      end,
      stride,
      maxDelta,
      isRing,
      x,
      y,
      closestPoint,
      minSquaredDistance,
      tmpPoint
    );
    offset = end;
  }
  return minSquaredDistance;
}

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {number} maxDelta Max delta.
 * @param {boolean} isRing Is ring.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {Array<number>} closestPoint Closest point.
 * @param {number} minSquaredDistance Minimum squared distance.
 * @param {Array<number>} [tmpPoint] Temporary point object.
 * @return {number} Minimum squared distance.
 */
function assignClosestMultiArrayPoint(
  flatCoordinates,
  offset,
  endss,
  stride,
  maxDelta,
  isRing,
  x,
  y,
  closestPoint,
  minSquaredDistance,
  tmpPoint
) {
  tmpPoint = tmpPoint ? tmpPoint : [NaN, NaN];
  for (let i = 0, ii = endss.length; i < ii; ++i) {
    const ends = endss[i];
    minSquaredDistance = assignClosestArrayPoint(
      flatCoordinates,
      offset,
      ends,
      stride,
      maxDelta,
      isRing,
      x,
      y,
      closestPoint,
      minSquaredDistance,
      tmpPoint
    );
    offset = ends[ends.length - 1];
  }
  return minSquaredDistance;
}


/***/ }),

/***/ "./node_modules/ol/geom/flat/contains.js":
/*!***********************************************!*\
  !*** ./node_modules/ol/geom/flat/contains.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   linearRingContainsExtent: () => (/* binding */ linearRingContainsExtent),
/* harmony export */   linearRingContainsXY: () => (/* binding */ linearRingContainsXY),
/* harmony export */   linearRingsContainsXY: () => (/* binding */ linearRingsContainsXY),
/* harmony export */   linearRingssContainsXY: () => (/* binding */ linearRingssContainsXY)
/* harmony export */ });
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../extent.js */ "./node_modules/ol/extent.js");
/**
 * @module ol/geom/flat/contains
 */


/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {import("../../extent.js").Extent} extent Extent.
 * @return {boolean} Contains extent.
 */
function linearRingContainsExtent(
  flatCoordinates,
  offset,
  end,
  stride,
  extent
) {
  const outside = (0,_extent_js__WEBPACK_IMPORTED_MODULE_0__.forEachCorner)(
    extent,
    /**
     * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
     * @return {boolean} Contains (x, y).
     */
    function (coordinate) {
      return !linearRingContainsXY(
        flatCoordinates,
        offset,
        end,
        stride,
        coordinate[0],
        coordinate[1]
      );
    }
  );
  return !outside;
}

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} x X.
 * @param {number} y Y.
 * @return {boolean} Contains (x, y).
 */
function linearRingContainsXY(
  flatCoordinates,
  offset,
  end,
  stride,
  x,
  y
) {
  // https://geomalgorithms.com/a03-_inclusion.html
  // Copyright 2000 softSurfer, 2012 Dan Sunday
  // This code may be freely used and modified for any purpose
  // providing that this copyright notice is included with it.
  // SoftSurfer makes no warranty for this code, and cannot be held
  // liable for any real or imagined damage resulting from its use.
  // Users of this code must verify correctness for their application.
  let wn = 0;
  let x1 = flatCoordinates[end - stride];
  let y1 = flatCoordinates[end - stride + 1];
  for (; offset < end; offset += stride) {
    const x2 = flatCoordinates[offset];
    const y2 = flatCoordinates[offset + 1];
    if (y1 <= y) {
      if (y2 > y && (x2 - x1) * (y - y1) - (x - x1) * (y2 - y1) > 0) {
        wn++;
      }
    } else if (y2 <= y && (x2 - x1) * (y - y1) - (x - x1) * (y2 - y1) < 0) {
      wn--;
    }
    x1 = x2;
    y1 = y2;
  }
  return wn !== 0;
}

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {number} x X.
 * @param {number} y Y.
 * @return {boolean} Contains (x, y).
 */
function linearRingsContainsXY(
  flatCoordinates,
  offset,
  ends,
  stride,
  x,
  y
) {
  if (ends.length === 0) {
    return false;
  }
  if (!linearRingContainsXY(flatCoordinates, offset, ends[0], stride, x, y)) {
    return false;
  }
  for (let i = 1, ii = ends.length; i < ii; ++i) {
    if (
      linearRingContainsXY(flatCoordinates, ends[i - 1], ends[i], stride, x, y)
    ) {
      return false;
    }
  }
  return true;
}

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {number} x X.
 * @param {number} y Y.
 * @return {boolean} Contains (x, y).
 */
function linearRingssContainsXY(
  flatCoordinates,
  offset,
  endss,
  stride,
  x,
  y
) {
  if (endss.length === 0) {
    return false;
  }
  for (let i = 0, ii = endss.length; i < ii; ++i) {
    const ends = endss[i];
    if (linearRingsContainsXY(flatCoordinates, offset, ends, stride, x, y)) {
      return true;
    }
    offset = ends[ends.length - 1];
  }
  return false;
}


/***/ }),

/***/ "./node_modules/ol/geom/flat/deflate.js":
/*!**********************************************!*\
  !*** ./node_modules/ol/geom/flat/deflate.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   deflateCoordinate: () => (/* binding */ deflateCoordinate),
/* harmony export */   deflateCoordinates: () => (/* binding */ deflateCoordinates),
/* harmony export */   deflateCoordinatesArray: () => (/* binding */ deflateCoordinatesArray),
/* harmony export */   deflateMultiCoordinatesArray: () => (/* binding */ deflateMultiCoordinatesArray)
/* harmony export */ });
/**
 * @module ol/geom/flat/deflate
 */

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
 * @param {number} stride Stride.
 * @return {number} offset Offset.
 */
function deflateCoordinate(flatCoordinates, offset, coordinate, stride) {
  for (let i = 0, ii = coordinate.length; i < ii; ++i) {
    flatCoordinates[offset++] = coordinate[i];
  }
  return offset;
}

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<import("../../coordinate.js").Coordinate>} coordinates Coordinates.
 * @param {number} stride Stride.
 * @return {number} offset Offset.
 */
function deflateCoordinates(
  flatCoordinates,
  offset,
  coordinates,
  stride
) {
  for (let i = 0, ii = coordinates.length; i < ii; ++i) {
    const coordinate = coordinates[i];
    for (let j = 0; j < stride; ++j) {
      flatCoordinates[offset++] = coordinate[j];
    }
  }
  return offset;
}

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<import("../../coordinate.js").Coordinate>>} coordinatess Coordinatess.
 * @param {number} stride Stride.
 * @param {Array<number>} [ends] Ends.
 * @return {Array<number>} Ends.
 */
function deflateCoordinatesArray(
  flatCoordinates,
  offset,
  coordinatess,
  stride,
  ends
) {
  ends = ends ? ends : [];
  let i = 0;
  for (let j = 0, jj = coordinatess.length; j < jj; ++j) {
    const end = deflateCoordinates(
      flatCoordinates,
      offset,
      coordinatess[j],
      stride
    );
    ends[i++] = end;
    offset = end;
  }
  ends.length = i;
  return ends;
}

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<Array<import("../../coordinate.js").Coordinate>>>} coordinatesss Coordinatesss.
 * @param {number} stride Stride.
 * @param {Array<Array<number>>} [endss] Endss.
 * @return {Array<Array<number>>} Endss.
 */
function deflateMultiCoordinatesArray(
  flatCoordinates,
  offset,
  coordinatesss,
  stride,
  endss
) {
  endss = endss ? endss : [];
  let i = 0;
  for (let j = 0, jj = coordinatesss.length; j < jj; ++j) {
    const ends = deflateCoordinatesArray(
      flatCoordinates,
      offset,
      coordinatesss[j],
      stride,
      endss[i]
    );
    if (ends.length === 0) {
      ends[0] = offset;
    }
    endss[i++] = ends;
    offset = ends[ends.length - 1];
  }
  endss.length = i;
  return endss;
}


/***/ }),

/***/ "./node_modules/ol/geom/flat/inflate.js":
/*!**********************************************!*\
  !*** ./node_modules/ol/geom/flat/inflate.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   inflateCoordinates: () => (/* binding */ inflateCoordinates),
/* harmony export */   inflateCoordinatesArray: () => (/* binding */ inflateCoordinatesArray),
/* harmony export */   inflateMultiCoordinatesArray: () => (/* binding */ inflateMultiCoordinatesArray)
/* harmony export */ });
/**
 * @module ol/geom/flat/inflate
 */

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {Array<import("../../coordinate.js").Coordinate>} [coordinates] Coordinates.
 * @return {Array<import("../../coordinate.js").Coordinate>} Coordinates.
 */
function inflateCoordinates(
  flatCoordinates,
  offset,
  end,
  stride,
  coordinates
) {
  coordinates = coordinates !== undefined ? coordinates : [];
  let i = 0;
  for (let j = offset; j < end; j += stride) {
    coordinates[i++] = flatCoordinates.slice(j, j + stride);
  }
  coordinates.length = i;
  return coordinates;
}

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {Array<Array<import("../../coordinate.js").Coordinate>>} [coordinatess] Coordinatess.
 * @return {Array<Array<import("../../coordinate.js").Coordinate>>} Coordinatess.
 */
function inflateCoordinatesArray(
  flatCoordinates,
  offset,
  ends,
  stride,
  coordinatess
) {
  coordinatess = coordinatess !== undefined ? coordinatess : [];
  let i = 0;
  for (let j = 0, jj = ends.length; j < jj; ++j) {
    const end = ends[j];
    coordinatess[i++] = inflateCoordinates(
      flatCoordinates,
      offset,
      end,
      stride,
      coordinatess[i]
    );
    offset = end;
  }
  coordinatess.length = i;
  return coordinatess;
}

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {Array<Array<Array<import("../../coordinate.js").Coordinate>>>} [coordinatesss]
 *     Coordinatesss.
 * @return {Array<Array<Array<import("../../coordinate.js").Coordinate>>>} Coordinatesss.
 */
function inflateMultiCoordinatesArray(
  flatCoordinates,
  offset,
  endss,
  stride,
  coordinatesss
) {
  coordinatesss = coordinatesss !== undefined ? coordinatesss : [];
  let i = 0;
  for (let j = 0, jj = endss.length; j < jj; ++j) {
    const ends = endss[j];
    coordinatesss[i++] =
      ends.length === 1 && ends[0] === offset
        ? []
        : inflateCoordinatesArray(
            flatCoordinates,
            offset,
            ends,
            stride,
            coordinatesss[i]
          );
    offset = ends[ends.length - 1];
  }
  coordinatesss.length = i;
  return coordinatesss;
}


/***/ }),

/***/ "./node_modules/ol/geom/flat/interiorpoint.js":
/*!****************************************************!*\
  !*** ./node_modules/ol/geom/flat/interiorpoint.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getInteriorPointOfArray: () => (/* binding */ getInteriorPointOfArray),
/* harmony export */   getInteriorPointsOfMultiArray: () => (/* binding */ getInteriorPointsOfMultiArray)
/* harmony export */ });
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _contains_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./contains.js */ "./node_modules/ol/geom/flat/contains.js");
/**
 * @module ol/geom/flat/interiorpoint
 */



/**
 * Calculates a point that is likely to lie in the interior of the linear rings.
 * Inspired by JTS's com.vividsolutions.jts.geom.Geometry#getInteriorPoint.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {Array<number>} flatCenters Flat centers.
 * @param {number} flatCentersOffset Flat center offset.
 * @param {Array<number>} [dest] Destination.
 * @return {Array<number>} Destination point as XYM coordinate, where M is the
 * length of the horizontal intersection that the point belongs to.
 */
function getInteriorPointOfArray(
  flatCoordinates,
  offset,
  ends,
  stride,
  flatCenters,
  flatCentersOffset,
  dest
) {
  let i, ii, x, x1, x2, y1, y2;
  const y = flatCenters[flatCentersOffset + 1];
  /** @type {Array<number>} */
  const intersections = [];
  // Calculate intersections with the horizontal line
  for (let r = 0, rr = ends.length; r < rr; ++r) {
    const end = ends[r];
    x1 = flatCoordinates[end - stride];
    y1 = flatCoordinates[end - stride + 1];
    for (i = offset; i < end; i += stride) {
      x2 = flatCoordinates[i];
      y2 = flatCoordinates[i + 1];
      if ((y <= y1 && y2 <= y) || (y1 <= y && y <= y2)) {
        x = ((y - y1) / (y2 - y1)) * (x2 - x1) + x1;
        intersections.push(x);
      }
      x1 = x2;
      y1 = y2;
    }
  }
  // Find the longest segment of the horizontal line that has its center point
  // inside the linear ring.
  let pointX = NaN;
  let maxSegmentLength = -Infinity;
  intersections.sort(_array_js__WEBPACK_IMPORTED_MODULE_0__.ascending);
  x1 = intersections[0];
  for (i = 1, ii = intersections.length; i < ii; ++i) {
    x2 = intersections[i];
    const segmentLength = Math.abs(x2 - x1);
    if (segmentLength > maxSegmentLength) {
      x = (x1 + x2) / 2;
      if ((0,_contains_js__WEBPACK_IMPORTED_MODULE_1__.linearRingsContainsXY)(flatCoordinates, offset, ends, stride, x, y)) {
        pointX = x;
        maxSegmentLength = segmentLength;
      }
    }
    x1 = x2;
  }
  if (isNaN(pointX)) {
    // There is no horizontal line that has its center point inside the linear
    // ring.  Use the center of the the linear ring's extent.
    pointX = flatCenters[flatCentersOffset];
  }
  if (dest) {
    dest.push(pointX, y, maxSegmentLength);
    return dest;
  }
  return [pointX, y, maxSegmentLength];
}

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {Array<number>} flatCenters Flat centers.
 * @return {Array<number>} Interior points as XYM coordinates, where M is the
 * length of the horizontal intersection that the point belongs to.
 */
function getInteriorPointsOfMultiArray(
  flatCoordinates,
  offset,
  endss,
  stride,
  flatCenters
) {
  let interiorPoints = [];
  for (let i = 0, ii = endss.length; i < ii; ++i) {
    const ends = endss[i];
    interiorPoints = getInteriorPointOfArray(
      flatCoordinates,
      offset,
      ends,
      stride,
      flatCenters,
      2 * i,
      interiorPoints
    );
    offset = ends[ends.length - 1];
  }
  return interiorPoints;
}


/***/ }),

/***/ "./node_modules/ol/geom/flat/interpolate.js":
/*!**************************************************!*\
  !*** ./node_modules/ol/geom/flat/interpolate.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   interpolatePoint: () => (/* binding */ interpolatePoint),
/* harmony export */   lineStringCoordinateAtM: () => (/* binding */ lineStringCoordinateAtM),
/* harmony export */   lineStringsCoordinateAtM: () => (/* binding */ lineStringsCoordinateAtM)
/* harmony export */ });
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../math.js */ "./node_modules/ol/math.js");
/**
 * @module ol/geom/flat/interpolate
 */



/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} fraction Fraction.
 * @param {Array<number>} [dest] Destination.
 * @param {number} [dimension] Destination dimension (default is `2`)
 * @return {Array<number>} Destination.
 */
function interpolatePoint(
  flatCoordinates,
  offset,
  end,
  stride,
  fraction,
  dest,
  dimension
) {
  let o, t;
  const n = (end - offset) / stride;
  if (n === 1) {
    o = offset;
  } else if (n === 2) {
    o = offset;
    t = fraction;
  } else if (n !== 0) {
    let x1 = flatCoordinates[offset];
    let y1 = flatCoordinates[offset + 1];
    let length = 0;
    const cumulativeLengths = [0];
    for (let i = offset + stride; i < end; i += stride) {
      const x2 = flatCoordinates[i];
      const y2 = flatCoordinates[i + 1];
      length += Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
      cumulativeLengths.push(length);
      x1 = x2;
      y1 = y2;
    }
    const target = fraction * length;
    const index = (0,_array_js__WEBPACK_IMPORTED_MODULE_0__.binarySearch)(cumulativeLengths, target);
    if (index < 0) {
      t =
        (target - cumulativeLengths[-index - 2]) /
        (cumulativeLengths[-index - 1] - cumulativeLengths[-index - 2]);
      o = offset + (-index - 2) * stride;
    } else {
      o = offset + index * stride;
    }
  }
  dimension = dimension > 1 ? dimension : 2;
  dest = dest ? dest : new Array(dimension);
  for (let i = 0; i < dimension; ++i) {
    dest[i] =
      o === undefined
        ? NaN
        : t === undefined
        ? flatCoordinates[o + i]
        : (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.lerp)(flatCoordinates[o + i], flatCoordinates[o + stride + i], t);
  }
  return dest;
}

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} m M.
 * @param {boolean} extrapolate Extrapolate.
 * @return {import("../../coordinate.js").Coordinate|null} Coordinate.
 */
function lineStringCoordinateAtM(
  flatCoordinates,
  offset,
  end,
  stride,
  m,
  extrapolate
) {
  if (end == offset) {
    return null;
  }
  let coordinate;
  if (m < flatCoordinates[offset + stride - 1]) {
    if (extrapolate) {
      coordinate = flatCoordinates.slice(offset, offset + stride);
      coordinate[stride - 1] = m;
      return coordinate;
    }
    return null;
  }
  if (flatCoordinates[end - 1] < m) {
    if (extrapolate) {
      coordinate = flatCoordinates.slice(end - stride, end);
      coordinate[stride - 1] = m;
      return coordinate;
    }
    return null;
  }
  // FIXME use O(1) search
  if (m == flatCoordinates[offset + stride - 1]) {
    return flatCoordinates.slice(offset, offset + stride);
  }
  let lo = offset / stride;
  let hi = end / stride;
  while (lo < hi) {
    const mid = (lo + hi) >> 1;
    if (m < flatCoordinates[(mid + 1) * stride - 1]) {
      hi = mid;
    } else {
      lo = mid + 1;
    }
  }
  const m0 = flatCoordinates[lo * stride - 1];
  if (m == m0) {
    return flatCoordinates.slice((lo - 1) * stride, (lo - 1) * stride + stride);
  }
  const m1 = flatCoordinates[(lo + 1) * stride - 1];
  const t = (m - m0) / (m1 - m0);
  coordinate = [];
  for (let i = 0; i < stride - 1; ++i) {
    coordinate.push(
      (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.lerp)(
        flatCoordinates[(lo - 1) * stride + i],
        flatCoordinates[lo * stride + i],
        t
      )
    );
  }
  coordinate.push(m);
  return coordinate;
}

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {number} m M.
 * @param {boolean} extrapolate Extrapolate.
 * @param {boolean} interpolate Interpolate.
 * @return {import("../../coordinate.js").Coordinate|null} Coordinate.
 */
function lineStringsCoordinateAtM(
  flatCoordinates,
  offset,
  ends,
  stride,
  m,
  extrapolate,
  interpolate
) {
  if (interpolate) {
    return lineStringCoordinateAtM(
      flatCoordinates,
      offset,
      ends[ends.length - 1],
      stride,
      m,
      extrapolate
    );
  }
  let coordinate;
  if (m < flatCoordinates[stride - 1]) {
    if (extrapolate) {
      coordinate = flatCoordinates.slice(0, stride);
      coordinate[stride - 1] = m;
      return coordinate;
    }
    return null;
  }
  if (flatCoordinates[flatCoordinates.length - 1] < m) {
    if (extrapolate) {
      coordinate = flatCoordinates.slice(flatCoordinates.length - stride);
      coordinate[stride - 1] = m;
      return coordinate;
    }
    return null;
  }
  for (let i = 0, ii = ends.length; i < ii; ++i) {
    const end = ends[i];
    if (offset == end) {
      continue;
    }
    if (m < flatCoordinates[offset + stride - 1]) {
      return null;
    }
    if (m <= flatCoordinates[end - 1]) {
      return lineStringCoordinateAtM(
        flatCoordinates,
        offset,
        end,
        stride,
        m,
        false
      );
    }
    offset = end;
  }
  return null;
}


/***/ }),

/***/ "./node_modules/ol/geom/flat/intersectsextent.js":
/*!*******************************************************!*\
  !*** ./node_modules/ol/geom/flat/intersectsextent.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   intersectsLineString: () => (/* binding */ intersectsLineString),
/* harmony export */   intersectsLineStringArray: () => (/* binding */ intersectsLineStringArray),
/* harmony export */   intersectsLinearRing: () => (/* binding */ intersectsLinearRing),
/* harmony export */   intersectsLinearRingArray: () => (/* binding */ intersectsLinearRingArray),
/* harmony export */   intersectsLinearRingMultiArray: () => (/* binding */ intersectsLinearRingMultiArray)
/* harmony export */ });
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _segments_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./segments.js */ "./node_modules/ol/geom/flat/segments.js");
/* harmony import */ var _contains_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./contains.js */ "./node_modules/ol/geom/flat/contains.js");
/**
 * @module ol/geom/flat/intersectsextent
 */




/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {import("../../extent.js").Extent} extent Extent.
 * @return {boolean} True if the geometry and the extent intersect.
 */
function intersectsLineString(
  flatCoordinates,
  offset,
  end,
  stride,
  extent
) {
  const coordinatesExtent = (0,_extent_js__WEBPACK_IMPORTED_MODULE_0__.extendFlatCoordinates)(
    (0,_extent_js__WEBPACK_IMPORTED_MODULE_0__.createEmpty)(),
    flatCoordinates,
    offset,
    end,
    stride
  );
  if (!(0,_extent_js__WEBPACK_IMPORTED_MODULE_0__.intersects)(extent, coordinatesExtent)) {
    return false;
  }
  if ((0,_extent_js__WEBPACK_IMPORTED_MODULE_0__.containsExtent)(extent, coordinatesExtent)) {
    return true;
  }
  if (coordinatesExtent[0] >= extent[0] && coordinatesExtent[2] <= extent[2]) {
    return true;
  }
  if (coordinatesExtent[1] >= extent[1] && coordinatesExtent[3] <= extent[3]) {
    return true;
  }
  return (0,_segments_js__WEBPACK_IMPORTED_MODULE_1__.forEach)(
    flatCoordinates,
    offset,
    end,
    stride,
    /**
     * @param {import("../../coordinate.js").Coordinate} point1 Start point.
     * @param {import("../../coordinate.js").Coordinate} point2 End point.
     * @return {boolean} `true` if the segment and the extent intersect,
     *     `false` otherwise.
     */
    function (point1, point2) {
      return (0,_extent_js__WEBPACK_IMPORTED_MODULE_0__.intersectsSegment)(extent, point1, point2);
    }
  );
}

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {import("../../extent.js").Extent} extent Extent.
 * @return {boolean} True if the geometry and the extent intersect.
 */
function intersectsLineStringArray(
  flatCoordinates,
  offset,
  ends,
  stride,
  extent
) {
  for (let i = 0, ii = ends.length; i < ii; ++i) {
    if (
      intersectsLineString(flatCoordinates, offset, ends[i], stride, extent)
    ) {
      return true;
    }
    offset = ends[i];
  }
  return false;
}

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {import("../../extent.js").Extent} extent Extent.
 * @return {boolean} True if the geometry and the extent intersect.
 */
function intersectsLinearRing(
  flatCoordinates,
  offset,
  end,
  stride,
  extent
) {
  if (intersectsLineString(flatCoordinates, offset, end, stride, extent)) {
    return true;
  }
  if (
    (0,_contains_js__WEBPACK_IMPORTED_MODULE_2__.linearRingContainsXY)(
      flatCoordinates,
      offset,
      end,
      stride,
      extent[0],
      extent[1]
    )
  ) {
    return true;
  }
  if (
    (0,_contains_js__WEBPACK_IMPORTED_MODULE_2__.linearRingContainsXY)(
      flatCoordinates,
      offset,
      end,
      stride,
      extent[0],
      extent[3]
    )
  ) {
    return true;
  }
  if (
    (0,_contains_js__WEBPACK_IMPORTED_MODULE_2__.linearRingContainsXY)(
      flatCoordinates,
      offset,
      end,
      stride,
      extent[2],
      extent[1]
    )
  ) {
    return true;
  }
  if (
    (0,_contains_js__WEBPACK_IMPORTED_MODULE_2__.linearRingContainsXY)(
      flatCoordinates,
      offset,
      end,
      stride,
      extent[2],
      extent[3]
    )
  ) {
    return true;
  }
  return false;
}

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {import("../../extent.js").Extent} extent Extent.
 * @return {boolean} True if the geometry and the extent intersect.
 */
function intersectsLinearRingArray(
  flatCoordinates,
  offset,
  ends,
  stride,
  extent
) {
  if (!intersectsLinearRing(flatCoordinates, offset, ends[0], stride, extent)) {
    return false;
  }
  if (ends.length === 1) {
    return true;
  }
  for (let i = 1, ii = ends.length; i < ii; ++i) {
    if (
      (0,_contains_js__WEBPACK_IMPORTED_MODULE_2__.linearRingContainsExtent)(
        flatCoordinates,
        ends[i - 1],
        ends[i],
        stride,
        extent
      )
    ) {
      if (
        !intersectsLineString(
          flatCoordinates,
          ends[i - 1],
          ends[i],
          stride,
          extent
        )
      ) {
        return false;
      }
    }
  }
  return true;
}

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {import("../../extent.js").Extent} extent Extent.
 * @return {boolean} True if the geometry and the extent intersect.
 */
function intersectsLinearRingMultiArray(
  flatCoordinates,
  offset,
  endss,
  stride,
  extent
) {
  for (let i = 0, ii = endss.length; i < ii; ++i) {
    const ends = endss[i];
    if (
      intersectsLinearRingArray(flatCoordinates, offset, ends, stride, extent)
    ) {
      return true;
    }
    offset = ends[ends.length - 1];
  }
  return false;
}


/***/ }),

/***/ "./node_modules/ol/geom/flat/length.js":
/*!*********************************************!*\
  !*** ./node_modules/ol/geom/flat/length.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   lineStringLength: () => (/* binding */ lineStringLength),
/* harmony export */   linearRingLength: () => (/* binding */ linearRingLength)
/* harmony export */ });
/**
 * @module ol/geom/flat/length
 */

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {number} Length.
 */
function lineStringLength(flatCoordinates, offset, end, stride) {
  let x1 = flatCoordinates[offset];
  let y1 = flatCoordinates[offset + 1];
  let length = 0;
  for (let i = offset + stride; i < end; i += stride) {
    const x2 = flatCoordinates[i];
    const y2 = flatCoordinates[i + 1];
    length += Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
    x1 = x2;
    y1 = y2;
  }
  return length;
}

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {number} Perimeter.
 */
function linearRingLength(flatCoordinates, offset, end, stride) {
  let perimeter = lineStringLength(flatCoordinates, offset, end, stride);
  const dx = flatCoordinates[end - stride] - flatCoordinates[offset];
  const dy = flatCoordinates[end - stride + 1] - flatCoordinates[offset + 1];
  perimeter += Math.sqrt(dx * dx + dy * dy);
  return perimeter;
}


/***/ }),

/***/ "./node_modules/ol/geom/flat/linechunk.js":
/*!************************************************!*\
  !*** ./node_modules/ol/geom/flat/linechunk.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   lineChunk: () => (/* binding */ lineChunk)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../math.js */ "./node_modules/ol/math.js");


/**
 * Creates chunks of equal length from a linestring
 * @param {number} chunkLength Length of each chunk.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Start offset of the `flatCoordinates`.
 * @param {number} end End offset of the `flatCoordinates`.
 * @param {number} stride Stride.
 * @return {Array<Array<number>>} Chunks of linestrings with stride 2.
 */
function lineChunk(chunkLength, flatCoordinates, offset, end, stride) {
  const chunks = [];
  let cursor = offset;
  let chunkM = 0;
  let currentChunk = flatCoordinates.slice(offset, 2);
  while (chunkM < chunkLength && cursor + stride < end) {
    const [x1, y1] = currentChunk.slice(-2);
    const x2 = flatCoordinates[cursor + stride];
    const y2 = flatCoordinates[cursor + stride + 1];
    const segmentLength = Math.sqrt(
      (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1)
    );
    chunkM += segmentLength;
    if (chunkM >= chunkLength) {
      const m = (chunkLength - chunkM + segmentLength) / segmentLength;
      const x = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.lerp)(x1, x2, m);
      const y = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.lerp)(y1, y2, m);
      currentChunk.push(x, y);
      chunks.push(currentChunk);
      currentChunk = [x, y];
      if (chunkM == chunkLength) {
        cursor += stride;
      }
      chunkM = 0;
    } else if (chunkM < chunkLength) {
      currentChunk.push(
        flatCoordinates[cursor + stride],
        flatCoordinates[cursor + stride + 1]
      );
      cursor += stride;
    } else {
      const missing = segmentLength - chunkM;
      const x = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.lerp)(x1, x2, missing / segmentLength);
      const y = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.lerp)(y1, y2, missing / segmentLength);
      currentChunk.push(x, y);
      chunks.push(currentChunk);
      currentChunk = [x, y];
      chunkM = 0;
      cursor += stride;
    }
  }
  if (chunkM > 0) {
    chunks.push(currentChunk);
  }
  return chunks;
}


/***/ }),

/***/ "./node_modules/ol/geom/flat/orient.js":
/*!*********************************************!*\
  !*** ./node_modules/ol/geom/flat/orient.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   inflateEnds: () => (/* binding */ inflateEnds),
/* harmony export */   linearRingIsClockwise: () => (/* binding */ linearRingIsClockwise),
/* harmony export */   linearRingsAreOriented: () => (/* binding */ linearRingsAreOriented),
/* harmony export */   linearRingssAreOriented: () => (/* binding */ linearRingssAreOriented),
/* harmony export */   orientLinearRings: () => (/* binding */ orientLinearRings),
/* harmony export */   orientLinearRingsArray: () => (/* binding */ orientLinearRingsArray)
/* harmony export */ });
/* harmony import */ var _reverse_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./reverse.js */ "./node_modules/ol/geom/flat/reverse.js");
/**
 * @module ol/geom/flat/orient
 */


/**
 * Is the linear ring oriented clockwise in a coordinate system with a bottom-left
 * coordinate origin? For a coordinate system with a top-left coordinate origin,
 * the ring's orientation is clockwise when this function returns false.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {boolean} Is clockwise.
 */
function linearRingIsClockwise(flatCoordinates, offset, end, stride) {
  // https://stackoverflow.com/q/1165647/clockwise-method#1165943
  // https://github.com/OSGeo/gdal/blob/master/gdal/ogr/ogrlinearring.cpp
  let edge = 0;
  let x1 = flatCoordinates[end - stride];
  let y1 = flatCoordinates[end - stride + 1];
  for (; offset < end; offset += stride) {
    const x2 = flatCoordinates[offset];
    const y2 = flatCoordinates[offset + 1];
    edge += (x2 - x1) * (y2 + y1);
    x1 = x2;
    y1 = y2;
  }
  return edge === 0 ? undefined : edge > 0;
}

/**
 * Determines if linear rings are oriented.  By default, left-hand orientation
 * is tested (first ring must be clockwise, remaining rings counter-clockwise).
 * To test for right-hand orientation, use the `right` argument.
 *
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Array of end indexes.
 * @param {number} stride Stride.
 * @param {boolean} [right] Test for right-hand orientation
 *     (counter-clockwise exterior ring and clockwise interior rings).
 * @return {boolean} Rings are correctly oriented.
 */
function linearRingsAreOriented(
  flatCoordinates,
  offset,
  ends,
  stride,
  right
) {
  right = right !== undefined ? right : false;
  for (let i = 0, ii = ends.length; i < ii; ++i) {
    const end = ends[i];
    const isClockwise = linearRingIsClockwise(
      flatCoordinates,
      offset,
      end,
      stride
    );
    if (i === 0) {
      if ((right && isClockwise) || (!right && !isClockwise)) {
        return false;
      }
    } else {
      if ((right && !isClockwise) || (!right && isClockwise)) {
        return false;
      }
    }
    offset = end;
  }
  return true;
}

/**
 * Determines if linear rings are oriented.  By default, left-hand orientation
 * is tested (first ring must be clockwise, remaining rings counter-clockwise).
 * To test for right-hand orientation, use the `right` argument.
 *
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Array of array of end indexes.
 * @param {number} stride Stride.
 * @param {boolean} [right] Test for right-hand orientation
 *     (counter-clockwise exterior ring and clockwise interior rings).
 * @return {boolean} Rings are correctly oriented.
 */
function linearRingssAreOriented(
  flatCoordinates,
  offset,
  endss,
  stride,
  right
) {
  for (let i = 0, ii = endss.length; i < ii; ++i) {
    const ends = endss[i];
    if (!linearRingsAreOriented(flatCoordinates, offset, ends, stride, right)) {
      return false;
    }
    if (ends.length) {
      offset = ends[ends.length - 1];
    }
  }
  return true;
}

/**
 * Orient coordinates in a flat array of linear rings.  By default, rings
 * are oriented following the left-hand rule (clockwise for exterior and
 * counter-clockwise for interior rings).  To orient according to the
 * right-hand rule, use the `right` argument.
 *
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {boolean} [right] Follow the right-hand rule for orientation.
 * @return {number} End.
 */
function orientLinearRings(
  flatCoordinates,
  offset,
  ends,
  stride,
  right
) {
  right = right !== undefined ? right : false;
  for (let i = 0, ii = ends.length; i < ii; ++i) {
    const end = ends[i];
    const isClockwise = linearRingIsClockwise(
      flatCoordinates,
      offset,
      end,
      stride
    );
    const reverse =
      i === 0
        ? (right && isClockwise) || (!right && !isClockwise)
        : (right && !isClockwise) || (!right && isClockwise);
    if (reverse) {
      (0,_reverse_js__WEBPACK_IMPORTED_MODULE_0__.coordinates)(flatCoordinates, offset, end, stride);
    }
    offset = end;
  }
  return offset;
}

/**
 * Orient coordinates in a flat array of linear rings.  By default, rings
 * are oriented following the left-hand rule (clockwise for exterior and
 * counter-clockwise for interior rings).  To orient according to the
 * right-hand rule, use the `right` argument.
 *
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Array of array of end indexes.
 * @param {number} stride Stride.
 * @param {boolean} [right] Follow the right-hand rule for orientation.
 * @return {number} End.
 */
function orientLinearRingsArray(
  flatCoordinates,
  offset,
  endss,
  stride,
  right
) {
  for (let i = 0, ii = endss.length; i < ii; ++i) {
    offset = orientLinearRings(
      flatCoordinates,
      offset,
      endss[i],
      stride,
      right
    );
  }
  return offset;
}

/**
 * Return a two-dimensional endss
 * @param {Array<number>} flatCoordinates Flat coordinates
 * @param {Array<number>} ends Linear ring end indexes
 * @return {Array<Array<number>>} Two dimensional endss array that can
 * be used to construct a MultiPolygon
 */
function inflateEnds(flatCoordinates, ends) {
  const endss = [];
  let offset = 0;
  let prevEndIndex = 0;
  for (let i = 0, ii = ends.length; i < ii; ++i) {
    const end = ends[i];
    // classifies an array of rings into polygons with outer rings and holes
    if (!linearRingIsClockwise(flatCoordinates, offset, end, 2)) {
      endss.push(ends.slice(prevEndIndex, i + 1));
    } else {
      if (endss.length === 0) {
        continue;
      }
      endss[endss.length - 1].push(ends[prevEndIndex]);
    }
    prevEndIndex = i + 1;
    offset = end;
  }
  return endss;
}


/***/ }),

/***/ "./node_modules/ol/geom/flat/reverse.js":
/*!**********************************************!*\
  !*** ./node_modules/ol/geom/flat/reverse.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   coordinates: () => (/* binding */ coordinates)
/* harmony export */ });
/**
 * @module ol/geom/flat/reverse
 */

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 */
function coordinates(flatCoordinates, offset, end, stride) {
  while (offset < end - stride) {
    for (let i = 0; i < stride; ++i) {
      const tmp = flatCoordinates[offset + i];
      flatCoordinates[offset + i] = flatCoordinates[end - stride + i];
      flatCoordinates[end - stride + i] = tmp;
    }
    offset += stride;
    end -= stride;
  }
}


/***/ }),

/***/ "./node_modules/ol/geom/flat/segments.js":
/*!***********************************************!*\
  !*** ./node_modules/ol/geom/flat/segments.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   forEach: () => (/* binding */ forEach)
/* harmony export */ });
/**
 * @module ol/geom/flat/segments
 */

/**
 * This function calls `callback` for each segment of the flat coordinates
 * array. If the callback returns a truthy value the function returns that
 * value immediately. Otherwise the function returns `false`.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {function(import("../../coordinate.js").Coordinate, import("../../coordinate.js").Coordinate): T} callback Function
 *     called for each segment.
 * @return {T|boolean} Value.
 * @template T
 */
function forEach(flatCoordinates, offset, end, stride, callback) {
  let ret;
  offset += stride;
  for (; offset < end; offset += stride) {
    ret = callback(
      flatCoordinates.slice(offset - stride, offset),
      flatCoordinates.slice(offset, offset + stride)
    );
    if (ret) {
      return ret;
    }
  }
  return false;
}


/***/ }),

/***/ "./node_modules/ol/geom/flat/simplify.js":
/*!***********************************************!*\
  !*** ./node_modules/ol/geom/flat/simplify.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   douglasPeucker: () => (/* binding */ douglasPeucker),
/* harmony export */   douglasPeuckerArray: () => (/* binding */ douglasPeuckerArray),
/* harmony export */   douglasPeuckerMultiArray: () => (/* binding */ douglasPeuckerMultiArray),
/* harmony export */   quantize: () => (/* binding */ quantize),
/* harmony export */   quantizeArray: () => (/* binding */ quantizeArray),
/* harmony export */   quantizeMultiArray: () => (/* binding */ quantizeMultiArray),
/* harmony export */   radialDistance: () => (/* binding */ radialDistance),
/* harmony export */   simplifyLineString: () => (/* binding */ simplifyLineString),
/* harmony export */   snap: () => (/* binding */ snap)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../math.js */ "./node_modules/ol/math.js");
/**
 * @module ol/geom/flat/simplify
 */
// Based on simplify-js https://github.com/mourner/simplify-js
// Copyright (c) 2012, Vladimir Agafonkin
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//
//    1. Redistributions of source code must retain the above copyright notice,
//       this list of conditions and the following disclaimer.
//
//    2. Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.



/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {boolean} highQuality Highest quality.
 * @param {Array<number>} [simplifiedFlatCoordinates] Simplified flat
 *     coordinates.
 * @return {Array<number>} Simplified line string.
 */
function simplifyLineString(
  flatCoordinates,
  offset,
  end,
  stride,
  squaredTolerance,
  highQuality,
  simplifiedFlatCoordinates
) {
  simplifiedFlatCoordinates =
    simplifiedFlatCoordinates !== undefined ? simplifiedFlatCoordinates : [];
  if (!highQuality) {
    end = radialDistance(
      flatCoordinates,
      offset,
      end,
      stride,
      squaredTolerance,
      simplifiedFlatCoordinates,
      0
    );
    flatCoordinates = simplifiedFlatCoordinates;
    offset = 0;
    stride = 2;
  }
  simplifiedFlatCoordinates.length = douglasPeucker(
    flatCoordinates,
    offset,
    end,
    stride,
    squaredTolerance,
    simplifiedFlatCoordinates,
    0
  );
  return simplifiedFlatCoordinates;
}

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {Array<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @return {number} Simplified offset.
 */
function douglasPeucker(
  flatCoordinates,
  offset,
  end,
  stride,
  squaredTolerance,
  simplifiedFlatCoordinates,
  simplifiedOffset
) {
  const n = (end - offset) / stride;
  if (n < 3) {
    for (; offset < end; offset += stride) {
      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset];
      simplifiedFlatCoordinates[simplifiedOffset++] =
        flatCoordinates[offset + 1];
    }
    return simplifiedOffset;
  }
  /** @type {Array<number>} */
  const markers = new Array(n);
  markers[0] = 1;
  markers[n - 1] = 1;
  /** @type {Array<number>} */
  const stack = [offset, end - stride];
  let index = 0;
  while (stack.length > 0) {
    const last = stack.pop();
    const first = stack.pop();
    let maxSquaredDistance = 0;
    const x1 = flatCoordinates[first];
    const y1 = flatCoordinates[first + 1];
    const x2 = flatCoordinates[last];
    const y2 = flatCoordinates[last + 1];
    for (let i = first + stride; i < last; i += stride) {
      const x = flatCoordinates[i];
      const y = flatCoordinates[i + 1];
      const squaredDistance = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.squaredSegmentDistance)(x, y, x1, y1, x2, y2);
      if (squaredDistance > maxSquaredDistance) {
        index = i;
        maxSquaredDistance = squaredDistance;
      }
    }
    if (maxSquaredDistance > squaredTolerance) {
      markers[(index - offset) / stride] = 1;
      if (first + stride < index) {
        stack.push(first, index);
      }
      if (index + stride < last) {
        stack.push(index, last);
      }
    }
  }
  for (let i = 0; i < n; ++i) {
    if (markers[i]) {
      simplifiedFlatCoordinates[simplifiedOffset++] =
        flatCoordinates[offset + i * stride];
      simplifiedFlatCoordinates[simplifiedOffset++] =
        flatCoordinates[offset + i * stride + 1];
    }
  }
  return simplifiedOffset;
}

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {Array<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @param {Array<number>} simplifiedEnds Simplified ends.
 * @return {number} Simplified offset.
 */
function douglasPeuckerArray(
  flatCoordinates,
  offset,
  ends,
  stride,
  squaredTolerance,
  simplifiedFlatCoordinates,
  simplifiedOffset,
  simplifiedEnds
) {
  for (let i = 0, ii = ends.length; i < ii; ++i) {
    const end = ends[i];
    simplifiedOffset = douglasPeucker(
      flatCoordinates,
      offset,
      end,
      stride,
      squaredTolerance,
      simplifiedFlatCoordinates,
      simplifiedOffset
    );
    simplifiedEnds.push(simplifiedOffset);
    offset = end;
  }
  return simplifiedOffset;
}

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {Array<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @param {Array<Array<number>>} simplifiedEndss Simplified endss.
 * @return {number} Simplified offset.
 */
function douglasPeuckerMultiArray(
  flatCoordinates,
  offset,
  endss,
  stride,
  squaredTolerance,
  simplifiedFlatCoordinates,
  simplifiedOffset,
  simplifiedEndss
) {
  for (let i = 0, ii = endss.length; i < ii; ++i) {
    const ends = endss[i];
    const simplifiedEnds = [];
    simplifiedOffset = douglasPeuckerArray(
      flatCoordinates,
      offset,
      ends,
      stride,
      squaredTolerance,
      simplifiedFlatCoordinates,
      simplifiedOffset,
      simplifiedEnds
    );
    simplifiedEndss.push(simplifiedEnds);
    offset = ends[ends.length - 1];
  }
  return simplifiedOffset;
}

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {Array<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @return {number} Simplified offset.
 */
function radialDistance(
  flatCoordinates,
  offset,
  end,
  stride,
  squaredTolerance,
  simplifiedFlatCoordinates,
  simplifiedOffset
) {
  if (end <= offset + stride) {
    // zero or one point, no simplification possible, so copy and return
    for (; offset < end; offset += stride) {
      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset];
      simplifiedFlatCoordinates[simplifiedOffset++] =
        flatCoordinates[offset + 1];
    }
    return simplifiedOffset;
  }
  let x1 = flatCoordinates[offset];
  let y1 = flatCoordinates[offset + 1];
  // copy first point
  simplifiedFlatCoordinates[simplifiedOffset++] = x1;
  simplifiedFlatCoordinates[simplifiedOffset++] = y1;
  let x2 = x1;
  let y2 = y1;
  for (offset += stride; offset < end; offset += stride) {
    x2 = flatCoordinates[offset];
    y2 = flatCoordinates[offset + 1];
    if ((0,_math_js__WEBPACK_IMPORTED_MODULE_0__.squaredDistance)(x1, y1, x2, y2) > squaredTolerance) {
      // copy point at offset
      simplifiedFlatCoordinates[simplifiedOffset++] = x2;
      simplifiedFlatCoordinates[simplifiedOffset++] = y2;
      x1 = x2;
      y1 = y2;
    }
  }
  if (x2 != x1 || y2 != y1) {
    // copy last point
    simplifiedFlatCoordinates[simplifiedOffset++] = x2;
    simplifiedFlatCoordinates[simplifiedOffset++] = y2;
  }
  return simplifiedOffset;
}

/**
 * @param {number} value Value.
 * @param {number} tolerance Tolerance.
 * @return {number} Rounded value.
 */
function snap(value, tolerance) {
  return tolerance * Math.round(value / tolerance);
}

/**
 * Simplifies a line string using an algorithm designed by Tim Schaub.
 * Coordinates are snapped to the nearest value in a virtual grid and
 * consecutive duplicate coordinates are discarded.  This effectively preserves
 * topology as the simplification of any subsection of a line string is
 * independent of the rest of the line string.  This means that, for examples,
 * the common edge between two polygons will be simplified to the same line
 * string independently in both polygons.  This implementation uses a single
 * pass over the coordinates and eliminates intermediate collinear points.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} tolerance Tolerance.
 * @param {Array<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @return {number} Simplified offset.
 */
function quantize(
  flatCoordinates,
  offset,
  end,
  stride,
  tolerance,
  simplifiedFlatCoordinates,
  simplifiedOffset
) {
  // do nothing if the line is empty
  if (offset == end) {
    return simplifiedOffset;
  }
  // snap the first coordinate (P1)
  let x1 = snap(flatCoordinates[offset], tolerance);
  let y1 = snap(flatCoordinates[offset + 1], tolerance);
  offset += stride;
  // add the first coordinate to the output
  simplifiedFlatCoordinates[simplifiedOffset++] = x1;
  simplifiedFlatCoordinates[simplifiedOffset++] = y1;
  // find the next coordinate that does not snap to the same value as the first
  // coordinate (P2)
  let x2, y2;
  do {
    x2 = snap(flatCoordinates[offset], tolerance);
    y2 = snap(flatCoordinates[offset + 1], tolerance);
    offset += stride;
    if (offset == end) {
      // all coordinates snap to the same value, the line collapses to a point
      // push the last snapped value anyway to ensure that the output contains
      // at least two points
      // FIXME should we really return at least two points anyway?
      simplifiedFlatCoordinates[simplifiedOffset++] = x2;
      simplifiedFlatCoordinates[simplifiedOffset++] = y2;
      return simplifiedOffset;
    }
  } while (x2 == x1 && y2 == y1);
  while (offset < end) {
    // snap the next coordinate (P3)
    const x3 = snap(flatCoordinates[offset], tolerance);
    const y3 = snap(flatCoordinates[offset + 1], tolerance);
    offset += stride;
    // skip P3 if it is equal to P2
    if (x3 == x2 && y3 == y2) {
      continue;
    }
    // calculate the delta between P1 and P2
    const dx1 = x2 - x1;
    const dy1 = y2 - y1;
    // calculate the delta between P3 and P1
    const dx2 = x3 - x1;
    const dy2 = y3 - y1;
    // if P1, P2, and P3 are colinear and P3 is further from P1 than P2 is from
    // P1 in the same direction then P2 is on the straight line between P1 and
    // P3
    if (
      dx1 * dy2 == dy1 * dx2 &&
      ((dx1 < 0 && dx2 < dx1) || dx1 == dx2 || (dx1 > 0 && dx2 > dx1)) &&
      ((dy1 < 0 && dy2 < dy1) || dy1 == dy2 || (dy1 > 0 && dy2 > dy1))
    ) {
      // discard P2 and set P2 = P3
      x2 = x3;
      y2 = y3;
      continue;
    }
    // either P1, P2, and P3 are not colinear, or they are colinear but P3 is
    // between P3 and P1 or on the opposite half of the line to P2.  add P2,
    // and continue with P1 = P2 and P2 = P3
    simplifiedFlatCoordinates[simplifiedOffset++] = x2;
    simplifiedFlatCoordinates[simplifiedOffset++] = y2;
    x1 = x2;
    y1 = y2;
    x2 = x3;
    y2 = y3;
  }
  // add the last point (P2)
  simplifiedFlatCoordinates[simplifiedOffset++] = x2;
  simplifiedFlatCoordinates[simplifiedOffset++] = y2;
  return simplifiedOffset;
}

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {number} tolerance Tolerance.
 * @param {Array<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @param {Array<number>} simplifiedEnds Simplified ends.
 * @return {number} Simplified offset.
 */
function quantizeArray(
  flatCoordinates,
  offset,
  ends,
  stride,
  tolerance,
  simplifiedFlatCoordinates,
  simplifiedOffset,
  simplifiedEnds
) {
  for (let i = 0, ii = ends.length; i < ii; ++i) {
    const end = ends[i];
    simplifiedOffset = quantize(
      flatCoordinates,
      offset,
      end,
      stride,
      tolerance,
      simplifiedFlatCoordinates,
      simplifiedOffset
    );
    simplifiedEnds.push(simplifiedOffset);
    offset = end;
  }
  return simplifiedOffset;
}

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {number} tolerance Tolerance.
 * @param {Array<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @param {Array<Array<number>>} simplifiedEndss Simplified endss.
 * @return {number} Simplified offset.
 */
function quantizeMultiArray(
  flatCoordinates,
  offset,
  endss,
  stride,
  tolerance,
  simplifiedFlatCoordinates,
  simplifiedOffset,
  simplifiedEndss
) {
  for (let i = 0, ii = endss.length; i < ii; ++i) {
    const ends = endss[i];
    const simplifiedEnds = [];
    simplifiedOffset = quantizeArray(
      flatCoordinates,
      offset,
      ends,
      stride,
      tolerance,
      simplifiedFlatCoordinates,
      simplifiedOffset,
      simplifiedEnds
    );
    simplifiedEndss.push(simplifiedEnds);
    offset = ends[ends.length - 1];
  }
  return simplifiedOffset;
}


/***/ }),

/***/ "./node_modules/ol/geom/flat/straightchunk.js":
/*!****************************************************!*\
  !*** ./node_modules/ol/geom/flat/straightchunk.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   matchingChunk: () => (/* binding */ matchingChunk)
/* harmony export */ });
/**
 * @module ol/geom/flat/straightchunk
 */

/**
 * @param {number} maxAngle Maximum acceptable angle delta between segments.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {Array<number>} Start and end of the first suitable chunk of the
 * given `flatCoordinates`.
 */
function matchingChunk(maxAngle, flatCoordinates, offset, end, stride) {
  let chunkStart = offset;
  let chunkEnd = offset;
  let chunkM = 0;
  let m = 0;
  let start = offset;
  let acos, i, m12, m23, x1, y1, x12, y12, x23, y23;
  for (i = offset; i < end; i += stride) {
    const x2 = flatCoordinates[i];
    const y2 = flatCoordinates[i + 1];
    if (x1 !== undefined) {
      x23 = x2 - x1;
      y23 = y2 - y1;
      m23 = Math.sqrt(x23 * x23 + y23 * y23);
      if (x12 !== undefined) {
        m += m12;
        acos = Math.acos((x12 * x23 + y12 * y23) / (m12 * m23));
        if (acos > maxAngle) {
          if (m > chunkM) {
            chunkM = m;
            chunkStart = start;
            chunkEnd = i;
          }
          m = 0;
          start = i - stride;
        }
      }
      m12 = m23;
      x12 = x23;
      y12 = y23;
    }
    x1 = x2;
    y1 = y2;
  }
  m += m23;
  return m > chunkM ? [start, i] : [chunkStart, chunkEnd];
}


/***/ }),

/***/ "./node_modules/ol/geom/flat/textpath.js":
/*!***********************************************!*\
  !*** ./node_modules/ol/geom/flat/textpath.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   drawTextOnPath: () => (/* binding */ drawTextOnPath)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../math.js */ "./node_modules/ol/math.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./transform.js */ "./node_modules/ol/geom/flat/transform.js");
/**
 * @module ol/geom/flat/textpath
 */



/**
 * @param {Array<number>} flatCoordinates Path to put text on.
 * @param {number} offset Start offset of the `flatCoordinates`.
 * @param {number} end End offset of the `flatCoordinates`.
 * @param {number} stride Stride.
 * @param {string} text Text to place on the path.
 * @param {number} startM m along the path where the text starts.
 * @param {number} maxAngle Max angle between adjacent chars in radians.
 * @param {number} scale The product of the text scale and the device pixel ratio.
 * @param {function(string, string, Object<string, number>):number} measureAndCacheTextWidth Measure and cache text width.
 * @param {string} font The font.
 * @param {Object<string, number>} cache A cache of measured widths.
 * @param {number} rotation Rotation to apply to the flatCoordinates to determine whether text needs to be reversed.
 * @return {Array<Array<*>>|null} The result array (or null if `maxAngle` was
 * exceeded). Entries of the array are x, y, anchorX, angle, chunk.
 */
function drawTextOnPath(
  flatCoordinates,
  offset,
  end,
  stride,
  text,
  startM,
  maxAngle,
  scale,
  measureAndCacheTextWidth,
  font,
  cache,
  rotation
) {
  let x2 = flatCoordinates[offset];
  let y2 = flatCoordinates[offset + 1];
  let x1 = 0;
  let y1 = 0;
  let segmentLength = 0;
  let segmentM = 0;

  function advance() {
    x1 = x2;
    y1 = y2;
    offset += stride;
    x2 = flatCoordinates[offset];
    y2 = flatCoordinates[offset + 1];
    segmentM += segmentLength;
    segmentLength = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
  }
  do {
    advance();
  } while (offset < end - stride && segmentM + segmentLength < startM);

  let interpolate =
    segmentLength === 0 ? 0 : (startM - segmentM) / segmentLength;
  const beginX = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.lerp)(x1, x2, interpolate);
  const beginY = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.lerp)(y1, y2, interpolate);

  const startOffset = offset - stride;
  const startLength = segmentM;
  const endM = startM + scale * measureAndCacheTextWidth(font, text, cache);
  while (offset < end - stride && segmentM + segmentLength < endM) {
    advance();
  }
  interpolate = segmentLength === 0 ? 0 : (endM - segmentM) / segmentLength;
  const endX = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.lerp)(x1, x2, interpolate);
  const endY = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.lerp)(y1, y2, interpolate);

  // Keep text upright
  let reverse;
  if (rotation) {
    const flat = [beginX, beginY, endX, endY];
    (0,_transform_js__WEBPACK_IMPORTED_MODULE_1__.rotate)(flat, 0, 4, 2, rotation, flat, flat);
    reverse = flat[0] > flat[2];
  } else {
    reverse = beginX > endX;
  }

  const PI = Math.PI;
  const result = [];
  const singleSegment = startOffset + stride === offset;

  offset = startOffset;
  segmentLength = 0;
  segmentM = startLength;
  x2 = flatCoordinates[offset];
  y2 = flatCoordinates[offset + 1];

  let previousAngle;
  // All on the same segment
  if (singleSegment) {
    advance();

    previousAngle = Math.atan2(y2 - y1, x2 - x1);
    if (reverse) {
      previousAngle += previousAngle > 0 ? -PI : PI;
    }
    const x = (endX + beginX) / 2;
    const y = (endY + beginY) / 2;
    result[0] = [x, y, (endM - startM) / 2, previousAngle, text];
    return result;
  }

  // rendering across line segments
  text = text.replace(/\n/g, ' '); // ensure rendering in single-line as all calculations below don't handle multi-lines

  for (let i = 0, ii = text.length; i < ii; ) {
    advance();
    let angle = Math.atan2(y2 - y1, x2 - x1);
    if (reverse) {
      angle += angle > 0 ? -PI : PI;
    }
    if (previousAngle !== undefined) {
      let delta = angle - previousAngle;
      delta += delta > PI ? -2 * PI : delta < -PI ? 2 * PI : 0;
      if (Math.abs(delta) > maxAngle) {
        return null;
      }
    }
    previousAngle = angle;

    const iStart = i;
    let charLength = 0;
    for (; i < ii; ++i) {
      const index = reverse ? ii - i - 1 : i;
      const len = scale * measureAndCacheTextWidth(font, text[index], cache);
      if (
        offset + stride < end &&
        segmentM + segmentLength < startM + charLength + len / 2
      ) {
        break;
      }
      charLength += len;
    }
    if (i === iStart) {
      continue;
    }
    const chars = reverse
      ? text.substring(ii - iStart, ii - i)
      : text.substring(iStart, i);
    interpolate =
      segmentLength === 0
        ? 0
        : (startM + charLength / 2 - segmentM) / segmentLength;
    const x = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.lerp)(x1, x2, interpolate);
    const y = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.lerp)(y1, y2, interpolate);
    result.push([x, y, charLength / 2, angle, chars]);
    startM += charLength;
  }
  return result;
}


/***/ }),

/***/ "./node_modules/ol/geom/flat/transform.js":
/*!************************************************!*\
  !*** ./node_modules/ol/geom/flat/transform.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   rotate: () => (/* binding */ rotate),
/* harmony export */   scale: () => (/* binding */ scale),
/* harmony export */   transform2D: () => (/* binding */ transform2D),
/* harmony export */   translate: () => (/* binding */ translate)
/* harmony export */ });
/**
 * @module ol/geom/flat/transform
 */

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {import("../../transform.js").Transform} transform Transform.
 * @param {Array<number>} [dest] Destination.
 * @return {Array<number>} Transformed coordinates.
 */
function transform2D(
  flatCoordinates,
  offset,
  end,
  stride,
  transform,
  dest
) {
  dest = dest ? dest : [];
  let i = 0;
  for (let j = offset; j < end; j += stride) {
    const x = flatCoordinates[j];
    const y = flatCoordinates[j + 1];
    dest[i++] = transform[0] * x + transform[2] * y + transform[4];
    dest[i++] = transform[1] * x + transform[3] * y + transform[5];
  }
  if (dest && dest.length != i) {
    dest.length = i;
  }
  return dest;
}

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} angle Angle.
 * @param {Array<number>} anchor Rotation anchor point.
 * @param {Array<number>} [dest] Destination.
 * @return {Array<number>} Transformed coordinates.
 */
function rotate(
  flatCoordinates,
  offset,
  end,
  stride,
  angle,
  anchor,
  dest
) {
  dest = dest ? dest : [];
  const cos = Math.cos(angle);
  const sin = Math.sin(angle);
  const anchorX = anchor[0];
  const anchorY = anchor[1];
  let i = 0;
  for (let j = offset; j < end; j += stride) {
    const deltaX = flatCoordinates[j] - anchorX;
    const deltaY = flatCoordinates[j + 1] - anchorY;
    dest[i++] = anchorX + deltaX * cos - deltaY * sin;
    dest[i++] = anchorY + deltaX * sin + deltaY * cos;
    for (let k = j + 2; k < j + stride; ++k) {
      dest[i++] = flatCoordinates[k];
    }
  }
  if (dest && dest.length != i) {
    dest.length = i;
  }
  return dest;
}

/**
 * Scale the coordinates.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} sx Scale factor in the x-direction.
 * @param {number} sy Scale factor in the y-direction.
 * @param {Array<number>} anchor Scale anchor point.
 * @param {Array<number>} [dest] Destination.
 * @return {Array<number>} Transformed coordinates.
 */
function scale(
  flatCoordinates,
  offset,
  end,
  stride,
  sx,
  sy,
  anchor,
  dest
) {
  dest = dest ? dest : [];
  const anchorX = anchor[0];
  const anchorY = anchor[1];
  let i = 0;
  for (let j = offset; j < end; j += stride) {
    const deltaX = flatCoordinates[j] - anchorX;
    const deltaY = flatCoordinates[j + 1] - anchorY;
    dest[i++] = anchorX + sx * deltaX;
    dest[i++] = anchorY + sy * deltaY;
    for (let k = j + 2; k < j + stride; ++k) {
      dest[i++] = flatCoordinates[k];
    }
  }
  if (dest && dest.length != i) {
    dest.length = i;
  }
  return dest;
}

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} deltaX Delta X.
 * @param {number} deltaY Delta Y.
 * @param {Array<number>} [dest] Destination.
 * @return {Array<number>} Transformed coordinates.
 */
function translate(
  flatCoordinates,
  offset,
  end,
  stride,
  deltaX,
  deltaY,
  dest
) {
  dest = dest ? dest : [];
  let i = 0;
  for (let j = offset; j < end; j += stride) {
    dest[i++] = flatCoordinates[j] + deltaX;
    dest[i++] = flatCoordinates[j + 1] + deltaY;
    for (let k = j + 2; k < j + stride; ++k) {
      dest[i++] = flatCoordinates[k];
    }
  }
  if (dest && dest.length != i) {
    dest.length = i;
  }
  return dest;
}


/***/ }),

/***/ "./node_modules/ol/has.js":
/*!********************************!*\
  !*** ./node_modules/ol/has.js ***!
  \********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CREATE_IMAGE_BITMAP: () => (/* binding */ CREATE_IMAGE_BITMAP),
/* harmony export */   DEVICE_PIXEL_RATIO: () => (/* binding */ DEVICE_PIXEL_RATIO),
/* harmony export */   FIREFOX: () => (/* binding */ FIREFOX),
/* harmony export */   IMAGE_DECODE: () => (/* binding */ IMAGE_DECODE),
/* harmony export */   MAC: () => (/* binding */ MAC),
/* harmony export */   PASSIVE_EVENT_LISTENERS: () => (/* binding */ PASSIVE_EVENT_LISTENERS),
/* harmony export */   SAFARI: () => (/* binding */ SAFARI),
/* harmony export */   SAFARI_BUG_237906: () => (/* binding */ SAFARI_BUG_237906),
/* harmony export */   WEBKIT: () => (/* binding */ WEBKIT),
/* harmony export */   WORKER_OFFSCREEN_CANVAS: () => (/* binding */ WORKER_OFFSCREEN_CANVAS)
/* harmony export */ });
/**
 * @module ol/has
 */

const ua =
  typeof navigator !== 'undefined' && typeof navigator.userAgent !== 'undefined'
    ? navigator.userAgent.toLowerCase()
    : '';

/**
 * User agent string says we are dealing with Firefox as browser.
 * @type {boolean}
 */
const FIREFOX = ua.includes('firefox');

/**
 * User agent string says we are dealing with Safari as browser.
 * @type {boolean}
 */
const SAFARI = ua.includes('safari') && !ua.includes('chrom');

/**
 * https://bugs.webkit.org/show_bug.cgi?id=237906
 * @type {boolean}
 */
const SAFARI_BUG_237906 =
  SAFARI &&
  (ua.includes('version/15.4') ||
    /cpu (os|iphone os) 15_4 like mac os x/.test(ua));

/**
 * User agent string says we are dealing with a WebKit engine.
 * @type {boolean}
 */
const WEBKIT = ua.includes('webkit') && !ua.includes('edge');

/**
 * User agent string says we are dealing with a Mac as platform.
 * @type {boolean}
 */
const MAC = ua.includes('macintosh');

/**
 * The ratio between physical pixels and device-independent pixels
 * (dips) on the device (`window.devicePixelRatio`).
 * @const
 * @type {number}
 * @api
 */
const DEVICE_PIXEL_RATIO =
  typeof devicePixelRatio !== 'undefined' ? devicePixelRatio : 1;

/**
 * The execution context is a worker with OffscreenCanvas available.
 * @const
 * @type {boolean}
 */
const WORKER_OFFSCREEN_CANVAS =
  typeof WorkerGlobalScope !== 'undefined' &&
  typeof OffscreenCanvas !== 'undefined' &&
  self instanceof WorkerGlobalScope; //eslint-disable-line

/**
 * Image.prototype.decode() is supported.
 * @type {boolean}
 */
const IMAGE_DECODE =
  typeof Image !== 'undefined' && Image.prototype.decode;

/**
 * createImageBitmap() is supported.
 * @type {boolean}
 */
const CREATE_IMAGE_BITMAP = typeof createImageBitmap === 'function';

/**
 * @type {boolean}
 */
const PASSIVE_EVENT_LISTENERS = (function () {
  let passive = false;
  try {
    const options = Object.defineProperty({}, 'passive', {
      get: function () {
        passive = true;
      },
    });

    window.addEventListener('_', null, options);
    window.removeEventListener('_', null, options);
  } catch (error) {
    // passive not supported
  }
  return passive;
})();


/***/ }),

/***/ "./node_modules/ol/interaction/DoubleClickZoom.js":
/*!********************************************************!*\
  !*** ./node_modules/ol/interaction/DoubleClickZoom.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Interaction_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Interaction.js */ "./node_modules/ol/interaction/Interaction.js");
/* harmony import */ var _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../MapBrowserEventType.js */ "./node_modules/ol/MapBrowserEventType.js");
/**
 * @module ol/interaction/DoubleClickZoom
 */



/**
 * @typedef {Object} Options
 * @property {number} [duration=250] Animation duration in milliseconds.
 * @property {number} [delta=1] The zoom delta applied on each double click.
 */

/**
 * @classdesc
 * Allows the user to zoom by double-clicking on the map.
 * @api
 */
class DoubleClickZoom extends _Interaction_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {Options} [options] Options.
   */
  constructor(options) {
    super();

    options = options ? options : {};

    /**
     * @private
     * @type {number}
     */
    this.delta_ = options.delta ? options.delta : 1;

    /**
     * @private
     * @type {number}
     */
    this.duration_ = options.duration !== undefined ? options.duration : 250;
  }

  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} (if it was a
   * doubleclick) and eventually zooms the map.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   */
  handleEvent(mapBrowserEvent) {
    let stopEvent = false;
    if (mapBrowserEvent.type == _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].DBLCLICK) {
      const browserEvent = /** @type {MouseEvent} */ (
        mapBrowserEvent.originalEvent
      );
      const map = mapBrowserEvent.map;
      const anchor = mapBrowserEvent.coordinate;
      const delta = browserEvent.shiftKey ? -this.delta_ : this.delta_;
      const view = map.getView();
      (0,_Interaction_js__WEBPACK_IMPORTED_MODULE_0__.zoomByDelta)(view, delta, anchor, this.duration_);
      browserEvent.preventDefault();
      stopEvent = true;
    }
    return !stopEvent;
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DoubleClickZoom);


/***/ }),

/***/ "./node_modules/ol/interaction/DragBox.js":
/*!************************************************!*\
  !*** ./node_modules/ol/interaction/DragBox.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DragBoxEvent: () => (/* binding */ DragBoxEvent),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _events_Event_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../events/Event.js */ "./node_modules/ol/events/Event.js");
/* harmony import */ var _Pointer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Pointer.js */ "./node_modules/ol/interaction/Pointer.js");
/* harmony import */ var _render_Box_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../render/Box.js */ "./node_modules/ol/render/Box.js");
/* harmony import */ var _events_condition_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../events/condition.js */ "./node_modules/ol/events/condition.js");
/**
 * @module ol/interaction/DragBox
 */
// FIXME draw drag box





/**
 * A function that takes a {@link module:ol/MapBrowserEvent~MapBrowserEvent} and two
 * {@link module:ol/pixel~Pixel}s and returns a `{boolean}`. If the condition is met,
 * true should be returned.
 * @typedef {function(this: ?, import("../MapBrowserEvent.js").default, import("../pixel.js").Pixel, import("../pixel.js").Pixel):boolean} EndCondition
 */

/**
 * @typedef {Object} Options
 * @property {string} [className='ol-dragbox'] CSS class name for styling the box.
 * @property {import("../events/condition.js").Condition} [condition] A function that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a boolean
 * to indicate whether that event should be handled.
 * Default is {@link ol/events/condition~mouseActionButton}.
 * @property {number} [minArea=64] The minimum area of the box in pixel, this value is used by the default
 * `boxEndCondition` function.
 * @property {EndCondition} [boxEndCondition] A function that takes a {@link module:ol/MapBrowserEvent~MapBrowserEvent} and two
 * {@link module:ol/pixel~Pixel}s to indicate whether a `boxend` event should be fired.
 * Default is `true` if the area of the box is bigger than the `minArea` option.
 * @property {function(this:DragBox, import("../MapBrowserEvent.js").default):void} [onBoxEnd] Code to execute just
 * before `boxend` is fired.
 */

/**
 * @enum {string}
 */
const DragBoxEventType = {
  /**
   * Triggered upon drag box start.
   * @event DragBoxEvent#boxstart
   * @api
   */
  BOXSTART: 'boxstart',

  /**
   * Triggered on drag when box is active.
   * @event DragBoxEvent#boxdrag
   * @api
   */
  BOXDRAG: 'boxdrag',

  /**
   * Triggered upon drag box end.
   * @event DragBoxEvent#boxend
   * @api
   */
  BOXEND: 'boxend',

  /**
   * Triggered upon drag box canceled.
   * @event DragBoxEvent#boxcancel
   * @api
   */
  BOXCANCEL: 'boxcancel',
};

/**
 * @classdesc
 * Events emitted by {@link module:ol/interaction/DragBox~DragBox} instances are instances of
 * this type.
 */
class DragBoxEvent extends _events_Event_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {string} type The event type.
   * @param {import("../coordinate.js").Coordinate} coordinate The event coordinate.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Originating event.
   */
  constructor(type, coordinate, mapBrowserEvent) {
    super(type);

    /**
     * The coordinate of the drag event.
     * @const
     * @type {import("../coordinate.js").Coordinate}
     * @api
     */
    this.coordinate = coordinate;

    /**
     * @const
     * @type {import("../MapBrowserEvent.js").default}
     * @api
     */
    this.mapBrowserEvent = mapBrowserEvent;
  }
}

/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("../ObjectEventType").Types|
 *     'change:active', import("../Object").ObjectEvent, Return> &
 *   import("../Observable").OnSignature<'boxcancel'|'boxdrag'|'boxend'|'boxstart', DragBoxEvent, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("../ObjectEventType").Types|
 *     'change:active'|'boxcancel'|'boxdrag'|'boxend', Return>} DragBoxOnSignature
 */

/**
 * @classdesc
 * Allows the user to draw a vector box by clicking and dragging on the map,
 * normally combined with an {@link module:ol/events/condition} that limits
 * it to when the shift or other key is held down. This is used, for example,
 * for zooming to a specific area of the map
 * (see {@link module:ol/interaction/DragZoom~DragZoom} and
 * {@link module:ol/interaction/DragRotateAndZoom~DragRotateAndZoom}).
 *
 * @fires DragBoxEvent
 * @api
 */
class DragBox extends _Pointer_js__WEBPACK_IMPORTED_MODULE_1__["default"] {
  /**
   * @param {Options} [options] Options.
   */
  constructor(options) {
    super();

    /***
     * @type {DragBoxOnSignature<import("../events").EventsKey>}
     */
    this.on;

    /***
     * @type {DragBoxOnSignature<import("../events").EventsKey>}
     */
    this.once;

    /***
     * @type {DragBoxOnSignature<void>}
     */
    this.un;

    options = options ? options : {};

    /**
     * @type {import("../render/Box.js").default}
     * @private
     */
    this.box_ = new _render_Box_js__WEBPACK_IMPORTED_MODULE_2__["default"](options.className || 'ol-dragbox');

    /**
     * @type {number}
     * @private
     */
    this.minArea_ = options.minArea !== undefined ? options.minArea : 64;

    if (options.onBoxEnd) {
      this.onBoxEnd = options.onBoxEnd;
    }

    /**
     * @type {import("../pixel.js").Pixel}
     * @private
     */
    this.startPixel_ = null;

    /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */
    this.condition_ = options.condition ? options.condition : _events_condition_js__WEBPACK_IMPORTED_MODULE_3__.mouseActionButton;

    /**
     * @private
     * @type {EndCondition}
     */
    this.boxEndCondition_ = options.boxEndCondition
      ? options.boxEndCondition
      : this.defaultBoxEndCondition;
  }

  /**
   * The default condition for determining whether the boxend event
   * should fire.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent The originating MapBrowserEvent
   *     leading to the box end.
   * @param {import("../pixel.js").Pixel} startPixel The starting pixel of the box.
   * @param {import("../pixel.js").Pixel} endPixel The end pixel of the box.
   * @return {boolean} Whether or not the boxend condition should be fired.
   */
  defaultBoxEndCondition(mapBrowserEvent, startPixel, endPixel) {
    const width = endPixel[0] - startPixel[0];
    const height = endPixel[1] - startPixel[1];
    return width * width + height * height >= this.minArea_;
  }

  /**
   * Returns geometry of last drawn box.
   * @return {import("../geom/Polygon.js").default} Geometry.
   * @api
   */
  getGeometry() {
    return this.box_.getGeometry();
  }

  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   */
  handleDragEvent(mapBrowserEvent) {
    this.box_.setPixels(this.startPixel_, mapBrowserEvent.pixel);

    this.dispatchEvent(
      new DragBoxEvent(
        DragBoxEventType.BOXDRAG,
        mapBrowserEvent.coordinate,
        mapBrowserEvent
      )
    );
  }

  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */
  handleUpEvent(mapBrowserEvent) {
    this.box_.setMap(null);

    const completeBox = this.boxEndCondition_(
      mapBrowserEvent,
      this.startPixel_,
      mapBrowserEvent.pixel
    );
    if (completeBox) {
      this.onBoxEnd(mapBrowserEvent);
    }
    this.dispatchEvent(
      new DragBoxEvent(
        completeBox ? DragBoxEventType.BOXEND : DragBoxEventType.BOXCANCEL,
        mapBrowserEvent.coordinate,
        mapBrowserEvent
      )
    );
    return false;
  }

  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */
  handleDownEvent(mapBrowserEvent) {
    if (this.condition_(mapBrowserEvent)) {
      this.startPixel_ = mapBrowserEvent.pixel;
      this.box_.setMap(mapBrowserEvent.map);
      this.box_.setPixels(this.startPixel_, this.startPixel_);
      this.dispatchEvent(
        new DragBoxEvent(
          DragBoxEventType.BOXSTART,
          mapBrowserEvent.coordinate,
          mapBrowserEvent
        )
      );
      return true;
    }
    return false;
  }

  /**
   * Function to execute just before `onboxend` is fired
   * @param {import("../MapBrowserEvent.js").default} event Event.
   */
  onBoxEnd(event) {}
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DragBox);


/***/ }),

/***/ "./node_modules/ol/interaction/DragPan.js":
/*!************************************************!*\
  !*** ./node_modules/ol/interaction/DragPan.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Pointer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Pointer.js */ "./node_modules/ol/interaction/Pointer.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../functions.js */ "./node_modules/ol/functions.js");
/* harmony import */ var _events_condition_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../events/condition.js */ "./node_modules/ol/events/condition.js");
/* harmony import */ var _easing_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../easing.js */ "./node_modules/ol/easing.js");
/* harmony import */ var _coordinate_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../coordinate.js */ "./node_modules/ol/coordinate.js");
/**
 * @module ol/interaction/DragPan
 */






/**
 * @typedef {Object} Options
 * @property {import("../events/condition.js").Condition} [condition] A function that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a boolean
 * to indicate whether that event should be handled.
 * Default is {@link module:ol/events/condition.noModifierKeys} and {@link module:ol/events/condition.primaryAction}.
 * @property {boolean} [onFocusOnly=false] When the map's target has a `tabindex` attribute set,
 * the interaction will only handle events when the map has the focus.
 * @property {import("../Kinetic.js").default} [kinetic] Kinetic inertia to apply to the pan.
 */

/**
 * @classdesc
 * Allows the user to pan the map by dragging the map.
 * @api
 */
class DragPan extends _Pointer_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {Options} [options] Options.
   */
  constructor(options) {
    super({
      stopDown: _functions_js__WEBPACK_IMPORTED_MODULE_1__.FALSE,
    });

    options = options ? options : {};

    /**
     * @private
     * @type {import("../Kinetic.js").default|undefined}
     */
    this.kinetic_ = options.kinetic;

    /**
     * @type {import("../pixel.js").Pixel}
     */
    this.lastCentroid = null;

    /**
     * @type {number}
     */
    this.lastPointersCount_;

    /**
     * @type {boolean}
     */
    this.panning_ = false;

    const condition = options.condition
      ? options.condition
      : (0,_events_condition_js__WEBPACK_IMPORTED_MODULE_2__.all)(_events_condition_js__WEBPACK_IMPORTED_MODULE_2__.noModifierKeys, _events_condition_js__WEBPACK_IMPORTED_MODULE_2__.primaryAction);

    /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */
    this.condition_ = options.onFocusOnly
      ? (0,_events_condition_js__WEBPACK_IMPORTED_MODULE_2__.all)(_events_condition_js__WEBPACK_IMPORTED_MODULE_2__.focusWithTabindex, condition)
      : condition;

    /**
     * @private
     * @type {boolean}
     */
    this.noKinetic_ = false;
  }

  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   */
  handleDragEvent(mapBrowserEvent) {
    const map = mapBrowserEvent.map;
    if (!this.panning_) {
      this.panning_ = true;
      map.getView().beginInteraction();
    }
    const targetPointers = this.targetPointers;
    const centroid = map.getEventPixel((0,_Pointer_js__WEBPACK_IMPORTED_MODULE_0__.centroid)(targetPointers));
    if (targetPointers.length == this.lastPointersCount_) {
      if (this.kinetic_) {
        this.kinetic_.update(centroid[0], centroid[1]);
      }
      if (this.lastCentroid) {
        const delta = [
          this.lastCentroid[0] - centroid[0],
          centroid[1] - this.lastCentroid[1],
        ];
        const map = mapBrowserEvent.map;
        const view = map.getView();
        (0,_coordinate_js__WEBPACK_IMPORTED_MODULE_3__.scale)(delta, view.getResolution());
        (0,_coordinate_js__WEBPACK_IMPORTED_MODULE_3__.rotate)(delta, view.getRotation());
        view.adjustCenterInternal(delta);
      }
    } else if (this.kinetic_) {
      // reset so we don't overestimate the kinetic energy after
      // after one finger down, tiny drag, second finger down
      this.kinetic_.begin();
    }
    this.lastCentroid = centroid;
    this.lastPointersCount_ = targetPointers.length;
    mapBrowserEvent.originalEvent.preventDefault();
  }

  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */
  handleUpEvent(mapBrowserEvent) {
    const map = mapBrowserEvent.map;
    const view = map.getView();
    if (this.targetPointers.length === 0) {
      if (!this.noKinetic_ && this.kinetic_ && this.kinetic_.end()) {
        const distance = this.kinetic_.getDistance();
        const angle = this.kinetic_.getAngle();
        const center = view.getCenterInternal();
        const centerpx = map.getPixelFromCoordinateInternal(center);
        const dest = map.getCoordinateFromPixelInternal([
          centerpx[0] - distance * Math.cos(angle),
          centerpx[1] - distance * Math.sin(angle),
        ]);
        view.animateInternal({
          center: view.getConstrainedCenter(dest),
          duration: 500,
          easing: _easing_js__WEBPACK_IMPORTED_MODULE_4__.easeOut,
        });
      }
      if (this.panning_) {
        this.panning_ = false;
        view.endInteraction();
      }
      return false;
    }
    if (this.kinetic_) {
      // reset so we don't overestimate the kinetic energy after
      // after one finger up, tiny drag, second finger up
      this.kinetic_.begin();
    }
    this.lastCentroid = null;
    return true;
  }

  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */
  handleDownEvent(mapBrowserEvent) {
    if (this.targetPointers.length > 0 && this.condition_(mapBrowserEvent)) {
      const map = mapBrowserEvent.map;
      const view = map.getView();
      this.lastCentroid = null;
      // stop any current animation
      if (view.getAnimating()) {
        view.cancelAnimations();
      }
      if (this.kinetic_) {
        this.kinetic_.begin();
      }
      // No kinetic as soon as more than one pointer on the screen is
      // detected. This is to prevent nasty pans after pinch.
      this.noKinetic_ = this.targetPointers.length > 1;
      return true;
    }
    return false;
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DragPan);


/***/ }),

/***/ "./node_modules/ol/interaction/DragRotate.js":
/*!***************************************************!*\
  !*** ./node_modules/ol/interaction/DragRotate.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Pointer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Pointer.js */ "./node_modules/ol/interaction/Pointer.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../functions.js */ "./node_modules/ol/functions.js");
/* harmony import */ var _events_condition_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../events/condition.js */ "./node_modules/ol/events/condition.js");
/* harmony import */ var _rotationconstraint_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../rotationconstraint.js */ "./node_modules/ol/rotationconstraint.js");
/**
 * @module ol/interaction/DragRotate
 */





/**
 * @typedef {Object} Options
 * @property {import("../events/condition.js").Condition} [condition] A function that takes an
 * {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a boolean
 * to indicate whether that event should be handled.
 * Default is {@link module:ol/events/condition.altShiftKeysOnly}.
 * @property {number} [duration=250] Animation duration in milliseconds.
 */

/**
 * @classdesc
 * Allows the user to rotate the map by clicking and dragging on the map,
 * normally combined with an {@link module:ol/events/condition} that limits
 * it to when the alt and shift keys are held down.
 *
 * This interaction is only supported for mouse devices.
 * @api
 */
class DragRotate extends _Pointer_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {Options} [options] Options.
   */
  constructor(options) {
    options = options ? options : {};

    super({
      stopDown: _functions_js__WEBPACK_IMPORTED_MODULE_1__.FALSE,
    });

    /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */
    this.condition_ = options.condition ? options.condition : _events_condition_js__WEBPACK_IMPORTED_MODULE_2__.altShiftKeysOnly;

    /**
     * @private
     * @type {number|undefined}
     */
    this.lastAngle_ = undefined;

    /**
     * @private
     * @type {number}
     */
    this.duration_ = options.duration !== undefined ? options.duration : 250;
  }

  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   */
  handleDragEvent(mapBrowserEvent) {
    if (!(0,_events_condition_js__WEBPACK_IMPORTED_MODULE_2__.mouseOnly)(mapBrowserEvent)) {
      return;
    }

    const map = mapBrowserEvent.map;
    const view = map.getView();
    if (view.getConstraints().rotation === _rotationconstraint_js__WEBPACK_IMPORTED_MODULE_3__.disable) {
      return;
    }
    const size = map.getSize();
    const offset = mapBrowserEvent.pixel;
    const theta = Math.atan2(size[1] / 2 - offset[1], offset[0] - size[0] / 2);
    if (this.lastAngle_ !== undefined) {
      const delta = theta - this.lastAngle_;
      view.adjustRotationInternal(-delta);
    }
    this.lastAngle_ = theta;
  }

  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */
  handleUpEvent(mapBrowserEvent) {
    if (!(0,_events_condition_js__WEBPACK_IMPORTED_MODULE_2__.mouseOnly)(mapBrowserEvent)) {
      return true;
    }

    const map = mapBrowserEvent.map;
    const view = map.getView();
    view.endInteraction(this.duration_);
    return false;
  }

  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */
  handleDownEvent(mapBrowserEvent) {
    if (!(0,_events_condition_js__WEBPACK_IMPORTED_MODULE_2__.mouseOnly)(mapBrowserEvent)) {
      return false;
    }

    if (
      (0,_events_condition_js__WEBPACK_IMPORTED_MODULE_2__.mouseActionButton)(mapBrowserEvent) &&
      this.condition_(mapBrowserEvent)
    ) {
      const map = mapBrowserEvent.map;
      map.getView().beginInteraction();
      this.lastAngle_ = undefined;
      return true;
    }
    return false;
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DragRotate);


/***/ }),

/***/ "./node_modules/ol/interaction/DragZoom.js":
/*!*************************************************!*\
  !*** ./node_modules/ol/interaction/DragZoom.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _DragBox_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DragBox.js */ "./node_modules/ol/interaction/DragBox.js");
/* harmony import */ var _easing_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../easing.js */ "./node_modules/ol/easing.js");
/* harmony import */ var _events_condition_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../events/condition.js */ "./node_modules/ol/events/condition.js");
/**
 * @module ol/interaction/DragZoom
 */




/**
 * @typedef {Object} Options
 * @property {string} [className='ol-dragzoom'] CSS class name for styling the
 * box.
 * @property {import("../events/condition.js").Condition} [condition] A function that
 * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled.
 * Default is {@link module:ol/events/condition.shiftKeyOnly}.
 * @property {number} [duration=200] Animation duration in milliseconds.
 * @property {boolean} [out=false] Use interaction for zooming out.
 * @property {number} [minArea=64] The minimum area of the box in pixel, this value is used by the parent default
 * `boxEndCondition` function.
 */

/**
 * @classdesc
 * Allows the user to zoom the map by clicking and dragging on the map,
 * normally combined with an {@link module:ol/events/condition} that limits
 * it to when a key, shift by default, is held down.
 *
 * To change the style of the box, use CSS and the `.ol-dragzoom` selector, or
 * your custom one configured with `className`.
 * @api
 */
class DragZoom extends _DragBox_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {Options} [options] Options.
   */
  constructor(options) {
    options = options ? options : {};

    const condition = options.condition ? options.condition : _events_condition_js__WEBPACK_IMPORTED_MODULE_1__.shiftKeyOnly;

    super({
      condition: condition,
      className: options.className || 'ol-dragzoom',
      minArea: options.minArea,
    });

    /**
     * @private
     * @type {number}
     */
    this.duration_ = options.duration !== undefined ? options.duration : 200;

    /**
     * @private
     * @type {boolean}
     */
    this.out_ = options.out !== undefined ? options.out : false;
  }

  /**
   * Function to execute just before `onboxend` is fired
   * @param {import("../MapBrowserEvent.js").default} event Event.
   */
  onBoxEnd(event) {
    const map = this.getMap();
    const view = /** @type {!import("../View.js").default} */ (map.getView());
    let geometry = this.getGeometry();

    if (this.out_) {
      const rotatedExtent = view.rotatedExtentForGeometry(geometry);
      const resolution = view.getResolutionForExtentInternal(rotatedExtent);
      const factor = view.getResolution() / resolution;
      geometry = geometry.clone();
      geometry.scale(factor * factor);
    }

    view.fitInternal(geometry, {
      duration: this.duration_,
      easing: _easing_js__WEBPACK_IMPORTED_MODULE_2__.easeOut,
    });
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DragZoom);


/***/ }),

/***/ "./node_modules/ol/interaction/Interaction.js":
/*!****************************************************!*\
  !*** ./node_modules/ol/interaction/Interaction.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   pan: () => (/* binding */ pan),
/* harmony export */   zoomByDelta: () => (/* binding */ zoomByDelta)
/* harmony export */ });
/* harmony import */ var _Object_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Object.js */ "./node_modules/ol/Object.js");
/* harmony import */ var _Property_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Property.js */ "./node_modules/ol/interaction/Property.js");
/* harmony import */ var _easing_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../easing.js */ "./node_modules/ol/easing.js");
/**
 * @module ol/interaction/Interaction
 */




/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("../ObjectEventType").Types|
 *     'change:active', import("../Object").ObjectEvent, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("../ObjectEventType").Types|
 *     'change:active', Return>} InteractionOnSignature
 */

/**
 * Object literal with config options for interactions.
 * @typedef {Object} InteractionOptions
 * @property {function(import("../MapBrowserEvent.js").default):boolean} handleEvent
 * Method called by the map to notify the interaction that a browser event was
 * dispatched to the map. If the function returns a falsy value, propagation of
 * the event to other interactions in the map's interactions chain will be
 * prevented (this includes functions with no explicit return). The interactions
 * are traversed in reverse order of the interactions collection of the map.
 */

/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * User actions that change the state of the map. Some are similar to controls,
 * but are not associated with a DOM element.
 * For example, {@link module:ol/interaction/KeyboardZoom~KeyboardZoom} is
 * functionally the same as {@link module:ol/control/Zoom~Zoom}, but triggered
 * by a keyboard event not a button element event.
 * Although interactions do not have a DOM element, some of them do render
 * vectors and so are visible on the screen.
 * @api
 */
class Interaction extends _Object_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {InteractionOptions} [options] Options.
   */
  constructor(options) {
    super();

    /***
     * @type {InteractionOnSignature<import("../events").EventsKey>}
     */
    this.on;

    /***
     * @type {InteractionOnSignature<import("../events").EventsKey>}
     */
    this.once;

    /***
     * @type {InteractionOnSignature<void>}
     */
    this.un;

    if (options && options.handleEvent) {
      this.handleEvent = options.handleEvent;
    }

    /**
     * @private
     * @type {import("../Map.js").default|null}
     */
    this.map_ = null;

    this.setActive(true);
  }

  /**
   * Return whether the interaction is currently active.
   * @return {boolean} `true` if the interaction is active, `false` otherwise.
   * @observable
   * @api
   */
  getActive() {
    return /** @type {boolean} */ (this.get(_Property_js__WEBPACK_IMPORTED_MODULE_1__["default"].ACTIVE));
  }

  /**
   * Get the map associated with this interaction.
   * @return {import("../Map.js").default|null} Map.
   * @api
   */
  getMap() {
    return this.map_;
  }

  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event}.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   * @api
   */
  handleEvent(mapBrowserEvent) {
    return true;
  }

  /**
   * Activate or deactivate the interaction.
   * @param {boolean} active Active.
   * @observable
   * @api
   */
  setActive(active) {
    this.set(_Property_js__WEBPACK_IMPORTED_MODULE_1__["default"].ACTIVE, active);
  }

  /**
   * Remove the interaction from its current map and attach it to the new map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {import("../Map.js").default|null} map Map.
   */
  setMap(map) {
    this.map_ = map;
  }
}

/**
 * @param {import("../View.js").default} view View.
 * @param {import("../coordinate.js").Coordinate} delta Delta.
 * @param {number} [duration] Duration.
 */
function pan(view, delta, duration) {
  const currentCenter = view.getCenterInternal();
  if (currentCenter) {
    const center = [currentCenter[0] + delta[0], currentCenter[1] + delta[1]];
    view.animateInternal({
      duration: duration !== undefined ? duration : 250,
      easing: _easing_js__WEBPACK_IMPORTED_MODULE_2__.linear,
      center: view.getConstrainedCenter(center),
    });
  }
}

/**
 * @param {import("../View.js").default} view View.
 * @param {number} delta Delta from previous zoom level.
 * @param {import("../coordinate.js").Coordinate} [anchor] Anchor coordinate in the user projection.
 * @param {number} [duration] Duration.
 */
function zoomByDelta(view, delta, anchor, duration) {
  const currentZoom = view.getZoom();

  if (currentZoom === undefined) {
    return;
  }

  const newZoom = view.getConstrainedZoom(currentZoom + delta);
  const newResolution = view.getResolutionForZoom(newZoom);

  if (view.getAnimating()) {
    view.cancelAnimations();
  }
  view.animate({
    resolution: newResolution,
    anchor: anchor,
    duration: duration !== undefined ? duration : 250,
    easing: _easing_js__WEBPACK_IMPORTED_MODULE_2__.easeOut,
  });
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Interaction);


/***/ }),

/***/ "./node_modules/ol/interaction/KeyboardPan.js":
/*!****************************************************!*\
  !*** ./node_modules/ol/interaction/KeyboardPan.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../events/EventType.js */ "./node_modules/ol/events/EventType.js");
/* harmony import */ var _Interaction_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Interaction.js */ "./node_modules/ol/interaction/Interaction.js");
/* harmony import */ var _events_Key_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../events/Key.js */ "./node_modules/ol/events/Key.js");
/* harmony import */ var _events_condition_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../events/condition.js */ "./node_modules/ol/events/condition.js");
/* harmony import */ var _coordinate_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../coordinate.js */ "./node_modules/ol/coordinate.js");
/**
 * @module ol/interaction/KeyboardPan
 */






/**
 * @typedef {Object} Options
 * @property {import("../events/condition.js").Condition} [condition] A function that
 * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled. Default is
 * {@link module:ol/events/condition.noModifierKeys} and
 * {@link module:ol/events/condition.targetNotEditable}.
 * @property {number} [duration=100] Animation duration in milliseconds.
 * @property {number} [pixelDelta=128] The amount of pixels to pan on each key
 * press.
 */

/**
 * @classdesc
 * Allows the user to pan the map using keyboard arrows.
 * Note that, although this interaction is by default included in maps,
 * the keys can only be used when browser focus is on the element to which
 * the keyboard events are attached. By default, this is the map div,
 * though you can change this with the `keyboardEventTarget` in
 * {@link module:ol/Map~Map}. `document` never loses focus but, for any other
 * element, focus will have to be on, and returned to, this element if the keys
 * are to function.
 * See also {@link module:ol/interaction/KeyboardZoom~KeyboardZoom}.
 * @api
 */
class KeyboardPan extends _Interaction_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {Options} [options] Options.
   */
  constructor(options) {
    super();

    options = options || {};

    /**
     * @private
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Browser event.
     * @return {boolean} Combined condition result.
     */
    this.defaultCondition_ = function (mapBrowserEvent) {
      return (
        (0,_events_condition_js__WEBPACK_IMPORTED_MODULE_1__.noModifierKeys)(mapBrowserEvent) && (0,_events_condition_js__WEBPACK_IMPORTED_MODULE_1__.targetNotEditable)(mapBrowserEvent)
      );
    };

    /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */
    this.condition_ =
      options.condition !== undefined
        ? options.condition
        : this.defaultCondition_;

    /**
     * @private
     * @type {number}
     */
    this.duration_ = options.duration !== undefined ? options.duration : 100;

    /**
     * @private
     * @type {number}
     */
    this.pixelDelta_ =
      options.pixelDelta !== undefined ? options.pixelDelta : 128;
  }

  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} if it was a
   * `KeyEvent`, and decides the direction to pan to (if an arrow key was
   * pressed).
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   */
  handleEvent(mapBrowserEvent) {
    let stopEvent = false;
    if (mapBrowserEvent.type == _events_EventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].KEYDOWN) {
      const keyEvent = /** @type {KeyboardEvent} */ (
        mapBrowserEvent.originalEvent
      );
      const key = keyEvent.key;
      if (
        this.condition_(mapBrowserEvent) &&
        (key == _events_Key_js__WEBPACK_IMPORTED_MODULE_3__["default"].DOWN ||
          key == _events_Key_js__WEBPACK_IMPORTED_MODULE_3__["default"].LEFT ||
          key == _events_Key_js__WEBPACK_IMPORTED_MODULE_3__["default"].RIGHT ||
          key == _events_Key_js__WEBPACK_IMPORTED_MODULE_3__["default"].UP)
      ) {
        const map = mapBrowserEvent.map;
        const view = map.getView();
        const mapUnitsDelta = view.getResolution() * this.pixelDelta_;
        let deltaX = 0,
          deltaY = 0;
        if (key == _events_Key_js__WEBPACK_IMPORTED_MODULE_3__["default"].DOWN) {
          deltaY = -mapUnitsDelta;
        } else if (key == _events_Key_js__WEBPACK_IMPORTED_MODULE_3__["default"].LEFT) {
          deltaX = -mapUnitsDelta;
        } else if (key == _events_Key_js__WEBPACK_IMPORTED_MODULE_3__["default"].RIGHT) {
          deltaX = mapUnitsDelta;
        } else {
          deltaY = mapUnitsDelta;
        }
        const delta = [deltaX, deltaY];
        (0,_coordinate_js__WEBPACK_IMPORTED_MODULE_4__.rotate)(delta, view.getRotation());
        (0,_Interaction_js__WEBPACK_IMPORTED_MODULE_0__.pan)(view, delta, this.duration_);
        keyEvent.preventDefault();
        stopEvent = true;
      }
    }
    return !stopEvent;
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (KeyboardPan);


/***/ }),

/***/ "./node_modules/ol/interaction/KeyboardZoom.js":
/*!*****************************************************!*\
  !*** ./node_modules/ol/interaction/KeyboardZoom.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../events/EventType.js */ "./node_modules/ol/events/EventType.js");
/* harmony import */ var _Interaction_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Interaction.js */ "./node_modules/ol/interaction/Interaction.js");
/* harmony import */ var _events_condition_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../events/condition.js */ "./node_modules/ol/events/condition.js");
/**
 * @module ol/interaction/KeyboardZoom
 */




/**
 * @typedef {Object} Options
 * @property {number} [duration=100] Animation duration in milliseconds.
 * @property {import("../events/condition.js").Condition} [condition] A function that
 * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled. The default condition is
 * that {@link module:ol/events/condition.targetNotEditable} is fulfilled and that
 * the platform modifier key isn't pressed
 * (!{@link module:ol/events/condition.platformModifierKey}).
 * @property {number} [delta=1] The zoom level delta on each key press.
 */

/**
 * @classdesc
 * Allows the user to zoom the map using keyboard + and -.
 * Note that, although this interaction is by default included in maps,
 * the keys can only be used when browser focus is on the element to which
 * the keyboard events are attached. By default, this is the map div,
 * though you can change this with the `keyboardEventTarget` in
 * {@link module:ol/Map~Map}. `document` never loses focus but, for any other
 * element, focus will have to be on, and returned to, this element if the keys
 * are to function.
 * See also {@link module:ol/interaction/KeyboardPan~KeyboardPan}.
 * @api
 */
class KeyboardZoom extends _Interaction_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {Options} [options] Options.
   */
  constructor(options) {
    super();

    options = options ? options : {};

    /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */
    this.condition_ = options.condition
      ? options.condition
      : function (mapBrowserEvent) {
          return (
            !(0,_events_condition_js__WEBPACK_IMPORTED_MODULE_1__.platformModifierKey)(mapBrowserEvent) &&
            (0,_events_condition_js__WEBPACK_IMPORTED_MODULE_1__.targetNotEditable)(mapBrowserEvent)
          );
        };

    /**
     * @private
     * @type {number}
     */
    this.delta_ = options.delta ? options.delta : 1;

    /**
     * @private
     * @type {number}
     */
    this.duration_ = options.duration !== undefined ? options.duration : 100;
  }

  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} if it was a
   * `KeyEvent`, and decides whether to zoom in or out (depending on whether the
   * key pressed was '+' or '-').
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   */
  handleEvent(mapBrowserEvent) {
    let stopEvent = false;
    if (
      mapBrowserEvent.type == _events_EventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].KEYDOWN ||
      mapBrowserEvent.type == _events_EventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].KEYPRESS
    ) {
      const keyEvent = /** @type {KeyboardEvent} */ (
        mapBrowserEvent.originalEvent
      );
      const key = keyEvent.key;
      if (this.condition_(mapBrowserEvent) && (key === '+' || key === '-')) {
        const map = mapBrowserEvent.map;
        const delta = key === '+' ? this.delta_ : -this.delta_;
        const view = map.getView();
        (0,_Interaction_js__WEBPACK_IMPORTED_MODULE_0__.zoomByDelta)(view, delta, undefined, this.duration_);
        keyEvent.preventDefault();
        stopEvent = true;
      }
    }
    return !stopEvent;
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (KeyboardZoom);


/***/ }),

/***/ "./node_modules/ol/interaction/MouseWheelZoom.js":
/*!*******************************************************!*\
  !*** ./node_modules/ol/interaction/MouseWheelZoom.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../events/EventType.js */ "./node_modules/ol/events/EventType.js");
/* harmony import */ var _Interaction_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Interaction.js */ "./node_modules/ol/interaction/Interaction.js");
/* harmony import */ var _has_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../has.js */ "./node_modules/ol/has.js");
/* harmony import */ var _events_condition_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../events/condition.js */ "./node_modules/ol/events/condition.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../math.js */ "./node_modules/ol/math.js");
/**
 * @module ol/interaction/MouseWheelZoom
 */






/**
 * @typedef {'trackpad' | 'wheel'} Mode
 */

/**
 * @typedef {Object} Options
 * @property {import("../events/condition.js").Condition} [condition] A function that
 * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled. Default is
 * {@link module:ol/events/condition.always}.
 * @property {boolean} [onFocusOnly=false] When the map's target has a `tabindex` attribute set,
 * the interaction will only handle events when the map has the focus.
 * @property {number} [maxDelta=1] Maximum mouse wheel delta.
 * @property {number} [duration=250] Animation duration in milliseconds.
 * @property {number} [timeout=80] Mouse wheel timeout duration in milliseconds.
 * @property {boolean} [useAnchor=true] Enable zooming using the mouse's
 * location as the anchor. When set to `false`, zooming in and out will zoom to
 * the center of the screen instead of zooming on the mouse's location.
 * @property {boolean} [constrainResolution=false] If true, the mouse wheel zoom
 * event will always animate to the closest zoom level after an interaction;
 * false means intermediary zoom levels are allowed.
 */

/**
 * @classdesc
 * Allows the user to zoom the map by scrolling the mouse wheel.
 * @api
 */
class MouseWheelZoom extends _Interaction_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {Options} [options] Options.
   */
  constructor(options) {
    options = options ? options : {};

    super(
      /** @type {import("./Interaction.js").InteractionOptions} */ (options)
    );

    /**
     * @private
     * @type {number}
     */
    this.totalDelta_ = 0;

    /**
     * @private
     * @type {number}
     */
    this.lastDelta_ = 0;

    /**
     * @private
     * @type {number}
     */
    this.maxDelta_ = options.maxDelta !== undefined ? options.maxDelta : 1;

    /**
     * @private
     * @type {number}
     */
    this.duration_ = options.duration !== undefined ? options.duration : 250;

    /**
     * @private
     * @type {number}
     */
    this.timeout_ = options.timeout !== undefined ? options.timeout : 80;

    /**
     * @private
     * @type {boolean}
     */
    this.useAnchor_ =
      options.useAnchor !== undefined ? options.useAnchor : true;

    /**
     * @private
     * @type {boolean}
     */
    this.constrainResolution_ =
      options.constrainResolution !== undefined
        ? options.constrainResolution
        : false;

    const condition = options.condition ? options.condition : _events_condition_js__WEBPACK_IMPORTED_MODULE_1__.always;

    /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */
    this.condition_ = options.onFocusOnly
      ? (0,_events_condition_js__WEBPACK_IMPORTED_MODULE_1__.all)(_events_condition_js__WEBPACK_IMPORTED_MODULE_1__.focusWithTabindex, condition)
      : condition;

    /**
     * @private
     * @type {?import("../coordinate.js").Coordinate}
     */
    this.lastAnchor_ = null;

    /**
     * @private
     * @type {number|undefined}
     */
    this.startTime_ = undefined;

    /**
     * @private
     * @type {ReturnType<typeof setTimeout>}
     */
    this.timeoutId_;

    /**
     * @private
     * @type {Mode|undefined}
     */
    this.mode_ = undefined;

    /**
     * Trackpad events separated by this delay will be considered separate
     * interactions.
     * @private
     * @type {number}
     */
    this.trackpadEventGap_ = 400;

    /**
     * @private
     * @type {ReturnType<typeof setTimeout>}
     */
    this.trackpadTimeoutId_;

    /**
     * The number of delta values per zoom level
     * @private
     * @type {number}
     */
    this.deltaPerZoom_ = 300;
  }

  /**
   * @private
   */
  endInteraction_() {
    this.trackpadTimeoutId_ = undefined;
    const map = this.getMap();
    if (!map) {
      return;
    }
    const view = map.getView();
    view.endInteraction(
      undefined,
      this.lastDelta_ ? (this.lastDelta_ > 0 ? 1 : -1) : 0,
      this.lastAnchor_
    );
  }

  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} (if it was a mousewheel-event) and eventually
   * zooms the map.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   */
  handleEvent(mapBrowserEvent) {
    if (!this.condition_(mapBrowserEvent)) {
      return true;
    }
    const type = mapBrowserEvent.type;
    if (type !== _events_EventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].WHEEL) {
      return true;
    }

    const map = mapBrowserEvent.map;
    const wheelEvent = /** @type {WheelEvent} */ (
      mapBrowserEvent.originalEvent
    );
    wheelEvent.preventDefault();

    if (this.useAnchor_) {
      this.lastAnchor_ = mapBrowserEvent.coordinate;
    }

    // Delta normalisation inspired by
    // https://github.com/mapbox/mapbox-gl-js/blob/001c7b9/js/ui/handler/scroll_zoom.js
    let delta;
    if (mapBrowserEvent.type == _events_EventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].WHEEL) {
      delta = wheelEvent.deltaY;
      if (_has_js__WEBPACK_IMPORTED_MODULE_3__.FIREFOX && wheelEvent.deltaMode === WheelEvent.DOM_DELTA_PIXEL) {
        delta /= _has_js__WEBPACK_IMPORTED_MODULE_3__.DEVICE_PIXEL_RATIO;
      }
      if (wheelEvent.deltaMode === WheelEvent.DOM_DELTA_LINE) {
        delta *= 40;
      }
    }

    if (delta === 0) {
      return false;
    }
    this.lastDelta_ = delta;

    const now = Date.now();

    if (this.startTime_ === undefined) {
      this.startTime_ = now;
    }

    if (!this.mode_ || now - this.startTime_ > this.trackpadEventGap_) {
      this.mode_ = Math.abs(delta) < 4 ? 'trackpad' : 'wheel';
    }

    const view = map.getView();
    if (
      this.mode_ === 'trackpad' &&
      !(view.getConstrainResolution() || this.constrainResolution_)
    ) {
      if (this.trackpadTimeoutId_) {
        clearTimeout(this.trackpadTimeoutId_);
      } else {
        if (view.getAnimating()) {
          view.cancelAnimations();
        }
        view.beginInteraction();
      }
      this.trackpadTimeoutId_ = setTimeout(
        this.endInteraction_.bind(this),
        this.timeout_
      );
      view.adjustZoom(-delta / this.deltaPerZoom_, this.lastAnchor_);
      this.startTime_ = now;
      return false;
    }

    this.totalDelta_ += delta;

    const timeLeft = Math.max(this.timeout_ - (now - this.startTime_), 0);

    clearTimeout(this.timeoutId_);
    this.timeoutId_ = setTimeout(
      this.handleWheelZoom_.bind(this, map),
      timeLeft
    );

    return false;
  }

  /**
   * @private
   * @param {import("../Map.js").default} map Map.
   */
  handleWheelZoom_(map) {
    const view = map.getView();
    if (view.getAnimating()) {
      view.cancelAnimations();
    }
    let delta =
      -(0,_math_js__WEBPACK_IMPORTED_MODULE_4__.clamp)(
        this.totalDelta_,
        -this.maxDelta_ * this.deltaPerZoom_,
        this.maxDelta_ * this.deltaPerZoom_
      ) / this.deltaPerZoom_;
    if (view.getConstrainResolution() || this.constrainResolution_) {
      // view has a zoom constraint, zoom by 1
      delta = delta ? (delta > 0 ? 1 : -1) : 0;
    }
    (0,_Interaction_js__WEBPACK_IMPORTED_MODULE_0__.zoomByDelta)(view, delta, this.lastAnchor_, this.duration_);

    this.mode_ = undefined;
    this.totalDelta_ = 0;
    this.lastAnchor_ = null;
    this.startTime_ = undefined;
    this.timeoutId_ = undefined;
  }

  /**
   * Enable or disable using the mouse's location as an anchor when zooming
   * @param {boolean} useAnchor true to zoom to the mouse's location, false
   * to zoom to the center of the map
   * @api
   */
  setMouseAnchor(useAnchor) {
    this.useAnchor_ = useAnchor;
    if (!useAnchor) {
      this.lastAnchor_ = null;
    }
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (MouseWheelZoom);


/***/ }),

/***/ "./node_modules/ol/interaction/PinchRotate.js":
/*!****************************************************!*\
  !*** ./node_modules/ol/interaction/PinchRotate.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Pointer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Pointer.js */ "./node_modules/ol/interaction/Pointer.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../functions.js */ "./node_modules/ol/functions.js");
/* harmony import */ var _rotationconstraint_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../rotationconstraint.js */ "./node_modules/ol/rotationconstraint.js");
/**
 * @module ol/interaction/PinchRotate
 */




/**
 * @typedef {Object} Options
 * @property {number} [duration=250] The duration of the animation in
 * milliseconds.
 * @property {number} [threshold=0.3] Minimal angle in radians to start a rotation.
 */

/**
 * @classdesc
 * Allows the user to rotate the map by twisting with two fingers
 * on a touch screen.
 * @api
 */
class PinchRotate extends _Pointer_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {Options} [options] Options.
   */
  constructor(options) {
    options = options ? options : {};

    const pointerOptions = /** @type {import("./Pointer.js").Options} */ (
      options
    );

    if (!pointerOptions.stopDown) {
      pointerOptions.stopDown = _functions_js__WEBPACK_IMPORTED_MODULE_1__.FALSE;
    }

    super(pointerOptions);

    /**
     * @private
     * @type {import("../coordinate.js").Coordinate}
     */
    this.anchor_ = null;

    /**
     * @private
     * @type {number|undefined}
     */
    this.lastAngle_ = undefined;

    /**
     * @private
     * @type {boolean}
     */
    this.rotating_ = false;

    /**
     * @private
     * @type {number}
     */
    this.rotationDelta_ = 0.0;

    /**
     * @private
     * @type {number}
     */
    this.threshold_ = options.threshold !== undefined ? options.threshold : 0.3;

    /**
     * @private
     * @type {number}
     */
    this.duration_ = options.duration !== undefined ? options.duration : 250;
  }

  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   */
  handleDragEvent(mapBrowserEvent) {
    let rotationDelta = 0.0;

    const touch0 = this.targetPointers[0];
    const touch1 = this.targetPointers[1];

    // angle between touches
    const angle = Math.atan2(
      touch1.clientY - touch0.clientY,
      touch1.clientX - touch0.clientX
    );

    if (this.lastAngle_ !== undefined) {
      const delta = angle - this.lastAngle_;
      this.rotationDelta_ += delta;
      if (!this.rotating_ && Math.abs(this.rotationDelta_) > this.threshold_) {
        this.rotating_ = true;
      }
      rotationDelta = delta;
    }
    this.lastAngle_ = angle;

    const map = mapBrowserEvent.map;
    const view = map.getView();
    if (view.getConstraints().rotation === _rotationconstraint_js__WEBPACK_IMPORTED_MODULE_2__.disable) {
      return;
    }

    // rotate anchor point.
    // FIXME: should be the intersection point between the lines:
    //     touch0,touch1 and previousTouch0,previousTouch1
    this.anchor_ = map.getCoordinateFromPixelInternal(
      map.getEventPixel((0,_Pointer_js__WEBPACK_IMPORTED_MODULE_0__.centroid)(this.targetPointers))
    );

    // rotate
    if (this.rotating_) {
      map.render();
      view.adjustRotationInternal(rotationDelta, this.anchor_);
    }
  }

  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */
  handleUpEvent(mapBrowserEvent) {
    if (this.targetPointers.length < 2) {
      const map = mapBrowserEvent.map;
      const view = map.getView();
      view.endInteraction(this.duration_);
      return false;
    }
    return true;
  }

  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */
  handleDownEvent(mapBrowserEvent) {
    if (this.targetPointers.length >= 2) {
      const map = mapBrowserEvent.map;
      this.anchor_ = null;
      this.lastAngle_ = undefined;
      this.rotating_ = false;
      this.rotationDelta_ = 0.0;
      if (!this.handlingDownUpSequence) {
        map.getView().beginInteraction();
      }
      return true;
    }
    return false;
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (PinchRotate);


/***/ }),

/***/ "./node_modules/ol/interaction/PinchZoom.js":
/*!**************************************************!*\
  !*** ./node_modules/ol/interaction/PinchZoom.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Pointer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Pointer.js */ "./node_modules/ol/interaction/Pointer.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../functions.js */ "./node_modules/ol/functions.js");
/**
 * @module ol/interaction/PinchZoom
 */



/**
 * @typedef {Object} Options
 * @property {number} [duration=400] Animation duration in milliseconds.
 */

/**
 * @classdesc
 * Allows the user to zoom the map by pinching with two fingers
 * on a touch screen.
 * @api
 */
class PinchZoom extends _Pointer_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {Options} [options] Options.
   */
  constructor(options) {
    options = options ? options : {};

    const pointerOptions = /** @type {import("./Pointer.js").Options} */ (
      options
    );

    if (!pointerOptions.stopDown) {
      pointerOptions.stopDown = _functions_js__WEBPACK_IMPORTED_MODULE_1__.FALSE;
    }

    super(pointerOptions);

    /**
     * @private
     * @type {import("../coordinate.js").Coordinate}
     */
    this.anchor_ = null;

    /**
     * @private
     * @type {number}
     */
    this.duration_ = options.duration !== undefined ? options.duration : 400;

    /**
     * @private
     * @type {number|undefined}
     */
    this.lastDistance_ = undefined;

    /**
     * @private
     * @type {number}
     */
    this.lastScaleDelta_ = 1;
  }

  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   */
  handleDragEvent(mapBrowserEvent) {
    let scaleDelta = 1.0;

    const touch0 = this.targetPointers[0];
    const touch1 = this.targetPointers[1];
    const dx = touch0.clientX - touch1.clientX;
    const dy = touch0.clientY - touch1.clientY;

    // distance between touches
    const distance = Math.sqrt(dx * dx + dy * dy);

    if (this.lastDistance_ !== undefined) {
      scaleDelta = this.lastDistance_ / distance;
    }
    this.lastDistance_ = distance;

    const map = mapBrowserEvent.map;
    const view = map.getView();

    if (scaleDelta != 1.0) {
      this.lastScaleDelta_ = scaleDelta;
    }

    // scale anchor point.
    this.anchor_ = map.getCoordinateFromPixelInternal(
      map.getEventPixel((0,_Pointer_js__WEBPACK_IMPORTED_MODULE_0__.centroid)(this.targetPointers))
    );

    // scale, bypass the resolution constraint
    map.render();
    view.adjustResolutionInternal(scaleDelta, this.anchor_);
  }

  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */
  handleUpEvent(mapBrowserEvent) {
    if (this.targetPointers.length < 2) {
      const map = mapBrowserEvent.map;
      const view = map.getView();
      const direction = this.lastScaleDelta_ > 1 ? 1 : -1;
      view.endInteraction(this.duration_, direction);
      return false;
    }
    return true;
  }

  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */
  handleDownEvent(mapBrowserEvent) {
    if (this.targetPointers.length >= 2) {
      const map = mapBrowserEvent.map;
      this.anchor_ = null;
      this.lastDistance_ = undefined;
      this.lastScaleDelta_ = 1;
      if (!this.handlingDownUpSequence) {
        map.getView().beginInteraction();
      }
      return true;
    }
    return false;
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (PinchZoom);


/***/ }),

/***/ "./node_modules/ol/interaction/Pointer.js":
/*!************************************************!*\
  !*** ./node_modules/ol/interaction/Pointer.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   centroid: () => (/* binding */ centroid),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Interaction_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Interaction.js */ "./node_modules/ol/interaction/Interaction.js");
/* harmony import */ var _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../MapBrowserEventType.js */ "./node_modules/ol/MapBrowserEventType.js");
/**
 * @module ol/interaction/Pointer
 */



/**
 * @typedef {Object} Options
 * @property {function(import("../MapBrowserEvent.js").default):boolean} [handleDownEvent]
 * Function handling "down" events. If the function returns `true` then a drag
 * sequence is started.
 * @property {function(import("../MapBrowserEvent.js").default):void} [handleDragEvent]
 * Function handling "drag" events. This function is called on "move" events
 * during a drag sequence.
 * @property {function(import("../MapBrowserEvent.js").default):boolean} [handleEvent]
 * Method called by the map to notify the interaction that a browser event was
 * dispatched to the map. The function may return `false` to prevent the
 * propagation of the event to other interactions in the map's interactions
 * chain.
 * @property {function(import("../MapBrowserEvent.js").default):void} [handleMoveEvent]
 * Function handling "move" events. This function is called on "move" events.
 * This functions is also called during a drag sequence, so during a drag
 * sequence both the `handleDragEvent` function and this function are called.
 * If `handleDownEvent` is defined and it returns true this function will not
 * be called during a drag sequence.
 * @property {function(import("../MapBrowserEvent.js").default):boolean} [handleUpEvent]
 *  Function handling "up" events. If the function returns `false` then the
 * current drag sequence is stopped.
 * @property {function(boolean):boolean} [stopDown]
 * Should the down event be propagated to other interactions, or should be
 * stopped?
 */

/**
 * @classdesc
 * Base class that calls user-defined functions on `down`, `move` and `up`
 * events. This class also manages "drag sequences".
 *
 * When the `handleDownEvent` user function returns `true` a drag sequence is
 * started. During a drag sequence the `handleDragEvent` user function is
 * called on `move` events. The drag sequence ends when the `handleUpEvent`
 * user function is called and returns `false`.
 * @api
 */
class PointerInteraction extends _Interaction_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {Options} [options] Options.
   */
  constructor(options) {
    options = options ? options : {};

    super(
      /** @type {import("./Interaction.js").InteractionOptions} */ (options)
    );

    if (options.handleDownEvent) {
      this.handleDownEvent = options.handleDownEvent;
    }

    if (options.handleDragEvent) {
      this.handleDragEvent = options.handleDragEvent;
    }

    if (options.handleMoveEvent) {
      this.handleMoveEvent = options.handleMoveEvent;
    }

    if (options.handleUpEvent) {
      this.handleUpEvent = options.handleUpEvent;
    }

    if (options.stopDown) {
      this.stopDown = options.stopDown;
    }

    /**
     * @type {boolean}
     * @protected
     */
    this.handlingDownUpSequence = false;

    /**
     * @type {Array<PointerEvent>}
     * @protected
     */
    this.targetPointers = [];
  }

  /**
   * Returns the current number of pointers involved in the interaction,
   * e.g. `2` when two fingers are used.
   * @return {number} The number of pointers.
   * @api
   */
  getPointerCount() {
    return this.targetPointers.length;
  }

  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   * @protected
   */
  handleDownEvent(mapBrowserEvent) {
    return false;
  }

  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @protected
   */
  handleDragEvent(mapBrowserEvent) {}

  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} and may call into
   * other functions, if event sequences like e.g. 'drag' or 'down-up' etc. are
   * detected.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   * @api
   */
  handleEvent(mapBrowserEvent) {
    if (!mapBrowserEvent.originalEvent) {
      return true;
    }

    let stopEvent = false;
    this.updateTrackedPointers_(mapBrowserEvent);
    if (this.handlingDownUpSequence) {
      if (mapBrowserEvent.type == _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].POINTERDRAG) {
        this.handleDragEvent(mapBrowserEvent);
        // prevent page scrolling during dragging
        mapBrowserEvent.originalEvent.preventDefault();
      } else if (mapBrowserEvent.type == _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].POINTERUP) {
        const handledUp = this.handleUpEvent(mapBrowserEvent);
        this.handlingDownUpSequence =
          handledUp && this.targetPointers.length > 0;
      }
    } else {
      if (mapBrowserEvent.type == _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].POINTERDOWN) {
        const handled = this.handleDownEvent(mapBrowserEvent);
        this.handlingDownUpSequence = handled;
        stopEvent = this.stopDown(handled);
      } else if (mapBrowserEvent.type == _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].POINTERMOVE) {
        this.handleMoveEvent(mapBrowserEvent);
      }
    }
    return !stopEvent;
  }

  /**
   * Handle pointer move events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @protected
   */
  handleMoveEvent(mapBrowserEvent) {}

  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   * @protected
   */
  handleUpEvent(mapBrowserEvent) {
    return false;
  }

  /**
   * This function is used to determine if "down" events should be propagated
   * to other interactions or should be stopped.
   * @param {boolean} handled Was the event handled by the interaction?
   * @return {boolean} Should the `down` event be stopped?
   */
  stopDown(handled) {
    return handled;
  }

  /**
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @private
   */
  updateTrackedPointers_(mapBrowserEvent) {
    if (mapBrowserEvent.activePointers) {
      this.targetPointers = mapBrowserEvent.activePointers;
    }
  }
}

/**
 * @param {Array<PointerEvent>} pointerEvents List of events.
 * @return {{clientX: number, clientY: number}} Centroid pixel.
 */
function centroid(pointerEvents) {
  const length = pointerEvents.length;
  let clientX = 0;
  let clientY = 0;
  for (let i = 0; i < length; i++) {
    clientX += pointerEvents[i].clientX;
    clientY += pointerEvents[i].clientY;
  }
  return {clientX: clientX / length, clientY: clientY / length};
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (PointerInteraction);


/***/ }),

/***/ "./node_modules/ol/interaction/Property.js":
/*!*************************************************!*\
  !*** ./node_modules/ol/interaction/Property.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * @module ol/interaction/Property
 */

/**
 * @enum {string}
 */
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  ACTIVE: 'active',
});


/***/ }),

/***/ "./node_modules/ol/interaction/defaults.js":
/*!*************************************************!*\
  !*** ./node_modules/ol/interaction/defaults.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   defaults: () => (/* binding */ defaults)
/* harmony export */ });
/* harmony import */ var _Collection_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Collection.js */ "./node_modules/ol/Collection.js");
/* harmony import */ var _DoubleClickZoom_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./DoubleClickZoom.js */ "./node_modules/ol/interaction/DoubleClickZoom.js");
/* harmony import */ var _DragPan_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./DragPan.js */ "./node_modules/ol/interaction/DragPan.js");
/* harmony import */ var _DragRotate_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./DragRotate.js */ "./node_modules/ol/interaction/DragRotate.js");
/* harmony import */ var _DragZoom_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./DragZoom.js */ "./node_modules/ol/interaction/DragZoom.js");
/* harmony import */ var _KeyboardPan_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./KeyboardPan.js */ "./node_modules/ol/interaction/KeyboardPan.js");
/* harmony import */ var _KeyboardZoom_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./KeyboardZoom.js */ "./node_modules/ol/interaction/KeyboardZoom.js");
/* harmony import */ var _Kinetic_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Kinetic.js */ "./node_modules/ol/Kinetic.js");
/* harmony import */ var _MouseWheelZoom_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./MouseWheelZoom.js */ "./node_modules/ol/interaction/MouseWheelZoom.js");
/* harmony import */ var _PinchRotate_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./PinchRotate.js */ "./node_modules/ol/interaction/PinchRotate.js");
/* harmony import */ var _PinchZoom_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./PinchZoom.js */ "./node_modules/ol/interaction/PinchZoom.js");
/**
 * @module ol/interaction/defaults
 */












/**
 * @typedef {Object} DefaultsOptions
 * @property {boolean} [altShiftDragRotate=true] Whether Alt-Shift-drag rotate is
 * desired.
 * @property {boolean} [onFocusOnly=false] Interact only when the map has the
 * focus. This affects the `MouseWheelZoom` and `DragPan` interactions and is
 * useful when page scroll is desired for maps that do not have the browser's
 * focus.
 * @property {boolean} [doubleClickZoom=true] Whether double click zoom is
 * desired.
 * @property {boolean} [keyboard=true] Whether keyboard interaction is desired.
 * @property {boolean} [mouseWheelZoom=true] Whether mousewheel zoom is desired.
 * @property {boolean} [shiftDragZoom=true] Whether Shift-drag zoom is desired.
 * @property {boolean} [dragPan=true] Whether drag pan is desired.
 * @property {boolean} [pinchRotate=true] Whether pinch rotate is desired.
 * @property {boolean} [pinchZoom=true] Whether pinch zoom is desired.
 * @property {number} [zoomDelta] Zoom level delta when using keyboard or double click zoom.
 * @property {number} [zoomDuration] Duration of the zoom animation in
 * milliseconds.
 */

/**
 * Set of interactions included in maps by default. Specific interactions can be
 * excluded by setting the appropriate option to false in the constructor
 * options, but the order of the interactions is fixed.  If you want to specify
 * a different order for interactions, you will need to create your own
 * {@link module:ol/interaction/Interaction~Interaction} instances and insert
 * them into a {@link module:ol/Collection~Collection} in the order you want
 * before creating your {@link module:ol/Map~Map} instance. Changing the order can
 * be of interest if the event propagation needs to be stopped at a point.
 * The default set of interactions, in sequence, is:
 * * {@link module:ol/interaction/DragRotate~DragRotate}
 * * {@link module:ol/interaction/DoubleClickZoom~DoubleClickZoom}
 * * {@link module:ol/interaction/DragPan~DragPan}
 * * {@link module:ol/interaction/PinchRotate~PinchRotate}
 * * {@link module:ol/interaction/PinchZoom~PinchZoom}
 * * {@link module:ol/interaction/KeyboardPan~KeyboardPan}
 * * {@link module:ol/interaction/KeyboardZoom~KeyboardZoom}
 * * {@link module:ol/interaction/MouseWheelZoom~MouseWheelZoom}
 * * {@link module:ol/interaction/DragZoom~DragZoom}
 *
 * @param {DefaultsOptions} [options] Defaults options.
 * @return {Collection<import("./Interaction.js").default>}
 * A collection of interactions to be used with the {@link module:ol/Map~Map}
 * constructor's `interactions` option.
 * @api
 */
function defaults(options) {
  options = options ? options : {};

  /** @type {Collection<import("./Interaction.js").default>} */
  const interactions = new _Collection_js__WEBPACK_IMPORTED_MODULE_0__["default"]();

  const kinetic = new _Kinetic_js__WEBPACK_IMPORTED_MODULE_1__["default"](-0.005, 0.05, 100);

  const altShiftDragRotate =
    options.altShiftDragRotate !== undefined
      ? options.altShiftDragRotate
      : true;
  if (altShiftDragRotate) {
    interactions.push(new _DragRotate_js__WEBPACK_IMPORTED_MODULE_2__["default"]());
  }

  const doubleClickZoom =
    options.doubleClickZoom !== undefined ? options.doubleClickZoom : true;
  if (doubleClickZoom) {
    interactions.push(
      new _DoubleClickZoom_js__WEBPACK_IMPORTED_MODULE_3__["default"]({
        delta: options.zoomDelta,
        duration: options.zoomDuration,
      })
    );
  }

  const dragPan = options.dragPan !== undefined ? options.dragPan : true;
  if (dragPan) {
    interactions.push(
      new _DragPan_js__WEBPACK_IMPORTED_MODULE_4__["default"]({
        onFocusOnly: options.onFocusOnly,
        kinetic: kinetic,
      })
    );
  }

  const pinchRotate =
    options.pinchRotate !== undefined ? options.pinchRotate : true;
  if (pinchRotate) {
    interactions.push(new _PinchRotate_js__WEBPACK_IMPORTED_MODULE_5__["default"]());
  }

  const pinchZoom = options.pinchZoom !== undefined ? options.pinchZoom : true;
  if (pinchZoom) {
    interactions.push(
      new _PinchZoom_js__WEBPACK_IMPORTED_MODULE_6__["default"]({
        duration: options.zoomDuration,
      })
    );
  }

  const keyboard = options.keyboard !== undefined ? options.keyboard : true;
  if (keyboard) {
    interactions.push(new _KeyboardPan_js__WEBPACK_IMPORTED_MODULE_7__["default"]());
    interactions.push(
      new _KeyboardZoom_js__WEBPACK_IMPORTED_MODULE_8__["default"]({
        delta: options.zoomDelta,
        duration: options.zoomDuration,
      })
    );
  }

  const mouseWheelZoom =
    options.mouseWheelZoom !== undefined ? options.mouseWheelZoom : true;
  if (mouseWheelZoom) {
    interactions.push(
      new _MouseWheelZoom_js__WEBPACK_IMPORTED_MODULE_9__["default"]({
        onFocusOnly: options.onFocusOnly,
        duration: options.zoomDuration,
      })
    );
  }

  const shiftDragZoom =
    options.shiftDragZoom !== undefined ? options.shiftDragZoom : true;
  if (shiftDragZoom) {
    interactions.push(
      new _DragZoom_js__WEBPACK_IMPORTED_MODULE_10__["default"]({
        duration: options.zoomDuration,
      })
    );
  }

  return interactions;
}


/***/ }),

/***/ "./node_modules/ol/layer/Base.js":
/*!***************************************!*\
  !*** ./node_modules/ol/layer/Base.js ***!
  \***************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Object_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Object.js */ "./node_modules/ol/Object.js");
/* harmony import */ var _Property_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Property.js */ "./node_modules/ol/layer/Property.js");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util.js */ "./node_modules/ol/util.js");
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../asserts.js */ "./node_modules/ol/asserts.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../math.js */ "./node_modules/ol/math.js");
/**
 * @module ol/layer/Base
 */






/**
 * A css color, or a function called with a view resolution returning a css color.
 *
 * @typedef {string|function(number):string} BackgroundColor
 * @api
 */

/**
 * @typedef {import("../ObjectEventType").Types|'change:extent'|'change:maxResolution'|'change:maxZoom'|
 *    'change:minResolution'|'change:minZoom'|'change:opacity'|'change:visible'|'change:zIndex'} BaseLayerObjectEventTypes
 */

/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<BaseLayerObjectEventTypes, import("../Object").ObjectEvent, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|BaseLayerObjectEventTypes, Return>} BaseLayerOnSignature
 */

/**
 * @typedef {Object} Options
 * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.
 * @property {number} [opacity=1] Opacity (0, 1).
 * @property {boolean} [visible=true] Visibility.
 * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
 * rendered outside of this extent.
 * @property {number | undefined} [zIndex] The z-index for layer rendering.  At rendering time, the layers
 * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
 * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
 * method was used.
 * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
 * visible.
 * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
 * be visible.
 * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be
 * visible.
 * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will
 * be visible.
 * @property {BackgroundColor} [background] Background color for the layer. If not specified, no background
 * will be rendered.
 * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.
 */

/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Note that with {@link module:ol/layer/Base~BaseLayer} and all its subclasses, any property set in
 * the options is set as a {@link module:ol/Object~BaseObject} property on the layer object, so
 * is observable, and has get/set accessors.
 *
 * @api
 */
class BaseLayer extends _Object_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {Options} options Layer options.
   */
  constructor(options) {
    super();

    /***
     * @type {BaseLayerOnSignature<import("../events").EventsKey>}
     */
    this.on;

    /***
     * @type {BaseLayerOnSignature<import("../events").EventsKey>}
     */
    this.once;

    /***
     * @type {BaseLayerOnSignature<void>}
     */
    this.un;

    /**
     * @type {BackgroundColor|false}
     * @private
     */
    this.background_ = options.background;

    /**
     * @type {Object<string, *>}
     */
    const properties = Object.assign({}, options);
    if (typeof options.properties === 'object') {
      delete properties.properties;
      Object.assign(properties, options.properties);
    }

    properties[_Property_js__WEBPACK_IMPORTED_MODULE_1__["default"].OPACITY] =
      options.opacity !== undefined ? options.opacity : 1;
    (0,_asserts_js__WEBPACK_IMPORTED_MODULE_2__.assert)(
      typeof properties[_Property_js__WEBPACK_IMPORTED_MODULE_1__["default"].OPACITY] === 'number',
      'Layer opacity must be a number'
    );

    properties[_Property_js__WEBPACK_IMPORTED_MODULE_1__["default"].VISIBLE] =
      options.visible !== undefined ? options.visible : true;
    properties[_Property_js__WEBPACK_IMPORTED_MODULE_1__["default"].Z_INDEX] = options.zIndex;
    properties[_Property_js__WEBPACK_IMPORTED_MODULE_1__["default"].MAX_RESOLUTION] =
      options.maxResolution !== undefined ? options.maxResolution : Infinity;
    properties[_Property_js__WEBPACK_IMPORTED_MODULE_1__["default"].MIN_RESOLUTION] =
      options.minResolution !== undefined ? options.minResolution : 0;
    properties[_Property_js__WEBPACK_IMPORTED_MODULE_1__["default"].MIN_ZOOM] =
      options.minZoom !== undefined ? options.minZoom : -Infinity;
    properties[_Property_js__WEBPACK_IMPORTED_MODULE_1__["default"].MAX_ZOOM] =
      options.maxZoom !== undefined ? options.maxZoom : Infinity;

    /**
     * @type {string}
     * @private
     */
    this.className_ =
      properties.className !== undefined ? properties.className : 'ol-layer';
    delete properties.className;

    this.setProperties(properties);

    /**
     * @type {import("./Layer.js").State}
     * @private
     */
    this.state_ = null;
  }

  /**
   * Get the background for this layer.
   * @return {BackgroundColor|false} Layer background.
   */
  getBackground() {
    return this.background_;
  }

  /**
   * @return {string} CSS class name.
   */
  getClassName() {
    return this.className_;
  }

  /**
   * This method is not meant to be called by layers or layer renderers because the state
   * is incorrect if the layer is included in a layer group.
   *
   * @param {boolean} [managed] Layer is managed.
   * @return {import("./Layer.js").State} Layer state.
   */
  getLayerState(managed) {
    /** @type {import("./Layer.js").State} */
    const state =
      this.state_ ||
      /** @type {?} */ ({
        layer: this,
        managed: managed === undefined ? true : managed,
      });
    const zIndex = this.getZIndex();
    state.opacity = (0,_math_js__WEBPACK_IMPORTED_MODULE_3__.clamp)(Math.round(this.getOpacity() * 100) / 100, 0, 1);
    state.visible = this.getVisible();
    state.extent = this.getExtent();
    state.zIndex = zIndex === undefined && !state.managed ? Infinity : zIndex;
    state.maxResolution = this.getMaxResolution();
    state.minResolution = Math.max(this.getMinResolution(), 0);
    state.minZoom = this.getMinZoom();
    state.maxZoom = this.getMaxZoom();
    this.state_ = state;

    return state;
  }

  /**
   * @abstract
   * @param {Array<import("./Layer.js").default>} [array] Array of layers (to be
   *     modified in place).
   * @return {Array<import("./Layer.js").default>} Array of layers.
   */
  getLayersArray(array) {
    return (0,_util_js__WEBPACK_IMPORTED_MODULE_4__.abstract)();
  }

  /**
   * @abstract
   * @param {Array<import("./Layer.js").State>} [states] Optional list of layer
   *     states (to be modified in place).
   * @return {Array<import("./Layer.js").State>} List of layer states.
   */
  getLayerStatesArray(states) {
    return (0,_util_js__WEBPACK_IMPORTED_MODULE_4__.abstract)();
  }

  /**
   * Return the {@link module:ol/extent~Extent extent} of the layer or `undefined` if it
   * will be visible regardless of extent.
   * @return {import("../extent.js").Extent|undefined} The layer extent.
   * @observable
   * @api
   */
  getExtent() {
    return /** @type {import("../extent.js").Extent|undefined} */ (
      this.get(_Property_js__WEBPACK_IMPORTED_MODULE_1__["default"].EXTENT)
    );
  }

  /**
   * Return the maximum resolution of the layer. Returns Infinity if
   * the layer has no maximum resolution set.
   * @return {number} The maximum resolution of the layer.
   * @observable
   * @api
   */
  getMaxResolution() {
    return /** @type {number} */ (this.get(_Property_js__WEBPACK_IMPORTED_MODULE_1__["default"].MAX_RESOLUTION));
  }

  /**
   * Return the minimum resolution of the layer. Returns 0 if
   * the layer has no minimum resolution set.
   * @return {number} The minimum resolution of the layer.
   * @observable
   * @api
   */
  getMinResolution() {
    return /** @type {number} */ (this.get(_Property_js__WEBPACK_IMPORTED_MODULE_1__["default"].MIN_RESOLUTION));
  }

  /**
   * Return the minimum zoom level of the layer. Returns -Infinity if
   * the layer has no minimum zoom set.
   * @return {number} The minimum zoom level of the layer.
   * @observable
   * @api
   */
  getMinZoom() {
    return /** @type {number} */ (this.get(_Property_js__WEBPACK_IMPORTED_MODULE_1__["default"].MIN_ZOOM));
  }

  /**
   * Return the maximum zoom level of the layer. Returns Infinity if
   * the layer has no maximum zoom set.
   * @return {number} The maximum zoom level of the layer.
   * @observable
   * @api
   */
  getMaxZoom() {
    return /** @type {number} */ (this.get(_Property_js__WEBPACK_IMPORTED_MODULE_1__["default"].MAX_ZOOM));
  }

  /**
   * Return the opacity of the layer (between 0 and 1).
   * @return {number} The opacity of the layer.
   * @observable
   * @api
   */
  getOpacity() {
    return /** @type {number} */ (this.get(_Property_js__WEBPACK_IMPORTED_MODULE_1__["default"].OPACITY));
  }

  /**
   * @abstract
   * @return {import("../source/Source.js").State} Source state.
   */
  getSourceState() {
    return (0,_util_js__WEBPACK_IMPORTED_MODULE_4__.abstract)();
  }

  /**
   * Return the value of this layer's `visible` property. To find out whether the layer
   * is visible on a map, use `isVisible()` instead.
   * @return {boolean} The value of the `visible` property of the layer.
   * @observable
   * @api
   */
  getVisible() {
    return /** @type {boolean} */ (this.get(_Property_js__WEBPACK_IMPORTED_MODULE_1__["default"].VISIBLE));
  }

  /**
   * Return the Z-index of the layer, which is used to order layers before
   * rendering. Returns undefined if the layer is unmanaged.
   * @return {number|undefined} The Z-index of the layer.
   * @observable
   * @api
   */
  getZIndex() {
    return /** @type {number|undefined} */ (this.get(_Property_js__WEBPACK_IMPORTED_MODULE_1__["default"].Z_INDEX));
  }

  /**
   * Sets the background color.
   * @param {BackgroundColor} [background] Background color.
   */
  setBackground(background) {
    this.background_ = background;
    this.changed();
  }

  /**
   * Set the extent at which the layer is visible.  If `undefined`, the layer
   * will be visible at all extents.
   * @param {import("../extent.js").Extent|undefined} extent The extent of the layer.
   * @observable
   * @api
   */
  setExtent(extent) {
    this.set(_Property_js__WEBPACK_IMPORTED_MODULE_1__["default"].EXTENT, extent);
  }

  /**
   * Set the maximum resolution at which the layer is visible.
   * @param {number} maxResolution The maximum resolution of the layer.
   * @observable
   * @api
   */
  setMaxResolution(maxResolution) {
    this.set(_Property_js__WEBPACK_IMPORTED_MODULE_1__["default"].MAX_RESOLUTION, maxResolution);
  }

  /**
   * Set the minimum resolution at which the layer is visible.
   * @param {number} minResolution The minimum resolution of the layer.
   * @observable
   * @api
   */
  setMinResolution(minResolution) {
    this.set(_Property_js__WEBPACK_IMPORTED_MODULE_1__["default"].MIN_RESOLUTION, minResolution);
  }

  /**
   * Set the maximum zoom (exclusive) at which the layer is visible.
   * Note that the zoom levels for layer visibility are based on the
   * view zoom level, which may be different from a tile source zoom level.
   * @param {number} maxZoom The maximum zoom of the layer.
   * @observable
   * @api
   */
  setMaxZoom(maxZoom) {
    this.set(_Property_js__WEBPACK_IMPORTED_MODULE_1__["default"].MAX_ZOOM, maxZoom);
  }

  /**
   * Set the minimum zoom (inclusive) at which the layer is visible.
   * Note that the zoom levels for layer visibility are based on the
   * view zoom level, which may be different from a tile source zoom level.
   * @param {number} minZoom The minimum zoom of the layer.
   * @observable
   * @api
   */
  setMinZoom(minZoom) {
    this.set(_Property_js__WEBPACK_IMPORTED_MODULE_1__["default"].MIN_ZOOM, minZoom);
  }

  /**
   * Set the opacity of the layer, allowed values range from 0 to 1.
   * @param {number} opacity The opacity of the layer.
   * @observable
   * @api
   */
  setOpacity(opacity) {
    (0,_asserts_js__WEBPACK_IMPORTED_MODULE_2__.assert)(typeof opacity === 'number', 'Layer opacity must be a number');
    this.set(_Property_js__WEBPACK_IMPORTED_MODULE_1__["default"].OPACITY, opacity);
  }

  /**
   * Set the visibility of the layer (`true` or `false`).
   * @param {boolean} visible The visibility of the layer.
   * @observable
   * @api
   */
  setVisible(visible) {
    this.set(_Property_js__WEBPACK_IMPORTED_MODULE_1__["default"].VISIBLE, visible);
  }

  /**
   * Set Z-index of the layer, which is used to order layers before rendering.
   * The default Z-index is 0.
   * @param {number} zindex The z-index of the layer.
   * @observable
   * @api
   */
  setZIndex(zindex) {
    this.set(_Property_js__WEBPACK_IMPORTED_MODULE_1__["default"].Z_INDEX, zindex);
  }

  /**
   * Clean up.
   */
  disposeInternal() {
    if (this.state_) {
      this.state_.layer = null;
      this.state_ = null;
    }
    super.disposeInternal();
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (BaseLayer);


/***/ }),

/***/ "./node_modules/ol/layer/BaseTile.js":
/*!*******************************************!*\
  !*** ./node_modules/ol/layer/BaseTile.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Layer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Layer.js */ "./node_modules/ol/layer/Layer.js");
/* harmony import */ var _TileProperty_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./TileProperty.js */ "./node_modules/ol/layer/TileProperty.js");
/**
 * @module ol/layer/BaseTile
 */



/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("./Base").BaseLayerObjectEventTypes|
 *     import("./Layer.js").LayerEventType|'change:preload'|'change:useInterimTilesOnError', import("../Object").ObjectEvent, Return> &
 *   import("../Observable").OnSignature<import("../render/EventType").LayerRenderEventTypes, import("../render/Event").default, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("./Base").BaseLayerObjectEventTypes|
 *   import("./Layer.js").LayerEventType|'change:preload'|'change:useInterimTilesOnError'|import("../render/EventType").LayerRenderEventTypes, Return>} BaseTileLayerOnSignature
 */

/**
 * @template {import("../source/Tile.js").default} TileSourceType
 * @typedef {Object} Options
 * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.
 * @property {number} [opacity=1] Opacity (0, 1).
 * @property {boolean} [visible=true] Visibility.
 * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
 * rendered outside of this extent.
 * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
 * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
 * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
 * method was used.
 * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
 * visible.
 * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
 * be visible.
 * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be
 * visible.
 * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will
 * be visible.
 * @property {number} [preload=0] Preload. Load low-resolution tiles up to `preload` levels. `0`
 * means no preloading.
 * @property {TileSourceType} [source] Source for this layer.
 * @property {import("../Map.js").default} [map] Sets the layer as overlay on a map. The map will not manage
 * this layer in its layers collection, and the layer will be rendered on top. This is useful for
 * temporary layers. The standard way to add a layer to a map and have it managed by the map is to
 * use {@link import("../Map.js").default#addLayer map.addLayer()}.
 * @property {boolean} [useInterimTilesOnError=true] Use interim tiles on error.
 * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.
 */

/**
 * @classdesc
 * For layer sources that provide pre-rendered, tiled images in grids that are
 * organized by zoom levels for specific resolutions.
 * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}
 * property on the layer object; for example, setting `title: 'My Title'` in the
 * options means that `title` is observable, and has get/set accessors.
 *
 * @template {import("../source/Tile.js").default} TileSourceType
 * @template {import("../renderer/Layer.js").default} RendererType
 * @extends {Layer<TileSourceType, RendererType>}
 * @api
 */
class BaseTileLayer extends _Layer_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {Options<TileSourceType>} [options] Tile layer options.
   */
  constructor(options) {
    options = options ? options : {};

    const baseOptions = Object.assign({}, options);

    delete baseOptions.preload;
    delete baseOptions.useInterimTilesOnError;
    super(baseOptions);

    /***
     * @type {BaseTileLayerOnSignature<import("../events").EventsKey>}
     */
    this.on;

    /***
     * @type {BaseTileLayerOnSignature<import("../events").EventsKey>}
     */
    this.once;

    /***
     * @type {BaseTileLayerOnSignature<void>}
     */
    this.un;

    this.setPreload(options.preload !== undefined ? options.preload : 0);
    this.setUseInterimTilesOnError(
      options.useInterimTilesOnError !== undefined
        ? options.useInterimTilesOnError
        : true
    );
  }

  /**
   * Return the level as number to which we will preload tiles up to.
   * @return {number} The level to preload tiles up to.
   * @observable
   * @api
   */
  getPreload() {
    return /** @type {number} */ (this.get(_TileProperty_js__WEBPACK_IMPORTED_MODULE_1__["default"].PRELOAD));
  }

  /**
   * Set the level as number to which we will preload tiles up to.
   * @param {number} preload The level to preload tiles up to.
   * @observable
   * @api
   */
  setPreload(preload) {
    this.set(_TileProperty_js__WEBPACK_IMPORTED_MODULE_1__["default"].PRELOAD, preload);
  }

  /**
   * Whether we use interim tiles on error.
   * @return {boolean} Use interim tiles on error.
   * @observable
   * @api
   */
  getUseInterimTilesOnError() {
    return /** @type {boolean} */ (
      this.get(_TileProperty_js__WEBPACK_IMPORTED_MODULE_1__["default"].USE_INTERIM_TILES_ON_ERROR)
    );
  }

  /**
   * Set whether we use interim tiles on error.
   * @param {boolean} useInterimTilesOnError Use interim tiles on error.
   * @observable
   * @api
   */
  setUseInterimTilesOnError(useInterimTilesOnError) {
    this.set(_TileProperty_js__WEBPACK_IMPORTED_MODULE_1__["default"].USE_INTERIM_TILES_ON_ERROR, useInterimTilesOnError);
  }

  /**
   * Get data for a pixel location.  The return type depends on the source data.  For image tiles,
   * a four element RGBA array will be returned.  For data tiles, the array length will match the
   * number of bands in the dataset.  For requests outside the layer extent, `null` will be returned.
   * Data for a image tiles can only be retrieved if the source's `crossOrigin` property is set.
   *
   * ```js
   * // display layer data on every pointer move
   * map.on('pointermove', (event) => {
   *   console.log(layer.getData(event.pixel));
   * });
   * ```
   * @param {import("../pixel").Pixel} pixel Pixel.
   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.
   * @api
   */
  getData(pixel) {
    return super.getData(pixel);
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (BaseTileLayer);


/***/ }),

/***/ "./node_modules/ol/layer/BaseVector.js":
/*!*********************************************!*\
  !*** ./node_modules/ol/layer/BaseVector.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Layer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Layer.js */ "./node_modules/ol/layer/Layer.js");
/* harmony import */ var rbush__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! rbush */ "./node_modules/rbush/rbush.min.js");
/* harmony import */ var _style_Style_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../style/Style.js */ "./node_modules/ol/style/Style.js");
/* harmony import */ var _render_canvas_style_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../render/canvas/style.js */ "./node_modules/ol/render/canvas/style.js");
/**
 * @module ol/layer/BaseVector
 */





/**
 * @template {import("../source/Vector.js").default|import("../source/VectorTile.js").default} VectorSourceType
 * @typedef {Object} Options
 * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.
 * @property {number} [opacity=1] Opacity (0, 1).
 * @property {boolean} [visible=true] Visibility.
 * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
 * rendered outside of this extent.
 * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
 * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
 * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
 * method was used.
 * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
 * visible.
 * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
 * be visible.
 * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be
 * visible.
 * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will
 * be visible.
 * @property {import("../render.js").OrderFunction} [renderOrder] Render order. Function to be used when sorting
 * features before rendering. By default features are drawn in the order that they are created. Use
 * `null` to avoid the sort, but get an undefined draw order.
 * @property {number} [renderBuffer=100] The buffer in pixels around the viewport extent used by the
 * renderer when getting features from the vector source for the rendering or hit-detection.
 * Recommended value: the size of the largest symbol, line width or label.
 * @property {VectorSourceType} [source] Source.
 * @property {import("../Map.js").default} [map] Sets the layer as overlay on a map. The map will not manage
 * this layer in its layers collection, and the layer will be rendered on top. This is useful for
 * temporary layers. The standard way to add a layer to a map and have it managed by the map is to
 * use [map.addLayer()]{@link import("../Map.js").default#addLayer}.
 * @property {boolean} [declutter=false] Declutter images and text. Decluttering is applied to all
 * image and text styles of all Vector and VectorTile layers that have set this to `true`. The priority
 * is defined by the z-index of the layer, the `zIndex` of the style and the render order of features.
 * Higher z-index means higher priority. Within the same z-index, a feature rendered before another has
 * higher priority.
 *
 * As an optimization decluttered features from layers with the same `className` are rendered above
 * the fill and stroke styles of all of those layers regardless of z-index.  To opt out of this
 * behavior and place declutterd features with their own layer configure the layer with a `className`
 * other than `ol-layer`.
 * @property {import("../style/Style.js").StyleLike|import("../style/flat.js").FlatStyleLike|null} [style] Layer style. When set to `null`, only
 * features that have their own style will be rendered. See {@link module:ol/style/Style~Style} for the default style
 * which will be used if this is not set.
 * @property {import("./Base.js").BackgroundColor} [background] Background color for the layer. If not specified, no background
 * will be rendered.
 * @property {boolean} [updateWhileAnimating=false] When set to `true`, feature batches will
 * be recreated during animations. This means that no vectors will be shown clipped, but the
 * setting will have a performance impact for large amounts of vector data. When set to `false`,
 * batches will be recreated when no animation is active.
 * @property {boolean} [updateWhileInteracting=false] When set to `true`, feature batches will
 * be recreated during interactions. See also `updateWhileAnimating`.
 * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.
 */

/**
 * @enum {string}
 * @private
 */
const Property = {
  RENDER_ORDER: 'renderOrder',
};

/**
 * @classdesc
 * Vector data that is rendered client-side.
 * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}
 * property on the layer object; for example, setting `title: 'My Title'` in the
 * options means that `title` is observable, and has get/set accessors.
 *
 * @template {import("../source/Vector.js").default|import("../source/VectorTile.js").default} VectorSourceType
 * @template {import("../renderer/canvas/VectorLayer.js").default|import("../renderer/canvas/VectorTileLayer.js").default|import("../renderer/canvas/VectorImageLayer.js").default|import("../renderer/webgl/PointsLayer.js").default} RendererType
 * @extends {Layer<VectorSourceType, RendererType>}
 * @api
 */
class BaseVectorLayer extends _Layer_js__WEBPACK_IMPORTED_MODULE_1__["default"] {
  /**
   * @param {Options<VectorSourceType>} [options] Options.
   */
  constructor(options) {
    options = options ? options : {};

    const baseOptions = Object.assign({}, options);

    delete baseOptions.style;
    delete baseOptions.renderBuffer;
    delete baseOptions.updateWhileAnimating;
    delete baseOptions.updateWhileInteracting;
    super(baseOptions);

    /**
     * @private
     * @type {boolean}
     */
    this.declutter_ =
      options.declutter !== undefined ? options.declutter : false;

    /**
     * @type {number}
     * @private
     */
    this.renderBuffer_ =
      options.renderBuffer !== undefined ? options.renderBuffer : 100;

    /**
     * User provided style.
     * @type {import("../style/Style.js").StyleLike}
     * @private
     */
    this.style_ = null;

    /**
     * Style function for use within the library.
     * @type {import("../style/Style.js").StyleFunction|undefined}
     * @private
     */
    this.styleFunction_ = undefined;

    this.setStyle(options.style);

    /**
     * @type {boolean}
     * @private
     */
    this.updateWhileAnimating_ =
      options.updateWhileAnimating !== undefined
        ? options.updateWhileAnimating
        : false;

    /**
     * @type {boolean}
     * @private
     */
    this.updateWhileInteracting_ =
      options.updateWhileInteracting !== undefined
        ? options.updateWhileInteracting
        : false;
  }

  /**
   * @return {boolean} Declutter.
   */
  getDeclutter() {
    return this.declutter_;
  }

  /**
   * Get the topmost feature that intersects the given pixel on the viewport. Returns a promise
   * that resolves with an array of features. The array will either contain the topmost feature
   * when a hit was detected, or it will be empty.
   *
   * The hit detection algorithm used for this method is optimized for performance, but is less
   * accurate than the one used in [map.getFeaturesAtPixel()]{@link import("../Map.js").default#getFeaturesAtPixel}.
   * Text is not considered, and icons are only represented by their bounding box instead of the exact
   * image.
   *
   * @param {import("../pixel.js").Pixel} pixel Pixel.
   * @return {Promise<Array<import("../Feature").FeatureLike>>} Promise that resolves with an array of features.
   * @api
   */
  getFeatures(pixel) {
    return super.getFeatures(pixel);
  }

  /**
   * @return {number|undefined} Render buffer.
   */
  getRenderBuffer() {
    return this.renderBuffer_;
  }

  /**
   * @return {function(import("../Feature.js").default, import("../Feature.js").default): number|null|undefined} Render
   *     order.
   */
  getRenderOrder() {
    return /** @type {import("../render.js").OrderFunction|null|undefined} */ (
      this.get(Property.RENDER_ORDER)
    );
  }

  /**
   * Get the style for features.  This returns whatever was passed to the `style`
   * option at construction or to the `setStyle` method.
   * @return {import("../style/Style.js").StyleLike|null|undefined} Layer style.
   * @api
   */
  getStyle() {
    return this.style_;
  }

  /**
   * Get the style function.
   * @return {import("../style/Style.js").StyleFunction|undefined} Layer style function.
   * @api
   */
  getStyleFunction() {
    return this.styleFunction_;
  }

  /**
   * @return {boolean} Whether the rendered layer should be updated while
   *     animating.
   */
  getUpdateWhileAnimating() {
    return this.updateWhileAnimating_;
  }

  /**
   * @return {boolean} Whether the rendered layer should be updated while
   *     interacting.
   */
  getUpdateWhileInteracting() {
    return this.updateWhileInteracting_;
  }

  /**
   * Render declutter items for this layer
   * @param {import("../Map.js").FrameState} frameState Frame state.
   */
  renderDeclutter(frameState) {
    if (!frameState.declutterTree) {
      frameState.declutterTree = new rbush__WEBPACK_IMPORTED_MODULE_0__(9);
    }
    /** @type {*} */ (this.getRenderer()).renderDeclutter(frameState);
  }

  /**
   * @param {import("../render.js").OrderFunction|null|undefined} renderOrder
   *     Render order.
   */
  setRenderOrder(renderOrder) {
    this.set(Property.RENDER_ORDER, renderOrder);
  }

  /**
   * Set the style for features.  This can be a single style object, an array
   * of styles, or a function that takes a feature and resolution and returns
   * an array of styles. If set to `null`, the layer has no style (a `null` style),
   * so only features that have their own styles will be rendered in the layer. Call
   * `setStyle()` without arguments to reset to the default style. See
   * [the ol/style/Style module]{@link module:ol/style/Style~Style} for information on the default style.
   *
   * If your layer has a static style, you can use [flat style]{@link module:ol/style/flat~FlatStyle} object
   * literals instead of using the `Style` and symbolizer constructors (`Fill`, `Stroke`, etc.):
   * ```js
   * vectorLayer.setStyle({
   *   "fill-color": "yellow",
   *   "stroke-color": "black",
   *   "stroke-width": 4
   * })
   * ```
   *
   * @param {import("../style/Style.js").StyleLike|import("../style/flat.js").FlatStyleLike|null} [style] Layer style.
   * @api
   */
  setStyle(style) {
    this.style_ = toStyleLike(style);
    this.styleFunction_ =
      style === null ? undefined : (0,_style_Style_js__WEBPACK_IMPORTED_MODULE_2__.toFunction)(this.style_);
    this.changed();
  }
}

/**
 * Coerce the allowed style types into a shorter list of types.  Flat styles, arrays of flat
 * styles, and arrays of rules are converted into style functions.
 *
 * @param {import("../style/Style.js").StyleLike|import("../style/flat.js").FlatStyleLike|null} [style] Layer style.
 * @return {import("../style/Style.js").StyleLike|null} The style.
 */
function toStyleLike(style) {
  if (style === undefined) {
    return _style_Style_js__WEBPACK_IMPORTED_MODULE_2__.createDefaultStyle;
  }
  if (!style) {
    return null;
  }
  if (typeof style === 'function') {
    return style;
  }
  if (style instanceof _style_Style_js__WEBPACK_IMPORTED_MODULE_2__["default"]) {
    return style;
  }
  if (!Array.isArray(style)) {
    return (0,_render_canvas_style_js__WEBPACK_IMPORTED_MODULE_3__.flatStylesToStyleFunction)([style]);
  }
  if (style.length === 0) {
    return [];
  }

  const length = style.length;
  const first = style[0];

  if (first instanceof _style_Style_js__WEBPACK_IMPORTED_MODULE_2__["default"]) {
    /**
     * @type {Array<Style>}
     */
    const styles = new Array(length);
    for (let i = 0; i < length; ++i) {
      const candidate = style[i];
      if (!(candidate instanceof _style_Style_js__WEBPACK_IMPORTED_MODULE_2__["default"])) {
        throw new Error('Expected a list of style instances');
      }
      styles[i] = candidate;
    }
    return styles;
  }

  if ('style' in first) {
    /**
     * @type Array<import("../style/flat.js").Rule>
     */
    const rules = new Array(length);
    for (let i = 0; i < length; ++i) {
      const candidate = style[i];
      if (!('style' in candidate)) {
        throw new Error('Expected a list of rules with a style property');
      }
      rules[i] = candidate;
    }
    return (0,_render_canvas_style_js__WEBPACK_IMPORTED_MODULE_3__.rulesToStyleFunction)(rules);
  }

  const flatStyles =
    /** @type {Array<import("../style/flat.js").FlatStyle>} */ (style);
  return (0,_render_canvas_style_js__WEBPACK_IMPORTED_MODULE_3__.flatStylesToStyleFunction)(flatStyles);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (BaseVectorLayer);


/***/ }),

/***/ "./node_modules/ol/layer/Group.js":
/*!****************************************!*\
  !*** ./node_modules/ol/layer/Group.js ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GroupEvent: () => (/* binding */ GroupEvent),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Base.js */ "./node_modules/ol/layer/Base.js");
/* harmony import */ var _Collection_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Collection.js */ "./node_modules/ol/Collection.js");
/* harmony import */ var _CollectionEventType_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../CollectionEventType.js */ "./node_modules/ol/CollectionEventType.js");
/* harmony import */ var _events_Event_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../events/Event.js */ "./node_modules/ol/events/Event.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../events/EventType.js */ "./node_modules/ol/events/EventType.js");
/* harmony import */ var _ObjectEventType_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../ObjectEventType.js */ "./node_modules/ol/ObjectEventType.js");
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../asserts.js */ "./node_modules/ol/asserts.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../obj.js */ "./node_modules/ol/obj.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../util.js */ "./node_modules/ol/util.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../events.js */ "./node_modules/ol/events.js");
/**
 * @module ol/layer/Group
 */












/**
 * @typedef {'addlayer'|'removelayer'} EventType
 */

/**
 * @classdesc
 * A layer group triggers 'addlayer' and 'removelayer' events when layers are added to or removed from
 * the group or one of its child groups.  When a layer group is added to or removed from another layer group,
 * a single event will be triggered (instead of one per layer in the group added or removed).
 */
class GroupEvent extends _events_Event_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {EventType} type The event type.
   * @param {BaseLayer} layer The layer.
   */
  constructor(type, layer) {
    super(type);

    /**
     * The added or removed layer.
     * @type {BaseLayer}
     * @api
     */
    this.layer = layer;
  }
}

/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("./Base").BaseLayerObjectEventTypes|
 *     'change:layers', import("../Object").ObjectEvent, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("./Base").BaseLayerObjectEventTypes|'change:layers', Return>} GroupOnSignature
 */

/**
 * @typedef {Object} Options
 * @property {number} [opacity=1] Opacity (0, 1).
 * @property {boolean} [visible=true] Visibility.
 * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
 * rendered outside of this extent.
 * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
 * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
 * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
 * method was used.
 * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
 * visible.
 * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
 * be visible.
 * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be
 * visible.
 * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will
 * be visible.
 * @property {Array<import("./Base.js").default>|Collection<import("./Base.js").default>} [layers] Child layers.
 * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.
 */

/**
 * @enum {string}
 * @private
 */
const Property = {
  LAYERS: 'layers',
};

/**
 * @classdesc
 * A {@link module:ol/Collection~Collection} of layers that are handled together.
 *
 * A generic `change` event is triggered when the group/Collection changes.
 *
 * @api
 */
class LayerGroup extends _Base_js__WEBPACK_IMPORTED_MODULE_1__["default"] {
  /**
   * @param {Options} [options] Layer options.
   */
  constructor(options) {
    options = options || {};
    const baseOptions = /** @type {Options} */ (Object.assign({}, options));
    delete baseOptions.layers;

    let layers = options.layers;

    super(baseOptions);

    /***
     * @type {GroupOnSignature<import("../events").EventsKey>}
     */
    this.on;

    /***
     * @type {GroupOnSignature<import("../events").EventsKey>}
     */
    this.once;

    /***
     * @type {GroupOnSignature<void>}
     */
    this.un;

    /**
     * @private
     * @type {Array<import("../events.js").EventsKey>}
     */
    this.layersListenerKeys_ = [];

    /**
     * @private
     * @type {Object<string, Array<import("../events.js").EventsKey>>}
     */
    this.listenerKeys_ = {};

    this.addChangeListener(Property.LAYERS, this.handleLayersChanged_);

    if (layers) {
      if (Array.isArray(layers)) {
        layers = new _Collection_js__WEBPACK_IMPORTED_MODULE_2__["default"](layers.slice(), {unique: true});
      } else {
        (0,_asserts_js__WEBPACK_IMPORTED_MODULE_3__.assert)(
          typeof (/** @type {?} */ (layers).getArray) === 'function',
          'Expected `layers` to be an array or a `Collection`'
        );
      }
    } else {
      layers = new _Collection_js__WEBPACK_IMPORTED_MODULE_2__["default"](undefined, {unique: true});
    }

    this.setLayers(layers);
  }

  /**
   * @private
   */
  handleLayerChange_() {
    this.changed();
  }

  /**
   * @private
   */
  handleLayersChanged_() {
    this.layersListenerKeys_.forEach(_events_js__WEBPACK_IMPORTED_MODULE_4__.unlistenByKey);
    this.layersListenerKeys_.length = 0;

    const layers = this.getLayers();
    this.layersListenerKeys_.push(
      (0,_events_js__WEBPACK_IMPORTED_MODULE_4__.listen)(layers, _CollectionEventType_js__WEBPACK_IMPORTED_MODULE_5__["default"].ADD, this.handleLayersAdd_, this),
      (0,_events_js__WEBPACK_IMPORTED_MODULE_4__.listen)(layers, _CollectionEventType_js__WEBPACK_IMPORTED_MODULE_5__["default"].REMOVE, this.handleLayersRemove_, this)
    );

    for (const id in this.listenerKeys_) {
      this.listenerKeys_[id].forEach(_events_js__WEBPACK_IMPORTED_MODULE_4__.unlistenByKey);
    }
    (0,_obj_js__WEBPACK_IMPORTED_MODULE_6__.clear)(this.listenerKeys_);

    const layersArray = layers.getArray();
    for (let i = 0, ii = layersArray.length; i < ii; i++) {
      const layer = layersArray[i];
      this.registerLayerListeners_(layer);
      this.dispatchEvent(new GroupEvent('addlayer', layer));
    }
    this.changed();
  }

  /**
   * @param {BaseLayer} layer The layer.
   */
  registerLayerListeners_(layer) {
    const listenerKeys = [
      (0,_events_js__WEBPACK_IMPORTED_MODULE_4__.listen)(
        layer,
        _ObjectEventType_js__WEBPACK_IMPORTED_MODULE_7__["default"].PROPERTYCHANGE,
        this.handleLayerChange_,
        this
      ),
      (0,_events_js__WEBPACK_IMPORTED_MODULE_4__.listen)(layer, _events_EventType_js__WEBPACK_IMPORTED_MODULE_8__["default"].CHANGE, this.handleLayerChange_, this),
    ];

    if (layer instanceof LayerGroup) {
      listenerKeys.push(
        (0,_events_js__WEBPACK_IMPORTED_MODULE_4__.listen)(layer, 'addlayer', this.handleLayerGroupAdd_, this),
        (0,_events_js__WEBPACK_IMPORTED_MODULE_4__.listen)(layer, 'removelayer', this.handleLayerGroupRemove_, this)
      );
    }

    this.listenerKeys_[(0,_util_js__WEBPACK_IMPORTED_MODULE_9__.getUid)(layer)] = listenerKeys;
  }

  /**
   * @param {GroupEvent} event The layer group event.
   */
  handleLayerGroupAdd_(event) {
    this.dispatchEvent(new GroupEvent('addlayer', event.layer));
  }

  /**
   * @param {GroupEvent} event The layer group event.
   */
  handleLayerGroupRemove_(event) {
    this.dispatchEvent(new GroupEvent('removelayer', event.layer));
  }

  /**
   * @param {import("../Collection.js").CollectionEvent<import("./Base.js").default>} collectionEvent CollectionEvent.
   * @private
   */
  handleLayersAdd_(collectionEvent) {
    const layer = collectionEvent.element;
    this.registerLayerListeners_(layer);
    this.dispatchEvent(new GroupEvent('addlayer', layer));
    this.changed();
  }

  /**
   * @param {import("../Collection.js").CollectionEvent<import("./Base.js").default>} collectionEvent CollectionEvent.
   * @private
   */
  handleLayersRemove_(collectionEvent) {
    const layer = collectionEvent.element;
    const key = (0,_util_js__WEBPACK_IMPORTED_MODULE_9__.getUid)(layer);
    this.listenerKeys_[key].forEach(_events_js__WEBPACK_IMPORTED_MODULE_4__.unlistenByKey);
    delete this.listenerKeys_[key];
    this.dispatchEvent(new GroupEvent('removelayer', layer));
    this.changed();
  }

  /**
   * Returns the {@link module:ol/Collection~Collection collection} of {@link module:ol/layer/Layer~Layer layers}
   * in this group.
   * @return {!Collection<import("./Base.js").default>} Collection of
   *   {@link module:ol/layer/Base~BaseLayer layers} that are part of this group.
   * @observable
   * @api
   */
  getLayers() {
    return /** @type {!Collection<import("./Base.js").default>} */ (
      this.get(Property.LAYERS)
    );
  }

  /**
   * Set the {@link module:ol/Collection~Collection collection} of {@link module:ol/layer/Layer~Layer layers}
   * in this group.
   * @param {!Collection<import("./Base.js").default>} layers Collection of
   *   {@link module:ol/layer/Base~BaseLayer layers} that are part of this group.
   * @observable
   * @api
   */
  setLayers(layers) {
    const collection = this.getLayers();
    if (collection) {
      const currentLayers = collection.getArray();
      for (let i = 0, ii = currentLayers.length; i < ii; ++i) {
        this.dispatchEvent(new GroupEvent('removelayer', currentLayers[i]));
      }
    }

    this.set(Property.LAYERS, layers);
  }

  /**
   * @param {Array<import("./Layer.js").default>} [array] Array of layers (to be modified in place).
   * @return {Array<import("./Layer.js").default>} Array of layers.
   */
  getLayersArray(array) {
    array = array !== undefined ? array : [];
    this.getLayers().forEach(function (layer) {
      layer.getLayersArray(array);
    });
    return array;
  }

  /**
   * Get the layer states list and use this groups z-index as the default
   * for all layers in this and nested groups, if it is unset at this point.
   * If dest is not provided and this group's z-index is undefined
   * 0 is used a the default z-index.
   * @param {Array<import("./Layer.js").State>} [dest] Optional list
   * of layer states (to be modified in place).
   * @return {Array<import("./Layer.js").State>} List of layer states.
   */
  getLayerStatesArray(dest) {
    const states = dest !== undefined ? dest : [];
    const pos = states.length;

    this.getLayers().forEach(function (layer) {
      layer.getLayerStatesArray(states);
    });

    const ownLayerState = this.getLayerState();
    let defaultZIndex = ownLayerState.zIndex;
    if (!dest && ownLayerState.zIndex === undefined) {
      defaultZIndex = 0;
    }
    for (let i = pos, ii = states.length; i < ii; i++) {
      const layerState = states[i];
      layerState.opacity *= ownLayerState.opacity;
      layerState.visible = layerState.visible && ownLayerState.visible;
      layerState.maxResolution = Math.min(
        layerState.maxResolution,
        ownLayerState.maxResolution
      );
      layerState.minResolution = Math.max(
        layerState.minResolution,
        ownLayerState.minResolution
      );
      layerState.minZoom = Math.max(layerState.minZoom, ownLayerState.minZoom);
      layerState.maxZoom = Math.min(layerState.maxZoom, ownLayerState.maxZoom);
      if (ownLayerState.extent !== undefined) {
        if (layerState.extent !== undefined) {
          layerState.extent = (0,_extent_js__WEBPACK_IMPORTED_MODULE_10__.getIntersection)(
            layerState.extent,
            ownLayerState.extent
          );
        } else {
          layerState.extent = ownLayerState.extent;
        }
      }
      if (layerState.zIndex === undefined) {
        layerState.zIndex = defaultZIndex;
      }
    }

    return states;
  }

  /**
   * @return {import("../source/Source.js").State} Source state.
   */
  getSourceState() {
    return 'ready';
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (LayerGroup);


/***/ }),

/***/ "./node_modules/ol/layer/Layer.js":
/*!****************************************!*\
  !*** ./node_modules/ol/layer/Layer.js ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   inView: () => (/* binding */ inView)
/* harmony export */ });
/* harmony import */ var _Base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.js */ "./node_modules/ol/layer/Base.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../events/EventType.js */ "./node_modules/ol/events/EventType.js");
/* harmony import */ var _Property_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Property.js */ "./node_modules/ol/layer/Property.js");
/* harmony import */ var _render_EventType_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../render/EventType.js */ "./node_modules/ol/render/EventType.js");
/* harmony import */ var _View_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../View.js */ "./node_modules/ol/View.js");
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../asserts.js */ "./node_modules/ol/asserts.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../events.js */ "./node_modules/ol/events.js");
/**
 * @module ol/layer/Layer
 */









/**
 * @typedef {function(import("../Map.js").FrameState):HTMLElement} RenderFunction
 */

/**
 * @typedef {'sourceready'|'change:source'} LayerEventType
 */

/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("./Base").BaseLayerObjectEventTypes|
 *     LayerEventType, import("../Object").ObjectEvent, Return> &
 *   import("../Observable").OnSignature<import("../render/EventType").LayerRenderEventTypes, import("../render/Event").default, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("./Base").BaseLayerObjectEventTypes|LayerEventType|
 *     import("../render/EventType").LayerRenderEventTypes, Return>} LayerOnSignature
 */

/**
 * @template {import("../source/Source.js").default} [SourceType=import("../source/Source.js").default]
 * @typedef {Object} Options
 * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.
 * @property {number} [opacity=1] Opacity (0, 1).
 * @property {boolean} [visible=true] Visibility.
 * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
 * rendered outside of this extent.
 * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
 * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
 * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
 * method was used.
 * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
 * visible.
 * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
 * be visible.
 * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be
 * visible.
 * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will
 * be visible.
 * @property {SourceType} [source] Source for this layer.  If not provided to the constructor,
 * the source can be set by calling {@link module:ol/layer/Layer~Layer#setSource layer.setSource(source)} after
 * construction.
 * @property {import("../Map.js").default|null} [map] Map.
 * @property {RenderFunction} [render] Render function. Takes the frame state as input and is expected to return an
 * HTML element. Will overwrite the default rendering for the layer.
 * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.
 */

/**
 * @typedef {Object} State
 * @property {import("./Layer.js").default} layer Layer.
 * @property {number} opacity Opacity, the value is rounded to two digits to appear after the decimal point.
 * @property {boolean} visible Visible.
 * @property {boolean} managed Managed.
 * @property {import("../extent.js").Extent} [extent] Extent.
 * @property {number | undefined} zIndex ZIndex.
 * @property {number} maxResolution Maximum resolution.
 * @property {number} minResolution Minimum resolution.
 * @property {number} minZoom Minimum zoom.
 * @property {number} maxZoom Maximum zoom.
 */

/**
 * @classdesc
 * Base class from which all layer types are derived. This should only be instantiated
 * in the case where a custom layer is added to the map with a custom `render` function.
 * Such a function can be specified in the `options` object, and is expected to return an HTML element.
 *
 * A visual representation of raster or vector map data.
 * Layers group together those properties that pertain to how the data is to be
 * displayed, irrespective of the source of that data.
 *
 * Layers are usually added to a map with [map.addLayer()]{@link import("../Map.js").default#addLayer}.
 * Components like {@link module:ol/interaction/Draw~Draw} use unmanaged layers
 * internally. These unmanaged layers are associated with the map using
 * [layer.setMap()]{@link module:ol/layer/Layer~Layer#setMap} instead.
 *
 * A generic `change` event is fired when the state of the source changes.
 * A `sourceready` event is fired when the layer's source is ready.
 *
 * @fires import("../render/Event.js").RenderEvent#prerender
 * @fires import("../render/Event.js").RenderEvent#postrender
 * @fires import("../events/Event.js").BaseEvent#sourceready
 *
 * @template {import("../source/Source.js").default} [SourceType=import("../source/Source.js").default]
 * @template {import("../renderer/Layer.js").default} [RendererType=import("../renderer/Layer.js").default]
 * @api
 */
class Layer extends _Base_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {Options<SourceType>} options Layer options.
   */
  constructor(options) {
    const baseOptions = Object.assign({}, options);
    delete baseOptions.source;

    super(baseOptions);

    /***
     * @type {LayerOnSignature<import("../events").EventsKey>}
     */
    this.on;

    /***
     * @type {LayerOnSignature<import("../events").EventsKey>}
     */
    this.once;

    /***
     * @type {LayerOnSignature<void>}
     */
    this.un;

    /**
     * @private
     * @type {?import("../events.js").EventsKey}
     */
    this.mapPrecomposeKey_ = null;

    /**
     * @private
     * @type {?import("../events.js").EventsKey}
     */
    this.mapRenderKey_ = null;

    /**
     * @private
     * @type {?import("../events.js").EventsKey}
     */
    this.sourceChangeKey_ = null;

    /**
     * @private
     * @type {RendererType}
     */
    this.renderer_ = null;

    /**
     * @private
     * @type {boolean}
     */
    this.sourceReady_ = false;

    /**
     * @protected
     * @type {boolean}
     */
    this.rendered = false;

    // Overwrite default render method with a custom one
    if (options.render) {
      this.render = options.render;
    }

    if (options.map) {
      this.setMap(options.map);
    }

    this.addChangeListener(
      _Property_js__WEBPACK_IMPORTED_MODULE_1__["default"].SOURCE,
      this.handleSourcePropertyChange_
    );

    const source = options.source
      ? /** @type {SourceType} */ (options.source)
      : null;
    this.setSource(source);
  }

  /**
   * @param {Array<import("./Layer.js").default>} [array] Array of layers (to be modified in place).
   * @return {Array<import("./Layer.js").default>} Array of layers.
   */
  getLayersArray(array) {
    array = array ? array : [];
    array.push(this);
    return array;
  }

  /**
   * @param {Array<import("./Layer.js").State>} [states] Optional list of layer states (to be modified in place).
   * @return {Array<import("./Layer.js").State>} List of layer states.
   */
  getLayerStatesArray(states) {
    states = states ? states : [];
    states.push(this.getLayerState());
    return states;
  }

  /**
   * Get the layer source.
   * @return {SourceType|null} The layer source (or `null` if not yet set).
   * @observable
   * @api
   */
  getSource() {
    return /** @type {SourceType} */ (this.get(_Property_js__WEBPACK_IMPORTED_MODULE_1__["default"].SOURCE)) || null;
  }

  /**
   * @return {SourceType|null} The source being rendered.
   */
  getRenderSource() {
    return this.getSource();
  }

  /**
   * @return {import("../source/Source.js").State} Source state.
   */
  getSourceState() {
    const source = this.getSource();
    return !source ? 'undefined' : source.getState();
  }

  /**
   * @private
   */
  handleSourceChange_() {
    this.changed();
    if (this.sourceReady_ || this.getSource().getState() !== 'ready') {
      return;
    }
    this.sourceReady_ = true;
    this.dispatchEvent('sourceready');
  }

  /**
   * @private
   */
  handleSourcePropertyChange_() {
    if (this.sourceChangeKey_) {
      (0,_events_js__WEBPACK_IMPORTED_MODULE_2__.unlistenByKey)(this.sourceChangeKey_);
      this.sourceChangeKey_ = null;
    }
    this.sourceReady_ = false;
    const source = this.getSource();
    if (source) {
      this.sourceChangeKey_ = (0,_events_js__WEBPACK_IMPORTED_MODULE_2__.listen)(
        source,
        _events_EventType_js__WEBPACK_IMPORTED_MODULE_3__["default"].CHANGE,
        this.handleSourceChange_,
        this
      );
      if (source.getState() === 'ready') {
        this.sourceReady_ = true;
        setTimeout(() => {
          this.dispatchEvent('sourceready');
        }, 0);
      }
    }
    this.changed();
  }

  /**
   * @param {import("../pixel").Pixel} pixel Pixel.
   * @return {Promise<Array<import("../Feature").FeatureLike>>} Promise that resolves with
   * an array of features.
   */
  getFeatures(pixel) {
    if (!this.renderer_) {
      return Promise.resolve([]);
    }
    return this.renderer_.getFeatures(pixel);
  }

  /**
   * @param {import("../pixel").Pixel} pixel Pixel.
   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.
   */
  getData(pixel) {
    if (!this.renderer_ || !this.rendered) {
      return null;
    }
    return this.renderer_.getData(pixel);
  }

  /**
   * The layer is visible on the map view, i.e. within its min/max resolution or zoom and
   * extent, not set to `visible: false`, and not inside a layer group that is set
   * to `visible: false`.
   * @param {View|import("../View.js").ViewStateLayerStateExtent} [view] View or {@link import("../Map.js").FrameState}.
   * Only required when the layer is not added to a map.
   * @return {boolean} The layer is visible in the map view.
   * @api
   */
  isVisible(view) {
    let frameState;
    const map = this.getMapInternal();
    if (!view && map) {
      view = map.getView();
    }
    if (view instanceof _View_js__WEBPACK_IMPORTED_MODULE_4__["default"]) {
      frameState = {
        viewState: view.getState(),
        extent: view.calculateExtent(),
      };
    } else {
      frameState = view;
    }
    if (!frameState.layerStatesArray && map) {
      frameState.layerStatesArray = map.getLayerGroup().getLayerStatesArray();
    }
    let layerState;
    if (frameState.layerStatesArray) {
      layerState = frameState.layerStatesArray.find(
        (layerState) => layerState.layer === this
      );
    } else {
      layerState = this.getLayerState();
    }

    const layerExtent = this.getExtent();

    return (
      inView(layerState, frameState.viewState) &&
      (!layerExtent || (0,_extent_js__WEBPACK_IMPORTED_MODULE_5__.intersects)(layerExtent, frameState.extent))
    );
  }

  /**
   * Get the attributions of the source of this layer for the given view.
   * @param {View|import("../View.js").ViewStateLayerStateExtent} [view] View or {@link import("../Map.js").FrameState}.
   * Only required when the layer is not added to a map.
   * @return {Array<string>} Attributions for this layer at the given view.
   * @api
   */
  getAttributions(view) {
    if (!this.isVisible(view)) {
      return [];
    }
    let getAttributions;
    const source = this.getSource();
    if (source) {
      getAttributions = source.getAttributions();
    }
    if (!getAttributions) {
      return [];
    }
    const frameState =
      view instanceof _View_js__WEBPACK_IMPORTED_MODULE_4__["default"] ? view.getViewStateAndExtent() : view;
    let attributions = getAttributions(frameState);
    if (!Array.isArray(attributions)) {
      attributions = [attributions];
    }
    return attributions;
  }

  /**
   * In charge to manage the rendering of the layer. One layer type is
   * bounded with one layer renderer.
   * @param {?import("../Map.js").FrameState} frameState Frame state.
   * @param {HTMLElement} target Target which the renderer may (but need not) use
   * for rendering its content.
   * @return {HTMLElement|null} The rendered element.
   */
  render(frameState, target) {
    const layerRenderer = this.getRenderer();

    if (layerRenderer.prepareFrame(frameState)) {
      this.rendered = true;
      return layerRenderer.renderFrame(frameState, target);
    }
    return null;
  }

  /**
   * Called when a layer is not visible during a map render.
   */
  unrender() {
    this.rendered = false;
  }

  /**
   * For use inside the library only.
   * @param {import("../Map.js").default|null} map Map.
   */
  setMapInternal(map) {
    if (!map) {
      this.unrender();
    }
    this.set(_Property_js__WEBPACK_IMPORTED_MODULE_1__["default"].MAP, map);
  }

  /**
   * For use inside the library only.
   * @return {import("../Map.js").default|null} Map.
   */
  getMapInternal() {
    return this.get(_Property_js__WEBPACK_IMPORTED_MODULE_1__["default"].MAP);
  }

  /**
   * Sets the layer to be rendered on top of other layers on a map. The map will
   * not manage this layer in its layers collection. This
   * is useful for temporary layers. To remove an unmanaged layer from the map,
   * use `#setMap(null)`.
   *
   * To add the layer to a map and have it managed by the map, use
   * {@link module:ol/Map~Map#addLayer} instead.
   * @param {import("../Map.js").default|null} map Map.
   * @api
   */
  setMap(map) {
    if (this.mapPrecomposeKey_) {
      (0,_events_js__WEBPACK_IMPORTED_MODULE_2__.unlistenByKey)(this.mapPrecomposeKey_);
      this.mapPrecomposeKey_ = null;
    }
    if (!map) {
      this.changed();
    }
    if (this.mapRenderKey_) {
      (0,_events_js__WEBPACK_IMPORTED_MODULE_2__.unlistenByKey)(this.mapRenderKey_);
      this.mapRenderKey_ = null;
    }
    if (map) {
      this.mapPrecomposeKey_ = (0,_events_js__WEBPACK_IMPORTED_MODULE_2__.listen)(
        map,
        _render_EventType_js__WEBPACK_IMPORTED_MODULE_6__["default"].PRECOMPOSE,
        function (evt) {
          const renderEvent =
            /** @type {import("../render/Event.js").default} */ (evt);
          const layerStatesArray = renderEvent.frameState.layerStatesArray;
          const layerState = this.getLayerState(false);
          (0,_asserts_js__WEBPACK_IMPORTED_MODULE_7__.assert)(
            !layerStatesArray.some(function (arrayLayerState) {
              return arrayLayerState.layer === layerState.layer;
            }),
            'A layer can only be added to the map once. Use either `layer.setMap()` or `map.addLayer()`, not both.'
          );
          layerStatesArray.push(layerState);
        },
        this
      );
      this.mapRenderKey_ = (0,_events_js__WEBPACK_IMPORTED_MODULE_2__.listen)(this, _events_EventType_js__WEBPACK_IMPORTED_MODULE_3__["default"].CHANGE, map.render, map);
      this.changed();
    }
  }

  /**
   * Set the layer source.
   * @param {SourceType|null} source The layer source.
   * @observable
   * @api
   */
  setSource(source) {
    this.set(_Property_js__WEBPACK_IMPORTED_MODULE_1__["default"].SOURCE, source);
  }

  /**
   * Get the renderer for this layer.
   * @return {RendererType|null} The layer renderer.
   */
  getRenderer() {
    if (!this.renderer_) {
      this.renderer_ = this.createRenderer();
    }
    return this.renderer_;
  }

  /**
   * @return {boolean} The layer has a renderer.
   */
  hasRenderer() {
    return !!this.renderer_;
  }

  /**
   * Create a renderer for this layer.
   * @return {RendererType} A layer renderer.
   * @protected
   */
  createRenderer() {
    return null;
  }

  /**
   * Clean up.
   */
  disposeInternal() {
    if (this.renderer_) {
      this.renderer_.dispose();
      delete this.renderer_;
    }

    this.setSource(null);
    super.disposeInternal();
  }
}

/**
 * Return `true` if the layer is visible and if the provided view state
 * has resolution and zoom levels that are in range of the layer's min/max.
 * @param {State} layerState Layer state.
 * @param {import("../View.js").State} viewState View state.
 * @return {boolean} The layer is visible at the given view state.
 */
function inView(layerState, viewState) {
  if (!layerState.visible) {
    return false;
  }
  const resolution = viewState.resolution;
  if (
    resolution < layerState.minResolution ||
    resolution >= layerState.maxResolution
  ) {
    return false;
  }
  const zoom = viewState.zoom;
  return zoom > layerState.minZoom && zoom <= layerState.maxZoom;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Layer);


/***/ }),

/***/ "./node_modules/ol/layer/Property.js":
/*!*******************************************!*\
  !*** ./node_modules/ol/layer/Property.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * @module ol/layer/Property
 */

/**
 * @enum {string}
 */
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  OPACITY: 'opacity',
  VISIBLE: 'visible',
  EXTENT: 'extent',
  Z_INDEX: 'zIndex',
  MAX_RESOLUTION: 'maxResolution',
  MIN_RESOLUTION: 'minResolution',
  MAX_ZOOM: 'maxZoom',
  MIN_ZOOM: 'minZoom',
  SOURCE: 'source',
  MAP: 'map',
});


/***/ }),

/***/ "./node_modules/ol/layer/Tile.js":
/*!***************************************!*\
  !*** ./node_modules/ol/layer/Tile.js ***!
  \***************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _BaseTile_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BaseTile.js */ "./node_modules/ol/layer/BaseTile.js");
/* harmony import */ var _renderer_canvas_TileLayer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../renderer/canvas/TileLayer.js */ "./node_modules/ol/renderer/canvas/TileLayer.js");
/**
 * @module ol/layer/Tile
 */



/**
 * @classdesc
 * For layer sources that provide pre-rendered, tiled images in grids that are
 * organized by zoom levels for specific resolutions.
 * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}
 * property on the layer object; for example, setting `title: 'My Title'` in the
 * options means that `title` is observable, and has get/set accessors.
 *
 * @template {import("../source/Tile.js").default} TileSourceType
 * @extends BaseTileLayer<TileSourceType, CanvasTileLayerRenderer>
 * @api
 */
class TileLayer extends _BaseTile_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {import("./BaseTile.js").Options<TileSourceType>} [options] Tile layer options.
   */
  constructor(options) {
    super(options);
  }

  createRenderer() {
    return new _renderer_canvas_TileLayer_js__WEBPACK_IMPORTED_MODULE_1__["default"](this);
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (TileLayer);


/***/ }),

/***/ "./node_modules/ol/layer/TileProperty.js":
/*!***********************************************!*\
  !*** ./node_modules/ol/layer/TileProperty.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * @module ol/layer/TileProperty
 */

/**
 * @enum {string}
 */
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  PRELOAD: 'preload',
  USE_INTERIM_TILES_ON_ERROR: 'useInterimTilesOnError',
});


/***/ }),

/***/ "./node_modules/ol/layer/Vector.js":
/*!*****************************************!*\
  !*** ./node_modules/ol/layer/Vector.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _BaseVector_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BaseVector.js */ "./node_modules/ol/layer/BaseVector.js");
/* harmony import */ var _renderer_canvas_VectorLayer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../renderer/canvas/VectorLayer.js */ "./node_modules/ol/renderer/canvas/VectorLayer.js");
/**
 * @module ol/layer/Vector
 */



/**
 * @classdesc
 * Vector data is rendered client-side, as vectors. This layer type provides most accurate rendering
 * even during animations. Points and labels stay upright on rotated views. For very large
 * amounts of vector data, performance may suffer during pan and zoom animations. In this case,
 * try {@link module:ol/layer/VectorImage~VectorImageLayer}.
 *
 * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}
 * property on the layer object; for example, setting `title: 'My Title'` in the
 * options means that `title` is observable, and has get/set accessors.
 *
 * @template {import("../source/Vector.js").default} VectorSourceType
 * @extends {BaseVectorLayer<VectorSourceType, CanvasVectorLayerRenderer>}
 * @api
 */
class VectorLayer extends _BaseVector_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {import("./BaseVector.js").Options<VectorSourceType>} [options] Options.
   */
  constructor(options) {
    super(options);
  }

  createRenderer() {
    return new _renderer_canvas_VectorLayer_js__WEBPACK_IMPORTED_MODULE_1__["default"](this);
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (VectorLayer);


/***/ }),

/***/ "./node_modules/ol/loadingstrategy.js":
/*!********************************************!*\
  !*** ./node_modules/ol/loadingstrategy.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   all: () => (/* binding */ all),
/* harmony export */   bbox: () => (/* binding */ bbox),
/* harmony export */   tile: () => (/* binding */ tile)
/* harmony export */ });
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./proj.js */ "./node_modules/ol/proj.js");
/**
 * @module ol/loadingstrategy
 */



/**
 * Strategy function for loading all features with a single request.
 * @param {import("./extent.js").Extent} extent Extent.
 * @param {number} resolution Resolution.
 * @return {Array<import("./extent.js").Extent>} Extents.
 * @api
 */
function all(extent, resolution) {
  return [[-Infinity, -Infinity, Infinity, Infinity]];
}

/**
 * Strategy function for loading features based on the view's extent and
 * resolution.
 * @param {import("./extent.js").Extent} extent Extent.
 * @param {number} resolution Resolution.
 * @return {Array<import("./extent.js").Extent>} Extents.
 * @api
 */
function bbox(extent, resolution) {
  return [extent];
}

/**
 * Creates a strategy function for loading features based on a tile grid.
 * @param {import("./tilegrid/TileGrid.js").default} tileGrid Tile grid.
 * @return {function(import("./extent.js").Extent, number, import("./proj.js").Projection): Array<import("./extent.js").Extent>} Loading strategy.
 * @api
 */
function tile(tileGrid) {
  return (
    /**
     * @param {import("./extent.js").Extent} extent Extent.
     * @param {number} resolution Resolution.
     * @param {import("./proj.js").Projection} projection Projection.
     * @return {Array<import("./extent.js").Extent>} Extents.
     */
    function (extent, resolution, projection) {
      const z = tileGrid.getZForResolution(
        (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.fromUserResolution)(resolution, projection)
      );
      const tileRange = tileGrid.getTileRangeForExtentAndZ(
        (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.fromUserExtent)(extent, projection),
        z
      );
      /** @type {Array<import("./extent.js").Extent>} */
      const extents = [];
      /** @type {import("./tilecoord.js").TileCoord} */
      const tileCoord = [z, 0, 0];
      for (
        tileCoord[1] = tileRange.minX;
        tileCoord[1] <= tileRange.maxX;
        ++tileCoord[1]
      ) {
        for (
          tileCoord[2] = tileRange.minY;
          tileCoord[2] <= tileRange.maxY;
          ++tileCoord[2]
        ) {
          extents.push(
            (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.toUserExtent)(tileGrid.getTileCoordExtent(tileCoord), projection)
          );
        }
      }
      return extents;
    }
  );
}


/***/ }),

/***/ "./node_modules/ol/math.js":
/*!*********************************!*\
  !*** ./node_modules/ol/math.js ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ceil: () => (/* binding */ ceil),
/* harmony export */   clamp: () => (/* binding */ clamp),
/* harmony export */   floor: () => (/* binding */ floor),
/* harmony export */   lerp: () => (/* binding */ lerp),
/* harmony export */   modulo: () => (/* binding */ modulo),
/* harmony export */   round: () => (/* binding */ round),
/* harmony export */   solveLinearSystem: () => (/* binding */ solveLinearSystem),
/* harmony export */   squaredDistance: () => (/* binding */ squaredDistance),
/* harmony export */   squaredSegmentDistance: () => (/* binding */ squaredSegmentDistance),
/* harmony export */   toDegrees: () => (/* binding */ toDegrees),
/* harmony export */   toFixed: () => (/* binding */ toFixed),
/* harmony export */   toRadians: () => (/* binding */ toRadians)
/* harmony export */ });
/**
 * @module ol/math
 */

/**
 * Takes a number and clamps it to within the provided bounds.
 * @param {number} value The input number.
 * @param {number} min The minimum value to return.
 * @param {number} max The maximum value to return.
 * @return {number} The input number if it is within bounds, or the nearest
 *     number within the bounds.
 */
function clamp(value, min, max) {
  return Math.min(Math.max(value, min), max);
}

/**
 * Returns the square of the closest distance between the point (x, y) and the
 * line segment (x1, y1) to (x2, y2).
 * @param {number} x X.
 * @param {number} y Y.
 * @param {number} x1 X1.
 * @param {number} y1 Y1.
 * @param {number} x2 X2.
 * @param {number} y2 Y2.
 * @return {number} Squared distance.
 */
function squaredSegmentDistance(x, y, x1, y1, x2, y2) {
  const dx = x2 - x1;
  const dy = y2 - y1;
  if (dx !== 0 || dy !== 0) {
    const t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);
    if (t > 1) {
      x1 = x2;
      y1 = y2;
    } else if (t > 0) {
      x1 += dx * t;
      y1 += dy * t;
    }
  }
  return squaredDistance(x, y, x1, y1);
}

/**
 * Returns the square of the distance between the points (x1, y1) and (x2, y2).
 * @param {number} x1 X1.
 * @param {number} y1 Y1.
 * @param {number} x2 X2.
 * @param {number} y2 Y2.
 * @return {number} Squared distance.
 */
function squaredDistance(x1, y1, x2, y2) {
  const dx = x2 - x1;
  const dy = y2 - y1;
  return dx * dx + dy * dy;
}

/**
 * Solves system of linear equations using Gaussian elimination method.
 *
 * @param {Array<Array<number>>} mat Augmented matrix (n x n + 1 column)
 *                                     in row-major order.
 * @return {Array<number>} The resulting vector.
 */
function solveLinearSystem(mat) {
  const n = mat.length;

  for (let i = 0; i < n; i++) {
    // Find max in the i-th column (ignoring i - 1 first rows)
    let maxRow = i;
    let maxEl = Math.abs(mat[i][i]);
    for (let r = i + 1; r < n; r++) {
      const absValue = Math.abs(mat[r][i]);
      if (absValue > maxEl) {
        maxEl = absValue;
        maxRow = r;
      }
    }

    if (maxEl === 0) {
      return null; // matrix is singular
    }

    // Swap max row with i-th (current) row
    const tmp = mat[maxRow];
    mat[maxRow] = mat[i];
    mat[i] = tmp;

    // Subtract the i-th row to make all the remaining rows 0 in the i-th column
    for (let j = i + 1; j < n; j++) {
      const coef = -mat[j][i] / mat[i][i];
      for (let k = i; k < n + 1; k++) {
        if (i == k) {
          mat[j][k] = 0;
        } else {
          mat[j][k] += coef * mat[i][k];
        }
      }
    }
  }

  // Solve Ax=b for upper triangular matrix A (mat)
  const x = new Array(n);
  for (let l = n - 1; l >= 0; l--) {
    x[l] = mat[l][n] / mat[l][l];
    for (let m = l - 1; m >= 0; m--) {
      mat[m][n] -= mat[m][l] * x[l];
    }
  }
  return x;
}

/**
 * Converts radians to to degrees.
 *
 * @param {number} angleInRadians Angle in radians.
 * @return {number} Angle in degrees.
 */
function toDegrees(angleInRadians) {
  return (angleInRadians * 180) / Math.PI;
}

/**
 * Converts degrees to radians.
 *
 * @param {number} angleInDegrees Angle in degrees.
 * @return {number} Angle in radians.
 */
function toRadians(angleInDegrees) {
  return (angleInDegrees * Math.PI) / 180;
}

/**
 * Returns the modulo of a / b, depending on the sign of b.
 *
 * @param {number} a Dividend.
 * @param {number} b Divisor.
 * @return {number} Modulo.
 */
function modulo(a, b) {
  const r = a % b;
  return r * b < 0 ? r + b : r;
}

/**
 * Calculates the linearly interpolated value of x between a and b.
 *
 * @param {number} a Number
 * @param {number} b Number
 * @param {number} x Value to be interpolated.
 * @return {number} Interpolated value.
 */
function lerp(a, b, x) {
  return a + x * (b - a);
}

/**
 * Returns a number with a limited number of decimal digits.
 * @param {number} n The input number.
 * @param {number} decimals The maximum number of decimal digits.
 * @return {number} The input number with a limited number of decimal digits.
 */
function toFixed(n, decimals) {
  const factor = Math.pow(10, decimals);
  return Math.round(n * factor) / factor;
}

/**
 * Rounds a number to the nearest integer value considering only the given number
 * of decimal digits (with rounding on the final digit).
 * @param {number} n The input number.
 * @param {number} decimals The maximum number of decimal digits.
 * @return {number} The nearest integer.
 */
function round(n, decimals) {
  return Math.round(toFixed(n, decimals));
}

/**
 * Rounds a number to the next smaller integer considering only the given number
 * of decimal digits (with rounding on the final digit).
 * @param {number} n The input number.
 * @param {number} decimals The maximum number of decimal digits.
 * @return {number} The next smaller integer.
 */
function floor(n, decimals) {
  return Math.floor(toFixed(n, decimals));
}

/**
 * Rounds a number to the next bigger integer considering only the given number
 * of decimal digits (with rounding on the final digit).
 * @param {number} n The input number.
 * @param {number} decimals The maximum number of decimal digits.
 * @return {number} The next bigger integer.
 */
function ceil(n, decimals) {
  return Math.ceil(toFixed(n, decimals));
}


/***/ }),

/***/ "./node_modules/ol/obj.js":
/*!********************************!*\
  !*** ./node_modules/ol/obj.js ***!
  \********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   clear: () => (/* binding */ clear),
/* harmony export */   isEmpty: () => (/* binding */ isEmpty)
/* harmony export */ });
/**
 * @module ol/obj
 */

/**
 * Removes all properties from an object.
 * @param {Object} object The object to clear.
 */
function clear(object) {
  for (const property in object) {
    delete object[property];
  }
}

/**
 * Determine if an object has any properties.
 * @param {Object} object The object to check.
 * @return {boolean} The object is empty.
 */
function isEmpty(object) {
  let property;
  for (property in object) {
    return false;
  }
  return !property;
}


/***/ }),

/***/ "./node_modules/ol/pointer/EventType.js":
/*!**********************************************!*\
  !*** ./node_modules/ol/pointer/EventType.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * @module ol/pointer/EventType
 */

/**
 * Constants for event names.
 * @enum {string}
 */
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  POINTERMOVE: 'pointermove',
  POINTERDOWN: 'pointerdown',
  POINTERUP: 'pointerup',
  POINTEROVER: 'pointerover',
  POINTEROUT: 'pointerout',
  POINTERENTER: 'pointerenter',
  POINTERLEAVE: 'pointerleave',
  POINTERCANCEL: 'pointercancel',
});


/***/ }),

/***/ "./node_modules/ol/proj.js":
/*!*********************************!*\
  !*** ./node_modules/ol/proj.js ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   METERS_PER_UNIT: () => (/* reexport safe */ _proj_Units_js__WEBPACK_IMPORTED_MODULE_0__.METERS_PER_UNIT),
/* harmony export */   Projection: () => (/* reexport safe */ _proj_Projection_js__WEBPACK_IMPORTED_MODULE_1__["default"]),
/* harmony export */   addCommon: () => (/* binding */ addCommon),
/* harmony export */   addCoordinateTransforms: () => (/* binding */ addCoordinateTransforms),
/* harmony export */   addEquivalentProjections: () => (/* binding */ addEquivalentProjections),
/* harmony export */   addEquivalentTransforms: () => (/* binding */ addEquivalentTransforms),
/* harmony export */   addProjection: () => (/* binding */ addProjection),
/* harmony export */   addProjections: () => (/* binding */ addProjections),
/* harmony export */   clearAllProjections: () => (/* binding */ clearAllProjections),
/* harmony export */   clearUserProjection: () => (/* binding */ clearUserProjection),
/* harmony export */   cloneTransform: () => (/* binding */ cloneTransform),
/* harmony export */   createProjection: () => (/* binding */ createProjection),
/* harmony export */   createSafeCoordinateTransform: () => (/* binding */ createSafeCoordinateTransform),
/* harmony export */   createTransformFromCoordinateTransform: () => (/* binding */ createTransformFromCoordinateTransform),
/* harmony export */   disableCoordinateWarning: () => (/* binding */ disableCoordinateWarning),
/* harmony export */   equivalent: () => (/* binding */ equivalent),
/* harmony export */   fromLonLat: () => (/* binding */ fromLonLat),
/* harmony export */   fromUserCoordinate: () => (/* binding */ fromUserCoordinate),
/* harmony export */   fromUserExtent: () => (/* binding */ fromUserExtent),
/* harmony export */   fromUserResolution: () => (/* binding */ fromUserResolution),
/* harmony export */   get: () => (/* binding */ get),
/* harmony export */   getPointResolution: () => (/* binding */ getPointResolution),
/* harmony export */   getTransform: () => (/* binding */ getTransform),
/* harmony export */   getTransformFromProjections: () => (/* binding */ getTransformFromProjections),
/* harmony export */   getUserProjection: () => (/* binding */ getUserProjection),
/* harmony export */   identityTransform: () => (/* binding */ identityTransform),
/* harmony export */   setUserProjection: () => (/* binding */ setUserProjection),
/* harmony export */   toLonLat: () => (/* binding */ toLonLat),
/* harmony export */   toUserCoordinate: () => (/* binding */ toUserCoordinate),
/* harmony export */   toUserExtent: () => (/* binding */ toUserExtent),
/* harmony export */   toUserResolution: () => (/* binding */ toUserResolution),
/* harmony export */   transform: () => (/* binding */ transform),
/* harmony export */   transformExtent: () => (/* binding */ transformExtent),
/* harmony export */   transformWithProjections: () => (/* binding */ transformWithProjections),
/* harmony export */   useGeographic: () => (/* binding */ useGeographic)
/* harmony export */ });
/* harmony import */ var _proj_Projection_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./proj/Projection.js */ "./node_modules/ol/proj/Projection.js");
/* harmony import */ var _proj_epsg3857_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./proj/epsg3857.js */ "./node_modules/ol/proj/epsg3857.js");
/* harmony import */ var _proj_epsg4326_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./proj/epsg4326.js */ "./node_modules/ol/proj/epsg4326.js");
/* harmony import */ var _proj_Units_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./proj/Units.js */ "./node_modules/ol/proj/Units.js");
/* harmony import */ var _proj_projections_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./proj/projections.js */ "./node_modules/ol/proj/projections.js");
/* harmony import */ var _proj_transforms_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./proj/transforms.js */ "./node_modules/ol/proj/transforms.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./math.js */ "./node_modules/ol/math.js");
/* harmony import */ var _coordinate_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./coordinate.js */ "./node_modules/ol/coordinate.js");
/* harmony import */ var _sphere_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./sphere.js */ "./node_modules/ol/sphere.js");
/* harmony import */ var _console_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./console.js */ "./node_modules/ol/console.js");
/**
 * @module ol/proj
 */

/**
 * The ol/proj module stores:
 * * a list of {@link module:ol/proj/Projection~Projection}
 * objects, one for each projection supported by the application
 * * a list of transform functions needed to convert coordinates in one projection
 * into another.
 *
 * The static functions are the methods used to maintain these.
 * Each transform function can handle not only simple coordinate pairs, but also
 * large arrays of coordinates such as vector geometries.
 *
 * When loaded, the library adds projection objects for EPSG:4326 (WGS84
 * geographic coordinates) and EPSG:3857 (Web or Spherical Mercator, as used
 * for example by Bing Maps or OpenStreetMap), together with the relevant
 * transform functions.
 *
 * Additional transforms may be added by using the http://proj4js.org/
 * library (version 2.2 or later). You can use the full build supplied by
 * Proj4js, or create a custom build to support those projections you need; see
 * the Proj4js website for how to do this. You also need the Proj4js definitions
 * for the required projections. These definitions can be obtained from
 * https://epsg.io/, and are a JS function, so can be loaded in a script
 * tag (as in the examples) or pasted into your application.
 *
 * After all required projection definitions are added to proj4's registry (by
 * using `proj4.defs()`), simply call `register(proj4)` from the `ol/proj/proj4`
 * package. Existing transforms are not changed by this function. See
 * examples/wms-image-custom-proj for an example of this.
 *
 * Additional projection definitions can be registered with `proj4.defs()` any
 * time. Just make sure to call `register(proj4)` again; for example, with user-supplied data where you don't
 * know in advance what projections are needed, you can initially load minimal
 * support and then load whichever are requested.
 *
 * Note that Proj4js does not support projection extents. If you want to add
 * one for creating default tile grids, you can add it after the Projection
 * object has been created with `setExtent`, for example,
 * `get('EPSG:1234').setExtent(extent)`.
 *
 * In addition to Proj4js support, any transform functions can be added with
 * {@link module:ol/proj.addCoordinateTransforms}. To use this, you must first create
 * a {@link module:ol/proj/Projection~Projection} object for the new projection and add it with
 * {@link module:ol/proj.addProjection}. You can then add the forward and inverse
 * functions with {@link module:ol/proj.addCoordinateTransforms}. See
 * examples/wms-custom-proj for an example of this.
 *
 * Note that if no transforms are needed and you only need to define the
 * projection, just add a {@link module:ol/proj/Projection~Projection} with
 * {@link module:ol/proj.addProjection}. See examples/wms-no-proj for an example of
 * this.
 */












/**
 * A projection as {@link module:ol/proj/Projection~Projection}, SRS identifier
 * string or undefined.
 * @typedef {Projection|string|undefined} ProjectionLike
 * @api
 */

/**
 * A transform function accepts an array of input coordinate values, an optional
 * output array, and an optional dimension (default should be 2).  The function
 * transforms the input coordinate values, populates the output array, and
 * returns the output array.
 *
 * @typedef {function(Array<number>, Array<number>=, number=): Array<number>} TransformFunction
 * @api
 */





let showCoordinateWarning = true;

/**
 * @param {boolean} [disable = true] Disable console info about `useGeographic()`
 */
function disableCoordinateWarning(disable) {
  const hide = disable === undefined ? true : disable;
  showCoordinateWarning = !hide;
}

/**
 * @param {Array<number>} input Input coordinate array.
 * @param {Array<number>} [output] Output array of coordinate values.
 * @return {Array<number>} Output coordinate array (new array, same coordinate
 *     values).
 */
function cloneTransform(input, output) {
  if (output !== undefined) {
    for (let i = 0, ii = input.length; i < ii; ++i) {
      output[i] = input[i];
    }
    output = output;
  } else {
    output = input.slice();
  }
  return output;
}

/**
 * @param {Array<number>} input Input coordinate array.
 * @param {Array<number>} [output] Output array of coordinate values.
 * @return {Array<number>} Input coordinate array (same array as input).
 */
function identityTransform(input, output) {
  if (output !== undefined && input !== output) {
    for (let i = 0, ii = input.length; i < ii; ++i) {
      output[i] = input[i];
    }
    input = output;
  }
  return input;
}

/**
 * Add a Projection object to the list of supported projections that can be
 * looked up by their code.
 *
 * @param {Projection} projection Projection instance.
 * @api
 */
function addProjection(projection) {
  (0,_proj_projections_js__WEBPACK_IMPORTED_MODULE_2__.add)(projection.getCode(), projection);
  (0,_proj_transforms_js__WEBPACK_IMPORTED_MODULE_3__.add)(projection, projection, cloneTransform);
}

/**
 * @param {Array<Projection>} projections Projections.
 */
function addProjections(projections) {
  projections.forEach(addProjection);
}

/**
 * Fetches a Projection object for the code specified.
 *
 * @param {ProjectionLike} projectionLike Either a code string which is
 *     a combination of authority and identifier such as "EPSG:4326", or an
 *     existing projection object, or undefined.
 * @return {Projection|null} Projection object, or null if not in list.
 * @api
 */
function get(projectionLike) {
  return typeof projectionLike === 'string'
    ? (0,_proj_projections_js__WEBPACK_IMPORTED_MODULE_2__.get)(/** @type {string} */ (projectionLike))
    : /** @type {Projection} */ (projectionLike) || null;
}

/**
 * Get the resolution of the point in degrees or distance units.
 * For projections with degrees as the unit this will simply return the
 * provided resolution. For other projections the point resolution is
 * by default estimated by transforming the `point` pixel to EPSG:4326,
 * measuring its width and height on the normal sphere,
 * and taking the average of the width and height.
 * A custom function can be provided for a specific projection, either
 * by setting the `getPointResolution` option in the
 * {@link module:ol/proj/Projection~Projection} constructor or by using
 * {@link module:ol/proj/Projection~Projection#setGetPointResolution} to change an existing
 * projection object.
 * @param {ProjectionLike} projection The projection.
 * @param {number} resolution Nominal resolution in projection units.
 * @param {import("./coordinate.js").Coordinate} point Point to find adjusted resolution at.
 * @param {import("./proj/Units.js").Units} [units] Units to get the point resolution in.
 * Default is the projection's units.
 * @return {number} Point resolution.
 * @api
 */
function getPointResolution(projection, resolution, point, units) {
  projection = get(projection);
  let pointResolution;
  const getter = projection.getPointResolutionFunc();
  if (getter) {
    pointResolution = getter(resolution, point);
    if (units && units !== projection.getUnits()) {
      const metersPerUnit = projection.getMetersPerUnit();
      if (metersPerUnit) {
        pointResolution =
          (pointResolution * metersPerUnit) / _proj_Units_js__WEBPACK_IMPORTED_MODULE_0__.METERS_PER_UNIT[units];
      }
    }
  } else {
    const projUnits = projection.getUnits();
    if ((projUnits == 'degrees' && !units) || units == 'degrees') {
      pointResolution = resolution;
    } else {
      // Estimate point resolution by transforming the center pixel to EPSG:4326,
      // measuring its width and height on the normal sphere, and taking the
      // average of the width and height.
      const toEPSG4326 = getTransformFromProjections(
        projection,
        get('EPSG:4326')
      );
      if (toEPSG4326 === identityTransform && projUnits !== 'degrees') {
        // no transform is available
        pointResolution = resolution * projection.getMetersPerUnit();
      } else {
        let vertices = [
          point[0] - resolution / 2,
          point[1],
          point[0] + resolution / 2,
          point[1],
          point[0],
          point[1] - resolution / 2,
          point[0],
          point[1] + resolution / 2,
        ];
        vertices = toEPSG4326(vertices, vertices, 2);
        const width = (0,_sphere_js__WEBPACK_IMPORTED_MODULE_4__.getDistance)(vertices.slice(0, 2), vertices.slice(2, 4));
        const height = (0,_sphere_js__WEBPACK_IMPORTED_MODULE_4__.getDistance)(vertices.slice(4, 6), vertices.slice(6, 8));
        pointResolution = (width + height) / 2;
      }
      const metersPerUnit = units
        ? _proj_Units_js__WEBPACK_IMPORTED_MODULE_0__.METERS_PER_UNIT[units]
        : projection.getMetersPerUnit();
      if (metersPerUnit !== undefined) {
        pointResolution /= metersPerUnit;
      }
    }
  }
  return pointResolution;
}

/**
 * Registers transformation functions that don't alter coordinates. Those allow
 * to transform between projections with equal meaning.
 *
 * @param {Array<Projection>} projections Projections.
 * @api
 */
function addEquivalentProjections(projections) {
  addProjections(projections);
  projections.forEach(function (source) {
    projections.forEach(function (destination) {
      if (source !== destination) {
        (0,_proj_transforms_js__WEBPACK_IMPORTED_MODULE_3__.add)(source, destination, cloneTransform);
      }
    });
  });
}

/**
 * Registers transformation functions to convert coordinates in any projection
 * in projection1 to any projection in projection2.
 *
 * @param {Array<Projection>} projections1 Projections with equal
 *     meaning.
 * @param {Array<Projection>} projections2 Projections with equal
 *     meaning.
 * @param {TransformFunction} forwardTransform Transformation from any
 *   projection in projection1 to any projection in projection2.
 * @param {TransformFunction} inverseTransform Transform from any projection
 *   in projection2 to any projection in projection1..
 */
function addEquivalentTransforms(
  projections1,
  projections2,
  forwardTransform,
  inverseTransform
) {
  projections1.forEach(function (projection1) {
    projections2.forEach(function (projection2) {
      (0,_proj_transforms_js__WEBPACK_IMPORTED_MODULE_3__.add)(projection1, projection2, forwardTransform);
      (0,_proj_transforms_js__WEBPACK_IMPORTED_MODULE_3__.add)(projection2, projection1, inverseTransform);
    });
  });
}

/**
 * Clear all cached projections and transforms.
 */
function clearAllProjections() {
  (0,_proj_projections_js__WEBPACK_IMPORTED_MODULE_2__.clear)();
  (0,_proj_transforms_js__WEBPACK_IMPORTED_MODULE_3__.clear)();
}

/**
 * @param {Projection|string|undefined} projection Projection.
 * @param {string} defaultCode Default code.
 * @return {Projection} Projection.
 */
function createProjection(projection, defaultCode) {
  if (!projection) {
    return get(defaultCode);
  }
  if (typeof projection === 'string') {
    return get(projection);
  }
  return /** @type {Projection} */ (projection);
}

/**
 * Creates a {@link module:ol/proj~TransformFunction} from a simple 2D coordinate transform
 * function.
 * @param {function(import("./coordinate.js").Coordinate): import("./coordinate.js").Coordinate} coordTransform Coordinate
 *     transform.
 * @return {TransformFunction} Transform function.
 */
function createTransformFromCoordinateTransform(coordTransform) {
  return (
    /**
     * @param {Array<number>} input Input.
     * @param {Array<number>} [output] Output.
     * @param {number} [dimension] Dimension.
     * @return {Array<number>} Output.
     */
    function (input, output, dimension) {
      const length = input.length;
      dimension = dimension !== undefined ? dimension : 2;
      output = output !== undefined ? output : new Array(length);
      for (let i = 0; i < length; i += dimension) {
        const point = coordTransform(input.slice(i, i + dimension));
        const pointLength = point.length;
        for (let j = 0, jj = dimension; j < jj; ++j) {
          output[i + j] = j >= pointLength ? input[i + j] : point[j];
        }
      }
      return output;
    }
  );
}

/**
 * Registers coordinate transform functions to convert coordinates between the
 * source projection and the destination projection.
 * The forward and inverse functions convert coordinate pairs; this function
 * converts these into the functions used internally which also handle
 * extents and coordinate arrays.
 *
 * @param {ProjectionLike} source Source projection.
 * @param {ProjectionLike} destination Destination projection.
 * @param {function(import("./coordinate.js").Coordinate): import("./coordinate.js").Coordinate} forward The forward transform
 *     function (that is, from the source projection to the destination
 *     projection) that takes a {@link module:ol/coordinate~Coordinate} as argument and returns
 *     the transformed {@link module:ol/coordinate~Coordinate}.
 * @param {function(import("./coordinate.js").Coordinate): import("./coordinate.js").Coordinate} inverse The inverse transform
 *     function (that is, from the destination projection to the source
 *     projection) that takes a {@link module:ol/coordinate~Coordinate} as argument and returns
 *     the transformed {@link module:ol/coordinate~Coordinate}. If the transform function can only
 *     transform less dimensions than the input coordinate, it is supposeed to return a coordinate
 *     with only the length it can transform. The other dimensions will be taken unchanged from the
 *     source.
 * @api
 */
function addCoordinateTransforms(source, destination, forward, inverse) {
  const sourceProj = get(source);
  const destProj = get(destination);
  (0,_proj_transforms_js__WEBPACK_IMPORTED_MODULE_3__.add)(
    sourceProj,
    destProj,
    createTransformFromCoordinateTransform(forward)
  );
  (0,_proj_transforms_js__WEBPACK_IMPORTED_MODULE_3__.add)(
    destProj,
    sourceProj,
    createTransformFromCoordinateTransform(inverse)
  );
}

/**
 * Transforms a coordinate from longitude/latitude to a different projection.
 * @param {import("./coordinate.js").Coordinate} coordinate Coordinate as longitude and latitude, i.e.
 *     an array with longitude as 1st and latitude as 2nd element.
 * @param {ProjectionLike} [projection] Target projection. The
 *     default is Web Mercator, i.e. 'EPSG:3857'.
 * @return {import("./coordinate.js").Coordinate} Coordinate projected to the target projection.
 * @api
 */
function fromLonLat(coordinate, projection) {
  disableCoordinateWarning();
  return transform(
    coordinate,
    'EPSG:4326',
    projection !== undefined ? projection : 'EPSG:3857'
  );
}

/**
 * Transforms a coordinate to longitude/latitude.
 * @param {import("./coordinate.js").Coordinate} coordinate Projected coordinate.
 * @param {ProjectionLike} [projection] Projection of the coordinate.
 *     The default is Web Mercator, i.e. 'EPSG:3857'.
 * @return {import("./coordinate.js").Coordinate} Coordinate as longitude and latitude, i.e. an array
 *     with longitude as 1st and latitude as 2nd element.
 * @api
 */
function toLonLat(coordinate, projection) {
  const lonLat = transform(
    coordinate,
    projection !== undefined ? projection : 'EPSG:3857',
    'EPSG:4326'
  );
  const lon = lonLat[0];
  if (lon < -180 || lon > 180) {
    lonLat[0] = (0,_math_js__WEBPACK_IMPORTED_MODULE_5__.modulo)(lon + 180, 360) - 180;
  }
  return lonLat;
}

/**
 * Checks if two projections are the same, that is every coordinate in one
 * projection does represent the same geographic point as the same coordinate in
 * the other projection.
 *
 * @param {Projection} projection1 Projection 1.
 * @param {Projection} projection2 Projection 2.
 * @return {boolean} Equivalent.
 * @api
 */
function equivalent(projection1, projection2) {
  if (projection1 === projection2) {
    return true;
  }
  const equalUnits = projection1.getUnits() === projection2.getUnits();
  if (projection1.getCode() === projection2.getCode()) {
    return equalUnits;
  }
  const transformFunc = getTransformFromProjections(projection1, projection2);
  return transformFunc === cloneTransform && equalUnits;
}

/**
 * Searches in the list of transform functions for the function for converting
 * coordinates from the source projection to the destination projection.
 *
 * @param {Projection} sourceProjection Source Projection object.
 * @param {Projection} destinationProjection Destination Projection
 *     object.
 * @return {TransformFunction} Transform function.
 */
function getTransformFromProjections(
  sourceProjection,
  destinationProjection
) {
  const sourceCode = sourceProjection.getCode();
  const destinationCode = destinationProjection.getCode();
  let transformFunc = (0,_proj_transforms_js__WEBPACK_IMPORTED_MODULE_3__.get)(sourceCode, destinationCode);
  if (!transformFunc) {
    transformFunc = identityTransform;
  }
  return transformFunc;
}

/**
 * Given the projection-like objects, searches for a transformation
 * function to convert a coordinates array from the source projection to the
 * destination projection.
 *
 * @param {ProjectionLike} source Source.
 * @param {ProjectionLike} destination Destination.
 * @return {TransformFunction} Transform function.
 * @api
 */
function getTransform(source, destination) {
  const sourceProjection = get(source);
  const destinationProjection = get(destination);
  return getTransformFromProjections(sourceProjection, destinationProjection);
}

/**
 * Transforms a coordinate from source projection to destination projection.
 * This returns a new coordinate (and does not modify the original).
 *
 * See {@link module:ol/proj.transformExtent} for extent transformation.
 * See the transform method of {@link module:ol/geom/Geometry~Geometry} and its
 * subclasses for geometry transforms.
 *
 * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
 * @param {ProjectionLike} source Source projection-like.
 * @param {ProjectionLike} destination Destination projection-like.
 * @return {import("./coordinate.js").Coordinate} Coordinate.
 * @api
 */
function transform(coordinate, source, destination) {
  const transformFunc = getTransform(source, destination);
  return transformFunc(coordinate, undefined, coordinate.length);
}

/**
 * Transforms an extent from source projection to destination projection.  This
 * returns a new extent (and does not modify the original).
 *
 * @param {import("./extent.js").Extent} extent The extent to transform.
 * @param {ProjectionLike} source Source projection-like.
 * @param {ProjectionLike} destination Destination projection-like.
 * @param {number} [stops] Number of stops per side used for the transform.
 * By default only the corners are used.
 * @return {import("./extent.js").Extent} The transformed extent.
 * @api
 */
function transformExtent(extent, source, destination, stops) {
  const transformFunc = getTransform(source, destination);
  return (0,_extent_js__WEBPACK_IMPORTED_MODULE_6__.applyTransform)(extent, transformFunc, undefined, stops);
}

/**
 * Transforms the given point to the destination projection.
 *
 * @param {import("./coordinate.js").Coordinate} point Point.
 * @param {Projection} sourceProjection Source projection.
 * @param {Projection} destinationProjection Destination projection.
 * @return {import("./coordinate.js").Coordinate} Point.
 */
function transformWithProjections(
  point,
  sourceProjection,
  destinationProjection
) {
  const transformFunc = getTransformFromProjections(
    sourceProjection,
    destinationProjection
  );
  return transformFunc(point);
}

/**
 * @type {Projection|null}
 */
let userProjection = null;

/**
 * Set the projection for coordinates supplied from and returned by API methods.
 * This includes all API methods except for those interacting with tile grids,
 * plus {@link import("./Map.js").FrameState} and {@link import("./View.js").State}.
 * @param {ProjectionLike} projection The user projection.
 * @api
 */
function setUserProjection(projection) {
  userProjection = get(projection);
}

/**
 * Clear the user projection if set.
 * @api
 */
function clearUserProjection() {
  userProjection = null;
}

/**
 * Get the projection for coordinates supplied from and returned by API methods.
 * @return {Projection|null} The user projection (or null if not set).
 * @api
 */
function getUserProjection() {
  return userProjection;
}

/**
 * Use geographic coordinates (WGS-84 datum) in API methods.
 * This includes all API methods except for those interacting with tile grids,
 * plus {@link import("./Map.js").FrameState} and {@link import("./View.js").State}.
 * @api
 */
function useGeographic() {
  setUserProjection('EPSG:4326');
}

/**
 * Return a coordinate transformed into the user projection.  If no user projection
 * is set, the original coordinate is returned.
 * @param {Array<number>} coordinate Input coordinate.
 * @param {ProjectionLike} sourceProjection The input coordinate projection.
 * @return {Array<number>} The input coordinate in the user projection.
 */
function toUserCoordinate(coordinate, sourceProjection) {
  if (!userProjection) {
    return coordinate;
  }
  return transform(coordinate, sourceProjection, userProjection);
}

/**
 * Return a coordinate transformed from the user projection.  If no user projection
 * is set, the original coordinate is returned.
 * @param {Array<number>} coordinate Input coordinate.
 * @param {ProjectionLike} destProjection The destination projection.
 * @return {Array<number>} The input coordinate transformed.
 */
function fromUserCoordinate(coordinate, destProjection) {
  if (!userProjection) {
    if (
      showCoordinateWarning &&
      !(0,_coordinate_js__WEBPACK_IMPORTED_MODULE_7__.equals)(coordinate, [0, 0]) &&
      coordinate[0] >= -180 &&
      coordinate[0] <= 180 &&
      coordinate[1] >= -90 &&
      coordinate[1] <= 90
    ) {
      showCoordinateWarning = false;
      (0,_console_js__WEBPACK_IMPORTED_MODULE_8__.warn)(
        'Call useGeographic() from ol/proj once to work with [longitude, latitude] coordinates.'
      );
    }
    return coordinate;
  }
  return transform(coordinate, userProjection, destProjection);
}

/**
 * Return an extent transformed into the user projection.  If no user projection
 * is set, the original extent is returned.
 * @param {import("./extent.js").Extent} extent Input extent.
 * @param {ProjectionLike} sourceProjection The input extent projection.
 * @return {import("./extent.js").Extent} The input extent in the user projection.
 */
function toUserExtent(extent, sourceProjection) {
  if (!userProjection) {
    return extent;
  }
  return transformExtent(extent, sourceProjection, userProjection);
}

/**
 * Return an extent transformed from the user projection.  If no user projection
 * is set, the original extent is returned.
 * @param {import("./extent.js").Extent} extent Input extent.
 * @param {ProjectionLike} destProjection The destination projection.
 * @return {import("./extent.js").Extent} The input extent transformed.
 */
function fromUserExtent(extent, destProjection) {
  if (!userProjection) {
    return extent;
  }
  return transformExtent(extent, userProjection, destProjection);
}

/**
 * Return the resolution in user projection units per pixel. If no user projection
 * is set, or source or user projection are missing units, the original resolution
 * is returned.
 * @param {number} resolution Resolution in input projection units per pixel.
 * @param {ProjectionLike} sourceProjection The input projection.
 * @return {number} Resolution in user projection units per pixel.
 */
function toUserResolution(resolution, sourceProjection) {
  if (!userProjection) {
    return resolution;
  }
  const sourceUnits = get(sourceProjection).getUnits();
  const userUnits = userProjection.getUnits();
  return sourceUnits && userUnits
    ? (resolution * _proj_Units_js__WEBPACK_IMPORTED_MODULE_0__.METERS_PER_UNIT[sourceUnits]) / _proj_Units_js__WEBPACK_IMPORTED_MODULE_0__.METERS_PER_UNIT[userUnits]
    : resolution;
}

/**
 * Return the resolution in user projection units per pixel. If no user projection
 * is set, or source or user projection are missing units, the original resolution
 * is returned.
 * @param {number} resolution Resolution in user projection units per pixel.
 * @param {ProjectionLike} destProjection The destination projection.
 * @return {number} Resolution in destination projection units per pixel.
 */
function fromUserResolution(resolution, destProjection) {
  if (!userProjection) {
    return resolution;
  }
  const sourceUnits = get(destProjection).getUnits();
  const userUnits = userProjection.getUnits();
  return sourceUnits && userUnits
    ? (resolution * _proj_Units_js__WEBPACK_IMPORTED_MODULE_0__.METERS_PER_UNIT[userUnits]) / _proj_Units_js__WEBPACK_IMPORTED_MODULE_0__.METERS_PER_UNIT[sourceUnits]
    : resolution;
}

/**
 * Creates a safe coordinate transform function from a coordinate transform function.
 * "Safe" means that it can handle wrapping of x-coordinates for global projections,
 * and that coordinates exceeding the source projection validity extent's range will be
 * clamped to the validity range.
 * @param {Projection} sourceProj Source projection.
 * @param {Projection} destProj Destination projection.
 * @param {function(import("./coordinate.js").Coordinate): import("./coordinate.js").Coordinate} transform Transform function (source to destination).
 * @return {function(import("./coordinate.js").Coordinate): import("./coordinate.js").Coordinate} Safe transform function (source to destination).
 */
function createSafeCoordinateTransform(sourceProj, destProj, transform) {
  return function (coord) {
    let transformed, worldsAway;
    if (sourceProj.canWrapX()) {
      const sourceExtent = sourceProj.getExtent();
      const sourceExtentWidth = (0,_extent_js__WEBPACK_IMPORTED_MODULE_6__.getWidth)(sourceExtent);
      coord = coord.slice(0);
      worldsAway = (0,_coordinate_js__WEBPACK_IMPORTED_MODULE_7__.getWorldsAway)(coord, sourceProj, sourceExtentWidth);
      if (worldsAway) {
        // Move x to the real world
        coord[0] = coord[0] - worldsAway * sourceExtentWidth;
      }
      coord[0] = (0,_math_js__WEBPACK_IMPORTED_MODULE_5__.clamp)(coord[0], sourceExtent[0], sourceExtent[2]);
      coord[1] = (0,_math_js__WEBPACK_IMPORTED_MODULE_5__.clamp)(coord[1], sourceExtent[1], sourceExtent[3]);
      transformed = transform(coord);
    } else {
      transformed = transform(coord);
    }
    if (worldsAway && destProj.canWrapX()) {
      // Move transformed coordinate back to the offset world
      transformed[0] += worldsAway * (0,_extent_js__WEBPACK_IMPORTED_MODULE_6__.getWidth)(destProj.getExtent());
    }
    return transformed;
  };
}

/**
 * Add transforms to and from EPSG:4326 and EPSG:3857.  This function is called
 * by when this module is executed and should only need to be called again after
 * `clearAllProjections()` is called (e.g. in tests).
 */
function addCommon() {
  // Add transformations that don't alter coordinates to convert within set of
  // projections with equal meaning.
  addEquivalentProjections(_proj_epsg3857_js__WEBPACK_IMPORTED_MODULE_9__.PROJECTIONS);
  addEquivalentProjections(_proj_epsg4326_js__WEBPACK_IMPORTED_MODULE_10__.PROJECTIONS);
  // Add transformations to convert EPSG:4326 like coordinates to EPSG:3857 like
  // coordinates and back.
  addEquivalentTransforms(
    _proj_epsg4326_js__WEBPACK_IMPORTED_MODULE_10__.PROJECTIONS,
    _proj_epsg3857_js__WEBPACK_IMPORTED_MODULE_9__.PROJECTIONS,
    _proj_epsg3857_js__WEBPACK_IMPORTED_MODULE_9__.fromEPSG4326,
    _proj_epsg3857_js__WEBPACK_IMPORTED_MODULE_9__.toEPSG4326
  );
}

addCommon();


/***/ }),

/***/ "./node_modules/ol/proj/Projection.js":
/*!********************************************!*\
  !*** ./node_modules/ol/proj/Projection.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Units_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Units.js */ "./node_modules/ol/proj/Units.js");
/**
 * @module ol/proj/Projection
 */


/**
 * @typedef {Object} Options
 * @property {string} code The SRS identifier code, e.g. `EPSG:4326`.
 * @property {import("./Units.js").Units} [units] Units. Required unless a
 * proj4 projection is defined for `code`.
 * @property {import("../extent.js").Extent} [extent] The validity extent for the SRS.
 * @property {string} [axisOrientation='enu'] The axis orientation as specified in Proj4.
 * @property {boolean} [global=false] Whether the projection is valid for the whole globe.
 * @property {number} [metersPerUnit] The meters per unit for the SRS.
 * If not provided, the `units` are used to get the meters per unit from the {@link METERS_PER_UNIT}
 * lookup table.
 * @property {import("../extent.js").Extent} [worldExtent] The world extent for the SRS.
 * @property {function(number, import("../coordinate.js").Coordinate):number} [getPointResolution]
 * Function to determine resolution at a point. The function is called with a
 * `number` view resolution and a {@link module:ol/coordinate~Coordinate} as arguments, and returns
 * the `number` resolution in projection units at the passed coordinate. If this is `undefined`,
 * the default {@link module:ol/proj.getPointResolution} function will be used.
 */

/**
 * @classdesc
 * Projection definition class. One of these is created for each projection
 * supported in the application and stored in the {@link module:ol/proj} namespace.
 * You can use these in applications, but this is not required, as API params
 * and options use {@link module:ol/proj~ProjectionLike} which means the simple string
 * code will suffice.
 *
 * You can use {@link module:ol/proj.get} to retrieve the object for a particular
 * projection.
 *
 * The library includes definitions for `EPSG:4326` and `EPSG:3857`, together
 * with the following aliases:
 * * `EPSG:4326`: CRS:84, urn:ogc:def:crs:EPSG:6.6:4326,
 *     urn:ogc:def:crs:OGC:1.3:CRS84, urn:ogc:def:crs:OGC:2:84,
 *     http://www.opengis.net/gml/srs/epsg.xml#4326,
 *     urn:x-ogc:def:crs:EPSG:4326
 * * `EPSG:3857`: EPSG:102100, EPSG:102113, EPSG:900913,
 *     urn:ogc:def:crs:EPSG:6.18:3:3857,
 *     http://www.opengis.net/gml/srs/epsg.xml#3857
 *
 * If you use [proj4js](https://github.com/proj4js/proj4js), aliases can
 * be added using `proj4.defs()`. After all required projection definitions are
 * added, call the {@link module:ol/proj/proj4.register} function.
 *
 * @api
 */
class Projection {
  /**
   * @param {Options} options Projection options.
   */
  constructor(options) {
    /**
     * @private
     * @type {string}
     */
    this.code_ = options.code;

    /**
     * Units of projected coordinates. When set to `TILE_PIXELS`, a
     * `this.extent_` and `this.worldExtent_` must be configured properly for each
     * tile.
     * @private
     * @type {import("./Units.js").Units}
     */
    this.units_ = /** @type {import("./Units.js").Units} */ (options.units);

    /**
     * Validity extent of the projection in projected coordinates. For projections
     * with `TILE_PIXELS` units, this is the extent of the tile in
     * tile pixel space.
     * @private
     * @type {import("../extent.js").Extent}
     */
    this.extent_ = options.extent !== undefined ? options.extent : null;

    /**
     * Extent of the world in EPSG:4326. For projections with
     * `TILE_PIXELS` units, this is the extent of the tile in
     * projected coordinate space.
     * @private
     * @type {import("../extent.js").Extent}
     */
    this.worldExtent_ =
      options.worldExtent !== undefined ? options.worldExtent : null;

    /**
     * @private
     * @type {string}
     */
    this.axisOrientation_ =
      options.axisOrientation !== undefined ? options.axisOrientation : 'enu';

    /**
     * @private
     * @type {boolean}
     */
    this.global_ = options.global !== undefined ? options.global : false;

    /**
     * @private
     * @type {boolean}
     */
    this.canWrapX_ = !!(this.global_ && this.extent_);

    /**
     * @private
     * @type {function(number, import("../coordinate.js").Coordinate):number|undefined}
     */
    this.getPointResolutionFunc_ = options.getPointResolution;

    /**
     * @private
     * @type {import("../tilegrid/TileGrid.js").default}
     */
    this.defaultTileGrid_ = null;

    /**
     * @private
     * @type {number|undefined}
     */
    this.metersPerUnit_ = options.metersPerUnit;
  }

  /**
   * @return {boolean} The projection is suitable for wrapping the x-axis
   */
  canWrapX() {
    return this.canWrapX_;
  }

  /**
   * Get the code for this projection, e.g. 'EPSG:4326'.
   * @return {string} Code.
   * @api
   */
  getCode() {
    return this.code_;
  }

  /**
   * Get the validity extent for this projection.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */
  getExtent() {
    return this.extent_;
  }

  /**
   * Get the units of this projection.
   * @return {import("./Units.js").Units} Units.
   * @api
   */
  getUnits() {
    return this.units_;
  }

  /**
   * Get the amount of meters per unit of this projection.  If the projection is
   * not configured with `metersPerUnit` or a units identifier, the return is
   * `undefined`.
   * @return {number|undefined} Meters.
   * @api
   */
  getMetersPerUnit() {
    return this.metersPerUnit_ || _Units_js__WEBPACK_IMPORTED_MODULE_0__.METERS_PER_UNIT[this.units_];
  }

  /**
   * Get the world extent for this projection.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */
  getWorldExtent() {
    return this.worldExtent_;
  }

  /**
   * Get the axis orientation of this projection.
   * Example values are:
   * enu - the default easting, northing, elevation.
   * neu - northing, easting, up - useful for "lat/long" geographic coordinates,
   *     or south orientated transverse mercator.
   * wnu - westing, northing, up - some planetary coordinate systems have
   *     "west positive" coordinate systems
   * @return {string} Axis orientation.
   * @api
   */
  getAxisOrientation() {
    return this.axisOrientation_;
  }

  /**
   * Is this projection a global projection which spans the whole world?
   * @return {boolean} Whether the projection is global.
   * @api
   */
  isGlobal() {
    return this.global_;
  }

  /**
   * Set if the projection is a global projection which spans the whole world
   * @param {boolean} global Whether the projection is global.
   * @api
   */
  setGlobal(global) {
    this.global_ = global;
    this.canWrapX_ = !!(global && this.extent_);
  }

  /**
   * @return {import("../tilegrid/TileGrid.js").default} The default tile grid.
   */
  getDefaultTileGrid() {
    return this.defaultTileGrid_;
  }

  /**
   * @param {import("../tilegrid/TileGrid.js").default} tileGrid The default tile grid.
   */
  setDefaultTileGrid(tileGrid) {
    this.defaultTileGrid_ = tileGrid;
  }

  /**
   * Set the validity extent for this projection.
   * @param {import("../extent.js").Extent} extent Extent.
   * @api
   */
  setExtent(extent) {
    this.extent_ = extent;
    this.canWrapX_ = !!(this.global_ && extent);
  }

  /**
   * Set the world extent for this projection.
   * @param {import("../extent.js").Extent} worldExtent World extent
   *     [minlon, minlat, maxlon, maxlat].
   * @api
   */
  setWorldExtent(worldExtent) {
    this.worldExtent_ = worldExtent;
  }

  /**
   * Set the getPointResolution function (see {@link module:ol/proj.getPointResolution}
   * for this projection.
   * @param {function(number, import("../coordinate.js").Coordinate):number} func Function
   * @api
   */
  setGetPointResolution(func) {
    this.getPointResolutionFunc_ = func;
  }

  /**
   * Get the custom point resolution function for this projection (if set).
   * @return {function(number, import("../coordinate.js").Coordinate):number|undefined} The custom point
   * resolution function (if set).
   */
  getPointResolutionFunc() {
    return this.getPointResolutionFunc_;
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Projection);


/***/ }),

/***/ "./node_modules/ol/proj/Units.js":
/*!***************************************!*\
  !*** ./node_modules/ol/proj/Units.js ***!
  \***************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   METERS_PER_UNIT: () => (/* binding */ METERS_PER_UNIT),
/* harmony export */   fromCode: () => (/* binding */ fromCode)
/* harmony export */ });
/**
 * @module ol/proj/Units
 */

/**
 * @typedef {'radians' | 'degrees' | 'ft' | 'm' | 'pixels' | 'tile-pixels' | 'us-ft'} Units
 * Projection units.
 */

/**
 * See http://duff.ess.washington.edu/data/raster/drg/docs/geotiff.txt
 * @type {Object<number, Units>}
 */
const unitByCode = {
  '9001': 'm',
  '9002': 'ft',
  '9003': 'us-ft',
  '9101': 'radians',
  '9102': 'degrees',
};

/**
 * @param {number} code Unit code.
 * @return {Units} Units.
 */
function fromCode(code) {
  return unitByCode[code];
}

/**
 * @typedef {Object} MetersPerUnitLookup
 * @property {number} radians Radians
 * @property {number} degrees Degrees
 * @property {number} ft  Feet
 * @property {number} m Meters
 * @property {number} us-ft US feet
 */

/**
 * Meters per unit lookup table.
 * @const
 * @type {MetersPerUnitLookup}
 * @api
 */
const METERS_PER_UNIT = {
  // use the radius of the Normal sphere
  'radians': 6370997 / (2 * Math.PI),
  'degrees': (2 * Math.PI * 6370997) / 360,
  'ft': 0.3048,
  'm': 1,
  'us-ft': 1200 / 3937,
};


/***/ }),

/***/ "./node_modules/ol/proj/epsg3857.js":
/*!******************************************!*\
  !*** ./node_modules/ol/proj/epsg3857.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EXTENT: () => (/* binding */ EXTENT),
/* harmony export */   HALF_SIZE: () => (/* binding */ HALF_SIZE),
/* harmony export */   MAX_SAFE_Y: () => (/* binding */ MAX_SAFE_Y),
/* harmony export */   PROJECTIONS: () => (/* binding */ PROJECTIONS),
/* harmony export */   RADIUS: () => (/* binding */ RADIUS),
/* harmony export */   WORLD_EXTENT: () => (/* binding */ WORLD_EXTENT),
/* harmony export */   fromEPSG4326: () => (/* binding */ fromEPSG4326),
/* harmony export */   toEPSG4326: () => (/* binding */ toEPSG4326)
/* harmony export */ });
/* harmony import */ var _Projection_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Projection.js */ "./node_modules/ol/proj/Projection.js");
/**
 * @module ol/proj/epsg3857
 */


/**
 * Radius of WGS84 sphere
 *
 * @const
 * @type {number}
 */
const RADIUS = 6378137;

/**
 * @const
 * @type {number}
 */
const HALF_SIZE = Math.PI * RADIUS;

/**
 * @const
 * @type {import("../extent.js").Extent}
 */
const EXTENT = [-HALF_SIZE, -HALF_SIZE, HALF_SIZE, HALF_SIZE];

/**
 * @const
 * @type {import("../extent.js").Extent}
 */
const WORLD_EXTENT = [-180, -85, 180, 85];

/**
 * Maximum safe value in y direction
 * @const
 * @type {number}
 */
const MAX_SAFE_Y = RADIUS * Math.log(Math.tan(Math.PI / 2));

/**
 * @classdesc
 * Projection object for web/spherical Mercator (EPSG:3857).
 */
class EPSG3857Projection extends _Projection_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {string} code Code.
   */
  constructor(code) {
    super({
      code: code,
      units: 'm',
      extent: EXTENT,
      global: true,
      worldExtent: WORLD_EXTENT,
      getPointResolution: function (resolution, point) {
        return resolution / Math.cosh(point[1] / RADIUS);
      },
    });
  }
}

/**
 * Projections equal to EPSG:3857.
 *
 * @const
 * @type {Array<import("./Projection.js").default>}
 */
const PROJECTIONS = [
  new EPSG3857Projection('EPSG:3857'),
  new EPSG3857Projection('EPSG:102100'),
  new EPSG3857Projection('EPSG:102113'),
  new EPSG3857Projection('EPSG:900913'),
  new EPSG3857Projection('http://www.opengis.net/def/crs/EPSG/0/3857'),
  new EPSG3857Projection('http://www.opengis.net/gml/srs/epsg.xml#3857'),
];

/**
 * Transformation from EPSG:4326 to EPSG:3857.
 *
 * @param {Array<number>} input Input array of coordinate values.
 * @param {Array<number>} [output] Output array of coordinate values.
 * @param {number} [dimension] Dimension (default is `2`).
 * @return {Array<number>} Output array of coordinate values.
 */
function fromEPSG4326(input, output, dimension) {
  const length = input.length;
  dimension = dimension > 1 ? dimension : 2;
  if (output === undefined) {
    if (dimension > 2) {
      // preserve values beyond second dimension
      output = input.slice();
    } else {
      output = new Array(length);
    }
  }
  for (let i = 0; i < length; i += dimension) {
    output[i] = (HALF_SIZE * input[i]) / 180;
    let y = RADIUS * Math.log(Math.tan((Math.PI * (+input[i + 1] + 90)) / 360));
    if (y > MAX_SAFE_Y) {
      y = MAX_SAFE_Y;
    } else if (y < -MAX_SAFE_Y) {
      y = -MAX_SAFE_Y;
    }
    output[i + 1] = y;
  }
  return output;
}

/**
 * Transformation from EPSG:3857 to EPSG:4326.
 *
 * @param {Array<number>} input Input array of coordinate values.
 * @param {Array<number>} [output] Output array of coordinate values.
 * @param {number} [dimension] Dimension (default is `2`).
 * @return {Array<number>} Output array of coordinate values.
 */
function toEPSG4326(input, output, dimension) {
  const length = input.length;
  dimension = dimension > 1 ? dimension : 2;
  if (output === undefined) {
    if (dimension > 2) {
      // preserve values beyond second dimension
      output = input.slice();
    } else {
      output = new Array(length);
    }
  }
  for (let i = 0; i < length; i += dimension) {
    output[i] = (180 * input[i]) / HALF_SIZE;
    output[i + 1] =
      (360 * Math.atan(Math.exp(input[i + 1] / RADIUS))) / Math.PI - 90;
  }
  return output;
}


/***/ }),

/***/ "./node_modules/ol/proj/epsg4326.js":
/*!******************************************!*\
  !*** ./node_modules/ol/proj/epsg4326.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EXTENT: () => (/* binding */ EXTENT),
/* harmony export */   METERS_PER_UNIT: () => (/* binding */ METERS_PER_UNIT),
/* harmony export */   PROJECTIONS: () => (/* binding */ PROJECTIONS),
/* harmony export */   RADIUS: () => (/* binding */ RADIUS)
/* harmony export */ });
/* harmony import */ var _Projection_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Projection.js */ "./node_modules/ol/proj/Projection.js");
/**
 * @module ol/proj/epsg4326
 */


/**
 * Semi-major radius of the WGS84 ellipsoid.
 *
 * @const
 * @type {number}
 */
const RADIUS = 6378137;

/**
 * Extent of the EPSG:4326 projection which is the whole world.
 *
 * @const
 * @type {import("../extent.js").Extent}
 */
const EXTENT = [-180, -90, 180, 90];

/**
 * @const
 * @type {number}
 */
const METERS_PER_UNIT = (Math.PI * RADIUS) / 180;

/**
 * @classdesc
 * Projection object for WGS84 geographic coordinates (EPSG:4326).
 *
 * Note that OpenLayers does not strictly comply with the EPSG definition.
 * The EPSG registry defines 4326 as a CRS for Latitude,Longitude (y,x).
 * OpenLayers treats EPSG:4326 as a pseudo-projection, with x,y coordinates.
 */
class EPSG4326Projection extends _Projection_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {string} code Code.
   * @param {string} [axisOrientation] Axis orientation.
   */
  constructor(code, axisOrientation) {
    super({
      code: code,
      units: 'degrees',
      extent: EXTENT,
      axisOrientation: axisOrientation,
      global: true,
      metersPerUnit: METERS_PER_UNIT,
      worldExtent: EXTENT,
    });
  }
}

/**
 * Projections equal to EPSG:4326.
 *
 * @const
 * @type {Array<import("./Projection.js").default>}
 */
const PROJECTIONS = [
  new EPSG4326Projection('CRS:84'),
  new EPSG4326Projection('EPSG:4326', 'neu'),
  new EPSG4326Projection('urn:ogc:def:crs:OGC:1.3:CRS84'),
  new EPSG4326Projection('urn:ogc:def:crs:OGC:2:84'),
  new EPSG4326Projection('http://www.opengis.net/def/crs/OGC/1.3/CRS84'),
  new EPSG4326Projection('http://www.opengis.net/gml/srs/epsg.xml#4326', 'neu'),
  new EPSG4326Projection('http://www.opengis.net/def/crs/EPSG/0/4326', 'neu'),
];


/***/ }),

/***/ "./node_modules/ol/proj/projections.js":
/*!*********************************************!*\
  !*** ./node_modules/ol/proj/projections.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   add: () => (/* binding */ add),
/* harmony export */   clear: () => (/* binding */ clear),
/* harmony export */   get: () => (/* binding */ get)
/* harmony export */ });
/**
 * @module ol/proj/projections
 */

/**
 * @type {Object<string, import("./Projection.js").default>}
 */
let cache = {};

/**
 * Clear the projections cache.
 */
function clear() {
  cache = {};
}

/**
 * Get a cached projection by code.
 * @param {string} code The code for the projection.
 * @return {import("./Projection.js").default} The projection (if cached).
 */
function get(code) {
  return (
    cache[code] ||
    cache[code.replace(/urn:(x-)?ogc:def:crs:EPSG:(.*:)?(\w+)$/, 'EPSG:$3')] ||
    null
  );
}

/**
 * Add a projection to the cache.
 * @param {string} code The projection code.
 * @param {import("./Projection.js").default} projection The projection to cache.
 */
function add(code, projection) {
  cache[code] = projection;
}


/***/ }),

/***/ "./node_modules/ol/proj/transforms.js":
/*!********************************************!*\
  !*** ./node_modules/ol/proj/transforms.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   add: () => (/* binding */ add),
/* harmony export */   clear: () => (/* binding */ clear),
/* harmony export */   get: () => (/* binding */ get),
/* harmony export */   remove: () => (/* binding */ remove)
/* harmony export */ });
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../obj.js */ "./node_modules/ol/obj.js");
/**
 * @module ol/proj/transforms
 */


/**
 * @private
 * @type {!Object<string, Object<string, import("../proj.js").TransformFunction>>}
 */
let transforms = {};

/**
 * Clear the transform cache.
 */
function clear() {
  transforms = {};
}

/**
 * Registers a conversion function to convert coordinates from the source
 * projection to the destination projection.
 *
 * @param {import("./Projection.js").default} source Source.
 * @param {import("./Projection.js").default} destination Destination.
 * @param {import("../proj.js").TransformFunction} transformFn Transform.
 */
function add(source, destination, transformFn) {
  const sourceCode = source.getCode();
  const destinationCode = destination.getCode();
  if (!(sourceCode in transforms)) {
    transforms[sourceCode] = {};
  }
  transforms[sourceCode][destinationCode] = transformFn;
}

/**
 * Unregisters the conversion function to convert coordinates from the source
 * projection to the destination projection.  This method is used to clean up
 * cached transforms during testing.
 *
 * @param {import("./Projection.js").default} source Source projection.
 * @param {import("./Projection.js").default} destination Destination projection.
 * @return {import("../proj.js").TransformFunction} transformFn The unregistered transform.
 */
function remove(source, destination) {
  const sourceCode = source.getCode();
  const destinationCode = destination.getCode();
  const transform = transforms[sourceCode][destinationCode];
  delete transforms[sourceCode][destinationCode];
  if ((0,_obj_js__WEBPACK_IMPORTED_MODULE_0__.isEmpty)(transforms[sourceCode])) {
    delete transforms[sourceCode];
  }
  return transform;
}

/**
 * Get a transform given a source code and a destination code.
 * @param {string} sourceCode The code for the source projection.
 * @param {string} destinationCode The code for the destination projection.
 * @return {import("../proj.js").TransformFunction|undefined} The transform function (if found).
 */
function get(sourceCode, destinationCode) {
  let transform;
  if (sourceCode in transforms && destinationCode in transforms[sourceCode]) {
    transform = transforms[sourceCode][destinationCode];
  }
  return transform;
}


/***/ }),

/***/ "./node_modules/ol/render/Box.js":
/*!***************************************!*\
  !*** ./node_modules/ol/render/Box.js ***!
  \***************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Disposable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Disposable.js */ "./node_modules/ol/Disposable.js");
/* harmony import */ var _geom_Polygon_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../geom/Polygon.js */ "./node_modules/ol/geom/Polygon.js");
/**
 * @module ol/render/Box
 */




class RenderBox extends _Disposable_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {string} className CSS class name.
   */
  constructor(className) {
    super();

    /**
     * @type {import("../geom/Polygon.js").default}
     * @private
     */
    this.geometry_ = null;

    /**
     * @type {HTMLDivElement}
     * @private
     */
    this.element_ = document.createElement('div');
    this.element_.style.position = 'absolute';
    this.element_.style.pointerEvents = 'auto';
    this.element_.className = 'ol-box ' + className;

    /**
     * @private
     * @type {import("../Map.js").default|null}
     */
    this.map_ = null;

    /**
     * @private
     * @type {import("../pixel.js").Pixel}
     */
    this.startPixel_ = null;

    /**
     * @private
     * @type {import("../pixel.js").Pixel}
     */
    this.endPixel_ = null;
  }

  /**
   * Clean up.
   */
  disposeInternal() {
    this.setMap(null);
  }

  /**
   * @private
   */
  render_() {
    const startPixel = this.startPixel_;
    const endPixel = this.endPixel_;
    const px = 'px';
    const style = this.element_.style;
    style.left = Math.min(startPixel[0], endPixel[0]) + px;
    style.top = Math.min(startPixel[1], endPixel[1]) + px;
    style.width = Math.abs(endPixel[0] - startPixel[0]) + px;
    style.height = Math.abs(endPixel[1] - startPixel[1]) + px;
  }

  /**
   * @param {import("../Map.js").default|null} map Map.
   */
  setMap(map) {
    if (this.map_) {
      this.map_.getOverlayContainer().removeChild(this.element_);
      const style = this.element_.style;
      style.left = 'inherit';
      style.top = 'inherit';
      style.width = 'inherit';
      style.height = 'inherit';
    }
    this.map_ = map;
    if (this.map_) {
      this.map_.getOverlayContainer().appendChild(this.element_);
    }
  }

  /**
   * @param {import("../pixel.js").Pixel} startPixel Start pixel.
   * @param {import("../pixel.js").Pixel} endPixel End pixel.
   */
  setPixels(startPixel, endPixel) {
    this.startPixel_ = startPixel;
    this.endPixel_ = endPixel;
    this.createOrUpdateGeometry();
    this.render_();
  }

  /**
   * Creates or updates the cached geometry.
   */
  createOrUpdateGeometry() {
    const startPixel = this.startPixel_;
    const endPixel = this.endPixel_;
    const pixels = [
      startPixel,
      [startPixel[0], endPixel[1]],
      endPixel,
      [endPixel[0], startPixel[1]],
    ];
    const coordinates = pixels.map(
      this.map_.getCoordinateFromPixelInternal,
      this.map_
    );
    // close the polygon
    coordinates[4] = coordinates[0].slice();
    if (!this.geometry_) {
      this.geometry_ = new _geom_Polygon_js__WEBPACK_IMPORTED_MODULE_1__["default"]([coordinates]);
    } else {
      this.geometry_.setCoordinates([coordinates]);
    }
  }

  /**
   * @return {import("../geom/Polygon.js").default} Geometry.
   */
  getGeometry() {
    return this.geometry_;
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (RenderBox);


/***/ }),

/***/ "./node_modules/ol/render/Event.js":
/*!*****************************************!*\
  !*** ./node_modules/ol/render/Event.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _events_Event_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../events/Event.js */ "./node_modules/ol/events/Event.js");
/**
 * @module ol/render/Event
 */



class RenderEvent extends _events_Event_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {import("./EventType.js").default} type Type.
   * @param {import("../transform.js").Transform} [inversePixelTransform] Transform for
   *     CSS pixels to rendered pixels.
   * @param {import("../Map.js").FrameState} [frameState] Frame state.
   * @param {?(CanvasRenderingContext2D|WebGLRenderingContext)} [context] Context.
   */
  constructor(type, inversePixelTransform, frameState, context) {
    super(type);

    /**
     * Transform from CSS pixels (relative to the top-left corner of the map viewport)
     * to rendered pixels on this event's `context`. Only available when a Canvas renderer is used, null otherwise.
     * @type {import("../transform.js").Transform|undefined}
     * @api
     */
    this.inversePixelTransform = inversePixelTransform;

    /**
     * An object representing the current render frame state.
     * @type {import("../Map.js").FrameState|undefined}
     * @api
     */
    this.frameState = frameState;

    /**
     * Canvas context. Not available when the event is dispatched by the map. For Canvas 2D layers,
     * the context will be the 2D rendering context.  For WebGL layers, the context will be the WebGL
     * context.
     * @type {CanvasRenderingContext2D|WebGLRenderingContext|undefined}
     * @api
     */
    this.context = context;
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (RenderEvent);


/***/ }),

/***/ "./node_modules/ol/render/EventType.js":
/*!*********************************************!*\
  !*** ./node_modules/ol/render/EventType.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * @module ol/render/EventType
 */

/**
 * @enum {string}
 */
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  /**
   * Triggered before a layer is rendered.
   * @event module:ol/render/Event~RenderEvent#prerender
   * @api
   */
  PRERENDER: 'prerender',

  /**
   * Triggered after a layer is rendered.
   * @event module:ol/render/Event~RenderEvent#postrender
   * @api
   */
  POSTRENDER: 'postrender',

  /**
   * Triggered before layers are composed.  When dispatched by the map, the event object will not have
   * a `context` set.  When dispatched by a layer, the event object will have a `context` set.  Only
   * WebGL layers currently dispatch this event.
   * @event module:ol/render/Event~RenderEvent#precompose
   * @api
   */
  PRECOMPOSE: 'precompose',

  /**
   * Triggered after layers are composed.  When dispatched by the map, the event object will not have
   * a `context` set.  When dispatched by a layer, the event object will have a `context` set.  Only
   * WebGL layers currently dispatch this event.
   * @event module:ol/render/Event~RenderEvent#postcompose
   * @api
   */
  POSTCOMPOSE: 'postcompose',

  /**
   * Triggered when rendering is complete, i.e. all sources and tiles have
   * finished loading for the current viewport, and all tiles are faded in.
   * The event object will not have a `context` set.
   * @event module:ol/render/Event~RenderEvent#rendercomplete
   * @api
   */
  RENDERCOMPLETE: 'rendercomplete',
});

/**
 * @typedef {'postrender'|'precompose'|'postcompose'|'rendercomplete'} MapRenderEventTypes
 */

/**
 * @typedef {'postrender'|'prerender'} LayerRenderEventTypes
 */


/***/ }),

/***/ "./node_modules/ol/render/VectorContext.js":
/*!*************************************************!*\
  !*** ./node_modules/ol/render/VectorContext.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * @module ol/render/VectorContext
 */

/**
 * @classdesc
 * Context for drawing geometries.  A vector context is available on render
 * events and does not need to be constructed directly.
 * @api
 */
class VectorContext {
  /**
   * Render a geometry with a custom renderer.
   *
   * @param {import("../geom/SimpleGeometry.js").default} geometry Geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   * @param {Function} renderer Renderer.
   * @param {Function} hitDetectionRenderer Renderer.
   */
  drawCustom(geometry, feature, renderer, hitDetectionRenderer) {}

  /**
   * Render a geometry.
   *
   * @param {import("../geom/Geometry.js").default} geometry The geometry to render.
   */
  drawGeometry(geometry) {}

  /**
   * Set the rendering style.
   *
   * @param {import("../style/Style.js").default} style The rendering style.
   */
  setStyle(style) {}

  /**
   * @param {import("../geom/Circle.js").default} circleGeometry Circle geometry.
   * @param {import("../Feature.js").default} feature Feature.
   */
  drawCircle(circleGeometry, feature) {}

  /**
   * @param {import("../Feature.js").default} feature Feature.
   * @param {import("../style/Style.js").default} style Style.
   */
  drawFeature(feature, style) {}

  /**
   * @param {import("../geom/GeometryCollection.js").default} geometryCollectionGeometry Geometry collection.
   * @param {import("../Feature.js").default} feature Feature.
   */
  drawGeometryCollection(geometryCollectionGeometry, feature) {}

  /**
   * @param {import("../geom/LineString.js").default|import("./Feature.js").default} lineStringGeometry Line string geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   */
  drawLineString(lineStringGeometry, feature) {}

  /**
   * @param {import("../geom/MultiLineString.js").default|import("./Feature.js").default} multiLineStringGeometry MultiLineString geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   */
  drawMultiLineString(multiLineStringGeometry, feature) {}

  /**
   * @param {import("../geom/MultiPoint.js").default|import("./Feature.js").default} multiPointGeometry MultiPoint geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   */
  drawMultiPoint(multiPointGeometry, feature) {}

  /**
   * @param {import("../geom/MultiPolygon.js").default} multiPolygonGeometry MultiPolygon geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   */
  drawMultiPolygon(multiPolygonGeometry, feature) {}

  /**
   * @param {import("../geom/Point.js").default|import("./Feature.js").default} pointGeometry Point geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   */
  drawPoint(pointGeometry, feature) {}

  /**
   * @param {import("../geom/Polygon.js").default|import("./Feature.js").default} polygonGeometry Polygon geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   */
  drawPolygon(polygonGeometry, feature) {}

  /**
   * @param {import("../geom/SimpleGeometry.js").default|import("./Feature.js").default} geometry Geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   */
  drawText(geometry, feature) {}

  /**
   * @param {import("../style/Fill.js").default} fillStyle Fill style.
   * @param {import("../style/Stroke.js").default} strokeStyle Stroke style.
   */
  setFillStrokeStyle(fillStyle, strokeStyle) {}

  /**
   * @param {import("../style/Image.js").default} imageStyle Image style.
   * @param {import("../render/canvas.js").DeclutterImageWithText} [declutterImageWithText] Shared data for combined decluttering with a text style.
   */
  setImageStyle(imageStyle, declutterImageWithText) {}

  /**
   * @param {import("../style/Text.js").default} textStyle Text style.
   * @param {import("../render/canvas.js").DeclutterImageWithText} [declutterImageWithText] Shared data for combined decluttering with an image style.
   */
  setTextStyle(textStyle, declutterImageWithText) {}
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (VectorContext);


/***/ }),

/***/ "./node_modules/ol/render/canvas.js":
/*!******************************************!*\
  !*** ./node_modules/ol/render/canvas.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   checkedFonts: () => (/* binding */ checkedFonts),
/* harmony export */   defaultFillStyle: () => (/* binding */ defaultFillStyle),
/* harmony export */   defaultFont: () => (/* binding */ defaultFont),
/* harmony export */   defaultLineCap: () => (/* binding */ defaultLineCap),
/* harmony export */   defaultLineDash: () => (/* binding */ defaultLineDash),
/* harmony export */   defaultLineDashOffset: () => (/* binding */ defaultLineDashOffset),
/* harmony export */   defaultLineJoin: () => (/* binding */ defaultLineJoin),
/* harmony export */   defaultLineWidth: () => (/* binding */ defaultLineWidth),
/* harmony export */   defaultMiterLimit: () => (/* binding */ defaultMiterLimit),
/* harmony export */   defaultPadding: () => (/* binding */ defaultPadding),
/* harmony export */   defaultStrokeStyle: () => (/* binding */ defaultStrokeStyle),
/* harmony export */   defaultTextAlign: () => (/* binding */ defaultTextAlign),
/* harmony export */   defaultTextBaseline: () => (/* binding */ defaultTextBaseline),
/* harmony export */   drawImageOrLabel: () => (/* binding */ drawImageOrLabel),
/* harmony export */   getTextDimensions: () => (/* binding */ getTextDimensions),
/* harmony export */   measureAndCacheTextWidth: () => (/* binding */ measureAndCacheTextWidth),
/* harmony export */   measureTextHeight: () => (/* binding */ measureTextHeight),
/* harmony export */   measureTextWidth: () => (/* binding */ measureTextWidth),
/* harmony export */   registerFont: () => (/* binding */ registerFont),
/* harmony export */   rotateAtOffset: () => (/* binding */ rotateAtOffset),
/* harmony export */   textHeights: () => (/* binding */ textHeights)
/* harmony export */ });
/* harmony import */ var _Object_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Object.js */ "./node_modules/ol/Object.js");
/* harmony import */ var _has_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../has.js */ "./node_modules/ol/has.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../obj.js */ "./node_modules/ol/obj.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../dom.js */ "./node_modules/ol/dom.js");
/* harmony import */ var _css_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../css.js */ "./node_modules/ol/css.js");
/**
 * @module ol/render/canvas
 */






/**
 * @typedef {'Circle' | 'Image' | 'LineString' | 'Polygon' | 'Text' | 'Default'} BuilderType
 */

/**
 * @typedef {Object} FillState
 * @property {import("../colorlike.js").ColorLike} fillStyle FillStyle.
 */

/**
 * @typedef Label
 * @property {number} width Width.
 * @property {number} height Height.
 * @property {Array<string|number>} contextInstructions ContextInstructions.
 */

/**
 * @typedef {Object} FillStrokeState
 * @property {import("../colorlike.js").ColorLike} [currentFillStyle] Current FillStyle.
 * @property {import("../colorlike.js").ColorLike} [currentStrokeStyle] Current StrokeStyle.
 * @property {CanvasLineCap} [currentLineCap] Current LineCap.
 * @property {Array<number>} currentLineDash Current LineDash.
 * @property {number} [currentLineDashOffset] Current LineDashOffset.
 * @property {CanvasLineJoin} [currentLineJoin] Current LineJoin.
 * @property {number} [currentLineWidth] Current LineWidth.
 * @property {number} [currentMiterLimit] Current MiterLimit.
 * @property {number} [lastStroke] Last stroke.
 * @property {import("../colorlike.js").ColorLike} [fillStyle] FillStyle.
 * @property {import("../colorlike.js").ColorLike} [strokeStyle] StrokeStyle.
 * @property {CanvasLineCap} [lineCap] LineCap.
 * @property {Array<number>} lineDash LineDash.
 * @property {number} [lineDashOffset] LineDashOffset.
 * @property {CanvasLineJoin} [lineJoin] LineJoin.
 * @property {number} [lineWidth] LineWidth.
 * @property {number} [miterLimit] MiterLimit.
 */

/**
 * @typedef {Object} StrokeState
 * @property {CanvasLineCap} lineCap LineCap.
 * @property {Array<number>} lineDash LineDash.
 * @property {number} lineDashOffset LineDashOffset.
 * @property {CanvasLineJoin} lineJoin LineJoin.
 * @property {number} lineWidth LineWidth.
 * @property {number} miterLimit MiterLimit.
 * @property {import("../colorlike.js").ColorLike} strokeStyle StrokeStyle.
 */

/**
 * @typedef {Object} TextState
 * @property {string} font Font.
 * @property {CanvasTextAlign} [textAlign] TextAlign.
 * @property {number} [repeat] Repeat.
 * @property {import("../style/Text.js").TextJustify} [justify] Justify.
 * @property {CanvasTextBaseline} textBaseline TextBaseline.
 * @property {import("../style/Text.js").TextPlacement} [placement] Placement.
 * @property {number} [maxAngle] MaxAngle.
 * @property {boolean} [overflow] Overflow.
 * @property {import("../style/Fill.js").default} [backgroundFill] BackgroundFill.
 * @property {import("../style/Stroke.js").default} [backgroundStroke] BackgroundStroke.
 * @property {import("../size.js").Size} [scale] Scale.
 * @property {Array<number>} [padding] Padding.
 */

/**
 * @typedef {Object} SerializableInstructions
 * @property {Array<*>} instructions The rendering instructions.
 * @property {Array<*>} hitDetectionInstructions The rendering hit detection instructions.
 * @property {Array<number>} coordinates The array of all coordinates.
 * @property {!Object<string, TextState>} [textStates] The text states (decluttering).
 * @property {!Object<string, FillState>} [fillStates] The fill states (decluttering).
 * @property {!Object<string, StrokeState>} [strokeStates] The stroke states (decluttering).
 */

/**
 * @typedef {Object<number, import("./canvas/Executor.js").ReplayImageOrLabelArgs>} DeclutterImageWithText
 */

/**
 * @const
 * @type {string}
 */
const defaultFont = '10px sans-serif';

/**
 * @const
 * @type {string}
 */
const defaultFillStyle = '#000';

/**
 * @const
 * @type {CanvasLineCap}
 */
const defaultLineCap = 'round';

/**
 * @const
 * @type {Array<number>}
 */
const defaultLineDash = [];

/**
 * @const
 * @type {number}
 */
const defaultLineDashOffset = 0;

/**
 * @const
 * @type {CanvasLineJoin}
 */
const defaultLineJoin = 'round';

/**
 * @const
 * @type {number}
 */
const defaultMiterLimit = 10;

/**
 * @const
 * @type {import("../colorlike.js").ColorLike}
 */
const defaultStrokeStyle = '#000';

/**
 * @const
 * @type {CanvasTextAlign}
 */
const defaultTextAlign = 'center';

/**
 * @const
 * @type {CanvasTextBaseline}
 */
const defaultTextBaseline = 'middle';

/**
 * @const
 * @type {Array<number>}
 */
const defaultPadding = [0, 0, 0, 0];

/**
 * @const
 * @type {number}
 */
const defaultLineWidth = 1;

/**
 * @type {BaseObject}
 */
const checkedFonts = new _Object_js__WEBPACK_IMPORTED_MODULE_0__["default"]();

/**
 * @type {CanvasRenderingContext2D}
 */
let measureContext = null;

/**
 * @type {string}
 */
let measureFont;

/**
 * @type {!Object<string, number>}
 */
const textHeights = {};

/**
 * Clears the label cache when a font becomes available.
 * @param {string} fontSpec CSS font spec.
 */
const registerFont = (function () {
  const retries = 100;
  const size = '32px ';
  const referenceFonts = ['monospace', 'serif'];
  const len = referenceFonts.length;
  const text = 'wmytzilWMYTZIL@#/&?$%10\uF013';
  let interval, referenceWidth;

  /**
   * @param {string} fontStyle Css font-style
   * @param {string} fontWeight Css font-weight
   * @param {*} fontFamily Css font-family
   * @return {boolean} Font with style and weight is available
   */
  function isAvailable(fontStyle, fontWeight, fontFamily) {
    let available = true;
    for (let i = 0; i < len; ++i) {
      const referenceFont = referenceFonts[i];
      referenceWidth = measureTextWidth(
        fontStyle + ' ' + fontWeight + ' ' + size + referenceFont,
        text
      );
      if (fontFamily != referenceFont) {
        const width = measureTextWidth(
          fontStyle +
            ' ' +
            fontWeight +
            ' ' +
            size +
            fontFamily +
            ',' +
            referenceFont,
          text
        );
        // If width and referenceWidth are the same, then the fallback was used
        // instead of the font we wanted, so the font is not available.
        available = available && width != referenceWidth;
      }
    }
    if (available) {
      return true;
    }
    return false;
  }

  function check() {
    let done = true;
    const fonts = checkedFonts.getKeys();
    for (let i = 0, ii = fonts.length; i < ii; ++i) {
      const font = fonts[i];
      if (checkedFonts.get(font) < retries) {
        if (isAvailable.apply(this, font.split('\n'))) {
          (0,_obj_js__WEBPACK_IMPORTED_MODULE_1__.clear)(textHeights);
          // Make sure that loaded fonts are picked up by Safari
          measureContext = null;
          measureFont = undefined;
          checkedFonts.set(font, retries);
        } else {
          checkedFonts.set(font, checkedFonts.get(font) + 1, true);
          done = false;
        }
      }
    }
    if (done) {
      clearInterval(interval);
      interval = undefined;
    }
  }

  return function (fontSpec) {
    const font = (0,_css_js__WEBPACK_IMPORTED_MODULE_2__.getFontParameters)(fontSpec);
    if (!font) {
      return;
    }
    const families = font.families;
    for (let i = 0, ii = families.length; i < ii; ++i) {
      const family = families[i];
      const key = font.style + '\n' + font.weight + '\n' + family;
      if (checkedFonts.get(key) === undefined) {
        checkedFonts.set(key, retries, true);
        if (!isAvailable(font.style, font.weight, family)) {
          checkedFonts.set(key, 0, true);
          if (interval === undefined) {
            interval = setInterval(check, 32);
          }
        }
      }
    }
  };
})();

/**
 * @param {string} font Font to use for measuring.
 * @return {import("../size.js").Size} Measurement.
 */
const measureTextHeight = (function () {
  /**
   * @type {HTMLDivElement}
   */
  let measureElement;
  return function (fontSpec) {
    let height = textHeights[fontSpec];
    if (height == undefined) {
      if (_has_js__WEBPACK_IMPORTED_MODULE_3__.WORKER_OFFSCREEN_CANVAS) {
        const font = (0,_css_js__WEBPACK_IMPORTED_MODULE_2__.getFontParameters)(fontSpec);
        const metrics = measureText(fontSpec, 'Žg');
        const lineHeight = isNaN(Number(font.lineHeight))
          ? 1.2
          : Number(font.lineHeight);
        height =
          lineHeight *
          (metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent);
      } else {
        if (!measureElement) {
          measureElement = document.createElement('div');
          measureElement.innerHTML = 'M';
          measureElement.style.minHeight = '0';
          measureElement.style.maxHeight = 'none';
          measureElement.style.height = 'auto';
          measureElement.style.padding = '0';
          measureElement.style.border = 'none';
          measureElement.style.position = 'absolute';
          measureElement.style.display = 'block';
          measureElement.style.left = '-99999px';
        }
        measureElement.style.font = fontSpec;
        document.body.appendChild(measureElement);
        height = measureElement.offsetHeight;
        document.body.removeChild(measureElement);
      }
      textHeights[fontSpec] = height;
    }
    return height;
  };
})();

/**
 * @param {string} font Font.
 * @param {string} text Text.
 * @return {TextMetrics} Text metrics.
 */
function measureText(font, text) {
  if (!measureContext) {
    measureContext = (0,_dom_js__WEBPACK_IMPORTED_MODULE_4__.createCanvasContext2D)(1, 1);
  }
  if (font != measureFont) {
    measureContext.font = font;
    measureFont = measureContext.font;
  }
  return measureContext.measureText(text);
}

/**
 * @param {string} font Font.
 * @param {string} text Text.
 * @return {number} Width.
 */
function measureTextWidth(font, text) {
  return measureText(font, text).width;
}

/**
 * Measure text width using a cache.
 * @param {string} font The font.
 * @param {string} text The text to measure.
 * @param {Object<string, number>} cache A lookup of cached widths by text.
 * @return {number} The text width.
 */
function measureAndCacheTextWidth(font, text, cache) {
  if (text in cache) {
    return cache[text];
  }
  const width = text
    .split('\n')
    .reduce((prev, curr) => Math.max(prev, measureTextWidth(font, curr)), 0);
  cache[text] = width;
  return width;
}

/**
 * @param {TextState} baseStyle Base style.
 * @param {Array<string>} chunks Text chunks to measure.
 * @return {{width: number, height: number, widths: Array<number>, heights: Array<number>, lineWidths: Array<number>}}} Text metrics.
 */
function getTextDimensions(baseStyle, chunks) {
  const widths = [];
  const heights = [];
  const lineWidths = [];
  let width = 0;
  let lineWidth = 0;
  let height = 0;
  let lineHeight = 0;
  for (let i = 0, ii = chunks.length; i <= ii; i += 2) {
    const text = chunks[i];
    if (text === '\n' || i === ii) {
      width = Math.max(width, lineWidth);
      lineWidths.push(lineWidth);
      lineWidth = 0;
      height += lineHeight;
      continue;
    }
    const font = chunks[i + 1] || baseStyle.font;
    const currentWidth = measureTextWidth(font, text);
    widths.push(currentWidth);
    lineWidth += currentWidth;
    const currentHeight = measureTextHeight(font);
    heights.push(currentHeight);
    lineHeight = Math.max(lineHeight, currentHeight);
  }
  return {width, height, widths, heights, lineWidths};
}

/**
 * @param {CanvasRenderingContext2D} context Context.
 * @param {number} rotation Rotation.
 * @param {number} offsetX X offset.
 * @param {number} offsetY Y offset.
 */
function rotateAtOffset(context, rotation, offsetX, offsetY) {
  if (rotation !== 0) {
    context.translate(offsetX, offsetY);
    context.rotate(rotation);
    context.translate(-offsetX, -offsetY);
  }
}

/**
 * @param {CanvasRenderingContext2D} context Context.
 * @param {import("../transform.js").Transform|null} transform Transform.
 * @param {number} opacity Opacity.
 * @param {Label|HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} labelOrImage Label.
 * @param {number} originX Origin X.
 * @param {number} originY Origin Y.
 * @param {number} w Width.
 * @param {number} h Height.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {import("../size.js").Size} scale Scale.
 */
function drawImageOrLabel(
  context,
  transform,
  opacity,
  labelOrImage,
  originX,
  originY,
  w,
  h,
  x,
  y,
  scale
) {
  context.save();

  if (opacity !== 1) {
    context.globalAlpha *= opacity;
  }
  if (transform) {
    context.transform.apply(context, transform);
  }

  if (/** @type {*} */ (labelOrImage).contextInstructions) {
    // label
    context.translate(x, y);
    context.scale(scale[0], scale[1]);
    executeLabelInstructions(/** @type {Label} */ (labelOrImage), context);
  } else if (scale[0] < 0 || scale[1] < 0) {
    // flipped image
    context.translate(x, y);
    context.scale(scale[0], scale[1]);
    context.drawImage(
      /** @type {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} */ (
        labelOrImage
      ),
      originX,
      originY,
      w,
      h,
      0,
      0,
      w,
      h
    );
  } else {
    // if image not flipped translate and scale can be avoided
    context.drawImage(
      /** @type {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} */ (
        labelOrImage
      ),
      originX,
      originY,
      w,
      h,
      x,
      y,
      w * scale[0],
      h * scale[1]
    );
  }

  context.restore();
}

/**
 * @param {Label} label Label.
 * @param {CanvasRenderingContext2D} context Context.
 */
function executeLabelInstructions(label, context) {
  const contextInstructions = label.contextInstructions;
  for (let i = 0, ii = contextInstructions.length; i < ii; i += 2) {
    if (Array.isArray(contextInstructions[i + 1])) {
      context[contextInstructions[i]].apply(
        context,
        contextInstructions[i + 1]
      );
    } else {
      context[contextInstructions[i]] = contextInstructions[i + 1];
    }
  }
}


/***/ }),

/***/ "./node_modules/ol/render/canvas/Builder.js":
/*!**************************************************!*\
  !*** ./node_modules/ol/render/canvas/Builder.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Instruction_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Instruction.js */ "./node_modules/ol/render/canvas/Instruction.js");
/* harmony import */ var _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../extent/Relationship.js */ "./node_modules/ol/extent/Relationship.js");
/* harmony import */ var _VectorContext_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../VectorContext.js */ "./node_modules/ol/render/VectorContext.js");
/* harmony import */ var _colorlike_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../colorlike.js */ "./node_modules/ol/colorlike.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _canvas_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../canvas.js */ "./node_modules/ol/render/canvas.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _geom_flat_inflate_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../geom/flat/inflate.js */ "./node_modules/ol/geom/flat/inflate.js");
/**
 * @module ol/render/canvas/Builder
 */









class CanvasBuilder extends _VectorContext_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */
  constructor(tolerance, maxExtent, resolution, pixelRatio) {
    super();

    /**
     * @protected
     * @type {number}
     */
    this.tolerance = tolerance;

    /**
     * @protected
     * @const
     * @type {import("../../extent.js").Extent}
     */
    this.maxExtent = maxExtent;

    /**
     * @protected
     * @type {number}
     */
    this.pixelRatio = pixelRatio;

    /**
     * @protected
     * @type {number}
     */
    this.maxLineWidth = 0;

    /**
     * @protected
     * @const
     * @type {number}
     */
    this.resolution = resolution;

    /**
     * @private
     * @type {Array<*>}
     */
    this.beginGeometryInstruction1_ = null;

    /**
     * @private
     * @type {Array<*>}
     */
    this.beginGeometryInstruction2_ = null;

    /**
     * @private
     * @type {import("../../extent.js").Extent}
     */
    this.bufferedMaxExtent_ = null;

    /**
     * @protected
     * @type {Array<*>}
     */
    this.instructions = [];

    /**
     * @protected
     * @type {Array<number>}
     */
    this.coordinates = [];

    /**
     * @private
     * @type {import("../../coordinate.js").Coordinate}
     */
    this.tmpCoordinate_ = [];

    /**
     * @protected
     * @type {Array<*>}
     */
    this.hitDetectionInstructions = [];

    /**
     * @protected
     * @type {import("../canvas.js").FillStrokeState}
     */
    this.state = /** @type {import("../canvas.js").FillStrokeState} */ ({});
  }

  /**
   * @protected
   * @param {Array<number>} dashArray Dash array.
   * @return {Array<number>} Dash array with pixel ratio applied
   */
  applyPixelRatio(dashArray) {
    const pixelRatio = this.pixelRatio;
    return pixelRatio == 1
      ? dashArray
      : dashArray.map(function (dash) {
          return dash * pixelRatio;
        });
  }

  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} stride Stride.
   * @protected
   * @return {number} My end
   */
  appendFlatPointCoordinates(flatCoordinates, stride) {
    const extent = this.getBufferedMaxExtent();
    const tmpCoord = this.tmpCoordinate_;
    const coordinates = this.coordinates;
    let myEnd = coordinates.length;
    for (let i = 0, ii = flatCoordinates.length; i < ii; i += stride) {
      tmpCoord[0] = flatCoordinates[i];
      tmpCoord[1] = flatCoordinates[i + 1];
      if ((0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.containsCoordinate)(extent, tmpCoord)) {
        coordinates[myEnd++] = tmpCoord[0];
        coordinates[myEnd++] = tmpCoord[1];
      }
    }
    return myEnd;
  }

  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @param {boolean} closed Last input coordinate equals first.
   * @param {boolean} skipFirst Skip first coordinate.
   * @protected
   * @return {number} My end.
   */
  appendFlatLineCoordinates(
    flatCoordinates,
    offset,
    end,
    stride,
    closed,
    skipFirst
  ) {
    const coordinates = this.coordinates;
    let myEnd = coordinates.length;
    const extent = this.getBufferedMaxExtent();
    if (skipFirst) {
      offset += stride;
    }
    let lastXCoord = flatCoordinates[offset];
    let lastYCoord = flatCoordinates[offset + 1];
    const nextCoord = this.tmpCoordinate_;
    let skipped = true;

    let i, lastRel, nextRel;
    for (i = offset + stride; i < end; i += stride) {
      nextCoord[0] = flatCoordinates[i];
      nextCoord[1] = flatCoordinates[i + 1];
      nextRel = (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.coordinateRelationship)(extent, nextCoord);
      if (nextRel !== lastRel) {
        if (skipped) {
          coordinates[myEnd++] = lastXCoord;
          coordinates[myEnd++] = lastYCoord;
          skipped = false;
        }
        coordinates[myEnd++] = nextCoord[0];
        coordinates[myEnd++] = nextCoord[1];
      } else if (nextRel === _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_2__["default"].INTERSECTING) {
        coordinates[myEnd++] = nextCoord[0];
        coordinates[myEnd++] = nextCoord[1];
        skipped = false;
      } else {
        skipped = true;
      }
      lastXCoord = nextCoord[0];
      lastYCoord = nextCoord[1];
      lastRel = nextRel;
    }

    // Last coordinate equals first or only one point to append:
    if ((closed && skipped) || i === offset + stride) {
      coordinates[myEnd++] = lastXCoord;
      coordinates[myEnd++] = lastYCoord;
    }
    return myEnd;
  }

  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<number>} ends Ends.
   * @param {number} stride Stride.
   * @param {Array<number>} builderEnds Builder ends.
   * @return {number} Offset.
   */
  drawCustomCoordinates_(flatCoordinates, offset, ends, stride, builderEnds) {
    for (let i = 0, ii = ends.length; i < ii; ++i) {
      const end = ends[i];
      const builderEnd = this.appendFlatLineCoordinates(
        flatCoordinates,
        offset,
        end,
        stride,
        false,
        false
      );
      builderEnds.push(builderEnd);
      offset = end;
    }
    return offset;
  }

  /**
   * @param {import("../../geom/SimpleGeometry.js").default} geometry Geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   * @param {Function} renderer Renderer.
   * @param {Function} hitDetectionRenderer Renderer.
   */
  drawCustom(geometry, feature, renderer, hitDetectionRenderer) {
    this.beginGeometry(geometry, feature);

    const type = geometry.getType();
    const stride = geometry.getStride();
    const builderBegin = this.coordinates.length;

    let flatCoordinates, builderEnd, builderEnds, builderEndss;
    let offset;

    switch (type) {
      case 'MultiPolygon':
        flatCoordinates =
          /** @type {import("../../geom/MultiPolygon.js").default} */ (
            geometry
          ).getOrientedFlatCoordinates();
        builderEndss = [];
        const endss =
          /** @type {import("../../geom/MultiPolygon.js").default} */ (
            geometry
          ).getEndss();
        offset = 0;
        for (let i = 0, ii = endss.length; i < ii; ++i) {
          const myEnds = [];
          offset = this.drawCustomCoordinates_(
            flatCoordinates,
            offset,
            endss[i],
            stride,
            myEnds
          );
          builderEndss.push(myEnds);
        }
        this.instructions.push([
          _Instruction_js__WEBPACK_IMPORTED_MODULE_3__["default"].CUSTOM,
          builderBegin,
          builderEndss,
          geometry,
          renderer,
          _geom_flat_inflate_js__WEBPACK_IMPORTED_MODULE_4__.inflateMultiCoordinatesArray,
        ]);
        this.hitDetectionInstructions.push([
          _Instruction_js__WEBPACK_IMPORTED_MODULE_3__["default"].CUSTOM,
          builderBegin,
          builderEndss,
          geometry,
          hitDetectionRenderer || renderer,
          _geom_flat_inflate_js__WEBPACK_IMPORTED_MODULE_4__.inflateMultiCoordinatesArray,
        ]);
        break;
      case 'Polygon':
      case 'MultiLineString':
        builderEnds = [];
        flatCoordinates =
          type == 'Polygon'
            ? /** @type {import("../../geom/Polygon.js").default} */ (
                geometry
              ).getOrientedFlatCoordinates()
            : geometry.getFlatCoordinates();
        offset = this.drawCustomCoordinates_(
          flatCoordinates,
          0,
          /** @type {import("../../geom/Polygon.js").default|import("../../geom/MultiLineString.js").default} */ (
            geometry
          ).getEnds(),
          stride,
          builderEnds
        );
        this.instructions.push([
          _Instruction_js__WEBPACK_IMPORTED_MODULE_3__["default"].CUSTOM,
          builderBegin,
          builderEnds,
          geometry,
          renderer,
          _geom_flat_inflate_js__WEBPACK_IMPORTED_MODULE_4__.inflateCoordinatesArray,
        ]);
        this.hitDetectionInstructions.push([
          _Instruction_js__WEBPACK_IMPORTED_MODULE_3__["default"].CUSTOM,
          builderBegin,
          builderEnds,
          geometry,
          hitDetectionRenderer || renderer,
          _geom_flat_inflate_js__WEBPACK_IMPORTED_MODULE_4__.inflateCoordinatesArray,
        ]);
        break;
      case 'LineString':
      case 'Circle':
        flatCoordinates = geometry.getFlatCoordinates();
        builderEnd = this.appendFlatLineCoordinates(
          flatCoordinates,
          0,
          flatCoordinates.length,
          stride,
          false,
          false
        );
        this.instructions.push([
          _Instruction_js__WEBPACK_IMPORTED_MODULE_3__["default"].CUSTOM,
          builderBegin,
          builderEnd,
          geometry,
          renderer,
          _geom_flat_inflate_js__WEBPACK_IMPORTED_MODULE_4__.inflateCoordinates,
        ]);
        this.hitDetectionInstructions.push([
          _Instruction_js__WEBPACK_IMPORTED_MODULE_3__["default"].CUSTOM,
          builderBegin,
          builderEnd,
          geometry,
          hitDetectionRenderer || renderer,
          _geom_flat_inflate_js__WEBPACK_IMPORTED_MODULE_4__.inflateCoordinates,
        ]);
        break;
      case 'MultiPoint':
        flatCoordinates = geometry.getFlatCoordinates();
        builderEnd = this.appendFlatPointCoordinates(flatCoordinates, stride);

        if (builderEnd > builderBegin) {
          this.instructions.push([
            _Instruction_js__WEBPACK_IMPORTED_MODULE_3__["default"].CUSTOM,
            builderBegin,
            builderEnd,
            geometry,
            renderer,
            _geom_flat_inflate_js__WEBPACK_IMPORTED_MODULE_4__.inflateCoordinates,
          ]);
          this.hitDetectionInstructions.push([
            _Instruction_js__WEBPACK_IMPORTED_MODULE_3__["default"].CUSTOM,
            builderBegin,
            builderEnd,
            geometry,
            hitDetectionRenderer || renderer,
            _geom_flat_inflate_js__WEBPACK_IMPORTED_MODULE_4__.inflateCoordinates,
          ]);
        }
        break;
      case 'Point':
        flatCoordinates = geometry.getFlatCoordinates();
        this.coordinates.push(flatCoordinates[0], flatCoordinates[1]);
        builderEnd = this.coordinates.length;

        this.instructions.push([
          _Instruction_js__WEBPACK_IMPORTED_MODULE_3__["default"].CUSTOM,
          builderBegin,
          builderEnd,
          geometry,
          renderer,
        ]);
        this.hitDetectionInstructions.push([
          _Instruction_js__WEBPACK_IMPORTED_MODULE_3__["default"].CUSTOM,
          builderBegin,
          builderEnd,
          geometry,
          hitDetectionRenderer || renderer,
        ]);
        break;
      default:
    }
    this.endGeometry(feature);
  }

  /**
   * @protected
   * @param {import("../../geom/Geometry").default|import("../Feature.js").default} geometry The geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   */
  beginGeometry(geometry, feature) {
    this.beginGeometryInstruction1_ = [
      _Instruction_js__WEBPACK_IMPORTED_MODULE_3__["default"].BEGIN_GEOMETRY,
      feature,
      0,
      geometry,
    ];
    this.instructions.push(this.beginGeometryInstruction1_);
    this.beginGeometryInstruction2_ = [
      _Instruction_js__WEBPACK_IMPORTED_MODULE_3__["default"].BEGIN_GEOMETRY,
      feature,
      0,
      geometry,
    ];
    this.hitDetectionInstructions.push(this.beginGeometryInstruction2_);
  }

  /**
   * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
   */
  finish() {
    return {
      instructions: this.instructions,
      hitDetectionInstructions: this.hitDetectionInstructions,
      coordinates: this.coordinates,
    };
  }

  /**
   * Reverse the hit detection instructions.
   */
  reverseHitDetectionInstructions() {
    const hitDetectionInstructions = this.hitDetectionInstructions;
    // step 1 - reverse array
    hitDetectionInstructions.reverse();
    // step 2 - reverse instructions within geometry blocks
    let i;
    const n = hitDetectionInstructions.length;
    let instruction;
    let type;
    let begin = -1;
    for (i = 0; i < n; ++i) {
      instruction = hitDetectionInstructions[i];
      type = /** @type {import("./Instruction.js").default} */ (instruction[0]);
      if (type == _Instruction_js__WEBPACK_IMPORTED_MODULE_3__["default"].END_GEOMETRY) {
        begin = i;
      } else if (type == _Instruction_js__WEBPACK_IMPORTED_MODULE_3__["default"].BEGIN_GEOMETRY) {
        instruction[2] = i;
        (0,_array_js__WEBPACK_IMPORTED_MODULE_5__.reverseSubArray)(this.hitDetectionInstructions, begin, i);
        begin = -1;
      }
    }
  }

  /**
   * @param {import("../../style/Fill.js").default} fillStyle Fill style.
   * @param {import("../../style/Stroke.js").default} strokeStyle Stroke style.
   */
  setFillStrokeStyle(fillStyle, strokeStyle) {
    const state = this.state;
    if (fillStyle) {
      const fillStyleColor = fillStyle.getColor();
      state.fillStyle = (0,_colorlike_js__WEBPACK_IMPORTED_MODULE_6__.asColorLike)(
        fillStyleColor ? fillStyleColor : _canvas_js__WEBPACK_IMPORTED_MODULE_7__.defaultFillStyle
      );
    } else {
      state.fillStyle = undefined;
    }
    if (strokeStyle) {
      const strokeStyleColor = strokeStyle.getColor();
      state.strokeStyle = (0,_colorlike_js__WEBPACK_IMPORTED_MODULE_6__.asColorLike)(
        strokeStyleColor ? strokeStyleColor : _canvas_js__WEBPACK_IMPORTED_MODULE_7__.defaultStrokeStyle
      );
      const strokeStyleLineCap = strokeStyle.getLineCap();
      state.lineCap =
        strokeStyleLineCap !== undefined ? strokeStyleLineCap : _canvas_js__WEBPACK_IMPORTED_MODULE_7__.defaultLineCap;
      const strokeStyleLineDash = strokeStyle.getLineDash();
      state.lineDash = strokeStyleLineDash
        ? strokeStyleLineDash.slice()
        : _canvas_js__WEBPACK_IMPORTED_MODULE_7__.defaultLineDash;
      const strokeStyleLineDashOffset = strokeStyle.getLineDashOffset();
      state.lineDashOffset = strokeStyleLineDashOffset
        ? strokeStyleLineDashOffset
        : _canvas_js__WEBPACK_IMPORTED_MODULE_7__.defaultLineDashOffset;
      const strokeStyleLineJoin = strokeStyle.getLineJoin();
      state.lineJoin =
        strokeStyleLineJoin !== undefined
          ? strokeStyleLineJoin
          : _canvas_js__WEBPACK_IMPORTED_MODULE_7__.defaultLineJoin;
      const strokeStyleWidth = strokeStyle.getWidth();
      state.lineWidth =
        strokeStyleWidth !== undefined ? strokeStyleWidth : _canvas_js__WEBPACK_IMPORTED_MODULE_7__.defaultLineWidth;
      const strokeStyleMiterLimit = strokeStyle.getMiterLimit();
      state.miterLimit =
        strokeStyleMiterLimit !== undefined
          ? strokeStyleMiterLimit
          : _canvas_js__WEBPACK_IMPORTED_MODULE_7__.defaultMiterLimit;

      if (state.lineWidth > this.maxLineWidth) {
        this.maxLineWidth = state.lineWidth;
        // invalidate the buffered max extent cache
        this.bufferedMaxExtent_ = null;
      }
    } else {
      state.strokeStyle = undefined;
      state.lineCap = undefined;
      state.lineDash = null;
      state.lineDashOffset = undefined;
      state.lineJoin = undefined;
      state.lineWidth = undefined;
      state.miterLimit = undefined;
    }
  }

  /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   * @return {Array<*>} Fill instruction.
   */
  createFill(state) {
    const fillStyle = state.fillStyle;
    /** @type {Array<*>} */
    const fillInstruction = [_Instruction_js__WEBPACK_IMPORTED_MODULE_3__["default"].SET_FILL_STYLE, fillStyle];
    if (typeof fillStyle !== 'string') {
      // Fill is a pattern or gradient - align it!
      fillInstruction.push(true);
    }
    return fillInstruction;
  }

  /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   */
  applyStroke(state) {
    this.instructions.push(this.createStroke(state));
  }

  /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   * @return {Array<*>} Stroke instruction.
   */
  createStroke(state) {
    return [
      _Instruction_js__WEBPACK_IMPORTED_MODULE_3__["default"].SET_STROKE_STYLE,
      state.strokeStyle,
      state.lineWidth * this.pixelRatio,
      state.lineCap,
      state.lineJoin,
      state.miterLimit,
      this.applyPixelRatio(state.lineDash),
      state.lineDashOffset * this.pixelRatio,
    ];
  }

  /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   * @param {function(this:CanvasBuilder, import("../canvas.js").FillStrokeState):Array<*>} createFill Create fill.
   */
  updateFillStyle(state, createFill) {
    const fillStyle = state.fillStyle;
    if (typeof fillStyle !== 'string' || state.currentFillStyle != fillStyle) {
      if (fillStyle !== undefined) {
        this.instructions.push(createFill.call(this, state));
      }
      state.currentFillStyle = fillStyle;
    }
  }

  /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   * @param {function(this:CanvasBuilder, import("../canvas.js").FillStrokeState): void} applyStroke Apply stroke.
   */
  updateStrokeStyle(state, applyStroke) {
    const strokeStyle = state.strokeStyle;
    const lineCap = state.lineCap;
    const lineDash = state.lineDash;
    const lineDashOffset = state.lineDashOffset;
    const lineJoin = state.lineJoin;
    const lineWidth = state.lineWidth;
    const miterLimit = state.miterLimit;
    if (
      state.currentStrokeStyle != strokeStyle ||
      state.currentLineCap != lineCap ||
      (lineDash != state.currentLineDash &&
        !(0,_array_js__WEBPACK_IMPORTED_MODULE_5__.equals)(state.currentLineDash, lineDash)) ||
      state.currentLineDashOffset != lineDashOffset ||
      state.currentLineJoin != lineJoin ||
      state.currentLineWidth != lineWidth ||
      state.currentMiterLimit != miterLimit
    ) {
      if (strokeStyle !== undefined) {
        applyStroke.call(this, state);
      }
      state.currentStrokeStyle = strokeStyle;
      state.currentLineCap = lineCap;
      state.currentLineDash = lineDash;
      state.currentLineDashOffset = lineDashOffset;
      state.currentLineJoin = lineJoin;
      state.currentLineWidth = lineWidth;
      state.currentMiterLimit = miterLimit;
    }
  }

  /**
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   */
  endGeometry(feature) {
    this.beginGeometryInstruction1_[2] = this.instructions.length;
    this.beginGeometryInstruction1_ = null;
    this.beginGeometryInstruction2_[2] = this.hitDetectionInstructions.length;
    this.beginGeometryInstruction2_ = null;
    const endGeometryInstruction = [_Instruction_js__WEBPACK_IMPORTED_MODULE_3__["default"].END_GEOMETRY, feature];
    this.instructions.push(endGeometryInstruction);
    this.hitDetectionInstructions.push(endGeometryInstruction);
  }

  /**
   * Get the buffered rendering extent.  Rendering will be clipped to the extent
   * provided to the constructor.  To account for symbolizers that may intersect
   * this extent, we calculate a buffered extent (e.g. based on stroke width).
   * @return {import("../../extent.js").Extent} The buffered rendering extent.
   * @protected
   */
  getBufferedMaxExtent() {
    if (!this.bufferedMaxExtent_) {
      this.bufferedMaxExtent_ = (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.clone)(this.maxExtent);
      if (this.maxLineWidth > 0) {
        const width = (this.resolution * (this.maxLineWidth + 1)) / 2;
        (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.buffer)(this.bufferedMaxExtent_, width, this.bufferedMaxExtent_);
      }
    }
    return this.bufferedMaxExtent_;
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CanvasBuilder);


/***/ }),

/***/ "./node_modules/ol/render/canvas/BuilderGroup.js":
/*!*******************************************************!*\
  !*** ./node_modules/ol/render/canvas/BuilderGroup.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Builder_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Builder.js */ "./node_modules/ol/render/canvas/Builder.js");
/* harmony import */ var _ImageBuilder_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ImageBuilder.js */ "./node_modules/ol/render/canvas/ImageBuilder.js");
/* harmony import */ var _LineStringBuilder_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./LineStringBuilder.js */ "./node_modules/ol/render/canvas/LineStringBuilder.js");
/* harmony import */ var _PolygonBuilder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PolygonBuilder.js */ "./node_modules/ol/render/canvas/PolygonBuilder.js");
/* harmony import */ var _TextBuilder_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./TextBuilder.js */ "./node_modules/ol/render/canvas/TextBuilder.js");
/**
 * @module ol/render/canvas/BuilderGroup
 */







/**
 * @type {Object<import("../canvas.js").BuilderType, typeof Builder>}
 */
const BATCH_CONSTRUCTORS = {
  'Circle': _PolygonBuilder_js__WEBPACK_IMPORTED_MODULE_0__["default"],
  'Default': _Builder_js__WEBPACK_IMPORTED_MODULE_1__["default"],
  'Image': _ImageBuilder_js__WEBPACK_IMPORTED_MODULE_2__["default"],
  'LineString': _LineStringBuilder_js__WEBPACK_IMPORTED_MODULE_3__["default"],
  'Polygon': _PolygonBuilder_js__WEBPACK_IMPORTED_MODULE_0__["default"],
  'Text': _TextBuilder_js__WEBPACK_IMPORTED_MODULE_4__["default"],
};

class BuilderGroup {
  /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Max extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */
  constructor(tolerance, maxExtent, resolution, pixelRatio) {
    /**
     * @private
     * @type {number}
     */
    this.tolerance_ = tolerance;

    /**
     * @private
     * @type {import("../../extent.js").Extent}
     */
    this.maxExtent_ = maxExtent;

    /**
     * @private
     * @type {number}
     */
    this.pixelRatio_ = pixelRatio;

    /**
     * @private
     * @type {number}
     */
    this.resolution_ = resolution;

    /**
     * @private
     * @type {!Object<string, !Object<import("../canvas.js").BuilderType, Builder>>}
     */
    this.buildersByZIndex_ = {};
  }

  /**
   * @return {!Object<string, !Object<import("../canvas.js").BuilderType, import("./Builder.js").SerializableInstructions>>} The serializable instructions
   */
  finish() {
    const builderInstructions = {};
    for (const zKey in this.buildersByZIndex_) {
      builderInstructions[zKey] = builderInstructions[zKey] || {};
      const builders = this.buildersByZIndex_[zKey];
      for (const builderKey in builders) {
        const builderInstruction = builders[builderKey].finish();
        builderInstructions[zKey][builderKey] = builderInstruction;
      }
    }
    return builderInstructions;
  }

  /**
   * @param {number|undefined} zIndex Z index.
   * @param {import("../canvas.js").BuilderType} builderType Replay type.
   * @return {import("../VectorContext.js").default} Replay.
   */
  getBuilder(zIndex, builderType) {
    const zIndexKey = zIndex !== undefined ? zIndex.toString() : '0';
    let replays = this.buildersByZIndex_[zIndexKey];
    if (replays === undefined) {
      replays = {};
      this.buildersByZIndex_[zIndexKey] = replays;
    }
    let replay = replays[builderType];
    if (replay === undefined) {
      const Constructor = BATCH_CONSTRUCTORS[builderType];
      replay = new Constructor(
        this.tolerance_,
        this.maxExtent_,
        this.resolution_,
        this.pixelRatio_
      );
      replays[builderType] = replay;
    }
    return replay;
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (BuilderGroup);


/***/ }),

/***/ "./node_modules/ol/render/canvas/Executor.js":
/*!***************************************************!*\
  !*** ./node_modules/ol/render/canvas/Executor.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Instruction_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Instruction.js */ "./node_modules/ol/render/canvas/Instruction.js");
/* harmony import */ var _TextBuilder_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./TextBuilder.js */ "./node_modules/ol/render/canvas/TextBuilder.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../transform.js */ "./node_modules/ol/transform.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _canvas_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../canvas.js */ "./node_modules/ol/render/canvas.js");
/* harmony import */ var _geom_flat_textpath_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../geom/flat/textpath.js */ "./node_modules/ol/geom/flat/textpath.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _geom_flat_length_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../geom/flat/length.js */ "./node_modules/ol/geom/flat/length.js");
/* harmony import */ var _geom_flat_transform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../geom/flat/transform.js */ "./node_modules/ol/geom/flat/transform.js");
/**
 * @module ol/render/canvas/Executor
 */










/**
 * @typedef {Object} BBox
 * @property {number} minX Minimal x.
 * @property {number} minY Minimal y.
 * @property {number} maxX Maximal x.
 * @property {number} maxY Maximal y
 * @property {*} value Value.
 */

/**
 * @typedef {Object} ImageOrLabelDimensions
 * @property {number} drawImageX DrawImageX.
 * @property {number} drawImageY DrawImageY.
 * @property {number} drawImageW DrawImageW.
 * @property {number} drawImageH DrawImageH.
 * @property {number} originX OriginX.
 * @property {number} originY OriginY.
 * @property {Array<number>} scale Scale.
 * @property {BBox} declutterBox DeclutterBox.
 * @property {import("../../transform.js").Transform} canvasTransform CanvasTransform.
 */

/**
 * @typedef {{0: CanvasRenderingContext2D, 1: number, 2: import("../canvas.js").Label|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement, 3: ImageOrLabelDimensions, 4: number, 5: Array<*>, 6: Array<*>}} ReplayImageOrLabelArgs
 */

/**
 * @template T
 * @typedef {function(import("../../Feature.js").FeatureLike, import("../../geom/SimpleGeometry.js").default): T} FeatureCallback
 */

/**
 * @type {import("../../extent.js").Extent}
 */
const tmpExtent = (0,_extent_js__WEBPACK_IMPORTED_MODULE_0__.createEmpty)();

/** @type {import("../../coordinate.js").Coordinate} */
const p1 = [];
/** @type {import("../../coordinate.js").Coordinate} */
const p2 = [];
/** @type {import("../../coordinate.js").Coordinate} */
const p3 = [];
/** @type {import("../../coordinate.js").Coordinate} */
const p4 = [];

/**
 * @param {ReplayImageOrLabelArgs} replayImageOrLabelArgs Arguments to replayImageOrLabel
 * @return {BBox} Declutter bbox.
 */
function getDeclutterBox(replayImageOrLabelArgs) {
  return replayImageOrLabelArgs[3].declutterBox;
}

const rtlRegEx = new RegExp(
  /* eslint-disable prettier/prettier */
  '[' +
    String.fromCharCode(0x00591) + '-' + String.fromCharCode(0x008ff) +
    String.fromCharCode(0x0fb1d) + '-' + String.fromCharCode(0x0fdff) +
    String.fromCharCode(0x0fe70) + '-' + String.fromCharCode(0x0fefc) +
    String.fromCharCode(0x10800) + '-' + String.fromCharCode(0x10fff) +
    String.fromCharCode(0x1e800) + '-' + String.fromCharCode(0x1efff) +
  ']'
  /* eslint-enable prettier/prettier */
);

/**
 * @param {string} text Text.
 * @param {CanvasTextAlign} align Alignment.
 * @return {number} Text alignment.
 */
function horizontalTextAlign(text, align) {
  if (align === 'start') {
    align = rtlRegEx.test(text) ? 'right' : 'left';
  } else if (align === 'end') {
    align = rtlRegEx.test(text) ? 'left' : 'right';
  }
  return _TextBuilder_js__WEBPACK_IMPORTED_MODULE_1__.TEXT_ALIGN[align];
}

/**
 * @param {Array<string>} acc Accumulator.
 * @param {string} line Line of text.
 * @param {number} i Index
 * @return {Array<string>} Accumulator.
 */
function createTextChunks(acc, line, i) {
  if (i > 0) {
    acc.push('\n', '');
  }
  acc.push(line, '');
  return acc;
}

class Executor {
  /**
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {boolean} overlaps The replay can have overlapping geometries.
   * @param {import("../canvas.js").SerializableInstructions} instructions The serializable instructions
   */
  constructor(resolution, pixelRatio, overlaps, instructions) {
    /**
     * @protected
     * @type {boolean}
     */
    this.overlaps = overlaps;

    /**
     * @protected
     * @type {number}
     */
    this.pixelRatio = pixelRatio;

    /**
     * @protected
     * @const
     * @type {number}
     */
    this.resolution = resolution;

    /**
     * @private
     * @type {boolean}
     */
    this.alignFill_;

    /**
     * @protected
     * @type {Array<*>}
     */
    this.instructions = instructions.instructions;

    /**
     * @protected
     * @type {Array<number>}
     */
    this.coordinates = instructions.coordinates;

    /**
     * @private
     * @type {!Object<number,import("../../coordinate.js").Coordinate|Array<import("../../coordinate.js").Coordinate>|Array<Array<import("../../coordinate.js").Coordinate>>>}
     */
    this.coordinateCache_ = {};

    /**
     * @private
     * @type {!import("../../transform.js").Transform}
     */
    this.renderedTransform_ = (0,_transform_js__WEBPACK_IMPORTED_MODULE_2__.create)();

    /**
     * @protected
     * @type {Array<*>}
     */
    this.hitDetectionInstructions = instructions.hitDetectionInstructions;

    /**
     * @private
     * @type {Array<number>}
     */
    this.pixelCoordinates_ = null;

    /**
     * @private
     * @type {number}
     */
    this.viewRotation_ = 0;

    /**
     * @type {!Object<string, import("../canvas.js").FillState>}
     */
    this.fillStates = instructions.fillStates || {};

    /**
     * @type {!Object<string, import("../canvas.js").StrokeState>}
     */
    this.strokeStates = instructions.strokeStates || {};

    /**
     * @type {!Object<string, import("../canvas.js").TextState>}
     */
    this.textStates = instructions.textStates || {};

    /**
     * @private
     * @type {Object<string, Object<string, number>>}
     */
    this.widths_ = {};

    /**
     * @private
     * @type {Object<string, import("../canvas.js").Label>}
     */
    this.labels_ = {};
  }

  /**
   * @param {string|Array<string>} text Text.
   * @param {string} textKey Text style key.
   * @param {string} fillKey Fill style key.
   * @param {string} strokeKey Stroke style key.
   * @return {import("../canvas.js").Label} Label.
   */
  createLabel(text, textKey, fillKey, strokeKey) {
    const key = text + textKey + fillKey + strokeKey;
    if (this.labels_[key]) {
      return this.labels_[key];
    }
    const strokeState = strokeKey ? this.strokeStates[strokeKey] : null;
    const fillState = fillKey ? this.fillStates[fillKey] : null;
    const textState = this.textStates[textKey];
    const pixelRatio = this.pixelRatio;
    const scale = [
      textState.scale[0] * pixelRatio,
      textState.scale[1] * pixelRatio,
    ];
    const textIsArray = Array.isArray(text);
    const align = textState.justify
      ? _TextBuilder_js__WEBPACK_IMPORTED_MODULE_1__.TEXT_ALIGN[textState.justify]
      : horizontalTextAlign(
          Array.isArray(text) ? text[0] : text,
          textState.textAlign || _canvas_js__WEBPACK_IMPORTED_MODULE_3__.defaultTextAlign
        );
    const strokeWidth =
      strokeKey && strokeState.lineWidth ? strokeState.lineWidth : 0;

    const chunks = textIsArray
      ? text
      : text.split('\n').reduce(createTextChunks, []);

    const {width, height, widths, heights, lineWidths} = (0,_canvas_js__WEBPACK_IMPORTED_MODULE_3__.getTextDimensions)(
      textState,
      chunks
    );
    const renderWidth = width + strokeWidth;
    const contextInstructions = [];
    // make canvas 2 pixels wider to account for italic text width measurement errors
    const w = (renderWidth + 2) * scale[0];
    const h = (height + strokeWidth) * scale[1];
    /** @type {import("../canvas.js").Label} */
    const label = {
      width: w < 0 ? Math.floor(w) : Math.ceil(w),
      height: h < 0 ? Math.floor(h) : Math.ceil(h),
      contextInstructions: contextInstructions,
    };
    if (scale[0] != 1 || scale[1] != 1) {
      contextInstructions.push('scale', scale);
    }
    if (strokeKey) {
      contextInstructions.push('strokeStyle', strokeState.strokeStyle);
      contextInstructions.push('lineWidth', strokeWidth);
      contextInstructions.push('lineCap', strokeState.lineCap);
      contextInstructions.push('lineJoin', strokeState.lineJoin);
      contextInstructions.push('miterLimit', strokeState.miterLimit);
      contextInstructions.push('setLineDash', [strokeState.lineDash]);
      contextInstructions.push('lineDashOffset', strokeState.lineDashOffset);
    }
    if (fillKey) {
      contextInstructions.push('fillStyle', fillState.fillStyle);
    }
    contextInstructions.push('textBaseline', 'middle');
    contextInstructions.push('textAlign', 'center');
    const leftRight = 0.5 - align;
    let x = align * renderWidth + leftRight * strokeWidth;
    const strokeInstructions = [];
    const fillInstructions = [];
    let lineHeight = 0;
    let lineOffset = 0;
    let widthHeightIndex = 0;
    let lineWidthIndex = 0;
    let previousFont;
    for (let i = 0, ii = chunks.length; i < ii; i += 2) {
      const text = chunks[i];
      if (text === '\n') {
        lineOffset += lineHeight;
        lineHeight = 0;
        x = align * renderWidth + leftRight * strokeWidth;
        ++lineWidthIndex;
        continue;
      }
      const font = chunks[i + 1] || textState.font;
      if (font !== previousFont) {
        if (strokeKey) {
          strokeInstructions.push('font', font);
        }
        if (fillKey) {
          fillInstructions.push('font', font);
        }
        previousFont = font;
      }
      lineHeight = Math.max(lineHeight, heights[widthHeightIndex]);
      const fillStrokeArgs = [
        text,
        x +
          leftRight * widths[widthHeightIndex] +
          align * (widths[widthHeightIndex] - lineWidths[lineWidthIndex]),
        0.5 * (strokeWidth + lineHeight) + lineOffset,
      ];
      x += widths[widthHeightIndex];
      if (strokeKey) {
        strokeInstructions.push('strokeText', fillStrokeArgs);
      }
      if (fillKey) {
        fillInstructions.push('fillText', fillStrokeArgs);
      }
      ++widthHeightIndex;
    }
    Array.prototype.push.apply(contextInstructions, strokeInstructions);
    Array.prototype.push.apply(contextInstructions, fillInstructions);
    this.labels_[key] = label;
    return label;
  }

  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../coordinate.js").Coordinate} p1 1st point of the background box.
   * @param {import("../../coordinate.js").Coordinate} p2 2nd point of the background box.
   * @param {import("../../coordinate.js").Coordinate} p3 3rd point of the background box.
   * @param {import("../../coordinate.js").Coordinate} p4 4th point of the background box.
   * @param {Array<*>} fillInstruction Fill instruction.
   * @param {Array<*>} strokeInstruction Stroke instruction.
   */
  replayTextBackground_(
    context,
    p1,
    p2,
    p3,
    p4,
    fillInstruction,
    strokeInstruction
  ) {
    context.beginPath();
    context.moveTo.apply(context, p1);
    context.lineTo.apply(context, p2);
    context.lineTo.apply(context, p3);
    context.lineTo.apply(context, p4);
    context.lineTo.apply(context, p1);
    if (fillInstruction) {
      this.alignFill_ = /** @type {boolean} */ (fillInstruction[2]);
      this.fill_(context);
    }
    if (strokeInstruction) {
      this.setStrokeStyle_(
        context,
        /** @type {Array<*>} */ (strokeInstruction)
      );
      context.stroke();
    }
  }

  /**
   * @private
   * @param {number} sheetWidth Width of the sprite sheet.
   * @param {number} sheetHeight Height of the sprite sheet.
   * @param {number} centerX X.
   * @param {number} centerY Y.
   * @param {number} width Width.
   * @param {number} height Height.
   * @param {number} anchorX Anchor X.
   * @param {number} anchorY Anchor Y.
   * @param {number} originX Origin X.
   * @param {number} originY Origin Y.
   * @param {number} rotation Rotation.
   * @param {import("../../size.js").Size} scale Scale.
   * @param {boolean} snapToPixel Snap to pixel.
   * @param {Array<number>} padding Padding.
   * @param {boolean} fillStroke Background fill or stroke.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   * @return {ImageOrLabelDimensions} Dimensions for positioning and decluttering the image or label.
   */
  calculateImageOrLabelDimensions_(
    sheetWidth,
    sheetHeight,
    centerX,
    centerY,
    width,
    height,
    anchorX,
    anchorY,
    originX,
    originY,
    rotation,
    scale,
    snapToPixel,
    padding,
    fillStroke,
    feature
  ) {
    anchorX *= scale[0];
    anchorY *= scale[1];
    let x = centerX - anchorX;
    let y = centerY - anchorY;

    const w = width + originX > sheetWidth ? sheetWidth - originX : width;
    const h = height + originY > sheetHeight ? sheetHeight - originY : height;
    const boxW = padding[3] + w * scale[0] + padding[1];
    const boxH = padding[0] + h * scale[1] + padding[2];
    const boxX = x - padding[3];
    const boxY = y - padding[0];

    if (fillStroke || rotation !== 0) {
      p1[0] = boxX;
      p4[0] = boxX;
      p1[1] = boxY;
      p2[1] = boxY;
      p2[0] = boxX + boxW;
      p3[0] = p2[0];
      p3[1] = boxY + boxH;
      p4[1] = p3[1];
    }

    let transform;
    if (rotation !== 0) {
      transform = (0,_transform_js__WEBPACK_IMPORTED_MODULE_2__.compose)(
        (0,_transform_js__WEBPACK_IMPORTED_MODULE_2__.create)(),
        centerX,
        centerY,
        1,
        1,
        rotation,
        -centerX,
        -centerY
      );

      (0,_transform_js__WEBPACK_IMPORTED_MODULE_2__.apply)(transform, p1);
      (0,_transform_js__WEBPACK_IMPORTED_MODULE_2__.apply)(transform, p2);
      (0,_transform_js__WEBPACK_IMPORTED_MODULE_2__.apply)(transform, p3);
      (0,_transform_js__WEBPACK_IMPORTED_MODULE_2__.apply)(transform, p4);
      (0,_extent_js__WEBPACK_IMPORTED_MODULE_0__.createOrUpdate)(
        Math.min(p1[0], p2[0], p3[0], p4[0]),
        Math.min(p1[1], p2[1], p3[1], p4[1]),
        Math.max(p1[0], p2[0], p3[0], p4[0]),
        Math.max(p1[1], p2[1], p3[1], p4[1]),
        tmpExtent
      );
    } else {
      (0,_extent_js__WEBPACK_IMPORTED_MODULE_0__.createOrUpdate)(
        Math.min(boxX, boxX + boxW),
        Math.min(boxY, boxY + boxH),
        Math.max(boxX, boxX + boxW),
        Math.max(boxY, boxY + boxH),
        tmpExtent
      );
    }
    if (snapToPixel) {
      x = Math.round(x);
      y = Math.round(y);
    }
    return {
      drawImageX: x,
      drawImageY: y,
      drawImageW: w,
      drawImageH: h,
      originX: originX,
      originY: originY,
      declutterBox: {
        minX: tmpExtent[0],
        minY: tmpExtent[1],
        maxX: tmpExtent[2],
        maxY: tmpExtent[3],
        value: feature,
      },
      canvasTransform: transform,
      scale: scale,
    };
  }

  /**
   * @private
   * @param {CanvasRenderingContext2D} context Context.
   * @param {number} contextScale Scale of the context.
   * @param {import("../canvas.js").Label|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} imageOrLabel Image.
   * @param {ImageOrLabelDimensions} dimensions Dimensions.
   * @param {number} opacity Opacity.
   * @param {Array<*>} fillInstruction Fill instruction.
   * @param {Array<*>} strokeInstruction Stroke instruction.
   * @return {boolean} The image or label was rendered.
   */
  replayImageOrLabel_(
    context,
    contextScale,
    imageOrLabel,
    dimensions,
    opacity,
    fillInstruction,
    strokeInstruction
  ) {
    const fillStroke = !!(fillInstruction || strokeInstruction);

    const box = dimensions.declutterBox;
    const canvas = context.canvas;
    const strokePadding = strokeInstruction
      ? (strokeInstruction[2] * dimensions.scale[0]) / 2
      : 0;
    const intersects =
      box.minX - strokePadding <= canvas.width / contextScale &&
      box.maxX + strokePadding >= 0 &&
      box.minY - strokePadding <= canvas.height / contextScale &&
      box.maxY + strokePadding >= 0;

    if (intersects) {
      if (fillStroke) {
        this.replayTextBackground_(
          context,
          p1,
          p2,
          p3,
          p4,
          /** @type {Array<*>} */ (fillInstruction),
          /** @type {Array<*>} */ (strokeInstruction)
        );
      }
      (0,_canvas_js__WEBPACK_IMPORTED_MODULE_3__.drawImageOrLabel)(
        context,
        dimensions.canvasTransform,
        opacity,
        imageOrLabel,
        dimensions.originX,
        dimensions.originY,
        dimensions.drawImageW,
        dimensions.drawImageH,
        dimensions.drawImageX,
        dimensions.drawImageY,
        dimensions.scale
      );
    }
    return true;
  }

  /**
   * @private
   * @param {CanvasRenderingContext2D} context Context.
   */
  fill_(context) {
    if (this.alignFill_) {
      const origin = (0,_transform_js__WEBPACK_IMPORTED_MODULE_2__.apply)(this.renderedTransform_, [0, 0]);
      const repeatSize = 512 * this.pixelRatio;
      context.save();
      context.translate(origin[0] % repeatSize, origin[1] % repeatSize);
      context.rotate(this.viewRotation_);
    }
    context.fill();
    if (this.alignFill_) {
      context.restore();
    }
  }

  /**
   * @private
   * @param {CanvasRenderingContext2D} context Context.
   * @param {Array<*>} instruction Instruction.
   */
  setStrokeStyle_(context, instruction) {
    context['strokeStyle'] =
      /** @type {import("../../colorlike.js").ColorLike} */ (instruction[1]);
    context.lineWidth = /** @type {number} */ (instruction[2]);
    context.lineCap = /** @type {CanvasLineCap} */ (instruction[3]);
    context.lineJoin = /** @type {CanvasLineJoin} */ (instruction[4]);
    context.miterLimit = /** @type {number} */ (instruction[5]);
    context.lineDashOffset = /** @type {number} */ (instruction[7]);
    context.setLineDash(/** @type {Array<number>} */ (instruction[6]));
  }

  /**
   * @private
   * @param {string|Array<string>} text The text to draw.
   * @param {string} textKey The key of the text state.
   * @param {string} strokeKey The key for the stroke state.
   * @param {string} fillKey The key for the fill state.
   * @return {{label: import("../canvas.js").Label, anchorX: number, anchorY: number}} The text image and its anchor.
   */
  drawLabelWithPointPlacement_(text, textKey, strokeKey, fillKey) {
    const textState = this.textStates[textKey];

    const label = this.createLabel(text, textKey, fillKey, strokeKey);

    const strokeState = this.strokeStates[strokeKey];
    const pixelRatio = this.pixelRatio;
    const align = horizontalTextAlign(
      Array.isArray(text) ? text[0] : text,
      textState.textAlign || _canvas_js__WEBPACK_IMPORTED_MODULE_3__.defaultTextAlign
    );
    const baseline = _TextBuilder_js__WEBPACK_IMPORTED_MODULE_1__.TEXT_ALIGN[textState.textBaseline || _canvas_js__WEBPACK_IMPORTED_MODULE_3__.defaultTextBaseline];
    const strokeWidth =
      strokeState && strokeState.lineWidth ? strokeState.lineWidth : 0;

    // Remove the 2 pixels we added in createLabel() for the anchor
    const width = label.width / pixelRatio - 2 * textState.scale[0];
    const anchorX = align * width + 2 * (0.5 - align) * strokeWidth;
    const anchorY =
      (baseline * label.height) / pixelRatio +
      2 * (0.5 - baseline) * strokeWidth;

    return {
      label: label,
      anchorX: anchorX,
      anchorY: anchorY,
    };
  }

  /**
   * @private
   * @param {CanvasRenderingContext2D} context Context.
   * @param {number} contextScale Scale of the context.
   * @param {import("../../transform.js").Transform} transform Transform.
   * @param {Array<*>} instructions Instructions array.
   * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.
   * @param {FeatureCallback<T>} [featureCallback] Feature callback.
   * @param {import("../../extent.js").Extent} [hitExtent] Only check
   *     features that intersect this extent.
   * @param {import("rbush").default} [declutterTree] Declutter tree.
   * @return {T|undefined} Callback result.
   * @template T
   */
  execute_(
    context,
    contextScale,
    transform,
    instructions,
    snapToPixel,
    featureCallback,
    hitExtent,
    declutterTree
  ) {
    /** @type {Array<number>} */
    let pixelCoordinates;
    if (this.pixelCoordinates_ && (0,_array_js__WEBPACK_IMPORTED_MODULE_4__.equals)(transform, this.renderedTransform_)) {
      pixelCoordinates = this.pixelCoordinates_;
    } else {
      if (!this.pixelCoordinates_) {
        this.pixelCoordinates_ = [];
      }
      pixelCoordinates = (0,_geom_flat_transform_js__WEBPACK_IMPORTED_MODULE_5__.transform2D)(
        this.coordinates,
        0,
        this.coordinates.length,
        2,
        transform,
        this.pixelCoordinates_
      );
      (0,_transform_js__WEBPACK_IMPORTED_MODULE_2__.setFromArray)(this.renderedTransform_, transform);
    }
    let i = 0; // instruction index
    const ii = instructions.length; // end of instructions
    let d = 0; // data index
    let dd; // end of per-instruction data
    let anchorX,
      anchorY,
      prevX,
      prevY,
      roundX,
      roundY,
      image,
      text,
      textKey,
      strokeKey,
      fillKey;
    let pendingFill = 0;
    let pendingStroke = 0;
    let lastFillInstruction = null;
    let lastStrokeInstruction = null;
    const coordinateCache = this.coordinateCache_;
    const viewRotation = this.viewRotation_;
    const viewRotationFromTransform =
      Math.round(Math.atan2(-transform[1], transform[0]) * 1e12) / 1e12;

    const state = /** @type {import("../../render.js").State} */ ({
      context: context,
      pixelRatio: this.pixelRatio,
      resolution: this.resolution,
      rotation: viewRotation,
    });

    // When the batch size gets too big, performance decreases. 200 is a good
    // balance between batch size and number of fill/stroke instructions.
    const batchSize =
      this.instructions != instructions || this.overlaps ? 0 : 200;
    let /** @type {import("../../Feature.js").FeatureLike} */ feature;
    let x, y, currentGeometry;
    while (i < ii) {
      const instruction = instructions[i];
      const type = /** @type {import("./Instruction.js").default} */ (
        instruction[0]
      );
      switch (type) {
        case _Instruction_js__WEBPACK_IMPORTED_MODULE_6__["default"].BEGIN_GEOMETRY:
          feature = /** @type {import("../../Feature.js").FeatureLike} */ (
            instruction[1]
          );
          currentGeometry = instruction[3];
          if (!feature.getGeometry()) {
            i = /** @type {number} */ (instruction[2]);
          } else if (
            hitExtent !== undefined &&
            !(0,_extent_js__WEBPACK_IMPORTED_MODULE_0__.intersects)(hitExtent, currentGeometry.getExtent())
          ) {
            i = /** @type {number} */ (instruction[2]) + 1;
          } else {
            ++i;
          }
          break;
        case _Instruction_js__WEBPACK_IMPORTED_MODULE_6__["default"].BEGIN_PATH:
          if (pendingFill > batchSize) {
            this.fill_(context);
            pendingFill = 0;
          }
          if (pendingStroke > batchSize) {
            context.stroke();
            pendingStroke = 0;
          }
          if (!pendingFill && !pendingStroke) {
            context.beginPath();
            prevX = NaN;
            prevY = NaN;
          }
          ++i;
          break;
        case _Instruction_js__WEBPACK_IMPORTED_MODULE_6__["default"].CIRCLE:
          d = /** @type {number} */ (instruction[1]);
          const x1 = pixelCoordinates[d];
          const y1 = pixelCoordinates[d + 1];
          const x2 = pixelCoordinates[d + 2];
          const y2 = pixelCoordinates[d + 3];
          const dx = x2 - x1;
          const dy = y2 - y1;
          const r = Math.sqrt(dx * dx + dy * dy);
          context.moveTo(x1 + r, y1);
          context.arc(x1, y1, r, 0, 2 * Math.PI, true);
          ++i;
          break;
        case _Instruction_js__WEBPACK_IMPORTED_MODULE_6__["default"].CLOSE_PATH:
          context.closePath();
          ++i;
          break;
        case _Instruction_js__WEBPACK_IMPORTED_MODULE_6__["default"].CUSTOM:
          d = /** @type {number} */ (instruction[1]);
          dd = instruction[2];
          const geometry =
            /** @type {import("../../geom/SimpleGeometry.js").default} */ (
              instruction[3]
            );
          const renderer = instruction[4];
          const fn = instruction.length == 6 ? instruction[5] : undefined;
          state.geometry = geometry;
          state.feature = feature;
          if (!(i in coordinateCache)) {
            coordinateCache[i] = [];
          }
          const coords = coordinateCache[i];
          if (fn) {
            fn(pixelCoordinates, d, dd, 2, coords);
          } else {
            coords[0] = pixelCoordinates[d];
            coords[1] = pixelCoordinates[d + 1];
            coords.length = 2;
          }
          renderer(coords, state);
          ++i;
          break;
        case _Instruction_js__WEBPACK_IMPORTED_MODULE_6__["default"].DRAW_IMAGE:
          d = /** @type {number} */ (instruction[1]);
          dd = /** @type {number} */ (instruction[2]);
          image =
            /** @type {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement} */ (
              instruction[3]
            );

          // Remaining arguments in DRAW_IMAGE are in alphabetical order
          anchorX = /** @type {number} */ (instruction[4]);
          anchorY = /** @type {number} */ (instruction[5]);
          let height = /** @type {number} */ (instruction[6]);
          const opacity = /** @type {number} */ (instruction[7]);
          const originX = /** @type {number} */ (instruction[8]);
          const originY = /** @type {number} */ (instruction[9]);
          const rotateWithView = /** @type {boolean} */ (instruction[10]);
          let rotation = /** @type {number} */ (instruction[11]);
          const scale = /** @type {import("../../size.js").Size} */ (
            instruction[12]
          );
          let width = /** @type {number} */ (instruction[13]);
          const declutterMode =
            /** @type {"declutter"|"obstacle"|"none"|undefined} */ (
              instruction[14]
            );
          const declutterImageWithText =
            /** @type {import("../canvas.js").DeclutterImageWithText} */ (
              instruction[15]
            );

          if (!image && instruction.length >= 20) {
            // create label images
            text = /** @type {string} */ (instruction[19]);
            textKey = /** @type {string} */ (instruction[20]);
            strokeKey = /** @type {string} */ (instruction[21]);
            fillKey = /** @type {string} */ (instruction[22]);
            const labelWithAnchor = this.drawLabelWithPointPlacement_(
              text,
              textKey,
              strokeKey,
              fillKey
            );
            image = labelWithAnchor.label;
            instruction[3] = image;
            const textOffsetX = /** @type {number} */ (instruction[23]);
            anchorX = (labelWithAnchor.anchorX - textOffsetX) * this.pixelRatio;
            instruction[4] = anchorX;
            const textOffsetY = /** @type {number} */ (instruction[24]);
            anchorY = (labelWithAnchor.anchorY - textOffsetY) * this.pixelRatio;
            instruction[5] = anchorY;
            height = image.height;
            instruction[6] = height;
            width = image.width;
            instruction[13] = width;
          }

          let geometryWidths;
          if (instruction.length > 25) {
            geometryWidths = /** @type {number} */ (instruction[25]);
          }

          let padding, backgroundFill, backgroundStroke;
          if (instruction.length > 17) {
            padding = /** @type {Array<number>} */ (instruction[16]);
            backgroundFill = /** @type {boolean} */ (instruction[17]);
            backgroundStroke = /** @type {boolean} */ (instruction[18]);
          } else {
            padding = _canvas_js__WEBPACK_IMPORTED_MODULE_3__.defaultPadding;
            backgroundFill = false;
            backgroundStroke = false;
          }

          if (rotateWithView && viewRotationFromTransform) {
            // Canvas is expected to be rotated to reverse view rotation.
            rotation += viewRotation;
          } else if (!rotateWithView && !viewRotationFromTransform) {
            // Canvas is not rotated, images need to be rotated back to be north-up.
            rotation -= viewRotation;
          }
          let widthIndex = 0;
          for (; d < dd; d += 2) {
            if (
              geometryWidths &&
              geometryWidths[widthIndex++] < width / this.pixelRatio
            ) {
              continue;
            }
            const dimensions = this.calculateImageOrLabelDimensions_(
              image.width,
              image.height,
              pixelCoordinates[d],
              pixelCoordinates[d + 1],
              width,
              height,
              anchorX,
              anchorY,
              originX,
              originY,
              rotation,
              scale,
              snapToPixel,
              padding,
              backgroundFill || backgroundStroke,
              feature
            );
            /** @type {ReplayImageOrLabelArgs} */
            const args = [
              context,
              contextScale,
              image,
              dimensions,
              opacity,
              backgroundFill
                ? /** @type {Array<*>} */ (lastFillInstruction)
                : null,
              backgroundStroke
                ? /** @type {Array<*>} */ (lastStrokeInstruction)
                : null,
            ];
            if (declutterTree) {
              if (declutterMode === 'none') {
                // not rendered in declutter group
                continue;
              } else if (declutterMode === 'obstacle') {
                // will always be drawn, thus no collision detection, but insert as obstacle
                declutterTree.insert(dimensions.declutterBox);
                continue;
              } else {
                let imageArgs;
                let imageDeclutterBox;
                if (declutterImageWithText) {
                  const index = dd - d;
                  if (!declutterImageWithText[index]) {
                    // We now have the image for an image+text combination.
                    declutterImageWithText[index] = args;
                    // Don't render anything for now, wait for the text.
                    continue;
                  }
                  imageArgs = declutterImageWithText[index];
                  delete declutterImageWithText[index];
                  imageDeclutterBox = getDeclutterBox(imageArgs);
                  if (declutterTree.collides(imageDeclutterBox)) {
                    continue;
                  }
                }
                if (declutterTree.collides(dimensions.declutterBox)) {
                  continue;
                }
                if (imageArgs) {
                  // We now have image and text for an image+text combination.
                  declutterTree.insert(imageDeclutterBox);
                  // Render the image before we render the text.
                  this.replayImageOrLabel_.apply(this, imageArgs);
                }
                declutterTree.insert(dimensions.declutterBox);
              }
            }
            this.replayImageOrLabel_.apply(this, args);
          }
          ++i;
          break;
        case _Instruction_js__WEBPACK_IMPORTED_MODULE_6__["default"].DRAW_CHARS:
          const begin = /** @type {number} */ (instruction[1]);
          const end = /** @type {number} */ (instruction[2]);
          const baseline = /** @type {number} */ (instruction[3]);
          const overflow = /** @type {number} */ (instruction[4]);
          fillKey = /** @type {string} */ (instruction[5]);
          const maxAngle = /** @type {number} */ (instruction[6]);
          const measurePixelRatio = /** @type {number} */ (instruction[7]);
          const offsetY = /** @type {number} */ (instruction[8]);
          strokeKey = /** @type {string} */ (instruction[9]);
          const strokeWidth = /** @type {number} */ (instruction[10]);
          text = /** @type {string} */ (instruction[11]);
          textKey = /** @type {string} */ (instruction[12]);
          const pixelRatioScale = [
            /** @type {number} */ (instruction[13]),
            /** @type {number} */ (instruction[13]),
          ];

          const textState = this.textStates[textKey];
          const font = textState.font;
          const textScale = [
            textState.scale[0] * measurePixelRatio,
            textState.scale[1] * measurePixelRatio,
          ];

          let cachedWidths;
          if (font in this.widths_) {
            cachedWidths = this.widths_[font];
          } else {
            cachedWidths = {};
            this.widths_[font] = cachedWidths;
          }

          const pathLength = (0,_geom_flat_length_js__WEBPACK_IMPORTED_MODULE_7__.lineStringLength)(pixelCoordinates, begin, end, 2);
          const textLength =
            Math.abs(textScale[0]) *
            (0,_canvas_js__WEBPACK_IMPORTED_MODULE_3__.measureAndCacheTextWidth)(font, text, cachedWidths);
          if (overflow || textLength <= pathLength) {
            const textAlign = this.textStates[textKey].textAlign;
            const startM =
              (pathLength - textLength) * horizontalTextAlign(text, textAlign);
            const parts = (0,_geom_flat_textpath_js__WEBPACK_IMPORTED_MODULE_8__.drawTextOnPath)(
              pixelCoordinates,
              begin,
              end,
              2,
              text,
              startM,
              maxAngle,
              Math.abs(textScale[0]),
              _canvas_js__WEBPACK_IMPORTED_MODULE_3__.measureAndCacheTextWidth,
              font,
              cachedWidths,
              viewRotationFromTransform ? 0 : this.viewRotation_
            );
            drawChars: if (parts) {
              /** @type {Array<ReplayImageOrLabelArgs>} */
              const replayImageOrLabelArgs = [];
              let c, cc, chars, label, part;
              if (strokeKey) {
                for (c = 0, cc = parts.length; c < cc; ++c) {
                  part = parts[c]; // x, y, anchorX, rotation, chunk
                  chars = /** @type {string} */ (part[4]);
                  label = this.createLabel(chars, textKey, '', strokeKey);
                  anchorX =
                    /** @type {number} */ (part[2]) +
                    (textScale[0] < 0 ? -strokeWidth : strokeWidth);
                  anchorY =
                    baseline * label.height +
                    ((0.5 - baseline) * 2 * strokeWidth * textScale[1]) /
                      textScale[0] -
                    offsetY;
                  const dimensions = this.calculateImageOrLabelDimensions_(
                    label.width,
                    label.height,
                    part[0],
                    part[1],
                    label.width,
                    label.height,
                    anchorX,
                    anchorY,
                    0,
                    0,
                    part[3],
                    pixelRatioScale,
                    false,
                    _canvas_js__WEBPACK_IMPORTED_MODULE_3__.defaultPadding,
                    false,
                    feature
                  );
                  if (
                    declutterTree &&
                    declutterTree.collides(dimensions.declutterBox)
                  ) {
                    break drawChars;
                  }
                  replayImageOrLabelArgs.push([
                    context,
                    contextScale,
                    label,
                    dimensions,
                    1,
                    null,
                    null,
                  ]);
                }
              }
              if (fillKey) {
                for (c = 0, cc = parts.length; c < cc; ++c) {
                  part = parts[c]; // x, y, anchorX, rotation, chunk
                  chars = /** @type {string} */ (part[4]);
                  label = this.createLabel(chars, textKey, fillKey, '');
                  anchorX = /** @type {number} */ (part[2]);
                  anchorY = baseline * label.height - offsetY;
                  const dimensions = this.calculateImageOrLabelDimensions_(
                    label.width,
                    label.height,
                    part[0],
                    part[1],
                    label.width,
                    label.height,
                    anchorX,
                    anchorY,
                    0,
                    0,
                    part[3],
                    pixelRatioScale,
                    false,
                    _canvas_js__WEBPACK_IMPORTED_MODULE_3__.defaultPadding,
                    false,
                    feature
                  );
                  if (
                    declutterTree &&
                    declutterTree.collides(dimensions.declutterBox)
                  ) {
                    break drawChars;
                  }
                  replayImageOrLabelArgs.push([
                    context,
                    contextScale,
                    label,
                    dimensions,
                    1,
                    null,
                    null,
                  ]);
                }
              }
              if (declutterTree) {
                declutterTree.load(replayImageOrLabelArgs.map(getDeclutterBox));
              }
              for (let i = 0, ii = replayImageOrLabelArgs.length; i < ii; ++i) {
                this.replayImageOrLabel_.apply(this, replayImageOrLabelArgs[i]);
              }
            }
          }
          ++i;
          break;
        case _Instruction_js__WEBPACK_IMPORTED_MODULE_6__["default"].END_GEOMETRY:
          if (featureCallback !== undefined) {
            feature = /** @type {import("../../Feature.js").FeatureLike} */ (
              instruction[1]
            );
            const result = featureCallback(feature, currentGeometry);
            if (result) {
              return result;
            }
          }
          ++i;
          break;
        case _Instruction_js__WEBPACK_IMPORTED_MODULE_6__["default"].FILL:
          if (batchSize) {
            pendingFill++;
          } else {
            this.fill_(context);
          }
          ++i;
          break;
        case _Instruction_js__WEBPACK_IMPORTED_MODULE_6__["default"].MOVE_TO_LINE_TO:
          d = /** @type {number} */ (instruction[1]);
          dd = /** @type {number} */ (instruction[2]);
          x = pixelCoordinates[d];
          y = pixelCoordinates[d + 1];
          roundX = (x + 0.5) | 0;
          roundY = (y + 0.5) | 0;
          if (roundX !== prevX || roundY !== prevY) {
            context.moveTo(x, y);
            prevX = roundX;
            prevY = roundY;
          }
          for (d += 2; d < dd; d += 2) {
            x = pixelCoordinates[d];
            y = pixelCoordinates[d + 1];
            roundX = (x + 0.5) | 0;
            roundY = (y + 0.5) | 0;
            if (d == dd - 2 || roundX !== prevX || roundY !== prevY) {
              context.lineTo(x, y);
              prevX = roundX;
              prevY = roundY;
            }
          }
          ++i;
          break;
        case _Instruction_js__WEBPACK_IMPORTED_MODULE_6__["default"].SET_FILL_STYLE:
          lastFillInstruction = instruction;
          this.alignFill_ = instruction[2];

          if (pendingFill) {
            this.fill_(context);
            pendingFill = 0;
            if (pendingStroke) {
              context.stroke();
              pendingStroke = 0;
            }
          }

          context.fillStyle =
            /** @type {import("../../colorlike.js").ColorLike} */ (
              instruction[1]
            );
          ++i;
          break;
        case _Instruction_js__WEBPACK_IMPORTED_MODULE_6__["default"].SET_STROKE_STYLE:
          lastStrokeInstruction = instruction;
          if (pendingStroke) {
            context.stroke();
            pendingStroke = 0;
          }
          this.setStrokeStyle_(context, /** @type {Array<*>} */ (instruction));
          ++i;
          break;
        case _Instruction_js__WEBPACK_IMPORTED_MODULE_6__["default"].STROKE:
          if (batchSize) {
            pendingStroke++;
          } else {
            context.stroke();
          }
          ++i;
          break;
        default: // consume the instruction anyway, to avoid an infinite loop
          ++i;
          break;
      }
    }
    if (pendingFill) {
      this.fill_(context);
    }
    if (pendingStroke) {
      context.stroke();
    }
    return undefined;
  }

  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {number} contextScale Scale of the context.
   * @param {import("../../transform.js").Transform} transform Transform.
   * @param {number} viewRotation View rotation.
   * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.
   * @param {import("rbush").default} [declutterTree] Declutter tree.
   */
  execute(
    context,
    contextScale,
    transform,
    viewRotation,
    snapToPixel,
    declutterTree
  ) {
    this.viewRotation_ = viewRotation;
    this.execute_(
      context,
      contextScale,
      transform,
      this.instructions,
      snapToPixel,
      undefined,
      undefined,
      declutterTree
    );
  }

  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../transform.js").Transform} transform Transform.
   * @param {number} viewRotation View rotation.
   * @param {FeatureCallback<T>} [featureCallback] Feature callback.
   * @param {import("../../extent.js").Extent} [hitExtent] Only check
   *     features that intersect this extent.
   * @return {T|undefined} Callback result.
   * @template T
   */
  executeHitDetection(
    context,
    transform,
    viewRotation,
    featureCallback,
    hitExtent
  ) {
    this.viewRotation_ = viewRotation;
    return this.execute_(
      context,
      1,
      transform,
      this.hitDetectionInstructions,
      true,
      featureCallback,
      hitExtent
    );
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Executor);


/***/ }),

/***/ "./node_modules/ol/render/canvas/ExecutorGroup.js":
/*!********************************************************!*\
  !*** ./node_modules/ol/render/canvas/ExecutorGroup.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   getPixelIndexArray: () => (/* binding */ getPixelIndexArray)
/* harmony export */ });
/* harmony import */ var _Executor_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Executor.js */ "./node_modules/ol/render/canvas/Executor.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../transform.js */ "./node_modules/ol/transform.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../dom.js */ "./node_modules/ol/dom.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../obj.js */ "./node_modules/ol/obj.js");
/* harmony import */ var _geom_flat_transform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../geom/flat/transform.js */ "./node_modules/ol/geom/flat/transform.js");
/**
 * @module ol/render/canvas/ExecutorGroup
 */









/**
 * @const
 * @type {Array<import("../canvas.js").BuilderType>}
 */
const ORDER = ['Polygon', 'Circle', 'LineString', 'Image', 'Text', 'Default'];

class ExecutorGroup {
  /**
   * @param {import("../../extent.js").Extent} maxExtent Max extent for clipping. When a
   * `maxExtent` was set on the Builder for this executor group, the same `maxExtent`
   * should be set here, unless the target context does not exceed that extent (which
   * can be the case when rendering to tiles).
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {boolean} overlaps The executor group can have overlapping geometries.
   * @param {!Object<string, !Object<import("../canvas.js").BuilderType, import("../canvas.js").SerializableInstructions>>} allInstructions
   * The serializable instructions.
   * @param {number} [renderBuffer] Optional rendering buffer.
   */
  constructor(
    maxExtent,
    resolution,
    pixelRatio,
    overlaps,
    allInstructions,
    renderBuffer
  ) {
    /**
     * @private
     * @type {import("../../extent.js").Extent}
     */
    this.maxExtent_ = maxExtent;

    /**
     * @private
     * @type {boolean}
     */
    this.overlaps_ = overlaps;

    /**
     * @private
     * @type {number}
     */
    this.pixelRatio_ = pixelRatio;

    /**
     * @private
     * @type {number}
     */
    this.resolution_ = resolution;

    /**
     * @private
     * @type {number|undefined}
     */
    this.renderBuffer_ = renderBuffer;

    /**
     * @private
     * @type {!Object<string, !Object<import("../canvas.js").BuilderType, import("./Executor").default>>}
     */
    this.executorsByZIndex_ = {};

    /**
     * @private
     * @type {CanvasRenderingContext2D}
     */
    this.hitDetectionContext_ = null;

    /**
     * @private
     * @type {import("../../transform.js").Transform}
     */
    this.hitDetectionTransform_ = (0,_transform_js__WEBPACK_IMPORTED_MODULE_0__.create)();

    this.createExecutors_(allInstructions);
  }

  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../transform.js").Transform} transform Transform.
   */
  clip(context, transform) {
    const flatClipCoords = this.getClipCoords(transform);
    context.beginPath();
    context.moveTo(flatClipCoords[0], flatClipCoords[1]);
    context.lineTo(flatClipCoords[2], flatClipCoords[3]);
    context.lineTo(flatClipCoords[4], flatClipCoords[5]);
    context.lineTo(flatClipCoords[6], flatClipCoords[7]);
    context.clip();
  }

  /**
   * Create executors and populate them using the provided instructions.
   * @private
   * @param {!Object<string, !Object<import("../canvas.js").BuilderType, import("../canvas.js").SerializableInstructions>>} allInstructions The serializable instructions
   */
  createExecutors_(allInstructions) {
    for (const zIndex in allInstructions) {
      let executors = this.executorsByZIndex_[zIndex];
      if (executors === undefined) {
        executors = {};
        this.executorsByZIndex_[zIndex] = executors;
      }
      const instructionByZindex = allInstructions[zIndex];
      for (const builderType in instructionByZindex) {
        const instructions = instructionByZindex[builderType];
        executors[builderType] = new _Executor_js__WEBPACK_IMPORTED_MODULE_1__["default"](
          this.resolution_,
          this.pixelRatio_,
          this.overlaps_,
          instructions
        );
      }
    }
  }

  /**
   * @param {Array<import("../canvas.js").BuilderType>} executors Executors.
   * @return {boolean} Has executors of the provided types.
   */
  hasExecutors(executors) {
    for (const zIndex in this.executorsByZIndex_) {
      const candidates = this.executorsByZIndex_[zIndex];
      for (let i = 0, ii = executors.length; i < ii; ++i) {
        if (executors[i] in candidates) {
          return true;
        }
      }
    }
    return false;
  }

  /**
   * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {number} resolution Resolution.
   * @param {number} rotation Rotation.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {function(import("../../Feature.js").FeatureLike, import("../../geom/SimpleGeometry.js").default, number): T} callback Feature callback.
   * @param {Array<import("../../Feature.js").FeatureLike>} declutteredFeatures Decluttered features.
   * @return {T|undefined} Callback result.
   * @template T
   */
  forEachFeatureAtCoordinate(
    coordinate,
    resolution,
    rotation,
    hitTolerance,
    callback,
    declutteredFeatures
  ) {
    hitTolerance = Math.round(hitTolerance);
    const contextSize = hitTolerance * 2 + 1;
    const transform = (0,_transform_js__WEBPACK_IMPORTED_MODULE_0__.compose)(
      this.hitDetectionTransform_,
      hitTolerance + 0.5,
      hitTolerance + 0.5,
      1 / resolution,
      -1 / resolution,
      -rotation,
      -coordinate[0],
      -coordinate[1]
    );

    const newContext = !this.hitDetectionContext_;
    if (newContext) {
      this.hitDetectionContext_ = (0,_dom_js__WEBPACK_IMPORTED_MODULE_2__.createCanvasContext2D)(
        contextSize,
        contextSize,
        undefined,
        {willReadFrequently: true}
      );
    }
    const context = this.hitDetectionContext_;

    if (
      context.canvas.width !== contextSize ||
      context.canvas.height !== contextSize
    ) {
      context.canvas.width = contextSize;
      context.canvas.height = contextSize;
    } else if (!newContext) {
      context.clearRect(0, 0, contextSize, contextSize);
    }

    /**
     * @type {import("../../extent.js").Extent}
     */
    let hitExtent;
    if (this.renderBuffer_ !== undefined) {
      hitExtent = (0,_extent_js__WEBPACK_IMPORTED_MODULE_3__.createEmpty)();
      (0,_extent_js__WEBPACK_IMPORTED_MODULE_3__.extendCoordinate)(hitExtent, coordinate);
      (0,_extent_js__WEBPACK_IMPORTED_MODULE_3__.buffer)(
        hitExtent,
        resolution * (this.renderBuffer_ + hitTolerance),
        hitExtent
      );
    }

    const indexes = getPixelIndexArray(hitTolerance);

    let builderType;

    /**
     * @param {import("../../Feature.js").FeatureLike} feature Feature.
     * @param {import("../../geom/SimpleGeometry.js").default} geometry Geometry.
     * @return {T|undefined} Callback result.
     */
    function featureCallback(feature, geometry) {
      const imageData = context.getImageData(
        0,
        0,
        contextSize,
        contextSize
      ).data;
      for (let i = 0, ii = indexes.length; i < ii; i++) {
        if (imageData[indexes[i]] > 0) {
          if (
            !declutteredFeatures ||
            (builderType !== 'Image' && builderType !== 'Text') ||
            declutteredFeatures.includes(feature)
          ) {
            const idx = (indexes[i] - 3) / 4;
            const x = hitTolerance - (idx % contextSize);
            const y = hitTolerance - ((idx / contextSize) | 0);
            const result = callback(feature, geometry, x * x + y * y);
            if (result) {
              return result;
            }
          }
          context.clearRect(0, 0, contextSize, contextSize);
          break;
        }
      }
      return undefined;
    }

    /** @type {Array<number>} */
    const zs = Object.keys(this.executorsByZIndex_).map(Number);
    zs.sort(_array_js__WEBPACK_IMPORTED_MODULE_4__.ascending);

    let i, j, executors, executor, result;
    for (i = zs.length - 1; i >= 0; --i) {
      const zIndexKey = zs[i].toString();
      executors = this.executorsByZIndex_[zIndexKey];
      for (j = ORDER.length - 1; j >= 0; --j) {
        builderType = ORDER[j];
        executor = executors[builderType];
        if (executor !== undefined) {
          result = executor.executeHitDetection(
            context,
            transform,
            rotation,
            featureCallback,
            hitExtent
          );
          if (result) {
            return result;
          }
        }
      }
    }
    return undefined;
  }

  /**
   * @param {import("../../transform.js").Transform} transform Transform.
   * @return {Array<number>|null} Clip coordinates.
   */
  getClipCoords(transform) {
    const maxExtent = this.maxExtent_;
    if (!maxExtent) {
      return null;
    }
    const minX = maxExtent[0];
    const minY = maxExtent[1];
    const maxX = maxExtent[2];
    const maxY = maxExtent[3];
    const flatClipCoords = [minX, minY, minX, maxY, maxX, maxY, maxX, minY];
    (0,_geom_flat_transform_js__WEBPACK_IMPORTED_MODULE_5__.transform2D)(flatClipCoords, 0, 8, 2, transform, flatClipCoords);
    return flatClipCoords;
  }

  /**
   * @return {boolean} Is empty.
   */
  isEmpty() {
    return (0,_obj_js__WEBPACK_IMPORTED_MODULE_6__.isEmpty)(this.executorsByZIndex_);
  }

  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {number} contextScale Scale of the context.
   * @param {import("../../transform.js").Transform} transform Transform.
   * @param {number} viewRotation View rotation.
   * @param {boolean} snapToPixel Snap point symbols and test to integer pixel.
   * @param {Array<import("../canvas.js").BuilderType>} [builderTypes] Ordered replay types to replay.
   *     Default is {@link module:ol/render/replay~ORDER}
   * @param {import("rbush").default} [declutterTree] Declutter tree.
   */
  execute(
    context,
    contextScale,
    transform,
    viewRotation,
    snapToPixel,
    builderTypes,
    declutterTree
  ) {
    /** @type {Array<number>} */
    const zs = Object.keys(this.executorsByZIndex_).map(Number);
    zs.sort(_array_js__WEBPACK_IMPORTED_MODULE_4__.ascending);

    // setup clipping so that the parts of over-simplified geometries are not
    // visible outside the current extent when panning
    if (this.maxExtent_) {
      context.save();
      this.clip(context, transform);
    }

    builderTypes = builderTypes ? builderTypes : ORDER;
    let i, ii, j, jj, replays, replay;
    if (declutterTree) {
      zs.reverse();
    }
    for (i = 0, ii = zs.length; i < ii; ++i) {
      const zIndexKey = zs[i].toString();
      replays = this.executorsByZIndex_[zIndexKey];
      for (j = 0, jj = builderTypes.length; j < jj; ++j) {
        const builderType = builderTypes[j];
        replay = replays[builderType];
        if (replay !== undefined) {
          replay.execute(
            context,
            contextScale,
            transform,
            viewRotation,
            snapToPixel,
            declutterTree
          );
        }
      }
    }

    if (this.maxExtent_) {
      context.restore();
    }
  }
}

/**
 * This cache is used to store arrays of indexes for calculated pixel circles
 * to increase performance.
 * It is a static property to allow each Replaygroup to access it.
 * @type {Object<number, Array<number>>}
 */
const circlePixelIndexArrayCache = {};

/**
 * This methods creates an array with indexes of all pixels within a circle,
 * ordered by how close they are to the center.
 * A cache is used to increase performance.
 * @param {number} radius Radius.
 * @return {Array<number>} An array with indexes within a circle.
 */
function getPixelIndexArray(radius) {
  if (circlePixelIndexArrayCache[radius] !== undefined) {
    return circlePixelIndexArrayCache[radius];
  }

  const size = radius * 2 + 1;
  const maxDistanceSq = radius * radius;
  const distances = new Array(maxDistanceSq + 1);
  for (let i = 0; i <= radius; ++i) {
    for (let j = 0; j <= radius; ++j) {
      const distanceSq = i * i + j * j;
      if (distanceSq > maxDistanceSq) {
        break;
      }
      let distance = distances[distanceSq];
      if (!distance) {
        distance = [];
        distances[distanceSq] = distance;
      }
      distance.push(((radius + i) * size + (radius + j)) * 4 + 3);
      if (i > 0) {
        distance.push(((radius - i) * size + (radius + j)) * 4 + 3);
      }
      if (j > 0) {
        distance.push(((radius + i) * size + (radius - j)) * 4 + 3);
        if (i > 0) {
          distance.push(((radius - i) * size + (radius - j)) * 4 + 3);
        }
      }
    }
  }

  const pixelIndex = [];
  for (let i = 0, ii = distances.length; i < ii; ++i) {
    if (distances[i]) {
      pixelIndex.push(...distances[i]);
    }
  }

  circlePixelIndexArrayCache[radius] = pixelIndex;
  return pixelIndex;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ExecutorGroup);


/***/ }),

/***/ "./node_modules/ol/render/canvas/ImageBuilder.js":
/*!*******************************************************!*\
  !*** ./node_modules/ol/render/canvas/ImageBuilder.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Builder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Builder.js */ "./node_modules/ol/render/canvas/Builder.js");
/* harmony import */ var _Instruction_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Instruction.js */ "./node_modules/ol/render/canvas/Instruction.js");
/**
 * @module ol/render/canvas/ImageBuilder
 */



class CanvasImageBuilder extends _Builder_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */
  constructor(tolerance, maxExtent, resolution, pixelRatio) {
    super(tolerance, maxExtent, resolution, pixelRatio);

    /**
     * @private
     * @type {import('../../DataTile.js').ImageLike}
     */
    this.hitDetectionImage_ = null;

    /**
     * @private
     * @type {import('../../DataTile.js').ImageLike}
     */
    this.image_ = null;

    /**
     * @private
     * @type {number|undefined}
     */
    this.imagePixelRatio_ = undefined;

    /**
     * @private
     * @type {number|undefined}
     */
    this.anchorX_ = undefined;

    /**
     * @private
     * @type {number|undefined}
     */
    this.anchorY_ = undefined;

    /**
     * @private
     * @type {number|undefined}
     */
    this.height_ = undefined;

    /**
     * @private
     * @type {number|undefined}
     */
    this.opacity_ = undefined;

    /**
     * @private
     * @type {number|undefined}
     */
    this.originX_ = undefined;

    /**
     * @private
     * @type {number|undefined}
     */
    this.originY_ = undefined;

    /**
     * @private
     * @type {boolean|undefined}
     */
    this.rotateWithView_ = undefined;

    /**
     * @private
     * @type {number|undefined}
     */
    this.rotation_ = undefined;

    /**
     * @private
     * @type {import("../../size.js").Size|undefined}
     */
    this.scale_ = undefined;

    /**
     * @private
     * @type {number|undefined}
     */
    this.width_ = undefined;

    /**
     * @private
     * @type {"declutter"|"obstacle"|"none"|undefined}
     */
    this.declutterMode_ = undefined;

    /**
     * Data shared with a text builder for combined decluttering.
     * @private
     * @type {import("../canvas.js").DeclutterImageWithText}
     */
    this.declutterImageWithText_ = undefined;
  }

  /**
   * @param {import("../../geom/Point.js").default|import("../Feature.js").default} pointGeometry Point geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   */
  drawPoint(pointGeometry, feature) {
    if (!this.image_) {
      return;
    }
    this.beginGeometry(pointGeometry, feature);
    const flatCoordinates = pointGeometry.getFlatCoordinates();
    const stride = pointGeometry.getStride();
    const myBegin = this.coordinates.length;
    const myEnd = this.appendFlatPointCoordinates(flatCoordinates, stride);
    this.instructions.push([
      _Instruction_js__WEBPACK_IMPORTED_MODULE_1__["default"].DRAW_IMAGE,
      myBegin,
      myEnd,
      this.image_,
      // Remaining arguments to DRAW_IMAGE are in alphabetical order
      this.anchorX_ * this.imagePixelRatio_,
      this.anchorY_ * this.imagePixelRatio_,
      Math.ceil(this.height_ * this.imagePixelRatio_),
      this.opacity_,
      this.originX_ * this.imagePixelRatio_,
      this.originY_ * this.imagePixelRatio_,
      this.rotateWithView_,
      this.rotation_,
      [
        (this.scale_[0] * this.pixelRatio) / this.imagePixelRatio_,
        (this.scale_[1] * this.pixelRatio) / this.imagePixelRatio_,
      ],
      Math.ceil(this.width_ * this.imagePixelRatio_),
      this.declutterMode_,
      this.declutterImageWithText_,
    ]);
    this.hitDetectionInstructions.push([
      _Instruction_js__WEBPACK_IMPORTED_MODULE_1__["default"].DRAW_IMAGE,
      myBegin,
      myEnd,
      this.hitDetectionImage_,
      // Remaining arguments to DRAW_IMAGE are in alphabetical order
      this.anchorX_,
      this.anchorY_,
      this.height_,
      1,
      this.originX_,
      this.originY_,
      this.rotateWithView_,
      this.rotation_,
      this.scale_,
      this.width_,
      this.declutterMode_,
      this.declutterImageWithText_,
    ]);
    this.endGeometry(feature);
  }

  /**
   * @param {import("../../geom/MultiPoint.js").default|import("../Feature.js").default} multiPointGeometry MultiPoint geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   */
  drawMultiPoint(multiPointGeometry, feature) {
    if (!this.image_) {
      return;
    }
    this.beginGeometry(multiPointGeometry, feature);
    const flatCoordinates = multiPointGeometry.getFlatCoordinates();
    const stride = multiPointGeometry.getStride();
    const myBegin = this.coordinates.length;
    const myEnd = this.appendFlatPointCoordinates(flatCoordinates, stride);
    this.instructions.push([
      _Instruction_js__WEBPACK_IMPORTED_MODULE_1__["default"].DRAW_IMAGE,
      myBegin,
      myEnd,
      this.image_,
      // Remaining arguments to DRAW_IMAGE are in alphabetical order
      this.anchorX_ * this.imagePixelRatio_,
      this.anchorY_ * this.imagePixelRatio_,
      Math.ceil(this.height_ * this.imagePixelRatio_),
      this.opacity_,
      this.originX_ * this.imagePixelRatio_,
      this.originY_ * this.imagePixelRatio_,
      this.rotateWithView_,
      this.rotation_,
      [
        (this.scale_[0] * this.pixelRatio) / this.imagePixelRatio_,
        (this.scale_[1] * this.pixelRatio) / this.imagePixelRatio_,
      ],
      Math.ceil(this.width_ * this.imagePixelRatio_),
      this.declutterMode_,
      this.declutterImageWithText_,
    ]);
    this.hitDetectionInstructions.push([
      _Instruction_js__WEBPACK_IMPORTED_MODULE_1__["default"].DRAW_IMAGE,
      myBegin,
      myEnd,
      this.hitDetectionImage_,
      // Remaining arguments to DRAW_IMAGE are in alphabetical order
      this.anchorX_,
      this.anchorY_,
      this.height_,
      1,
      this.originX_,
      this.originY_,
      this.rotateWithView_,
      this.rotation_,
      this.scale_,
      this.width_,
      this.declutterMode_,
      this.declutterImageWithText_,
    ]);
    this.endGeometry(feature);
  }

  /**
   * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
   */
  finish() {
    this.reverseHitDetectionInstructions();
    // FIXME this doesn't really protect us against further calls to draw*Geometry
    this.anchorX_ = undefined;
    this.anchorY_ = undefined;
    this.hitDetectionImage_ = null;
    this.image_ = null;
    this.imagePixelRatio_ = undefined;
    this.height_ = undefined;
    this.scale_ = undefined;
    this.opacity_ = undefined;
    this.originX_ = undefined;
    this.originY_ = undefined;
    this.rotateWithView_ = undefined;
    this.rotation_ = undefined;
    this.width_ = undefined;
    return super.finish();
  }

  /**
   * @param {import("../../style/Image.js").default} imageStyle Image style.
   * @param {Object} [sharedData] Shared data.
   */
  setImageStyle(imageStyle, sharedData) {
    const anchor = imageStyle.getAnchor();
    const size = imageStyle.getSize();
    const origin = imageStyle.getOrigin();
    this.imagePixelRatio_ = imageStyle.getPixelRatio(this.pixelRatio);
    this.anchorX_ = anchor[0];
    this.anchorY_ = anchor[1];
    this.hitDetectionImage_ = imageStyle.getHitDetectionImage();
    this.image_ = imageStyle.getImage(this.pixelRatio);
    this.height_ = size[1];
    this.opacity_ = imageStyle.getOpacity();
    this.originX_ = origin[0];
    this.originY_ = origin[1];
    this.rotateWithView_ = imageStyle.getRotateWithView();
    this.rotation_ = imageStyle.getRotation();
    this.scale_ = imageStyle.getScaleArray();
    this.width_ = size[0];
    this.declutterMode_ = imageStyle.getDeclutterMode();
    this.declutterImageWithText_ = sharedData;
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CanvasImageBuilder);


/***/ }),

/***/ "./node_modules/ol/render/canvas/Immediate.js":
/*!****************************************************!*\
  !*** ./node_modules/ol/render/canvas/Immediate.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _VectorContext_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../VectorContext.js */ "./node_modules/ol/render/VectorContext.js");
/* harmony import */ var _colorlike_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../colorlike.js */ "./node_modules/ol/colorlike.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../transform.js */ "./node_modules/ol/transform.js");
/* harmony import */ var _canvas_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../canvas.js */ "./node_modules/ol/render/canvas.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../math.js */ "./node_modules/ol/math.js");
/* harmony import */ var _geom_flat_transform_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../geom/flat/transform.js */ "./node_modules/ol/geom/flat/transform.js");
/* harmony import */ var _geom_SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../geom/SimpleGeometry.js */ "./node_modules/ol/geom/SimpleGeometry.js");
/**
 * @module ol/render/canvas/Immediate
 */
// FIXME test, especially polygons with holes and multipolygons
// FIXME need to handle large thick features (where pixel size matters)
// FIXME add offset and end to ol/geom/flat/transform~transform2D?











/**
 * @classdesc
 * A concrete subclass of {@link module:ol/render/VectorContext~VectorContext} that implements
 * direct rendering of features and geometries to an HTML5 Canvas context.
 * Instances of this class are created internally by the library and
 * provided to application code as vectorContext member of the
 * {@link module:ol/render/Event~RenderEvent} object associated with postcompose, precompose and
 * render events emitted by layers and maps.
 */
class CanvasImmediateRenderer extends _VectorContext_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../../extent.js").Extent} extent Extent.
   * @param {import("../../transform.js").Transform} transform Transform.
   * @param {number} viewRotation View rotation.
   * @param {number} [squaredTolerance] Optional squared tolerance for simplification.
   * @param {import("../../proj.js").TransformFunction} [userTransform] Transform from user to view projection.
   */
  constructor(
    context,
    pixelRatio,
    extent,
    transform,
    viewRotation,
    squaredTolerance,
    userTransform
  ) {
    super();

    /**
     * @private
     * @type {CanvasRenderingContext2D}
     */
    this.context_ = context;

    /**
     * @private
     * @type {number}
     */
    this.pixelRatio_ = pixelRatio;

    /**
     * @private
     * @type {import("../../extent.js").Extent}
     */
    this.extent_ = extent;

    /**
     * @private
     * @type {import("../../transform.js").Transform}
     */
    this.transform_ = transform;

    /**
     * @private
     * @type {number}
     */
    this.transformRotation_ = transform
      ? (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.toFixed)(Math.atan2(transform[1], transform[0]), 10)
      : 0;

    /**
     * @private
     * @type {number}
     */
    this.viewRotation_ = viewRotation;

    /**
     * @private
     * @type {number}
     */
    this.squaredTolerance_ = squaredTolerance;

    /**
     * @private
     * @type {import("../../proj.js").TransformFunction}
     */
    this.userTransform_ = userTransform;

    /**
     * @private
     * @type {?import("../canvas.js").FillState}
     */
    this.contextFillState_ = null;

    /**
     * @private
     * @type {?import("../canvas.js").StrokeState}
     */
    this.contextStrokeState_ = null;

    /**
     * @private
     * @type {?import("../canvas.js").TextState}
     */
    this.contextTextState_ = null;

    /**
     * @private
     * @type {?import("../canvas.js").FillState}
     */
    this.fillState_ = null;

    /**
     * @private
     * @type {?import("../canvas.js").StrokeState}
     */
    this.strokeState_ = null;

    /**
     * @private
     * @type {import('../../DataTile.js').ImageLike}
     */
    this.image_ = null;

    /**
     * @private
     * @type {number}
     */
    this.imageAnchorX_ = 0;

    /**
     * @private
     * @type {number}
     */
    this.imageAnchorY_ = 0;

    /**
     * @private
     * @type {number}
     */
    this.imageHeight_ = 0;

    /**
     * @private
     * @type {number}
     */
    this.imageOpacity_ = 0;

    /**
     * @private
     * @type {number}
     */
    this.imageOriginX_ = 0;

    /**
     * @private
     * @type {number}
     */
    this.imageOriginY_ = 0;

    /**
     * @private
     * @type {boolean}
     */
    this.imageRotateWithView_ = false;

    /**
     * @private
     * @type {number}
     */
    this.imageRotation_ = 0;

    /**
     * @private
     * @type {import("../../size.js").Size}
     */
    this.imageScale_ = [0, 0];

    /**
     * @private
     * @type {number}
     */
    this.imageWidth_ = 0;

    /**
     * @private
     * @type {string}
     */
    this.text_ = '';

    /**
     * @private
     * @type {number}
     */
    this.textOffsetX_ = 0;

    /**
     * @private
     * @type {number}
     */
    this.textOffsetY_ = 0;

    /**
     * @private
     * @type {boolean}
     */
    this.textRotateWithView_ = false;

    /**
     * @private
     * @type {number}
     */
    this.textRotation_ = 0;

    /**
     * @private
     * @type {import("../../size.js").Size}
     */
    this.textScale_ = [0, 0];

    /**
     * @private
     * @type {?import("../canvas.js").FillState}
     */
    this.textFillState_ = null;

    /**
     * @private
     * @type {?import("../canvas.js").StrokeState}
     */
    this.textStrokeState_ = null;

    /**
     * @private
     * @type {?import("../canvas.js").TextState}
     */
    this.textState_ = null;

    /**
     * @private
     * @type {Array<number>}
     */
    this.pixelCoordinates_ = [];

    /**
     * @private
     * @type {import("../../transform.js").Transform}
     */
    this.tmpLocalTransform_ = (0,_transform_js__WEBPACK_IMPORTED_MODULE_2__.create)();
  }

  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @private
   */
  drawImages_(flatCoordinates, offset, end, stride) {
    if (!this.image_) {
      return;
    }
    const pixelCoordinates = (0,_geom_flat_transform_js__WEBPACK_IMPORTED_MODULE_3__.transform2D)(
      flatCoordinates,
      offset,
      end,
      stride,
      this.transform_,
      this.pixelCoordinates_
    );
    const context = this.context_;
    const localTransform = this.tmpLocalTransform_;
    const alpha = context.globalAlpha;
    if (this.imageOpacity_ != 1) {
      context.globalAlpha = alpha * this.imageOpacity_;
    }
    let rotation = this.imageRotation_;
    if (this.transformRotation_ === 0) {
      rotation -= this.viewRotation_;
    }
    if (this.imageRotateWithView_) {
      rotation += this.viewRotation_;
    }
    for (let i = 0, ii = pixelCoordinates.length; i < ii; i += 2) {
      const x = pixelCoordinates[i] - this.imageAnchorX_;
      const y = pixelCoordinates[i + 1] - this.imageAnchorY_;
      if (
        rotation !== 0 ||
        this.imageScale_[0] != 1 ||
        this.imageScale_[1] != 1
      ) {
        const centerX = x + this.imageAnchorX_;
        const centerY = y + this.imageAnchorY_;
        (0,_transform_js__WEBPACK_IMPORTED_MODULE_2__.compose)(
          localTransform,
          centerX,
          centerY,
          1,
          1,
          rotation,
          -centerX,
          -centerY
        );
        context.save();
        context.transform.apply(context, localTransform);
        context.translate(centerX, centerY);
        context.scale(this.imageScale_[0], this.imageScale_[1]);
        context.drawImage(
          this.image_,
          this.imageOriginX_,
          this.imageOriginY_,
          this.imageWidth_,
          this.imageHeight_,
          -this.imageAnchorX_,
          -this.imageAnchorY_,
          this.imageWidth_,
          this.imageHeight_
        );
        context.restore();
      } else {
        context.drawImage(
          this.image_,
          this.imageOriginX_,
          this.imageOriginY_,
          this.imageWidth_,
          this.imageHeight_,
          x,
          y,
          this.imageWidth_,
          this.imageHeight_
        );
      }
    }
    if (this.imageOpacity_ != 1) {
      context.globalAlpha = alpha;
    }
  }

  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @private
   */
  drawText_(flatCoordinates, offset, end, stride) {
    if (!this.textState_ || this.text_ === '') {
      return;
    }
    if (this.textFillState_) {
      this.setContextFillState_(this.textFillState_);
    }
    if (this.textStrokeState_) {
      this.setContextStrokeState_(this.textStrokeState_);
    }
    this.setContextTextState_(this.textState_);
    const pixelCoordinates = (0,_geom_flat_transform_js__WEBPACK_IMPORTED_MODULE_3__.transform2D)(
      flatCoordinates,
      offset,
      end,
      stride,
      this.transform_,
      this.pixelCoordinates_
    );
    const context = this.context_;
    let rotation = this.textRotation_;
    if (this.transformRotation_ === 0) {
      rotation -= this.viewRotation_;
    }
    if (this.textRotateWithView_) {
      rotation += this.viewRotation_;
    }
    for (; offset < end; offset += stride) {
      const x = pixelCoordinates[offset] + this.textOffsetX_;
      const y = pixelCoordinates[offset + 1] + this.textOffsetY_;
      if (
        rotation !== 0 ||
        this.textScale_[0] != 1 ||
        this.textScale_[1] != 1
      ) {
        context.save();
        context.translate(x - this.textOffsetX_, y - this.textOffsetY_);
        context.rotate(rotation);
        context.translate(this.textOffsetX_, this.textOffsetY_);
        context.scale(this.textScale_[0], this.textScale_[1]);
        if (this.textStrokeState_) {
          context.strokeText(this.text_, 0, 0);
        }
        if (this.textFillState_) {
          context.fillText(this.text_, 0, 0);
        }
        context.restore();
      } else {
        if (this.textStrokeState_) {
          context.strokeText(this.text_, x, y);
        }
        if (this.textFillState_) {
          context.fillText(this.text_, x, y);
        }
      }
    }
  }

  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @param {boolean} close Close.
   * @private
   * @return {number} end End.
   */
  moveToLineTo_(flatCoordinates, offset, end, stride, close) {
    const context = this.context_;
    const pixelCoordinates = (0,_geom_flat_transform_js__WEBPACK_IMPORTED_MODULE_3__.transform2D)(
      flatCoordinates,
      offset,
      end,
      stride,
      this.transform_,
      this.pixelCoordinates_
    );
    context.moveTo(pixelCoordinates[0], pixelCoordinates[1]);
    let length = pixelCoordinates.length;
    if (close) {
      length -= 2;
    }
    for (let i = 2; i < length; i += 2) {
      context.lineTo(pixelCoordinates[i], pixelCoordinates[i + 1]);
    }
    if (close) {
      context.closePath();
    }
    return end;
  }

  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<number>} ends Ends.
   * @param {number} stride Stride.
   * @private
   * @return {number} End.
   */
  drawRings_(flatCoordinates, offset, ends, stride) {
    for (let i = 0, ii = ends.length; i < ii; ++i) {
      offset = this.moveToLineTo_(
        flatCoordinates,
        offset,
        ends[i],
        stride,
        true
      );
    }
    return offset;
  }

  /**
   * Render a circle geometry into the canvas.  Rendering is immediate and uses
   * the current fill and stroke styles.
   *
   * @param {import("../../geom/Circle.js").default} geometry Circle geometry.
   * @api
   */
  drawCircle(geometry) {
    if (this.squaredTolerance_) {
      geometry = /** @type {import("../../geom/Circle.js").default} */ (
        geometry.simplifyTransformed(
          this.squaredTolerance_,
          this.userTransform_
        )
      );
    }
    if (!(0,_extent_js__WEBPACK_IMPORTED_MODULE_4__.intersects)(this.extent_, geometry.getExtent())) {
      return;
    }
    if (this.fillState_ || this.strokeState_) {
      if (this.fillState_) {
        this.setContextFillState_(this.fillState_);
      }
      if (this.strokeState_) {
        this.setContextStrokeState_(this.strokeState_);
      }
      const pixelCoordinates = (0,_geom_SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_5__.transformGeom2D)(
        geometry,
        this.transform_,
        this.pixelCoordinates_
      );
      const dx = pixelCoordinates[2] - pixelCoordinates[0];
      const dy = pixelCoordinates[3] - pixelCoordinates[1];
      const radius = Math.sqrt(dx * dx + dy * dy);
      const context = this.context_;
      context.beginPath();
      context.arc(
        pixelCoordinates[0],
        pixelCoordinates[1],
        radius,
        0,
        2 * Math.PI
      );
      if (this.fillState_) {
        context.fill();
      }
      if (this.strokeState_) {
        context.stroke();
      }
    }
    if (this.text_ !== '') {
      this.drawText_(geometry.getCenter(), 0, 2, 2);
    }
  }

  /**
   * Set the rendering style.  Note that since this is an immediate rendering API,
   * any `zIndex` on the provided style will be ignored.
   *
   * @param {import("../../style/Style.js").default} style The rendering style.
   * @api
   */
  setStyle(style) {
    this.setFillStrokeStyle(style.getFill(), style.getStroke());
    this.setImageStyle(style.getImage());
    this.setTextStyle(style.getText());
  }

  /**
   * @param {import("../../transform.js").Transform} transform Transform.
   */
  setTransform(transform) {
    this.transform_ = transform;
  }

  /**
   * Render a geometry into the canvas.  Call
   * {@link module:ol/render/canvas/Immediate~CanvasImmediateRenderer#setStyle renderer.setStyle()} first to set the rendering style.
   *
   * @param {import("../../geom/Geometry.js").default|import("../Feature.js").default} geometry The geometry to render.
   * @api
   */
  drawGeometry(geometry) {
    const type = geometry.getType();
    switch (type) {
      case 'Point':
        this.drawPoint(
          /** @type {import("../../geom/Point.js").default} */ (geometry)
        );
        break;
      case 'LineString':
        this.drawLineString(
          /** @type {import("../../geom/LineString.js").default} */ (geometry)
        );
        break;
      case 'Polygon':
        this.drawPolygon(
          /** @type {import("../../geom/Polygon.js").default} */ (geometry)
        );
        break;
      case 'MultiPoint':
        this.drawMultiPoint(
          /** @type {import("../../geom/MultiPoint.js").default} */ (geometry)
        );
        break;
      case 'MultiLineString':
        this.drawMultiLineString(
          /** @type {import("../../geom/MultiLineString.js").default} */ (
            geometry
          )
        );
        break;
      case 'MultiPolygon':
        this.drawMultiPolygon(
          /** @type {import("../../geom/MultiPolygon.js").default} */ (geometry)
        );
        break;
      case 'GeometryCollection':
        this.drawGeometryCollection(
          /** @type {import("../../geom/GeometryCollection.js").default} */ (
            geometry
          )
        );
        break;
      case 'Circle':
        this.drawCircle(
          /** @type {import("../../geom/Circle.js").default} */ (geometry)
        );
        break;
      default:
    }
  }

  /**
   * Render a feature into the canvas.  Note that any `zIndex` on the provided
   * style will be ignored - features are rendered immediately in the order that
   * this method is called.  If you need `zIndex` support, you should be using an
   * {@link module:ol/layer/Vector~VectorLayer} instead.
   *
   * @param {import("../../Feature.js").default} feature Feature.
   * @param {import("../../style/Style.js").default} style Style.
   * @api
   */
  drawFeature(feature, style) {
    const geometry = style.getGeometryFunction()(feature);
    if (!geometry) {
      return;
    }
    this.setStyle(style);
    this.drawGeometry(geometry);
  }

  /**
   * Render a GeometryCollection to the canvas.  Rendering is immediate and
   * uses the current styles appropriate for each geometry in the collection.
   *
   * @param {import("../../geom/GeometryCollection.js").default} geometry Geometry collection.
   */
  drawGeometryCollection(geometry) {
    const geometries = geometry.getGeometriesArray();
    for (let i = 0, ii = geometries.length; i < ii; ++i) {
      this.drawGeometry(geometries[i]);
    }
  }

  /**
   * Render a Point geometry into the canvas.  Rendering is immediate and uses
   * the current style.
   *
   * @param {import("../../geom/Point.js").default|import("../Feature.js").default} geometry Point geometry.
   */
  drawPoint(geometry) {
    if (this.squaredTolerance_) {
      geometry = /** @type {import("../../geom/Point.js").default} */ (
        geometry.simplifyTransformed(
          this.squaredTolerance_,
          this.userTransform_
        )
      );
    }
    const flatCoordinates = geometry.getFlatCoordinates();
    const stride = geometry.getStride();
    if (this.image_) {
      this.drawImages_(flatCoordinates, 0, flatCoordinates.length, stride);
    }
    if (this.text_ !== '') {
      this.drawText_(flatCoordinates, 0, flatCoordinates.length, stride);
    }
  }

  /**
   * Render a MultiPoint geometry  into the canvas.  Rendering is immediate and
   * uses the current style.
   *
   * @param {import("../../geom/MultiPoint.js").default|import("../Feature.js").default} geometry MultiPoint geometry.
   */
  drawMultiPoint(geometry) {
    if (this.squaredTolerance_) {
      geometry = /** @type {import("../../geom/MultiPoint.js").default} */ (
        geometry.simplifyTransformed(
          this.squaredTolerance_,
          this.userTransform_
        )
      );
    }
    const flatCoordinates = geometry.getFlatCoordinates();
    const stride = geometry.getStride();
    if (this.image_) {
      this.drawImages_(flatCoordinates, 0, flatCoordinates.length, stride);
    }
    if (this.text_ !== '') {
      this.drawText_(flatCoordinates, 0, flatCoordinates.length, stride);
    }
  }

  /**
   * Render a LineString into the canvas.  Rendering is immediate and uses
   * the current style.
   *
   * @param {import("../../geom/LineString.js").default|import("../Feature.js").default} geometry LineString geometry.
   */
  drawLineString(geometry) {
    if (this.squaredTolerance_) {
      geometry = /** @type {import("../../geom/LineString.js").default} */ (
        geometry.simplifyTransformed(
          this.squaredTolerance_,
          this.userTransform_
        )
      );
    }
    if (!(0,_extent_js__WEBPACK_IMPORTED_MODULE_4__.intersects)(this.extent_, geometry.getExtent())) {
      return;
    }
    if (this.strokeState_) {
      this.setContextStrokeState_(this.strokeState_);
      const context = this.context_;
      const flatCoordinates = geometry.getFlatCoordinates();
      context.beginPath();
      this.moveToLineTo_(
        flatCoordinates,
        0,
        flatCoordinates.length,
        geometry.getStride(),
        false
      );
      context.stroke();
    }
    if (this.text_ !== '') {
      const flatMidpoint = geometry.getFlatMidpoint();
      this.drawText_(flatMidpoint, 0, 2, 2);
    }
  }

  /**
   * Render a MultiLineString geometry into the canvas.  Rendering is immediate
   * and uses the current style.
   *
   * @param {import("../../geom/MultiLineString.js").default|import("../Feature.js").default} geometry MultiLineString geometry.
   */
  drawMultiLineString(geometry) {
    if (this.squaredTolerance_) {
      geometry =
        /** @type {import("../../geom/MultiLineString.js").default} */ (
          geometry.simplifyTransformed(
            this.squaredTolerance_,
            this.userTransform_
          )
        );
    }
    const geometryExtent = geometry.getExtent();
    if (!(0,_extent_js__WEBPACK_IMPORTED_MODULE_4__.intersects)(this.extent_, geometryExtent)) {
      return;
    }
    if (this.strokeState_) {
      this.setContextStrokeState_(this.strokeState_);
      const context = this.context_;
      const flatCoordinates = geometry.getFlatCoordinates();
      let offset = 0;
      const ends = /** @type {Array<number>} */ (geometry.getEnds());
      const stride = geometry.getStride();
      context.beginPath();
      for (let i = 0, ii = ends.length; i < ii; ++i) {
        offset = this.moveToLineTo_(
          flatCoordinates,
          offset,
          ends[i],
          stride,
          false
        );
      }
      context.stroke();
    }
    if (this.text_ !== '') {
      const flatMidpoints = geometry.getFlatMidpoints();
      this.drawText_(flatMidpoints, 0, flatMidpoints.length, 2);
    }
  }

  /**
   * Render a Polygon geometry into the canvas.  Rendering is immediate and uses
   * the current style.
   *
   * @param {import("../../geom/Polygon.js").default|import("../Feature.js").default} geometry Polygon geometry.
   */
  drawPolygon(geometry) {
    if (this.squaredTolerance_) {
      geometry = /** @type {import("../../geom/Polygon.js").default} */ (
        geometry.simplifyTransformed(
          this.squaredTolerance_,
          this.userTransform_
        )
      );
    }
    if (!(0,_extent_js__WEBPACK_IMPORTED_MODULE_4__.intersects)(this.extent_, geometry.getExtent())) {
      return;
    }
    if (this.strokeState_ || this.fillState_) {
      if (this.fillState_) {
        this.setContextFillState_(this.fillState_);
      }
      if (this.strokeState_) {
        this.setContextStrokeState_(this.strokeState_);
      }
      const context = this.context_;
      context.beginPath();
      this.drawRings_(
        geometry.getOrientedFlatCoordinates(),
        0,
        /** @type {Array<number>} */ (geometry.getEnds()),
        geometry.getStride()
      );
      if (this.fillState_) {
        context.fill();
      }
      if (this.strokeState_) {
        context.stroke();
      }
    }
    if (this.text_ !== '') {
      const flatInteriorPoint = geometry.getFlatInteriorPoint();
      this.drawText_(flatInteriorPoint, 0, 2, 2);
    }
  }

  /**
   * Render MultiPolygon geometry into the canvas.  Rendering is immediate and
   * uses the current style.
   * @param {import("../../geom/MultiPolygon.js").default} geometry MultiPolygon geometry.
   */
  drawMultiPolygon(geometry) {
    if (this.squaredTolerance_) {
      geometry = /** @type {import("../../geom/MultiPolygon.js").default} */ (
        geometry.simplifyTransformed(
          this.squaredTolerance_,
          this.userTransform_
        )
      );
    }
    if (!(0,_extent_js__WEBPACK_IMPORTED_MODULE_4__.intersects)(this.extent_, geometry.getExtent())) {
      return;
    }
    if (this.strokeState_ || this.fillState_) {
      if (this.fillState_) {
        this.setContextFillState_(this.fillState_);
      }
      if (this.strokeState_) {
        this.setContextStrokeState_(this.strokeState_);
      }
      const context = this.context_;
      const flatCoordinates = geometry.getOrientedFlatCoordinates();
      let offset = 0;
      const endss = geometry.getEndss();
      const stride = geometry.getStride();
      context.beginPath();
      for (let i = 0, ii = endss.length; i < ii; ++i) {
        const ends = endss[i];
        offset = this.drawRings_(flatCoordinates, offset, ends, stride);
      }
      if (this.fillState_) {
        context.fill();
      }
      if (this.strokeState_) {
        context.stroke();
      }
    }
    if (this.text_ !== '') {
      const flatInteriorPoints = geometry.getFlatInteriorPoints();
      this.drawText_(flatInteriorPoints, 0, flatInteriorPoints.length, 2);
    }
  }

  /**
   * @param {import("../canvas.js").FillState} fillState Fill state.
   * @private
   */
  setContextFillState_(fillState) {
    const context = this.context_;
    const contextFillState = this.contextFillState_;
    if (!contextFillState) {
      context.fillStyle = fillState.fillStyle;
      this.contextFillState_ = {
        fillStyle: fillState.fillStyle,
      };
    } else {
      if (contextFillState.fillStyle != fillState.fillStyle) {
        contextFillState.fillStyle = fillState.fillStyle;
        context.fillStyle = fillState.fillStyle;
      }
    }
  }

  /**
   * @param {import("../canvas.js").StrokeState} strokeState Stroke state.
   * @private
   */
  setContextStrokeState_(strokeState) {
    const context = this.context_;
    const contextStrokeState = this.contextStrokeState_;
    if (!contextStrokeState) {
      context.lineCap = strokeState.lineCap;
      context.setLineDash(strokeState.lineDash);
      context.lineDashOffset = strokeState.lineDashOffset;
      context.lineJoin = strokeState.lineJoin;
      context.lineWidth = strokeState.lineWidth;
      context.miterLimit = strokeState.miterLimit;
      context.strokeStyle = strokeState.strokeStyle;
      this.contextStrokeState_ = {
        lineCap: strokeState.lineCap,
        lineDash: strokeState.lineDash,
        lineDashOffset: strokeState.lineDashOffset,
        lineJoin: strokeState.lineJoin,
        lineWidth: strokeState.lineWidth,
        miterLimit: strokeState.miterLimit,
        strokeStyle: strokeState.strokeStyle,
      };
    } else {
      if (contextStrokeState.lineCap != strokeState.lineCap) {
        contextStrokeState.lineCap = strokeState.lineCap;
        context.lineCap = strokeState.lineCap;
      }
      if (!(0,_array_js__WEBPACK_IMPORTED_MODULE_6__.equals)(contextStrokeState.lineDash, strokeState.lineDash)) {
        context.setLineDash(
          (contextStrokeState.lineDash = strokeState.lineDash)
        );
      }
      if (contextStrokeState.lineDashOffset != strokeState.lineDashOffset) {
        contextStrokeState.lineDashOffset = strokeState.lineDashOffset;
        context.lineDashOffset = strokeState.lineDashOffset;
      }
      if (contextStrokeState.lineJoin != strokeState.lineJoin) {
        contextStrokeState.lineJoin = strokeState.lineJoin;
        context.lineJoin = strokeState.lineJoin;
      }
      if (contextStrokeState.lineWidth != strokeState.lineWidth) {
        contextStrokeState.lineWidth = strokeState.lineWidth;
        context.lineWidth = strokeState.lineWidth;
      }
      if (contextStrokeState.miterLimit != strokeState.miterLimit) {
        contextStrokeState.miterLimit = strokeState.miterLimit;
        context.miterLimit = strokeState.miterLimit;
      }
      if (contextStrokeState.strokeStyle != strokeState.strokeStyle) {
        contextStrokeState.strokeStyle = strokeState.strokeStyle;
        context.strokeStyle = strokeState.strokeStyle;
      }
    }
  }

  /**
   * @param {import("../canvas.js").TextState} textState Text state.
   * @private
   */
  setContextTextState_(textState) {
    const context = this.context_;
    const contextTextState = this.contextTextState_;
    const textAlign = textState.textAlign
      ? textState.textAlign
      : _canvas_js__WEBPACK_IMPORTED_MODULE_7__.defaultTextAlign;
    if (!contextTextState) {
      context.font = textState.font;
      context.textAlign = textAlign;
      context.textBaseline = textState.textBaseline;
      this.contextTextState_ = {
        font: textState.font,
        textAlign: textAlign,
        textBaseline: textState.textBaseline,
      };
    } else {
      if (contextTextState.font != textState.font) {
        contextTextState.font = textState.font;
        context.font = textState.font;
      }
      if (contextTextState.textAlign != textAlign) {
        contextTextState.textAlign = textAlign;
        context.textAlign = textAlign;
      }
      if (contextTextState.textBaseline != textState.textBaseline) {
        contextTextState.textBaseline = textState.textBaseline;
        context.textBaseline = textState.textBaseline;
      }
    }
  }

  /**
   * Set the fill and stroke style for subsequent draw operations.  To clear
   * either fill or stroke styles, pass null for the appropriate parameter.
   *
   * @param {import("../../style/Fill.js").default} fillStyle Fill style.
   * @param {import("../../style/Stroke.js").default} strokeStyle Stroke style.
   */
  setFillStrokeStyle(fillStyle, strokeStyle) {
    if (!fillStyle) {
      this.fillState_ = null;
    } else {
      const fillStyleColor = fillStyle.getColor();
      this.fillState_ = {
        fillStyle: (0,_colorlike_js__WEBPACK_IMPORTED_MODULE_8__.asColorLike)(
          fillStyleColor ? fillStyleColor : _canvas_js__WEBPACK_IMPORTED_MODULE_7__.defaultFillStyle
        ),
      };
    }
    if (!strokeStyle) {
      this.strokeState_ = null;
    } else {
      const strokeStyleColor = strokeStyle.getColor();
      const strokeStyleLineCap = strokeStyle.getLineCap();
      const strokeStyleLineDash = strokeStyle.getLineDash();
      const strokeStyleLineDashOffset = strokeStyle.getLineDashOffset();
      const strokeStyleLineJoin = strokeStyle.getLineJoin();
      const strokeStyleWidth = strokeStyle.getWidth();
      const strokeStyleMiterLimit = strokeStyle.getMiterLimit();
      const lineDash = strokeStyleLineDash
        ? strokeStyleLineDash
        : _canvas_js__WEBPACK_IMPORTED_MODULE_7__.defaultLineDash;
      this.strokeState_ = {
        lineCap:
          strokeStyleLineCap !== undefined
            ? strokeStyleLineCap
            : _canvas_js__WEBPACK_IMPORTED_MODULE_7__.defaultLineCap,
        lineDash:
          this.pixelRatio_ === 1
            ? lineDash
            : lineDash.map((n) => n * this.pixelRatio_),
        lineDashOffset:
          (strokeStyleLineDashOffset
            ? strokeStyleLineDashOffset
            : _canvas_js__WEBPACK_IMPORTED_MODULE_7__.defaultLineDashOffset) * this.pixelRatio_,
        lineJoin:
          strokeStyleLineJoin !== undefined
            ? strokeStyleLineJoin
            : _canvas_js__WEBPACK_IMPORTED_MODULE_7__.defaultLineJoin,
        lineWidth:
          (strokeStyleWidth !== undefined
            ? strokeStyleWidth
            : _canvas_js__WEBPACK_IMPORTED_MODULE_7__.defaultLineWidth) * this.pixelRatio_,
        miterLimit:
          strokeStyleMiterLimit !== undefined
            ? strokeStyleMiterLimit
            : _canvas_js__WEBPACK_IMPORTED_MODULE_7__.defaultMiterLimit,
        strokeStyle: (0,_colorlike_js__WEBPACK_IMPORTED_MODULE_8__.asColorLike)(
          strokeStyleColor ? strokeStyleColor : _canvas_js__WEBPACK_IMPORTED_MODULE_7__.defaultStrokeStyle
        ),
      };
    }
  }

  /**
   * Set the image style for subsequent draw operations.  Pass null to remove
   * the image style.
   *
   * @param {import("../../style/Image.js").default} imageStyle Image style.
   */
  setImageStyle(imageStyle) {
    let imageSize;
    if (!imageStyle || !(imageSize = imageStyle.getSize())) {
      this.image_ = null;
      return;
    }
    const imagePixelRatio = imageStyle.getPixelRatio(this.pixelRatio_);
    const imageAnchor = imageStyle.getAnchor();
    const imageOrigin = imageStyle.getOrigin();
    this.image_ = imageStyle.getImage(this.pixelRatio_);
    this.imageAnchorX_ = imageAnchor[0] * imagePixelRatio;
    this.imageAnchorY_ = imageAnchor[1] * imagePixelRatio;
    this.imageHeight_ = imageSize[1] * imagePixelRatio;
    this.imageOpacity_ = imageStyle.getOpacity();
    this.imageOriginX_ = imageOrigin[0];
    this.imageOriginY_ = imageOrigin[1];
    this.imageRotateWithView_ = imageStyle.getRotateWithView();
    this.imageRotation_ = imageStyle.getRotation();
    const imageScale = imageStyle.getScaleArray();
    this.imageScale_ = [
      (imageScale[0] * this.pixelRatio_) / imagePixelRatio,
      (imageScale[1] * this.pixelRatio_) / imagePixelRatio,
    ];
    this.imageWidth_ = imageSize[0] * imagePixelRatio;
  }

  /**
   * Set the text style for subsequent draw operations.  Pass null to
   * remove the text style.
   *
   * @param {import("../../style/Text.js").default} textStyle Text style.
   */
  setTextStyle(textStyle) {
    if (!textStyle) {
      this.text_ = '';
    } else {
      const textFillStyle = textStyle.getFill();
      if (!textFillStyle) {
        this.textFillState_ = null;
      } else {
        const textFillStyleColor = textFillStyle.getColor();
        this.textFillState_ = {
          fillStyle: (0,_colorlike_js__WEBPACK_IMPORTED_MODULE_8__.asColorLike)(
            textFillStyleColor ? textFillStyleColor : _canvas_js__WEBPACK_IMPORTED_MODULE_7__.defaultFillStyle
          ),
        };
      }
      const textStrokeStyle = textStyle.getStroke();
      if (!textStrokeStyle) {
        this.textStrokeState_ = null;
      } else {
        const textStrokeStyleColor = textStrokeStyle.getColor();
        const textStrokeStyleLineCap = textStrokeStyle.getLineCap();
        const textStrokeStyleLineDash = textStrokeStyle.getLineDash();
        const textStrokeStyleLineDashOffset =
          textStrokeStyle.getLineDashOffset();
        const textStrokeStyleLineJoin = textStrokeStyle.getLineJoin();
        const textStrokeStyleWidth = textStrokeStyle.getWidth();
        const textStrokeStyleMiterLimit = textStrokeStyle.getMiterLimit();
        this.textStrokeState_ = {
          lineCap:
            textStrokeStyleLineCap !== undefined
              ? textStrokeStyleLineCap
              : _canvas_js__WEBPACK_IMPORTED_MODULE_7__.defaultLineCap,
          lineDash: textStrokeStyleLineDash
            ? textStrokeStyleLineDash
            : _canvas_js__WEBPACK_IMPORTED_MODULE_7__.defaultLineDash,
          lineDashOffset: textStrokeStyleLineDashOffset
            ? textStrokeStyleLineDashOffset
            : _canvas_js__WEBPACK_IMPORTED_MODULE_7__.defaultLineDashOffset,
          lineJoin:
            textStrokeStyleLineJoin !== undefined
              ? textStrokeStyleLineJoin
              : _canvas_js__WEBPACK_IMPORTED_MODULE_7__.defaultLineJoin,
          lineWidth:
            textStrokeStyleWidth !== undefined
              ? textStrokeStyleWidth
              : _canvas_js__WEBPACK_IMPORTED_MODULE_7__.defaultLineWidth,
          miterLimit:
            textStrokeStyleMiterLimit !== undefined
              ? textStrokeStyleMiterLimit
              : _canvas_js__WEBPACK_IMPORTED_MODULE_7__.defaultMiterLimit,
          strokeStyle: (0,_colorlike_js__WEBPACK_IMPORTED_MODULE_8__.asColorLike)(
            textStrokeStyleColor ? textStrokeStyleColor : _canvas_js__WEBPACK_IMPORTED_MODULE_7__.defaultStrokeStyle
          ),
        };
      }
      const textFont = textStyle.getFont();
      const textOffsetX = textStyle.getOffsetX();
      const textOffsetY = textStyle.getOffsetY();
      const textRotateWithView = textStyle.getRotateWithView();
      const textRotation = textStyle.getRotation();
      const textScale = textStyle.getScaleArray();
      const textText = textStyle.getText();
      const textTextAlign = textStyle.getTextAlign();
      const textTextBaseline = textStyle.getTextBaseline();
      this.textState_ = {
        font: textFont !== undefined ? textFont : _canvas_js__WEBPACK_IMPORTED_MODULE_7__.defaultFont,
        textAlign:
          textTextAlign !== undefined ? textTextAlign : _canvas_js__WEBPACK_IMPORTED_MODULE_7__.defaultTextAlign,
        textBaseline:
          textTextBaseline !== undefined
            ? textTextBaseline
            : _canvas_js__WEBPACK_IMPORTED_MODULE_7__.defaultTextBaseline,
      };
      this.text_ =
        textText !== undefined
          ? Array.isArray(textText)
            ? textText.reduce((acc, t, i) => (acc += i % 2 ? ' ' : t), '')
            : textText
          : '';
      this.textOffsetX_ =
        textOffsetX !== undefined ? this.pixelRatio_ * textOffsetX : 0;
      this.textOffsetY_ =
        textOffsetY !== undefined ? this.pixelRatio_ * textOffsetY : 0;
      this.textRotateWithView_ =
        textRotateWithView !== undefined ? textRotateWithView : false;
      this.textRotation_ = textRotation !== undefined ? textRotation : 0;
      this.textScale_ = [
        this.pixelRatio_ * textScale[0],
        this.pixelRatio_ * textScale[1],
      ];
    }
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CanvasImmediateRenderer);


/***/ }),

/***/ "./node_modules/ol/render/canvas/Instruction.js":
/*!******************************************************!*\
  !*** ./node_modules/ol/render/canvas/Instruction.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   beginPathInstruction: () => (/* binding */ beginPathInstruction),
/* harmony export */   closePathInstruction: () => (/* binding */ closePathInstruction),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   fillInstruction: () => (/* binding */ fillInstruction),
/* harmony export */   strokeInstruction: () => (/* binding */ strokeInstruction)
/* harmony export */ });
/**
 * @module ol/render/canvas/Instruction
 */

/**
 * @enum {number}
 */
const Instruction = {
  BEGIN_GEOMETRY: 0,
  BEGIN_PATH: 1,
  CIRCLE: 2,
  CLOSE_PATH: 3,
  CUSTOM: 4,
  DRAW_CHARS: 5,
  DRAW_IMAGE: 6,
  END_GEOMETRY: 7,
  FILL: 8,
  MOVE_TO_LINE_TO: 9,
  SET_FILL_STYLE: 10,
  SET_STROKE_STYLE: 11,
  STROKE: 12,
};

/**
 * @type {Array<Instruction>}
 */
const fillInstruction = [Instruction.FILL];

/**
 * @type {Array<Instruction>}
 */
const strokeInstruction = [Instruction.STROKE];

/**
 * @type {Array<Instruction>}
 */
const beginPathInstruction = [Instruction.BEGIN_PATH];

/**
 * @type {Array<Instruction>}
 */
const closePathInstruction = [Instruction.CLOSE_PATH];

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Instruction);


/***/ }),

/***/ "./node_modules/ol/render/canvas/LineStringBuilder.js":
/*!************************************************************!*\
  !*** ./node_modules/ol/render/canvas/LineStringBuilder.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Builder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Builder.js */ "./node_modules/ol/render/canvas/Builder.js");
/* harmony import */ var _Instruction_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Instruction.js */ "./node_modules/ol/render/canvas/Instruction.js");
/* harmony import */ var _canvas_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../canvas.js */ "./node_modules/ol/render/canvas.js");
/**
 * @module ol/render/canvas/LineStringBuilder
 */




class CanvasLineStringBuilder extends _Builder_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */
  constructor(tolerance, maxExtent, resolution, pixelRatio) {
    super(tolerance, maxExtent, resolution, pixelRatio);
  }

  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @private
   * @return {number} end.
   */
  drawFlatCoordinates_(flatCoordinates, offset, end, stride) {
    const myBegin = this.coordinates.length;
    const myEnd = this.appendFlatLineCoordinates(
      flatCoordinates,
      offset,
      end,
      stride,
      false,
      false
    );
    const moveToLineToInstruction = [
      _Instruction_js__WEBPACK_IMPORTED_MODULE_1__["default"].MOVE_TO_LINE_TO,
      myBegin,
      myEnd,
    ];
    this.instructions.push(moveToLineToInstruction);
    this.hitDetectionInstructions.push(moveToLineToInstruction);
    return end;
  }

  /**
   * @param {import("../../geom/LineString.js").default|import("../Feature.js").default} lineStringGeometry Line string geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   */
  drawLineString(lineStringGeometry, feature) {
    const state = this.state;
    const strokeStyle = state.strokeStyle;
    const lineWidth = state.lineWidth;
    if (strokeStyle === undefined || lineWidth === undefined) {
      return;
    }
    this.updateStrokeStyle(state, this.applyStroke);
    this.beginGeometry(lineStringGeometry, feature);
    this.hitDetectionInstructions.push(
      [
        _Instruction_js__WEBPACK_IMPORTED_MODULE_1__["default"].SET_STROKE_STYLE,
        state.strokeStyle,
        state.lineWidth,
        state.lineCap,
        state.lineJoin,
        state.miterLimit,
        _canvas_js__WEBPACK_IMPORTED_MODULE_2__.defaultLineDash,
        _canvas_js__WEBPACK_IMPORTED_MODULE_2__.defaultLineDashOffset,
      ],
      _Instruction_js__WEBPACK_IMPORTED_MODULE_1__.beginPathInstruction
    );
    const flatCoordinates = lineStringGeometry.getFlatCoordinates();
    const stride = lineStringGeometry.getStride();
    this.drawFlatCoordinates_(
      flatCoordinates,
      0,
      flatCoordinates.length,
      stride
    );
    this.hitDetectionInstructions.push(_Instruction_js__WEBPACK_IMPORTED_MODULE_1__.strokeInstruction);
    this.endGeometry(feature);
  }

  /**
   * @param {import("../../geom/MultiLineString.js").default|import("../Feature.js").default} multiLineStringGeometry MultiLineString geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   */
  drawMultiLineString(multiLineStringGeometry, feature) {
    const state = this.state;
    const strokeStyle = state.strokeStyle;
    const lineWidth = state.lineWidth;
    if (strokeStyle === undefined || lineWidth === undefined) {
      return;
    }
    this.updateStrokeStyle(state, this.applyStroke);
    this.beginGeometry(multiLineStringGeometry, feature);
    this.hitDetectionInstructions.push(
      [
        _Instruction_js__WEBPACK_IMPORTED_MODULE_1__["default"].SET_STROKE_STYLE,
        state.strokeStyle,
        state.lineWidth,
        state.lineCap,
        state.lineJoin,
        state.miterLimit,
        _canvas_js__WEBPACK_IMPORTED_MODULE_2__.defaultLineDash,
        _canvas_js__WEBPACK_IMPORTED_MODULE_2__.defaultLineDashOffset,
      ],
      _Instruction_js__WEBPACK_IMPORTED_MODULE_1__.beginPathInstruction
    );
    const ends = multiLineStringGeometry.getEnds();
    const flatCoordinates = multiLineStringGeometry.getFlatCoordinates();
    const stride = multiLineStringGeometry.getStride();
    let offset = 0;
    for (let i = 0, ii = ends.length; i < ii; ++i) {
      offset = this.drawFlatCoordinates_(
        flatCoordinates,
        offset,
        /** @type {number} */ (ends[i]),
        stride
      );
    }
    this.hitDetectionInstructions.push(_Instruction_js__WEBPACK_IMPORTED_MODULE_1__.strokeInstruction);
    this.endGeometry(feature);
  }

  /**
   * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
   */
  finish() {
    const state = this.state;
    if (
      state.lastStroke != undefined &&
      state.lastStroke != this.coordinates.length
    ) {
      this.instructions.push(_Instruction_js__WEBPACK_IMPORTED_MODULE_1__.strokeInstruction);
    }
    this.reverseHitDetectionInstructions();
    this.state = null;
    return super.finish();
  }

  /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   */
  applyStroke(state) {
    if (
      state.lastStroke != undefined &&
      state.lastStroke != this.coordinates.length
    ) {
      this.instructions.push(_Instruction_js__WEBPACK_IMPORTED_MODULE_1__.strokeInstruction);
      state.lastStroke = this.coordinates.length;
    }
    state.lastStroke = 0;
    super.applyStroke(state);
    this.instructions.push(_Instruction_js__WEBPACK_IMPORTED_MODULE_1__.beginPathInstruction);
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CanvasLineStringBuilder);


/***/ }),

/***/ "./node_modules/ol/render/canvas/PolygonBuilder.js":
/*!*********************************************************!*\
  !*** ./node_modules/ol/render/canvas/PolygonBuilder.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Builder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Builder.js */ "./node_modules/ol/render/canvas/Builder.js");
/* harmony import */ var _Instruction_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Instruction.js */ "./node_modules/ol/render/canvas/Instruction.js");
/* harmony import */ var _canvas_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../canvas.js */ "./node_modules/ol/render/canvas.js");
/* harmony import */ var _geom_flat_simplify_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../geom/flat/simplify.js */ "./node_modules/ol/geom/flat/simplify.js");
/**
 * @module ol/render/canvas/PolygonBuilder
 */





class CanvasPolygonBuilder extends _Builder_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */
  constructor(tolerance, maxExtent, resolution, pixelRatio) {
    super(tolerance, maxExtent, resolution, pixelRatio);
  }

  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<number>} ends Ends.
   * @param {number} stride Stride.
   * @private
   * @return {number} End.
   */
  drawFlatCoordinatess_(flatCoordinates, offset, ends, stride) {
    const state = this.state;
    const fill = state.fillStyle !== undefined;
    const stroke = state.strokeStyle !== undefined;
    const numEnds = ends.length;
    this.instructions.push(_Instruction_js__WEBPACK_IMPORTED_MODULE_1__.beginPathInstruction);
    this.hitDetectionInstructions.push(_Instruction_js__WEBPACK_IMPORTED_MODULE_1__.beginPathInstruction);
    for (let i = 0; i < numEnds; ++i) {
      const end = ends[i];
      const myBegin = this.coordinates.length;
      const myEnd = this.appendFlatLineCoordinates(
        flatCoordinates,
        offset,
        end,
        stride,
        true,
        !stroke
      );
      const moveToLineToInstruction = [
        _Instruction_js__WEBPACK_IMPORTED_MODULE_1__["default"].MOVE_TO_LINE_TO,
        myBegin,
        myEnd,
      ];
      this.instructions.push(moveToLineToInstruction);
      this.hitDetectionInstructions.push(moveToLineToInstruction);
      if (stroke) {
        // Performance optimization: only call closePath() when we have a stroke.
        // Otherwise the ring is closed already (see appendFlatLineCoordinates above).
        this.instructions.push(_Instruction_js__WEBPACK_IMPORTED_MODULE_1__.closePathInstruction);
        this.hitDetectionInstructions.push(_Instruction_js__WEBPACK_IMPORTED_MODULE_1__.closePathInstruction);
      }
      offset = end;
    }
    if (fill) {
      this.instructions.push(_Instruction_js__WEBPACK_IMPORTED_MODULE_1__.fillInstruction);
      this.hitDetectionInstructions.push(_Instruction_js__WEBPACK_IMPORTED_MODULE_1__.fillInstruction);
    }
    if (stroke) {
      this.instructions.push(_Instruction_js__WEBPACK_IMPORTED_MODULE_1__.strokeInstruction);
      this.hitDetectionInstructions.push(_Instruction_js__WEBPACK_IMPORTED_MODULE_1__.strokeInstruction);
    }
    return offset;
  }

  /**
   * @param {import("../../geom/Circle.js").default} circleGeometry Circle geometry.
   * @param {import("../../Feature.js").default} feature Feature.
   */
  drawCircle(circleGeometry, feature) {
    const state = this.state;
    const fillStyle = state.fillStyle;
    const strokeStyle = state.strokeStyle;
    if (fillStyle === undefined && strokeStyle === undefined) {
      return;
    }
    this.setFillStrokeStyles_();
    this.beginGeometry(circleGeometry, feature);
    if (state.fillStyle !== undefined) {
      this.hitDetectionInstructions.push([
        _Instruction_js__WEBPACK_IMPORTED_MODULE_1__["default"].SET_FILL_STYLE,
        _canvas_js__WEBPACK_IMPORTED_MODULE_2__.defaultFillStyle,
      ]);
    }
    if (state.strokeStyle !== undefined) {
      this.hitDetectionInstructions.push([
        _Instruction_js__WEBPACK_IMPORTED_MODULE_1__["default"].SET_STROKE_STYLE,
        state.strokeStyle,
        state.lineWidth,
        state.lineCap,
        state.lineJoin,
        state.miterLimit,
        _canvas_js__WEBPACK_IMPORTED_MODULE_2__.defaultLineDash,
        _canvas_js__WEBPACK_IMPORTED_MODULE_2__.defaultLineDashOffset,
      ]);
    }
    const flatCoordinates = circleGeometry.getFlatCoordinates();
    const stride = circleGeometry.getStride();
    const myBegin = this.coordinates.length;
    this.appendFlatLineCoordinates(
      flatCoordinates,
      0,
      flatCoordinates.length,
      stride,
      false,
      false
    );
    const circleInstruction = [_Instruction_js__WEBPACK_IMPORTED_MODULE_1__["default"].CIRCLE, myBegin];
    this.instructions.push(_Instruction_js__WEBPACK_IMPORTED_MODULE_1__.beginPathInstruction, circleInstruction);
    this.hitDetectionInstructions.push(_Instruction_js__WEBPACK_IMPORTED_MODULE_1__.beginPathInstruction, circleInstruction);
    if (state.fillStyle !== undefined) {
      this.instructions.push(_Instruction_js__WEBPACK_IMPORTED_MODULE_1__.fillInstruction);
      this.hitDetectionInstructions.push(_Instruction_js__WEBPACK_IMPORTED_MODULE_1__.fillInstruction);
    }
    if (state.strokeStyle !== undefined) {
      this.instructions.push(_Instruction_js__WEBPACK_IMPORTED_MODULE_1__.strokeInstruction);
      this.hitDetectionInstructions.push(_Instruction_js__WEBPACK_IMPORTED_MODULE_1__.strokeInstruction);
    }
    this.endGeometry(feature);
  }

  /**
   * @param {import("../../geom/Polygon.js").default|import("../Feature.js").default} polygonGeometry Polygon geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   */
  drawPolygon(polygonGeometry, feature) {
    const state = this.state;
    const fillStyle = state.fillStyle;
    const strokeStyle = state.strokeStyle;
    if (fillStyle === undefined && strokeStyle === undefined) {
      return;
    }
    this.setFillStrokeStyles_();
    this.beginGeometry(polygonGeometry, feature);
    if (state.fillStyle !== undefined) {
      this.hitDetectionInstructions.push([
        _Instruction_js__WEBPACK_IMPORTED_MODULE_1__["default"].SET_FILL_STYLE,
        _canvas_js__WEBPACK_IMPORTED_MODULE_2__.defaultFillStyle,
      ]);
    }
    if (state.strokeStyle !== undefined) {
      this.hitDetectionInstructions.push([
        _Instruction_js__WEBPACK_IMPORTED_MODULE_1__["default"].SET_STROKE_STYLE,
        state.strokeStyle,
        state.lineWidth,
        state.lineCap,
        state.lineJoin,
        state.miterLimit,
        _canvas_js__WEBPACK_IMPORTED_MODULE_2__.defaultLineDash,
        _canvas_js__WEBPACK_IMPORTED_MODULE_2__.defaultLineDashOffset,
      ]);
    }
    const ends = polygonGeometry.getEnds();
    const flatCoordinates = polygonGeometry.getOrientedFlatCoordinates();
    const stride = polygonGeometry.getStride();
    this.drawFlatCoordinatess_(
      flatCoordinates,
      0,
      /** @type {Array<number>} */ (ends),
      stride
    );
    this.endGeometry(feature);
  }

  /**
   * @param {import("../../geom/MultiPolygon.js").default} multiPolygonGeometry MultiPolygon geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   */
  drawMultiPolygon(multiPolygonGeometry, feature) {
    const state = this.state;
    const fillStyle = state.fillStyle;
    const strokeStyle = state.strokeStyle;
    if (fillStyle === undefined && strokeStyle === undefined) {
      return;
    }
    this.setFillStrokeStyles_();
    this.beginGeometry(multiPolygonGeometry, feature);
    if (state.fillStyle !== undefined) {
      this.hitDetectionInstructions.push([
        _Instruction_js__WEBPACK_IMPORTED_MODULE_1__["default"].SET_FILL_STYLE,
        _canvas_js__WEBPACK_IMPORTED_MODULE_2__.defaultFillStyle,
      ]);
    }
    if (state.strokeStyle !== undefined) {
      this.hitDetectionInstructions.push([
        _Instruction_js__WEBPACK_IMPORTED_MODULE_1__["default"].SET_STROKE_STYLE,
        state.strokeStyle,
        state.lineWidth,
        state.lineCap,
        state.lineJoin,
        state.miterLimit,
        _canvas_js__WEBPACK_IMPORTED_MODULE_2__.defaultLineDash,
        _canvas_js__WEBPACK_IMPORTED_MODULE_2__.defaultLineDashOffset,
      ]);
    }
    const endss = multiPolygonGeometry.getEndss();
    const flatCoordinates = multiPolygonGeometry.getOrientedFlatCoordinates();
    const stride = multiPolygonGeometry.getStride();
    let offset = 0;
    for (let i = 0, ii = endss.length; i < ii; ++i) {
      offset = this.drawFlatCoordinatess_(
        flatCoordinates,
        offset,
        endss[i],
        stride
      );
    }
    this.endGeometry(feature);
  }

  /**
   * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
   */
  finish() {
    this.reverseHitDetectionInstructions();
    this.state = null;
    // We want to preserve topology when drawing polygons.  Polygons are
    // simplified using quantization and point elimination. However, we might
    // have received a mix of quantized and non-quantized geometries, so ensure
    // that all are quantized by quantizing all coordinates in the batch.
    const tolerance = this.tolerance;
    if (tolerance !== 0) {
      const coordinates = this.coordinates;
      for (let i = 0, ii = coordinates.length; i < ii; ++i) {
        coordinates[i] = (0,_geom_flat_simplify_js__WEBPACK_IMPORTED_MODULE_3__.snap)(coordinates[i], tolerance);
      }
    }
    return super.finish();
  }

  /**
   * @private
   */
  setFillStrokeStyles_() {
    const state = this.state;
    const fillStyle = state.fillStyle;
    if (fillStyle !== undefined) {
      this.updateFillStyle(state, this.createFill);
    }
    if (state.strokeStyle !== undefined) {
      this.updateStrokeStyle(state, this.applyStroke);
    }
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CanvasPolygonBuilder);


/***/ }),

/***/ "./node_modules/ol/render/canvas/TextBuilder.js":
/*!******************************************************!*\
  !*** ./node_modules/ol/render/canvas/TextBuilder.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TEXT_ALIGN: () => (/* binding */ TEXT_ALIGN),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Builder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Builder.js */ "./node_modules/ol/render/canvas/Builder.js");
/* harmony import */ var _Instruction_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Instruction.js */ "./node_modules/ol/render/canvas/Instruction.js");
/* harmony import */ var _colorlike_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../colorlike.js */ "./node_modules/ol/colorlike.js");
/* harmony import */ var _canvas_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../canvas.js */ "./node_modules/ol/render/canvas.js");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../util.js */ "./node_modules/ol/util.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _geom_flat_linechunk_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../geom/flat/linechunk.js */ "./node_modules/ol/geom/flat/linechunk.js");
/* harmony import */ var _geom_flat_straightchunk_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../geom/flat/straightchunk.js */ "./node_modules/ol/geom/flat/straightchunk.js");
/**
 * @module ol/render/canvas/TextBuilder
 */








/**
 * @const
 * @type {{left: 0, center: 0.5, right: 1, top: 0, middle: 0.5, hanging: 0.2, alphabetic: 0.8, ideographic: 0.8, bottom: 1}}
 */
const TEXT_ALIGN = {
  'left': 0,
  'center': 0.5,
  'right': 1,
  'top': 0,
  'middle': 0.5,
  'hanging': 0.2,
  'alphabetic': 0.8,
  'ideographic': 0.8,
  'bottom': 1,
};

class CanvasTextBuilder extends _Builder_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */
  constructor(tolerance, maxExtent, resolution, pixelRatio) {
    super(tolerance, maxExtent, resolution, pixelRatio);

    /**
     * @private
     * @type {Array<HTMLCanvasElement>}
     */
    this.labels_ = null;

    /**
     * @private
     * @type {string|Array<string>}
     */
    this.text_ = '';

    /**
     * @private
     * @type {number}
     */
    this.textOffsetX_ = 0;

    /**
     * @private
     * @type {number}
     */
    this.textOffsetY_ = 0;

    /**
     * @private
     * @type {boolean|undefined}
     */
    this.textRotateWithView_ = undefined;

    /**
     * @private
     * @type {number}
     */
    this.textRotation_ = 0;

    /**
     * @private
     * @type {?import("../canvas.js").FillState}
     */
    this.textFillState_ = null;

    /**
     * @type {!Object<string, import("../canvas.js").FillState>}
     */
    this.fillStates = {};
    this.fillStates[_canvas_js__WEBPACK_IMPORTED_MODULE_1__.defaultFillStyle] = {fillStyle: _canvas_js__WEBPACK_IMPORTED_MODULE_1__.defaultFillStyle};

    /**
     * @private
     * @type {?import("../canvas.js").StrokeState}
     */
    this.textStrokeState_ = null;

    /**
     * @type {!Object<string, import("../canvas.js").StrokeState>}
     */
    this.strokeStates = {};

    /**
     * @private
     * @type {import("../canvas.js").TextState}
     */
    this.textState_ = /** @type {import("../canvas.js").TextState} */ ({});

    /**
     * @type {!Object<string, import("../canvas.js").TextState>}
     */
    this.textStates = {};

    /**
     * @private
     * @type {string}
     */
    this.textKey_ = '';

    /**
     * @private
     * @type {string}
     */
    this.fillKey_ = '';

    /**
     * @private
     * @type {string}
     */
    this.strokeKey_ = '';

    /**
     * Data shared with an image builder for combined decluttering.
     * @private
     * @type {import("../canvas.js").DeclutterImageWithText}
     */
    this.declutterImageWithText_ = undefined;
  }

  /**
   * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
   */
  finish() {
    const instructions = super.finish();
    instructions.textStates = this.textStates;
    instructions.fillStates = this.fillStates;
    instructions.strokeStates = this.strokeStates;
    return instructions;
  }

  /**
   * @param {import("../../geom/SimpleGeometry.js").default|import("../Feature.js").default} geometry Geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   */
  drawText(geometry, feature) {
    const fillState = this.textFillState_;
    const strokeState = this.textStrokeState_;
    const textState = this.textState_;
    if (this.text_ === '' || !textState || (!fillState && !strokeState)) {
      return;
    }

    const coordinates = this.coordinates;
    let begin = coordinates.length;

    const geometryType = geometry.getType();
    let flatCoordinates = null;
    let stride = geometry.getStride();

    if (
      textState.placement === 'line' &&
      (geometryType == 'LineString' ||
        geometryType == 'MultiLineString' ||
        geometryType == 'Polygon' ||
        geometryType == 'MultiPolygon')
    ) {
      if (!(0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.intersects)(this.getBufferedMaxExtent(), geometry.getExtent())) {
        return;
      }
      let ends;
      flatCoordinates = geometry.getFlatCoordinates();
      if (geometryType == 'LineString') {
        ends = [flatCoordinates.length];
      } else if (geometryType == 'MultiLineString') {
        ends = /** @type {import("../../geom/MultiLineString.js").default} */ (
          geometry
        ).getEnds();
      } else if (geometryType == 'Polygon') {
        ends = /** @type {import("../../geom/Polygon.js").default} */ (geometry)
          .getEnds()
          .slice(0, 1);
      } else if (geometryType == 'MultiPolygon') {
        const endss =
          /** @type {import("../../geom/MultiPolygon.js").default} */ (
            geometry
          ).getEndss();
        ends = [];
        for (let i = 0, ii = endss.length; i < ii; ++i) {
          ends.push(endss[i][0]);
        }
      }
      this.beginGeometry(geometry, feature);
      const repeat = textState.repeat;
      const textAlign = repeat ? undefined : textState.textAlign;
      // No `justify` support for line placement.
      let flatOffset = 0;
      for (let o = 0, oo = ends.length; o < oo; ++o) {
        let chunks;
        if (repeat) {
          chunks = (0,_geom_flat_linechunk_js__WEBPACK_IMPORTED_MODULE_3__.lineChunk)(
            repeat * this.resolution,
            flatCoordinates,
            flatOffset,
            ends[o],
            stride
          );
        } else {
          chunks = [flatCoordinates.slice(flatOffset, ends[o])];
        }
        for (let c = 0, cc = chunks.length; c < cc; ++c) {
          const chunk = chunks[c];
          let chunkBegin = 0;
          let chunkEnd = chunk.length;
          if (textAlign == undefined) {
            const range = (0,_geom_flat_straightchunk_js__WEBPACK_IMPORTED_MODULE_4__.matchingChunk)(
              textState.maxAngle,
              chunk,
              0,
              chunk.length,
              2
            );
            chunkBegin = range[0];
            chunkEnd = range[1];
          }
          for (let i = chunkBegin; i < chunkEnd; i += stride) {
            coordinates.push(chunk[i], chunk[i + 1]);
          }
          const end = coordinates.length;
          flatOffset = ends[o];
          this.drawChars_(begin, end);
          begin = end;
        }
      }
      this.endGeometry(feature);
    } else {
      let geometryWidths = textState.overflow ? null : [];
      switch (geometryType) {
        case 'Point':
        case 'MultiPoint':
          flatCoordinates =
            /** @type {import("../../geom/MultiPoint.js").default} */ (
              geometry
            ).getFlatCoordinates();
          break;
        case 'LineString':
          flatCoordinates =
            /** @type {import("../../geom/LineString.js").default} */ (
              geometry
            ).getFlatMidpoint();
          break;
        case 'Circle':
          flatCoordinates =
            /** @type {import("../../geom/Circle.js").default} */ (
              geometry
            ).getCenter();
          break;
        case 'MultiLineString':
          flatCoordinates =
            /** @type {import("../../geom/MultiLineString.js").default} */ (
              geometry
            ).getFlatMidpoints();
          stride = 2;
          break;
        case 'Polygon':
          flatCoordinates =
            /** @type {import("../../geom/Polygon.js").default} */ (
              geometry
            ).getFlatInteriorPoint();
          if (!textState.overflow) {
            geometryWidths.push(flatCoordinates[2] / this.resolution);
          }
          stride = 3;
          break;
        case 'MultiPolygon':
          const interiorPoints =
            /** @type {import("../../geom/MultiPolygon.js").default} */ (
              geometry
            ).getFlatInteriorPoints();
          flatCoordinates = [];
          for (let i = 0, ii = interiorPoints.length; i < ii; i += 3) {
            if (!textState.overflow) {
              geometryWidths.push(interiorPoints[i + 2] / this.resolution);
            }
            flatCoordinates.push(interiorPoints[i], interiorPoints[i + 1]);
          }
          if (flatCoordinates.length === 0) {
            return;
          }
          stride = 2;
          break;
        default:
      }
      const end = this.appendFlatPointCoordinates(flatCoordinates, stride);
      if (end === begin) {
        return;
      }
      if (
        geometryWidths &&
        (end - begin) / 2 !== flatCoordinates.length / stride
      ) {
        let beg = begin / 2;
        geometryWidths = geometryWidths.filter((w, i) => {
          const keep =
            coordinates[(beg + i) * 2] === flatCoordinates[i * stride] &&
            coordinates[(beg + i) * 2 + 1] === flatCoordinates[i * stride + 1];
          if (!keep) {
            --beg;
          }
          return keep;
        });
      }

      this.saveTextStates_();

      if (textState.backgroundFill || textState.backgroundStroke) {
        this.setFillStrokeStyle(
          textState.backgroundFill,
          textState.backgroundStroke
        );
        if (textState.backgroundFill) {
          this.updateFillStyle(this.state, this.createFill);
        }
        if (textState.backgroundStroke) {
          this.updateStrokeStyle(this.state, this.applyStroke);
          this.hitDetectionInstructions.push(this.createStroke(this.state));
        }
      }

      this.beginGeometry(geometry, feature);

      // adjust padding for negative scale
      let padding = textState.padding;
      if (
        padding != _canvas_js__WEBPACK_IMPORTED_MODULE_1__.defaultPadding &&
        (textState.scale[0] < 0 || textState.scale[1] < 0)
      ) {
        let p0 = textState.padding[0];
        let p1 = textState.padding[1];
        let p2 = textState.padding[2];
        let p3 = textState.padding[3];
        if (textState.scale[0] < 0) {
          p1 = -p1;
          p3 = -p3;
        }
        if (textState.scale[1] < 0) {
          p0 = -p0;
          p2 = -p2;
        }
        padding = [p0, p1, p2, p3];
      }

      // The image is unknown at this stage so we pass null; it will be computed at render time.
      // For clarity, we pass NaN for offsetX, offsetY, width and height, which will be computed at
      // render time.
      const pixelRatio = this.pixelRatio;
      this.instructions.push([
        _Instruction_js__WEBPACK_IMPORTED_MODULE_5__["default"].DRAW_IMAGE,
        begin,
        end,
        null,
        NaN,
        NaN,
        NaN,
        1,
        0,
        0,
        this.textRotateWithView_,
        this.textRotation_,
        [1, 1],
        NaN,
        undefined,
        this.declutterImageWithText_,
        padding == _canvas_js__WEBPACK_IMPORTED_MODULE_1__.defaultPadding
          ? _canvas_js__WEBPACK_IMPORTED_MODULE_1__.defaultPadding
          : padding.map(function (p) {
              return p * pixelRatio;
            }),
        !!textState.backgroundFill,
        !!textState.backgroundStroke,
        this.text_,
        this.textKey_,
        this.strokeKey_,
        this.fillKey_,
        this.textOffsetX_,
        this.textOffsetY_,
        geometryWidths,
      ]);
      const scale = 1 / pixelRatio;
      // Set default fill for hit detection background
      const currentFillStyle = this.state.fillStyle;
      if (textState.backgroundFill) {
        this.state.fillStyle = _canvas_js__WEBPACK_IMPORTED_MODULE_1__.defaultFillStyle;
        this.hitDetectionInstructions.push(this.createFill(this.state));
      }
      this.hitDetectionInstructions.push([
        _Instruction_js__WEBPACK_IMPORTED_MODULE_5__["default"].DRAW_IMAGE,
        begin,
        end,
        null,
        NaN,
        NaN,
        NaN,
        1,
        0,
        0,
        this.textRotateWithView_,
        this.textRotation_,
        [scale, scale],
        NaN,
        undefined,
        this.declutterImageWithText_,
        padding,
        !!textState.backgroundFill,
        !!textState.backgroundStroke,
        this.text_,
        this.textKey_,
        this.strokeKey_,
        this.fillKey_ ? _canvas_js__WEBPACK_IMPORTED_MODULE_1__.defaultFillStyle : this.fillKey_,
        this.textOffsetX_,
        this.textOffsetY_,
        geometryWidths,
      ]);
      // Reset previous fill
      if (textState.backgroundFill) {
        this.state.fillStyle = currentFillStyle;
        this.hitDetectionInstructions.push(this.createFill(this.state));
      }

      this.endGeometry(feature);
    }
  }

  /**
   * @private
   */
  saveTextStates_() {
    const strokeState = this.textStrokeState_;
    const textState = this.textState_;
    const fillState = this.textFillState_;

    const strokeKey = this.strokeKey_;
    if (strokeState) {
      if (!(strokeKey in this.strokeStates)) {
        this.strokeStates[strokeKey] = {
          strokeStyle: strokeState.strokeStyle,
          lineCap: strokeState.lineCap,
          lineDashOffset: strokeState.lineDashOffset,
          lineWidth: strokeState.lineWidth,
          lineJoin: strokeState.lineJoin,
          miterLimit: strokeState.miterLimit,
          lineDash: strokeState.lineDash,
        };
      }
    }
    const textKey = this.textKey_;
    if (!(textKey in this.textStates)) {
      this.textStates[textKey] = {
        font: textState.font,
        textAlign: textState.textAlign || _canvas_js__WEBPACK_IMPORTED_MODULE_1__.defaultTextAlign,
        justify: textState.justify,
        textBaseline: textState.textBaseline || _canvas_js__WEBPACK_IMPORTED_MODULE_1__.defaultTextBaseline,
        scale: textState.scale,
      };
    }
    const fillKey = this.fillKey_;
    if (fillState) {
      if (!(fillKey in this.fillStates)) {
        this.fillStates[fillKey] = {
          fillStyle: fillState.fillStyle,
        };
      }
    }
  }

  /**
   * @private
   * @param {number} begin Begin.
   * @param {number} end End.
   */
  drawChars_(begin, end) {
    const strokeState = this.textStrokeState_;
    const textState = this.textState_;

    const strokeKey = this.strokeKey_;
    const textKey = this.textKey_;
    const fillKey = this.fillKey_;
    this.saveTextStates_();

    const pixelRatio = this.pixelRatio;
    const baseline = TEXT_ALIGN[textState.textBaseline];

    const offsetY = this.textOffsetY_ * pixelRatio;
    const text = this.text_;
    const strokeWidth = strokeState
      ? (strokeState.lineWidth * Math.abs(textState.scale[0])) / 2
      : 0;

    this.instructions.push([
      _Instruction_js__WEBPACK_IMPORTED_MODULE_5__["default"].DRAW_CHARS,
      begin,
      end,
      baseline,
      textState.overflow,
      fillKey,
      textState.maxAngle,
      pixelRatio,
      offsetY,
      strokeKey,
      strokeWidth * pixelRatio,
      text,
      textKey,
      1,
    ]);
    this.hitDetectionInstructions.push([
      _Instruction_js__WEBPACK_IMPORTED_MODULE_5__["default"].DRAW_CHARS,
      begin,
      end,
      baseline,
      textState.overflow,
      fillKey ? _canvas_js__WEBPACK_IMPORTED_MODULE_1__.defaultFillStyle : fillKey,
      textState.maxAngle,
      pixelRatio,
      offsetY,
      strokeKey,
      strokeWidth * pixelRatio,
      text,
      textKey,
      1 / pixelRatio,
    ]);
  }

  /**
   * @param {import("../../style/Text.js").default} textStyle Text style.
   * @param {Object} [sharedData] Shared data.
   */
  setTextStyle(textStyle, sharedData) {
    let textState, fillState, strokeState;
    if (!textStyle) {
      this.text_ = '';
    } else {
      const textFillStyle = textStyle.getFill();
      if (!textFillStyle) {
        fillState = null;
        this.textFillState_ = fillState;
      } else {
        fillState = this.textFillState_;
        if (!fillState) {
          fillState = /** @type {import("../canvas.js").FillState} */ ({});
          this.textFillState_ = fillState;
        }
        fillState.fillStyle = (0,_colorlike_js__WEBPACK_IMPORTED_MODULE_6__.asColorLike)(
          textFillStyle.getColor() || _canvas_js__WEBPACK_IMPORTED_MODULE_1__.defaultFillStyle
        );
      }

      const textStrokeStyle = textStyle.getStroke();
      if (!textStrokeStyle) {
        strokeState = null;
        this.textStrokeState_ = strokeState;
      } else {
        strokeState = this.textStrokeState_;
        if (!strokeState) {
          strokeState = /** @type {import("../canvas.js").StrokeState} */ ({});
          this.textStrokeState_ = strokeState;
        }
        const lineDash = textStrokeStyle.getLineDash();
        const lineDashOffset = textStrokeStyle.getLineDashOffset();
        const lineWidth = textStrokeStyle.getWidth();
        const miterLimit = textStrokeStyle.getMiterLimit();
        strokeState.lineCap = textStrokeStyle.getLineCap() || _canvas_js__WEBPACK_IMPORTED_MODULE_1__.defaultLineCap;
        strokeState.lineDash = lineDash ? lineDash.slice() : _canvas_js__WEBPACK_IMPORTED_MODULE_1__.defaultLineDash;
        strokeState.lineDashOffset =
          lineDashOffset === undefined ? _canvas_js__WEBPACK_IMPORTED_MODULE_1__.defaultLineDashOffset : lineDashOffset;
        strokeState.lineJoin = textStrokeStyle.getLineJoin() || _canvas_js__WEBPACK_IMPORTED_MODULE_1__.defaultLineJoin;
        strokeState.lineWidth =
          lineWidth === undefined ? _canvas_js__WEBPACK_IMPORTED_MODULE_1__.defaultLineWidth : lineWidth;
        strokeState.miterLimit =
          miterLimit === undefined ? _canvas_js__WEBPACK_IMPORTED_MODULE_1__.defaultMiterLimit : miterLimit;
        strokeState.strokeStyle = (0,_colorlike_js__WEBPACK_IMPORTED_MODULE_6__.asColorLike)(
          textStrokeStyle.getColor() || _canvas_js__WEBPACK_IMPORTED_MODULE_1__.defaultStrokeStyle
        );
      }

      textState = this.textState_;
      const font = textStyle.getFont() || _canvas_js__WEBPACK_IMPORTED_MODULE_1__.defaultFont;
      (0,_canvas_js__WEBPACK_IMPORTED_MODULE_1__.registerFont)(font);
      const textScale = textStyle.getScaleArray();
      textState.overflow = textStyle.getOverflow();
      textState.font = font;
      textState.maxAngle = textStyle.getMaxAngle();
      textState.placement = textStyle.getPlacement();
      textState.textAlign = textStyle.getTextAlign();
      textState.repeat = textStyle.getRepeat();
      textState.justify = textStyle.getJustify();
      textState.textBaseline =
        textStyle.getTextBaseline() || _canvas_js__WEBPACK_IMPORTED_MODULE_1__.defaultTextBaseline;
      textState.backgroundFill = textStyle.getBackgroundFill();
      textState.backgroundStroke = textStyle.getBackgroundStroke();
      textState.padding = textStyle.getPadding() || _canvas_js__WEBPACK_IMPORTED_MODULE_1__.defaultPadding;
      textState.scale = textScale === undefined ? [1, 1] : textScale;

      const textOffsetX = textStyle.getOffsetX();
      const textOffsetY = textStyle.getOffsetY();
      const textRotateWithView = textStyle.getRotateWithView();
      const textRotation = textStyle.getRotation();
      this.text_ = textStyle.getText() || '';
      this.textOffsetX_ = textOffsetX === undefined ? 0 : textOffsetX;
      this.textOffsetY_ = textOffsetY === undefined ? 0 : textOffsetY;
      this.textRotateWithView_ =
        textRotateWithView === undefined ? false : textRotateWithView;
      this.textRotation_ = textRotation === undefined ? 0 : textRotation;

      this.strokeKey_ = strokeState
        ? (typeof strokeState.strokeStyle == 'string'
            ? strokeState.strokeStyle
            : (0,_util_js__WEBPACK_IMPORTED_MODULE_7__.getUid)(strokeState.strokeStyle)) +
          strokeState.lineCap +
          strokeState.lineDashOffset +
          '|' +
          strokeState.lineWidth +
          strokeState.lineJoin +
          strokeState.miterLimit +
          '[' +
          strokeState.lineDash.join() +
          ']'
        : '';
      this.textKey_ =
        textState.font +
        textState.scale +
        (textState.textAlign || '?') +
        (textState.repeat || '?') +
        (textState.justify || '?') +
        (textState.textBaseline || '?');
      this.fillKey_ = fillState
        ? typeof fillState.fillStyle == 'string'
          ? fillState.fillStyle
          : '|' + (0,_util_js__WEBPACK_IMPORTED_MODULE_7__.getUid)(fillState.fillStyle)
        : '';
    }
    this.declutterImageWithText_ = sharedData;
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CanvasTextBuilder);


/***/ }),

/***/ "./node_modules/ol/render/canvas/hitdetect.js":
/*!****************************************************!*\
  !*** ./node_modules/ol/render/canvas/hitdetect.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   HIT_DETECT_RESOLUTION: () => (/* binding */ HIT_DETECT_RESOLUTION),
/* harmony export */   createHitDetectionImageData: () => (/* binding */ createHitDetectionImageData),
/* harmony export */   hitDetect: () => (/* binding */ hitDetect)
/* harmony export */ });
/* harmony import */ var _Immediate_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Immediate.js */ "./node_modules/ol/render/canvas/Immediate.js");
/* harmony import */ var _style_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../style.js */ "./node_modules/ol/style/Icon.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../math.js */ "./node_modules/ol/math.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../dom.js */ "./node_modules/ol/dom.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../extent.js */ "./node_modules/ol/extent.js");
/**
 * @module ol/render/canvas/hitdetect
 */








const HIT_DETECT_RESOLUTION = 0.5;

/**
 * @param {import("../../size.js").Size} size Canvas size in css pixels.
 * @param {Array<import("../../transform.js").Transform>} transforms Transforms
 * for rendering features to all worlds of the viewport, from coordinates to css
 * pixels.
 * @param {Array<import("../../Feature.js").FeatureLike>} features
 * Features to consider for hit detection.
 * @param {import("../../style/Style.js").StyleFunction|undefined} styleFunction
 * Layer style function.
 * @param {import("../../extent.js").Extent} extent Extent.
 * @param {number} resolution Resolution.
 * @param {number} rotation Rotation.
 * @return {ImageData} Hit detection image data.
 */
function createHitDetectionImageData(
  size,
  transforms,
  features,
  styleFunction,
  extent,
  resolution,
  rotation
) {
  const width = size[0] * HIT_DETECT_RESOLUTION;
  const height = size[1] * HIT_DETECT_RESOLUTION;
  const context = (0,_dom_js__WEBPACK_IMPORTED_MODULE_0__.createCanvasContext2D)(width, height);
  context.imageSmoothingEnabled = false;
  const canvas = context.canvas;
  const renderer = new _Immediate_js__WEBPACK_IMPORTED_MODULE_1__["default"](
    context,
    HIT_DETECT_RESOLUTION,
    extent,
    null,
    rotation
  );
  const featureCount = features.length;
  // Stretch hit detection index to use the whole available color range
  const indexFactor = Math.floor((256 * 256 * 256 - 1) / featureCount);
  const featuresByZIndex = {};
  for (let i = 1; i <= featureCount; ++i) {
    const feature = features[i - 1];
    const featureStyleFunction = feature.getStyleFunction() || styleFunction;
    if (!featureStyleFunction) {
      continue;
    }
    let styles = featureStyleFunction(feature, resolution);
    if (!styles) {
      continue;
    }
    if (!Array.isArray(styles)) {
      styles = [styles];
    }
    const index = i * indexFactor;
    const color = index.toString(16).padStart(7, '#00000');
    for (let j = 0, jj = styles.length; j < jj; ++j) {
      const originalStyle = styles[j];
      const geometry = originalStyle.getGeometryFunction()(feature);
      if (!geometry || !(0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.intersects)(extent, geometry.getExtent())) {
        continue;
      }
      const style = originalStyle.clone();
      const fill = style.getFill();
      if (fill) {
        fill.setColor(color);
      }
      const stroke = style.getStroke();
      if (stroke) {
        stroke.setColor(color);
        stroke.setLineDash(null);
      }
      style.setText(undefined);
      const image = originalStyle.getImage();
      if (image) {
        const imgSize = image.getImageSize();
        if (!imgSize) {
          continue;
        }

        const imgContext = (0,_dom_js__WEBPACK_IMPORTED_MODULE_0__.createCanvasContext2D)(
          imgSize[0],
          imgSize[1],
          undefined,
          {alpha: false}
        );
        const img = imgContext.canvas;
        imgContext.fillStyle = color;
        imgContext.fillRect(0, 0, img.width, img.height);
        style.setImage(
          new _style_js__WEBPACK_IMPORTED_MODULE_3__["default"]({
            img: img,
            anchor: image.getAnchor(),
            anchorXUnits: 'pixels',
            anchorYUnits: 'pixels',
            offset: image.getOrigin(),
            opacity: 1,
            size: image.getSize(),
            scale: image.getScale(),
            rotation: image.getRotation(),
            rotateWithView: image.getRotateWithView(),
          })
        );
      }
      const zIndex = style.getZIndex() || 0;
      let byGeometryType = featuresByZIndex[zIndex];
      if (!byGeometryType) {
        byGeometryType = {};
        featuresByZIndex[zIndex] = byGeometryType;
        byGeometryType['Polygon'] = [];
        byGeometryType['Circle'] = [];
        byGeometryType['LineString'] = [];
        byGeometryType['Point'] = [];
      }
      const type = geometry.getType();
      if (type === 'GeometryCollection') {
        const geometries =
          /** @type {import("../../geom/GeometryCollection.js").default} */ (
            geometry
          ).getGeometriesArrayRecursive();
        for (let i = 0, ii = geometries.length; i < ii; ++i) {
          const geometry = geometries[i];
          byGeometryType[geometry.getType().replace('Multi', '')].push(
            geometry,
            style
          );
        }
      } else {
        byGeometryType[type.replace('Multi', '')].push(geometry, style);
      }
    }
  }

  const zIndexKeys = Object.keys(featuresByZIndex).map(Number).sort(_array_js__WEBPACK_IMPORTED_MODULE_4__.ascending);
  for (let i = 0, ii = zIndexKeys.length; i < ii; ++i) {
    const byGeometryType = featuresByZIndex[zIndexKeys[i]];
    for (const type in byGeometryType) {
      const geomAndStyle = byGeometryType[type];
      for (let j = 0, jj = geomAndStyle.length; j < jj; j += 2) {
        renderer.setStyle(geomAndStyle[j + 1]);
        for (let k = 0, kk = transforms.length; k < kk; ++k) {
          renderer.setTransform(transforms[k]);
          renderer.drawGeometry(geomAndStyle[j]);
        }
      }
    }
  }
  return context.getImageData(0, 0, canvas.width, canvas.height);
}

/**
 * @param {import("../../pixel").Pixel} pixel Pixel coordinate on the hit
 * detection canvas in css pixels.
 * @param {Array<F>} features Features. Has to
 * match the `features` array that was passed to `createHitDetectionImageData()`.
 * @param {ImageData} imageData Hit detection image data generated by
 * `createHitDetectionImageData()`.
 * @return {Array<F>} Features.
 * @template {import("../../Feature.js").FeatureLike} F
 */
function hitDetect(pixel, features, imageData) {
  const resultFeatures = [];
  if (imageData) {
    const x = Math.floor(Math.round(pixel[0]) * HIT_DETECT_RESOLUTION);
    const y = Math.floor(Math.round(pixel[1]) * HIT_DETECT_RESOLUTION);
    // The pixel coordinate is clamped down to the hit-detect canvas' size to account
    // for browsers returning coordinates slightly larger than the actual canvas size
    // due to a non-integer pixel ratio.
    const index =
      ((0,_math_js__WEBPACK_IMPORTED_MODULE_5__.clamp)(x, 0, imageData.width - 1) +
        (0,_math_js__WEBPACK_IMPORTED_MODULE_5__.clamp)(y, 0, imageData.height - 1) * imageData.width) *
      4;
    const r = imageData.data[index];
    const g = imageData.data[index + 1];
    const b = imageData.data[index + 2];
    const i = b + 256 * (g + 256 * r);
    const indexFactor = Math.floor((256 * 256 * 256 - 1) / features.length);
    if (i && i % indexFactor === 0) {
      resultFeatures.push(features[i / indexFactor - 1]);
    }
  }
  // @ts-ignore Features are copied from `features` to `resultFeatures` so the type should be the same
  return resultFeatures;
}


/***/ }),

/***/ "./node_modules/ol/render/canvas/style.js":
/*!************************************************!*\
  !*** ./node_modules/ol/render/canvas/style.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   buildRuleSet: () => (/* binding */ buildRuleSet),
/* harmony export */   buildStyle: () => (/* binding */ buildStyle),
/* harmony export */   flatStylesToStyleFunction: () => (/* binding */ flatStylesToStyleFunction),
/* harmony export */   rulesToStyleFunction: () => (/* binding */ rulesToStyleFunction)
/* harmony export */ });
/* harmony import */ var _style_Circle_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../style/Circle.js */ "./node_modules/ol/style/Circle.js");
/* harmony import */ var _style_Fill_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../style/Fill.js */ "./node_modules/ol/style/Fill.js");
/* harmony import */ var _style_Icon_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../style/Icon.js */ "./node_modules/ol/style/Icon.js");
/* harmony import */ var _style_RegularShape_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../style/RegularShape.js */ "./node_modules/ol/style/RegularShape.js");
/* harmony import */ var _style_Stroke_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../style/Stroke.js */ "./node_modules/ol/style/Stroke.js");
/* harmony import */ var _style_Style_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../style/Style.js */ "./node_modules/ol/style/Style.js");
/* harmony import */ var _style_Text_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../style/Text.js */ "./node_modules/ol/style/Text.js");
/* harmony import */ var _expr_expression_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../expr/expression.js */ "./node_modules/ol/expr/expression.js");
/* harmony import */ var _expr_cpu_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../expr/cpu.js */ "./node_modules/ol/expr/cpu.js");
/* harmony import */ var _size_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../size.js */ "./node_modules/ol/size.js");
/**
 * @module ol/render/canvas/style
 */












/**
 * @fileoverview This module includes functions to build styles for the canvas renderer.  Building
 * is composed of two steps: parsing and compiling.  The parsing step takes an encoded expression
 * and returns an instance of one of the expression classes.  The compiling step takes the
 * expression instance and returns a function that can be evaluated to return a literal value.  The
 * evaluator function should do as little allocation and work as possible.
 */

/**
 * @typedef {import("../../style/flat.js").FlatStyle} FlatStyle
 */

/**
 * @typedef {import("../../expr/expression.js").EncodedExpression} EncodedExpression
 */

/**
 * @typedef {import("../../expr/expression.js").ParsingContext} ParsingContext
 */

/**
 * @typedef {import("../../expr/expression.js").CallExpression} CallExpression
 */

/**
 * @typedef {import("../../expr/cpu.js").EvaluationContext} EvaluationContext
 */

/**
 * @typedef {import("../../expr/cpu.js").ExpressionEvaluator} ExpressionEvaluator
 */

/**
 * @param {EvaluationContext} context The evaluation context.
 * @return {boolean} Always true.
 */
function always(context) {
  return true;
}

/**
 * This function adapts a rule evaluator to the existing style function interface.
 * After we have deprecated the style function, we can use the compiled rules directly
 * and pass a more complete evaluation context (variables, zoom, time, etc.).
 *
 * @param {Array<import('../../style/flat.js').Rule>} rules The rules.
 * @return {import('../../style/Style.js').StyleFunction} A style function.
 */
function rulesToStyleFunction(rules) {
  const parsingContext = (0,_expr_expression_js__WEBPACK_IMPORTED_MODULE_0__.newParsingContext)();
  const evaluator = buildRuleSet(rules, parsingContext);
  const evaluationContext = (0,_expr_cpu_js__WEBPACK_IMPORTED_MODULE_1__.newEvaluationContext)();
  return function (feature, resolution) {
    evaluationContext.properties = feature.getPropertiesInternal();
    evaluationContext.resolution = resolution;
    return evaluator(evaluationContext);
  };
}

/**
 * This function adapts a style evaluator to the existing style function interface.
 * After we have deprecated the style function, we can use the compiled rules directly
 * and pass a more complete evaluation context (variables, zoom, time, etc.).
 *
 * @param {Array<import('../../style/flat.js').FlatStyle>} flatStyles The flat styles.
 * @return {import('../../style/Style.js').StyleFunction} A style function.
 */
function flatStylesToStyleFunction(flatStyles) {
  const parsingContext = (0,_expr_expression_js__WEBPACK_IMPORTED_MODULE_0__.newParsingContext)();
  const length = flatStyles.length;

  /**
   * @type {Array<StyleEvaluator>}
   */
  const evaluators = new Array(length);
  for (let i = 0; i < length; ++i) {
    evaluators[i] = buildStyle(flatStyles[i], parsingContext);
  }
  const evaluationContext = (0,_expr_cpu_js__WEBPACK_IMPORTED_MODULE_1__.newEvaluationContext)();

  /**
   * @type {Array<Style>}
   */
  const styles = new Array(length);

  return function (feature, resolution) {
    evaluationContext.properties = feature.getPropertiesInternal();
    evaluationContext.resolution = resolution;
    for (let i = 0; i < length; ++i) {
      styles[i] = evaluators[i](evaluationContext);
    }
    return styles;
  };
}

/**
 * @typedef {function(EvaluationContext):Array<Style>} RuleSetEvaluator
 */

/**
 * @typedef {Object} CompiledRule
 * @property {ExpressionEvaluator} filter The compiled filter evaluator.
 * @property {Array<StyleEvaluator>} styles The list of compiled style evaluators.
 */

/**
 * @param {Array<import('../../style/flat.js').Rule>} rules The rules.
 * @param {ParsingContext} context The parsing context.
 * @return {RuleSetEvaluator} The evaluator function.
 */
function buildRuleSet(rules, context) {
  const length = rules.length;

  /**
   * @type {Array<CompiledRule>}
   */
  const compiledRules = new Array(length);

  for (let i = 0; i < length; ++i) {
    const rule = rules[i];
    const filter =
      'filter' in rule
        ? (0,_expr_cpu_js__WEBPACK_IMPORTED_MODULE_1__.buildExpression)(rule.filter, _expr_expression_js__WEBPACK_IMPORTED_MODULE_0__.BooleanType, context)
        : always;

    /**
     * @type {Array<StyleEvaluator>}
     */
    let styles;
    if (Array.isArray(rule.style)) {
      const styleLength = rule.style.length;
      styles = new Array(styleLength);
      for (let j = 0; j < styleLength; ++j) {
        styles[j] = buildStyle(rule.style[j], context);
      }
    } else {
      styles = [buildStyle(rule.style, context)];
    }

    compiledRules[i] = {filter, styles};
  }

  return function (context) {
    /**
     * @type {Array<Style>}
     */
    const styles = [];

    let someMatched = false;
    for (let i = 0; i < length; ++i) {
      const filterEvaluator = compiledRules[i].filter;
      if (!filterEvaluator(context)) {
        continue;
      }
      if (rules[i].else && someMatched) {
        continue;
      }
      someMatched = true;
      for (const styleEvaluator of compiledRules[i].styles) {
        const style = styleEvaluator(context);
        if (!style) {
          continue;
        }
        styles.push(style);
      }
    }

    return styles;
  };
}

/**
 * @typedef {function(EvaluationContext):Style} StyleEvaluator
 */

/**
 * @param {FlatStyle} flatStyle A flat style literal.
 * @param {ParsingContext} context The parsing context.
 * @return {StyleEvaluator} A function that evaluates to a style.  The style returned by
 * this function will be reused between invocations.
 */
function buildStyle(flatStyle, context) {
  const evaluateFill = buildFill(flatStyle, '', context);
  const evaluateStroke = buildStroke(flatStyle, '', context);
  const evaluateText = buildText(flatStyle, context);
  const evaluateImage = buildImage(flatStyle, context);
  const evaluateZIndex = numberEvaluator(flatStyle, 'z-index', context);

  const style = new _style_Style_js__WEBPACK_IMPORTED_MODULE_2__["default"]();
  return function (context) {
    let empty = true;
    if (evaluateFill) {
      const fill = evaluateFill(context);
      if (fill) {
        empty = false;
      }
      style.setFill(fill);
    }
    if (evaluateStroke) {
      const stroke = evaluateStroke(context);
      if (stroke) {
        empty = false;
      }
      style.setStroke(stroke);
    }
    if (evaluateText) {
      const text = evaluateText(context);
      if (text) {
        empty = false;
      }
      style.setText(text);
    }
    if (evaluateImage) {
      const image = evaluateImage(context);
      if (image) {
        empty = false;
      }
      style.setImage(image);
    }
    if (evaluateZIndex) {
      style.setZIndex(evaluateZIndex(context));
    }
    if (empty) {
      return null;
    }
    return style;
  };
}

/**
 * @typedef {function(EvaluationContext):Fill} FillEvaluator
 */

/**
 * @param {FlatStyle} flatStyle The flat style.
 * @param {string} prefix The property prefix.
 * @param {ParsingContext} context The parsing context.
 * @return {FillEvaluator?} A function that evaluates to a fill.
 */
function buildFill(flatStyle, prefix, context) {
  const evaluateColor = colorLikeEvaluator(
    flatStyle,
    prefix + 'fill-color',
    context
  );
  if (!evaluateColor) {
    return null;
  }

  const fill = new _style_Fill_js__WEBPACK_IMPORTED_MODULE_3__["default"]();
  return function (context) {
    const color = evaluateColor(context);
    if (color === 'none') {
      return null;
    }
    fill.setColor(color);
    return fill;
  };
}

/**
 * @typedef {function(EvaluationContext):Stroke} StrokeEvaluator
 */

/**
 * @param {FlatStyle} flatStyle The flat style.
 * @param {string} prefix The property prefix.
 * @param {ParsingContext} context The parsing context.
 * @return {StrokeEvaluator?} A function the evaluates to a stroke.
 */
function buildStroke(flatStyle, prefix, context) {
  const evaluateWidth = numberEvaluator(
    flatStyle,
    prefix + 'stroke-width',
    context
  );

  const evaluateColor = colorLikeEvaluator(
    flatStyle,
    prefix + 'stroke-color',
    context
  );

  if (!evaluateWidth && !evaluateColor) {
    return null;
  }

  const evaluateLineCap = stringEvaluator(
    flatStyle,
    prefix + 'stroke-line-cap',
    context
  );

  const evaluateLineJoin = stringEvaluator(
    flatStyle,
    prefix + 'stroke-line-join',
    context
  );

  const evaluateLineDash = numberArrayEvaluator(
    flatStyle,
    prefix + 'stroke-line-dash',
    context
  );

  const evaluateLineDashOffset = numberEvaluator(
    flatStyle,
    prefix + 'stroke-line-dash-offset',
    context
  );

  const evaluateMiterLimit = numberEvaluator(
    flatStyle,
    prefix + 'stroke-miter-limit',
    context
  );

  const stroke = new _style_Stroke_js__WEBPACK_IMPORTED_MODULE_4__["default"]();
  return function (context) {
    if (evaluateColor) {
      const color = evaluateColor(context);
      if (color === 'none') {
        return null;
      }
      stroke.setColor(color);
    }

    if (evaluateWidth) {
      stroke.setWidth(evaluateWidth(context));
    }

    if (evaluateLineCap) {
      const lineCap = evaluateLineCap(context);
      if (lineCap !== 'butt' && lineCap !== 'round' && lineCap !== 'square') {
        throw new Error('Expected butt, round, or square line cap');
      }
      stroke.setLineCap(lineCap);
    }

    if (evaluateLineJoin) {
      const lineJoin = evaluateLineJoin(context);
      if (
        lineJoin !== 'bevel' &&
        lineJoin !== 'round' &&
        lineJoin !== 'miter'
      ) {
        throw new Error('Expected bevel, round, or miter line join');
      }
      stroke.setLineJoin(lineJoin);
    }

    if (evaluateLineDash) {
      stroke.setLineDash(evaluateLineDash(context));
    }

    if (evaluateLineDashOffset) {
      stroke.setLineDashOffset(evaluateLineDashOffset(context));
    }

    if (evaluateMiterLimit) {
      stroke.setMiterLimit(evaluateMiterLimit(context));
    }

    return stroke;
  };
}

/**
 * @typedef {function(EvaluationContext):Text} TextEvaluator
 */

/**
 * @param {FlatStyle} flatStyle The flat style.
 * @param {ParsingContext} context The parsing context.
 * @return {TextEvaluator?} A function that evaluates to a text symbolizer.
 */
function buildText(flatStyle, context) {
  const prefix = 'text-';

  // Currently, an Array<string> may be used for rich text support.  This doesn't
  // work with our expression syntax where arrays of strings are interpreted as
  // call expressions.  To support rich text, we could add a 'strings' operator
  // where all the following arguments would be string values.
  const evaluateValue = stringEvaluator(flatStyle, prefix + 'value', context);
  if (!evaluateValue) {
    return null;
  }

  const evaluateFill = buildFill(flatStyle, prefix, context);

  const evaluateBackgroundFill = buildFill(
    flatStyle,
    prefix + 'background-',
    context
  );

  const evaluateStroke = buildStroke(flatStyle, prefix, context);

  const evaluateBackgroundStroke = buildStroke(
    flatStyle,
    prefix + 'background-',
    context
  );

  const evaluateFont = stringEvaluator(flatStyle, prefix + 'font', context);

  const evaluateMaxAngle = numberEvaluator(
    flatStyle,
    prefix + 'max-angle',
    context
  );

  const evaluateOffsetX = numberEvaluator(
    flatStyle,
    prefix + 'offset-x',
    context
  );

  const evaluateOffsetY = numberEvaluator(
    flatStyle,
    prefix + 'offset-y',
    context
  );

  const evaluateOverflow = booleanEvaluator(
    flatStyle,
    prefix + 'overflow',
    context
  );

  const evaluatePlacement = stringEvaluator(
    flatStyle,
    prefix + 'placement',
    context
  );

  const evaluateRepeat = numberEvaluator(flatStyle, prefix + 'repeat', context);

  const evaluateScale = sizeLikeEvaluator(flatStyle, prefix + 'scale', context);

  const evaluateRotateWithView = booleanEvaluator(
    flatStyle,
    prefix + 'rotate-with-view',
    context
  );

  const evaluateRotation = numberEvaluator(
    flatStyle,
    prefix + 'rotation',
    context
  );

  const evaluateAlign = stringEvaluator(flatStyle, prefix + 'align', context);

  const evaluateJustify = stringEvaluator(
    flatStyle,
    prefix + 'justify',
    context
  );

  const evaluateBaseline = stringEvaluator(
    flatStyle,
    prefix + 'baseline',
    context
  );

  const evaluatePadding = numberArrayEvaluator(
    flatStyle,
    prefix + 'padding',
    context
  );

  const text = new _style_Text_js__WEBPACK_IMPORTED_MODULE_5__["default"]({});
  return function (context) {
    text.setText(evaluateValue(context));

    if (evaluateFill) {
      text.setFill(evaluateFill(context));
    }

    if (evaluateBackgroundFill) {
      text.setBackgroundFill(evaluateBackgroundFill(context));
    }

    if (evaluateStroke) {
      text.setStroke(evaluateStroke(context));
    }

    if (evaluateBackgroundStroke) {
      text.setBackgroundStroke(evaluateBackgroundStroke(context));
    }

    if (evaluateFont) {
      text.setFont(evaluateFont(context));
    }

    if (evaluateMaxAngle) {
      text.setMaxAngle(evaluateMaxAngle(context));
    }

    if (evaluateOffsetX) {
      text.setOffsetX(evaluateOffsetX(context));
    }

    if (evaluateOffsetY) {
      text.setOffsetY(evaluateOffsetY(context));
    }

    if (evaluateOverflow) {
      text.setOverflow(evaluateOverflow(context));
    }

    if (evaluatePlacement) {
      const placement = evaluatePlacement(context);
      if (placement !== 'point' && placement !== 'line') {
        throw new Error('Expected point or line for text-placement');
      }
      text.setPlacement(placement);
    }

    if (evaluateRepeat) {
      text.setRepeat(evaluateRepeat(context));
    }

    if (evaluateScale) {
      text.setScale(evaluateScale(context));
    }

    if (evaluateRotateWithView) {
      text.setRotateWithView(evaluateRotateWithView(context));
    }

    if (evaluateRotation) {
      text.setRotation(evaluateRotation(context));
    }

    if (evaluateAlign) {
      const textAlign = evaluateAlign(context);
      if (
        textAlign !== 'left' &&
        textAlign !== 'center' &&
        textAlign !== 'right' &&
        textAlign !== 'end' &&
        textAlign !== 'start'
      ) {
        throw new Error(
          'Expected left, right, center, start, or end for text-align'
        );
      }
      text.setTextAlign(textAlign);
    }

    if (evaluateJustify) {
      const justify = evaluateJustify(context);
      if (justify !== 'left' && justify !== 'right' && justify !== 'center') {
        throw new Error('Expected left, right, or center for text-justify');
      }
      text.setJustify(justify);
    }

    if (evaluateBaseline) {
      const textBaseline = evaluateBaseline(context);
      if (
        textBaseline !== 'bottom' &&
        textBaseline !== 'top' &&
        textBaseline !== 'middle' &&
        textBaseline !== 'alphabetic' &&
        textBaseline !== 'hanging'
      ) {
        throw new Error(
          'Expected bottom, top, middle, alphabetic, or hanging for text-baseline'
        );
      }
      text.setTextBaseline(textBaseline);
    }

    if (evaluatePadding) {
      text.setPadding(evaluatePadding(context));
    }

    return text;
  };
}

/**
 * @typedef {function(EvaluationContext):import("../../style/Image.js").default} ImageEvaluator
 */

/**
 * @param {FlatStyle} flatStyle The flat style.
 * @param {ParsingContext} context The parsing context.
 * @return {ImageEvaluator?} A function that evaluates to an image symbolizer.
 */
function buildImage(flatStyle, context) {
  if ('icon-src' in flatStyle) {
    return buildIcon(flatStyle, context);
  }

  if ('shape-points' in flatStyle) {
    return buildShape(flatStyle, context);
  }

  if ('circle-radius' in flatStyle) {
    return buildCircle(flatStyle, context);
  }

  return null;
}

/**
 * @param {FlatStyle} flatStyle The flat style.
 * @param {ParsingContext} context The parsing context.
 * @return {ImageEvaluator} A function that evaluates to an image symbolizer.
 */
function buildIcon(flatStyle, context) {
  const prefix = 'icon-';

  // required property
  const srcName = prefix + 'src';
  const src = requireString(flatStyle[srcName], srcName);

  // settable properties
  const evaluateAnchor = coordinateEvaluator(
    flatStyle,
    prefix + 'anchor',
    context
  );

  const evaluateScale = sizeLikeEvaluator(flatStyle, prefix + 'scale', context);

  const evaluateOpacity = numberEvaluator(
    flatStyle,
    prefix + 'opacity',
    context
  );

  const evaluateDisplacement = coordinateEvaluator(
    flatStyle,
    prefix + 'displacement',
    context
  );

  const evaluateRotation = numberEvaluator(
    flatStyle,
    prefix + 'rotation',
    context
  );

  const evaluateRotateWithView = booleanEvaluator(
    flatStyle,
    prefix + 'rotate-with-view',
    context
  );

  // the remaining symbolizer properties are not currently settable
  const anchorOrigin = optionalIconOrigin(flatStyle, prefix + 'anchor-origin');
  const anchorXUnits = optionalIconAnchorUnits(
    flatStyle,
    prefix + 'anchor-x-units'
  );
  const anchorYUnits = optionalIconAnchorUnits(
    flatStyle,
    prefix + 'anchor-y-units'
  );
  const color = optionalColorLike(flatStyle, prefix + 'color');
  const crossOrigin = optionalString(flatStyle, prefix + 'cross-origin');
  const offset = optionalNumberArray(flatStyle, prefix + 'offset');
  const offsetOrigin = optionalIconOrigin(flatStyle, prefix + 'offset-origin');
  const width = optionalNumber(flatStyle, prefix + 'width');
  const height = optionalNumber(flatStyle, prefix + 'height');
  const size = optionalSize(flatStyle, prefix + 'size');
  const declutterMode = optionalDeclutterMode(flatStyle, prefix + 'declutter');

  const icon = new _style_Icon_js__WEBPACK_IMPORTED_MODULE_6__["default"]({
    src,
    anchorOrigin,
    anchorXUnits,
    anchorYUnits,
    color,
    crossOrigin,
    offset,
    offsetOrigin,
    height,
    width,
    size,
    declutterMode,
  });

  return function (context) {
    if (evaluateOpacity) {
      icon.setOpacity(evaluateOpacity(context));
    }

    if (evaluateDisplacement) {
      icon.setDisplacement(evaluateDisplacement(context));
    }

    if (evaluateRotation) {
      icon.setRotation(evaluateRotation(context));
    }

    if (evaluateRotateWithView) {
      icon.setRotateWithView(evaluateRotateWithView(context));
    }

    if (evaluateScale) {
      icon.setScale(evaluateScale(context));
    }

    if (evaluateAnchor) {
      icon.setAnchor(evaluateAnchor(context));
    }
    return icon;
  };
}

/**
 * @param {FlatStyle} flatStyle The flat style.
 * @param {ParsingContext} context The parsing context.
 * @return {ImageEvaluator} A function that evaluates to an icon symbolizer.
 */
function buildShape(flatStyle, context) {
  const prefix = 'shape-';

  // required property
  const pointsName = prefix + 'points';
  const points = requireNumber(flatStyle[pointsName], pointsName);

  // settable properties
  const evaluateFill = buildFill(flatStyle, prefix, context);
  const evaluateStroke = buildStroke(flatStyle, prefix, context);
  const evaluateScale = sizeLikeEvaluator(flatStyle, prefix + 'scale', context);
  const evaluateDisplacement = coordinateEvaluator(
    flatStyle,
    prefix + 'displacement',
    context
  );
  const evaluateRotation = numberEvaluator(
    flatStyle,
    prefix + 'rotation',
    context
  );
  const evaluateRotateWithView = booleanEvaluator(
    flatStyle,
    prefix + 'rotate-with-view',
    context
  );

  // the remaining properties are not currently settable
  const radius = optionalNumber(flatStyle, prefix + 'radius');
  const radius1 = optionalNumber(flatStyle, prefix + 'radius1');
  const radius2 = optionalNumber(flatStyle, prefix + 'radius2');
  const angle = optionalNumber(flatStyle, prefix + 'angle');
  const declutterMode = optionalDeclutterMode(
    flatStyle,
    prefix + 'declutter-mode'
  );

  const shape = new _style_RegularShape_js__WEBPACK_IMPORTED_MODULE_7__["default"]({
    points,
    radius,
    radius1,
    radius2,
    angle,
    declutterMode,
  });

  return function (context) {
    if (evaluateFill) {
      shape.setFill(evaluateFill(context));
    }
    if (evaluateStroke) {
      shape.setStroke(evaluateStroke(context));
    }
    if (evaluateDisplacement) {
      shape.setDisplacement(evaluateDisplacement(context));
    }
    if (evaluateRotation) {
      shape.setRotation(evaluateRotation(context));
    }
    if (evaluateRotateWithView) {
      shape.setRotateWithView(evaluateRotateWithView(context));
    }
    if (evaluateScale) {
      shape.setScale(evaluateScale(context));
    }

    return shape;
  };
}

/**
 * @param {FlatStyle} flatStyle The flat style.
 * @param {ParsingContext} context The parsing context.
 * @return {ImageEvaluator} A function that evaluates to a circle symbolizer.
 */
function buildCircle(flatStyle, context) {
  const prefix = 'circle-';

  // settable properties
  const evaluateFill = buildFill(flatStyle, prefix, context);
  const evaluateStroke = buildStroke(flatStyle, prefix, context);
  const evaluateRadius = numberEvaluator(flatStyle, prefix + 'radius', context);
  const evaluateScale = sizeLikeEvaluator(flatStyle, prefix + 'scale', context);
  const evaluateDisplacement = coordinateEvaluator(
    flatStyle,
    prefix + 'displacement',
    context
  );
  const evaluateRotation = numberEvaluator(
    flatStyle,
    prefix + 'rotation',
    context
  );
  const evaluateRotateWithView = booleanEvaluator(
    flatStyle,
    prefix + 'rotate-with-view',
    context
  );

  // the remaining properties are not currently settable
  const declutterMode = optionalDeclutterMode(
    flatStyle,
    prefix + 'declutter-mode'
  );

  const circle = new _style_Circle_js__WEBPACK_IMPORTED_MODULE_8__["default"]({
    radius: 5, // this is arbitrary, but required - the evaluated radius is used below
    declutterMode,
  });

  return function (context) {
    if (evaluateRadius) {
      circle.setRadius(evaluateRadius(context));
    }
    if (evaluateFill) {
      circle.setFill(evaluateFill(context));
    }
    if (evaluateStroke) {
      circle.setStroke(evaluateStroke(context));
    }
    if (evaluateDisplacement) {
      circle.setDisplacement(evaluateDisplacement(context));
    }
    if (evaluateRotation) {
      circle.setRotation(evaluateRotation(context));
    }
    if (evaluateRotateWithView) {
      circle.setRotateWithView(evaluateRotateWithView(context));
    }
    if (evaluateScale) {
      circle.setScale(evaluateScale(context));
    }

    return circle;
  };
}

/**
 * @param {FlatStyle} flatStyle The flat style.
 * @param {string} name The property name.
 * @param {ParsingContext} context The parsing context.
 * @return {import('../../expr/cpu.js').NumberEvaluator|undefined} The expression evaluator or undefined.
 */
function numberEvaluator(flatStyle, name, context) {
  if (!(name in flatStyle)) {
    return undefined;
  }
  const evaluator = (0,_expr_cpu_js__WEBPACK_IMPORTED_MODULE_1__.buildExpression)(flatStyle[name], _expr_expression_js__WEBPACK_IMPORTED_MODULE_0__.NumberType, context);
  return function (context) {
    return requireNumber(evaluator(context), name);
  };
}

/**
 * @param {FlatStyle} flatStyle The flat style.
 * @param {string} name The property name.
 * @param {ParsingContext} context The parsing context.
 * @return {import('../../expr/cpu.js').StringEvaluator?} The expression evaluator.
 */
function stringEvaluator(flatStyle, name, context) {
  if (!(name in flatStyle)) {
    return null;
  }
  const evaluator = (0,_expr_cpu_js__WEBPACK_IMPORTED_MODULE_1__.buildExpression)(flatStyle[name], _expr_expression_js__WEBPACK_IMPORTED_MODULE_0__.StringType, context);
  return function (context) {
    return requireString(evaluator(context), name);
  };
}

/**
 * @param {FlatStyle} flatStyle The flat style.
 * @param {string} name The property name.
 * @param {ParsingContext} context The parsing context.
 * @return {import('../../expr/cpu.js').BooleanEvaluator?} The expression evaluator.
 */
function booleanEvaluator(flatStyle, name, context) {
  if (!(name in flatStyle)) {
    return null;
  }
  const evaluator = (0,_expr_cpu_js__WEBPACK_IMPORTED_MODULE_1__.buildExpression)(flatStyle[name], _expr_expression_js__WEBPACK_IMPORTED_MODULE_0__.BooleanType, context);
  return function (context) {
    const value = evaluator(context);
    if (typeof value !== 'boolean') {
      throw new Error(`Expected a boolean for ${name}`);
    }
    return value;
  };
}

/**
 * @param {FlatStyle} flatStyle The flat style.
 * @param {string} name The property name.
 * @param {ParsingContext} context The parsing context.
 * @return {import('../../expr/cpu.js').ColorLikeEvaluator?} The expression evaluator.
 */
function colorLikeEvaluator(flatStyle, name, context) {
  if (!(name in flatStyle)) {
    return null;
  }
  const evaluator = (0,_expr_cpu_js__WEBPACK_IMPORTED_MODULE_1__.buildExpression)(
    flatStyle[name],
    _expr_expression_js__WEBPACK_IMPORTED_MODULE_0__.ColorType | _expr_expression_js__WEBPACK_IMPORTED_MODULE_0__.StringType,
    context
  );
  return function (context) {
    return requireColorLike(evaluator(context), name);
  };
}

/**
 * @param {FlatStyle} flatStyle The flat style.
 * @param {string} name The property name.
 * @param {ParsingContext} context The parsing context.
 * @return {import('../../expr/cpu.js').NumberArrayEvaluator?} The expression evaluator.
 */
function numberArrayEvaluator(flatStyle, name, context) {
  if (!(name in flatStyle)) {
    return null;
  }
  const evaluator = (0,_expr_cpu_js__WEBPACK_IMPORTED_MODULE_1__.buildExpression)(flatStyle[name], _expr_expression_js__WEBPACK_IMPORTED_MODULE_0__.NumberArrayType, context);
  return function (context) {
    return requireNumberArray(evaluator(context), name);
  };
}

/**
 * @param {FlatStyle} flatStyle The flat style.
 * @param {string} name The property name.
 * @param {ParsingContext} context The parsing context.
 * @return {import('../../expr/cpu.js').CoordinateEvaluator?} The expression evaluator.
 */
function coordinateEvaluator(flatStyle, name, context) {
  if (!(name in flatStyle)) {
    return null;
  }
  const evaluator = (0,_expr_cpu_js__WEBPACK_IMPORTED_MODULE_1__.buildExpression)(flatStyle[name], _expr_expression_js__WEBPACK_IMPORTED_MODULE_0__.NumberArrayType, context);
  return function (context) {
    const array = requireNumberArray(evaluator(context), name);
    if (array.length !== 2) {
      throw new Error(`Expected two numbers for ${name}`);
    }
    return array;
  };
}

/**
 * @param {FlatStyle} flatStyle The flat style.
 * @param {string} name The property name.
 * @param {ParsingContext} context The parsing context.
 * @return {import('../../expr/cpu.js').SizeLikeEvaluator?} The expression evaluator.
 */
function sizeLikeEvaluator(flatStyle, name, context) {
  if (!(name in flatStyle)) {
    return null;
  }
  const evaluator = (0,_expr_cpu_js__WEBPACK_IMPORTED_MODULE_1__.buildExpression)(flatStyle[name], _expr_expression_js__WEBPACK_IMPORTED_MODULE_0__.NumberArrayType, context);
  return function (context) {
    return requireSizeLike(evaluator(context), name);
  };
}

/**
 * @param {FlatStyle} flatStyle The flat style.
 * @param {string} property The symbolizer property.
 * @return {number|undefined} A number or undefined.
 */
function optionalNumber(flatStyle, property) {
  const value = flatStyle[property];
  if (value === undefined) {
    return undefined;
  }
  if (typeof value !== 'number') {
    throw new Error(`Expected a number for ${property}`);
  }
  return value;
}

/**
 * @param {FlatStyle} flatStyle The flat style.
 * @param {string} property The symbolizer property.
 * @return {import("../../size.js").Size|undefined} A size or undefined.
 */
function optionalSize(flatStyle, property) {
  const encoded = flatStyle[property];
  if (encoded === undefined) {
    return undefined;
  }
  if (typeof encoded === 'number') {
    return (0,_size_js__WEBPACK_IMPORTED_MODULE_9__.toSize)(encoded);
  }
  if (!Array.isArray(encoded)) {
    throw new Error(`Expected a number or size array for ${property}`);
  }
  if (
    encoded.length !== 2 ||
    typeof encoded[0] !== 'number' ||
    typeof encoded[1] !== 'number'
  ) {
    throw new Error(`Expected a number or size array for ${property}`);
  }
  return encoded;
}

/**
 * @param {FlatStyle} flatStyle The flat style.
 * @param {string} property The symbolizer property.
 * @return {string|undefined} A string or undefined.
 */
function optionalString(flatStyle, property) {
  const encoded = flatStyle[property];
  if (encoded === undefined) {
    return undefined;
  }
  if (typeof encoded !== 'string') {
    throw new Error(`Expected a string for ${property}`);
  }
  return encoded;
}

/**
 * @param {FlatStyle} flatStyle The flat style.
 * @param {string} property The symbolizer property.
 * @return {import("../../style/Icon.js").IconOrigin|undefined} An icon origin or undefined.
 */
function optionalIconOrigin(flatStyle, property) {
  const encoded = flatStyle[property];
  if (encoded === undefined) {
    return undefined;
  }
  if (
    encoded !== 'bottom-left' &&
    encoded !== 'bottom-right' &&
    encoded !== 'top-left' &&
    encoded !== 'top-right'
  ) {
    throw new Error(
      `Expected bottom-left, bottom-right, top-left, or top-right for ${property}`
    );
  }
  return encoded;
}

/**
 * @param {FlatStyle} flatStyle The flat style.
 * @param {string} property The symbolizer property.
 * @return {import("../../style/Icon.js").IconAnchorUnits|undefined} Icon anchor units or undefined.
 */
function optionalIconAnchorUnits(flatStyle, property) {
  const encoded = flatStyle[property];
  if (encoded === undefined) {
    return undefined;
  }
  if (encoded !== 'pixels' && encoded !== 'fraction') {
    throw new Error(`Expected pixels or fraction for ${property}`);
  }
  return encoded;
}

/**
 * @param {FlatStyle} flatStyle The flat style.
 * @param {string} property The symbolizer property.
 * @return {Array<number>|undefined} An array of numbers or undefined.
 */
function optionalNumberArray(flatStyle, property) {
  const encoded = flatStyle[property];
  if (encoded === undefined) {
    return undefined;
  }
  return requireNumberArray(encoded, property);
}

/**
 * @param {FlatStyle} flatStyle The flat style.
 * @param {string} property The symbolizer property.
 * @return {"declutter"|"obstacle"|"none"|undefined} Icon declutter mode.
 */
function optionalDeclutterMode(flatStyle, property) {
  const encoded = flatStyle[property];
  if (encoded === undefined) {
    return undefined;
  }
  if (typeof encoded !== 'string') {
    throw new Error(`Expected a string for ${property}`);
  }
  if (encoded !== 'declutter' && encoded !== 'obstacle' && encoded !== 'none') {
    throw new Error(`Expected declutter, obstacle, or none for ${property}`);
  }
  return encoded;
}

/**
 * @param {FlatStyle} flatStyle The flat style.
 * @param {string} property The symbolizer property.
 * @return {string|Array<number>|undefined} A string or an array of color values or undefined.
 */
function optionalColorLike(flatStyle, property) {
  const encoded = flatStyle[property];
  if (encoded === undefined) {
    return undefined;
  }
  return requireColorLike(encoded, property);
}

/**
 * @param {any} value The value.
 * @param {string} property The property.
 * @return {Array<number>} An array of numbers.
 */
function requireNumberArray(value, property) {
  if (!Array.isArray(value)) {
    throw new Error(`Expected an array for ${property}`);
  }
  const length = value.length;
  for (let i = 0; i < length; ++i) {
    if (typeof value[i] !== 'number') {
      throw new Error(`Expected an array of numbers for ${property}`);
    }
  }
  return value;
}

/**
 * @param {any} value The value.
 * @param {string} property The property.
 * @return {string} A string.
 */
function requireString(value, property) {
  if (typeof value !== 'string') {
    throw new Error(`Expected a string for ${property}`);
  }
  return value;
}

/**
 * @param {any} value The value.
 * @param {string} property The property.
 * @return {number} A number.
 */
function requireNumber(value, property) {
  if (typeof value !== 'number') {
    throw new Error(`Expected a number for ${property}`);
  }
  return value;
}

/**
 * @param {any} value The value.
 * @param {string} property The property.
 * @return {Array<number>|string} A color.
 */
function requireColorLike(value, property) {
  if (typeof value === 'string') {
    return value;
  }
  const array = requireNumberArray(value, property);
  const length = array.length;
  if (length < 3 || length > 4) {
    throw new Error(`Expected a color with 3 or 4 values for ${property}`);
  }
  return array;
}

/**
 * @param {any} value The value.
 * @param {string} property The property.
 * @return {number|Array<number>} A number or an array of two numbers.
 */
function requireSizeLike(value, property) {
  if (typeof value === 'number') {
    return value;
  }
  const size = requireNumberArray(value, property);
  if (size.length !== 2) {
    throw new Error(`Expected an array of two numbers for ${property}`);
  }
  return size;
}


/***/ }),

/***/ "./node_modules/ol/renderer/Composite.js":
/*!***********************************************!*\
  !*** ./node_modules/ol/renderer/Composite.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Map_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Map.js */ "./node_modules/ol/renderer/Map.js");
/* harmony import */ var _ObjectEventType_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../ObjectEventType.js */ "./node_modules/ol/ObjectEventType.js");
/* harmony import */ var _render_Event_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../render/Event.js */ "./node_modules/ol/render/Event.js");
/* harmony import */ var _render_EventType_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../render/EventType.js */ "./node_modules/ol/render/EventType.js");
/* harmony import */ var _css_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../css.js */ "./node_modules/ol/css.js");
/* harmony import */ var _render_canvas_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../render/canvas.js */ "./node_modules/ol/render/canvas.js");
/* harmony import */ var _layer_Layer_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../layer/Layer.js */ "./node_modules/ol/layer/Layer.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../dom.js */ "./node_modules/ol/dom.js");
/**
 * @module ol/renderer/Composite
 */










/**
 * @classdesc
 * Canvas map renderer.
 * @api
 */
class CompositeMapRenderer extends _Map_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {import("../Map.js").default} map Map.
   */
  constructor(map) {
    super(map);

    /**
     * @type {import("../events.js").EventsKey}
     */
    this.fontChangeListenerKey_ = (0,_events_js__WEBPACK_IMPORTED_MODULE_1__.listen)(
      _render_canvas_js__WEBPACK_IMPORTED_MODULE_2__.checkedFonts,
      _ObjectEventType_js__WEBPACK_IMPORTED_MODULE_3__["default"].PROPERTYCHANGE,
      map.redrawText.bind(map)
    );

    /**
     * @private
     * @type {HTMLDivElement}
     */
    this.element_ = document.createElement('div');
    const style = this.element_.style;
    style.position = 'absolute';
    style.width = '100%';
    style.height = '100%';
    style.zIndex = '0';

    this.element_.className = _css_js__WEBPACK_IMPORTED_MODULE_4__.CLASS_UNSELECTABLE + ' ol-layers';

    const container = map.getViewport();
    container.insertBefore(this.element_, container.firstChild || null);

    /**
     * @private
     * @type {Array<HTMLElement>}
     */
    this.children_ = [];

    /**
     * @private
     * @type {boolean}
     */
    this.renderedVisible_ = true;

    /**
     * @type {Array<import("../layer/BaseVector.js").default>}
     */
    this.declutterLayers_ = [];
  }

  /**
   * @param {import("../render/EventType.js").default} type Event type.
   * @param {import("../Map.js").FrameState} frameState Frame state.
   */
  dispatchRenderEvent(type, frameState) {
    const map = this.getMap();
    if (map.hasListener(type)) {
      const event = new _render_Event_js__WEBPACK_IMPORTED_MODULE_5__["default"](type, undefined, frameState);
      map.dispatchEvent(event);
    }
  }

  disposeInternal() {
    (0,_events_js__WEBPACK_IMPORTED_MODULE_1__.unlistenByKey)(this.fontChangeListenerKey_);
    this.element_.parentNode.removeChild(this.element_);
    super.disposeInternal();
  }

  /**
   * Render.
   * @param {?import("../Map.js").FrameState} frameState Frame state.
   */
  renderFrame(frameState) {
    if (!frameState) {
      if (this.renderedVisible_) {
        this.element_.style.display = 'none';
        this.renderedVisible_ = false;
      }
      return;
    }

    this.calculateMatrices2D(frameState);
    this.dispatchRenderEvent(_render_EventType_js__WEBPACK_IMPORTED_MODULE_6__["default"].PRECOMPOSE, frameState);

    const layerStatesArray = frameState.layerStatesArray.sort(function (a, b) {
      return a.zIndex - b.zIndex;
    });
    const viewState = frameState.viewState;

    this.children_.length = 0;

    const declutterLayers = this.declutterLayers_;
    declutterLayers.length = 0;

    let previousElement = null;
    for (let i = 0, ii = layerStatesArray.length; i < ii; ++i) {
      const layerState = layerStatesArray[i];
      frameState.layerIndex = i;

      const layer = layerState.layer;
      const sourceState = layer.getSourceState();
      if (
        !(0,_layer_Layer_js__WEBPACK_IMPORTED_MODULE_7__.inView)(layerState, viewState) ||
        (sourceState != 'ready' && sourceState != 'undefined')
      ) {
        layer.unrender();
        continue;
      }

      const element = layer.render(frameState, previousElement);
      if (!element) {
        continue;
      }
      if (element !== previousElement) {
        this.children_.push(element);
        previousElement = element;
      }
      if ('getDeclutter' in layer) {
        declutterLayers.push(
          /** @type {import("../layer/BaseVector.js").default} */ (layer)
        );
      }
    }
    this.flushDeclutterItems(frameState);

    (0,_dom_js__WEBPACK_IMPORTED_MODULE_8__.replaceChildren)(this.element_, this.children_);

    this.dispatchRenderEvent(_render_EventType_js__WEBPACK_IMPORTED_MODULE_6__["default"].POSTCOMPOSE, frameState);

    if (!this.renderedVisible_) {
      this.element_.style.display = '';
      this.renderedVisible_ = true;
    }

    this.scheduleExpireIconCache(frameState);
  }

  /**
   * @param {import("../Map.js").FrameState} frameState Frame state.
   */
  flushDeclutterItems(frameState) {
    const layers = this.declutterLayers_;
    for (let i = layers.length - 1; i >= 0; --i) {
      layers[i].renderDeclutter(frameState);
    }
    layers.length = 0;
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CompositeMapRenderer);


/***/ }),

/***/ "./node_modules/ol/renderer/Layer.js":
/*!*******************************************!*\
  !*** ./node_modules/ol/renderer/Layer.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../events/EventType.js */ "./node_modules/ol/events/EventType.js");
/* harmony import */ var _ImageState_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../ImageState.js */ "./node_modules/ol/ImageState.js");
/* harmony import */ var _Observable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Observable.js */ "./node_modules/ol/Observable.js");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util.js */ "./node_modules/ol/util.js");
/**
 * @module ol/renderer/Layer
 */





/**
 * @template {import("../layer/Layer.js").default} LayerType
 */
class LayerRenderer extends _Observable_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {LayerType} layer Layer.
   */
  constructor(layer) {
    super();

    /**
     * The renderer is initialized and ready to render.
     * @type {boolean}
     */
    this.ready = true;

    /** @private */
    this.boundHandleImageChange_ = this.handleImageChange_.bind(this);

    /**
     * @protected
     * @type {LayerType}
     */
    this.layer_ = layer;

    /**
     * @type {import("../render/canvas/ExecutorGroup").default}
     */
    this.declutterExecutorGroup = null;
  }

  /**
   * Asynchronous layer level hit detection.
   * @param {import("../pixel.js").Pixel} pixel Pixel.
   * @return {Promise<Array<import("../Feature").FeatureLike>>} Promise that resolves with
   * an array of features.
   */
  getFeatures(pixel) {
    return (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.abstract)();
  }

  /**
   * @param {import("../pixel.js").Pixel} pixel Pixel.
   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.
   */
  getData(pixel) {
    return null;
  }

  /**
   * Determine whether render should be called.
   * @abstract
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @return {boolean} Layer is ready to be rendered.
   */
  prepareFrame(frameState) {
    return (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.abstract)();
  }

  /**
   * Render the layer.
   * @abstract
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @param {HTMLElement|null} target Target that may be used to render content to.
   * @return {HTMLElement|null} The rendered element.
   */
  renderFrame(frameState, target) {
    return (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.abstract)();
  }

  /**
   * @param {Object<number, Object<string, import("../Tile.js").default>>} tiles Lookup of loaded tiles by zoom level.
   * @param {number} zoom Zoom level.
   * @param {import("../Tile.js").default} tile Tile.
   * @return {boolean|void} If `false`, the tile will not be considered loaded.
   */
  loadedTileCallback(tiles, zoom, tile) {
    if (!tiles[zoom]) {
      tiles[zoom] = {};
    }
    tiles[zoom][tile.tileCoord.toString()] = tile;
    return undefined;
  }

  /**
   * Create a function that adds loaded tiles to the tile lookup.
   * @param {import("../source/Tile.js").default} source Tile source.
   * @param {import("../proj/Projection.js").default} projection Projection of the tiles.
   * @param {Object<number, Object<string, import("../Tile.js").default>>} tiles Lookup of loaded tiles by zoom level.
   * @return {function(number, import("../TileRange.js").default):boolean} A function that can be
   *     called with a zoom level and a tile range to add loaded tiles to the lookup.
   * @protected
   */
  createLoadedTileFinder(source, projection, tiles) {
    return (
      /**
       * @param {number} zoom Zoom level.
       * @param {import("../TileRange.js").default} tileRange Tile range.
       * @return {boolean} The tile range is fully loaded.
       */
      (zoom, tileRange) => {
        const callback = this.loadedTileCallback.bind(this, tiles, zoom);
        return source.forEachLoadedTile(projection, zoom, tileRange, callback);
      }
    );
  }
  /**
   * @abstract
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {import("./vector.js").FeatureCallback<T>} callback Feature callback.
   * @param {Array<import("./Map.js").HitMatch<T>>} matches The hit detected matches with tolerance.
   * @return {T|undefined} Callback result.
   * @template T
   */
  forEachFeatureAtCoordinate(
    coordinate,
    frameState,
    hitTolerance,
    callback,
    matches
  ) {
    return undefined;
  }

  /**
   * @return {LayerType} Layer.
   */
  getLayer() {
    return this.layer_;
  }

  /**
   * Perform action necessary to get the layer rendered after new fonts have loaded
   * @abstract
   */
  handleFontsChanged() {}

  /**
   * Handle changes in image state.
   * @param {import("../events/Event.js").default} event Image change event.
   * @private
   */
  handleImageChange_(event) {
    const image = /** @type {import("../Image.js").default} */ (event.target);
    if (
      image.getState() === _ImageState_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADED ||
      image.getState() === _ImageState_js__WEBPACK_IMPORTED_MODULE_2__["default"].ERROR
    ) {
      this.renderIfReadyAndVisible();
    }
  }

  /**
   * Load the image if not already loaded, and register the image change
   * listener if needed.
   * @param {import("../Image.js").default} image Image.
   * @return {boolean} `true` if the image is already loaded, `false` otherwise.
   * @protected
   */
  loadImage(image) {
    let imageState = image.getState();
    if (imageState != _ImageState_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADED && imageState != _ImageState_js__WEBPACK_IMPORTED_MODULE_2__["default"].ERROR) {
      image.addEventListener(_events_EventType_js__WEBPACK_IMPORTED_MODULE_3__["default"].CHANGE, this.boundHandleImageChange_);
    }
    if (imageState == _ImageState_js__WEBPACK_IMPORTED_MODULE_2__["default"].IDLE) {
      image.load();
      imageState = image.getState();
    }
    return imageState == _ImageState_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADED;
  }

  /**
   * @protected
   */
  renderIfReadyAndVisible() {
    const layer = this.getLayer();
    if (layer && layer.getVisible() && layer.getSourceState() === 'ready') {
      layer.changed();
    }
  }

  /**
   * Clean up.
   */
  disposeInternal() {
    delete this.layer_;
    super.disposeInternal();
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (LayerRenderer);


/***/ }),

/***/ "./node_modules/ol/renderer/Map.js":
/*!*****************************************!*\
  !*** ./node_modules/ol/renderer/Map.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Disposable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Disposable.js */ "./node_modules/ol/Disposable.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../functions.js */ "./node_modules/ol/functions.js");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util.js */ "./node_modules/ol/util.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../transform.js */ "./node_modules/ol/transform.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _style_IconImageCache_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../style/IconImageCache.js */ "./node_modules/ol/style/IconImageCache.js");
/* harmony import */ var _layer_Layer_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../layer/Layer.js */ "./node_modules/ol/layer/Layer.js");
/* harmony import */ var _coordinate_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../coordinate.js */ "./node_modules/ol/coordinate.js");
/**
 * @module ol/renderer/Map
 */









/**
 * @template T
 * @typedef HitMatch
 * @property {import("../Feature.js").FeatureLike} feature Feature.
 * @property {import("../layer/Layer.js").default} layer Layer.
 * @property {import("../geom/SimpleGeometry.js").default} geometry Geometry.
 * @property {number} distanceSq Squared distance.
 * @property {import("./vector.js").FeatureCallback<T>} callback Callback.
 */

/**
 * @abstract
 */
class MapRenderer extends _Disposable_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {import("../Map.js").default} map Map.
   */
  constructor(map) {
    super();

    /**
     * @private
     * @type {import("../Map.js").default}
     */
    this.map_ = map;
  }

  /**
   * @abstract
   * @param {import("../render/EventType.js").default} type Event type.
   * @param {import("../Map.js").FrameState} frameState Frame state.
   */
  dispatchRenderEvent(type, frameState) {
    (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.abstract)();
  }

  /**
   * @param {import("../Map.js").FrameState} frameState FrameState.
   * @protected
   */
  calculateMatrices2D(frameState) {
    const viewState = frameState.viewState;
    const coordinateToPixelTransform = frameState.coordinateToPixelTransform;
    const pixelToCoordinateTransform = frameState.pixelToCoordinateTransform;

    (0,_transform_js__WEBPACK_IMPORTED_MODULE_2__.compose)(
      coordinateToPixelTransform,
      frameState.size[0] / 2,
      frameState.size[1] / 2,
      1 / viewState.resolution,
      -1 / viewState.resolution,
      -viewState.rotation,
      -viewState.center[0],
      -viewState.center[1]
    );

    (0,_transform_js__WEBPACK_IMPORTED_MODULE_2__.makeInverse)(pixelToCoordinateTransform, coordinateToPixelTransform);
  }

  /**
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../Map.js").FrameState} frameState FrameState.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {boolean} checkWrapped Check for wrapped geometries.
   * @param {import("./vector.js").FeatureCallback<T>} callback Feature callback.
   * @param {S} thisArg Value to use as `this` when executing `callback`.
   * @param {function(this: U, import("../layer/Layer.js").default): boolean} layerFilter Layer filter
   *     function, only layers which are visible and for which this function
   *     returns `true` will be tested for features.  By default, all visible
   *     layers will be tested.
   * @param {U} thisArg2 Value to use as `this` when executing `layerFilter`.
   * @return {T|undefined} Callback result.
   * @template S,T,U
   */
  forEachFeatureAtCoordinate(
    coordinate,
    frameState,
    hitTolerance,
    checkWrapped,
    callback,
    thisArg,
    layerFilter,
    thisArg2
  ) {
    let result;
    const viewState = frameState.viewState;

    /**
     * @param {boolean} managed Managed layer.
     * @param {import("../Feature.js").FeatureLike} feature Feature.
     * @param {import("../layer/Layer.js").default} layer Layer.
     * @param {import("../geom/Geometry.js").default} geometry Geometry.
     * @return {T|undefined} Callback result.
     */
    function forEachFeatureAtCoordinate(managed, feature, layer, geometry) {
      return callback.call(thisArg, feature, managed ? layer : null, geometry);
    }

    const projection = viewState.projection;

    const translatedCoordinate = (0,_coordinate_js__WEBPACK_IMPORTED_MODULE_3__.wrapX)(coordinate.slice(), projection);
    const offsets = [[0, 0]];
    if (projection.canWrapX() && checkWrapped) {
      const projectionExtent = projection.getExtent();
      const worldWidth = (0,_extent_js__WEBPACK_IMPORTED_MODULE_4__.getWidth)(projectionExtent);
      offsets.push([-worldWidth, 0], [worldWidth, 0]);
    }

    const layerStates = frameState.layerStatesArray;
    const numLayers = layerStates.length;

    const matches = /** @type {Array<HitMatch<T>>} */ ([]);
    const tmpCoord = [];
    for (let i = 0; i < offsets.length; i++) {
      for (let j = numLayers - 1; j >= 0; --j) {
        const layerState = layerStates[j];
        const layer = layerState.layer;
        if (
          layer.hasRenderer() &&
          (0,_layer_Layer_js__WEBPACK_IMPORTED_MODULE_5__.inView)(layerState, viewState) &&
          layerFilter.call(thisArg2, layer)
        ) {
          const layerRenderer = layer.getRenderer();
          const source = layer.getSource();
          if (layerRenderer && source) {
            const coordinates = source.getWrapX()
              ? translatedCoordinate
              : coordinate;
            const callback = forEachFeatureAtCoordinate.bind(
              null,
              layerState.managed
            );
            tmpCoord[0] = coordinates[0] + offsets[i][0];
            tmpCoord[1] = coordinates[1] + offsets[i][1];
            result = layerRenderer.forEachFeatureAtCoordinate(
              tmpCoord,
              frameState,
              hitTolerance,
              callback,
              matches
            );
          }
          if (result) {
            return result;
          }
        }
      }
    }
    if (matches.length === 0) {
      return undefined;
    }
    const order = 1 / matches.length;
    matches.forEach((m, i) => (m.distanceSq += i * order));
    matches.sort((a, b) => a.distanceSq - b.distanceSq);
    matches.some((m) => {
      return (result = m.callback(m.feature, m.layer, m.geometry));
    });
    return result;
  }

  /**
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../Map.js").FrameState} frameState FrameState.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {boolean} checkWrapped Check for wrapped geometries.
   * @param {function(this: U, import("../layer/Layer.js").default): boolean} layerFilter Layer filter
   *     function, only layers which are visible and for which this function
   *     returns `true` will be tested for features.  By default, all visible
   *     layers will be tested.
   * @param {U} thisArg Value to use as `this` when executing `layerFilter`.
   * @return {boolean} Is there a feature at the given coordinate?
   * @template U
   */
  hasFeatureAtCoordinate(
    coordinate,
    frameState,
    hitTolerance,
    checkWrapped,
    layerFilter,
    thisArg
  ) {
    const hasFeature = this.forEachFeatureAtCoordinate(
      coordinate,
      frameState,
      hitTolerance,
      checkWrapped,
      _functions_js__WEBPACK_IMPORTED_MODULE_6__.TRUE,
      this,
      layerFilter,
      thisArg
    );

    return hasFeature !== undefined;
  }

  /**
   * @return {import("../Map.js").default} Map.
   */
  getMap() {
    return this.map_;
  }

  /**
   * Render.
   * @abstract
   * @param {?import("../Map.js").FrameState} frameState Frame state.
   */
  renderFrame(frameState) {
    (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.abstract)();
  }

  /**
   * @param {import("../Map.js").FrameState} frameState Frame state.
   */
  flushDeclutterItems(frameState) {}

  /**
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @protected
   */
  scheduleExpireIconCache(frameState) {
    if (_style_IconImageCache_js__WEBPACK_IMPORTED_MODULE_7__.shared.canExpireCache()) {
      frameState.postRenderFunctions.push(expireIconCache);
    }
  }
}

/**
 * @param {import("../Map.js").default} map Map.
 * @param {import("../Map.js").FrameState} frameState Frame state.
 */
function expireIconCache(map, frameState) {
  _style_IconImageCache_js__WEBPACK_IMPORTED_MODULE_7__.shared.expire();
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (MapRenderer);


/***/ }),

/***/ "./node_modules/ol/renderer/canvas/Layer.js":
/*!**************************************************!*\
  !*** ./node_modules/ol/renderer/canvas/Layer.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   canvasPool: () => (/* binding */ canvasPool),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Layer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Layer.js */ "./node_modules/ol/renderer/Layer.js");
/* harmony import */ var _render_Event_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../render/Event.js */ "./node_modules/ol/render/Event.js");
/* harmony import */ var _render_EventType_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../render/EventType.js */ "./node_modules/ol/render/EventType.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../transform.js */ "./node_modules/ol/transform.js");
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../color.js */ "./node_modules/ol/color.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../dom.js */ "./node_modules/ol/dom.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../extent.js */ "./node_modules/ol/extent.js");
/**
 * @module ol/renderer/canvas/Layer
 */









/**
 * @type {Array<HTMLCanvasElement>}
 */
const canvasPool = [];

/**
 * @type {CanvasRenderingContext2D}
 */
let pixelContext = null;

function createPixelContext() {
  pixelContext = (0,_dom_js__WEBPACK_IMPORTED_MODULE_0__.createCanvasContext2D)(1, 1, undefined, {
    willReadFrequently: true,
  });
}

/**
 * @abstract
 * @template {import("../../layer/Layer.js").default} LayerType
 * @extends {LayerRenderer<LayerType>}
 */
class CanvasLayerRenderer extends _Layer_js__WEBPACK_IMPORTED_MODULE_1__["default"] {
  /**
   * @param {LayerType} layer Layer.
   */
  constructor(layer) {
    super(layer);

    /**
     * @protected
     * @type {HTMLElement}
     */
    this.container = null;

    /**
     * @protected
     * @type {number}
     */
    this.renderedResolution;

    /**
     * A temporary transform.  The values in this transform should only be used in a
     * function that sets the values.
     * @protected
     * @type {import("../../transform.js").Transform}
     */
    this.tempTransform = (0,_transform_js__WEBPACK_IMPORTED_MODULE_2__.create)();

    /**
     * The transform for rendered pixels to viewport CSS pixels.  This transform must
     * be set when rendering a frame and may be used by other functions after rendering.
     * @protected
     * @type {import("../../transform.js").Transform}
     */
    this.pixelTransform = (0,_transform_js__WEBPACK_IMPORTED_MODULE_2__.create)();

    /**
     * The transform for viewport CSS pixels to rendered pixels.  This transform must
     * be set when rendering a frame and may be used by other functions after rendering.
     * @protected
     * @type {import("../../transform.js").Transform}
     */
    this.inversePixelTransform = (0,_transform_js__WEBPACK_IMPORTED_MODULE_2__.create)();

    /**
     * @type {CanvasRenderingContext2D}
     */
    this.context = null;

    /**
     * @type {boolean}
     */
    this.containerReused = false;

    /**
     * @private
     * @type {CanvasRenderingContext2D}
     */
    this.pixelContext_ = null;

    /**
     * @protected
     * @type {import("../../Map.js").FrameState|null}
     */
    this.frameState = null;
  }

  /**
   * @param {import('../../DataTile.js').ImageLike} image Image.
   * @param {number} col The column index.
   * @param {number} row The row index.
   * @return {Uint8ClampedArray|null} The image data.
   */
  getImageData(image, col, row) {
    if (!pixelContext) {
      createPixelContext();
    }
    pixelContext.clearRect(0, 0, 1, 1);

    let data;
    try {
      pixelContext.drawImage(image, col, row, 1, 1, 0, 0, 1, 1);
      data = pixelContext.getImageData(0, 0, 1, 1).data;
    } catch (err) {
      pixelContext = null;
      return null;
    }
    return data;
  }

  /**
   * @param {import('../../Map.js').FrameState} frameState Frame state.
   * @return {string} Background color.
   */
  getBackground(frameState) {
    const layer = this.getLayer();
    let background = layer.getBackground();
    if (typeof background === 'function') {
      background = background(frameState.viewState.resolution);
    }
    return background || undefined;
  }

  /**
   * Get a rendering container from an existing target, if compatible.
   * @param {HTMLElement} target Potential render target.
   * @param {string} transform CSS Transform.
   * @param {string} [backgroundColor] Background color.
   */
  useContainer(target, transform, backgroundColor) {
    const layerClassName = this.getLayer().getClassName();
    let container, context;
    if (
      target &&
      target.className === layerClassName &&
      (!backgroundColor ||
        (target &&
          target.style.backgroundColor &&
          (0,_array_js__WEBPACK_IMPORTED_MODULE_3__.equals)(
            (0,_color_js__WEBPACK_IMPORTED_MODULE_4__.asArray)(target.style.backgroundColor),
            (0,_color_js__WEBPACK_IMPORTED_MODULE_4__.asArray)(backgroundColor)
          )))
    ) {
      const canvas = target.firstElementChild;
      if (canvas instanceof HTMLCanvasElement) {
        context = canvas.getContext('2d');
      }
    }
    if (context && context.canvas.style.transform === transform) {
      // Container of the previous layer renderer can be used.
      this.container = target;
      this.context = context;
      this.containerReused = true;
    } else if (this.containerReused) {
      // Previously reused container cannot be used any more.
      this.container = null;
      this.context = null;
      this.containerReused = false;
    } else if (this.container) {
      this.container.style.backgroundColor = null;
    }
    if (!this.container) {
      container = document.createElement('div');
      container.className = layerClassName;
      let style = container.style;
      style.position = 'absolute';
      style.width = '100%';
      style.height = '100%';
      context = (0,_dom_js__WEBPACK_IMPORTED_MODULE_0__.createCanvasContext2D)();
      const canvas = context.canvas;
      container.appendChild(canvas);
      style = canvas.style;
      style.position = 'absolute';
      style.left = '0';
      style.transformOrigin = 'top left';
      this.container = container;
      this.context = context;
    }
    if (
      !this.containerReused &&
      backgroundColor &&
      !this.container.style.backgroundColor
    ) {
      this.container.style.backgroundColor = backgroundColor;
    }
  }

  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {import("../../extent.js").Extent} extent Clip extent.
   * @protected
   */
  clipUnrotated(context, frameState, extent) {
    const topLeft = (0,_extent_js__WEBPACK_IMPORTED_MODULE_5__.getTopLeft)(extent);
    const topRight = (0,_extent_js__WEBPACK_IMPORTED_MODULE_5__.getTopRight)(extent);
    const bottomRight = (0,_extent_js__WEBPACK_IMPORTED_MODULE_5__.getBottomRight)(extent);
    const bottomLeft = (0,_extent_js__WEBPACK_IMPORTED_MODULE_5__.getBottomLeft)(extent);

    (0,_transform_js__WEBPACK_IMPORTED_MODULE_2__.apply)(frameState.coordinateToPixelTransform, topLeft);
    (0,_transform_js__WEBPACK_IMPORTED_MODULE_2__.apply)(frameState.coordinateToPixelTransform, topRight);
    (0,_transform_js__WEBPACK_IMPORTED_MODULE_2__.apply)(frameState.coordinateToPixelTransform, bottomRight);
    (0,_transform_js__WEBPACK_IMPORTED_MODULE_2__.apply)(frameState.coordinateToPixelTransform, bottomLeft);

    const inverted = this.inversePixelTransform;
    (0,_transform_js__WEBPACK_IMPORTED_MODULE_2__.apply)(inverted, topLeft);
    (0,_transform_js__WEBPACK_IMPORTED_MODULE_2__.apply)(inverted, topRight);
    (0,_transform_js__WEBPACK_IMPORTED_MODULE_2__.apply)(inverted, bottomRight);
    (0,_transform_js__WEBPACK_IMPORTED_MODULE_2__.apply)(inverted, bottomLeft);

    context.save();
    context.beginPath();
    context.moveTo(Math.round(topLeft[0]), Math.round(topLeft[1]));
    context.lineTo(Math.round(topRight[0]), Math.round(topRight[1]));
    context.lineTo(Math.round(bottomRight[0]), Math.round(bottomRight[1]));
    context.lineTo(Math.round(bottomLeft[0]), Math.round(bottomLeft[1]));
    context.clip();
  }

  /**
   * @param {import("../../render/EventType.js").default} type Event type.
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @private
   */
  dispatchRenderEvent_(type, context, frameState) {
    const layer = this.getLayer();
    if (layer.hasListener(type)) {
      const event = new _render_Event_js__WEBPACK_IMPORTED_MODULE_6__["default"](
        type,
        this.inversePixelTransform,
        frameState,
        context
      );
      layer.dispatchEvent(event);
    }
  }

  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @protected
   */
  preRender(context, frameState) {
    this.frameState = frameState;
    this.dispatchRenderEvent_(_render_EventType_js__WEBPACK_IMPORTED_MODULE_7__["default"].PRERENDER, context, frameState);
  }

  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @protected
   */
  postRender(context, frameState) {
    this.dispatchRenderEvent_(_render_EventType_js__WEBPACK_IMPORTED_MODULE_7__["default"].POSTRENDER, context, frameState);
  }

  /**
   * Creates a transform for rendering to an element that will be rotated after rendering.
   * @param {import("../../coordinate.js").Coordinate} center Center.
   * @param {number} resolution Resolution.
   * @param {number} rotation Rotation.
   * @param {number} pixelRatio Pixel ratio.
   * @param {number} width Width of the rendered element (in pixels).
   * @param {number} height Height of the rendered element (in pixels).
   * @param {number} offsetX Offset on the x-axis in view coordinates.
   * @protected
   * @return {!import("../../transform.js").Transform} Transform.
   */
  getRenderTransform(
    center,
    resolution,
    rotation,
    pixelRatio,
    width,
    height,
    offsetX
  ) {
    const dx1 = width / 2;
    const dy1 = height / 2;
    const sx = pixelRatio / resolution;
    const sy = -sx;
    const dx2 = -center[0] + offsetX;
    const dy2 = -center[1];
    return (0,_transform_js__WEBPACK_IMPORTED_MODULE_2__.compose)(
      this.tempTransform,
      dx1,
      dy1,
      sx,
      sy,
      -rotation,
      dx2,
      dy2
    );
  }

  /**
   * Clean up.
   */
  disposeInternal() {
    delete this.frameState;
    super.disposeInternal();
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CanvasLayerRenderer);


/***/ }),

/***/ "./node_modules/ol/renderer/canvas/TileLayer.js":
/*!******************************************************!*\
  !*** ./node_modules/ol/renderer/canvas/TileLayer.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Layer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Layer.js */ "./node_modules/ol/renderer/canvas/Layer.js");
/* harmony import */ var _ImageTile_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../ImageTile.js */ "./node_modules/ol/ImageTile.js");
/* harmony import */ var _reproj_Tile_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../reproj/Tile.js */ "./node_modules/ol/reproj/Tile.js");
/* harmony import */ var _TileRange_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../TileRange.js */ "./node_modules/ol/TileRange.js");
/* harmony import */ var _TileState_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../TileState.js */ "./node_modules/ol/TileState.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../transform.js */ "./node_modules/ol/transform.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../proj.js */ "./node_modules/ol/proj.js");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../util.js */ "./node_modules/ol/util.js");
/* harmony import */ var _size_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../size.js */ "./node_modules/ol/size.js");
/**
 * @module ol/renderer/canvas/TileLayer
 */












/**
 * @classdesc
 * Canvas renderer for tile layers.
 * @api
 * @template {import("../../layer/Tile.js").default<import("../../source/Tile.js").default>|import("../../layer/VectorTile.js").default} [LayerType=import("../../layer/Tile.js").default<import("../../source/Tile.js").default>|import("../../layer/VectorTile.js").default]
 * @extends {CanvasLayerRenderer<LayerType>}
 */
class CanvasTileLayerRenderer extends _Layer_js__WEBPACK_IMPORTED_MODULE_1__["default"] {
  /**
   * @param {LayerType} tileLayer Tile layer.
   */
  constructor(tileLayer) {
    super(tileLayer);

    /**
     * Rendered extent has changed since the previous `renderFrame()` call
     * @type {boolean}
     */
    this.extentChanged = true;

    /**
     * @private
     * @type {?import("../../extent.js").Extent}
     */
    this.renderedExtent_ = null;

    /**
     * @protected
     * @type {number}
     */
    this.renderedPixelRatio;

    /**
     * @protected
     * @type {import("../../proj/Projection.js").default}
     */
    this.renderedProjection = null;

    /**
     * @protected
     * @type {number}
     */
    this.renderedRevision;

    /**
     * @protected
     * @type {!Array<import("../../Tile.js").default>}
     */
    this.renderedTiles = [];

    /**
     * @private
     * @type {boolean}
     */
    this.newTiles_ = false;

    /**
     * @protected
     * @type {import("../../extent.js").Extent}
     */
    this.tmpExtent = (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.createEmpty)();

    /**
     * @private
     * @type {import("../../TileRange.js").default}
     */
    this.tmpTileRange_ = new _TileRange_js__WEBPACK_IMPORTED_MODULE_3__["default"](0, 0, 0, 0);
  }

  /**
   * @protected
   * @param {import("../../Tile.js").default} tile Tile.
   * @return {boolean} Tile is drawable.
   */
  isDrawableTile(tile) {
    const tileLayer = this.getLayer();
    const tileState = tile.getState();
    const useInterimTilesOnError = tileLayer.getUseInterimTilesOnError();
    return (
      tileState == _TileState_js__WEBPACK_IMPORTED_MODULE_4__["default"].LOADED ||
      tileState == _TileState_js__WEBPACK_IMPORTED_MODULE_4__["default"].EMPTY ||
      (tileState == _TileState_js__WEBPACK_IMPORTED_MODULE_4__["default"].ERROR && !useInterimTilesOnError)
    );
  }

  /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {!import("../../Tile.js").default} Tile.
   */
  getTile(z, x, y, frameState) {
    const pixelRatio = frameState.pixelRatio;
    const projection = frameState.viewState.projection;
    const tileLayer = this.getLayer();
    const tileSource = tileLayer.getSource();
    let tile = tileSource.getTile(z, x, y, pixelRatio, projection);
    if (tile.getState() == _TileState_js__WEBPACK_IMPORTED_MODULE_4__["default"].ERROR) {
      if (tileLayer.getUseInterimTilesOnError() && tileLayer.getPreload() > 0) {
        // Preloaded tiles for lower resolutions might have finished loading.
        this.newTiles_ = true;
      }
    }
    if (!this.isDrawableTile(tile)) {
      tile = tile.getInterimTile();
    }
    return tile;
  }

  /**
   * @param {import("../../pixel.js").Pixel} pixel Pixel.
   * @return {Uint8ClampedArray} Data at the pixel location.
   */
  getData(pixel) {
    const frameState = this.frameState;
    if (!frameState) {
      return null;
    }

    const layer = this.getLayer();
    const coordinate = (0,_transform_js__WEBPACK_IMPORTED_MODULE_5__.apply)(
      frameState.pixelToCoordinateTransform,
      pixel.slice()
    );

    const layerExtent = layer.getExtent();
    if (layerExtent) {
      if (!(0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.containsCoordinate)(layerExtent, coordinate)) {
        return null;
      }
    }

    const pixelRatio = frameState.pixelRatio;
    const projection = frameState.viewState.projection;
    const viewState = frameState.viewState;
    const source = layer.getRenderSource();
    const tileGrid = source.getTileGridForProjection(viewState.projection);
    const tilePixelRatio = source.getTilePixelRatio(frameState.pixelRatio);

    for (
      let z = tileGrid.getZForResolution(viewState.resolution);
      z >= tileGrid.getMinZoom();
      --z
    ) {
      const tileCoord = tileGrid.getTileCoordForCoordAndZ(coordinate, z);
      const tile = source.getTile(
        z,
        tileCoord[1],
        tileCoord[2],
        pixelRatio,
        projection
      );
      if (
        !(tile instanceof _ImageTile_js__WEBPACK_IMPORTED_MODULE_6__["default"] || tile instanceof _reproj_Tile_js__WEBPACK_IMPORTED_MODULE_7__["default"]) ||
        (tile instanceof _reproj_Tile_js__WEBPACK_IMPORTED_MODULE_7__["default"] && tile.getState() === _TileState_js__WEBPACK_IMPORTED_MODULE_4__["default"].EMPTY)
      ) {
        return null;
      }

      if (tile.getState() !== _TileState_js__WEBPACK_IMPORTED_MODULE_4__["default"].LOADED) {
        continue;
      }

      const tileOrigin = tileGrid.getOrigin(z);
      const tileSize = (0,_size_js__WEBPACK_IMPORTED_MODULE_8__.toSize)(tileGrid.getTileSize(z));
      const tileResolution = tileGrid.getResolution(z);

      const col = Math.floor(
        tilePixelRatio *
          ((coordinate[0] - tileOrigin[0]) / tileResolution -
            tileCoord[1] * tileSize[0])
      );

      const row = Math.floor(
        tilePixelRatio *
          ((tileOrigin[1] - coordinate[1]) / tileResolution -
            tileCoord[2] * tileSize[1])
      );

      const gutter = Math.round(
        tilePixelRatio * source.getGutterForProjection(viewState.projection)
      );

      return this.getImageData(tile.getImage(), col + gutter, row + gutter);
    }

    return null;
  }

  /**
   * @param {Object<number, Object<string, import("../../Tile.js").default>>} tiles Lookup of loaded tiles by zoom level.
   * @param {number} zoom Zoom level.
   * @param {import("../../Tile.js").default} tile Tile.
   * @return {boolean|void} If `false`, the tile will not be considered loaded.
   */
  loadedTileCallback(tiles, zoom, tile) {
    if (this.isDrawableTile(tile)) {
      return super.loadedTileCallback(tiles, zoom, tile);
    }
    return false;
  }

  /**
   * Determine whether render should be called.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {boolean} Layer is ready to be rendered.
   */
  prepareFrame(frameState) {
    return !!this.getLayer().getSource();
  }

  /**
   * Render the layer.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {HTMLElement} target Target that may be used to render content to.
   * @return {HTMLElement} The rendered element.
   */
  renderFrame(frameState, target) {
    const layerState = frameState.layerStatesArray[frameState.layerIndex];
    const viewState = frameState.viewState;
    const projection = viewState.projection;
    const viewResolution = viewState.resolution;
    const viewCenter = viewState.center;
    const rotation = viewState.rotation;
    const pixelRatio = frameState.pixelRatio;

    const tileLayer = this.getLayer();
    const tileSource = tileLayer.getSource();
    const sourceRevision = tileSource.getRevision();
    const tileGrid = tileSource.getTileGridForProjection(projection);
    const z = tileGrid.getZForResolution(viewResolution, tileSource.zDirection);
    const tileResolution = tileGrid.getResolution(z);

    let extent = frameState.extent;
    const resolution = frameState.viewState.resolution;
    const tilePixelRatio = tileSource.getTilePixelRatio(pixelRatio);
    // desired dimensions of the canvas in pixels
    const width = Math.round(((0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.getWidth)(extent) / resolution) * pixelRatio);
    const height = Math.round(((0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.getHeight)(extent) / resolution) * pixelRatio);

    const layerExtent =
      layerState.extent && (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.fromUserExtent)(layerState.extent, projection);
    if (layerExtent) {
      extent = (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.getIntersection)(
        extent,
        (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.fromUserExtent)(layerState.extent, projection)
      );
    }

    const dx = (tileResolution * width) / 2 / tilePixelRatio;
    const dy = (tileResolution * height) / 2 / tilePixelRatio;
    const canvasExtent = [
      viewCenter[0] - dx,
      viewCenter[1] - dy,
      viewCenter[0] + dx,
      viewCenter[1] + dy,
    ];

    const tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z);

    /**
     * @type {Object<number, Object<string, import("../../Tile.js").default>>}
     */
    const tilesToDrawByZ = {};
    tilesToDrawByZ[z] = {};

    const findLoadedTiles = this.createLoadedTileFinder(
      tileSource,
      projection,
      tilesToDrawByZ
    );

    const tmpExtent = this.tmpExtent;
    const tmpTileRange = this.tmpTileRange_;
    this.newTiles_ = false;
    const viewport = rotation
      ? (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.getRotatedViewport)(
          viewState.center,
          resolution,
          rotation,
          frameState.size
        )
      : undefined;
    for (let x = tileRange.minX; x <= tileRange.maxX; ++x) {
      for (let y = tileRange.minY; y <= tileRange.maxY; ++y) {
        if (
          rotation &&
          !tileGrid.tileCoordIntersectsViewport([z, x, y], viewport)
        ) {
          continue;
        }
        const tile = this.getTile(z, x, y, frameState);
        if (this.isDrawableTile(tile)) {
          const uid = (0,_util_js__WEBPACK_IMPORTED_MODULE_9__.getUid)(this);
          if (tile.getState() == _TileState_js__WEBPACK_IMPORTED_MODULE_4__["default"].LOADED) {
            tilesToDrawByZ[z][tile.tileCoord.toString()] = tile;
            let inTransition = tile.inTransition(uid);
            if (inTransition && layerState.opacity !== 1) {
              // Skipping transition when layer is not fully opaque avoids visual artifacts.
              tile.endTransition(uid);
              inTransition = false;
            }
            if (
              !this.newTiles_ &&
              (inTransition || !this.renderedTiles.includes(tile))
            ) {
              this.newTiles_ = true;
            }
          }
          if (tile.getAlpha(uid, frameState.time) === 1) {
            // don't look for alt tiles if alpha is 1
            continue;
          }
        }

        const childTileRange = tileGrid.getTileCoordChildTileRange(
          tile.tileCoord,
          tmpTileRange,
          tmpExtent
        );

        let covered = false;
        if (childTileRange) {
          covered = findLoadedTiles(z + 1, childTileRange);
        }
        if (!covered) {
          tileGrid.forEachTileCoordParentTileRange(
            tile.tileCoord,
            findLoadedTiles,
            tmpTileRange,
            tmpExtent
          );
        }
      }
    }

    const canvasScale =
      ((tileResolution / viewResolution) * pixelRatio) / tilePixelRatio;

    // set forward and inverse pixel transforms
    (0,_transform_js__WEBPACK_IMPORTED_MODULE_5__.compose)(
      this.pixelTransform,
      frameState.size[0] / 2,
      frameState.size[1] / 2,
      1 / pixelRatio,
      1 / pixelRatio,
      rotation,
      -width / 2,
      -height / 2
    );

    const canvasTransform = (0,_transform_js__WEBPACK_IMPORTED_MODULE_5__.toString)(this.pixelTransform);

    this.useContainer(target, canvasTransform, this.getBackground(frameState));
    const context = this.context;
    const canvas = context.canvas;

    (0,_transform_js__WEBPACK_IMPORTED_MODULE_5__.makeInverse)(this.inversePixelTransform, this.pixelTransform);

    // set scale transform for calculating tile positions on the canvas
    (0,_transform_js__WEBPACK_IMPORTED_MODULE_5__.compose)(
      this.tempTransform,
      width / 2,
      height / 2,
      canvasScale,
      canvasScale,
      0,
      -width / 2,
      -height / 2
    );

    if (canvas.width != width || canvas.height != height) {
      canvas.width = width;
      canvas.height = height;
    } else if (!this.containerReused) {
      context.clearRect(0, 0, width, height);
    }

    if (layerExtent) {
      this.clipUnrotated(context, frameState, layerExtent);
    }

    if (!tileSource.getInterpolate()) {
      context.imageSmoothingEnabled = false;
    }

    this.preRender(context, frameState);

    this.renderedTiles.length = 0;
    /** @type {Array<number>} */
    let zs = Object.keys(tilesToDrawByZ).map(Number);
    zs.sort(_array_js__WEBPACK_IMPORTED_MODULE_10__.ascending);

    let clips, clipZs, currentClip;
    if (
      layerState.opacity === 1 &&
      (!this.containerReused ||
        tileSource.getOpaque(frameState.viewState.projection))
    ) {
      zs = zs.reverse();
    } else {
      clips = [];
      clipZs = [];
    }
    for (let i = zs.length - 1; i >= 0; --i) {
      const currentZ = zs[i];
      const currentTilePixelSize = tileSource.getTilePixelSize(
        currentZ,
        pixelRatio,
        projection
      );
      const currentResolution = tileGrid.getResolution(currentZ);
      const currentScale = currentResolution / tileResolution;
      const dx = currentTilePixelSize[0] * currentScale * canvasScale;
      const dy = currentTilePixelSize[1] * currentScale * canvasScale;
      const originTileCoord = tileGrid.getTileCoordForCoordAndZ(
        (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.getTopLeft)(canvasExtent),
        currentZ
      );
      const originTileExtent = tileGrid.getTileCoordExtent(originTileCoord);
      const origin = (0,_transform_js__WEBPACK_IMPORTED_MODULE_5__.apply)(this.tempTransform, [
        (tilePixelRatio * (originTileExtent[0] - canvasExtent[0])) /
          tileResolution,
        (tilePixelRatio * (canvasExtent[3] - originTileExtent[3])) /
          tileResolution,
      ]);
      const tileGutter =
        tilePixelRatio * tileSource.getGutterForProjection(projection);
      const tilesToDraw = tilesToDrawByZ[currentZ];
      for (const tileCoordKey in tilesToDraw) {
        const tile = /** @type {import("../../ImageTile.js").default} */ (
          tilesToDraw[tileCoordKey]
        );
        const tileCoord = tile.tileCoord;

        // Calculate integer positions and sizes so that tiles align
        const xIndex = originTileCoord[1] - tileCoord[1];
        const nextX = Math.round(origin[0] - (xIndex - 1) * dx);
        const yIndex = originTileCoord[2] - tileCoord[2];
        const nextY = Math.round(origin[1] - (yIndex - 1) * dy);
        const x = Math.round(origin[0] - xIndex * dx);
        const y = Math.round(origin[1] - yIndex * dy);
        const w = nextX - x;
        const h = nextY - y;
        const transition = z === currentZ;

        const inTransition =
          transition && tile.getAlpha((0,_util_js__WEBPACK_IMPORTED_MODULE_9__.getUid)(this), frameState.time) !== 1;
        let contextSaved = false;
        if (!inTransition) {
          if (clips) {
            // Clip mask for regions in this tile that already filled by a higher z tile
            currentClip = [x, y, x + w, y, x + w, y + h, x, y + h];
            for (let i = 0, ii = clips.length; i < ii; ++i) {
              if (z !== currentZ && currentZ < clipZs[i]) {
                const clip = clips[i];
                if (
                  (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.intersects)(
                    [x, y, x + w, y + h],
                    [clip[0], clip[3], clip[4], clip[7]]
                  )
                ) {
                  if (!contextSaved) {
                    context.save();
                    contextSaved = true;
                  }
                  context.beginPath();
                  // counter-clockwise (outer ring) for current tile
                  context.moveTo(currentClip[0], currentClip[1]);
                  context.lineTo(currentClip[2], currentClip[3]);
                  context.lineTo(currentClip[4], currentClip[5]);
                  context.lineTo(currentClip[6], currentClip[7]);
                  // clockwise (inner ring) for higher z tile
                  context.moveTo(clip[6], clip[7]);
                  context.lineTo(clip[4], clip[5]);
                  context.lineTo(clip[2], clip[3]);
                  context.lineTo(clip[0], clip[1]);
                  context.clip();
                }
              }
            }
            clips.push(currentClip);
            clipZs.push(currentZ);
          } else {
            context.clearRect(x, y, w, h);
          }
        }
        this.drawTileImage(
          tile,
          frameState,
          x,
          y,
          w,
          h,
          tileGutter,
          transition
        );
        if (clips && !inTransition) {
          if (contextSaved) {
            context.restore();
          }
          this.renderedTiles.unshift(tile);
        } else {
          this.renderedTiles.push(tile);
        }
        this.updateUsedTiles(frameState.usedTiles, tileSource, tile);
      }
    }

    this.renderedRevision = sourceRevision;
    this.renderedResolution = tileResolution;
    this.extentChanged =
      !this.renderedExtent_ || !(0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.equals)(this.renderedExtent_, canvasExtent);
    this.renderedExtent_ = canvasExtent;
    this.renderedPixelRatio = pixelRatio;
    this.renderedProjection = projection;

    this.manageTilePyramid(
      frameState,
      tileSource,
      tileGrid,
      pixelRatio,
      projection,
      extent,
      z,
      tileLayer.getPreload()
    );
    this.scheduleExpireCache(frameState, tileSource);

    this.postRender(context, frameState);

    if (layerState.extent) {
      context.restore();
    }
    context.imageSmoothingEnabled = true;

    if (canvasTransform !== canvas.style.transform) {
      canvas.style.transform = canvasTransform;
    }

    return this.container;
  }

  /**
   * @param {import("../../ImageTile.js").default} tile Tile.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {number} x Left of the tile.
   * @param {number} y Top of the tile.
   * @param {number} w Width of the tile.
   * @param {number} h Height of the tile.
   * @param {number} gutter Tile gutter.
   * @param {boolean} transition Apply an alpha transition.
   */
  drawTileImage(tile, frameState, x, y, w, h, gutter, transition) {
    const image = this.getTileImage(tile);
    if (!image) {
      return;
    }
    const uid = (0,_util_js__WEBPACK_IMPORTED_MODULE_9__.getUid)(this);
    const layerState = frameState.layerStatesArray[frameState.layerIndex];
    const alpha =
      layerState.opacity *
      (transition ? tile.getAlpha(uid, frameState.time) : 1);
    const alphaChanged = alpha !== this.context.globalAlpha;
    if (alphaChanged) {
      this.context.save();
      this.context.globalAlpha = alpha;
    }
    this.context.drawImage(
      image,
      gutter,
      gutter,
      image.width - 2 * gutter,
      image.height - 2 * gutter,
      x,
      y,
      w,
      h
    );

    if (alphaChanged) {
      this.context.restore();
    }
    if (alpha !== layerState.opacity) {
      frameState.animate = true;
    } else if (transition) {
      tile.endTransition(uid);
    }
  }

  /**
   * @return {HTMLCanvasElement} Image
   */
  getImage() {
    const context = this.context;
    return context ? context.canvas : null;
  }

  /**
   * Get the image from a tile.
   * @param {import("../../ImageTile.js").default} tile Tile.
   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.
   * @protected
   */
  getTileImage(tile) {
    return tile.getImage();
  }

  /**
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {import("../../source/Tile.js").default} tileSource Tile source.
   * @protected
   */
  scheduleExpireCache(frameState, tileSource) {
    if (tileSource.canExpireCache()) {
      /**
       * @param {import("../../source/Tile.js").default} tileSource Tile source.
       * @param {import("../../Map.js").default} map Map.
       * @param {import("../../Map.js").FrameState} frameState Frame state.
       */
      const postRenderFunction = function (tileSource, map, frameState) {
        const tileSourceKey = (0,_util_js__WEBPACK_IMPORTED_MODULE_9__.getUid)(tileSource);
        if (tileSourceKey in frameState.usedTiles) {
          tileSource.expireCache(
            frameState.viewState.projection,
            frameState.usedTiles[tileSourceKey]
          );
        }
      }.bind(null, tileSource);

      frameState.postRenderFunctions.push(
        /** @type {import("../../Map.js").PostRenderFunction} */ (
          postRenderFunction
        )
      );
    }
  }

  /**
   * @param {!Object<string, !Object<string, boolean>>} usedTiles Used tiles.
   * @param {import("../../source/Tile.js").default} tileSource Tile source.
   * @param {import('../../Tile.js').default} tile Tile.
   * @protected
   */
  updateUsedTiles(usedTiles, tileSource, tile) {
    // FIXME should we use tilesToDrawByZ instead?
    const tileSourceKey = (0,_util_js__WEBPACK_IMPORTED_MODULE_9__.getUid)(tileSource);
    if (!(tileSourceKey in usedTiles)) {
      usedTiles[tileSourceKey] = {};
    }
    usedTiles[tileSourceKey][tile.getKey()] = true;
  }

  /**
   * Manage tile pyramid.
   * This function performs a number of functions related to the tiles at the
   * current zoom and lower zoom levels:
   * - registers idle tiles in frameState.wantedTiles so that they are not
   *   discarded by the tile queue
   * - enqueues missing tiles
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {import("../../source/Tile.js").default} tileSource Tile source.
   * @param {import("../../tilegrid/TileGrid.js").default} tileGrid Tile grid.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../../proj/Projection.js").default} projection Projection.
   * @param {import("../../extent.js").Extent} extent Extent.
   * @param {number} currentZ Current Z.
   * @param {number} preload Load low resolution tiles up to `preload` levels.
   * @param {function(import("../../Tile.js").default):void} [tileCallback] Tile callback.
   * @protected
   */
  manageTilePyramid(
    frameState,
    tileSource,
    tileGrid,
    pixelRatio,
    projection,
    extent,
    currentZ,
    preload,
    tileCallback
  ) {
    const tileSourceKey = (0,_util_js__WEBPACK_IMPORTED_MODULE_9__.getUid)(tileSource);
    if (!(tileSourceKey in frameState.wantedTiles)) {
      frameState.wantedTiles[tileSourceKey] = {};
    }
    const wantedTiles = frameState.wantedTiles[tileSourceKey];
    const tileQueue = frameState.tileQueue;
    const minZoom = tileGrid.getMinZoom();
    const rotation = frameState.viewState.rotation;
    const viewport = rotation
      ? (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.getRotatedViewport)(
          frameState.viewState.center,
          frameState.viewState.resolution,
          rotation,
          frameState.size
        )
      : undefined;
    let tileCount = 0;
    let tile, tileRange, tileResolution, x, y, z;
    for (z = minZoom; z <= currentZ; ++z) {
      tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z, tileRange);
      tileResolution = tileGrid.getResolution(z);
      for (x = tileRange.minX; x <= tileRange.maxX; ++x) {
        for (y = tileRange.minY; y <= tileRange.maxY; ++y) {
          if (
            rotation &&
            !tileGrid.tileCoordIntersectsViewport([z, x, y], viewport)
          ) {
            continue;
          }
          if (currentZ - z <= preload) {
            ++tileCount;
            tile = tileSource.getTile(z, x, y, pixelRatio, projection);
            if (tile.getState() == _TileState_js__WEBPACK_IMPORTED_MODULE_4__["default"].IDLE) {
              wantedTiles[tile.getKey()] = true;
              if (!tileQueue.isKeyQueued(tile.getKey())) {
                tileQueue.enqueue([
                  tile,
                  tileSourceKey,
                  tileGrid.getTileCoordCenter(tile.tileCoord),
                  tileResolution,
                ]);
              }
            }
            if (tileCallback !== undefined) {
              tileCallback(tile);
            }
          } else {
            tileSource.useTile(z, x, y, projection);
          }
        }
      }
    }
    tileSource.updateCacheSize(tileCount, projection);
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CanvasTileLayerRenderer);


/***/ }),

/***/ "./node_modules/ol/renderer/canvas/VectorLayer.js":
/*!********************************************************!*\
  !*** ./node_modules/ol/renderer/canvas/VectorLayer.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _render_canvas_BuilderGroup_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../render/canvas/BuilderGroup.js */ "./node_modules/ol/render/canvas/BuilderGroup.js");
/* harmony import */ var _Layer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Layer.js */ "./node_modules/ol/renderer/canvas/Layer.js");
/* harmony import */ var _render_canvas_ExecutorGroup_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../render/canvas/ExecutorGroup.js */ "./node_modules/ol/render/canvas/ExecutorGroup.js");
/* harmony import */ var _render_EventType_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../render/EventType.js */ "./node_modules/ol/render/EventType.js");
/* harmony import */ var _ViewHint_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../ViewHint.js */ "./node_modules/ol/ViewHint.js");
/* harmony import */ var _render_canvas_hitdetect_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../render/canvas/hitdetect.js */ "./node_modules/ol/render/canvas/hitdetect.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../transform.js */ "./node_modules/ol/transform.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../dom.js */ "./node_modules/ol/dom.js");
/* harmony import */ var _vector_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../vector.js */ "./node_modules/ol/renderer/vector.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../proj.js */ "./node_modules/ol/proj.js");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../util.js */ "./node_modules/ol/util.js");
/* harmony import */ var _coordinate_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../coordinate.js */ "./node_modules/ol/coordinate.js");
/**
 * @module ol/renderer/canvas/VectorLayer
 */















/**
 * @classdesc
 * Canvas renderer for vector layers.
 * @api
 */
class CanvasVectorLayerRenderer extends _Layer_js__WEBPACK_IMPORTED_MODULE_1__["default"] {
  /**
   * @param {import("../../layer/BaseVector.js").default} vectorLayer Vector layer.
   */
  constructor(vectorLayer) {
    super(vectorLayer);

    /** @private */
    this.boundHandleStyleImageChange_ = this.handleStyleImageChange_.bind(this);

    /**
     * @type {boolean}
     */
    this.animatingOrInteracting_;

    /**
     * @type {ImageData|null}
     */
    this.hitDetectionImageData_ = null;

    /**
     * @type {Array<import("../../Feature.js").default>}
     */
    this.renderedFeatures_ = null;

    /**
     * @private
     * @type {number}
     */
    this.renderedRevision_ = -1;

    /**
     * @private
     * @type {number}
     */
    this.renderedResolution_ = NaN;

    /**
     * @private
     * @type {import("../../extent.js").Extent}
     */
    this.renderedExtent_ = (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.createEmpty)();

    /**
     * @private
     * @type {import("../../extent.js").Extent}
     */
    this.wrappedRenderedExtent_ = (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.createEmpty)();

    /**
     * @private
     * @type {number}
     */
    this.renderedRotation_;

    /**
     * @private
     * @type {import("../../coordinate").Coordinate}
     */
    this.renderedCenter_ = null;

    /**
     * @private
     * @type {import("../../proj/Projection").default}
     */
    this.renderedProjection_ = null;

    /**
     * @private
     * @type {function(import("../../Feature.js").default, import("../../Feature.js").default): number|null}
     */
    this.renderedRenderOrder_ = null;

    /**
     * @private
     * @type {import("../../render/canvas/ExecutorGroup").default}
     */
    this.replayGroup_ = null;

    /**
     * A new replay group had to be created by `prepareFrame()`
     * @type {boolean}
     */
    this.replayGroupChanged = true;

    /**
     * @type {import("../../render/canvas/ExecutorGroup").default}
     */
    this.declutterExecutorGroup = null;

    /**
     * Clipping to be performed by `renderFrame()`
     * @type {boolean}
     */
    this.clipping = true;

    /**
     * @private
     * @type {CanvasRenderingContext2D}
     */
    this.compositionContext_ = null;

    /**
     * @private
     * @type {number}
     */
    this.opacity_ = 1;
  }

  /**
   * @param {ExecutorGroup} executorGroup Executor group.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {import("rbush").default} [declutterTree] Declutter tree.
   */
  renderWorlds(executorGroup, frameState, declutterTree) {
    const extent = frameState.extent;
    const viewState = frameState.viewState;
    const center = viewState.center;
    const resolution = viewState.resolution;
    const projection = viewState.projection;
    const rotation = viewState.rotation;
    const projectionExtent = projection.getExtent();
    const vectorSource = this.getLayer().getSource();
    const pixelRatio = frameState.pixelRatio;
    const viewHints = frameState.viewHints;
    const snapToPixel = !(
      viewHints[_ViewHint_js__WEBPACK_IMPORTED_MODULE_3__["default"].ANIMATING] || viewHints[_ViewHint_js__WEBPACK_IMPORTED_MODULE_3__["default"].INTERACTING]
    );
    const context = this.compositionContext_;
    const width = Math.round(frameState.size[0] * pixelRatio);
    const height = Math.round(frameState.size[1] * pixelRatio);

    const multiWorld = vectorSource.getWrapX() && projection.canWrapX();
    const worldWidth = multiWorld ? (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.getWidth)(projectionExtent) : null;
    const endWorld = multiWorld
      ? Math.ceil((extent[2] - projectionExtent[2]) / worldWidth) + 1
      : 1;
    let world = multiWorld
      ? Math.floor((extent[0] - projectionExtent[0]) / worldWidth)
      : 0;
    do {
      const transform = this.getRenderTransform(
        center,
        resolution,
        rotation,
        pixelRatio,
        width,
        height,
        world * worldWidth
      );
      executorGroup.execute(
        context,
        1,
        transform,
        rotation,
        snapToPixel,
        undefined,
        declutterTree
      );
    } while (++world < endWorld);
  }

  setupCompositionContext_() {
    if (this.opacity_ !== 1) {
      const compositionContext = (0,_dom_js__WEBPACK_IMPORTED_MODULE_4__.createCanvasContext2D)(
        this.context.canvas.width,
        this.context.canvas.height,
        _Layer_js__WEBPACK_IMPORTED_MODULE_1__.canvasPool
      );
      this.compositionContext_ = compositionContext;
    } else {
      this.compositionContext_ = this.context;
    }
  }

  releaseCompositionContext_() {
    if (this.opacity_ !== 1) {
      const alpha = this.context.globalAlpha;
      this.context.globalAlpha = this.opacity_;
      this.context.drawImage(this.compositionContext_.canvas, 0, 0);
      this.context.globalAlpha = alpha;
      (0,_dom_js__WEBPACK_IMPORTED_MODULE_4__.releaseCanvas)(this.compositionContext_);
      _Layer_js__WEBPACK_IMPORTED_MODULE_1__.canvasPool.push(this.compositionContext_.canvas);
      this.compositionContext_ = null;
    }
  }

  /**
   * Render declutter items for this layer
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   */
  renderDeclutter(frameState) {
    if (this.declutterExecutorGroup) {
      this.setupCompositionContext_();
      this.renderWorlds(
        this.declutterExecutorGroup,
        frameState,
        frameState.declutterTree
      );
      this.releaseCompositionContext_();
    }
  }

  /**
   * Render the layer.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {HTMLElement|null} target Target that may be used to render content to.
   * @return {HTMLElement|null} The rendered element.
   */
  renderFrame(frameState, target) {
    const pixelRatio = frameState.pixelRatio;
    const layerState = frameState.layerStatesArray[frameState.layerIndex];

    // set forward and inverse pixel transforms
    (0,_transform_js__WEBPACK_IMPORTED_MODULE_5__.makeScale)(this.pixelTransform, 1 / pixelRatio, 1 / pixelRatio);
    (0,_transform_js__WEBPACK_IMPORTED_MODULE_5__.makeInverse)(this.inversePixelTransform, this.pixelTransform);

    const canvasTransform = (0,_transform_js__WEBPACK_IMPORTED_MODULE_5__.toString)(this.pixelTransform);

    this.useContainer(target, canvasTransform, this.getBackground(frameState));
    const context = this.context;
    const canvas = context.canvas;

    const replayGroup = this.replayGroup_;
    const declutterExecutorGroup = this.declutterExecutorGroup;
    let render =
      (replayGroup && !replayGroup.isEmpty()) ||
      (declutterExecutorGroup && !declutterExecutorGroup.isEmpty());
    if (!render) {
      const hasRenderListeners =
        this.getLayer().hasListener(_render_EventType_js__WEBPACK_IMPORTED_MODULE_6__["default"].PRERENDER) ||
        this.getLayer().hasListener(_render_EventType_js__WEBPACK_IMPORTED_MODULE_6__["default"].POSTRENDER);
      if (!hasRenderListeners) {
        return null;
      }
    }

    // resize and clear
    const width = Math.round(frameState.size[0] * pixelRatio);
    const height = Math.round(frameState.size[1] * pixelRatio);
    if (canvas.width != width || canvas.height != height) {
      canvas.width = width;
      canvas.height = height;
      if (canvas.style.transform !== canvasTransform) {
        canvas.style.transform = canvasTransform;
      }
    } else if (!this.containerReused) {
      context.clearRect(0, 0, width, height);
    }

    this.preRender(context, frameState);

    const viewState = frameState.viewState;
    const projection = viewState.projection;

    this.opacity_ = layerState.opacity;
    this.setupCompositionContext_();

    // clipped rendering if layer extent is set
    let clipped = false;
    if (render && layerState.extent && this.clipping) {
      const layerExtent = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.fromUserExtent)(layerState.extent, projection);
      render = (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.intersects)(layerExtent, frameState.extent);
      clipped = render && !(0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.containsExtent)(layerExtent, frameState.extent);
      if (clipped) {
        this.clipUnrotated(this.compositionContext_, frameState, layerExtent);
      }
    }

    if (render) {
      this.renderWorlds(replayGroup, frameState);
    }

    if (clipped) {
      this.compositionContext_.restore();
    }

    this.releaseCompositionContext_();

    this.postRender(context, frameState);

    if (this.renderedRotation_ !== viewState.rotation) {
      this.renderedRotation_ = viewState.rotation;
      this.hitDetectionImageData_ = null;
    }
    return this.container;
  }

  /**
   * Asynchronous layer level hit detection.
   * @param {import("../../pixel.js").Pixel} pixel Pixel.
   * @return {Promise<Array<import("../../Feature").default>>} Promise
   * that resolves with an array of features.
   */
  getFeatures(pixel) {
    return new Promise((resolve) => {
      if (!this.hitDetectionImageData_ && !this.animatingOrInteracting_) {
        const size = [this.context.canvas.width, this.context.canvas.height];
        (0,_transform_js__WEBPACK_IMPORTED_MODULE_5__.apply)(this.pixelTransform, size);
        const center = this.renderedCenter_;
        const resolution = this.renderedResolution_;
        const rotation = this.renderedRotation_;
        const projection = this.renderedProjection_;
        const extent = this.wrappedRenderedExtent_;
        const layer = this.getLayer();
        const transforms = [];
        const width = size[0] * _render_canvas_hitdetect_js__WEBPACK_IMPORTED_MODULE_7__.HIT_DETECT_RESOLUTION;
        const height = size[1] * _render_canvas_hitdetect_js__WEBPACK_IMPORTED_MODULE_7__.HIT_DETECT_RESOLUTION;
        transforms.push(
          this.getRenderTransform(
            center,
            resolution,
            rotation,
            _render_canvas_hitdetect_js__WEBPACK_IMPORTED_MODULE_7__.HIT_DETECT_RESOLUTION,
            width,
            height,
            0
          ).slice()
        );
        const source = layer.getSource();
        const projectionExtent = projection.getExtent();
        if (
          source.getWrapX() &&
          projection.canWrapX() &&
          !(0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.containsExtent)(projectionExtent, extent)
        ) {
          let startX = extent[0];
          const worldWidth = (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.getWidth)(projectionExtent);
          let world = 0;
          let offsetX;
          while (startX < projectionExtent[0]) {
            --world;
            offsetX = worldWidth * world;
            transforms.push(
              this.getRenderTransform(
                center,
                resolution,
                rotation,
                _render_canvas_hitdetect_js__WEBPACK_IMPORTED_MODULE_7__.HIT_DETECT_RESOLUTION,
                width,
                height,
                offsetX
              ).slice()
            );
            startX += worldWidth;
          }
          world = 0;
          startX = extent[2];
          while (startX > projectionExtent[2]) {
            ++world;
            offsetX = worldWidth * world;
            transforms.push(
              this.getRenderTransform(
                center,
                resolution,
                rotation,
                _render_canvas_hitdetect_js__WEBPACK_IMPORTED_MODULE_7__.HIT_DETECT_RESOLUTION,
                width,
                height,
                offsetX
              ).slice()
            );
            startX -= worldWidth;
          }
        }

        this.hitDetectionImageData_ = (0,_render_canvas_hitdetect_js__WEBPACK_IMPORTED_MODULE_7__.createHitDetectionImageData)(
          size,
          transforms,
          this.renderedFeatures_,
          layer.getStyleFunction(),
          extent,
          resolution,
          rotation
        );
      }
      resolve(
        (0,_render_canvas_hitdetect_js__WEBPACK_IMPORTED_MODULE_7__.hitDetect)(pixel, this.renderedFeatures_, this.hitDetectionImageData_)
      );
    });
  }

  /**
   * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {import("../vector.js").FeatureCallback<T>} callback Feature callback.
   * @param {Array<import("../Map.js").HitMatch<T>>} matches The hit detected matches with tolerance.
   * @return {T|undefined} Callback result.
   * @template T
   */
  forEachFeatureAtCoordinate(
    coordinate,
    frameState,
    hitTolerance,
    callback,
    matches
  ) {
    if (!this.replayGroup_) {
      return undefined;
    }
    const resolution = frameState.viewState.resolution;
    const rotation = frameState.viewState.rotation;
    const layer = this.getLayer();

    /** @type {!Object<string, import("../Map.js").HitMatch<T>|true>} */
    const features = {};

    /**
     * @param {import("../../Feature.js").FeatureLike} feature Feature.
     * @param {import("../../geom/SimpleGeometry.js").default} geometry Geometry.
     * @param {number} distanceSq The squared distance to the click position
     * @return {T|undefined} Callback result.
     */
    const featureCallback = function (feature, geometry, distanceSq) {
      const key = (0,_util_js__WEBPACK_IMPORTED_MODULE_8__.getUid)(feature);
      const match = features[key];
      if (!match) {
        if (distanceSq === 0) {
          features[key] = true;
          return callback(feature, layer, geometry);
        }
        matches.push(
          (features[key] = {
            feature: feature,
            layer: layer,
            geometry: geometry,
            distanceSq: distanceSq,
            callback: callback,
          })
        );
      } else if (match !== true && distanceSq < match.distanceSq) {
        if (distanceSq === 0) {
          features[key] = true;
          matches.splice(matches.lastIndexOf(match), 1);
          return callback(feature, layer, geometry);
        }
        match.geometry = geometry;
        match.distanceSq = distanceSq;
      }
      return undefined;
    };

    let result;
    const executorGroups = [this.replayGroup_];
    if (this.declutterExecutorGroup) {
      executorGroups.push(this.declutterExecutorGroup);
    }
    executorGroups.some((executorGroup) => {
      return (result = executorGroup.forEachFeatureAtCoordinate(
        coordinate,
        resolution,
        rotation,
        hitTolerance,
        featureCallback,
        executorGroup === this.declutterExecutorGroup &&
          frameState.declutterTree
          ? frameState.declutterTree.all().map((item) => item.value)
          : null
      ));
    });

    return result;
  }

  /**
   * Perform action necessary to get the layer rendered after new fonts have loaded
   */
  handleFontsChanged() {
    const layer = this.getLayer();
    if (layer.getVisible() && this.replayGroup_) {
      layer.changed();
    }
  }

  /**
   * Handle changes in image style state.
   * @param {import("../../events/Event.js").default} event Image style change event.
   * @private
   */
  handleStyleImageChange_(event) {
    this.renderIfReadyAndVisible();
  }

  /**
   * Determine whether render should be called.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {boolean} Layer is ready to be rendered.
   */
  prepareFrame(frameState) {
    const vectorLayer = this.getLayer();
    const vectorSource = vectorLayer.getSource();
    if (!vectorSource) {
      return false;
    }

    const animating = frameState.viewHints[_ViewHint_js__WEBPACK_IMPORTED_MODULE_3__["default"].ANIMATING];
    const interacting = frameState.viewHints[_ViewHint_js__WEBPACK_IMPORTED_MODULE_3__["default"].INTERACTING];
    const updateWhileAnimating = vectorLayer.getUpdateWhileAnimating();
    const updateWhileInteracting = vectorLayer.getUpdateWhileInteracting();

    if (
      (this.ready && !updateWhileAnimating && animating) ||
      (!updateWhileInteracting && interacting)
    ) {
      this.animatingOrInteracting_ = true;
      return true;
    }
    this.animatingOrInteracting_ = false;

    const frameStateExtent = frameState.extent;
    const viewState = frameState.viewState;
    const projection = viewState.projection;
    const resolution = viewState.resolution;
    const pixelRatio = frameState.pixelRatio;
    const vectorLayerRevision = vectorLayer.getRevision();
    const vectorLayerRenderBuffer = vectorLayer.getRenderBuffer();
    let vectorLayerRenderOrder = vectorLayer.getRenderOrder();

    if (vectorLayerRenderOrder === undefined) {
      vectorLayerRenderOrder = _vector_js__WEBPACK_IMPORTED_MODULE_9__.defaultOrder;
    }

    const center = viewState.center.slice();
    const extent = (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.buffer)(
      frameStateExtent,
      vectorLayerRenderBuffer * resolution
    );
    const renderedExtent = extent.slice();
    const loadExtents = [extent.slice()];
    const projectionExtent = projection.getExtent();

    if (
      vectorSource.getWrapX() &&
      projection.canWrapX() &&
      !(0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.containsExtent)(projectionExtent, frameState.extent)
    ) {
      // For the replay group, we need an extent that intersects the real world
      // (-180° to +180°). To support geometries in a coordinate range from -540°
      // to +540°, we add at least 1 world width on each side of the projection
      // extent. If the viewport is wider than the world, we need to add half of
      // the viewport width to make sure we cover the whole viewport.
      const worldWidth = (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.getWidth)(projectionExtent);
      const gutter = Math.max((0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.getWidth)(extent) / 2, worldWidth);
      extent[0] = projectionExtent[0] - gutter;
      extent[2] = projectionExtent[2] + gutter;
      (0,_coordinate_js__WEBPACK_IMPORTED_MODULE_10__.wrapX)(center, projection);
      const loadExtent = (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.wrapX)(loadExtents[0], projection);
      // If the extent crosses the date line, we load data for both edges of the worlds
      if (
        loadExtent[0] < projectionExtent[0] &&
        loadExtent[2] < projectionExtent[2]
      ) {
        loadExtents.push([
          loadExtent[0] + worldWidth,
          loadExtent[1],
          loadExtent[2] + worldWidth,
          loadExtent[3],
        ]);
      } else if (
        loadExtent[0] > projectionExtent[0] &&
        loadExtent[2] > projectionExtent[2]
      ) {
        loadExtents.push([
          loadExtent[0] - worldWidth,
          loadExtent[1],
          loadExtent[2] - worldWidth,
          loadExtent[3],
        ]);
      }
    }

    if (
      this.ready &&
      this.renderedResolution_ == resolution &&
      this.renderedRevision_ == vectorLayerRevision &&
      this.renderedRenderOrder_ == vectorLayerRenderOrder &&
      (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.containsExtent)(this.wrappedRenderedExtent_, extent)
    ) {
      if (!(0,_array_js__WEBPACK_IMPORTED_MODULE_11__.equals)(this.renderedExtent_, renderedExtent)) {
        this.hitDetectionImageData_ = null;
        this.renderedExtent_ = renderedExtent;
      }
      this.renderedCenter_ = center;
      this.replayGroupChanged = false;
      return true;
    }

    this.replayGroup_ = null;

    const replayGroup = new _render_canvas_BuilderGroup_js__WEBPACK_IMPORTED_MODULE_12__["default"](
      (0,_vector_js__WEBPACK_IMPORTED_MODULE_9__.getTolerance)(resolution, pixelRatio),
      extent,
      resolution,
      pixelRatio
    );

    let declutterBuilderGroup;
    if (this.getLayer().getDeclutter()) {
      declutterBuilderGroup = new _render_canvas_BuilderGroup_js__WEBPACK_IMPORTED_MODULE_12__["default"](
        (0,_vector_js__WEBPACK_IMPORTED_MODULE_9__.getTolerance)(resolution, pixelRatio),
        extent,
        resolution,
        pixelRatio
      );
    }

    const userProjection = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.getUserProjection)();
    let userTransform;
    if (userProjection) {
      for (let i = 0, ii = loadExtents.length; i < ii; ++i) {
        const extent = loadExtents[i];
        const userExtent = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.toUserExtent)(extent, projection);
        vectorSource.loadFeatures(
          userExtent,
          (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.toUserResolution)(resolution, projection),
          userProjection
        );
      }
      userTransform = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.getTransformFromProjections)(userProjection, projection);
    } else {
      for (let i = 0, ii = loadExtents.length; i < ii; ++i) {
        vectorSource.loadFeatures(loadExtents[i], resolution, projection);
      }
    }

    const squaredTolerance = (0,_vector_js__WEBPACK_IMPORTED_MODULE_9__.getSquaredTolerance)(resolution, pixelRatio);
    let ready = true;
    const render =
      /**
       * @param {import("../../Feature.js").default} feature Feature.
       */
      (feature) => {
        let styles;
        const styleFunction =
          feature.getStyleFunction() || vectorLayer.getStyleFunction();
        if (styleFunction) {
          styles = styleFunction(feature, resolution);
        }
        if (styles) {
          const dirty = this.renderFeature(
            feature,
            squaredTolerance,
            styles,
            replayGroup,
            userTransform,
            declutterBuilderGroup
          );
          ready = ready && !dirty;
        }
      };

    const userExtent = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.toUserExtent)(extent, projection);
    /** @type {Array<import("../../Feature.js").default>} */
    const features = vectorSource.getFeaturesInExtent(userExtent);
    if (vectorLayerRenderOrder) {
      features.sort(vectorLayerRenderOrder);
    }
    for (let i = 0, ii = features.length; i < ii; ++i) {
      render(features[i]);
    }
    this.renderedFeatures_ = features;
    this.ready = ready;

    const replayGroupInstructions = replayGroup.finish();
    const executorGroup = new _render_canvas_ExecutorGroup_js__WEBPACK_IMPORTED_MODULE_13__["default"](
      extent,
      resolution,
      pixelRatio,
      vectorSource.getOverlaps(),
      replayGroupInstructions,
      vectorLayer.getRenderBuffer()
    );

    if (declutterBuilderGroup) {
      this.declutterExecutorGroup = new _render_canvas_ExecutorGroup_js__WEBPACK_IMPORTED_MODULE_13__["default"](
        extent,
        resolution,
        pixelRatio,
        vectorSource.getOverlaps(),
        declutterBuilderGroup.finish(),
        vectorLayer.getRenderBuffer()
      );
    }

    this.renderedResolution_ = resolution;
    this.renderedRevision_ = vectorLayerRevision;
    this.renderedRenderOrder_ = vectorLayerRenderOrder;
    this.renderedExtent_ = renderedExtent;
    this.wrappedRenderedExtent_ = extent;
    this.renderedCenter_ = center;
    this.renderedProjection_ = projection;
    this.replayGroup_ = executorGroup;
    this.hitDetectionImageData_ = null;

    this.replayGroupChanged = true;
    return true;
  }

  /**
   * @param {import("../../Feature.js").default} feature Feature.
   * @param {number} squaredTolerance Squared render tolerance.
   * @param {import("../../style/Style.js").default|Array<import("../../style/Style.js").default>} styles The style or array of styles.
   * @param {import("../../render/canvas/BuilderGroup.js").default} builderGroup Builder group.
   * @param {import("../../proj.js").TransformFunction} [transform] Transform from user to view projection.
   * @param {import("../../render/canvas/BuilderGroup.js").default} [declutterBuilderGroup] Builder for decluttering.
   * @return {boolean} `true` if an image is loading.
   */
  renderFeature(
    feature,
    squaredTolerance,
    styles,
    builderGroup,
    transform,
    declutterBuilderGroup
  ) {
    if (!styles) {
      return false;
    }
    let loading = false;
    if (Array.isArray(styles)) {
      for (let i = 0, ii = styles.length; i < ii; ++i) {
        loading =
          (0,_vector_js__WEBPACK_IMPORTED_MODULE_9__.renderFeature)(
            builderGroup,
            feature,
            styles[i],
            squaredTolerance,
            this.boundHandleStyleImageChange_,
            transform,
            declutterBuilderGroup
          ) || loading;
      }
    } else {
      loading = (0,_vector_js__WEBPACK_IMPORTED_MODULE_9__.renderFeature)(
        builderGroup,
        feature,
        styles,
        squaredTolerance,
        this.boundHandleStyleImageChange_,
        transform,
        declutterBuilderGroup
      );
    }
    return loading;
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CanvasVectorLayerRenderer);


/***/ }),

/***/ "./node_modules/ol/renderer/vector.js":
/*!********************************************!*\
  !*** ./node_modules/ol/renderer/vector.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   defaultOrder: () => (/* binding */ defaultOrder),
/* harmony export */   getSquaredTolerance: () => (/* binding */ getSquaredTolerance),
/* harmony export */   getTolerance: () => (/* binding */ getTolerance),
/* harmony export */   renderFeature: () => (/* binding */ renderFeature)
/* harmony export */ });
/* harmony import */ var _ImageState_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ImageState.js */ "./node_modules/ol/ImageState.js");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util.js */ "./node_modules/ol/util.js");
/**
 * @module ol/renderer/vector
 */



/**
 * Feature callback. The callback will be called with three arguments. The first
 * argument is one {@link module:ol/Feature~Feature feature} or {@link module:ol/render/Feature~RenderFeature render feature}
 * at the pixel, the second is the {@link module:ol/layer/Layer~Layer layer} of the feature and will be null for
 * unmanaged layers. The third is the {@link module:ol/geom/SimpleGeometry~SimpleGeometry} of the feature. For features
 * with a GeometryCollection geometry, it will be the first detected geometry from the collection.
 * @template T
 * @typedef {function(import("../Feature.js").FeatureLike, import("../layer/Layer.js").default<import("../source/Source").default>, import("../geom/SimpleGeometry.js").default): T} FeatureCallback
 */

/**
 * Tolerance for geometry simplification in device pixels.
 * @type {number}
 */
const SIMPLIFY_TOLERANCE = 0.5;

/**
 * @const
 * @type {Object<import("../geom/Geometry.js").Type,
 *                function(import("../render/canvas/BuilderGroup.js").default, import("../geom/Geometry.js").default,
 *                         import("../style/Style.js").default, Object): void>}
 */
const GEOMETRY_RENDERERS = {
  'Point': renderPointGeometry,
  'LineString': renderLineStringGeometry,
  'Polygon': renderPolygonGeometry,
  'MultiPoint': renderMultiPointGeometry,
  'MultiLineString': renderMultiLineStringGeometry,
  'MultiPolygon': renderMultiPolygonGeometry,
  'GeometryCollection': renderGeometryCollectionGeometry,
  'Circle': renderCircleGeometry,
};

/**
 * @param {import("../Feature.js").FeatureLike} feature1 Feature 1.
 * @param {import("../Feature.js").FeatureLike} feature2 Feature 2.
 * @return {number} Order.
 */
function defaultOrder(feature1, feature2) {
  return parseInt((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.getUid)(feature1), 10) - parseInt((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.getUid)(feature2), 10);
}

/**
 * @param {number} resolution Resolution.
 * @param {number} pixelRatio Pixel ratio.
 * @return {number} Squared pixel tolerance.
 */
function getSquaredTolerance(resolution, pixelRatio) {
  const tolerance = getTolerance(resolution, pixelRatio);
  return tolerance * tolerance;
}

/**
 * @param {number} resolution Resolution.
 * @param {number} pixelRatio Pixel ratio.
 * @return {number} Pixel tolerance.
 */
function getTolerance(resolution, pixelRatio) {
  return (SIMPLIFY_TOLERANCE * resolution) / pixelRatio;
}

/**
 * @param {import("../render/canvas/BuilderGroup.js").default} builderGroup Builder group.
 * @param {import("../geom/Circle.js").default} geometry Geometry.
 * @param {import("../style/Style.js").default} style Style.
 * @param {import("../Feature.js").default} feature Feature.
 * @param {import("../render/canvas/BuilderGroup.js").default} [declutterBuilderGroup] Builder for decluttering.
 */
function renderCircleGeometry(
  builderGroup,
  geometry,
  style,
  feature,
  declutterBuilderGroup
) {
  const fillStyle = style.getFill();
  const strokeStyle = style.getStroke();
  if (fillStyle || strokeStyle) {
    const circleReplay = builderGroup.getBuilder(style.getZIndex(), 'Circle');
    circleReplay.setFillStrokeStyle(fillStyle, strokeStyle);
    circleReplay.drawCircle(geometry, feature);
  }
  const textStyle = style.getText();
  if (textStyle && textStyle.getText()) {
    const textReplay = (declutterBuilderGroup || builderGroup).getBuilder(
      style.getZIndex(),
      'Text'
    );
    textReplay.setTextStyle(textStyle);
    textReplay.drawText(geometry, feature);
  }
}

/**
 * @param {import("../render/canvas/BuilderGroup.js").default} replayGroup Replay group.
 * @param {import("../Feature.js").FeatureLike} feature Feature.
 * @param {import("../style/Style.js").default} style Style.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {function(import("../events/Event.js").default): void} listener Listener function.
 * @param {import("../proj.js").TransformFunction} [transform] Transform from user to view projection.
 * @param {import("../render/canvas/BuilderGroup.js").default} [declutterBuilderGroup] Builder for decluttering.
 * @return {boolean} `true` if style is loading.
 */
function renderFeature(
  replayGroup,
  feature,
  style,
  squaredTolerance,
  listener,
  transform,
  declutterBuilderGroup
) {
  let loading = false;
  const imageStyle = style.getImage();
  if (imageStyle) {
    const imageState = imageStyle.getImageState();
    if (imageState == _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADED || imageState == _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].ERROR) {
      imageStyle.unlistenImageChange(listener);
    } else {
      if (imageState == _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].IDLE) {
        imageStyle.load();
      }
      imageStyle.listenImageChange(listener);
      loading = true;
    }
  }
  renderFeatureInternal(
    replayGroup,
    feature,
    style,
    squaredTolerance,
    transform,
    declutterBuilderGroup
  );

  return loading;
}

/**
 * @param {import("../render/canvas/BuilderGroup.js").default} replayGroup Replay group.
 * @param {import("../Feature.js").FeatureLike} feature Feature.
 * @param {import("../style/Style.js").default} style Style.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {import("../proj.js").TransformFunction} [transform] Optional transform function.
 * @param {import("../render/canvas/BuilderGroup.js").default} [declutterBuilderGroup] Builder for decluttering.
 */
function renderFeatureInternal(
  replayGroup,
  feature,
  style,
  squaredTolerance,
  transform,
  declutterBuilderGroup
) {
  const geometry = style.getGeometryFunction()(feature);
  if (!geometry) {
    return;
  }
  const simplifiedGeometry = geometry.simplifyTransformed(
    squaredTolerance,
    transform
  );
  const renderer = style.getRenderer();
  if (renderer) {
    renderGeometry(replayGroup, simplifiedGeometry, style, feature);
  } else {
    const geometryRenderer = GEOMETRY_RENDERERS[simplifiedGeometry.getType()];
    geometryRenderer(
      replayGroup,
      simplifiedGeometry,
      style,
      feature,
      declutterBuilderGroup
    );
  }
}

/**
 * @param {import("../render/canvas/BuilderGroup.js").default} replayGroup Replay group.
 * @param {import("../geom/Geometry.js").default|import("../render/Feature.js").default} geometry Geometry.
 * @param {import("../style/Style.js").default} style Style.
 * @param {import("../Feature.js").FeatureLike} feature Feature.
 */
function renderGeometry(replayGroup, geometry, style, feature) {
  if (geometry.getType() == 'GeometryCollection') {
    const geometries =
      /** @type {import("../geom/GeometryCollection.js").default} */ (
        geometry
      ).getGeometries();
    for (let i = 0, ii = geometries.length; i < ii; ++i) {
      renderGeometry(replayGroup, geometries[i], style, feature);
    }
    return;
  }
  const replay = replayGroup.getBuilder(style.getZIndex(), 'Default');
  replay.drawCustom(
    /** @type {import("../geom/SimpleGeometry.js").default} */ (geometry),
    feature,
    style.getRenderer(),
    style.getHitDetectionRenderer()
  );
}

/**
 * @param {import("../render/canvas/BuilderGroup.js").default} replayGroup Replay group.
 * @param {import("../geom/GeometryCollection.js").default} geometry Geometry.
 * @param {import("../style/Style.js").default} style Style.
 * @param {import("../Feature.js").default} feature Feature.
 * @param {import("../render/canvas/BuilderGroup.js").default} [declutterBuilderGroup] Builder for decluttering.
 */
function renderGeometryCollectionGeometry(
  replayGroup,
  geometry,
  style,
  feature,
  declutterBuilderGroup
) {
  const geometries = geometry.getGeometriesArray();
  let i, ii;
  for (i = 0, ii = geometries.length; i < ii; ++i) {
    const geometryRenderer = GEOMETRY_RENDERERS[geometries[i].getType()];
    geometryRenderer(
      replayGroup,
      geometries[i],
      style,
      feature,
      declutterBuilderGroup
    );
  }
}

/**
 * @param {import("../render/canvas/BuilderGroup.js").default} builderGroup Replay group.
 * @param {import("../geom/LineString.js").default|import("../render/Feature.js").default} geometry Geometry.
 * @param {import("../style/Style.js").default} style Style.
 * @param {import("../Feature.js").FeatureLike} feature Feature.
 * @param {import("../render/canvas/BuilderGroup.js").default} [declutterBuilderGroup] Builder for decluttering.
 */
function renderLineStringGeometry(
  builderGroup,
  geometry,
  style,
  feature,
  declutterBuilderGroup
) {
  const strokeStyle = style.getStroke();
  if (strokeStyle) {
    const lineStringReplay = builderGroup.getBuilder(
      style.getZIndex(),
      'LineString'
    );
    lineStringReplay.setFillStrokeStyle(null, strokeStyle);
    lineStringReplay.drawLineString(geometry, feature);
  }
  const textStyle = style.getText();
  if (textStyle && textStyle.getText()) {
    const textReplay = (declutterBuilderGroup || builderGroup).getBuilder(
      style.getZIndex(),
      'Text'
    );
    textReplay.setTextStyle(textStyle);
    textReplay.drawText(geometry, feature);
  }
}

/**
 * @param {import("../render/canvas/BuilderGroup.js").default} builderGroup Replay group.
 * @param {import("../geom/MultiLineString.js").default|import("../render/Feature.js").default} geometry Geometry.
 * @param {import("../style/Style.js").default} style Style.
 * @param {import("../Feature.js").FeatureLike} feature Feature.
 * @param {import("../render/canvas/BuilderGroup.js").default} [declutterBuilderGroup] Builder for decluttering.
 */
function renderMultiLineStringGeometry(
  builderGroup,
  geometry,
  style,
  feature,
  declutterBuilderGroup
) {
  const strokeStyle = style.getStroke();
  if (strokeStyle) {
    const lineStringReplay = builderGroup.getBuilder(
      style.getZIndex(),
      'LineString'
    );
    lineStringReplay.setFillStrokeStyle(null, strokeStyle);
    lineStringReplay.drawMultiLineString(geometry, feature);
  }
  const textStyle = style.getText();
  if (textStyle && textStyle.getText()) {
    const textReplay = (declutterBuilderGroup || builderGroup).getBuilder(
      style.getZIndex(),
      'Text'
    );
    textReplay.setTextStyle(textStyle);
    textReplay.drawText(geometry, feature);
  }
}

/**
 * @param {import("../render/canvas/BuilderGroup.js").default} builderGroup Replay group.
 * @param {import("../geom/MultiPolygon.js").default} geometry Geometry.
 * @param {import("../style/Style.js").default} style Style.
 * @param {import("../Feature.js").default} feature Feature.
 * @param {import("../render/canvas/BuilderGroup.js").default} [declutterBuilderGroup] Builder for decluttering.
 */
function renderMultiPolygonGeometry(
  builderGroup,
  geometry,
  style,
  feature,
  declutterBuilderGroup
) {
  const fillStyle = style.getFill();
  const strokeStyle = style.getStroke();
  if (strokeStyle || fillStyle) {
    const polygonReplay = builderGroup.getBuilder(style.getZIndex(), 'Polygon');
    polygonReplay.setFillStrokeStyle(fillStyle, strokeStyle);
    polygonReplay.drawMultiPolygon(geometry, feature);
  }
  const textStyle = style.getText();
  if (textStyle && textStyle.getText()) {
    const textReplay = (declutterBuilderGroup || builderGroup).getBuilder(
      style.getZIndex(),
      'Text'
    );
    textReplay.setTextStyle(textStyle);
    textReplay.drawText(geometry, feature);
  }
}

/**
 * @param {import("../render/canvas/BuilderGroup.js").default} builderGroup Replay group.
 * @param {import("../geom/Point.js").default|import("../render/Feature.js").default} geometry Geometry.
 * @param {import("../style/Style.js").default} style Style.
 * @param {import("../Feature.js").FeatureLike} feature Feature.
 * @param {import("../render/canvas/BuilderGroup.js").default} [declutterBuilderGroup] Builder for decluttering.
 */
function renderPointGeometry(
  builderGroup,
  geometry,
  style,
  feature,
  declutterBuilderGroup
) {
  const imageStyle = style.getImage();
  const textStyle = style.getText();
  /** @type {import("../render/canvas.js").DeclutterImageWithText} */
  let declutterImageWithText;
  if (imageStyle) {
    if (imageStyle.getImageState() != _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADED) {
      return;
    }
    let imageBuilderGroup = builderGroup;
    if (declutterBuilderGroup) {
      const declutterMode = imageStyle.getDeclutterMode();
      if (declutterMode !== 'none') {
        imageBuilderGroup = declutterBuilderGroup;
        if (declutterMode === 'obstacle') {
          // draw in non-declutter group:
          const imageReplay = builderGroup.getBuilder(
            style.getZIndex(),
            'Image'
          );
          imageReplay.setImageStyle(imageStyle, declutterImageWithText);
          imageReplay.drawPoint(geometry, feature);
        } else if (textStyle && textStyle.getText()) {
          declutterImageWithText = {};
        }
      }
    }
    const imageReplay = imageBuilderGroup.getBuilder(
      style.getZIndex(),
      'Image'
    );
    imageReplay.setImageStyle(imageStyle, declutterImageWithText);
    imageReplay.drawPoint(geometry, feature);
  }
  if (textStyle && textStyle.getText()) {
    let textBuilderGroup = builderGroup;
    if (declutterBuilderGroup) {
      textBuilderGroup = declutterBuilderGroup;
    }
    const textReplay = textBuilderGroup.getBuilder(style.getZIndex(), 'Text');
    textReplay.setTextStyle(textStyle, declutterImageWithText);
    textReplay.drawText(geometry, feature);
  }
}

/**
 * @param {import("../render/canvas/BuilderGroup.js").default} builderGroup Replay group.
 * @param {import("../geom/MultiPoint.js").default|import("../render/Feature.js").default} geometry Geometry.
 * @param {import("../style/Style.js").default} style Style.
 * @param {import("../Feature.js").FeatureLike} feature Feature.
 * @param {import("../render/canvas/BuilderGroup.js").default} [declutterBuilderGroup] Builder for decluttering.
 */
function renderMultiPointGeometry(
  builderGroup,
  geometry,
  style,
  feature,
  declutterBuilderGroup
) {
  const imageStyle = style.getImage();
  const textStyle = style.getText();
  /** @type {import("../render/canvas.js").DeclutterImageWithText} */
  let declutterImageWithText;
  if (imageStyle) {
    if (imageStyle.getImageState() != _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADED) {
      return;
    }
    let imageBuilderGroup = builderGroup;
    if (declutterBuilderGroup) {
      const declutterMode = imageStyle.getDeclutterMode();
      if (declutterMode !== 'none') {
        imageBuilderGroup = declutterBuilderGroup;
        if (declutterMode === 'obstacle') {
          // draw in non-declutter group:
          const imageReplay = builderGroup.getBuilder(
            style.getZIndex(),
            'Image'
          );
          imageReplay.setImageStyle(imageStyle, declutterImageWithText);
          imageReplay.drawMultiPoint(geometry, feature);
        } else if (textStyle && textStyle.getText()) {
          declutterImageWithText = {};
        }
      }
    }
    const imageReplay = imageBuilderGroup.getBuilder(
      style.getZIndex(),
      'Image'
    );
    imageReplay.setImageStyle(imageStyle, declutterImageWithText);
    imageReplay.drawMultiPoint(geometry, feature);
  }
  if (textStyle && textStyle.getText()) {
    let textBuilderGroup = builderGroup;
    if (declutterBuilderGroup) {
      textBuilderGroup = declutterBuilderGroup;
    }
    const textReplay = textBuilderGroup.getBuilder(style.getZIndex(), 'Text');
    textReplay.setTextStyle(textStyle, declutterImageWithText);
    textReplay.drawText(geometry, feature);
  }
}

/**
 * @param {import("../render/canvas/BuilderGroup.js").default} builderGroup Replay group.
 * @param {import("../geom/Polygon.js").default|import("../render/Feature.js").default} geometry Geometry.
 * @param {import("../style/Style.js").default} style Style.
 * @param {import("../Feature.js").FeatureLike} feature Feature.
 * @param {import("../render/canvas/BuilderGroup.js").default} [declutterBuilderGroup] Builder for decluttering.
 */
function renderPolygonGeometry(
  builderGroup,
  geometry,
  style,
  feature,
  declutterBuilderGroup
) {
  const fillStyle = style.getFill();
  const strokeStyle = style.getStroke();
  if (fillStyle || strokeStyle) {
    const polygonReplay = builderGroup.getBuilder(style.getZIndex(), 'Polygon');
    polygonReplay.setFillStrokeStyle(fillStyle, strokeStyle);
    polygonReplay.drawPolygon(geometry, feature);
  }
  const textStyle = style.getText();
  if (textStyle && textStyle.getText()) {
    const textReplay = (declutterBuilderGroup || builderGroup).getBuilder(
      style.getZIndex(),
      'Text'
    );
    textReplay.setTextStyle(textStyle);
    textReplay.drawText(geometry, feature);
  }
}


/***/ }),

/***/ "./node_modules/ol/reproj.js":
/*!***********************************!*\
  !*** ./node_modules/ol/reproj.js ***!
  \***********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   calculateSourceExtentResolution: () => (/* binding */ calculateSourceExtentResolution),
/* harmony export */   calculateSourceResolution: () => (/* binding */ calculateSourceResolution),
/* harmony export */   canvasPool: () => (/* binding */ canvasPool),
/* harmony export */   render: () => (/* binding */ render)
/* harmony export */ });
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./dom.js */ "./node_modules/ol/dom.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./proj.js */ "./node_modules/ol/proj.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./math.js */ "./node_modules/ol/math.js");
/**
 * @module ol/reproj
 */





let brokenDiagonalRendering_;

/**
 * @type {Array<HTMLCanvasElement>}
 */
const canvasPool = [];

/**
 * This draws a small triangle into a canvas by setting the triangle as the clip region
 * and then drawing a (too large) rectangle
 *
 * @param {CanvasRenderingContext2D} ctx The context in which to draw the triangle
 * @param {number} u1 The x-coordinate of the second point. The first point is 0,0.
 * @param {number} v1 The y-coordinate of the second point.
 * @param {number} u2 The x-coordinate of the third point.
 * @param {number} v2 The y-coordinate of the third point.
 */
function drawTestTriangle(ctx, u1, v1, u2, v2) {
  ctx.beginPath();
  ctx.moveTo(0, 0);
  ctx.lineTo(u1, v1);
  ctx.lineTo(u2, v2);
  ctx.closePath();
  ctx.save();
  ctx.clip();
  ctx.fillRect(0, 0, Math.max(u1, u2) + 1, Math.max(v1, v2));
  ctx.restore();
}

/**
 * Given the data from getImageData, see if the right values appear at the provided offset.
 * Returns true if either the color or transparency is off
 *
 * @param {Uint8ClampedArray} data The data returned from getImageData
 * @param {number} offset The pixel offset from the start of data.
 * @return {boolean} true if the diagonal rendering is broken
 */
function verifyBrokenDiagonalRendering(data, offset) {
  // the values ought to be close to the rgba(210, 0, 0, 0.75)
  return (
    Math.abs(data[offset * 4] - 210) > 2 ||
    Math.abs(data[offset * 4 + 3] - 0.75 * 255) > 2
  );
}

/**
 * Determines if the current browser configuration can render triangular clip regions correctly.
 * This value is cached so the function is only expensive the first time called.
 * Firefox on Windows (as of now) does not if HWA is enabled. See https://bugzilla.mozilla.org/show_bug.cgi?id=1606976
 * Chrome works, and everything seems to work on OSX and Android. This function caches the
 * result. I suppose that it is conceivably possible that a browser might flip modes while the app is
 * running, but lets hope not.
 *
 * @return {boolean} true if the Diagonal Rendering is broken.
 */
function isBrokenDiagonalRendering() {
  if (brokenDiagonalRendering_ === undefined) {
    const ctx = (0,_dom_js__WEBPACK_IMPORTED_MODULE_1__.createCanvasContext2D)(6, 6, canvasPool);
    ctx.globalCompositeOperation = 'lighter';
    ctx.fillStyle = 'rgba(210, 0, 0, 0.75)';
    drawTestTriangle(ctx, 4, 5, 4, 0);
    drawTestTriangle(ctx, 4, 5, 0, 5);
    const data = ctx.getImageData(0, 0, 3, 3).data;
    brokenDiagonalRendering_ =
      verifyBrokenDiagonalRendering(data, 0) ||
      verifyBrokenDiagonalRendering(data, 4) ||
      verifyBrokenDiagonalRendering(data, 8);
    (0,_dom_js__WEBPACK_IMPORTED_MODULE_1__.releaseCanvas)(ctx);
    canvasPool.push(ctx.canvas);
  }

  return brokenDiagonalRendering_;
}

/**
 * Calculates ideal resolution to use from the source in order to achieve
 * pixel mapping as close as possible to 1:1 during reprojection.
 * The resolution is calculated regardless of what resolutions
 * are actually available in the dataset (TileGrid, Image, ...).
 *
 * @param {import("./proj/Projection.js").default} sourceProj Source projection.
 * @param {import("./proj/Projection.js").default} targetProj Target projection.
 * @param {import("./coordinate.js").Coordinate} targetCenter Target center.
 * @param {number} targetResolution Target resolution.
 * @return {number} The best resolution to use. Can be +-Infinity, NaN or 0.
 */
function calculateSourceResolution(
  sourceProj,
  targetProj,
  targetCenter,
  targetResolution
) {
  const sourceCenter = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.transform)(targetCenter, targetProj, sourceProj);

  // calculate the ideal resolution of the source data
  let sourceResolution = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.getPointResolution)(
    targetProj,
    targetResolution,
    targetCenter
  );

  const targetMetersPerUnit = targetProj.getMetersPerUnit();
  if (targetMetersPerUnit !== undefined) {
    sourceResolution *= targetMetersPerUnit;
  }
  const sourceMetersPerUnit = sourceProj.getMetersPerUnit();
  if (sourceMetersPerUnit !== undefined) {
    sourceResolution /= sourceMetersPerUnit;
  }

  // Based on the projection properties, the point resolution at the specified
  // coordinates may be slightly different. We need to reverse-compensate this
  // in order to achieve optimal results.

  const sourceExtent = sourceProj.getExtent();
  if (!sourceExtent || (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.containsCoordinate)(sourceExtent, sourceCenter)) {
    const compensationFactor =
      (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.getPointResolution)(sourceProj, sourceResolution, sourceCenter) /
      sourceResolution;
    if (isFinite(compensationFactor) && compensationFactor > 0) {
      sourceResolution /= compensationFactor;
    }
  }

  return sourceResolution;
}

/**
 * Calculates ideal resolution to use from the source in order to achieve
 * pixel mapping as close as possible to 1:1 during reprojection.
 * The resolution is calculated regardless of what resolutions
 * are actually available in the dataset (TileGrid, Image, ...).
 *
 * @param {import("./proj/Projection.js").default} sourceProj Source projection.
 * @param {import("./proj/Projection.js").default} targetProj Target projection.
 * @param {import("./extent.js").Extent} targetExtent Target extent
 * @param {number} targetResolution Target resolution.
 * @return {number} The best resolution to use. Can be +-Infinity, NaN or 0.
 */
function calculateSourceExtentResolution(
  sourceProj,
  targetProj,
  targetExtent,
  targetResolution
) {
  const targetCenter = (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.getCenter)(targetExtent);
  let sourceResolution = calculateSourceResolution(
    sourceProj,
    targetProj,
    targetCenter,
    targetResolution
  );

  if (!isFinite(sourceResolution) || sourceResolution <= 0) {
    (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.forEachCorner)(targetExtent, function (corner) {
      sourceResolution = calculateSourceResolution(
        sourceProj,
        targetProj,
        corner,
        targetResolution
      );
      return isFinite(sourceResolution) && sourceResolution > 0;
    });
  }

  return sourceResolution;
}

/**
 * @typedef {Object} ImageExtent
 * @property {import("./extent.js").Extent} extent Extent.
 * @property {import('./DataTile.js').ImageLike} image Image.
 */

/**
 * Renders the source data into new canvas based on the triangulation.
 *
 * @param {number} width Width of the canvas.
 * @param {number} height Height of the canvas.
 * @param {number} pixelRatio Pixel ratio.
 * @param {number} sourceResolution Source resolution.
 * @param {import("./extent.js").Extent} sourceExtent Extent of the data source.
 * @param {number} targetResolution Target resolution.
 * @param {import("./extent.js").Extent} targetExtent Target extent.
 * @param {import("./reproj/Triangulation.js").default} triangulation Calculated triangulation.
 * @param {Array<ImageExtent>} sources Array of sources.
 * @param {number} gutter Gutter of the sources.
 * @param {boolean} [renderEdges] Render reprojection edges.
 * @param {boolean} [interpolate] Use linear interpolation when resampling.
 * @return {HTMLCanvasElement} Canvas with reprojected data.
 */
function render(
  width,
  height,
  pixelRatio,
  sourceResolution,
  sourceExtent,
  targetResolution,
  targetExtent,
  triangulation,
  sources,
  gutter,
  renderEdges,
  interpolate
) {
  const context = (0,_dom_js__WEBPACK_IMPORTED_MODULE_1__.createCanvasContext2D)(
    Math.round(pixelRatio * width),
    Math.round(pixelRatio * height),
    canvasPool
  );

  if (!interpolate) {
    context.imageSmoothingEnabled = false;
  }

  if (sources.length === 0) {
    return context.canvas;
  }

  context.scale(pixelRatio, pixelRatio);

  function pixelRound(value) {
    return Math.round(value * pixelRatio) / pixelRatio;
  }

  context.globalCompositeOperation = 'lighter';

  const sourceDataExtent = (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.createEmpty)();
  sources.forEach(function (src, i, arr) {
    (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.extend)(sourceDataExtent, src.extent);
  });

  const canvasWidthInUnits = (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.getWidth)(sourceDataExtent);
  const canvasHeightInUnits = (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.getHeight)(sourceDataExtent);
  const stitchContext = (0,_dom_js__WEBPACK_IMPORTED_MODULE_1__.createCanvasContext2D)(
    Math.round((pixelRatio * canvasWidthInUnits) / sourceResolution),
    Math.round((pixelRatio * canvasHeightInUnits) / sourceResolution),
    canvasPool
  );

  if (!interpolate) {
    stitchContext.imageSmoothingEnabled = false;
  }

  const stitchScale = pixelRatio / sourceResolution;

  sources.forEach(function (src, i, arr) {
    const xPos = src.extent[0] - sourceDataExtent[0];
    const yPos = -(src.extent[3] - sourceDataExtent[3]);
    const srcWidth = (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.getWidth)(src.extent);
    const srcHeight = (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.getHeight)(src.extent);

    // This test should never fail -- but it does. Need to find a fix the upstream condition
    if (src.image.width > 0 && src.image.height > 0) {
      stitchContext.drawImage(
        src.image,
        gutter,
        gutter,
        src.image.width - 2 * gutter,
        src.image.height - 2 * gutter,
        xPos * stitchScale,
        yPos * stitchScale,
        srcWidth * stitchScale,
        srcHeight * stitchScale
      );
    }
  });

  const targetTopLeft = (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.getTopLeft)(targetExtent);

  triangulation.getTriangles().forEach(function (triangle, i, arr) {
    /* Calculate affine transform (src -> dst)
     * Resulting matrix can be used to transform coordinate
     * from `sourceProjection` to destination pixels.
     *
     * To optimize number of context calls and increase numerical stability,
     * we also do the following operations:
     * trans(-topLeftExtentCorner), scale(1 / targetResolution), scale(1, -1)
     * here before solving the linear system so [ui, vi] are pixel coordinates.
     *
     * Src points: xi, yi
     * Dst points: ui, vi
     * Affine coefficients: aij
     *
     * | x0 y0 1  0  0 0 |   |a00|   |u0|
     * | x1 y1 1  0  0 0 |   |a01|   |u1|
     * | x2 y2 1  0  0 0 | x |a02| = |u2|
     * |  0  0 0 x0 y0 1 |   |a10|   |v0|
     * |  0  0 0 x1 y1 1 |   |a11|   |v1|
     * |  0  0 0 x2 y2 1 |   |a12|   |v2|
     */
    const source = triangle.source;
    const target = triangle.target;
    let x0 = source[0][0],
      y0 = source[0][1];
    let x1 = source[1][0],
      y1 = source[1][1];
    let x2 = source[2][0],
      y2 = source[2][1];
    // Make sure that everything is on pixel boundaries
    const u0 = pixelRound((target[0][0] - targetTopLeft[0]) / targetResolution);
    const v0 = pixelRound(
      -(target[0][1] - targetTopLeft[1]) / targetResolution
    );
    const u1 = pixelRound((target[1][0] - targetTopLeft[0]) / targetResolution);
    const v1 = pixelRound(
      -(target[1][1] - targetTopLeft[1]) / targetResolution
    );
    const u2 = pixelRound((target[2][0] - targetTopLeft[0]) / targetResolution);
    const v2 = pixelRound(
      -(target[2][1] - targetTopLeft[1]) / targetResolution
    );

    // Shift all the source points to improve numerical stability
    // of all the subsequent calculations. The [x0, y0] is used here.
    // This is also used to simplify the linear system.
    const sourceNumericalShiftX = x0;
    const sourceNumericalShiftY = y0;
    x0 = 0;
    y0 = 0;
    x1 -= sourceNumericalShiftX;
    y1 -= sourceNumericalShiftY;
    x2 -= sourceNumericalShiftX;
    y2 -= sourceNumericalShiftY;

    const augmentedMatrix = [
      [x1, y1, 0, 0, u1 - u0],
      [x2, y2, 0, 0, u2 - u0],
      [0, 0, x1, y1, v1 - v0],
      [0, 0, x2, y2, v2 - v0],
    ];
    const affineCoefs = (0,_math_js__WEBPACK_IMPORTED_MODULE_3__.solveLinearSystem)(augmentedMatrix);
    if (!affineCoefs) {
      return;
    }

    context.save();
    context.beginPath();

    if (isBrokenDiagonalRendering() || !interpolate) {
      // Make sure that all lines are horizontal or vertical
      context.moveTo(u1, v1);
      // This is the diagonal line. Do it in 4 steps
      const steps = 4;
      const ud = u0 - u1;
      const vd = v0 - v1;
      for (let step = 0; step < steps; step++) {
        // Go horizontally
        context.lineTo(
          u1 + pixelRound(((step + 1) * ud) / steps),
          v1 + pixelRound((step * vd) / (steps - 1))
        );
        // Go vertically
        if (step != steps - 1) {
          context.lineTo(
            u1 + pixelRound(((step + 1) * ud) / steps),
            v1 + pixelRound(((step + 1) * vd) / (steps - 1))
          );
        }
      }
      // We are almost at u0r, v0r
      context.lineTo(u2, v2);
    } else {
      context.moveTo(u1, v1);
      context.lineTo(u0, v0);
      context.lineTo(u2, v2);
    }

    context.clip();

    context.transform(
      affineCoefs[0],
      affineCoefs[2],
      affineCoefs[1],
      affineCoefs[3],
      u0,
      v0
    );

    context.translate(
      sourceDataExtent[0] - sourceNumericalShiftX,
      sourceDataExtent[3] - sourceNumericalShiftY
    );

    context.scale(
      sourceResolution / pixelRatio,
      -sourceResolution / pixelRatio
    );

    context.drawImage(stitchContext.canvas, 0, 0);
    context.restore();
  });

  (0,_dom_js__WEBPACK_IMPORTED_MODULE_1__.releaseCanvas)(stitchContext);
  canvasPool.push(stitchContext.canvas);

  if (renderEdges) {
    context.save();

    context.globalCompositeOperation = 'source-over';
    context.strokeStyle = 'black';
    context.lineWidth = 1;

    triangulation.getTriangles().forEach(function (triangle, i, arr) {
      const target = triangle.target;
      const u0 = (target[0][0] - targetTopLeft[0]) / targetResolution;
      const v0 = -(target[0][1] - targetTopLeft[1]) / targetResolution;
      const u1 = (target[1][0] - targetTopLeft[0]) / targetResolution;
      const v1 = -(target[1][1] - targetTopLeft[1]) / targetResolution;
      const u2 = (target[2][0] - targetTopLeft[0]) / targetResolution;
      const v2 = -(target[2][1] - targetTopLeft[1]) / targetResolution;

      context.beginPath();
      context.moveTo(u1, v1);
      context.lineTo(u0, v0);
      context.lineTo(u2, v2);
      context.closePath();
      context.stroke();
    });

    context.restore();
  }
  return context.canvas;
}


/***/ }),

/***/ "./node_modules/ol/reproj/Tile.js":
/*!****************************************!*\
  !*** ./node_modules/ol/reproj/Tile.js ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./common.js */ "./node_modules/ol/reproj/common.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../events/EventType.js */ "./node_modules/ol/events/EventType.js");
/* harmony import */ var _Tile_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Tile.js */ "./node_modules/ol/Tile.js");
/* harmony import */ var _TileState_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../TileState.js */ "./node_modules/ol/TileState.js");
/* harmony import */ var _Triangulation_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Triangulation.js */ "./node_modules/ol/reproj/Triangulation.js");
/* harmony import */ var _reproj_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../reproj.js */ "./node_modules/ol/reproj.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../math.js */ "./node_modules/ol/math.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../dom.js */ "./node_modules/ol/dom.js");
/**
 * @module ol/reproj/Tile
 */












/**
 * @typedef {function(number, number, number, number) : (import("../ImageTile.js").default)} FunctionType
 */

/**
 * @classdesc
 * Class encapsulating single reprojected tile.
 * See {@link module:ol/source/TileImage~TileImage}.
 *
 */
class ReprojTile extends _Tile_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {import("../proj/Projection.js").default} sourceProj Source projection.
   * @param {import("../tilegrid/TileGrid.js").default} sourceTileGrid Source tile grid.
   * @param {import("../proj/Projection.js").default} targetProj Target projection.
   * @param {import("../tilegrid/TileGrid.js").default} targetTileGrid Target tile grid.
   * @param {import("../tilecoord.js").TileCoord} tileCoord Coordinate of the tile.
   * @param {import("../tilecoord.js").TileCoord} wrappedTileCoord Coordinate of the tile wrapped in X.
   * @param {number} pixelRatio Pixel ratio.
   * @param {number} gutter Gutter of the source tiles.
   * @param {FunctionType} getTileFunction
   *     Function returning source tiles (z, x, y, pixelRatio).
   * @param {number} [errorThreshold] Acceptable reprojection error (in px).
   * @param {boolean} [renderEdges] Render reprojection edges.
   * @param {boolean} [interpolate] Use linear interpolation when resampling.
   */
  constructor(
    sourceProj,
    sourceTileGrid,
    targetProj,
    targetTileGrid,
    tileCoord,
    wrappedTileCoord,
    pixelRatio,
    gutter,
    getTileFunction,
    errorThreshold,
    renderEdges,
    interpolate
  ) {
    super(tileCoord, _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].IDLE, {interpolate: !!interpolate});

    /**
     * @private
     * @type {boolean}
     */
    this.renderEdges_ = renderEdges !== undefined ? renderEdges : false;

    /**
     * @private
     * @type {number}
     */
    this.pixelRatio_ = pixelRatio;

    /**
     * @private
     * @type {number}
     */
    this.gutter_ = gutter;

    /**
     * @private
     * @type {HTMLCanvasElement}
     */
    this.canvas_ = null;

    /**
     * @private
     * @type {import("../tilegrid/TileGrid.js").default}
     */
    this.sourceTileGrid_ = sourceTileGrid;

    /**
     * @private
     * @type {import("../tilegrid/TileGrid.js").default}
     */
    this.targetTileGrid_ = targetTileGrid;

    /**
     * @private
     * @type {import("../tilecoord.js").TileCoord}
     */
    this.wrappedTileCoord_ = wrappedTileCoord ? wrappedTileCoord : tileCoord;

    /**
     * @private
     * @type {!Array<import("../ImageTile.js").default>}
     */
    this.sourceTiles_ = [];

    /**
     * @private
     * @type {?Array<import("../events.js").EventsKey>}
     */
    this.sourcesListenerKeys_ = null;

    /**
     * @private
     * @type {number}
     */
    this.sourceZ_ = 0;

    const targetExtent = targetTileGrid.getTileCoordExtent(
      this.wrappedTileCoord_
    );
    const maxTargetExtent = this.targetTileGrid_.getExtent();
    let maxSourceExtent = this.sourceTileGrid_.getExtent();

    const limitedTargetExtent = maxTargetExtent
      ? (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.getIntersection)(targetExtent, maxTargetExtent)
      : targetExtent;

    if ((0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.getArea)(limitedTargetExtent) === 0) {
      // Tile is completely outside range -> EMPTY
      // TODO: is it actually correct that the source even creates the tile ?
      this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].EMPTY;
      return;
    }

    const sourceProjExtent = sourceProj.getExtent();
    if (sourceProjExtent) {
      if (!maxSourceExtent) {
        maxSourceExtent = sourceProjExtent;
      } else {
        maxSourceExtent = (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.getIntersection)(maxSourceExtent, sourceProjExtent);
      }
    }

    const targetResolution = targetTileGrid.getResolution(
      this.wrappedTileCoord_[0]
    );

    const sourceResolution = (0,_reproj_js__WEBPACK_IMPORTED_MODULE_3__.calculateSourceExtentResolution)(
      sourceProj,
      targetProj,
      limitedTargetExtent,
      targetResolution
    );

    if (!isFinite(sourceResolution) || sourceResolution <= 0) {
      // invalid sourceResolution -> EMPTY
      // probably edges of the projections when no extent is defined
      this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].EMPTY;
      return;
    }

    const errorThresholdInPixels =
      errorThreshold !== undefined ? errorThreshold : _common_js__WEBPACK_IMPORTED_MODULE_4__.ERROR_THRESHOLD;

    /**
     * @private
     * @type {!import("./Triangulation.js").default}
     */
    this.triangulation_ = new _Triangulation_js__WEBPACK_IMPORTED_MODULE_5__["default"](
      sourceProj,
      targetProj,
      limitedTargetExtent,
      maxSourceExtent,
      sourceResolution * errorThresholdInPixels,
      targetResolution
    );

    if (this.triangulation_.getTriangles().length === 0) {
      // no valid triangles -> EMPTY
      this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].EMPTY;
      return;
    }

    this.sourceZ_ = sourceTileGrid.getZForResolution(sourceResolution);
    let sourceExtent = this.triangulation_.calculateSourceExtent();

    if (maxSourceExtent) {
      if (sourceProj.canWrapX()) {
        sourceExtent[1] = (0,_math_js__WEBPACK_IMPORTED_MODULE_6__.clamp)(
          sourceExtent[1],
          maxSourceExtent[1],
          maxSourceExtent[3]
        );
        sourceExtent[3] = (0,_math_js__WEBPACK_IMPORTED_MODULE_6__.clamp)(
          sourceExtent[3],
          maxSourceExtent[1],
          maxSourceExtent[3]
        );
      } else {
        sourceExtent = (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.getIntersection)(sourceExtent, maxSourceExtent);
      }
    }

    if (!(0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.getArea)(sourceExtent)) {
      this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].EMPTY;
    } else {
      const sourceRange = sourceTileGrid.getTileRangeForExtentAndZ(
        sourceExtent,
        this.sourceZ_
      );

      for (let srcX = sourceRange.minX; srcX <= sourceRange.maxX; srcX++) {
        for (let srcY = sourceRange.minY; srcY <= sourceRange.maxY; srcY++) {
          const tile = getTileFunction(this.sourceZ_, srcX, srcY, pixelRatio);
          if (tile) {
            this.sourceTiles_.push(tile);
          }
        }
      }

      if (this.sourceTiles_.length === 0) {
        this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].EMPTY;
      }
    }
  }

  /**
   * Get the HTML Canvas element for this tile.
   * @return {HTMLCanvasElement} Canvas.
   */
  getImage() {
    return this.canvas_;
  }

  /**
   * @private
   */
  reproject_() {
    const sources = [];
    this.sourceTiles_.forEach((tile) => {
      if (tile && tile.getState() == _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADED) {
        sources.push({
          extent: this.sourceTileGrid_.getTileCoordExtent(tile.tileCoord),
          image: tile.getImage(),
        });
      }
    });
    this.sourceTiles_.length = 0;

    if (sources.length === 0) {
      this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].ERROR;
    } else {
      const z = this.wrappedTileCoord_[0];
      const size = this.targetTileGrid_.getTileSize(z);
      const width = typeof size === 'number' ? size : size[0];
      const height = typeof size === 'number' ? size : size[1];
      const targetResolution = this.targetTileGrid_.getResolution(z);
      const sourceResolution = this.sourceTileGrid_.getResolution(
        this.sourceZ_
      );

      const targetExtent = this.targetTileGrid_.getTileCoordExtent(
        this.wrappedTileCoord_
      );

      this.canvas_ = (0,_reproj_js__WEBPACK_IMPORTED_MODULE_3__.render)(
        width,
        height,
        this.pixelRatio_,
        sourceResolution,
        this.sourceTileGrid_.getExtent(),
        targetResolution,
        targetExtent,
        this.triangulation_,
        sources,
        this.gutter_,
        this.renderEdges_,
        this.interpolate
      );

      this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADED;
    }
    this.changed();
  }

  /**
   * Load not yet loaded URI.
   */
  load() {
    if (this.state == _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].IDLE) {
      this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADING;
      this.changed();

      let leftToLoad = 0;

      this.sourcesListenerKeys_ = [];
      this.sourceTiles_.forEach((tile) => {
        const state = tile.getState();
        if (state == _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].IDLE || state == _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADING) {
          leftToLoad++;

          const sourceListenKey = (0,_events_js__WEBPACK_IMPORTED_MODULE_7__.listen)(
            tile,
            _events_EventType_js__WEBPACK_IMPORTED_MODULE_8__["default"].CHANGE,
            function (e) {
              const state = tile.getState();
              if (
                state == _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADED ||
                state == _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].ERROR ||
                state == _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].EMPTY
              ) {
                (0,_events_js__WEBPACK_IMPORTED_MODULE_7__.unlistenByKey)(sourceListenKey);
                leftToLoad--;
                if (leftToLoad === 0) {
                  this.unlistenSources_();
                  this.reproject_();
                }
              }
            },
            this
          );
          this.sourcesListenerKeys_.push(sourceListenKey);
        }
      });

      if (leftToLoad === 0) {
        setTimeout(this.reproject_.bind(this), 0);
      } else {
        this.sourceTiles_.forEach(function (tile, i, arr) {
          const state = tile.getState();
          if (state == _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].IDLE) {
            tile.load();
          }
        });
      }
    }
  }

  /**
   * @private
   */
  unlistenSources_() {
    this.sourcesListenerKeys_.forEach(_events_js__WEBPACK_IMPORTED_MODULE_7__.unlistenByKey);
    this.sourcesListenerKeys_ = null;
  }

  /**
   * Remove from the cache due to expiry
   */
  release() {
    if (this.canvas_) {
      (0,_dom_js__WEBPACK_IMPORTED_MODULE_9__.releaseCanvas)(this.canvas_.getContext('2d'));
      _reproj_js__WEBPACK_IMPORTED_MODULE_3__.canvasPool.push(this.canvas_);
      this.canvas_ = null;
    }
    super.release();
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ReprojTile);


/***/ }),

/***/ "./node_modules/ol/reproj/Triangulation.js":
/*!*************************************************!*\
  !*** ./node_modules/ol/reproj/Triangulation.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../proj.js */ "./node_modules/ol/proj.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math.js */ "./node_modules/ol/math.js");
/**
 * @module ol/reproj/Triangulation
 */




/**
 * Single triangle; consists of 3 source points and 3 target points.
 * @typedef {Object} Triangle
 * @property {Array<import("../coordinate.js").Coordinate>} source Source.
 * @property {Array<import("../coordinate.js").Coordinate>} target Target.
 */

/**
 * Maximum number of subdivision steps during raster reprojection triangulation.
 * Prevents high memory usage and large number of proj4 calls (for certain
 * transformations and areas). At most `2*(2^this)` triangles are created for
 * each triangulated extent (tile/image).
 * @type {number}
 */
const MAX_SUBDIVISION = 10;

/**
 * Maximum allowed size of triangle relative to world width. When transforming
 * corners of world extent between certain projections, the resulting
 * triangulation seems to have zero error and no subdivision is performed. If
 * the triangle width is more than this (relative to world width; 0-1),
 * subdivison is forced (up to `MAX_SUBDIVISION`). Default is `0.25`.
 * @type {number}
 */
const MAX_TRIANGLE_WIDTH = 0.25;

/**
 * @classdesc
 * Class containing triangulation of the given target extent.
 * Used for determining source data and the reprojection itself.
 */
class Triangulation {
  /**
   * @param {import("../proj/Projection.js").default} sourceProj Source projection.
   * @param {import("../proj/Projection.js").default} targetProj Target projection.
   * @param {import("../extent.js").Extent} targetExtent Target extent to triangulate.
   * @param {import("../extent.js").Extent} maxSourceExtent Maximal source extent that can be used.
   * @param {number} errorThreshold Acceptable error (in source units).
   * @param {?number} destinationResolution The (optional) resolution of the destination.
   */
  constructor(
    sourceProj,
    targetProj,
    targetExtent,
    maxSourceExtent,
    errorThreshold,
    destinationResolution
  ) {
    /**
     * @type {import("../proj/Projection.js").default}
     * @private
     */
    this.sourceProj_ = sourceProj;

    /**
     * @type {import("../proj/Projection.js").default}
     * @private
     */
    this.targetProj_ = targetProj;

    /** @type {!Object<string, import("../coordinate.js").Coordinate>} */
    let transformInvCache = {};
    const transformInv = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.getTransform)(this.targetProj_, this.sourceProj_);

    /**
     * @param {import("../coordinate.js").Coordinate} c A coordinate.
     * @return {import("../coordinate.js").Coordinate} Transformed coordinate.
     * @private
     */
    this.transformInv_ = function (c) {
      const key = c[0] + '/' + c[1];
      if (!transformInvCache[key]) {
        transformInvCache[key] = transformInv(c);
      }
      return transformInvCache[key];
    };

    /**
     * @type {import("../extent.js").Extent}
     * @private
     */
    this.maxSourceExtent_ = maxSourceExtent;

    /**
     * @type {number}
     * @private
     */
    this.errorThresholdSquared_ = errorThreshold * errorThreshold;

    /**
     * @type {Array<Triangle>}
     * @private
     */
    this.triangles_ = [];

    /**
     * Indicates that the triangulation crosses edge of the source projection.
     * @type {boolean}
     * @private
     */
    this.wrapsXInSource_ = false;

    /**
     * @type {boolean}
     * @private
     */
    this.canWrapXInSource_ =
      this.sourceProj_.canWrapX() &&
      !!maxSourceExtent &&
      !!this.sourceProj_.getExtent() &&
      (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.getWidth)(maxSourceExtent) >= (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.getWidth)(this.sourceProj_.getExtent());

    /**
     * @type {?number}
     * @private
     */
    this.sourceWorldWidth_ = this.sourceProj_.getExtent()
      ? (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.getWidth)(this.sourceProj_.getExtent())
      : null;

    /**
     * @type {?number}
     * @private
     */
    this.targetWorldWidth_ = this.targetProj_.getExtent()
      ? (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.getWidth)(this.targetProj_.getExtent())
      : null;

    const destinationTopLeft = (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.getTopLeft)(targetExtent);
    const destinationTopRight = (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.getTopRight)(targetExtent);
    const destinationBottomRight = (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.getBottomRight)(targetExtent);
    const destinationBottomLeft = (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.getBottomLeft)(targetExtent);
    const sourceTopLeft = this.transformInv_(destinationTopLeft);
    const sourceTopRight = this.transformInv_(destinationTopRight);
    const sourceBottomRight = this.transformInv_(destinationBottomRight);
    const sourceBottomLeft = this.transformInv_(destinationBottomLeft);

    /*
     * The maxSubdivision controls how many splittings of the target area can
     * be done. The idea here is to do a linear mapping of the target areas
     * but the actual overall reprojection (can be) extremely non-linear. The
     * default value of MAX_SUBDIVISION was chosen based on mapping a 256x256
     * tile size. However this function is also called to remap canvas rendered
     * layers which can be much larger. This calculation increases the maxSubdivision
     * value by the right factor so that each 256x256 pixel area has
     * MAX_SUBDIVISION divisions.
     */
    const maxSubdivision =
      MAX_SUBDIVISION +
      (destinationResolution
        ? Math.max(
            0,
            Math.ceil(
              Math.log2(
                (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.getArea)(targetExtent) /
                  (destinationResolution * destinationResolution * 256 * 256)
              )
            )
          )
        : 0);

    this.addQuad_(
      destinationTopLeft,
      destinationTopRight,
      destinationBottomRight,
      destinationBottomLeft,
      sourceTopLeft,
      sourceTopRight,
      sourceBottomRight,
      sourceBottomLeft,
      maxSubdivision
    );

    if (this.wrapsXInSource_) {
      let leftBound = Infinity;
      this.triangles_.forEach(function (triangle, i, arr) {
        leftBound = Math.min(
          leftBound,
          triangle.source[0][0],
          triangle.source[1][0],
          triangle.source[2][0]
        );
      });

      // Shift triangles to be as close to `leftBound` as possible
      // (if the distance is more than `worldWidth / 2` it can be closer.
      this.triangles_.forEach((triangle) => {
        if (
          Math.max(
            triangle.source[0][0],
            triangle.source[1][0],
            triangle.source[2][0]
          ) -
            leftBound >
          this.sourceWorldWidth_ / 2
        ) {
          const newTriangle = [
            [triangle.source[0][0], triangle.source[0][1]],
            [triangle.source[1][0], triangle.source[1][1]],
            [triangle.source[2][0], triangle.source[2][1]],
          ];
          if (newTriangle[0][0] - leftBound > this.sourceWorldWidth_ / 2) {
            newTriangle[0][0] -= this.sourceWorldWidth_;
          }
          if (newTriangle[1][0] - leftBound > this.sourceWorldWidth_ / 2) {
            newTriangle[1][0] -= this.sourceWorldWidth_;
          }
          if (newTriangle[2][0] - leftBound > this.sourceWorldWidth_ / 2) {
            newTriangle[2][0] -= this.sourceWorldWidth_;
          }

          // Rarely (if the extent contains both the dateline and prime meridian)
          // the shift can in turn break some triangles.
          // Detect this here and don't shift in such cases.
          const minX = Math.min(
            newTriangle[0][0],
            newTriangle[1][0],
            newTriangle[2][0]
          );
          const maxX = Math.max(
            newTriangle[0][0],
            newTriangle[1][0],
            newTriangle[2][0]
          );
          if (maxX - minX < this.sourceWorldWidth_ / 2) {
            triangle.source = newTriangle;
          }
        }
      });
    }

    transformInvCache = {};
  }

  /**
   * Adds triangle to the triangulation.
   * @param {import("../coordinate.js").Coordinate} a The target a coordinate.
   * @param {import("../coordinate.js").Coordinate} b The target b coordinate.
   * @param {import("../coordinate.js").Coordinate} c The target c coordinate.
   * @param {import("../coordinate.js").Coordinate} aSrc The source a coordinate.
   * @param {import("../coordinate.js").Coordinate} bSrc The source b coordinate.
   * @param {import("../coordinate.js").Coordinate} cSrc The source c coordinate.
   * @private
   */
  addTriangle_(a, b, c, aSrc, bSrc, cSrc) {
    this.triangles_.push({
      source: [aSrc, bSrc, cSrc],
      target: [a, b, c],
    });
  }

  /**
   * Adds quad (points in clock-wise order) to the triangulation
   * (and reprojects the vertices) if valid.
   * Performs quad subdivision if needed to increase precision.
   *
   * @param {import("../coordinate.js").Coordinate} a The target a coordinate.
   * @param {import("../coordinate.js").Coordinate} b The target b coordinate.
   * @param {import("../coordinate.js").Coordinate} c The target c coordinate.
   * @param {import("../coordinate.js").Coordinate} d The target d coordinate.
   * @param {import("../coordinate.js").Coordinate} aSrc The source a coordinate.
   * @param {import("../coordinate.js").Coordinate} bSrc The source b coordinate.
   * @param {import("../coordinate.js").Coordinate} cSrc The source c coordinate.
   * @param {import("../coordinate.js").Coordinate} dSrc The source d coordinate.
   * @param {number} maxSubdivision Maximal allowed subdivision of the quad.
   * @private
   */
  addQuad_(a, b, c, d, aSrc, bSrc, cSrc, dSrc, maxSubdivision) {
    const sourceQuadExtent = (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.boundingExtent)([aSrc, bSrc, cSrc, dSrc]);
    const sourceCoverageX = this.sourceWorldWidth_
      ? (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.getWidth)(sourceQuadExtent) / this.sourceWorldWidth_
      : null;
    const sourceWorldWidth = /** @type {number} */ (this.sourceWorldWidth_);

    // when the quad is wrapped in the source projection
    // it covers most of the projection extent, but not fully
    const wrapsX =
      this.sourceProj_.canWrapX() &&
      sourceCoverageX > 0.5 &&
      sourceCoverageX < 1;

    let needsSubdivision = false;

    if (maxSubdivision > 0) {
      if (this.targetProj_.isGlobal() && this.targetWorldWidth_) {
        const targetQuadExtent = (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.boundingExtent)([a, b, c, d]);
        const targetCoverageX =
          (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.getWidth)(targetQuadExtent) / this.targetWorldWidth_;
        needsSubdivision =
          targetCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;
      }
      if (!wrapsX && this.sourceProj_.isGlobal() && sourceCoverageX) {
        needsSubdivision =
          sourceCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;
      }
    }

    if (!needsSubdivision && this.maxSourceExtent_) {
      if (
        isFinite(sourceQuadExtent[0]) &&
        isFinite(sourceQuadExtent[1]) &&
        isFinite(sourceQuadExtent[2]) &&
        isFinite(sourceQuadExtent[3])
      ) {
        if (!(0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.intersects)(sourceQuadExtent, this.maxSourceExtent_)) {
          // whole quad outside source projection extent -> ignore
          return;
        }
      }
    }

    let isNotFinite = 0;

    if (!needsSubdivision) {
      if (
        !isFinite(aSrc[0]) ||
        !isFinite(aSrc[1]) ||
        !isFinite(bSrc[0]) ||
        !isFinite(bSrc[1]) ||
        !isFinite(cSrc[0]) ||
        !isFinite(cSrc[1]) ||
        !isFinite(dSrc[0]) ||
        !isFinite(dSrc[1])
      ) {
        if (maxSubdivision > 0) {
          needsSubdivision = true;
        } else {
          // It might be the case that only 1 of the points is infinite. In this case
          // we can draw a single triangle with the other three points
          isNotFinite =
            (!isFinite(aSrc[0]) || !isFinite(aSrc[1]) ? 8 : 0) +
            (!isFinite(bSrc[0]) || !isFinite(bSrc[1]) ? 4 : 0) +
            (!isFinite(cSrc[0]) || !isFinite(cSrc[1]) ? 2 : 0) +
            (!isFinite(dSrc[0]) || !isFinite(dSrc[1]) ? 1 : 0);
          if (
            isNotFinite != 1 &&
            isNotFinite != 2 &&
            isNotFinite != 4 &&
            isNotFinite != 8
          ) {
            return;
          }
        }
      }
    }

    if (maxSubdivision > 0) {
      if (!needsSubdivision) {
        const center = [(a[0] + c[0]) / 2, (a[1] + c[1]) / 2];
        const centerSrc = this.transformInv_(center);

        let dx;
        if (wrapsX) {
          const centerSrcEstimX =
            ((0,_math_js__WEBPACK_IMPORTED_MODULE_2__.modulo)(aSrc[0], sourceWorldWidth) +
              (0,_math_js__WEBPACK_IMPORTED_MODULE_2__.modulo)(cSrc[0], sourceWorldWidth)) /
            2;
          dx = centerSrcEstimX - (0,_math_js__WEBPACK_IMPORTED_MODULE_2__.modulo)(centerSrc[0], sourceWorldWidth);
        } else {
          dx = (aSrc[0] + cSrc[0]) / 2 - centerSrc[0];
        }
        const dy = (aSrc[1] + cSrc[1]) / 2 - centerSrc[1];
        const centerSrcErrorSquared = dx * dx + dy * dy;
        needsSubdivision = centerSrcErrorSquared > this.errorThresholdSquared_;
      }
      if (needsSubdivision) {
        if (Math.abs(a[0] - c[0]) <= Math.abs(a[1] - c[1])) {
          // split horizontally (top & bottom)
          const bc = [(b[0] + c[0]) / 2, (b[1] + c[1]) / 2];
          const bcSrc = this.transformInv_(bc);
          const da = [(d[0] + a[0]) / 2, (d[1] + a[1]) / 2];
          const daSrc = this.transformInv_(da);

          this.addQuad_(
            a,
            b,
            bc,
            da,
            aSrc,
            bSrc,
            bcSrc,
            daSrc,
            maxSubdivision - 1
          );
          this.addQuad_(
            da,
            bc,
            c,
            d,
            daSrc,
            bcSrc,
            cSrc,
            dSrc,
            maxSubdivision - 1
          );
        } else {
          // split vertically (left & right)
          const ab = [(a[0] + b[0]) / 2, (a[1] + b[1]) / 2];
          const abSrc = this.transformInv_(ab);
          const cd = [(c[0] + d[0]) / 2, (c[1] + d[1]) / 2];
          const cdSrc = this.transformInv_(cd);

          this.addQuad_(
            a,
            ab,
            cd,
            d,
            aSrc,
            abSrc,
            cdSrc,
            dSrc,
            maxSubdivision - 1
          );
          this.addQuad_(
            ab,
            b,
            c,
            cd,
            abSrc,
            bSrc,
            cSrc,
            cdSrc,
            maxSubdivision - 1
          );
        }
        return;
      }
    }

    if (wrapsX) {
      if (!this.canWrapXInSource_) {
        return;
      }
      this.wrapsXInSource_ = true;
    }

    // Exactly zero or one of *Src is not finite
    // The triangles must have the diagonal line as the first side
    // This is to allow easy code in reproj.s to make it straight for broken
    // browsers that can't handle diagonal clipping
    if ((isNotFinite & 0xb) == 0) {
      this.addTriangle_(a, c, d, aSrc, cSrc, dSrc);
    }
    if ((isNotFinite & 0xe) == 0) {
      this.addTriangle_(a, c, b, aSrc, cSrc, bSrc);
    }
    if (isNotFinite) {
      // Try the other two triangles
      if ((isNotFinite & 0xd) == 0) {
        this.addTriangle_(b, d, a, bSrc, dSrc, aSrc);
      }
      if ((isNotFinite & 0x7) == 0) {
        this.addTriangle_(b, d, c, bSrc, dSrc, cSrc);
      }
    }
  }

  /**
   * Calculates extent of the `source` coordinates from all the triangles.
   *
   * @return {import("../extent.js").Extent} Calculated extent.
   */
  calculateSourceExtent() {
    const extent = (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.createEmpty)();

    this.triangles_.forEach(function (triangle, i, arr) {
      const src = triangle.source;
      (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.extendCoordinate)(extent, src[0]);
      (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.extendCoordinate)(extent, src[1]);
      (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.extendCoordinate)(extent, src[2]);
    });

    return extent;
  }

  /**
   * @return {Array<Triangle>} Array of the calculated triangles.
   */
  getTriangles() {
    return this.triangles_;
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Triangulation);


/***/ }),

/***/ "./node_modules/ol/reproj/common.js":
/*!******************************************!*\
  !*** ./node_modules/ol/reproj/common.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ERROR_THRESHOLD: () => (/* binding */ ERROR_THRESHOLD)
/* harmony export */ });
/**
 * @module ol/reproj/common
 */

/**
 * Default maximum allowed threshold  (in pixels) for reprojection
 * triangulation.
 * @type {number}
 */
const ERROR_THRESHOLD = 0.5;


/***/ }),

/***/ "./node_modules/ol/resolutionconstraint.js":
/*!*************************************************!*\
  !*** ./node_modules/ol/resolutionconstraint.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createMinMaxResolution: () => (/* binding */ createMinMaxResolution),
/* harmony export */   createSnapToPower: () => (/* binding */ createSnapToPower),
/* harmony export */   createSnapToResolutions: () => (/* binding */ createSnapToResolutions)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math.js */ "./node_modules/ol/math.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./array.js */ "./node_modules/ol/array.js");
/**
 * @module ol/resolutionconstraint
 */




/**
 * @typedef {function((number|undefined), number, import("./size.js").Size, boolean=): (number|undefined)} Type
 */

/**
 * Returns a modified resolution taking into account the viewport size and maximum
 * allowed extent.
 * @param {number} resolution Resolution
 * @param {import("./extent.js").Extent} maxExtent Maximum allowed extent.
 * @param {import("./size.js").Size} viewportSize Viewport size.
 * @param {boolean} showFullExtent Whether to show the full extent.
 * @return {number} Capped resolution.
 */
function getViewportClampedResolution(
  resolution,
  maxExtent,
  viewportSize,
  showFullExtent
) {
  const xResolution = (0,_extent_js__WEBPACK_IMPORTED_MODULE_0__.getWidth)(maxExtent) / viewportSize[0];
  const yResolution = (0,_extent_js__WEBPACK_IMPORTED_MODULE_0__.getHeight)(maxExtent) / viewportSize[1];

  if (showFullExtent) {
    return Math.min(resolution, Math.max(xResolution, yResolution));
  }
  return Math.min(resolution, Math.min(xResolution, yResolution));
}

/**
 * Returns a modified resolution to be between maxResolution and minResolution while
 * still allowing the value to be slightly out of bounds.
 * Note: the computation is based on the logarithm function (ln):
 *  - at 1, ln(x) is 0
 *  - above 1, ln(x) keeps increasing but at a much slower pace than x
 * The final result is clamped to prevent getting too far away from bounds.
 * @param {number} resolution Resolution.
 * @param {number} maxResolution Max resolution.
 * @param {number} minResolution Min resolution.
 * @return {number} Smoothed resolution.
 */
function getSmoothClampedResolution(resolution, maxResolution, minResolution) {
  let result = Math.min(resolution, maxResolution);
  const ratio = 50;

  result *=
    Math.log(1 + ratio * Math.max(0, resolution / maxResolution - 1)) / ratio +
    1;
  if (minResolution) {
    result = Math.max(result, minResolution);
    result /=
      Math.log(1 + ratio * Math.max(0, minResolution / resolution - 1)) /
        ratio +
      1;
  }
  return (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.clamp)(result, minResolution / 2, maxResolution * 2);
}

/**
 * @param {Array<number>} resolutions Resolutions.
 * @param {boolean} [smooth] If true, the view will be able to slightly exceed resolution limits. Default: true.
 * @param {import("./extent.js").Extent} [maxExtent] Maximum allowed extent.
 * @param {boolean} [showFullExtent] If true, allows us to show the full extent. Default: false.
 * @return {Type} Zoom function.
 */
function createSnapToResolutions(
  resolutions,
  smooth,
  maxExtent,
  showFullExtent
) {
  smooth = smooth !== undefined ? smooth : true;
  return (
    /**
     * @param {number|undefined} resolution Resolution.
     * @param {number} direction Direction.
     * @param {import("./size.js").Size} size Viewport size.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Resolution.
     */
    function (resolution, direction, size, isMoving) {
      if (resolution !== undefined) {
        const maxResolution = resolutions[0];
        const minResolution = resolutions[resolutions.length - 1];
        const cappedMaxRes = maxExtent
          ? getViewportClampedResolution(
              maxResolution,
              maxExtent,
              size,
              showFullExtent
            )
          : maxResolution;

        // during interacting or animating, allow intermediary values
        if (isMoving) {
          if (!smooth) {
            return (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.clamp)(resolution, minResolution, cappedMaxRes);
          }
          return getSmoothClampedResolution(
            resolution,
            cappedMaxRes,
            minResolution
          );
        }

        const capped = Math.min(cappedMaxRes, resolution);
        const z = Math.floor((0,_array_js__WEBPACK_IMPORTED_MODULE_2__.linearFindNearest)(resolutions, capped, direction));
        if (resolutions[z] > cappedMaxRes && z < resolutions.length - 1) {
          return resolutions[z + 1];
        }
        return resolutions[z];
      }
      return undefined;
    }
  );
}

/**
 * @param {number} power Power.
 * @param {number} maxResolution Maximum resolution.
 * @param {number} [minResolution] Minimum resolution.
 * @param {boolean} [smooth] If true, the view will be able to slightly exceed resolution limits. Default: true.
 * @param {import("./extent.js").Extent} [maxExtent] Maximum allowed extent.
 * @param {boolean} [showFullExtent] If true, allows us to show the full extent. Default: false.
 * @return {Type} Zoom function.
 */
function createSnapToPower(
  power,
  maxResolution,
  minResolution,
  smooth,
  maxExtent,
  showFullExtent
) {
  smooth = smooth !== undefined ? smooth : true;
  minResolution = minResolution !== undefined ? minResolution : 0;

  return (
    /**
     * @param {number|undefined} resolution Resolution.
     * @param {number} direction Direction.
     * @param {import("./size.js").Size} size Viewport size.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Resolution.
     */
    function (resolution, direction, size, isMoving) {
      if (resolution !== undefined) {
        const cappedMaxRes = maxExtent
          ? getViewportClampedResolution(
              maxResolution,
              maxExtent,
              size,
              showFullExtent
            )
          : maxResolution;

        // during interacting or animating, allow intermediary values
        if (isMoving) {
          if (!smooth) {
            return (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.clamp)(resolution, minResolution, cappedMaxRes);
          }
          return getSmoothClampedResolution(
            resolution,
            cappedMaxRes,
            minResolution
          );
        }

        const tolerance = 1e-9;
        const minZoomLevel = Math.ceil(
          Math.log(maxResolution / cappedMaxRes) / Math.log(power) - tolerance
        );
        const offset = -direction * (0.5 - tolerance) + 0.5;
        const capped = Math.min(cappedMaxRes, resolution);
        const cappedZoomLevel = Math.floor(
          Math.log(maxResolution / capped) / Math.log(power) + offset
        );
        const zoomLevel = Math.max(minZoomLevel, cappedZoomLevel);
        const newResolution = maxResolution / Math.pow(power, zoomLevel);
        return (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.clamp)(newResolution, minResolution, cappedMaxRes);
      }
      return undefined;
    }
  );
}

/**
 * @param {number} maxResolution Max resolution.
 * @param {number} minResolution Min resolution.
 * @param {boolean} [smooth] If true, the view will be able to slightly exceed resolution limits. Default: true.
 * @param {import("./extent.js").Extent} [maxExtent] Maximum allowed extent.
 * @param {boolean} [showFullExtent] If true, allows us to show the full extent. Default: false.
 * @return {Type} Zoom function.
 */
function createMinMaxResolution(
  maxResolution,
  minResolution,
  smooth,
  maxExtent,
  showFullExtent
) {
  smooth = smooth !== undefined ? smooth : true;

  return (
    /**
     * @param {number|undefined} resolution Resolution.
     * @param {number} direction Direction.
     * @param {import("./size.js").Size} size Viewport size.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Resolution.
     */
    function (resolution, direction, size, isMoving) {
      if (resolution !== undefined) {
        const cappedMaxRes = maxExtent
          ? getViewportClampedResolution(
              maxResolution,
              maxExtent,
              size,
              showFullExtent
            )
          : maxResolution;

        if (!smooth || !isMoving) {
          return (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.clamp)(resolution, minResolution, cappedMaxRes);
        }
        return getSmoothClampedResolution(
          resolution,
          cappedMaxRes,
          minResolution
        );
      }
      return undefined;
    }
  );
}


/***/ }),

/***/ "./node_modules/ol/rotationconstraint.js":
/*!***********************************************!*\
  !*** ./node_modules/ol/rotationconstraint.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createSnapToN: () => (/* binding */ createSnapToN),
/* harmony export */   createSnapToZero: () => (/* binding */ createSnapToZero),
/* harmony export */   disable: () => (/* binding */ disable),
/* harmony export */   none: () => (/* binding */ none)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.js */ "./node_modules/ol/math.js");
/**
 * @module ol/rotationconstraint
 */


/**
 * @typedef {function((number|undefined), boolean=): (number|undefined)} Type
 */

/**
 * @param {number|undefined} rotation Rotation.
 * @return {number|undefined} Rotation.
 */
function disable(rotation) {
  if (rotation !== undefined) {
    return 0;
  }
  return undefined;
}

/**
 * @param {number|undefined} rotation Rotation.
 * @return {number|undefined} Rotation.
 */
function none(rotation) {
  if (rotation !== undefined) {
    return rotation;
  }
  return undefined;
}

/**
 * @param {number} n N.
 * @return {Type} Rotation constraint.
 */
function createSnapToN(n) {
  const theta = (2 * Math.PI) / n;
  return (
    /**
     * @param {number|undefined} rotation Rotation.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Rotation.
     */
    function (rotation, isMoving) {
      if (isMoving) {
        return rotation;
      }

      if (rotation !== undefined) {
        rotation = Math.floor(rotation / theta + 0.5) * theta;
        return rotation;
      }
      return undefined;
    }
  );
}

/**
 * @param {number} [tolerance] Tolerance.
 * @return {Type} Rotation constraint.
 */
function createSnapToZero(tolerance) {
  tolerance = tolerance || (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.toRadians)(5);
  return (
    /**
     * @param {number|undefined} rotation Rotation.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Rotation.
     */
    function (rotation, isMoving) {
      if (isMoving) {
        return rotation;
      }

      if (rotation !== undefined) {
        if (Math.abs(rotation) <= tolerance) {
          return 0;
        }
        return rotation;
      }
      return undefined;
    }
  );
}


/***/ }),

/***/ "./node_modules/ol/size.js":
/*!*********************************!*\
  !*** ./node_modules/ol/size.js ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   buffer: () => (/* binding */ buffer),
/* harmony export */   hasArea: () => (/* binding */ hasArea),
/* harmony export */   scale: () => (/* binding */ scale),
/* harmony export */   toSize: () => (/* binding */ toSize)
/* harmony export */ });
/**
 * @module ol/size
 */

/**
 * An array of numbers representing a size: `[width, height]`.
 * @typedef {Array<number>} Size
 * @api
 */

/**
 * Returns a buffered size.
 * @param {Size} size Size.
 * @param {number} num The amount by which to buffer.
 * @param {Size} [dest] Optional reusable size array.
 * @return {Size} The buffered size.
 */
function buffer(size, num, dest) {
  if (dest === undefined) {
    dest = [0, 0];
  }
  dest[0] = size[0] + 2 * num;
  dest[1] = size[1] + 2 * num;
  return dest;
}

/**
 * Determines if a size has a positive area.
 * @param {Size} size The size to test.
 * @return {boolean} The size has a positive area.
 */
function hasArea(size) {
  return size[0] > 0 && size[1] > 0;
}

/**
 * Returns a size scaled by a ratio. The result will be an array of integers.
 * @param {Size} size Size.
 * @param {number} ratio Ratio.
 * @param {Size} [dest] Optional reusable size array.
 * @return {Size} The scaled size.
 */
function scale(size, ratio, dest) {
  if (dest === undefined) {
    dest = [0, 0];
  }
  dest[0] = (size[0] * ratio + 0.5) | 0;
  dest[1] = (size[1] * ratio + 0.5) | 0;
  return dest;
}

/**
 * Returns an `Size` array for the passed in number (meaning: square) or
 * `Size` array.
 * (meaning: non-square),
 * @param {number|Size} size Width and height.
 * @param {Size} [dest] Optional reusable size array.
 * @return {Size} Size.
 * @api
 */
function toSize(size, dest) {
  if (Array.isArray(size)) {
    return size;
  }
  if (dest === undefined) {
    dest = [size, size];
  } else {
    dest[0] = size;
    dest[1] = size;
  }
  return dest;
}


/***/ }),

/***/ "./node_modules/ol/source/OSM.js":
/*!***************************************!*\
  !*** ./node_modules/ol/source/OSM.js ***!
  \***************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ATTRIBUTION: () => (/* binding */ ATTRIBUTION),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _XYZ_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./XYZ.js */ "./node_modules/ol/source/XYZ.js");
/**
 * @module ol/source/OSM
 */



/**
 * The attribution containing a link to the OpenStreetMap Copyright and License
 * page.
 * @const
 * @type {string}
 * @api
 */
const ATTRIBUTION =
  '&#169; ' +
  '<a href="https://www.openstreetmap.org/copyright" target="_blank">OpenStreetMap</a> ' +
  'contributors.';

/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {number} [cacheSize] Initial tile cache size. Will auto-grow to hold at least the number of tiles in the viewport.
 * @property {null|string} [crossOrigin='anonymous'] The `crossOrigin` attribute for loaded images.  Note that
 * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.
 * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
 * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,
 * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.
 * @property {number} [maxZoom=19] Max zoom.
 * @property {boolean} [opaque=true] Whether the layer is opaque.
 * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).
 * Higher values can increase reprojection performance, but decrease precision.
 * @property {import("../Tile.js").LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is
 * ```js
 * function(imageTile, src) {
 *   imageTile.getImage().src = src;
 * };
 * ```
 * @property {number} [transition=250] Duration of the opacity transition for rendering.
 * To disable the opacity transition, pass `transition: 0`.
 * @property {string} [url='https://tile.openstreetmap.org/{z}/{x}/{y}.png'] URL template.
 * Must include `{x}`, `{y}` or `{-y}`, and `{z}` placeholders.
 * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.
 * @property {number|import("../array.js").NearestDirectionFunction} [zDirection=0]
 * Choose whether to use tiles with a higher or lower zoom level when between integer
 * zoom levels. See {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution}.
 */

/**
 * @classdesc
 * Layer source for the OpenStreetMap tile server.
 * @api
 */
class OSM extends _XYZ_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {Options} [options] Open Street Map options.
   */
  constructor(options) {
    options = options || {};

    let attributions;
    if (options.attributions !== undefined) {
      attributions = options.attributions;
    } else {
      attributions = [ATTRIBUTION];
    }

    const crossOrigin =
      options.crossOrigin !== undefined ? options.crossOrigin : 'anonymous';

    const url =
      options.url !== undefined
        ? options.url
        : 'https://tile.openstreetmap.org/{z}/{x}/{y}.png';

    super({
      attributions: attributions,
      attributionsCollapsible: false,
      cacheSize: options.cacheSize,
      crossOrigin: crossOrigin,
      interpolate: options.interpolate,
      maxZoom: options.maxZoom !== undefined ? options.maxZoom : 19,
      opaque: options.opaque !== undefined ? options.opaque : true,
      reprojectionErrorThreshold: options.reprojectionErrorThreshold,
      tileLoadFunction: options.tileLoadFunction,
      transition: options.transition,
      url: url,
      wrapX: options.wrapX,
      zDirection: options.zDirection,
    });
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (OSM);


/***/ }),

/***/ "./node_modules/ol/source/Source.js":
/*!******************************************!*\
  !*** ./node_modules/ol/source/Source.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Object_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Object.js */ "./node_modules/ol/Object.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../proj.js */ "./node_modules/ol/proj.js");
/**
 * @module ol/source/Source
 */



/**
 * @typedef {'undefined' | 'loading' | 'ready' | 'error'} State
 * State of the source, one of 'undefined', 'loading', 'ready' or 'error'.
 */

/**
 * A function that takes a {@link import("../View.js").ViewStateLayerStateExtent} and returns a string or
 * an array of strings representing source attributions.
 *
 * @typedef {function(import("../View.js").ViewStateLayerStateExtent): (string|Array<string>)} Attribution
 */

/**
 * A type that can be used to provide attribution information for data sources.
 *
 * It represents either
 * * a simple string (e.g. `'© Acme Inc.'`)
 * * an array of simple strings (e.g. `['© Acme Inc.', '© Bacme Inc.']`)
 * * a function that returns a string or array of strings ({@link module:ol/source/Source~Attribution})
 *
 * @typedef {string|Array<string>|Attribution} AttributionLike
 */

/**
 * @typedef {Object} Options
 * @property {AttributionLike} [attributions] Attributions.
 * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.
 * @property {import("../proj.js").ProjectionLike} [projection] Projection. Default is the view projection.
 * @property {import("./Source.js").State} [state='ready'] State.
 * @property {boolean} [wrapX=false] WrapX.
 * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,
 * the nearest neighbor is used when resampling.
 */

/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Base class for {@link module:ol/layer/Layer~Layer} sources.
 *
 * A generic `change` event is triggered when the state of the source changes.
 * @abstract
 * @api
 */
class Source extends _Object_js__WEBPACK_IMPORTED_MODULE_1__["default"] {
  /**
   * @param {Options} options Source options.
   */
  constructor(options) {
    super();

    /**
     * @protected
     * @type {import("../proj/Projection.js").default|null}
     */
    this.projection = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.get)(options.projection);

    /**
     * @private
     * @type {?Attribution}
     */
    this.attributions_ = adaptAttributions(options.attributions);

    /**
     * @private
     * @type {boolean}
     */
    this.attributionsCollapsible_ =
      options.attributionsCollapsible !== undefined
        ? options.attributionsCollapsible
        : true;

    /**
     * This source is currently loading data. Sources that defer loading to the
     * map's tile queue never set this to `true`.
     * @type {boolean}
     */
    this.loading = false;

    /**
     * @private
     * @type {import("./Source.js").State}
     */
    this.state_ = options.state !== undefined ? options.state : 'ready';

    /**
     * @private
     * @type {boolean}
     */
    this.wrapX_ = options.wrapX !== undefined ? options.wrapX : false;

    /**
     * @private
     * @type {boolean}
     */
    this.interpolate_ = !!options.interpolate;

    /**
     * @protected
     * @type {function(import("../View.js").ViewOptions):void}
     */
    this.viewResolver = null;

    /**
     * @protected
     * @type {function(Error):void}
     */
    this.viewRejector = null;

    const self = this;
    /**
     * @private
     * @type {Promise<import("../View.js").ViewOptions>}
     */
    this.viewPromise_ = new Promise(function (resolve, reject) {
      self.viewResolver = resolve;
      self.viewRejector = reject;
    });
  }

  /**
   * Get the attribution function for the source.
   * @return {?Attribution} Attribution function.
   * @api
   */
  getAttributions() {
    return this.attributions_;
  }

  /**
   * @return {boolean} Attributions are collapsible.
   * @api
   */
  getAttributionsCollapsible() {
    return this.attributionsCollapsible_;
  }

  /**
   * Get the projection of the source.
   * @return {import("../proj/Projection.js").default|null} Projection.
   * @api
   */
  getProjection() {
    return this.projection;
  }

  /**
   * @param {import("../proj/Projection").default} [projection] Projection.
   * @return {Array<number>|null} Resolutions.
   */
  getResolutions(projection) {
    return null;
  }

  /**
   * @return {Promise<import("../View.js").ViewOptions>} A promise for view-related properties.
   */
  getView() {
    return this.viewPromise_;
  }

  /**
   * Get the state of the source, see {@link import("./Source.js").State} for possible states.
   * @return {import("./Source.js").State} State.
   * @api
   */
  getState() {
    return this.state_;
  }

  /**
   * @return {boolean|undefined} Wrap X.
   */
  getWrapX() {
    return this.wrapX_;
  }

  /**
   * @return {boolean} Use linear interpolation when resampling.
   */
  getInterpolate() {
    return this.interpolate_;
  }

  /**
   * Refreshes the source. The source will be cleared, and data from the server will be reloaded.
   * @api
   */
  refresh() {
    this.changed();
  }

  /**
   * Set the attributions of the source.
   * @param {AttributionLike|undefined} attributions Attributions.
   *     Can be passed as `string`, `Array<string>`, {@link module:ol/source/Source~Attribution},
   *     or `undefined`.
   * @api
   */
  setAttributions(attributions) {
    this.attributions_ = adaptAttributions(attributions);
    this.changed();
  }

  /**
   * Set the state of the source.
   * @param {import("./Source.js").State} state State.
   */
  setState(state) {
    this.state_ = state;
    this.changed();
  }
}

/**
 * Turns the attributions option into an attributions function.
 * @param {AttributionLike|undefined} attributionLike The attribution option.
 * @return {Attribution|null} An attribution function (or null).
 */
function adaptAttributions(attributionLike) {
  if (!attributionLike) {
    return null;
  }
  if (Array.isArray(attributionLike)) {
    return function (frameState) {
      return attributionLike;
    };
  }

  if (typeof attributionLike === 'function') {
    return attributionLike;
  }

  return function (frameState) {
    return [attributionLike];
  };
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Source);


/***/ }),

/***/ "./node_modules/ol/source/Tile.js":
/*!****************************************!*\
  !*** ./node_modules/ol/source/Tile.js ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TileSourceEvent: () => (/* binding */ TileSourceEvent),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _events_Event_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../events/Event.js */ "./node_modules/ol/events/Event.js");
/* harmony import */ var _Source_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Source.js */ "./node_modules/ol/source/Source.js");
/* harmony import */ var _TileCache_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../TileCache.js */ "./node_modules/ol/TileCache.js");
/* harmony import */ var _TileState_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../TileState.js */ "./node_modules/ol/TileState.js");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../util.js */ "./node_modules/ol/util.js");
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../asserts.js */ "./node_modules/ol/asserts.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../proj.js */ "./node_modules/ol/proj.js");
/* harmony import */ var _tilecoord_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../tilecoord.js */ "./node_modules/ol/tilecoord.js");
/* harmony import */ var _tilegrid_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../tilegrid.js */ "./node_modules/ol/tilegrid.js");
/* harmony import */ var _size_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../size.js */ "./node_modules/ol/size.js");
/**
 * @module ol/source/Tile
 */











/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("../ObjectEventType").Types, import("../Object").ObjectEvent, Return> &
 *   import("../Observable").OnSignature<import("./TileEventType").TileSourceEventTypes, TileSourceEvent, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("../ObjectEventType").Types|
 *     import("./TileEventType").TileSourceEventTypes, Return>} TileSourceOnSignature
 */

/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.
 * @property {number} [cacheSize] CacheSize.
 * @property {boolean} [opaque=false] Whether the layer is opaque.
 * @property {number} [tilePixelRatio] TilePixelRatio.
 * @property {import("../proj.js").ProjectionLike} [projection] Projection.
 * @property {import("./Source.js").State} [state] State.
 * @property {import("../tilegrid/TileGrid.js").default} [tileGrid] TileGrid.
 * @property {boolean} [wrapX=false] WrapX.
 * @property {number} [transition] Transition.
 * @property {string} [key] Key.
 * @property {number|import("../array.js").NearestDirectionFunction} [zDirection=0] ZDirection.
 * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,
 * the nearest neighbor is used when resampling.
 */

/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Base class for sources providing images divided into a tile grid.
 * @abstract
 * @api
 */
class TileSource extends _Source_js__WEBPACK_IMPORTED_MODULE_1__["default"] {
  /**
   * @param {Options} options SourceTile source options.
   */
  constructor(options) {
    super({
      attributions: options.attributions,
      attributionsCollapsible: options.attributionsCollapsible,
      projection: options.projection,
      state: options.state,
      wrapX: options.wrapX,
      interpolate: options.interpolate,
    });

    /***
     * @type {TileSourceOnSignature<import("../events").EventsKey>}
     */
    this.on;

    /***
     * @type {TileSourceOnSignature<import("../events").EventsKey>}
     */
    this.once;

    /***
     * @type {TileSourceOnSignature<void>}
     */
    this.un;

    /**
     * @private
     * @type {boolean}
     */
    this.opaque_ = options.opaque !== undefined ? options.opaque : false;

    /**
     * @private
     * @type {number}
     */
    this.tilePixelRatio_ =
      options.tilePixelRatio !== undefined ? options.tilePixelRatio : 1;

    /**
     * @type {import("../tilegrid/TileGrid.js").default|null}
     */
    this.tileGrid = options.tileGrid !== undefined ? options.tileGrid : null;

    const tileSize = [256, 256];
    if (this.tileGrid) {
      (0,_size_js__WEBPACK_IMPORTED_MODULE_2__.toSize)(this.tileGrid.getTileSize(this.tileGrid.getMinZoom()), tileSize);
    }

    /**
     * @protected
     * @type {import("../TileCache.js").default}
     */
    this.tileCache = new _TileCache_js__WEBPACK_IMPORTED_MODULE_3__["default"](options.cacheSize || 0);

    /**
     * @protected
     * @type {import("../size.js").Size}
     */
    this.tmpSize = [0, 0];

    /**
     * @private
     * @type {string}
     */
    this.key_ = options.key || '';

    /**
     * @protected
     * @type {import("../Tile.js").Options}
     */
    this.tileOptions = {
      transition: options.transition,
      interpolate: options.interpolate,
    };

    /**
     * zDirection hint, read by the renderer. Indicates which resolution should be used
     * by a renderer if the views resolution does not match any resolution of the tile source.
     * If 0, the nearest resolution will be used. If 1, the nearest lower resolution
     * will be used. If -1, the nearest higher resolution will be used.
     * @type {number|import("../array.js").NearestDirectionFunction}
     */
    this.zDirection = options.zDirection ? options.zDirection : 0;
  }

  /**
   * @return {boolean} Can expire cache.
   */
  canExpireCache() {
    return this.tileCache.canExpireCache();
  }

  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @param {!Object<string, boolean>} usedTiles Used tiles.
   */
  expireCache(projection, usedTiles) {
    const tileCache = this.getTileCacheForProjection(projection);
    if (tileCache) {
      tileCache.expireCache(usedTiles);
    }
  }

  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @param {number} z Zoom level.
   * @param {import("../TileRange.js").default} tileRange Tile range.
   * @param {function(import("../Tile.js").default):(boolean|void)} callback Called with each
   *     loaded tile.  If the callback returns `false`, the tile will not be
   *     considered loaded.
   * @return {boolean} The tile range is fully covered with loaded tiles.
   */
  forEachLoadedTile(projection, z, tileRange, callback) {
    const tileCache = this.getTileCacheForProjection(projection);
    if (!tileCache) {
      return false;
    }

    let covered = true;
    let tile, tileCoordKey, loaded;
    for (let x = tileRange.minX; x <= tileRange.maxX; ++x) {
      for (let y = tileRange.minY; y <= tileRange.maxY; ++y) {
        tileCoordKey = (0,_tilecoord_js__WEBPACK_IMPORTED_MODULE_4__.getKeyZXY)(z, x, y);
        loaded = false;
        if (tileCache.containsKey(tileCoordKey)) {
          tile = /** @type {!import("../Tile.js").default} */ (
            tileCache.get(tileCoordKey)
          );
          loaded = tile.getState() === _TileState_js__WEBPACK_IMPORTED_MODULE_5__["default"].LOADED;
          if (loaded) {
            loaded = callback(tile) !== false;
          }
        }
        if (!loaded) {
          covered = false;
        }
      }
    }
    return covered;
  }

  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {number} Gutter.
   */
  getGutterForProjection(projection) {
    return 0;
  }

  /**
   * Return the key to be used for all tiles in the source.
   * @return {string} The key for all tiles.
   */
  getKey() {
    return this.key_;
  }

  /**
   * Set the value to be used as the key for all tiles in the source.
   * @param {string} key The key for tiles.
   * @protected
   */
  setKey(key) {
    if (this.key_ !== key) {
      this.key_ = key;
      this.changed();
    }
  }

  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {boolean} Opaque.
   */
  getOpaque(projection) {
    return this.opaque_;
  }

  /**
   * @param {import("../proj/Projection").default} [projection] Projection.
   * @return {Array<number>|null} Resolutions.
   */
  getResolutions(projection) {
    const tileGrid = projection
      ? this.getTileGridForProjection(projection)
      : this.tileGrid;
    if (!tileGrid) {
      return null;
    }
    return tileGrid.getResolutions();
  }

  /**
   * @abstract
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {!import("../Tile.js").default} Tile.
   */
  getTile(z, x, y, pixelRatio, projection) {
    return (0,_util_js__WEBPACK_IMPORTED_MODULE_6__.abstract)();
  }

  /**
   * Return the tile grid of the tile source.
   * @return {import("../tilegrid/TileGrid.js").default|null} Tile grid.
   * @api
   */
  getTileGrid() {
    return this.tileGrid;
  }

  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {!import("../tilegrid/TileGrid.js").default} Tile grid.
   */
  getTileGridForProjection(projection) {
    if (!this.tileGrid) {
      return (0,_tilegrid_js__WEBPACK_IMPORTED_MODULE_7__.getForProjection)(projection);
    }
    return this.tileGrid;
  }

  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../TileCache.js").default} Tile cache.
   * @protected
   */
  getTileCacheForProjection(projection) {
    const sourceProjection = this.getProjection();
    (0,_asserts_js__WEBPACK_IMPORTED_MODULE_8__.assert)(
      sourceProjection === null || (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.equivalent)(sourceProjection, projection),
      'A VectorTile source can only be rendered if it has a projection compatible with the view projection.'
    );
    return this.tileCache;
  }

  /**
   * Get the tile pixel ratio for this source. Subclasses may override this
   * method, which is meant to return a supported pixel ratio that matches the
   * provided `pixelRatio` as close as possible.
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} Tile pixel ratio.
   */
  getTilePixelRatio(pixelRatio) {
    return this.tilePixelRatio_;
  }

  /**
   * @param {number} z Z.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../size.js").Size} Tile size.
   */
  getTilePixelSize(z, pixelRatio, projection) {
    const tileGrid = this.getTileGridForProjection(projection);
    const tilePixelRatio = this.getTilePixelRatio(pixelRatio);
    const tileSize = (0,_size_js__WEBPACK_IMPORTED_MODULE_2__.toSize)(tileGrid.getTileSize(z), this.tmpSize);
    if (tilePixelRatio == 1) {
      return tileSize;
    }
    return (0,_size_js__WEBPACK_IMPORTED_MODULE_2__.scale)(tileSize, tilePixelRatio, this.tmpSize);
  }

  /**
   * Returns a tile coordinate wrapped around the x-axis. When the tile coordinate
   * is outside the resolution and extent range of the tile grid, `null` will be
   * returned.
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("../proj/Projection.js").default} [projection] Projection.
   * @return {import("../tilecoord.js").TileCoord} Tile coordinate to be passed to the tileUrlFunction or
   *     null if no tile URL should be created for the passed `tileCoord`.
   */
  getTileCoordForTileUrlFunction(tileCoord, projection) {
    projection = projection !== undefined ? projection : this.getProjection();
    const tileGrid = this.getTileGridForProjection(projection);
    if (this.getWrapX() && projection.isGlobal()) {
      tileCoord = (0,_tilegrid_js__WEBPACK_IMPORTED_MODULE_7__.wrapX)(tileGrid, tileCoord, projection);
    }
    return (0,_tilecoord_js__WEBPACK_IMPORTED_MODULE_4__.withinExtentAndZ)(tileCoord, tileGrid) ? tileCoord : null;
  }

  /**
   * Remove all cached tiles from the source. The next render cycle will fetch new tiles.
   * @api
   */
  clear() {
    this.tileCache.clear();
  }

  refresh() {
    this.clear();
    super.refresh();
  }

  /**
   * Increases the cache size if needed
   * @param {number} tileCount Minimum number of tiles needed.
   * @param {import("../proj/Projection.js").default} projection Projection.
   */
  updateCacheSize(tileCount, projection) {
    const tileCache = this.getTileCacheForProjection(projection);
    if (tileCount > tileCache.highWaterMark) {
      tileCache.highWaterMark = tileCount;
    }
  }

  /**
   * Marks a tile coord as being used, without triggering a load.
   * @abstract
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {import("../proj/Projection.js").default} projection Projection.
   */
  useTile(z, x, y, projection) {}
}

/**
 * @classdesc
 * Events emitted by {@link module:ol/source/Tile~TileSource} instances are instances of this
 * type.
 */
class TileSourceEvent extends _events_Event_js__WEBPACK_IMPORTED_MODULE_9__["default"] {
  /**
   * @param {string} type Type.
   * @param {import("../Tile.js").default} tile The tile.
   */
  constructor(type, tile) {
    super(type);

    /**
     * The tile related to the event.
     * @type {import("../Tile.js").default}
     * @api
     */
    this.tile = tile;
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (TileSource);


/***/ }),

/***/ "./node_modules/ol/source/TileEventType.js":
/*!*************************************************!*\
  !*** ./node_modules/ol/source/TileEventType.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * @module ol/source/TileEventType
 */

/**
 * @enum {string}
 */
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  /**
   * Triggered when a tile starts loading.
   * @event module:ol/source/Tile.TileSourceEvent#tileloadstart
   * @api
   */
  TILELOADSTART: 'tileloadstart',

  /**
   * Triggered when a tile finishes loading, either when its data is loaded,
   * or when loading was aborted because the tile is no longer needed.
   * @event module:ol/source/Tile.TileSourceEvent#tileloadend
   * @api
   */
  TILELOADEND: 'tileloadend',

  /**
   * Triggered if tile loading results in an error. Note that this is not the
   * right place to re-fetch tiles. See {@link module:ol/ImageTile~ImageTile#load}
   * for details.
   * @event module:ol/source/Tile.TileSourceEvent#tileloaderror
   * @api
   */
  TILELOADERROR: 'tileloaderror',
});

/**
 * @typedef {'tileloadstart'|'tileloadend'|'tileloaderror'} TileSourceEventTypes
 */


/***/ }),

/***/ "./node_modules/ol/source/TileImage.js":
/*!*********************************************!*\
  !*** ./node_modules/ol/source/TileImage.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../events/EventType.js */ "./node_modules/ol/events/EventType.js");
/* harmony import */ var _ImageTile_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../ImageTile.js */ "./node_modules/ol/ImageTile.js");
/* harmony import */ var _reproj_Tile_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../reproj/Tile.js */ "./node_modules/ol/reproj/Tile.js");
/* harmony import */ var _TileCache_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../TileCache.js */ "./node_modules/ol/TileCache.js");
/* harmony import */ var _TileState_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../TileState.js */ "./node_modules/ol/TileState.js");
/* harmony import */ var _UrlTile_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./UrlTile.js */ "./node_modules/ol/source/UrlTile.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../proj.js */ "./node_modules/ol/proj.js");
/* harmony import */ var _tilecoord_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../tilecoord.js */ "./node_modules/ol/tilecoord.js");
/* harmony import */ var _tilegrid_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../tilegrid.js */ "./node_modules/ol/tilegrid.js");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util.js */ "./node_modules/ol/util.js");
/**
 * @module ol/source/TileImage
 */











/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.
 * @property {number} [cacheSize] Initial tile cache size. Will auto-grow to hold at least the number of tiles in the viewport.
 * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that
 * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.
 * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
 * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,
 * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.
 * @property {boolean} [opaque=false] Whether the layer is opaque.
 * @property {import("../proj.js").ProjectionLike} [projection] Projection. Default is the view projection.
 * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).
 * Higher values can increase reprojection performance, but decrease precision.
 * @property {import("./Source.js").State} [state] Source state.
 * @property {typeof import("../ImageTile.js").default} [tileClass] Class used to instantiate image tiles.
 * Default is {@link module:ol/ImageTile~ImageTile}.
 * @property {import("../tilegrid/TileGrid.js").default} [tileGrid] Tile grid.
 * @property {import("../Tile.js").LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is
 * ```js
 * function(imageTile, src) {
 *   imageTile.getImage().src = src;
 * };
 * ```
 * @property {number} [tilePixelRatio=1] The pixel ratio used by the tile service. For example, if the tile
 * service advertizes 256px by 256px tiles but actually sends 512px
 * by 512px images (for retina/hidpi devices) then `tilePixelRatio`
 * should be set to `2`.
 * @property {import("../Tile.js").UrlFunction} [tileUrlFunction] Optional function to get tile URL given a tile coordinate and the projection.
 * @property {string} [url] URL template. Must include `{x}`, `{y}` or `{-y}`, and `{z}` placeholders.
 * A `{?-?}` template pattern, for example `subdomain{a-f}.domain.com`, may be
 * used instead of defining each one separately in the `urls` option.
 * @property {Array<string>} [urls] An array of URL templates.
 * @property {boolean} [wrapX] Whether to wrap the world horizontally. The default, is to
 * request out-of-bounds tiles from the server. When set to `false`, only one
 * world will be rendered. When set to `true`, tiles will be requested for one
 * world only, but they will be wrapped horizontally to render multiple worlds.
 * @property {number} [transition] Duration of the opacity transition for rendering.
 * To disable the opacity transition, pass `transition: 0`.
 * @property {string} [key] Optional tile key for proper cache fetching
 * @property {number|import("../array.js").NearestDirectionFunction} [zDirection=0]
 * Choose whether to use tiles with a higher or lower zoom level when between integer
 * zoom levels. See {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution}.
 */

/**
 * @classdesc
 * Base class for sources providing images divided into a tile grid.
 *
 * @fires import("./Tile.js").TileSourceEvent
 * @api
 */
class TileImage extends _UrlTile_js__WEBPACK_IMPORTED_MODULE_1__["default"] {
  /**
   * @param {!Options} options Image tile options.
   */
  constructor(options) {
    super({
      attributions: options.attributions,
      cacheSize: options.cacheSize,
      opaque: options.opaque,
      projection: options.projection,
      state: options.state,
      tileGrid: options.tileGrid,
      tileLoadFunction: options.tileLoadFunction
        ? options.tileLoadFunction
        : defaultTileLoadFunction,
      tilePixelRatio: options.tilePixelRatio,
      tileUrlFunction: options.tileUrlFunction,
      url: options.url,
      urls: options.urls,
      wrapX: options.wrapX,
      transition: options.transition,
      interpolate:
        options.interpolate !== undefined ? options.interpolate : true,
      key: options.key,
      attributionsCollapsible: options.attributionsCollapsible,
      zDirection: options.zDirection,
    });

    /**
     * @protected
     * @type {?string}
     */
    this.crossOrigin =
      options.crossOrigin !== undefined ? options.crossOrigin : null;

    /**
     * @protected
     * @type {typeof ImageTile}
     */
    this.tileClass =
      options.tileClass !== undefined ? options.tileClass : _ImageTile_js__WEBPACK_IMPORTED_MODULE_2__["default"];

    /**
     * @protected
     * @type {!Object<string, TileCache>}
     */
    this.tileCacheForProjection = {};

    /**
     * @protected
     * @type {!Object<string, import("../tilegrid/TileGrid.js").default>}
     */
    this.tileGridForProjection = {};

    /**
     * @private
     * @type {number|undefined}
     */
    this.reprojectionErrorThreshold_ = options.reprojectionErrorThreshold;

    /**
     * @private
     * @type {boolean}
     */
    this.renderReprojectionEdges_ = false;
  }

  /**
   * @return {boolean} Can expire cache.
   */
  canExpireCache() {
    if (this.tileCache.canExpireCache()) {
      return true;
    }
    for (const key in this.tileCacheForProjection) {
      if (this.tileCacheForProjection[key].canExpireCache()) {
        return true;
      }
    }

    return false;
  }

  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @param {!Object<string, boolean>} usedTiles Used tiles.
   */
  expireCache(projection, usedTiles) {
    const usedTileCache = this.getTileCacheForProjection(projection);

    this.tileCache.expireCache(
      this.tileCache == usedTileCache ? usedTiles : {}
    );
    for (const id in this.tileCacheForProjection) {
      const tileCache = this.tileCacheForProjection[id];
      tileCache.expireCache(tileCache == usedTileCache ? usedTiles : {});
    }
  }

  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {number} Gutter.
   */
  getGutterForProjection(projection) {
    if (
      this.getProjection() &&
      projection &&
      !(0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.equivalent)(this.getProjection(), projection)
    ) {
      return 0;
    }
    return this.getGutter();
  }

  /**
   * @return {number} Gutter.
   */
  getGutter() {
    return 0;
  }

  /**
   * Return the key to be used for all tiles in the source.
   * @return {string} The key for all tiles.
   */
  getKey() {
    let key = super.getKey();
    if (!this.getInterpolate()) {
      key += ':disable-interpolation';
    }
    return key;
  }

  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {boolean} Opaque.
   */
  getOpaque(projection) {
    if (
      this.getProjection() &&
      projection &&
      !(0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.equivalent)(this.getProjection(), projection)
    ) {
      return false;
    }
    return super.getOpaque(projection);
  }

  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {!import("../tilegrid/TileGrid.js").default} Tile grid.
   */
  getTileGridForProjection(projection) {
    const thisProj = this.getProjection();
    if (this.tileGrid && (!thisProj || (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.equivalent)(thisProj, projection))) {
      return this.tileGrid;
    }
    const projKey = (0,_util_js__WEBPACK_IMPORTED_MODULE_3__.getUid)(projection);
    if (!(projKey in this.tileGridForProjection)) {
      this.tileGridForProjection[projKey] =
        (0,_tilegrid_js__WEBPACK_IMPORTED_MODULE_4__.getForProjection)(projection);
    }
    return this.tileGridForProjection[projKey];
  }

  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../TileCache.js").default} Tile cache.
   */
  getTileCacheForProjection(projection) {
    const thisProj = this.getProjection();
    if (!thisProj || (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.equivalent)(thisProj, projection)) {
      return this.tileCache;
    }
    const projKey = (0,_util_js__WEBPACK_IMPORTED_MODULE_3__.getUid)(projection);
    if (!(projKey in this.tileCacheForProjection)) {
      this.tileCacheForProjection[projKey] = new _TileCache_js__WEBPACK_IMPORTED_MODULE_5__["default"](
        this.tileCache.highWaterMark
      );
    }
    return this.tileCacheForProjection[projKey];
  }

  /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @param {string} key The key set on the tile.
   * @return {!ImageTile} Tile.
   * @private
   */
  createTile_(z, x, y, pixelRatio, projection, key) {
    const tileCoord = [z, x, y];
    const urlTileCoord = this.getTileCoordForTileUrlFunction(
      tileCoord,
      projection
    );
    const tileUrl = urlTileCoord
      ? this.tileUrlFunction(urlTileCoord, pixelRatio, projection)
      : undefined;
    const tile = new this.tileClass(
      tileCoord,
      tileUrl !== undefined ? _TileState_js__WEBPACK_IMPORTED_MODULE_6__["default"].IDLE : _TileState_js__WEBPACK_IMPORTED_MODULE_6__["default"].EMPTY,
      tileUrl !== undefined ? tileUrl : '',
      this.crossOrigin,
      this.tileLoadFunction,
      this.tileOptions
    );
    tile.key = key;
    tile.addEventListener(_events_EventType_js__WEBPACK_IMPORTED_MODULE_7__["default"].CHANGE, this.handleTileChange.bind(this));
    return tile;
  }

  /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {!(ImageTile|ReprojTile)} Tile.
   */
  getTile(z, x, y, pixelRatio, projection) {
    const sourceProjection = this.getProjection();
    if (
      !sourceProjection ||
      !projection ||
      (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.equivalent)(sourceProjection, projection)
    ) {
      return this.getTileInternal(
        z,
        x,
        y,
        pixelRatio,
        sourceProjection || projection
      );
    }
    const cache = this.getTileCacheForProjection(projection);
    const tileCoord = [z, x, y];
    let tile;
    const tileCoordKey = (0,_tilecoord_js__WEBPACK_IMPORTED_MODULE_8__.getKey)(tileCoord);
    if (cache.containsKey(tileCoordKey)) {
      tile = cache.get(tileCoordKey);
    }
    const key = this.getKey();
    if (tile && tile.key == key) {
      return tile;
    }
    const sourceTileGrid = this.getTileGridForProjection(sourceProjection);
    const targetTileGrid = this.getTileGridForProjection(projection);
    const wrappedTileCoord = this.getTileCoordForTileUrlFunction(
      tileCoord,
      projection
    );
    const newTile = new _reproj_Tile_js__WEBPACK_IMPORTED_MODULE_9__["default"](
      sourceProjection,
      sourceTileGrid,
      projection,
      targetTileGrid,
      tileCoord,
      wrappedTileCoord,
      this.getTilePixelRatio(pixelRatio),
      this.getGutter(),
      (z, x, y, pixelRatio) =>
        this.getTileInternal(z, x, y, pixelRatio, sourceProjection),
      this.reprojectionErrorThreshold_,
      this.renderReprojectionEdges_,
      this.getInterpolate()
    );
    newTile.key = key;

    if (tile) {
      newTile.interimTile = tile;
      newTile.refreshInterimChain();
      cache.replace(tileCoordKey, newTile);
    } else {
      cache.set(tileCoordKey, newTile);
    }
    return newTile;
  }

  /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {number} pixelRatio Pixel ratio.
   * @param {!import("../proj/Projection.js").default} projection Projection.
   * @return {!ImageTile} Tile.
   * @protected
   */
  getTileInternal(z, x, y, pixelRatio, projection) {
    let tile = null;
    const tileCoordKey = (0,_tilecoord_js__WEBPACK_IMPORTED_MODULE_8__.getKeyZXY)(z, x, y);
    const key = this.getKey();
    if (!this.tileCache.containsKey(tileCoordKey)) {
      tile = this.createTile_(z, x, y, pixelRatio, projection, key);
      this.tileCache.set(tileCoordKey, tile);
    } else {
      tile = this.tileCache.get(tileCoordKey);
      if (tile.key != key) {
        // The source's params changed. If the tile has an interim tile and if we
        // can use it then we use it. Otherwise we create a new tile.  In both
        // cases we attempt to assign an interim tile to the new tile.
        const interimTile = tile;
        tile = this.createTile_(z, x, y, pixelRatio, projection, key);

        //make the new tile the head of the list,
        if (interimTile.getState() == _TileState_js__WEBPACK_IMPORTED_MODULE_6__["default"].IDLE) {
          //the old tile hasn't begun loading yet, and is now outdated, so we can simply discard it
          tile.interimTile = interimTile.interimTile;
        } else {
          tile.interimTile = interimTile;
        }
        tile.refreshInterimChain();
        this.tileCache.replace(tileCoordKey, tile);
      }
    }
    return tile;
  }

  /**
   * Sets whether to render reprojection edges or not (usually for debugging).
   * @param {boolean} render Render the edges.
   * @api
   */
  setRenderReprojectionEdges(render) {
    if (this.renderReprojectionEdges_ == render) {
      return;
    }
    this.renderReprojectionEdges_ = render;
    for (const id in this.tileCacheForProjection) {
      this.tileCacheForProjection[id].clear();
    }
    this.changed();
  }

  /**
   * Sets the tile grid to use when reprojecting the tiles to the given
   * projection instead of the default tile grid for the projection.
   *
   * This can be useful when the default tile grid cannot be created
   * (e.g. projection has no extent defined) or
   * for optimization reasons (custom tile size, resolutions, ...).
   *
   * @param {import("../proj.js").ProjectionLike} projection Projection.
   * @param {import("../tilegrid/TileGrid.js").default} tilegrid Tile grid to use for the projection.
   * @api
   */
  setTileGridForProjection(projection, tilegrid) {
    const proj = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.get)(projection);
    if (proj) {
      const projKey = (0,_util_js__WEBPACK_IMPORTED_MODULE_3__.getUid)(proj);
      if (!(projKey in this.tileGridForProjection)) {
        this.tileGridForProjection[projKey] = tilegrid;
      }
    }
  }

  clear() {
    super.clear();
    for (const id in this.tileCacheForProjection) {
      this.tileCacheForProjection[id].clear();
    }
  }
}

/**
 * @param {ImageTile} imageTile Image tile.
 * @param {string} src Source.
 */
function defaultTileLoadFunction(imageTile, src) {
  /** @type {HTMLImageElement|HTMLVideoElement} */ (imageTile.getImage()).src =
    src;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (TileImage);


/***/ }),

/***/ "./node_modules/ol/source/UrlTile.js":
/*!*******************************************!*\
  !*** ./node_modules/ol/source/UrlTile.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _TileEventType_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./TileEventType.js */ "./node_modules/ol/source/TileEventType.js");
/* harmony import */ var _Tile_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Tile.js */ "./node_modules/ol/source/Tile.js");
/* harmony import */ var _TileState_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../TileState.js */ "./node_modules/ol/TileState.js");
/* harmony import */ var _tileurlfunction_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../tileurlfunction.js */ "./node_modules/ol/tileurlfunction.js");
/* harmony import */ var _tilecoord_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../tilecoord.js */ "./node_modules/ol/tilecoord.js");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util.js */ "./node_modules/ol/util.js");
/**
 * @module ol/source/UrlTile
 */







/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.
 * @property {number} [cacheSize] Cache size.
 * @property {boolean} [opaque=false] Whether the layer is opaque.
 * @property {import("../proj.js").ProjectionLike} [projection] Projection.
 * @property {import("./Source.js").State} [state] State.
 * @property {import("../tilegrid/TileGrid.js").default} [tileGrid] TileGrid.
 * @property {import("../Tile.js").LoadFunction} tileLoadFunction TileLoadFunction.
 * @property {number} [tilePixelRatio] TilePixelRatio.
 * @property {import("../Tile.js").UrlFunction} [tileUrlFunction] TileUrlFunction.
 * @property {string} [url] Url.
 * @property {Array<string>} [urls] Urls.
 * @property {boolean} [wrapX=true] WrapX.
 * @property {number} [transition] Transition.
 * @property {string} [key] Key.
 * @property {number|import("../array.js").NearestDirectionFunction} [zDirection=0] ZDirection.
 * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,
 * the nearest neighbor is used when resampling.
 */

/**
 * @classdesc
 * Base class for sources providing tiles divided into a tile grid over http.
 *
 * @fires import("./Tile.js").TileSourceEvent
 */
class UrlTile extends _Tile_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {Options} options Image tile options.
   */
  constructor(options) {
    super({
      attributions: options.attributions,
      cacheSize: options.cacheSize,
      opaque: options.opaque,
      projection: options.projection,
      state: options.state,
      tileGrid: options.tileGrid,
      tilePixelRatio: options.tilePixelRatio,
      wrapX: options.wrapX,
      transition: options.transition,
      interpolate: options.interpolate,
      key: options.key,
      attributionsCollapsible: options.attributionsCollapsible,
      zDirection: options.zDirection,
    });

    /**
     * @private
     * @type {boolean}
     */
    this.generateTileUrlFunction_ =
      this.tileUrlFunction === UrlTile.prototype.tileUrlFunction;

    /**
     * @protected
     * @type {import("../Tile.js").LoadFunction}
     */
    this.tileLoadFunction = options.tileLoadFunction;

    if (options.tileUrlFunction) {
      this.tileUrlFunction = options.tileUrlFunction;
    }

    /**
     * @protected
     * @type {!Array<string>|null}
     */
    this.urls = null;

    if (options.urls) {
      this.setUrls(options.urls);
    } else if (options.url) {
      this.setUrl(options.url);
    }

    /**
     * @private
     * @type {!Object<string, boolean>}
     */
    this.tileLoadingKeys_ = {};
  }

  /**
   * Return the tile load function of the source.
   * @return {import("../Tile.js").LoadFunction} TileLoadFunction
   * @api
   */
  getTileLoadFunction() {
    return this.tileLoadFunction;
  }

  /**
   * Return the tile URL function of the source.
   * @return {import("../Tile.js").UrlFunction} TileUrlFunction
   * @api
   */
  getTileUrlFunction() {
    return Object.getPrototypeOf(this).tileUrlFunction === this.tileUrlFunction
      ? this.tileUrlFunction.bind(this)
      : this.tileUrlFunction;
  }

  /**
   * Return the URLs used for this source.
   * When a tileUrlFunction is used instead of url or urls,
   * null will be returned.
   * @return {!Array<string>|null} URLs.
   * @api
   */
  getUrls() {
    return this.urls;
  }

  /**
   * Handle tile change events.
   * @param {import("../events/Event.js").default} event Event.
   * @protected
   */
  handleTileChange(event) {
    const tile = /** @type {import("../Tile.js").default} */ (event.target);
    const uid = (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.getUid)(tile);
    const tileState = tile.getState();
    let type;
    if (tileState == _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADING) {
      this.tileLoadingKeys_[uid] = true;
      type = _TileEventType_js__WEBPACK_IMPORTED_MODULE_3__["default"].TILELOADSTART;
    } else if (uid in this.tileLoadingKeys_) {
      delete this.tileLoadingKeys_[uid];
      type =
        tileState == _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].ERROR
          ? _TileEventType_js__WEBPACK_IMPORTED_MODULE_3__["default"].TILELOADERROR
          : tileState == _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADED
          ? _TileEventType_js__WEBPACK_IMPORTED_MODULE_3__["default"].TILELOADEND
          : undefined;
    }
    if (type != undefined) {
      this.dispatchEvent(new _Tile_js__WEBPACK_IMPORTED_MODULE_0__.TileSourceEvent(type, tile));
    }
  }

  /**
   * Set the tile load function of the source.
   * @param {import("../Tile.js").LoadFunction} tileLoadFunction Tile load function.
   * @api
   */
  setTileLoadFunction(tileLoadFunction) {
    this.tileCache.clear();
    this.tileLoadFunction = tileLoadFunction;
    this.changed();
  }

  /**
   * Set the tile URL function of the source.
   * @param {import("../Tile.js").UrlFunction} tileUrlFunction Tile URL function.
   * @param {string} [key] Optional new tile key for the source.
   * @api
   */
  setTileUrlFunction(tileUrlFunction, key) {
    this.tileUrlFunction = tileUrlFunction;
    this.tileCache.pruneExceptNewestZ();
    if (typeof key !== 'undefined') {
      this.setKey(key);
    } else {
      this.changed();
    }
  }

  /**
   * Set the URL to use for requests.
   * @param {string} url URL.
   * @api
   */
  setUrl(url) {
    const urls = (0,_tileurlfunction_js__WEBPACK_IMPORTED_MODULE_4__.expandUrl)(url);
    this.urls = urls;
    this.setUrls(urls);
  }

  /**
   * Set the URLs to use for requests.
   * @param {Array<string>} urls URLs.
   * @api
   */
  setUrls(urls) {
    this.urls = urls;
    const key = urls.join('\n');
    if (this.generateTileUrlFunction_) {
      this.setTileUrlFunction((0,_tileurlfunction_js__WEBPACK_IMPORTED_MODULE_4__.createFromTemplates)(urls, this.tileGrid), key);
    } else {
      this.setKey(key);
    }
  }

  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {string|undefined} Tile URL.
   */
  tileUrlFunction(tileCoord, pixelRatio, projection) {
    return undefined;
  }

  /**
   * Marks a tile coord as being used, without triggering a load.
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   */
  useTile(z, x, y) {
    const tileCoordKey = (0,_tilecoord_js__WEBPACK_IMPORTED_MODULE_5__.getKeyZXY)(z, x, y);
    if (this.tileCache.containsKey(tileCoordKey)) {
      this.tileCache.get(tileCoordKey);
    }
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (UrlTile);


/***/ }),

/***/ "./node_modules/ol/source/Vector.js":
/*!******************************************!*\
  !*** ./node_modules/ol/source/Vector.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   VectorSourceEvent: () => (/* binding */ VectorSourceEvent),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Collection_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../Collection.js */ "./node_modules/ol/Collection.js");
/* harmony import */ var _CollectionEventType_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../CollectionEventType.js */ "./node_modules/ol/CollectionEventType.js");
/* harmony import */ var _events_Event_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../events/Event.js */ "./node_modules/ol/events/Event.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../events/EventType.js */ "./node_modules/ol/events/EventType.js");
/* harmony import */ var _ObjectEventType_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../ObjectEventType.js */ "./node_modules/ol/ObjectEventType.js");
/* harmony import */ var _structs_RBush_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../structs/RBush.js */ "./node_modules/ol/structs/RBush.js");
/* harmony import */ var _Source_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Source.js */ "./node_modules/ol/source/Source.js");
/* harmony import */ var _VectorEventType_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./VectorEventType.js */ "./node_modules/ol/source/VectorEventType.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../functions.js */ "./node_modules/ol/functions.js");
/* harmony import */ var _loadingstrategy_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../loadingstrategy.js */ "./node_modules/ol/loadingstrategy.js");
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../asserts.js */ "./node_modules/ol/asserts.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../util.js */ "./node_modules/ol/util.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../obj.js */ "./node_modules/ol/obj.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _featureloader_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../featureloader.js */ "./node_modules/ol/featureloader.js");
/**
 * @module ol/source/Vector
 */



















/**
 * A function that takes an {@link module:ol/extent~Extent} and a resolution as arguments, and
 * returns an array of {@link module:ol/extent~Extent} with the extents to load. Usually this
 * is one of the standard {@link module:ol/loadingstrategy} strategies.
 *
 * @typedef {function(import("../extent.js").Extent, number, import("../proj/Projection.js").default): Array<import("../extent.js").Extent>} LoadingStrategy
 * @api
 */

/**
 * @classdesc
 * Events emitted by {@link module:ol/source/Vector~VectorSource} instances are instances of this
 * type.
 * @template {import("../geom/Geometry.js").default} [Geometry=import("../geom/Geometry.js").default]
 */
class VectorSourceEvent extends _events_Event_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {string} type Type.
   * @param {import("../Feature.js").default<Geometry>} [feature] Feature.
   * @param {Array<import("../Feature.js").default<Geometry>>} [features] Features.
   */
  constructor(type, feature, features) {
    super(type);

    /**
     * The added or removed feature for the `ADDFEATURE` and `REMOVEFEATURE` events, `undefined` otherwise.
     * @type {import("../Feature.js").default<Geometry>|undefined}
     * @api
     */
    this.feature = feature;

    /**
     * The loaded features for the `FEATURESLOADED` event, `undefined` otherwise.
     * @type {Array<import("../Feature.js").default<Geometry>>|undefined}
     * @api
     */
    this.features = features;
  }
}

/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("../ObjectEventType").Types, import("../Object").ObjectEvent, Return> &
 *   import("../Observable").OnSignature<import("./VectorEventType").VectorSourceEventTypes, VectorSourceEvent, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("../ObjectEventType").Types|
 *     import("./VectorEventType").VectorSourceEventTypes, Return>} VectorSourceOnSignature
 */

/**
 * @template {import("../geom/Geometry.js").default} [Geometry=import("../geom/Geometry.js").default]
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {Array<import("../Feature.js").default<Geometry>>|Collection<import("../Feature.js").default<Geometry>>} [features]
 * Features. If provided as {@link module:ol/Collection~Collection}, the features in the source
 * and the collection will stay in sync.
 * @property {import("../format/Feature.js").default} [format] The feature format used by the XHR
 * feature loader when `url` is set. Required if `url` is set, otherwise ignored.
 * @property {import("../featureloader.js").FeatureLoader} [loader]
 * The loader function used to load features, from a remote source for example.
 * If this is not set and `url` is set, the source will create and use an XHR
 * feature loader. The `'featuresloadend'` and `'featuresloaderror'` events
 * will only fire if the `success` and `failure` callbacks are used.
 *
 * Example:
 *
 * ```js
 * import Vector from 'ol/source/Vector.js';
 * import GeoJSON from 'ol/format/GeoJSON.js';
 * import {bbox} from 'ol/loadingstrategy.js';
 *
 * const vectorSource = new Vector({
 *   format: new GeoJSON(),
 *   loader: function(extent, resolution, projection, success, failure) {
 *      const proj = projection.getCode();
 *      const url = 'https://ahocevar.com/geoserver/wfs?service=WFS&' +
 *          'version=1.1.0&request=GetFeature&typename=osm:water_areas&' +
 *          'outputFormat=application/json&srsname=' + proj + '&' +
 *          'bbox=' + extent.join(',') + ',' + proj;
 *      const xhr = new XMLHttpRequest();
 *      xhr.open('GET', url);
 *      const onError = function() {
 *        vectorSource.removeLoadedExtent(extent);
 *        failure();
 *      }
 *      xhr.onerror = onError;
 *      xhr.onload = function() {
 *        if (xhr.status == 200) {
 *          const features = vectorSource.getFormat().readFeatures(xhr.responseText);
 *          vectorSource.addFeatures(features);
 *          success(features);
 *        } else {
 *          onError();
 *        }
 *      }
 *      xhr.send();
 *    },
 *    strategy: bbox,
 *  });
 * ```
 * @property {boolean} [overlaps=true] This source may have overlapping geometries.
 * Setting this to `false` (e.g. for sources with polygons that represent administrative
 * boundaries or TopoJSON sources) allows the renderer to optimise fill and
 * stroke operations.
 * @property {LoadingStrategy} [strategy] The loading strategy to use.
 * By default an {@link module:ol/loadingstrategy.all}
 * strategy is used, a one-off strategy which loads all features at once.
 * @property {string|import("../featureloader.js").FeatureUrlFunction} [url]
 * Setting this option instructs the source to load features using an XHR loader
 * (see {@link module:ol/featureloader.xhr}). Use a `string` and an
 * {@link module:ol/loadingstrategy.all} for a one-off download of all features from
 * the given URL. Use a {@link module:ol/featureloader~FeatureUrlFunction} to generate the url with
 * other loading strategies.
 * Requires `format` to be set as well.
 * When default XHR feature loader is provided, the features will
 * be transformed from the data projection to the view projection
 * during parsing. If your remote data source does not advertise its projection
 * properly, this transformation will be incorrect. For some formats, the
 * default projection (usually EPSG:4326) can be overridden by setting the
 * dataProjection constructor option on the format.
 * Note that if a source contains non-feature data, such as a GeoJSON geometry
 * or a KML NetworkLink, these will be ignored. Use a custom loader to load these.
 * @property {boolean} [useSpatialIndex=true]
 * By default, an RTree is used as spatial index. When features are removed and
 * added frequently, and the total number of features is low, setting this to
 * `false` may improve performance.
 *
 * Note that
 * {@link module:ol/source/Vector~VectorSource#getFeaturesInExtent},
 * {@link module:ol/source/Vector~VectorSource#getClosestFeatureToCoordinate} and
 * {@link module:ol/source/Vector~VectorSource#getExtent} cannot be used when `useSpatialIndex` is
 * set to `false`, and {@link module:ol/source/Vector~VectorSource#forEachFeatureInExtent} will loop
 * through all features.
 *
 * When set to `false`, the features will be maintained in an
 * {@link module:ol/Collection~Collection}, which can be retrieved through
 * {@link module:ol/source/Vector~VectorSource#getFeaturesCollection}.
 * @property {boolean} [wrapX=true] Wrap the world horizontally. For vector editing across the
 * -180° and 180° meridians to work properly, this should be set to `false`. The
 * resulting geometry coordinates will then exceed the world bounds.
 */

/**
 * @classdesc
 * Provides a source of features for vector layers. Vector features provided
 * by this source are suitable for editing. See {@link module:ol/source/VectorTile~VectorTile} for
 * vector data that is optimized for rendering.
 *
 * @fires VectorSourceEvent
 * @api
 * @template {import("../geom/Geometry.js").default} [Geometry=import("../geom/Geometry.js").default]
 */
class VectorSource extends _Source_js__WEBPACK_IMPORTED_MODULE_1__["default"] {
  /**
   * @param {Options<Geometry>} [options] Vector source options.
   */
  constructor(options) {
    options = options || {};

    super({
      attributions: options.attributions,
      interpolate: true,
      projection: undefined,
      state: 'ready',
      wrapX: options.wrapX !== undefined ? options.wrapX : true,
    });

    /***
     * @type {VectorSourceOnSignature<import("../events").EventsKey>}
     */
    this.on;

    /***
     * @type {VectorSourceOnSignature<import("../events").EventsKey>}
     */
    this.once;

    /***
     * @type {VectorSourceOnSignature<void>}
     */
    this.un;

    /**
     * @private
     * @type {import("../featureloader.js").FeatureLoader}
     */
    this.loader_ = _functions_js__WEBPACK_IMPORTED_MODULE_2__.VOID;

    /**
     * @private
     * @type {import("../format/Feature.js").default|undefined}
     */
    this.format_ = options.format;

    /**
     * @private
     * @type {boolean}
     */
    this.overlaps_ = options.overlaps === undefined ? true : options.overlaps;

    /**
     * @private
     * @type {string|import("../featureloader.js").FeatureUrlFunction|undefined}
     */
    this.url_ = options.url;

    if (options.loader !== undefined) {
      this.loader_ = options.loader;
    } else if (this.url_ !== undefined) {
      (0,_asserts_js__WEBPACK_IMPORTED_MODULE_3__.assert)(this.format_, '`format` must be set when `url` is set');
      // create a XHR feature loader for "url" and "format"
      this.loader_ = (0,_featureloader_js__WEBPACK_IMPORTED_MODULE_4__.xhr)(
        this.url_,
        /** @type {import("../format/Feature.js").default} */ (this.format_)
      );
    }

    /**
     * @private
     * @type {LoadingStrategy}
     */
    this.strategy_ =
      options.strategy !== undefined ? options.strategy : _loadingstrategy_js__WEBPACK_IMPORTED_MODULE_5__.all;

    const useSpatialIndex =
      options.useSpatialIndex !== undefined ? options.useSpatialIndex : true;

    /**
     * @private
     * @type {RBush<import("../Feature.js").default<Geometry>>}
     */
    this.featuresRtree_ = useSpatialIndex ? new _structs_RBush_js__WEBPACK_IMPORTED_MODULE_6__["default"]() : null;

    /**
     * @private
     * @type {RBush<{extent: import("../extent.js").Extent}>}
     */
    this.loadedExtentsRtree_ = new _structs_RBush_js__WEBPACK_IMPORTED_MODULE_6__["default"]();

    /**
     * @type {number}
     * @private
     */
    this.loadingExtentsCount_ = 0;

    /**
     * @private
     * @type {!Object<string, import("../Feature.js").default<Geometry>>}
     */
    this.nullGeometryFeatures_ = {};

    /**
     * A lookup of features by id (the return from feature.getId()).
     * @private
     * @type {!Object<string, import("../Feature.js").default<Geometry>>}
     */
    this.idIndex_ = {};

    /**
     * A lookup of features by uid (using getUid(feature)).
     * @private
     * @type {!Object<string, import("../Feature.js").default<Geometry>>}
     */
    this.uidIndex_ = {};

    /**
     * @private
     * @type {Object<string, Array<import("../events.js").EventsKey>>}
     */
    this.featureChangeKeys_ = {};

    /**
     * @private
     * @type {Collection<import("../Feature.js").default<Geometry>>|null}
     */
    this.featuresCollection_ = null;

    /** @type {Collection<import("../Feature.js").default<Geometry>>} */
    let collection;
    /** @type {Array<import("../Feature.js").default<Geometry>>} */
    let features;
    if (Array.isArray(options.features)) {
      features = options.features;
    } else if (options.features) {
      collection = options.features;
      features = collection.getArray();
    }
    if (!useSpatialIndex && collection === undefined) {
      collection = new _Collection_js__WEBPACK_IMPORTED_MODULE_7__["default"](features);
    }
    if (features !== undefined) {
      this.addFeaturesInternal(features);
    }
    if (collection !== undefined) {
      this.bindFeaturesCollection_(collection);
    }
  }

  /**
   * Add a single feature to the source.  If you want to add a batch of features
   * at once, call {@link module:ol/source/Vector~VectorSource#addFeatures #addFeatures()}
   * instead. A feature will not be added to the source if feature with
   * the same id is already there. The reason for this behavior is to avoid
   * feature duplication when using bbox or tile loading strategies.
   * Note: this also applies if an {@link module:ol/Collection~Collection} is used for features,
   * meaning that if a feature with a duplicate id is added in the collection, it will
   * be removed from it right away.
   * @param {import("../Feature.js").default<Geometry>} feature Feature to add.
   * @api
   */
  addFeature(feature) {
    this.addFeatureInternal(feature);
    this.changed();
  }

  /**
   * Add a feature without firing a `change` event.
   * @param {import("../Feature.js").default<Geometry>} feature Feature.
   * @protected
   */
  addFeatureInternal(feature) {
    const featureKey = (0,_util_js__WEBPACK_IMPORTED_MODULE_8__.getUid)(feature);

    if (!this.addToIndex_(featureKey, feature)) {
      if (this.featuresCollection_) {
        this.featuresCollection_.remove(feature);
      }
      return;
    }

    this.setupChangeEvents_(featureKey, feature);

    const geometry = feature.getGeometry();
    if (geometry) {
      const extent = geometry.getExtent();
      if (this.featuresRtree_) {
        this.featuresRtree_.insert(extent, feature);
      }
    } else {
      this.nullGeometryFeatures_[featureKey] = feature;
    }

    this.dispatchEvent(
      new VectorSourceEvent(_VectorEventType_js__WEBPACK_IMPORTED_MODULE_9__["default"].ADDFEATURE, feature)
    );
  }

  /**
   * @param {string} featureKey Unique identifier for the feature.
   * @param {import("../Feature.js").default<Geometry>} feature The feature.
   * @private
   */
  setupChangeEvents_(featureKey, feature) {
    this.featureChangeKeys_[featureKey] = [
      (0,_events_js__WEBPACK_IMPORTED_MODULE_10__.listen)(feature, _events_EventType_js__WEBPACK_IMPORTED_MODULE_11__["default"].CHANGE, this.handleFeatureChange_, this),
      (0,_events_js__WEBPACK_IMPORTED_MODULE_10__.listen)(
        feature,
        _ObjectEventType_js__WEBPACK_IMPORTED_MODULE_12__["default"].PROPERTYCHANGE,
        this.handleFeatureChange_,
        this
      ),
    ];
  }

  /**
   * @param {string} featureKey Unique identifier for the feature.
   * @param {import("../Feature.js").default<Geometry>} feature The feature.
   * @return {boolean} The feature is "valid", in the sense that it is also a
   *     candidate for insertion into the Rtree.
   * @private
   */
  addToIndex_(featureKey, feature) {
    let valid = true;
    const id = feature.getId();
    if (id !== undefined) {
      if (!(id.toString() in this.idIndex_)) {
        this.idIndex_[id.toString()] = feature;
      } else {
        valid = false;
      }
    }
    if (valid) {
      (0,_asserts_js__WEBPACK_IMPORTED_MODULE_3__.assert)(
        !(featureKey in this.uidIndex_),
        'The passed `feature` was already added to the source'
      );
      this.uidIndex_[featureKey] = feature;
    }
    return valid;
  }

  /**
   * Add a batch of features to the source.
   * @param {Array<import("../Feature.js").default<Geometry>>} features Features to add.
   * @api
   */
  addFeatures(features) {
    this.addFeaturesInternal(features);
    this.changed();
  }

  /**
   * Add features without firing a `change` event.
   * @param {Array<import("../Feature.js").default<Geometry>>} features Features.
   * @protected
   */
  addFeaturesInternal(features) {
    const extents = [];
    const newFeatures = [];
    const geometryFeatures = [];

    for (let i = 0, length = features.length; i < length; i++) {
      const feature = features[i];
      const featureKey = (0,_util_js__WEBPACK_IMPORTED_MODULE_8__.getUid)(feature);
      if (this.addToIndex_(featureKey, feature)) {
        newFeatures.push(feature);
      }
    }

    for (let i = 0, length = newFeatures.length; i < length; i++) {
      const feature = newFeatures[i];
      const featureKey = (0,_util_js__WEBPACK_IMPORTED_MODULE_8__.getUid)(feature);
      this.setupChangeEvents_(featureKey, feature);

      const geometry = feature.getGeometry();
      if (geometry) {
        const extent = geometry.getExtent();
        extents.push(extent);
        geometryFeatures.push(feature);
      } else {
        this.nullGeometryFeatures_[featureKey] = feature;
      }
    }
    if (this.featuresRtree_) {
      this.featuresRtree_.load(extents, geometryFeatures);
    }

    if (this.hasListener(_VectorEventType_js__WEBPACK_IMPORTED_MODULE_9__["default"].ADDFEATURE)) {
      for (let i = 0, length = newFeatures.length; i < length; i++) {
        this.dispatchEvent(
          new VectorSourceEvent(_VectorEventType_js__WEBPACK_IMPORTED_MODULE_9__["default"].ADDFEATURE, newFeatures[i])
        );
      }
    }
  }

  /**
   * @param {!Collection<import("../Feature.js").default<Geometry>>} collection Collection.
   * @private
   */
  bindFeaturesCollection_(collection) {
    let modifyingCollection = false;
    this.addEventListener(
      _VectorEventType_js__WEBPACK_IMPORTED_MODULE_9__["default"].ADDFEATURE,
      /**
       * @param {VectorSourceEvent<Geometry>} evt The vector source event
       */
      function (evt) {
        if (!modifyingCollection) {
          modifyingCollection = true;
          collection.push(evt.feature);
          modifyingCollection = false;
        }
      }
    );
    this.addEventListener(
      _VectorEventType_js__WEBPACK_IMPORTED_MODULE_9__["default"].REMOVEFEATURE,
      /**
       * @param {VectorSourceEvent<Geometry>} evt The vector source event
       */
      function (evt) {
        if (!modifyingCollection) {
          modifyingCollection = true;
          collection.remove(evt.feature);
          modifyingCollection = false;
        }
      }
    );
    collection.addEventListener(
      _CollectionEventType_js__WEBPACK_IMPORTED_MODULE_13__["default"].ADD,
      /**
       * @param {import("../Collection.js").CollectionEvent<import("../Feature.js").default<Geometry>>} evt The collection event
       */
      (evt) => {
        if (!modifyingCollection) {
          modifyingCollection = true;
          this.addFeature(evt.element);
          modifyingCollection = false;
        }
      }
    );
    collection.addEventListener(
      _CollectionEventType_js__WEBPACK_IMPORTED_MODULE_13__["default"].REMOVE,
      /**
       * @param {import("../Collection.js").CollectionEvent<import("../Feature.js").default<Geometry>>} evt The collection event
       */
      (evt) => {
        if (!modifyingCollection) {
          modifyingCollection = true;
          this.removeFeature(evt.element);
          modifyingCollection = false;
        }
      }
    );
    this.featuresCollection_ = collection;
  }

  /**
   * Remove all features from the source.
   * @param {boolean} [fast] Skip dispatching of {@link module:ol/source/Vector.VectorSourceEvent#event:removefeature} events.
   * @api
   */
  clear(fast) {
    if (fast) {
      for (const featureId in this.featureChangeKeys_) {
        const keys = this.featureChangeKeys_[featureId];
        keys.forEach(_events_js__WEBPACK_IMPORTED_MODULE_10__.unlistenByKey);
      }
      if (!this.featuresCollection_) {
        this.featureChangeKeys_ = {};
        this.idIndex_ = {};
        this.uidIndex_ = {};
      }
    } else {
      if (this.featuresRtree_) {
        const removeAndIgnoreReturn = (feature) => {
          this.removeFeatureInternal(feature);
        };
        this.featuresRtree_.forEach(removeAndIgnoreReturn);
        for (const id in this.nullGeometryFeatures_) {
          this.removeFeatureInternal(this.nullGeometryFeatures_[id]);
        }
      }
    }
    if (this.featuresCollection_) {
      this.featuresCollection_.clear();
    }

    if (this.featuresRtree_) {
      this.featuresRtree_.clear();
    }
    this.nullGeometryFeatures_ = {};

    const clearEvent = new VectorSourceEvent(_VectorEventType_js__WEBPACK_IMPORTED_MODULE_9__["default"].CLEAR);
    this.dispatchEvent(clearEvent);
    this.changed();
  }

  /**
   * Iterate through all features on the source, calling the provided callback
   * with each one.  If the callback returns any "truthy" value, iteration will
   * stop and the function will return the same value.
   * Note: this function only iterate through the feature that have a defined geometry.
   *
   * @param {function(import("../Feature.js").default<Geometry>): T} callback Called with each feature
   *     on the source.  Return a truthy value to stop iteration.
   * @return {T|undefined} The return value from the last call to the callback.
   * @template T
   * @api
   */
  forEachFeature(callback) {
    if (this.featuresRtree_) {
      return this.featuresRtree_.forEach(callback);
    }
    if (this.featuresCollection_) {
      this.featuresCollection_.forEach(callback);
    }
  }

  /**
   * Iterate through all features whose geometries contain the provided
   * coordinate, calling the callback with each feature.  If the callback returns
   * a "truthy" value, iteration will stop and the function will return the same
   * value.
   *
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {function(import("../Feature.js").default<Geometry>): T} callback Called with each feature
   *     whose goemetry contains the provided coordinate.
   * @return {T|undefined} The return value from the last call to the callback.
   * @template T
   */
  forEachFeatureAtCoordinateDirect(coordinate, callback) {
    const extent = [coordinate[0], coordinate[1], coordinate[0], coordinate[1]];
    return this.forEachFeatureInExtent(extent, function (feature) {
      const geometry = feature.getGeometry();
      if (geometry.intersectsCoordinate(coordinate)) {
        return callback(feature);
      }
      return undefined;
    });
  }

  /**
   * Iterate through all features whose bounding box intersects the provided
   * extent (note that the feature's geometry may not intersect the extent),
   * calling the callback with each feature.  If the callback returns a "truthy"
   * value, iteration will stop and the function will return the same value.
   *
   * If you are interested in features whose geometry intersects an extent, call
   * the {@link module:ol/source/Vector~VectorSource#forEachFeatureIntersectingExtent #forEachFeatureIntersectingExtent()} method instead.
   *
   * When `useSpatialIndex` is set to false, this method will loop through all
   * features, equivalent to {@link module:ol/source/Vector~VectorSource#forEachFeature #forEachFeature()}.
   *
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {function(import("../Feature.js").default<Geometry>): T} callback Called with each feature
   *     whose bounding box intersects the provided extent.
   * @return {T|undefined} The return value from the last call to the callback.
   * @template T
   * @api
   */
  forEachFeatureInExtent(extent, callback) {
    if (this.featuresRtree_) {
      return this.featuresRtree_.forEachInExtent(extent, callback);
    }
    if (this.featuresCollection_) {
      this.featuresCollection_.forEach(callback);
    }
  }

  /**
   * Iterate through all features whose geometry intersects the provided extent,
   * calling the callback with each feature.  If the callback returns a "truthy"
   * value, iteration will stop and the function will return the same value.
   *
   * If you only want to test for bounding box intersection, call the
   * {@link module:ol/source/Vector~VectorSource#forEachFeatureInExtent #forEachFeatureInExtent()} method instead.
   *
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {function(import("../Feature.js").default<Geometry>): T} callback Called with each feature
   *     whose geometry intersects the provided extent.
   * @return {T|undefined} The return value from the last call to the callback.
   * @template T
   * @api
   */
  forEachFeatureIntersectingExtent(extent, callback) {
    return this.forEachFeatureInExtent(
      extent,
      /**
       * @param {import("../Feature.js").default<Geometry>} feature Feature.
       * @return {T|undefined} The return value from the last call to the callback.
       */
      function (feature) {
        const geometry = feature.getGeometry();
        if (geometry.intersectsExtent(extent)) {
          const result = callback(feature);
          if (result) {
            return result;
          }
        }
      }
    );
  }

  /**
   * Get the features collection associated with this source. Will be `null`
   * unless the source was configured with `useSpatialIndex` set to `false`, or
   * with an {@link module:ol/Collection~Collection} as `features`.
   * @return {Collection<import("../Feature.js").default<Geometry>>|null} The collection of features.
   * @api
   */
  getFeaturesCollection() {
    return this.featuresCollection_;
  }

  /**
   * Get a snapshot of the features currently on the source in random order. The returned array
   * is a copy, the features are references to the features in the source.
   * @return {Array<import("../Feature.js").default<Geometry>>} Features.
   * @api
   */
  getFeatures() {
    let features;
    if (this.featuresCollection_) {
      features = this.featuresCollection_.getArray().slice(0);
    } else if (this.featuresRtree_) {
      features = this.featuresRtree_.getAll();
      if (!(0,_obj_js__WEBPACK_IMPORTED_MODULE_14__.isEmpty)(this.nullGeometryFeatures_)) {
        (0,_array_js__WEBPACK_IMPORTED_MODULE_15__.extend)(features, Object.values(this.nullGeometryFeatures_));
      }
    }
    return /** @type {Array<import("../Feature.js").default<Geometry>>} */ (
      features
    );
  }

  /**
   * Get all features whose geometry intersects the provided coordinate.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @return {Array<import("../Feature.js").default<Geometry>>} Features.
   * @api
   */
  getFeaturesAtCoordinate(coordinate) {
    const features = [];
    this.forEachFeatureAtCoordinateDirect(coordinate, function (feature) {
      features.push(feature);
    });
    return features;
  }

  /**
   * Get all features whose bounding box intersects the provided extent.  Note that this returns an array of
   * all features intersecting the given extent in random order (so it may include
   * features whose geometries do not intersect the extent).
   *
   * When `useSpatialIndex` is set to false, this method will return all
   * features.
   *
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {import("../proj/Projection.js").default} [projection] Include features
   * where `extent` exceeds the x-axis bounds of `projection` and wraps around the world.
   * @return {Array<import("../Feature.js").default<Geometry>>} Features.
   * @api
   */
  getFeaturesInExtent(extent, projection) {
    if (this.featuresRtree_) {
      const multiWorld = projection && projection.canWrapX() && this.getWrapX();

      if (!multiWorld) {
        return this.featuresRtree_.getInExtent(extent);
      }

      const extents = (0,_extent_js__WEBPACK_IMPORTED_MODULE_16__.wrapAndSliceX)(extent, projection);

      return [].concat(
        ...extents.map((anExtent) => this.featuresRtree_.getInExtent(anExtent))
      );
    }
    if (this.featuresCollection_) {
      return this.featuresCollection_.getArray().slice(0);
    }
    return [];
  }

  /**
   * Get the closest feature to the provided coordinate.
   *
   * This method is not available when the source is configured with
   * `useSpatialIndex` set to `false`.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {function(import("../Feature.js").default<Geometry>):boolean} [filter] Feature filter function.
   *     The filter function will receive one argument, the {@link module:ol/Feature~Feature feature}
   *     and it should return a boolean value. By default, no filtering is made.
   * @return {import("../Feature.js").default<Geometry>} Closest feature.
   * @api
   */
  getClosestFeatureToCoordinate(coordinate, filter) {
    // Find the closest feature using branch and bound.  We start searching an
    // infinite extent, and find the distance from the first feature found.  This
    // becomes the closest feature.  We then compute a smaller extent which any
    // closer feature must intersect.  We continue searching with this smaller
    // extent, trying to find a closer feature.  Every time we find a closer
    // feature, we update the extent being searched so that any even closer
    // feature must intersect it.  We continue until we run out of features.
    const x = coordinate[0];
    const y = coordinate[1];
    let closestFeature = null;
    const closestPoint = [NaN, NaN];
    let minSquaredDistance = Infinity;
    const extent = [-Infinity, -Infinity, Infinity, Infinity];
    filter = filter ? filter : _functions_js__WEBPACK_IMPORTED_MODULE_2__.TRUE;
    this.featuresRtree_.forEachInExtent(
      extent,
      /**
       * @param {import("../Feature.js").default<Geometry>} feature Feature.
       */
      function (feature) {
        if (filter(feature)) {
          const geometry = feature.getGeometry();
          const previousMinSquaredDistance = minSquaredDistance;
          minSquaredDistance = geometry.closestPointXY(
            x,
            y,
            closestPoint,
            minSquaredDistance
          );
          if (minSquaredDistance < previousMinSquaredDistance) {
            closestFeature = feature;
            // This is sneaky.  Reduce the extent that it is currently being
            // searched while the R-Tree traversal using this same extent object
            // is still in progress.  This is safe because the new extent is
            // strictly contained by the old extent.
            const minDistance = Math.sqrt(minSquaredDistance);
            extent[0] = x - minDistance;
            extent[1] = y - minDistance;
            extent[2] = x + minDistance;
            extent[3] = y + minDistance;
          }
        }
      }
    );
    return closestFeature;
  }

  /**
   * Get the extent of the features currently in the source.
   *
   * This method is not available when the source is configured with
   * `useSpatialIndex` set to `false`.
   * @param {import("../extent.js").Extent} [extent] Destination extent. If provided, no new extent
   *     will be created. Instead, that extent's coordinates will be overwritten.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */
  getExtent(extent) {
    return this.featuresRtree_.getExtent(extent);
  }

  /**
   * Get a feature by its identifier (the value returned by feature.getId()).
   * Note that the index treats string and numeric identifiers as the same.  So
   * `source.getFeatureById(2)` will return a feature with id `'2'` or `2`.
   *
   * @param {string|number} id Feature identifier.
   * @return {import("../Feature.js").default<Geometry>|null} The feature (or `null` if not found).
   * @api
   */
  getFeatureById(id) {
    const feature = this.idIndex_[id.toString()];
    return feature !== undefined ? feature : null;
  }

  /**
   * Get a feature by its internal unique identifier (using `getUid`).
   *
   * @param {string} uid Feature identifier.
   * @return {import("../Feature.js").default<Geometry>|null} The feature (or `null` if not found).
   */
  getFeatureByUid(uid) {
    const feature = this.uidIndex_[uid];
    return feature !== undefined ? feature : null;
  }

  /**
   * Get the format associated with this source.
   *
   * @return {import("../format/Feature.js").default|undefined} The feature format.
   * @api
   */
  getFormat() {
    return this.format_;
  }

  /**
   * @return {boolean} The source can have overlapping geometries.
   */
  getOverlaps() {
    return this.overlaps_;
  }

  /**
   * Get the url associated with this source.
   *
   * @return {string|import("../featureloader.js").FeatureUrlFunction|undefined} The url.
   * @api
   */
  getUrl() {
    return this.url_;
  }

  /**
   * @param {Event} event Event.
   * @private
   */
  handleFeatureChange_(event) {
    const feature = /** @type {import("../Feature.js").default<Geometry>} */ (
      event.target
    );
    const featureKey = (0,_util_js__WEBPACK_IMPORTED_MODULE_8__.getUid)(feature);
    const geometry = feature.getGeometry();
    if (!geometry) {
      if (!(featureKey in this.nullGeometryFeatures_)) {
        if (this.featuresRtree_) {
          this.featuresRtree_.remove(feature);
        }
        this.nullGeometryFeatures_[featureKey] = feature;
      }
    } else {
      const extent = geometry.getExtent();
      if (featureKey in this.nullGeometryFeatures_) {
        delete this.nullGeometryFeatures_[featureKey];
        if (this.featuresRtree_) {
          this.featuresRtree_.insert(extent, feature);
        }
      } else {
        if (this.featuresRtree_) {
          this.featuresRtree_.update(extent, feature);
        }
      }
    }
    const id = feature.getId();
    if (id !== undefined) {
      const sid = id.toString();
      if (this.idIndex_[sid] !== feature) {
        this.removeFromIdIndex_(feature);
        this.idIndex_[sid] = feature;
      }
    } else {
      this.removeFromIdIndex_(feature);
      this.uidIndex_[featureKey] = feature;
    }
    this.changed();
    this.dispatchEvent(
      new VectorSourceEvent(_VectorEventType_js__WEBPACK_IMPORTED_MODULE_9__["default"].CHANGEFEATURE, feature)
    );
  }

  /**
   * Returns true if the feature is contained within the source.
   * @param {import("../Feature.js").default<Geometry>} feature Feature.
   * @return {boolean} Has feature.
   * @api
   */
  hasFeature(feature) {
    const id = feature.getId();
    if (id !== undefined) {
      return id in this.idIndex_;
    }
    return (0,_util_js__WEBPACK_IMPORTED_MODULE_8__.getUid)(feature) in this.uidIndex_;
  }

  /**
   * @return {boolean} Is empty.
   */
  isEmpty() {
    if (this.featuresRtree_) {
      return (
        this.featuresRtree_.isEmpty() && (0,_obj_js__WEBPACK_IMPORTED_MODULE_14__.isEmpty)(this.nullGeometryFeatures_)
      );
    }
    if (this.featuresCollection_) {
      return this.featuresCollection_.getLength() === 0;
    }
    return true;
  }

  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @param {import("../proj/Projection.js").default} projection Projection.
   */
  loadFeatures(extent, resolution, projection) {
    const loadedExtentsRtree = this.loadedExtentsRtree_;
    const extentsToLoad = this.strategy_(extent, resolution, projection);
    for (let i = 0, ii = extentsToLoad.length; i < ii; ++i) {
      const extentToLoad = extentsToLoad[i];
      const alreadyLoaded = loadedExtentsRtree.forEachInExtent(
        extentToLoad,
        /**
         * @param {{extent: import("../extent.js").Extent}} object Object.
         * @return {boolean} Contains.
         */
        function (object) {
          return (0,_extent_js__WEBPACK_IMPORTED_MODULE_16__.containsExtent)(object.extent, extentToLoad);
        }
      );
      if (!alreadyLoaded) {
        ++this.loadingExtentsCount_;
        this.dispatchEvent(
          new VectorSourceEvent(_VectorEventType_js__WEBPACK_IMPORTED_MODULE_9__["default"].FEATURESLOADSTART)
        );
        this.loader_.call(
          this,
          extentToLoad,
          resolution,
          projection,
          (features) => {
            --this.loadingExtentsCount_;
            this.dispatchEvent(
              new VectorSourceEvent(
                _VectorEventType_js__WEBPACK_IMPORTED_MODULE_9__["default"].FEATURESLOADEND,
                undefined,
                features
              )
            );
          },
          () => {
            --this.loadingExtentsCount_;
            this.dispatchEvent(
              new VectorSourceEvent(_VectorEventType_js__WEBPACK_IMPORTED_MODULE_9__["default"].FEATURESLOADERROR)
            );
          }
        );
        loadedExtentsRtree.insert(extentToLoad, {extent: extentToLoad.slice()});
      }
    }
    this.loading =
      this.loader_.length < 4 ? false : this.loadingExtentsCount_ > 0;
  }

  refresh() {
    this.clear(true);
    this.loadedExtentsRtree_.clear();
    super.refresh();
  }

  /**
   * Remove an extent from the list of loaded extents.
   * @param {import("../extent.js").Extent} extent Extent.
   * @api
   */
  removeLoadedExtent(extent) {
    const loadedExtentsRtree = this.loadedExtentsRtree_;
    let obj;
    loadedExtentsRtree.forEachInExtent(extent, function (object) {
      if ((0,_extent_js__WEBPACK_IMPORTED_MODULE_16__.equals)(object.extent, extent)) {
        obj = object;
        return true;
      }
    });
    if (obj) {
      loadedExtentsRtree.remove(obj);
    }
  }

  /**
   * Remove a single feature from the source.  If you want to remove all features
   * at once, use the {@link module:ol/source/Vector~VectorSource#clear #clear()} method
   * instead.
   * @param {import("../Feature.js").default<Geometry>} feature Feature to remove.
   * @api
   */
  removeFeature(feature) {
    if (!feature) {
      return;
    }
    const featureKey = (0,_util_js__WEBPACK_IMPORTED_MODULE_8__.getUid)(feature);
    if (featureKey in this.nullGeometryFeatures_) {
      delete this.nullGeometryFeatures_[featureKey];
    } else {
      if (this.featuresRtree_) {
        this.featuresRtree_.remove(feature);
      }
    }
    const result = this.removeFeatureInternal(feature);
    if (result) {
      this.changed();
    }
  }

  /**
   * Remove feature without firing a `change` event.
   * @param {import("../Feature.js").default<Geometry>} feature Feature.
   * @return {import("../Feature.js").default<Geometry>|undefined} The removed feature
   *     (or undefined if the feature was not found).
   * @protected
   */
  removeFeatureInternal(feature) {
    const featureKey = (0,_util_js__WEBPACK_IMPORTED_MODULE_8__.getUid)(feature);
    const featureChangeKeys = this.featureChangeKeys_[featureKey];
    if (!featureChangeKeys) {
      return;
    }
    featureChangeKeys.forEach(_events_js__WEBPACK_IMPORTED_MODULE_10__.unlistenByKey);
    delete this.featureChangeKeys_[featureKey];
    const id = feature.getId();
    if (id !== undefined) {
      delete this.idIndex_[id.toString()];
    }
    delete this.uidIndex_[featureKey];
    this.dispatchEvent(
      new VectorSourceEvent(_VectorEventType_js__WEBPACK_IMPORTED_MODULE_9__["default"].REMOVEFEATURE, feature)
    );
    return feature;
  }

  /**
   * Remove a feature from the id index.  Called internally when the feature id
   * may have changed.
   * @param {import("../Feature.js").default<Geometry>} feature The feature.
   * @return {boolean} Removed the feature from the index.
   * @private
   */
  removeFromIdIndex_(feature) {
    let removed = false;
    for (const id in this.idIndex_) {
      if (this.idIndex_[id] === feature) {
        delete this.idIndex_[id];
        removed = true;
        break;
      }
    }
    return removed;
  }

  /**
   * Set the new loader of the source. The next render cycle will use the
   * new loader.
   * @param {import("../featureloader.js").FeatureLoader} loader The loader to set.
   * @api
   */
  setLoader(loader) {
    this.loader_ = loader;
  }

  /**
   * Points the source to a new url. The next render cycle will use the new url.
   * @param {string|import("../featureloader.js").FeatureUrlFunction} url Url.
   * @api
   */
  setUrl(url) {
    (0,_asserts_js__WEBPACK_IMPORTED_MODULE_3__.assert)(this.format_, '`format` must be set when `url` is set');
    this.url_ = url;
    this.setLoader((0,_featureloader_js__WEBPACK_IMPORTED_MODULE_4__.xhr)(url, this.format_));
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (VectorSource);


/***/ }),

/***/ "./node_modules/ol/source/VectorEventType.js":
/*!***************************************************!*\
  !*** ./node_modules/ol/source/VectorEventType.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * @module ol/source/VectorEventType
 */

/**
 * @enum {string}
 */
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  /**
   * Triggered when a feature is added to the source.
   * @event module:ol/source/Vector.VectorSourceEvent#addfeature
   * @api
   */
  ADDFEATURE: 'addfeature',

  /**
   * Triggered when a feature is updated.
   * @event module:ol/source/Vector.VectorSourceEvent#changefeature
   * @api
   */
  CHANGEFEATURE: 'changefeature',

  /**
   * Triggered when the clear method is called on the source.
   * @event module:ol/source/Vector.VectorSourceEvent#clear
   * @api
   */
  CLEAR: 'clear',

  /**
   * Triggered when a feature is removed from the source.
   * See {@link module:ol/source/Vector~VectorSource#clear source.clear()} for exceptions.
   * @event module:ol/source/Vector.VectorSourceEvent#removefeature
   * @api
   */
  REMOVEFEATURE: 'removefeature',

  /**
   * Triggered when features starts loading.
   * @event module:ol/source/Vector.VectorSourceEvent#featuresloadstart
   * @api
   */
  FEATURESLOADSTART: 'featuresloadstart',

  /**
   * Triggered when features finishes loading.
   * @event module:ol/source/Vector.VectorSourceEvent#featuresloadend
   * @api
   */
  FEATURESLOADEND: 'featuresloadend',

  /**
   * Triggered if feature loading results in an error.
   * @event module:ol/source/Vector.VectorSourceEvent#featuresloaderror
   * @api
   */
  FEATURESLOADERROR: 'featuresloaderror',
});

/**
 * @typedef {'addfeature'|'changefeature'|'clear'|'removefeature'|'featuresloadstart'|'featuresloadend'|'featuresloaderror'} VectorSourceEventTypes
 */


/***/ }),

/***/ "./node_modules/ol/source/XYZ.js":
/*!***************************************!*\
  !*** ./node_modules/ol/source/XYZ.js ***!
  \***************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _TileImage_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./TileImage.js */ "./node_modules/ol/source/TileImage.js");
/* harmony import */ var _tilegrid_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../tilegrid.js */ "./node_modules/ol/tilegrid.js");
/**
 * @module ol/source/XYZ
 */




/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.
 * @property {number} [cacheSize] Initial tile cache size. Will auto-grow to hold at least the number of tiles in the viewport.
 * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that
 * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.
 * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
 * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,
 * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.
 * @property {boolean} [opaque=false] Whether the layer is opaque.
 * @property {import("../proj.js").ProjectionLike} [projection='EPSG:3857'] Projection.
 * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).
 * Higher values can increase reprojection performance, but decrease precision.
 * @property {number} [maxZoom=42] Optional max zoom level. Not used if `tileGrid` is provided.
 * @property {number} [minZoom=0] Optional min zoom level. Not used if `tileGrid` is provided.
 * @property {number} [maxResolution] Optional tile grid resolution at level zero. Not used if `tileGrid` is provided.
 * @property {import("../tilegrid/TileGrid.js").default} [tileGrid] Tile grid.
 * @property {import("../Tile.js").LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is
 * ```js
 * function(imageTile, src) {
 *   imageTile.getImage().src = src;
 * };
 * ```
 * @property {number} [tilePixelRatio=1] The pixel ratio used by the tile service.
 * For example, if the tile service advertizes 256px by 256px tiles but actually sends 512px
 * by 512px images (for retina/hidpi devices) then `tilePixelRatio`
 * should be set to `2`.
 * @property {number|import("../size.js").Size} [tileSize=[256, 256]] The tile size used by the tile service.
 * Not used if `tileGrid` is provided.
 * @property {number} [gutter=0] The size in pixels of the gutter around image tiles to ignore.
 * This allows artifacts of rendering at tile edges to be ignored.
 * Supported images should be wider and taller than the tile size by a value of `2 x gutter`.
 * @property {import("../Tile.js").UrlFunction} [tileUrlFunction] Optional function to get
 * tile URL given a tile coordinate and the projection.
 * Required if `url` or `urls` are not provided.
 * @property {string} [url] URL template. Must include `{x}`, `{y}` or `{-y}`,
 * and `{z}` placeholders. A `{?-?}` template pattern, for example `subdomain{a-f}.domain.com`,
 * may be used instead of defining each one separately in the `urls` option.
 * @property {Array<string>} [urls] An array of URL templates.
 * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.
 * @property {number} [transition=250] Duration of the opacity transition for rendering.
 * To disable the opacity transition, pass `transition: 0`.
 * @property {number|import("../array.js").NearestDirectionFunction} [zDirection=0]
 * Choose whether to use tiles with a higher or lower zoom level when between integer
 * zoom levels. See {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution}.
 */

/**
 * @classdesc
 * Layer source for tile data with URLs in a set XYZ format that are
 * defined in a URL template. By default, this follows the widely-used
 * Google grid where `x` 0 and `y` 0 are in the top left. Grids like
 * TMS where `x` 0 and `y` 0 are in the bottom left can be used by
 * using the `{-y}` placeholder in the URL template, so long as the
 * source does not have a custom tile grid. In this case
 * a `tileUrlFunction` can be used, such as:
 * ```js
 *  tileUrlFunction: function(coordinate) {
 *    return 'http://mapserver.com/' + coordinate[0] + '/' +
 *      coordinate[1] + '/' + (-coordinate[2] - 1) + '.png';
 *  }
 * ```
 * @api
 */
class XYZ extends _TileImage_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {Options} [options] XYZ options.
   */
  constructor(options) {
    options = options || {};

    const projection =
      options.projection !== undefined ? options.projection : 'EPSG:3857';

    const tileGrid =
      options.tileGrid !== undefined
        ? options.tileGrid
        : (0,_tilegrid_js__WEBPACK_IMPORTED_MODULE_1__.createXYZ)({
            extent: (0,_tilegrid_js__WEBPACK_IMPORTED_MODULE_1__.extentFromProjection)(projection),
            maxResolution: options.maxResolution,
            maxZoom: options.maxZoom,
            minZoom: options.minZoom,
            tileSize: options.tileSize,
          });

    super({
      attributions: options.attributions,
      cacheSize: options.cacheSize,
      crossOrigin: options.crossOrigin,
      interpolate: options.interpolate,
      opaque: options.opaque,
      projection: projection,
      reprojectionErrorThreshold: options.reprojectionErrorThreshold,
      tileGrid: tileGrid,
      tileLoadFunction: options.tileLoadFunction,
      tilePixelRatio: options.tilePixelRatio,
      tileUrlFunction: options.tileUrlFunction,
      url: options.url,
      urls: options.urls,
      wrapX: options.wrapX !== undefined ? options.wrapX : true,
      transition: options.transition,
      attributionsCollapsible: options.attributionsCollapsible,
      zDirection: options.zDirection,
    });

    /**
     * @private
     * @type {number}
     */
    this.gutter_ = options.gutter !== undefined ? options.gutter : 0;
  }

  /**
   * @return {number} Gutter.
   */
  getGutter() {
    return this.gutter_;
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (XYZ);


/***/ }),

/***/ "./node_modules/ol/sphere.js":
/*!***********************************!*\
  !*** ./node_modules/ol/sphere.js ***!
  \***********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DEFAULT_RADIUS: () => (/* binding */ DEFAULT_RADIUS),
/* harmony export */   getArea: () => (/* binding */ getArea),
/* harmony export */   getDistance: () => (/* binding */ getDistance),
/* harmony export */   getLength: () => (/* binding */ getLength),
/* harmony export */   offset: () => (/* binding */ offset)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.js */ "./node_modules/ol/math.js");
/**
 * @module ol/sphere
 */


/**
 * Object literal with options for the {@link getLength} or {@link getArea}
 * functions.
 * @typedef {Object} SphereMetricOptions
 * @property {import("./proj.js").ProjectionLike} [projection='EPSG:3857']
 * Projection of the  geometry.  By default, the geometry is assumed to be in
 * Web Mercator.
 * @property {number} [radius=6371008.8] Sphere radius.  By default, the
 * [mean Earth radius](https://en.wikipedia.org/wiki/Earth_radius#Mean_radius)
 * for the WGS84 ellipsoid is used.
 */

/**
 * The mean Earth radius (1/3 * (2a + b)) for the WGS84 ellipsoid.
 * https://en.wikipedia.org/wiki/Earth_radius#Mean_radius
 * @type {number}
 */
const DEFAULT_RADIUS = 6371008.8;

/**
 * Get the great circle distance (in meters) between two geographic coordinates.
 * @param {Array} c1 Starting coordinate.
 * @param {Array} c2 Ending coordinate.
 * @param {number} [radius] The sphere radius to use.  Defaults to the Earth's
 *     mean radius using the WGS84 ellipsoid.
 * @return {number} The great circle distance between the points (in meters).
 * @api
 */
function getDistance(c1, c2, radius) {
  radius = radius || DEFAULT_RADIUS;
  const lat1 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.toRadians)(c1[1]);
  const lat2 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.toRadians)(c2[1]);
  const deltaLatBy2 = (lat2 - lat1) / 2;
  const deltaLonBy2 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.toRadians)(c2[0] - c1[0]) / 2;
  const a =
    Math.sin(deltaLatBy2) * Math.sin(deltaLatBy2) +
    Math.sin(deltaLonBy2) *
      Math.sin(deltaLonBy2) *
      Math.cos(lat1) *
      Math.cos(lat2);
  return 2 * radius * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
}

/**
 * Get the cumulative great circle length of linestring coordinates (geographic).
 * @param {Array} coordinates Linestring coordinates.
 * @param {number} radius The sphere radius to use.
 * @return {number} The length (in meters).
 */
function getLengthInternal(coordinates, radius) {
  let length = 0;
  for (let i = 0, ii = coordinates.length; i < ii - 1; ++i) {
    length += getDistance(coordinates[i], coordinates[i + 1], radius);
  }
  return length;
}

/**
 * Get the spherical length of a geometry.  This length is the sum of the
 * great circle distances between coordinates.  For polygons, the length is
 * the sum of all rings.  For points, the length is zero.  For multi-part
 * geometries, the length is the sum of the length of each part.
 * @param {import("./geom/Geometry.js").default} geometry A geometry.
 * @param {SphereMetricOptions} [options] Options for the
 * length calculation.  By default, geometries are assumed to be in 'EPSG:3857'.
 * You can change this by providing a `projection` option.
 * @return {number} The spherical length (in meters).
 * @api
 */
function getLength(geometry, options) {
  options = options || {};
  const radius = options.radius || DEFAULT_RADIUS;
  const projection = options.projection || 'EPSG:3857';
  const type = geometry.getType();
  if (type !== 'GeometryCollection') {
    geometry = geometry.clone().transform(projection, 'EPSG:4326');
  }
  let length = 0;
  let coordinates, coords, i, ii, j, jj;
  switch (type) {
    case 'Point':
    case 'MultiPoint': {
      break;
    }
    case 'LineString':
    case 'LinearRing': {
      coordinates = /** @type {import("./geom/SimpleGeometry.js").default} */ (
        geometry
      ).getCoordinates();
      length = getLengthInternal(coordinates, radius);
      break;
    }
    case 'MultiLineString':
    case 'Polygon': {
      coordinates = /** @type {import("./geom/SimpleGeometry.js").default} */ (
        geometry
      ).getCoordinates();
      for (i = 0, ii = coordinates.length; i < ii; ++i) {
        length += getLengthInternal(coordinates[i], radius);
      }
      break;
    }
    case 'MultiPolygon': {
      coordinates = /** @type {import("./geom/SimpleGeometry.js").default} */ (
        geometry
      ).getCoordinates();
      for (i = 0, ii = coordinates.length; i < ii; ++i) {
        coords = coordinates[i];
        for (j = 0, jj = coords.length; j < jj; ++j) {
          length += getLengthInternal(coords[j], radius);
        }
      }
      break;
    }
    case 'GeometryCollection': {
      const geometries =
        /** @type {import("./geom/GeometryCollection.js").default} */ (
          geometry
        ).getGeometries();
      for (i = 0, ii = geometries.length; i < ii; ++i) {
        length += getLength(geometries[i], options);
      }
      break;
    }
    default: {
      throw new Error('Unsupported geometry type: ' + type);
    }
  }
  return length;
}

/**
 * Returns the spherical area for a list of coordinates.
 *
 * [Reference](https://trs.jpl.nasa.gov/handle/2014/40409)
 * Robert. G. Chamberlain and William H. Duquette, "Some Algorithms for
 * Polygons on a Sphere", JPL Publication 07-03, Jet Propulsion
 * Laboratory, Pasadena, CA, June 2007
 *
 * @param {Array<import("./coordinate.js").Coordinate>} coordinates List of coordinates of a linear
 * ring. If the ring is oriented clockwise, the area will be positive,
 * otherwise it will be negative.
 * @param {number} radius The sphere radius.
 * @return {number} Area (in square meters).
 */
function getAreaInternal(coordinates, radius) {
  let area = 0;
  const len = coordinates.length;
  let x1 = coordinates[len - 1][0];
  let y1 = coordinates[len - 1][1];
  for (let i = 0; i < len; i++) {
    const x2 = coordinates[i][0];
    const y2 = coordinates[i][1];
    area +=
      (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.toRadians)(x2 - x1) *
      (2 + Math.sin((0,_math_js__WEBPACK_IMPORTED_MODULE_0__.toRadians)(y1)) + Math.sin((0,_math_js__WEBPACK_IMPORTED_MODULE_0__.toRadians)(y2)));
    x1 = x2;
    y1 = y2;
  }
  return (area * radius * radius) / 2.0;
}

/**
 * Get the spherical area of a geometry.  This is the area (in meters) assuming
 * that polygon edges are segments of great circles on a sphere.
 * @param {import("./geom/Geometry.js").default} geometry A geometry.
 * @param {SphereMetricOptions} [options] Options for the area
 *     calculation.  By default, geometries are assumed to be in 'EPSG:3857'.
 *     You can change this by providing a `projection` option.
 * @return {number} The spherical area (in square meters).
 * @api
 */
function getArea(geometry, options) {
  options = options || {};
  const radius = options.radius || DEFAULT_RADIUS;
  const projection = options.projection || 'EPSG:3857';
  const type = geometry.getType();
  if (type !== 'GeometryCollection') {
    geometry = geometry.clone().transform(projection, 'EPSG:4326');
  }
  let area = 0;
  let coordinates, coords, i, ii, j, jj;
  switch (type) {
    case 'Point':
    case 'MultiPoint':
    case 'LineString':
    case 'MultiLineString':
    case 'LinearRing': {
      break;
    }
    case 'Polygon': {
      coordinates = /** @type {import("./geom/Polygon.js").default} */ (
        geometry
      ).getCoordinates();
      area = Math.abs(getAreaInternal(coordinates[0], radius));
      for (i = 1, ii = coordinates.length; i < ii; ++i) {
        area -= Math.abs(getAreaInternal(coordinates[i], radius));
      }
      break;
    }
    case 'MultiPolygon': {
      coordinates = /** @type {import("./geom/SimpleGeometry.js").default} */ (
        geometry
      ).getCoordinates();
      for (i = 0, ii = coordinates.length; i < ii; ++i) {
        coords = coordinates[i];
        area += Math.abs(getAreaInternal(coords[0], radius));
        for (j = 1, jj = coords.length; j < jj; ++j) {
          area -= Math.abs(getAreaInternal(coords[j], radius));
        }
      }
      break;
    }
    case 'GeometryCollection': {
      const geometries =
        /** @type {import("./geom/GeometryCollection.js").default} */ (
          geometry
        ).getGeometries();
      for (i = 0, ii = geometries.length; i < ii; ++i) {
        area += getArea(geometries[i], options);
      }
      break;
    }
    default: {
      throw new Error('Unsupported geometry type: ' + type);
    }
  }
  return area;
}

/**
 * Returns the coordinate at the given distance and bearing from `c1`.
 *
 * @param {import("./coordinate.js").Coordinate} c1 The origin point (`[lon, lat]` in degrees).
 * @param {number} distance The great-circle distance between the origin
 *     point and the target point.
 * @param {number} bearing The bearing (in radians).
 * @param {number} [radius] The sphere radius to use.  Defaults to the Earth's
 *     mean radius using the WGS84 ellipsoid.
 * @return {import("./coordinate.js").Coordinate} The target point.
 */
function offset(c1, distance, bearing, radius) {
  radius = radius || DEFAULT_RADIUS;
  const lat1 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.toRadians)(c1[1]);
  const lon1 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.toRadians)(c1[0]);
  const dByR = distance / radius;
  const lat = Math.asin(
    Math.sin(lat1) * Math.cos(dByR) +
      Math.cos(lat1) * Math.sin(dByR) * Math.cos(bearing)
  );
  const lon =
    lon1 +
    Math.atan2(
      Math.sin(bearing) * Math.sin(dByR) * Math.cos(lat1),
      Math.cos(dByR) - Math.sin(lat1) * Math.sin(lat)
    );
  return [(0,_math_js__WEBPACK_IMPORTED_MODULE_0__.toDegrees)(lon), (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.toDegrees)(lat)];
}


/***/ }),

/***/ "./node_modules/ol/string.js":
/*!***********************************!*\
  !*** ./node_modules/ol/string.js ***!
  \***********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   compareVersions: () => (/* binding */ compareVersions),
/* harmony export */   padNumber: () => (/* binding */ padNumber)
/* harmony export */ });
/**
 * @module ol/string
 */

/**
 * @param {number} number Number to be formatted
 * @param {number} width The desired width
 * @param {number} [precision] Precision of the output string (i.e. number of decimal places)
 * @return {string} Formatted string
 */
function padNumber(number, width, precision) {
  const numberString =
    precision !== undefined ? number.toFixed(precision) : '' + number;
  let decimal = numberString.indexOf('.');
  decimal = decimal === -1 ? numberString.length : decimal;
  return decimal > width
    ? numberString
    : new Array(1 + width - decimal).join('0') + numberString;
}

/**
 * Adapted from https://github.com/omichelsen/compare-versions/blob/master/index.js
 * @param {string|number} v1 First version
 * @param {string|number} v2 Second version
 * @return {number} Value
 */
function compareVersions(v1, v2) {
  const s1 = ('' + v1).split('.');
  const s2 = ('' + v2).split('.');

  for (let i = 0; i < Math.max(s1.length, s2.length); i++) {
    const n1 = parseInt(s1[i] || '0', 10);
    const n2 = parseInt(s2[i] || '0', 10);

    if (n1 > n2) {
      return 1;
    }
    if (n2 > n1) {
      return -1;
    }
  }

  return 0;
}


/***/ }),

/***/ "./node_modules/ol/structs/LRUCache.js":
/*!*********************************************!*\
  !*** ./node_modules/ol/structs/LRUCache.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../asserts.js */ "./node_modules/ol/asserts.js");
/**
 * @module ol/structs/LRUCache
 */



/**
 * @typedef {Object} Entry
 * @property {string} key_ Key.
 * @property {Object} newer Newer.
 * @property {Object} older Older.
 * @property {*} value_ Value.
 */

/**
 * @classdesc
 * Implements a Least-Recently-Used cache where the keys do not conflict with
 * Object's properties (e.g. 'hasOwnProperty' is not allowed as a key). Expiring
 * items from the cache is the responsibility of the user.
 *
 * @fires import("../events/Event.js").default
 * @template T
 */
class LRUCache {
  /**
   * @param {number} [highWaterMark] High water mark.
   */
  constructor(highWaterMark) {
    /**
     * Desired max cache size after expireCache(). If set to 0, no cache entries
     * will be pruned at all.
     * @type {number}
     */
    this.highWaterMark = highWaterMark !== undefined ? highWaterMark : 2048;

    /**
     * @private
     * @type {number}
     */
    this.count_ = 0;

    /**
     * @private
     * @type {!Object<string, Entry>}
     */
    this.entries_ = {};

    /**
     * @private
     * @type {?Entry}
     */
    this.oldest_ = null;

    /**
     * @private
     * @type {?Entry}
     */
    this.newest_ = null;
  }

  /**
   * @return {boolean} Can expire cache.
   */
  canExpireCache() {
    return this.highWaterMark > 0 && this.getCount() > this.highWaterMark;
  }

  /**
   * Expire the cache.
   * @param {!Object<string, boolean>} [keep] Keys to keep. To be implemented by subclasses.
   */
  expireCache(keep) {
    while (this.canExpireCache()) {
      this.pop();
    }
  }

  /**
   * FIXME empty description for jsdoc
   */
  clear() {
    this.count_ = 0;
    this.entries_ = {};
    this.oldest_ = null;
    this.newest_ = null;
  }

  /**
   * @param {string} key Key.
   * @return {boolean} Contains key.
   */
  containsKey(key) {
    return this.entries_.hasOwnProperty(key);
  }

  /**
   * @param {function(T, string, LRUCache<T>): ?} f The function
   *     to call for every entry from the oldest to the newer. This function takes
   *     3 arguments (the entry value, the entry key and the LRUCache object).
   *     The return value is ignored.
   */
  forEach(f) {
    let entry = this.oldest_;
    while (entry) {
      f(entry.value_, entry.key_, this);
      entry = entry.newer;
    }
  }

  /**
   * @param {string} key Key.
   * @param {*} [options] Options (reserved for subclasses).
   * @return {T} Value.
   */
  get(key, options) {
    const entry = this.entries_[key];
    (0,_asserts_js__WEBPACK_IMPORTED_MODULE_0__.assert)(
      entry !== undefined,
      'Tried to get a value for a key that does not exist in the cache'
    );
    if (entry === this.newest_) {
      return entry.value_;
    }
    if (entry === this.oldest_) {
      this.oldest_ = /** @type {Entry} */ (this.oldest_.newer);
      this.oldest_.older = null;
    } else {
      entry.newer.older = entry.older;
      entry.older.newer = entry.newer;
    }
    entry.newer = null;
    entry.older = this.newest_;
    this.newest_.newer = entry;
    this.newest_ = entry;
    return entry.value_;
  }

  /**
   * Remove an entry from the cache.
   * @param {string} key The entry key.
   * @return {T} The removed entry.
   */
  remove(key) {
    const entry = this.entries_[key];
    (0,_asserts_js__WEBPACK_IMPORTED_MODULE_0__.assert)(
      entry !== undefined,
      'Tried to get a value for a key that does not exist in the cache'
    );
    if (entry === this.newest_) {
      this.newest_ = /** @type {Entry} */ (entry.older);
      if (this.newest_) {
        this.newest_.newer = null;
      }
    } else if (entry === this.oldest_) {
      this.oldest_ = /** @type {Entry} */ (entry.newer);
      if (this.oldest_) {
        this.oldest_.older = null;
      }
    } else {
      entry.newer.older = entry.older;
      entry.older.newer = entry.newer;
    }
    delete this.entries_[key];
    --this.count_;
    return entry.value_;
  }

  /**
   * @return {number} Count.
   */
  getCount() {
    return this.count_;
  }

  /**
   * @return {Array<string>} Keys.
   */
  getKeys() {
    const keys = new Array(this.count_);
    let i = 0;
    let entry;
    for (entry = this.newest_; entry; entry = entry.older) {
      keys[i++] = entry.key_;
    }
    return keys;
  }

  /**
   * @return {Array<T>} Values.
   */
  getValues() {
    const values = new Array(this.count_);
    let i = 0;
    let entry;
    for (entry = this.newest_; entry; entry = entry.older) {
      values[i++] = entry.value_;
    }
    return values;
  }

  /**
   * @return {T} Last value.
   */
  peekLast() {
    return this.oldest_.value_;
  }

  /**
   * @return {string} Last key.
   */
  peekLastKey() {
    return this.oldest_.key_;
  }

  /**
   * Get the key of the newest item in the cache.  Throws if the cache is empty.
   * @return {string} The newest key.
   */
  peekFirstKey() {
    return this.newest_.key_;
  }

  /**
   * Return an entry without updating least recently used time.
   * @param {string} key Key.
   * @return {T} Value.
   */
  peek(key) {
    if (!this.containsKey(key)) {
      return undefined;
    }
    return this.entries_[key].value_;
  }

  /**
   * @return {T} value Value.
   */
  pop() {
    const entry = this.oldest_;
    delete this.entries_[entry.key_];
    if (entry.newer) {
      entry.newer.older = null;
    }
    this.oldest_ = /** @type {Entry} */ (entry.newer);
    if (!this.oldest_) {
      this.newest_ = null;
    }
    --this.count_;
    return entry.value_;
  }

  /**
   * @param {string} key Key.
   * @param {T} value Value.
   */
  replace(key, value) {
    this.get(key); // update `newest_`
    this.entries_[key].value_ = value;
  }

  /**
   * @param {string} key Key.
   * @param {T} value Value.
   */
  set(key, value) {
    (0,_asserts_js__WEBPACK_IMPORTED_MODULE_0__.assert)(
      !(key in this.entries_),
      'Tried to set a value for a key that is used already'
    );
    const entry = {
      key_: key,
      newer: null,
      older: this.newest_,
      value_: value,
    };
    if (!this.newest_) {
      this.oldest_ = entry;
    } else {
      this.newest_.newer = entry;
    }
    this.newest_ = entry;
    this.entries_[key] = entry;
    ++this.count_;
  }

  /**
   * Set a maximum number of entries for the cache.
   * @param {number} size Cache size.
   * @api
   */
  setSize(size) {
    this.highWaterMark = size;
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (LRUCache);


/***/ }),

/***/ "./node_modules/ol/structs/PriorityQueue.js":
/*!**************************************************!*\
  !*** ./node_modules/ol/structs/PriorityQueue.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DROP: () => (/* binding */ DROP),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../asserts.js */ "./node_modules/ol/asserts.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../obj.js */ "./node_modules/ol/obj.js");
/**
 * @module ol/structs/PriorityQueue
 */



/**
 * @type {number}
 */
const DROP = Infinity;

/**
 * @classdesc
 * Priority queue.
 *
 * The implementation is inspired from the Closure Library's Heap class and
 * Python's heapq module.
 *
 * See https://github.com/google/closure-library/blob/master/closure/goog/structs/heap.js
 * and https://hg.python.org/cpython/file/2.7/Lib/heapq.py.
 *
 * @template T
 */
class PriorityQueue {
  /**
   * @param {function(T): number} priorityFunction Priority function.
   * @param {function(T): string} keyFunction Key function.
   */
  constructor(priorityFunction, keyFunction) {
    /**
     * @type {function(T): number}
     * @private
     */
    this.priorityFunction_ = priorityFunction;

    /**
     * @type {function(T): string}
     * @private
     */
    this.keyFunction_ = keyFunction;

    /**
     * @type {Array<T>}
     * @private
     */
    this.elements_ = [];

    /**
     * @type {Array<number>}
     * @private
     */
    this.priorities_ = [];

    /**
     * @type {!Object<string, boolean>}
     * @private
     */
    this.queuedElements_ = {};
  }

  /**
   * FIXME empty description for jsdoc
   */
  clear() {
    this.elements_.length = 0;
    this.priorities_.length = 0;
    (0,_obj_js__WEBPACK_IMPORTED_MODULE_0__.clear)(this.queuedElements_);
  }

  /**
   * Remove and return the highest-priority element. O(log N).
   * @return {T} Element.
   */
  dequeue() {
    const elements = this.elements_;
    const priorities = this.priorities_;
    const element = elements[0];
    if (elements.length == 1) {
      elements.length = 0;
      priorities.length = 0;
    } else {
      elements[0] = elements.pop();
      priorities[0] = priorities.pop();
      this.siftUp_(0);
    }
    const elementKey = this.keyFunction_(element);
    delete this.queuedElements_[elementKey];
    return element;
  }

  /**
   * Enqueue an element. O(log N).
   * @param {T} element Element.
   * @return {boolean} The element was added to the queue.
   */
  enqueue(element) {
    (0,_asserts_js__WEBPACK_IMPORTED_MODULE_1__.assert)(
      !(this.keyFunction_(element) in this.queuedElements_),
      'Tried to enqueue an `element` that was already added to the queue'
    );
    const priority = this.priorityFunction_(element);
    if (priority != DROP) {
      this.elements_.push(element);
      this.priorities_.push(priority);
      this.queuedElements_[this.keyFunction_(element)] = true;
      this.siftDown_(0, this.elements_.length - 1);
      return true;
    }
    return false;
  }

  /**
   * @return {number} Count.
   */
  getCount() {
    return this.elements_.length;
  }

  /**
   * Gets the index of the left child of the node at the given index.
   * @param {number} index The index of the node to get the left child for.
   * @return {number} The index of the left child.
   * @private
   */
  getLeftChildIndex_(index) {
    return index * 2 + 1;
  }

  /**
   * Gets the index of the right child of the node at the given index.
   * @param {number} index The index of the node to get the right child for.
   * @return {number} The index of the right child.
   * @private
   */
  getRightChildIndex_(index) {
    return index * 2 + 2;
  }

  /**
   * Gets the index of the parent of the node at the given index.
   * @param {number} index The index of the node to get the parent for.
   * @return {number} The index of the parent.
   * @private
   */
  getParentIndex_(index) {
    return (index - 1) >> 1;
  }

  /**
   * Make this a heap. O(N).
   * @private
   */
  heapify_() {
    let i;
    for (i = (this.elements_.length >> 1) - 1; i >= 0; i--) {
      this.siftUp_(i);
    }
  }

  /**
   * @return {boolean} Is empty.
   */
  isEmpty() {
    return this.elements_.length === 0;
  }

  /**
   * @param {string} key Key.
   * @return {boolean} Is key queued.
   */
  isKeyQueued(key) {
    return key in this.queuedElements_;
  }

  /**
   * @param {T} element Element.
   * @return {boolean} Is queued.
   */
  isQueued(element) {
    return this.isKeyQueued(this.keyFunction_(element));
  }

  /**
   * @param {number} index The index of the node to move down.
   * @private
   */
  siftUp_(index) {
    const elements = this.elements_;
    const priorities = this.priorities_;
    const count = elements.length;
    const element = elements[index];
    const priority = priorities[index];
    const startIndex = index;

    while (index < count >> 1) {
      const lIndex = this.getLeftChildIndex_(index);
      const rIndex = this.getRightChildIndex_(index);

      const smallerChildIndex =
        rIndex < count && priorities[rIndex] < priorities[lIndex]
          ? rIndex
          : lIndex;

      elements[index] = elements[smallerChildIndex];
      priorities[index] = priorities[smallerChildIndex];
      index = smallerChildIndex;
    }

    elements[index] = element;
    priorities[index] = priority;
    this.siftDown_(startIndex, index);
  }

  /**
   * @param {number} startIndex The index of the root.
   * @param {number} index The index of the node to move up.
   * @private
   */
  siftDown_(startIndex, index) {
    const elements = this.elements_;
    const priorities = this.priorities_;
    const element = elements[index];
    const priority = priorities[index];

    while (index > startIndex) {
      const parentIndex = this.getParentIndex_(index);
      if (priorities[parentIndex] > priority) {
        elements[index] = elements[parentIndex];
        priorities[index] = priorities[parentIndex];
        index = parentIndex;
      } else {
        break;
      }
    }
    elements[index] = element;
    priorities[index] = priority;
  }

  /**
   * FIXME empty description for jsdoc
   */
  reprioritize() {
    const priorityFunction = this.priorityFunction_;
    const elements = this.elements_;
    const priorities = this.priorities_;
    let index = 0;
    const n = elements.length;
    let element, i, priority;
    for (i = 0; i < n; ++i) {
      element = elements[i];
      priority = priorityFunction(element);
      if (priority == DROP) {
        delete this.queuedElements_[this.keyFunction_(element)];
      } else {
        priorities[index] = priority;
        elements[index++] = element;
      }
    }
    elements.length = index;
    priorities.length = index;
    this.heapify_();
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (PriorityQueue);


/***/ }),

/***/ "./node_modules/ol/structs/RBush.js":
/*!******************************************!*\
  !*** ./node_modules/ol/structs/RBush.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var rbush__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! rbush */ "./node_modules/rbush/rbush.min.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util.js */ "./node_modules/ol/util.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../obj.js */ "./node_modules/ol/obj.js");
/**
 * @module ol/structs/RBush
 */





/**
 * @typedef {Object} Entry
 * @property {number} minX MinX.
 * @property {number} minY MinY.
 * @property {number} maxX MaxX.
 * @property {number} maxY MaxY.
 * @property {Object} [value] Value.
 */

/**
 * @classdesc
 * Wrapper around the RBush by Vladimir Agafonkin.
 * See https://github.com/mourner/rbush.
 *
 * @template T
 */
class RBush {
  /**
   * @param {number} [maxEntries] Max entries.
   */
  constructor(maxEntries) {
    /**
     * @private
     */
    this.rbush_ = new rbush__WEBPACK_IMPORTED_MODULE_0__(maxEntries);

    /**
     * A mapping between the objects added to this rbush wrapper
     * and the objects that are actually added to the internal rbush.
     * @private
     * @type {Object<string, Entry>}
     */
    this.items_ = {};
  }

  /**
   * Insert a value into the RBush.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {T} value Value.
   */
  insert(extent, value) {
    /** @type {Entry} */
    const item = {
      minX: extent[0],
      minY: extent[1],
      maxX: extent[2],
      maxY: extent[3],
      value: value,
    };

    this.rbush_.insert(item);
    this.items_[(0,_util_js__WEBPACK_IMPORTED_MODULE_1__.getUid)(value)] = item;
  }

  /**
   * Bulk-insert values into the RBush.
   * @param {Array<import("../extent.js").Extent>} extents Extents.
   * @param {Array<T>} values Values.
   */
  load(extents, values) {
    const items = new Array(values.length);
    for (let i = 0, l = values.length; i < l; i++) {
      const extent = extents[i];
      const value = values[i];

      /** @type {Entry} */
      const item = {
        minX: extent[0],
        minY: extent[1],
        maxX: extent[2],
        maxY: extent[3],
        value: value,
      };
      items[i] = item;
      this.items_[(0,_util_js__WEBPACK_IMPORTED_MODULE_1__.getUid)(value)] = item;
    }
    this.rbush_.load(items);
  }

  /**
   * Remove a value from the RBush.
   * @param {T} value Value.
   * @return {boolean} Removed.
   */
  remove(value) {
    const uid = (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.getUid)(value);

    // get the object in which the value was wrapped when adding to the
    // internal rbush. then use that object to do the removal.
    const item = this.items_[uid];
    delete this.items_[uid];
    return this.rbush_.remove(item) !== null;
  }

  /**
   * Update the extent of a value in the RBush.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {T} value Value.
   */
  update(extent, value) {
    const item = this.items_[(0,_util_js__WEBPACK_IMPORTED_MODULE_1__.getUid)(value)];
    const bbox = [item.minX, item.minY, item.maxX, item.maxY];
    if (!(0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.equals)(bbox, extent)) {
      this.remove(value);
      this.insert(extent, value);
    }
  }

  /**
   * Return all values in the RBush.
   * @return {Array<T>} All.
   */
  getAll() {
    const items = this.rbush_.all();
    return items.map(function (item) {
      return item.value;
    });
  }

  /**
   * Return all values in the given extent.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {Array<T>} All in extent.
   */
  getInExtent(extent) {
    /** @type {Entry} */
    const bbox = {
      minX: extent[0],
      minY: extent[1],
      maxX: extent[2],
      maxY: extent[3],
    };
    const items = this.rbush_.search(bbox);
    return items.map(function (item) {
      return item.value;
    });
  }

  /**
   * Calls a callback function with each value in the tree.
   * If the callback returns a truthy value, this value is returned without
   * checking the rest of the tree.
   * @param {function(T): *} callback Callback.
   * @return {*} Callback return value.
   */
  forEach(callback) {
    return this.forEach_(this.getAll(), callback);
  }

  /**
   * Calls a callback function with each value in the provided extent.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {function(T): *} callback Callback.
   * @return {*} Callback return value.
   */
  forEachInExtent(extent, callback) {
    return this.forEach_(this.getInExtent(extent), callback);
  }

  /**
   * @param {Array<T>} values Values.
   * @param {function(T): *} callback Callback.
   * @private
   * @return {*} Callback return value.
   */
  forEach_(values, callback) {
    let result;
    for (let i = 0, l = values.length; i < l; i++) {
      result = callback(values[i]);
      if (result) {
        return result;
      }
    }
    return result;
  }

  /**
   * @return {boolean} Is empty.
   */
  isEmpty() {
    return (0,_obj_js__WEBPACK_IMPORTED_MODULE_3__.isEmpty)(this.items_);
  }

  /**
   * Remove all values from the RBush.
   */
  clear() {
    this.rbush_.clear();
    this.items_ = {};
  }

  /**
   * @param {import("../extent.js").Extent} [extent] Extent.
   * @return {import("../extent.js").Extent} Extent.
   */
  getExtent(extent) {
    const data = this.rbush_.toJSON();
    return (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.createOrUpdate)(data.minX, data.minY, data.maxX, data.maxY, extent);
  }

  /**
   * @param {RBush} rbush R-Tree.
   */
  concat(rbush) {
    this.rbush_.load(rbush.rbush_.all());
    for (const i in rbush.items_) {
      this.items_[i] = rbush.items_[i];
    }
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (RBush);


/***/ }),

/***/ "./node_modules/ol/style/Circle.js":
/*!*****************************************!*\
  !*** ./node_modules/ol/style/Circle.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _RegularShape_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./RegularShape.js */ "./node_modules/ol/style/RegularShape.js");
/**
 * @module ol/style/Circle
 */



/**
 * @typedef {Object} Options
 * @property {import("./Fill.js").default} [fill] Fill style.
 * @property {number} radius Circle radius.
 * @property {import("./Stroke.js").default} [stroke] Stroke style.
 * @property {Array<number>} [displacement=[0,0]] displacement
 * @property {number|import("../size.js").Size} [scale=1] Scale. A two dimensional scale will produce an ellipse.
 * Unless two dimensional scaling is required a better result may be obtained with an appropriate setting for `radius`.
 * @property {number} [rotation=0] Rotation in radians
 * (positive rotation clockwise, meaningful only when used in conjunction with a two dimensional scale).
 * @property {boolean} [rotateWithView=false] Whether to rotate the shape with the view
 * (meaningful only when used in conjunction with a two dimensional scale).
 * @property {"declutter"|"obstacle"|"none"|undefined} [declutterMode] Declutter mode
 */

/**
 * @classdesc
 * Set circle style for vector features.
 * @api
 */
class CircleStyle extends _RegularShape_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {Options} [options] Options.
   */
  constructor(options) {
    options = options ? options : {radius: 5};

    super({
      points: Infinity,
      fill: options.fill,
      radius: options.radius,
      stroke: options.stroke,
      scale: options.scale !== undefined ? options.scale : 1,
      rotation: options.rotation !== undefined ? options.rotation : 0,
      rotateWithView:
        options.rotateWithView !== undefined ? options.rotateWithView : false,
      displacement:
        options.displacement !== undefined ? options.displacement : [0, 0],
      declutterMode: options.declutterMode,
    });
  }

  /**
   * Clones the style.
   * @return {CircleStyle} The cloned style.
   * @api
   */
  clone() {
    const scale = this.getScale();
    const style = new CircleStyle({
      fill: this.getFill() ? this.getFill().clone() : undefined,
      stroke: this.getStroke() ? this.getStroke().clone() : undefined,
      radius: this.getRadius(),
      scale: Array.isArray(scale) ? scale.slice() : scale,
      rotation: this.getRotation(),
      rotateWithView: this.getRotateWithView(),
      displacement: this.getDisplacement().slice(),
      declutterMode: this.getDeclutterMode(),
    });
    style.setOpacity(this.getOpacity());
    return style;
  }

  /**
   * Set the circle radius.
   *
   * @param {number} radius Circle radius.
   * @api
   */
  setRadius(radius) {
    this.radius_ = radius;
    this.render();
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CircleStyle);


/***/ }),

/***/ "./node_modules/ol/style/Fill.js":
/*!***************************************!*\
  !*** ./node_modules/ol/style/Fill.js ***!
  \***************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * @module ol/style/Fill
 */

/**
 * @typedef {Object} Options
 * @property {import("../color.js").Color|import("../colorlike.js").ColorLike|null} [color=null] A color, gradient or pattern.
 * See {@link module:ol/color~Color} and {@link module:ol/colorlike~ColorLike} for possible formats.
 * Default null; if null, the Canvas/renderer default black will be used.
 */

/**
 * @classdesc
 * Set fill style for vector features.
 * @api
 */
class Fill {
  /**
   * @param {Options} [options] Options.
   */
  constructor(options) {
    options = options || {};

    /**
     * @private
     * @type {import("../color.js").Color|import("../colorlike.js").ColorLike|null}
     */
    this.color_ = options.color !== undefined ? options.color : null;
  }

  /**
   * Clones the style. The color is not cloned if it is an {@link module:ol/colorlike~ColorLike}.
   * @return {Fill} The cloned style.
   * @api
   */
  clone() {
    const color = this.getColor();
    return new Fill({
      color: Array.isArray(color) ? color.slice() : color || undefined,
    });
  }

  /**
   * Get the fill color.
   * @return {import("../color.js").Color|import("../colorlike.js").ColorLike|null} Color.
   * @api
   */
  getColor() {
    return this.color_;
  }

  /**
   * Set the color.
   *
   * @param {import("../color.js").Color|import("../colorlike.js").ColorLike|null} color Color.
   * @api
   */
  setColor(color) {
    this.color_ = color;
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Fill);


/***/ }),

/***/ "./node_modules/ol/style/Icon.js":
/*!***************************************!*\
  !*** ./node_modules/ol/style/Icon.js ***!
  \***************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../events/EventType.js */ "./node_modules/ol/events/EventType.js");
/* harmony import */ var _ImageState_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../ImageState.js */ "./node_modules/ol/ImageState.js");
/* harmony import */ var _Image_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Image.js */ "./node_modules/ol/style/Image.js");
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../color.js */ "./node_modules/ol/color.js");
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../asserts.js */ "./node_modules/ol/asserts.js");
/* harmony import */ var _IconImage_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./IconImage.js */ "./node_modules/ol/style/IconImage.js");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util.js */ "./node_modules/ol/util.js");
/**
 * @module ol/style/Icon
 */








/**
 * @typedef {'fraction' | 'pixels'} IconAnchorUnits
 * Anchor unit can be either a fraction of the icon size or in pixels.
 */

/**
 * @typedef {'bottom-left' | 'bottom-right' | 'top-left' | 'top-right'} IconOrigin
 * Icon origin. One of 'bottom-left', 'bottom-right', 'top-left', 'top-right'.
 */

/**
 * @typedef {Object} Options
 * @property {Array<number>} [anchor=[0.5, 0.5]] Anchor. Default value is the icon center.
 * @property {IconOrigin} [anchorOrigin='top-left'] Origin of the anchor: `bottom-left`, `bottom-right`,
 * `top-left` or `top-right`.
 * @property {IconAnchorUnits} [anchorXUnits='fraction'] Units in which the anchor x value is
 * specified. A value of `'fraction'` indicates the x value is a fraction of the icon. A value of `'pixels'` indicates
 * the x value in pixels.
 * @property {IconAnchorUnits} [anchorYUnits='fraction'] Units in which the anchor y value is
 * specified. A value of `'fraction'` indicates the y value is a fraction of the icon. A value of `'pixels'` indicates
 * the y value in pixels.
 * @property {import("../color.js").Color|string} [color] Color to tint the icon. If not specified,
 * the icon will be left as is.
 * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images. Note that you must provide a
 * `crossOrigin` value if you want to access pixel data with the Canvas renderer.
 * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
 * @property {HTMLImageElement|HTMLCanvasElement|ImageBitmap} [img] Image object for the icon.
 * @property {Array<number>} [displacement=[0, 0]] Displacement of the icon in pixels.
 * Positive values will shift the icon right and up.
 * @property {number} [opacity=1] Opacity of the icon.
 * @property {number} [width] The width of the icon in pixels. This can't be used together with `scale`.
 * @property {number} [height] The height of the icon in pixels. This can't be used together with `scale`.
 * @property {number|import("../size.js").Size} [scale=1] Scale.
 * @property {boolean} [rotateWithView=false] Whether to rotate the icon with the view.
 * @property {number} [rotation=0] Rotation in radians (positive rotation clockwise).
 * @property {Array<number>} [offset=[0, 0]] Offset which, together with `size` and `offsetOrigin`, defines the
 * sub-rectangle to use from the original (sprite) image.
 * @property {IconOrigin} [offsetOrigin='top-left'] Origin of the offset: `bottom-left`, `bottom-right`,
 * `top-left` or `top-right`.
 * @property {import("../size.js").Size} [size] Icon size in pixels. Used together with `offset` to define the
 * sub-rectangle to use from the original (sprite) image.
 * @property {string} [src] Image source URI.
 * @property {"declutter"|"obstacle"|"none"|undefined} [declutterMode] Declutter mode.
 */

/**
 * @param {number} width The width.
 * @param {number} height The height.
 * @param {number|undefined} wantedWidth The wanted width.
 * @param {number|undefined} wantedHeight The wanted height.
 * @return {number|Array<number>} The scale.
 */
function calculateScale(width, height, wantedWidth, wantedHeight) {
  if (wantedWidth !== undefined && wantedHeight !== undefined) {
    return [wantedWidth / width, wantedHeight / height];
  }
  if (wantedWidth !== undefined) {
    return wantedWidth / width;
  }
  if (wantedHeight !== undefined) {
    return wantedHeight / height;
  }
  return 1;
}

/**
 * @classdesc
 * Set icon style for vector features.
 * @api
 */
class Icon extends _Image_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {Options} [options] Options.
   */
  constructor(options) {
    options = options || {};

    /**
     * @type {number}
     */
    const opacity = options.opacity !== undefined ? options.opacity : 1;

    /**
     * @type {number}
     */
    const rotation = options.rotation !== undefined ? options.rotation : 0;

    /**
     * @type {number|import("../size.js").Size}
     */
    const scale = options.scale !== undefined ? options.scale : 1;

    /**
     * @type {boolean}
     */
    const rotateWithView =
      options.rotateWithView !== undefined ? options.rotateWithView : false;

    super({
      opacity: opacity,
      rotation: rotation,
      scale: scale,
      displacement:
        options.displacement !== undefined ? options.displacement : [0, 0],
      rotateWithView: rotateWithView,
      declutterMode: options.declutterMode,
    });

    /**
     * @private
     * @type {Array<number>}
     */
    this.anchor_ = options.anchor !== undefined ? options.anchor : [0.5, 0.5];

    /**
     * @private
     * @type {Array<number>}
     */
    this.normalizedAnchor_ = null;

    /**
     * @private
     * @type {IconOrigin}
     */
    this.anchorOrigin_ =
      options.anchorOrigin !== undefined ? options.anchorOrigin : 'top-left';

    /**
     * @private
     * @type {IconAnchorUnits}
     */
    this.anchorXUnits_ =
      options.anchorXUnits !== undefined ? options.anchorXUnits : 'fraction';

    /**
     * @private
     * @type {IconAnchorUnits}
     */
    this.anchorYUnits_ =
      options.anchorYUnits !== undefined ? options.anchorYUnits : 'fraction';

    /**
     * @private
     * @type {?string}
     */
    this.crossOrigin_ =
      options.crossOrigin !== undefined ? options.crossOrigin : null;

    const image = options.img !== undefined ? options.img : null;

    let cacheKey = options.src;

    (0,_asserts_js__WEBPACK_IMPORTED_MODULE_1__.assert)(
      !(cacheKey !== undefined && image),
      '`image` and `src` cannot be provided at the same time'
    );

    if ((cacheKey === undefined || cacheKey.length === 0) && image) {
      cacheKey = /** @type {HTMLImageElement} */ (image).src || (0,_util_js__WEBPACK_IMPORTED_MODULE_2__.getUid)(image);
    }
    (0,_asserts_js__WEBPACK_IMPORTED_MODULE_1__.assert)(
      cacheKey !== undefined && cacheKey.length > 0,
      'A defined and non-empty `src` or `image` must be provided'
    );

    (0,_asserts_js__WEBPACK_IMPORTED_MODULE_1__.assert)(
      !(
        (options.width !== undefined || options.height !== undefined) &&
        options.scale !== undefined
      ),
      '`width` or `height` cannot be provided together with `scale`'
    );

    let imageState;
    if (options.src !== undefined) {
      imageState = _ImageState_js__WEBPACK_IMPORTED_MODULE_3__["default"].IDLE;
    } else if (image !== undefined) {
      if (image instanceof HTMLImageElement) {
        if (image.complete) {
          imageState = image.src ? _ImageState_js__WEBPACK_IMPORTED_MODULE_3__["default"].LOADED : _ImageState_js__WEBPACK_IMPORTED_MODULE_3__["default"].IDLE;
        } else {
          imageState = _ImageState_js__WEBPACK_IMPORTED_MODULE_3__["default"].LOADING;
        }
      } else {
        imageState = _ImageState_js__WEBPACK_IMPORTED_MODULE_3__["default"].LOADED;
      }
    }

    /**
     * @private
     * @type {import("../color.js").Color}
     */
    this.color_ = options.color !== undefined ? (0,_color_js__WEBPACK_IMPORTED_MODULE_4__.asArray)(options.color) : null;

    /**
     * @private
     * @type {import("./IconImage.js").default}
     */
    this.iconImage_ = (0,_IconImage_js__WEBPACK_IMPORTED_MODULE_5__.get)(
      image,
      /** @type {string} */ (cacheKey),
      this.crossOrigin_,
      imageState,
      this.color_
    );

    /**
     * @private
     * @type {Array<number>}
     */
    this.offset_ = options.offset !== undefined ? options.offset : [0, 0];
    /**
     * @private
     * @type {IconOrigin}
     */
    this.offsetOrigin_ =
      options.offsetOrigin !== undefined ? options.offsetOrigin : 'top-left';

    /**
     * @private
     * @type {Array<number>}
     */
    this.origin_ = null;

    /**
     * @private
     * @type {import("../size.js").Size}
     */
    this.size_ = options.size !== undefined ? options.size : null;

    /**
     * Calculate the scale if width or height were given.
     */
    if (options.width !== undefined || options.height !== undefined) {
      let width, height;
      if (options.size) {
        [width, height] = options.size;
      } else {
        const image = this.getImage(1);
        if (image.width && image.height) {
          width = image.width;
          height = image.height;
        } else if (image instanceof HTMLImageElement) {
          this.initialOptions_ = options;
          const onload = () => {
            this.unlistenImageChange(onload);
            if (!this.initialOptions_) {
              return;
            }
            const imageSize = this.iconImage_.getSize();
            this.setScale(
              calculateScale(
                imageSize[0],
                imageSize[1],
                options.width,
                options.height
              )
            );
          };
          this.listenImageChange(onload);
          return;
        }
      }
      if (width !== undefined) {
        this.setScale(
          calculateScale(width, height, options.width, options.height)
        );
      }
    }
  }

  /**
   * Clones the style. The underlying Image/HTMLCanvasElement is not cloned.
   * @return {Icon} The cloned style.
   * @api
   */
  clone() {
    let scale, width, height;
    if (this.initialOptions_) {
      width = this.initialOptions_.width;
      height = this.initialOptions_.height;
    } else {
      scale = this.getScale();
      scale = Array.isArray(scale) ? scale.slice() : scale;
    }
    return new Icon({
      anchor: this.anchor_.slice(),
      anchorOrigin: this.anchorOrigin_,
      anchorXUnits: this.anchorXUnits_,
      anchorYUnits: this.anchorYUnits_,
      color:
        this.color_ && this.color_.slice
          ? this.color_.slice()
          : this.color_ || undefined,
      crossOrigin: this.crossOrigin_,
      offset: this.offset_.slice(),
      offsetOrigin: this.offsetOrigin_,
      opacity: this.getOpacity(),
      rotateWithView: this.getRotateWithView(),
      rotation: this.getRotation(),
      scale,
      width,
      height,
      size: this.size_ !== null ? this.size_.slice() : undefined,
      src: this.getSrc(),
      displacement: this.getDisplacement().slice(),
      declutterMode: this.getDeclutterMode(),
    });
  }

  /**
   * Get the anchor point in pixels. The anchor determines the center point for the
   * symbolizer.
   * @return {Array<number>} Anchor.
   * @api
   */
  getAnchor() {
    let anchor = this.normalizedAnchor_;
    if (!anchor) {
      anchor = this.anchor_;
      const size = this.getSize();
      if (
        this.anchorXUnits_ == 'fraction' ||
        this.anchorYUnits_ == 'fraction'
      ) {
        if (!size) {
          return null;
        }
        anchor = this.anchor_.slice();
        if (this.anchorXUnits_ == 'fraction') {
          anchor[0] *= size[0];
        }
        if (this.anchorYUnits_ == 'fraction') {
          anchor[1] *= size[1];
        }
      }

      if (this.anchorOrigin_ != 'top-left') {
        if (!size) {
          return null;
        }
        if (anchor === this.anchor_) {
          anchor = this.anchor_.slice();
        }
        if (
          this.anchorOrigin_ == 'top-right' ||
          this.anchorOrigin_ == 'bottom-right'
        ) {
          anchor[0] = -anchor[0] + size[0];
        }
        if (
          this.anchorOrigin_ == 'bottom-left' ||
          this.anchorOrigin_ == 'bottom-right'
        ) {
          anchor[1] = -anchor[1] + size[1];
        }
      }
      this.normalizedAnchor_ = anchor;
    }
    const displacement = this.getDisplacement();
    const scale = this.getScaleArray();
    // anchor is scaled by renderer but displacement should not be scaled
    // so divide by scale here
    return [
      anchor[0] - displacement[0] / scale[0],
      anchor[1] + displacement[1] / scale[1],
    ];
  }

  /**
   * Set the anchor point. The anchor determines the center point for the
   * symbolizer.
   *
   * @param {Array<number>} anchor Anchor.
   * @api
   */
  setAnchor(anchor) {
    this.anchor_ = anchor;
    this.normalizedAnchor_ = null;
  }

  /**
   * Get the icon color.
   * @return {import("../color.js").Color} Color.
   * @api
   */
  getColor() {
    return this.color_;
  }

  /**
   * Get the image icon.
   * @param {number} pixelRatio Pixel ratio.
   * @return {HTMLImageElement|HTMLCanvasElement|ImageBitmap} Image or Canvas element. If the Icon
   * style was configured with `src` or with a not let loaded `img`, an `ImageBitmap` will be returned.
   * @api
   */
  getImage(pixelRatio) {
    return this.iconImage_.getImage(pixelRatio);
  }

  /**
   * Get the pixel ratio.
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} The pixel ratio of the image.
   * @api
   */
  getPixelRatio(pixelRatio) {
    return this.iconImage_.getPixelRatio(pixelRatio);
  }

  /**
   * @return {import("../size.js").Size} Image size.
   */
  getImageSize() {
    return this.iconImage_.getSize();
  }

  /**
   * @return {import("../ImageState.js").default} Image state.
   */
  getImageState() {
    return this.iconImage_.getImageState();
  }

  /**
   * @return {HTMLImageElement|HTMLCanvasElement|ImageBitmap} Image element.
   */
  getHitDetectionImage() {
    return this.iconImage_.getHitDetectionImage();
  }

  /**
   * Get the origin of the symbolizer.
   * @return {Array<number>} Origin.
   * @api
   */
  getOrigin() {
    if (this.origin_) {
      return this.origin_;
    }
    let offset = this.offset_;

    if (this.offsetOrigin_ != 'top-left') {
      const size = this.getSize();
      const iconImageSize = this.iconImage_.getSize();
      if (!size || !iconImageSize) {
        return null;
      }
      offset = offset.slice();
      if (
        this.offsetOrigin_ == 'top-right' ||
        this.offsetOrigin_ == 'bottom-right'
      ) {
        offset[0] = iconImageSize[0] - size[0] - offset[0];
      }
      if (
        this.offsetOrigin_ == 'bottom-left' ||
        this.offsetOrigin_ == 'bottom-right'
      ) {
        offset[1] = iconImageSize[1] - size[1] - offset[1];
      }
    }
    this.origin_ = offset;
    return this.origin_;
  }

  /**
   * Get the image URL.
   * @return {string|undefined} Image src.
   * @api
   */
  getSrc() {
    return this.iconImage_.getSrc();
  }

  /**
   * Get the size of the icon (in pixels).
   * @return {import("../size.js").Size} Image size.
   * @api
   */
  getSize() {
    return !this.size_ ? this.iconImage_.getSize() : this.size_;
  }

  /**
   * Get the width of the icon (in pixels). Will return undefined when the icon image is not yet loaded.
   * @return {number} Icon width (in pixels).
   * @api
   */
  getWidth() {
    const scale = this.getScaleArray();
    if (this.size_) {
      return this.size_[0] * scale[0];
    }
    if (this.iconImage_.getImageState() == _ImageState_js__WEBPACK_IMPORTED_MODULE_3__["default"].LOADED) {
      return this.iconImage_.getSize()[0] * scale[0];
    }
    return undefined;
  }

  /**
   * Get the height of the icon (in pixels). Will return undefined when the icon image is not yet loaded.
   * @return {number} Icon height (in pixels).
   * @api
   */
  getHeight() {
    const scale = this.getScaleArray();
    if (this.size_) {
      return this.size_[1] * scale[1];
    }
    if (this.iconImage_.getImageState() == _ImageState_js__WEBPACK_IMPORTED_MODULE_3__["default"].LOADED) {
      return this.iconImage_.getSize()[1] * scale[1];
    }
    return undefined;
  }

  /**
   * Set the scale.
   *
   * @param {number|import("../size.js").Size} scale Scale.
   * @api
   */
  setScale(scale) {
    delete this.initialOptions_;
    super.setScale(scale);
  }

  /**
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   */
  listenImageChange(listener) {
    this.iconImage_.addEventListener(_events_EventType_js__WEBPACK_IMPORTED_MODULE_6__["default"].CHANGE, listener);
  }

  /**
   * Load not yet loaded URI.
   * When rendering a feature with an icon style, the vector renderer will
   * automatically call this method. However, you might want to call this
   * method yourself for preloading or other purposes.
   * @api
   */
  load() {
    this.iconImage_.load();
  }

  /**
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   */
  unlistenImageChange(listener) {
    this.iconImage_.removeEventListener(_events_EventType_js__WEBPACK_IMPORTED_MODULE_6__["default"].CHANGE, listener);
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Icon);


/***/ }),

/***/ "./node_modules/ol/style/IconImage.js":
/*!********************************************!*\
  !*** ./node_modules/ol/style/IconImage.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   get: () => (/* binding */ get)
/* harmony export */ });
/* harmony import */ var _events_Target_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../events/Target.js */ "./node_modules/ol/events/Target.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../events/EventType.js */ "./node_modules/ol/events/EventType.js");
/* harmony import */ var _ImageState_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ImageState.js */ "./node_modules/ol/ImageState.js");
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../color.js */ "./node_modules/ol/color.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../dom.js */ "./node_modules/ol/dom.js");
/* harmony import */ var _Image_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../Image.js */ "./node_modules/ol/Image.js");
/* harmony import */ var _IconImageCache_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./IconImageCache.js */ "./node_modules/ol/style/IconImageCache.js");
/**
 * @module ol/style/IconImage
 */









/**
 * @type {CanvasRenderingContext2D}
 */
let taintedTestContext = null;

class IconImage extends _events_Target_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {HTMLImageElement|HTMLCanvasElement|ImageBitmap} image Image.
   * @param {string|undefined} src Src.
   * @param {?string} crossOrigin Cross origin.
   * @param {import("../ImageState.js").default} imageState Image state.
   * @param {import("../color.js").Color} color Color.
   */
  constructor(image, src, crossOrigin, imageState, color) {
    super();

    /**
     * @private
     * @type {HTMLImageElement|HTMLCanvasElement|ImageBitmap}
     */
    this.hitDetectionImage_ = null;

    /**
     * @private
     * @type {HTMLImageElement|HTMLCanvasElement|ImageBitmap}
     */
    this.image_ = image;

    /**
     * @private
     * @type {string|null}
     */
    this.crossOrigin_ = crossOrigin;

    /**
     * @private
     * @type {Object<number, HTMLCanvasElement>}
     */
    this.canvas_ = {};

    /**
     * @private
     * @type {import("../color.js").Color}
     */
    this.color_ = color;

    /**
     * @private
     * @type {import("../ImageState.js").default}
     */
    this.imageState_ = imageState === undefined ? _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].IDLE : imageState;

    /**
     * @private
     * @type {import("../size.js").Size|null}
     */
    this.size_ =
      image && image.width && image.height ? [image.width, image.height] : null;

    /**
     * @private
     * @type {string|undefined}
     */
    this.src_ = src;

    /**
     * @private
     */
    this.tainted_;
  }

  /**
   * @private
   */
  initializeImage_() {
    this.image_ = new Image();
    if (this.crossOrigin_ !== null) {
      this.image_.crossOrigin = this.crossOrigin_;
    }
  }

  /**
   * @private
   * @return {boolean} The image canvas is tainted.
   */
  isTainted_() {
    if (this.tainted_ === undefined && this.imageState_ === _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADED) {
      if (!taintedTestContext) {
        taintedTestContext = (0,_dom_js__WEBPACK_IMPORTED_MODULE_2__.createCanvasContext2D)(1, 1, undefined, {
          willReadFrequently: true,
        });
      }
      taintedTestContext.drawImage(this.image_, 0, 0);
      try {
        taintedTestContext.getImageData(0, 0, 1, 1);
        this.tainted_ = false;
      } catch (e) {
        taintedTestContext = null;
        this.tainted_ = true;
      }
    }
    return this.tainted_ === true;
  }

  /**
   * @private
   */
  dispatchChangeEvent_() {
    this.dispatchEvent(_events_EventType_js__WEBPACK_IMPORTED_MODULE_3__["default"].CHANGE);
  }

  /**
   * @private
   */
  handleImageError_() {
    this.imageState_ = _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].ERROR;
    this.dispatchChangeEvent_();
  }

  /**
   * @private
   */
  handleImageLoad_() {
    this.imageState_ = _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADED;
    this.size_ = [this.image_.width, this.image_.height];
    this.dispatchChangeEvent_();
  }

  /**
   * @param {number} pixelRatio Pixel ratio.
   * @return {HTMLImageElement|HTMLCanvasElement|ImageBitmap} Image or Canvas element or image bitmap.
   */
  getImage(pixelRatio) {
    if (!this.image_) {
      this.initializeImage_();
    }
    this.replaceColor_(pixelRatio);
    return this.canvas_[pixelRatio] ? this.canvas_[pixelRatio] : this.image_;
  }

  /**
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} Image or Canvas element.
   */
  getPixelRatio(pixelRatio) {
    this.replaceColor_(pixelRatio);
    return this.canvas_[pixelRatio] ? pixelRatio : 1;
  }

  /**
   * @return {import("../ImageState.js").default} Image state.
   */
  getImageState() {
    return this.imageState_;
  }

  /**
   * @return {HTMLImageElement|HTMLCanvasElement|ImageBitmap} Image element.
   */
  getHitDetectionImage() {
    if (!this.image_) {
      this.initializeImage_();
    }
    if (!this.hitDetectionImage_) {
      if (this.isTainted_()) {
        const width = this.size_[0];
        const height = this.size_[1];
        const context = (0,_dom_js__WEBPACK_IMPORTED_MODULE_2__.createCanvasContext2D)(width, height);
        context.fillRect(0, 0, width, height);
        this.hitDetectionImage_ = context.canvas;
      } else {
        this.hitDetectionImage_ = this.image_;
      }
    }
    return this.hitDetectionImage_;
  }

  /**
   * Get the size of the icon (in pixels).
   * @return {import("../size.js").Size} Image size.
   */
  getSize() {
    return this.size_;
  }

  /**
   * @return {string|undefined} Image src.
   */
  getSrc() {
    return this.src_;
  }

  /**
   * Load not yet loaded URI.
   */
  load() {
    if (this.imageState_ !== _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].IDLE) {
      return;
    }
    if (!this.image_) {
      this.initializeImage_();
    }

    this.imageState_ = _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADING;
    try {
      if (this.src_ !== undefined) {
        /** @type {HTMLImageElement} */ (this.image_).src = this.src_;
      }
    } catch (e) {
      this.handleImageError_();
    }
    if (this.image_ instanceof HTMLImageElement) {
      (0,_Image_js__WEBPACK_IMPORTED_MODULE_4__.decodeFallback)(this.image_, this.src_)
        .then((image) => {
          this.image_ = image;
          this.handleImageLoad_();
        })
        .catch(this.handleImageError_.bind(this));
    }
  }

  /**
   * @param {number} pixelRatio Pixel ratio.
   * @private
   */
  replaceColor_(pixelRatio) {
    if (
      !this.color_ ||
      this.canvas_[pixelRatio] ||
      this.imageState_ !== _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADED
    ) {
      return;
    }

    const image = this.image_;
    const canvas = document.createElement('canvas');
    canvas.width = Math.ceil(image.width * pixelRatio);
    canvas.height = Math.ceil(image.height * pixelRatio);

    const ctx = canvas.getContext('2d');
    ctx.scale(pixelRatio, pixelRatio);
    ctx.drawImage(image, 0, 0);

    ctx.globalCompositeOperation = 'multiply';
    ctx.fillStyle = (0,_color_js__WEBPACK_IMPORTED_MODULE_5__.asString)(this.color_);
    ctx.fillRect(0, 0, canvas.width / pixelRatio, canvas.height / pixelRatio);

    ctx.globalCompositeOperation = 'destination-in';
    ctx.drawImage(image, 0, 0);

    this.canvas_[pixelRatio] = canvas;
  }
}

/**
 * @param {HTMLImageElement|HTMLCanvasElement|ImageBitmap} image Image.
 * @param {string} cacheKey Src.
 * @param {?string} crossOrigin Cross origin.
 * @param {import("../ImageState.js").default} imageState Image state.
 * @param {import("../color.js").Color} color Color.
 * @return {IconImage} Icon image.
 */
function get(image, cacheKey, crossOrigin, imageState, color) {
  let iconImage =
    cacheKey === undefined
      ? undefined
      : _IconImageCache_js__WEBPACK_IMPORTED_MODULE_6__.shared.get(cacheKey, crossOrigin, color);
  if (!iconImage) {
    iconImage = new IconImage(
      image,
      image instanceof HTMLImageElement ? image.src || undefined : cacheKey,
      crossOrigin,
      imageState,
      color
    );
    _IconImageCache_js__WEBPACK_IMPORTED_MODULE_6__.shared.set(cacheKey, crossOrigin, color, iconImage);
  }
  return iconImage;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (IconImage);


/***/ }),

/***/ "./node_modules/ol/style/IconImageCache.js":
/*!*************************************************!*\
  !*** ./node_modules/ol/style/IconImageCache.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   shared: () => (/* binding */ shared)
/* harmony export */ });
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../color.js */ "./node_modules/ol/color.js");
/**
 * @module ol/style/IconImageCache
 */


/**
 * @classdesc
 * Singleton class. Available through {@link module:ol/style/IconImageCache.shared}.
 */
class IconImageCache {
  constructor() {
    /**
     * @type {!Object<string, import("./IconImage.js").default>}
     * @private
     */
    this.cache_ = {};

    /**
     * @type {number}
     * @private
     */
    this.cacheSize_ = 0;

    /**
     * @type {number}
     * @private
     */
    this.maxCacheSize_ = 32;
  }

  /**
   * FIXME empty description for jsdoc
   */
  clear() {
    this.cache_ = {};
    this.cacheSize_ = 0;
  }

  /**
   * @return {boolean} Can expire cache.
   */
  canExpireCache() {
    return this.cacheSize_ > this.maxCacheSize_;
  }

  /**
   * FIXME empty description for jsdoc
   */
  expire() {
    if (this.canExpireCache()) {
      let i = 0;
      for (const key in this.cache_) {
        const iconImage = this.cache_[key];
        if ((i++ & 3) === 0 && !iconImage.hasListener()) {
          delete this.cache_[key];
          --this.cacheSize_;
        }
      }
    }
  }

  /**
   * @param {string} src Src.
   * @param {?string} crossOrigin Cross origin.
   * @param {import("../color.js").Color} color Color.
   * @return {import("./IconImage.js").default} Icon image.
   */
  get(src, crossOrigin, color) {
    const key = getKey(src, crossOrigin, color);
    return key in this.cache_ ? this.cache_[key] : null;
  }

  /**
   * @param {string} src Src.
   * @param {?string} crossOrigin Cross origin.
   * @param {import("../color.js").Color} color Color.
   * @param {import("./IconImage.js").default} iconImage Icon image.
   */
  set(src, crossOrigin, color, iconImage) {
    const key = getKey(src, crossOrigin, color);
    this.cache_[key] = iconImage;
    ++this.cacheSize_;
  }

  /**
   * Set the cache size of the icon cache. Default is `32`. Change this value when
   * your map uses more than 32 different icon images and you are not caching icon
   * styles on the application level.
   * @param {number} maxCacheSize Cache max size.
   * @api
   */
  setSize(maxCacheSize) {
    this.maxCacheSize_ = maxCacheSize;
    this.expire();
  }
}

/**
 * @param {string} src Src.
 * @param {?string} crossOrigin Cross origin.
 * @param {import("../color.js").Color} color Color.
 * @return {string} Cache key.
 */
function getKey(src, crossOrigin, color) {
  const colorString = color ? (0,_color_js__WEBPACK_IMPORTED_MODULE_0__.asString)(color) : 'null';
  return crossOrigin + ':' + src + ':' + colorString;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (IconImageCache);

/**
 * The {@link module:ol/style/IconImageCache~IconImageCache} for
 * {@link module:ol/style/Icon~Icon} images.
 * @api
 */
const shared = new IconImageCache();


/***/ }),

/***/ "./node_modules/ol/style/Image.js":
/*!****************************************!*\
  !*** ./node_modules/ol/style/Image.js ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util.js */ "./node_modules/ol/util.js");
/* harmony import */ var _size_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../size.js */ "./node_modules/ol/size.js");
/**
 * @module ol/style/Image
 */



/**
 * @typedef {Object} Options
 * @property {number} opacity Opacity.
 * @property {boolean} rotateWithView If the image should get rotated with the view.
 * @property {number} rotation Rotation.
 * @property {number|import("../size.js").Size} scale Scale.
 * @property {Array<number>} displacement Displacement.
 * @property {"declutter"|"obstacle"|"none"|undefined} declutterMode Declutter mode: `declutter`, `obstacle`, 'none */

/**
 * @classdesc
 * A base class used for creating subclasses and not instantiated in
 * apps. Base class for {@link module:ol/style/Icon~Icon}, {@link module:ol/style/Circle~CircleStyle} and
 * {@link module:ol/style/RegularShape~RegularShape}.
 * @abstract
 * @api
 */
class ImageStyle {
  /**
   * @param {Options} options Options.
   */
  constructor(options) {
    /**
     * @private
     * @type {number}
     */
    this.opacity_ = options.opacity;

    /**
     * @private
     * @type {boolean}
     */
    this.rotateWithView_ = options.rotateWithView;

    /**
     * @private
     * @type {number}
     */
    this.rotation_ = options.rotation;

    /**
     * @private
     * @type {number|import("../size.js").Size}
     */
    this.scale_ = options.scale;

    /**
     * @private
     * @type {import("../size.js").Size}
     */
    this.scaleArray_ = (0,_size_js__WEBPACK_IMPORTED_MODULE_0__.toSize)(options.scale);

    /**
     * @private
     * @type {Array<number>}
     */
    this.displacement_ = options.displacement;

    /**
     * @private
     * @type {"declutter"|"obstacle"|"none"|undefined}
     */
    this.declutterMode_ = options.declutterMode;
  }

  /**
   * Clones the style.
   * @return {ImageStyle} The cloned style.
   * @api
   */
  clone() {
    const scale = this.getScale();
    return new ImageStyle({
      opacity: this.getOpacity(),
      scale: Array.isArray(scale) ? scale.slice() : scale,
      rotation: this.getRotation(),
      rotateWithView: this.getRotateWithView(),
      displacement: this.getDisplacement().slice(),
      declutterMode: this.getDeclutterMode(),
    });
  }

  /**
   * Get the symbolizer opacity.
   * @return {number} Opacity.
   * @api
   */
  getOpacity() {
    return this.opacity_;
  }

  /**
   * Determine whether the symbolizer rotates with the map.
   * @return {boolean} Rotate with map.
   * @api
   */
  getRotateWithView() {
    return this.rotateWithView_;
  }

  /**
   * Get the symoblizer rotation.
   * @return {number} Rotation.
   * @api
   */
  getRotation() {
    return this.rotation_;
  }

  /**
   * Get the symbolizer scale.
   * @return {number|import("../size.js").Size} Scale.
   * @api
   */
  getScale() {
    return this.scale_;
  }

  /**
   * Get the symbolizer scale array.
   * @return {import("../size.js").Size} Scale array.
   */
  getScaleArray() {
    return this.scaleArray_;
  }

  /**
   * Get the displacement of the shape
   * @return {Array<number>} Shape's center displacement
   * @api
   */
  getDisplacement() {
    return this.displacement_;
  }

  /**
   * Get the declutter mode of the shape
   * @return {"declutter"|"obstacle"|"none"|undefined} Shape's declutter mode
   * @api
   */
  getDeclutterMode() {
    return this.declutterMode_;
  }

  /**
   * Get the anchor point in pixels. The anchor determines the center point for the
   * symbolizer.
   * @abstract
   * @return {Array<number>} Anchor.
   */
  getAnchor() {
    return (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.abstract)();
  }

  /**
   * Get the image element for the symbolizer.
   * @abstract
   * @param {number} pixelRatio Pixel ratio.
   * @return {import('../DataTile.js').ImageLike} Image element.
   */
  getImage(pixelRatio) {
    return (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.abstract)();
  }

  /**
   * @abstract
   * @return {import('../DataTile.js').ImageLike} Image element.
   */
  getHitDetectionImage() {
    return (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.abstract)();
  }

  /**
   * Get the image pixel ratio.
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} Pixel ratio.
   */
  getPixelRatio(pixelRatio) {
    return 1;
  }

  /**
   * @abstract
   * @return {import("../ImageState.js").default} Image state.
   */
  getImageState() {
    return (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.abstract)();
  }

  /**
   * @abstract
   * @return {import("../size.js").Size} Image size.
   */
  getImageSize() {
    return (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.abstract)();
  }

  /**
   * Get the origin of the symbolizer.
   * @abstract
   * @return {Array<number>} Origin.
   */
  getOrigin() {
    return (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.abstract)();
  }

  /**
   * Get the size of the symbolizer (in pixels).
   * @abstract
   * @return {import("../size.js").Size} Size.
   */
  getSize() {
    return (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.abstract)();
  }

  /**
   * Set the displacement.
   *
   * @param {Array<number>} displacement Displacement.
   * @api
   */
  setDisplacement(displacement) {
    this.displacement_ = displacement;
  }

  /**
   * Set the opacity.
   *
   * @param {number} opacity Opacity.
   * @api
   */
  setOpacity(opacity) {
    this.opacity_ = opacity;
  }

  /**
   * Set whether to rotate the style with the view.
   *
   * @param {boolean} rotateWithView Rotate with map.
   * @api
   */
  setRotateWithView(rotateWithView) {
    this.rotateWithView_ = rotateWithView;
  }

  /**
   * Set the rotation.
   *
   * @param {number} rotation Rotation.
   * @api
   */
  setRotation(rotation) {
    this.rotation_ = rotation;
  }

  /**
   * Set the scale.
   *
   * @param {number|import("../size.js").Size} scale Scale.
   * @api
   */
  setScale(scale) {
    this.scale_ = scale;
    this.scaleArray_ = (0,_size_js__WEBPACK_IMPORTED_MODULE_0__.toSize)(scale);
  }

  /**
   * @abstract
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   */
  listenImageChange(listener) {
    (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.abstract)();
  }

  /**
   * Load not yet loaded URI.
   * @abstract
   */
  load() {
    (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.abstract)();
  }

  /**
   * @abstract
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   */
  unlistenImageChange(listener) {
    (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.abstract)();
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ImageStyle);


/***/ }),

/***/ "./node_modules/ol/style/RegularShape.js":
/*!***********************************************!*\
  !*** ./node_modules/ol/style/RegularShape.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _ImageState_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../ImageState.js */ "./node_modules/ol/ImageState.js");
/* harmony import */ var _Image_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Image.js */ "./node_modules/ol/style/Image.js");
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../color.js */ "./node_modules/ol/color.js");
/* harmony import */ var _colorlike_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../colorlike.js */ "./node_modules/ol/colorlike.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../dom.js */ "./node_modules/ol/dom.js");
/* harmony import */ var _render_canvas_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../render/canvas.js */ "./node_modules/ol/render/canvas.js");
/**
 * @module ol/style/RegularShape
 */








/**
 * Specify radius for regular polygons, or radius1 and radius2 for stars.
 * @typedef {Object} Options
 * @property {import("./Fill.js").default} [fill] Fill style.
 * @property {number} points Number of points for stars and regular polygons. In case of a polygon, the number of points
 * is the number of sides.
 * @property {number} [radius] Radius of a regular polygon.
 * @property {number} [radius1] First radius of a star. Ignored if radius is set.
 * @property {number} [radius2] Second radius of a star.
 * @property {number} [angle=0] Shape's angle in radians. A value of 0 will have one of the shape's points facing up.
 * @property {Array<number>} [displacement=[0, 0]] Displacement of the shape in pixels.
 * Positive values will shift the shape right and up.
 * @property {import("./Stroke.js").default} [stroke] Stroke style.
 * @property {number} [rotation=0] Rotation in radians (positive rotation clockwise).
 * @property {boolean} [rotateWithView=false] Whether to rotate the shape with the view.
 * @property {number|import("../size.js").Size} [scale=1] Scale. Unless two dimensional scaling is required a better
 * result may be obtained with appropriate settings for `radius`, `radius1` and `radius2`.
 * @property {"declutter"|"obstacle"|"none"|undefined} [declutterMode] Declutter mode.
 */

/**
 * @typedef {Object} RenderOptions
 * @property {import("../colorlike.js").ColorLike} [strokeStyle] StrokeStyle.
 * @property {number} strokeWidth StrokeWidth.
 * @property {number} size Size.
 * @property {CanvasLineCap} lineCap LineCap.
 * @property {Array<number>|null} lineDash LineDash.
 * @property {number} lineDashOffset LineDashOffset.
 * @property {CanvasLineJoin} lineJoin LineJoin.
 * @property {number} miterLimit MiterLimit.
 */

/**
 * @classdesc
 * Set regular shape style for vector features. The resulting shape will be
 * a regular polygon when `radius` is provided, or a star when `radius1` and
 * `radius2` are provided.
 * @api
 */
class RegularShape extends _Image_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {Options} options Options.
   */
  constructor(options) {
    /**
     * @type {boolean}
     */
    const rotateWithView =
      options.rotateWithView !== undefined ? options.rotateWithView : false;

    super({
      opacity: 1,
      rotateWithView: rotateWithView,
      rotation: options.rotation !== undefined ? options.rotation : 0,
      scale: options.scale !== undefined ? options.scale : 1,
      displacement:
        options.displacement !== undefined ? options.displacement : [0, 0],
      declutterMode: options.declutterMode,
    });

    /**
     * @private
     * @type {Object<number, HTMLCanvasElement>}
     */
    this.canvas_ = undefined;

    /**
     * @private
     * @type {HTMLCanvasElement}
     */
    this.hitDetectionCanvas_ = null;

    /**
     * @private
     * @type {import("./Fill.js").default}
     */
    this.fill_ = options.fill !== undefined ? options.fill : null;

    /**
     * @private
     * @type {Array<number>}
     */
    this.origin_ = [0, 0];

    /**
     * @private
     * @type {number}
     */
    this.points_ = options.points;

    /**
     * @protected
     * @type {number}
     */
    this.radius_ =
      options.radius !== undefined ? options.radius : options.radius1;

    /**
     * @private
     * @type {number|undefined}
     */
    this.radius2_ = options.radius2;

    /**
     * @private
     * @type {number}
     */
    this.angle_ = options.angle !== undefined ? options.angle : 0;

    /**
     * @private
     * @type {import("./Stroke.js").default}
     */
    this.stroke_ = options.stroke !== undefined ? options.stroke : null;

    /**
     * @private
     * @type {import("../size.js").Size}
     */
    this.size_ = null;

    /**
     * @private
     * @type {RenderOptions}
     */
    this.renderOptions_ = null;

    this.render();
  }

  /**
   * Clones the style.
   * @return {RegularShape} The cloned style.
   * @api
   */
  clone() {
    const scale = this.getScale();
    const style = new RegularShape({
      fill: this.getFill() ? this.getFill().clone() : undefined,
      points: this.getPoints(),
      radius: this.getRadius(),
      radius2: this.getRadius2(),
      angle: this.getAngle(),
      stroke: this.getStroke() ? this.getStroke().clone() : undefined,
      rotation: this.getRotation(),
      rotateWithView: this.getRotateWithView(),
      scale: Array.isArray(scale) ? scale.slice() : scale,
      displacement: this.getDisplacement().slice(),
      declutterMode: this.getDeclutterMode(),
    });
    style.setOpacity(this.getOpacity());
    return style;
  }

  /**
   * Get the anchor point in pixels. The anchor determines the center point for the
   * symbolizer.
   * @return {Array<number>} Anchor.
   * @api
   */
  getAnchor() {
    const size = this.size_;
    if (!size) {
      return null;
    }
    const displacement = this.getDisplacement();
    const scale = this.getScaleArray();
    // anchor is scaled by renderer but displacement should not be scaled
    // so divide by scale here
    return [
      size[0] / 2 - displacement[0] / scale[0],
      size[1] / 2 + displacement[1] / scale[1],
    ];
  }

  /**
   * Get the angle used in generating the shape.
   * @return {number} Shape's rotation in radians.
   * @api
   */
  getAngle() {
    return this.angle_;
  }

  /**
   * Get the fill style for the shape.
   * @return {import("./Fill.js").default} Fill style.
   * @api
   */
  getFill() {
    return this.fill_;
  }

  /**
   * Set the fill style.
   * @param {import("./Fill.js").default} fill Fill style.
   * @api
   */
  setFill(fill) {
    this.fill_ = fill;
    this.render();
  }

  /**
   * @return {HTMLCanvasElement} Image element.
   */
  getHitDetectionImage() {
    if (!this.hitDetectionCanvas_) {
      this.createHitDetectionCanvas_(this.renderOptions_);
    }
    return this.hitDetectionCanvas_;
  }

  /**
   * Get the image icon.
   * @param {number} pixelRatio Pixel ratio.
   * @return {HTMLCanvasElement} Image or Canvas element.
   * @api
   */
  getImage(pixelRatio) {
    let image = this.canvas_[pixelRatio];
    if (!image) {
      const renderOptions = this.renderOptions_;
      const context = (0,_dom_js__WEBPACK_IMPORTED_MODULE_1__.createCanvasContext2D)(
        renderOptions.size * pixelRatio,
        renderOptions.size * pixelRatio
      );
      this.draw_(renderOptions, context, pixelRatio);

      image = context.canvas;
      this.canvas_[pixelRatio] = image;
    }
    return image;
  }

  /**
   * Get the image pixel ratio.
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} Pixel ratio.
   */
  getPixelRatio(pixelRatio) {
    return pixelRatio;
  }

  /**
   * @return {import("../size.js").Size} Image size.
   */
  getImageSize() {
    return this.size_;
  }

  /**
   * @return {import("../ImageState.js").default} Image state.
   */
  getImageState() {
    return _ImageState_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADED;
  }

  /**
   * Get the origin of the symbolizer.
   * @return {Array<number>} Origin.
   * @api
   */
  getOrigin() {
    return this.origin_;
  }

  /**
   * Get the number of points for generating the shape.
   * @return {number} Number of points for stars and regular polygons.
   * @api
   */
  getPoints() {
    return this.points_;
  }

  /**
   * Get the (primary) radius for the shape.
   * @return {number} Radius.
   * @api
   */
  getRadius() {
    return this.radius_;
  }

  /**
   * Get the secondary radius for the shape.
   * @return {number|undefined} Radius2.
   * @api
   */
  getRadius2() {
    return this.radius2_;
  }

  /**
   * Get the size of the symbolizer (in pixels).
   * @return {import("../size.js").Size} Size.
   * @api
   */
  getSize() {
    return this.size_;
  }

  /**
   * Get the stroke style for the shape.
   * @return {import("./Stroke.js").default} Stroke style.
   * @api
   */
  getStroke() {
    return this.stroke_;
  }

  /**
   * Set the stroke style.
   * @param {import("./Stroke.js").default} stroke Stroke style.
   * @api
   */
  setStroke(stroke) {
    this.stroke_ = stroke;
    this.render();
  }

  /**
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   */
  listenImageChange(listener) {}

  /**
   * Load not yet loaded URI.
   */
  load() {}

  /**
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   */
  unlistenImageChange(listener) {}

  /**
   * Calculate additional canvas size needed for the miter.
   * @param {string} lineJoin Line join
   * @param {number} strokeWidth Stroke width
   * @param {number} miterLimit Miter limit
   * @return {number} Additional canvas size needed
   * @private
   */
  calculateLineJoinSize_(lineJoin, strokeWidth, miterLimit) {
    if (
      strokeWidth === 0 ||
      this.points_ === Infinity ||
      (lineJoin !== 'bevel' && lineJoin !== 'miter')
    ) {
      return strokeWidth;
    }
    // m  | ^
    // i  | |\                  .
    // t >|  #\
    // e  | |\ \              .
    // r      \s\
    //      |  \t\          .                 .
    //          \r\                      .   .
    //      |    \o\      .          .  . . .
    //          e \k\            .  .    . .
    //      |      \e\  .    .  .       . .
    //       d      \ \  .  .          . .
    //      | _ _a_ _\#  .            . .
    //   r1          / `             . .
    //      |                       . .
    //       b     /               . .
    //      |                     . .
    //           / r2            . .
    //      |                        .   .
    //         /                           .   .
    //      |α                                   .   .
    //       /                                         .   .
    //      ° center
    let r1 = this.radius_;
    let r2 = this.radius2_ === undefined ? r1 : this.radius2_;
    if (r1 < r2) {
      const tmp = r1;
      r1 = r2;
      r2 = tmp;
    }
    const points =
      this.radius2_ === undefined ? this.points_ : this.points_ * 2;
    const alpha = (2 * Math.PI) / points;
    const a = r2 * Math.sin(alpha);
    const b = Math.sqrt(r2 * r2 - a * a);
    const d = r1 - b;
    const e = Math.sqrt(a * a + d * d);
    const miterRatio = e / a;
    if (lineJoin === 'miter' && miterRatio <= miterLimit) {
      return miterRatio * strokeWidth;
    }
    // Calculate the distance from center to the stroke corner where
    // it was cut short because of the miter limit.
    //              l
    //        ----+---- <= distance from center to here is maxr
    //       /####|k ##\
    //      /#####^#####\
    //     /#### /+\# s #\
    //    /### h/+++\# t #\
    //   /### t/+++++\# r #\
    //  /### a/+++++++\# o #\
    // /### p/++ fill +\# k #\
    ///#### /+++++^+++++\# e #\
    //#####/+++++/+\+++++\#####\
    const k = strokeWidth / 2 / miterRatio;
    const l = (strokeWidth / 2) * (d / e);
    const maxr = Math.sqrt((r1 + k) * (r1 + k) + l * l);
    const bevelAdd = maxr - r1;
    if (this.radius2_ === undefined || lineJoin === 'bevel') {
      return bevelAdd * 2;
    }
    // If outer miter is over the miter limit the inner miter may reach through the
    // center and be longer than the bevel, same calculation as above but swap r1 / r2.
    const aa = r1 * Math.sin(alpha);
    const bb = Math.sqrt(r1 * r1 - aa * aa);
    const dd = r2 - bb;
    const ee = Math.sqrt(aa * aa + dd * dd);
    const innerMiterRatio = ee / aa;
    if (innerMiterRatio <= miterLimit) {
      const innerLength = (innerMiterRatio * strokeWidth) / 2 - r2 - r1;
      return 2 * Math.max(bevelAdd, innerLength);
    }
    return bevelAdd * 2;
  }

  /**
   * @return {RenderOptions}  The render options
   * @protected
   */
  createRenderOptions() {
    let lineCap = _render_canvas_js__WEBPACK_IMPORTED_MODULE_3__.defaultLineCap;
    let lineJoin = _render_canvas_js__WEBPACK_IMPORTED_MODULE_3__.defaultLineJoin;
    let miterLimit = 0;
    let lineDash = null;
    let lineDashOffset = 0;
    let strokeStyle;
    let strokeWidth = 0;

    if (this.stroke_) {
      strokeStyle = this.stroke_.getColor();
      if (strokeStyle === null) {
        strokeStyle = _render_canvas_js__WEBPACK_IMPORTED_MODULE_3__.defaultStrokeStyle;
      }
      strokeStyle = (0,_colorlike_js__WEBPACK_IMPORTED_MODULE_4__.asColorLike)(strokeStyle);
      strokeWidth = this.stroke_.getWidth();
      if (strokeWidth === undefined) {
        strokeWidth = _render_canvas_js__WEBPACK_IMPORTED_MODULE_3__.defaultLineWidth;
      }
      lineDash = this.stroke_.getLineDash();
      lineDashOffset = this.stroke_.getLineDashOffset();
      lineJoin = this.stroke_.getLineJoin();
      if (lineJoin === undefined) {
        lineJoin = _render_canvas_js__WEBPACK_IMPORTED_MODULE_3__.defaultLineJoin;
      }
      lineCap = this.stroke_.getLineCap();
      if (lineCap === undefined) {
        lineCap = _render_canvas_js__WEBPACK_IMPORTED_MODULE_3__.defaultLineCap;
      }
      miterLimit = this.stroke_.getMiterLimit();
      if (miterLimit === undefined) {
        miterLimit = _render_canvas_js__WEBPACK_IMPORTED_MODULE_3__.defaultMiterLimit;
      }
    }

    const add = this.calculateLineJoinSize_(lineJoin, strokeWidth, miterLimit);
    const maxRadius = Math.max(this.radius_, this.radius2_ || 0);
    const size = Math.ceil(2 * maxRadius + add);

    return {
      strokeStyle: strokeStyle,
      strokeWidth: strokeWidth,
      size: size,
      lineCap: lineCap,
      lineDash: lineDash,
      lineDashOffset: lineDashOffset,
      lineJoin: lineJoin,
      miterLimit: miterLimit,
    };
  }

  /**
   * @protected
   */
  render() {
    this.renderOptions_ = this.createRenderOptions();
    const size = this.renderOptions_.size;
    this.canvas_ = {};
    this.size_ = [size, size];
  }

  /**
   * @private
   * @param {RenderOptions} renderOptions Render options.
   * @param {CanvasRenderingContext2D} context The rendering context.
   * @param {number} pixelRatio The pixel ratio.
   */
  draw_(renderOptions, context, pixelRatio) {
    context.scale(pixelRatio, pixelRatio);
    // set origin to canvas center
    context.translate(renderOptions.size / 2, renderOptions.size / 2);

    this.createPath_(context);

    if (this.fill_) {
      let color = this.fill_.getColor();
      if (color === null) {
        color = _render_canvas_js__WEBPACK_IMPORTED_MODULE_3__.defaultFillStyle;
      }
      context.fillStyle = (0,_colorlike_js__WEBPACK_IMPORTED_MODULE_4__.asColorLike)(color);
      context.fill();
    }
    if (this.stroke_) {
      context.strokeStyle = renderOptions.strokeStyle;
      context.lineWidth = renderOptions.strokeWidth;
      if (renderOptions.lineDash) {
        context.setLineDash(renderOptions.lineDash);
        context.lineDashOffset = renderOptions.lineDashOffset;
      }
      context.lineCap = renderOptions.lineCap;
      context.lineJoin = renderOptions.lineJoin;
      context.miterLimit = renderOptions.miterLimit;
      context.stroke();
    }
  }

  /**
   * @private
   * @param {RenderOptions} renderOptions Render options.
   */
  createHitDetectionCanvas_(renderOptions) {
    if (this.fill_) {
      let color = this.fill_.getColor();

      // determine if fill is transparent (or pattern or gradient)
      let opacity = 0;
      if (typeof color === 'string') {
        color = (0,_color_js__WEBPACK_IMPORTED_MODULE_5__.asArray)(color);
      }
      if (color === null) {
        opacity = 1;
      } else if (Array.isArray(color)) {
        opacity = color.length === 4 ? color[3] : 1;
      }
      if (opacity === 0) {
        // if a transparent fill style is set, create an extra hit-detection image
        // with a default fill style
        const context = (0,_dom_js__WEBPACK_IMPORTED_MODULE_1__.createCanvasContext2D)(
          renderOptions.size,
          renderOptions.size
        );
        this.hitDetectionCanvas_ = context.canvas;

        this.drawHitDetectionCanvas_(renderOptions, context);
      }
    }
    if (!this.hitDetectionCanvas_) {
      this.hitDetectionCanvas_ = this.getImage(1);
    }
  }

  /**
   * @private
   * @param {CanvasRenderingContext2D} context The context to draw in.
   */
  createPath_(context) {
    let points = this.points_;
    const radius = this.radius_;
    if (points === Infinity) {
      context.arc(0, 0, radius, 0, 2 * Math.PI);
    } else {
      const radius2 = this.radius2_ === undefined ? radius : this.radius2_;
      if (this.radius2_ !== undefined) {
        points *= 2;
      }
      const startAngle = this.angle_ - Math.PI / 2;
      const step = (2 * Math.PI) / points;
      for (let i = 0; i < points; i++) {
        const angle0 = startAngle + i * step;
        const radiusC = i % 2 === 0 ? radius : radius2;
        context.lineTo(radiusC * Math.cos(angle0), radiusC * Math.sin(angle0));
      }
      context.closePath();
    }
  }

  /**
   * @private
   * @param {RenderOptions} renderOptions Render options.
   * @param {CanvasRenderingContext2D} context The context.
   */
  drawHitDetectionCanvas_(renderOptions, context) {
    // set origin to canvas center
    context.translate(renderOptions.size / 2, renderOptions.size / 2);

    this.createPath_(context);

    context.fillStyle = _render_canvas_js__WEBPACK_IMPORTED_MODULE_3__.defaultFillStyle;
    context.fill();
    if (this.stroke_) {
      context.strokeStyle = renderOptions.strokeStyle;
      context.lineWidth = renderOptions.strokeWidth;
      if (renderOptions.lineDash) {
        context.setLineDash(renderOptions.lineDash);
        context.lineDashOffset = renderOptions.lineDashOffset;
      }
      context.lineJoin = renderOptions.lineJoin;
      context.miterLimit = renderOptions.miterLimit;
      context.stroke();
    }
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (RegularShape);


/***/ }),

/***/ "./node_modules/ol/style/Stroke.js":
/*!*****************************************!*\
  !*** ./node_modules/ol/style/Stroke.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * @module ol/style/Stroke
 */

/**
 * @typedef {Object} Options
 * @property {import("../color.js").Color|import("../colorlike.js").ColorLike} [color] A color, gradient or pattern.
 * See {@link module:ol/color~Color} and {@link module:ol/colorlike~ColorLike} for possible formats.
 * Default null; if null, the Canvas/renderer default black will be used.
 * @property {CanvasLineCap} [lineCap='round'] Line cap style: `butt`, `round`, or `square`.
 * @property {CanvasLineJoin} [lineJoin='round'] Line join style: `bevel`, `round`, or `miter`.
 * @property {Array<number>} [lineDash] Line dash pattern. Default is `null` (no dash).
 * @property {number} [lineDashOffset=0] Line dash offset.
 * @property {number} [miterLimit=10] Miter limit.
 * @property {number} [width] Width.
 */

/**
 * @classdesc
 * Set stroke style for vector features.
 * Note that the defaults given are the Canvas defaults, which will be used if
 * option is not defined. The `get` functions return whatever was entered in
 * the options; they will not return the default.
 * @api
 */
class Stroke {
  /**
   * @param {Options} [options] Options.
   */
  constructor(options) {
    options = options || {};

    /**
     * @private
     * @type {import("../color.js").Color|import("../colorlike.js").ColorLike}
     */
    this.color_ = options.color !== undefined ? options.color : null;

    /**
     * @private
     * @type {CanvasLineCap|undefined}
     */
    this.lineCap_ = options.lineCap;

    /**
     * @private
     * @type {Array<number>|null}
     */
    this.lineDash_ = options.lineDash !== undefined ? options.lineDash : null;

    /**
     * @private
     * @type {number|undefined}
     */
    this.lineDashOffset_ = options.lineDashOffset;

    /**
     * @private
     * @type {CanvasLineJoin|undefined}
     */
    this.lineJoin_ = options.lineJoin;

    /**
     * @private
     * @type {number|undefined}
     */
    this.miterLimit_ = options.miterLimit;

    /**
     * @private
     * @type {number|undefined}
     */
    this.width_ = options.width;
  }

  /**
   * Clones the style.
   * @return {Stroke} The cloned style.
   * @api
   */
  clone() {
    const color = this.getColor();
    return new Stroke({
      color: Array.isArray(color) ? color.slice() : color || undefined,
      lineCap: this.getLineCap(),
      lineDash: this.getLineDash() ? this.getLineDash().slice() : undefined,
      lineDashOffset: this.getLineDashOffset(),
      lineJoin: this.getLineJoin(),
      miterLimit: this.getMiterLimit(),
      width: this.getWidth(),
    });
  }

  /**
   * Get the stroke color.
   * @return {import("../color.js").Color|import("../colorlike.js").ColorLike} Color.
   * @api
   */
  getColor() {
    return this.color_;
  }

  /**
   * Get the line cap type for the stroke.
   * @return {CanvasLineCap|undefined} Line cap.
   * @api
   */
  getLineCap() {
    return this.lineCap_;
  }

  /**
   * Get the line dash style for the stroke.
   * @return {Array<number>|null} Line dash.
   * @api
   */
  getLineDash() {
    return this.lineDash_;
  }

  /**
   * Get the line dash offset for the stroke.
   * @return {number|undefined} Line dash offset.
   * @api
   */
  getLineDashOffset() {
    return this.lineDashOffset_;
  }

  /**
   * Get the line join type for the stroke.
   * @return {CanvasLineJoin|undefined} Line join.
   * @api
   */
  getLineJoin() {
    return this.lineJoin_;
  }

  /**
   * Get the miter limit for the stroke.
   * @return {number|undefined} Miter limit.
   * @api
   */
  getMiterLimit() {
    return this.miterLimit_;
  }

  /**
   * Get the stroke width.
   * @return {number|undefined} Width.
   * @api
   */
  getWidth() {
    return this.width_;
  }

  /**
   * Set the color.
   *
   * @param {import("../color.js").Color|import("../colorlike.js").ColorLike} color Color.
   * @api
   */
  setColor(color) {
    this.color_ = color;
  }

  /**
   * Set the line cap.
   *
   * @param {CanvasLineCap|undefined} lineCap Line cap.
   * @api
   */
  setLineCap(lineCap) {
    this.lineCap_ = lineCap;
  }

  /**
   * Set the line dash.
   *
   * @param {Array<number>|null} lineDash Line dash.
   * @api
   */
  setLineDash(lineDash) {
    this.lineDash_ = lineDash;
  }

  /**
   * Set the line dash offset.
   *
   * @param {number|undefined} lineDashOffset Line dash offset.
   * @api
   */
  setLineDashOffset(lineDashOffset) {
    this.lineDashOffset_ = lineDashOffset;
  }

  /**
   * Set the line join.
   *
   * @param {CanvasLineJoin|undefined} lineJoin Line join.
   * @api
   */
  setLineJoin(lineJoin) {
    this.lineJoin_ = lineJoin;
  }

  /**
   * Set the miter limit.
   *
   * @param {number|undefined} miterLimit Miter limit.
   * @api
   */
  setMiterLimit(miterLimit) {
    this.miterLimit_ = miterLimit;
  }

  /**
   * Set the width.
   *
   * @param {number|undefined} width Width.
   * @api
   */
  setWidth(width) {
    this.width_ = width;
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Stroke);


/***/ }),

/***/ "./node_modules/ol/style/Style.js":
/*!****************************************!*\
  !*** ./node_modules/ol/style/Style.js ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createDefaultStyle: () => (/* binding */ createDefaultStyle),
/* harmony export */   createEditingStyle: () => (/* binding */ createEditingStyle),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   toFunction: () => (/* binding */ toFunction)
/* harmony export */ });
/* harmony import */ var _Circle_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Circle.js */ "./node_modules/ol/style/Circle.js");
/* harmony import */ var _Fill_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Fill.js */ "./node_modules/ol/style/Fill.js");
/* harmony import */ var _Stroke_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Stroke.js */ "./node_modules/ol/style/Stroke.js");
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../asserts.js */ "./node_modules/ol/asserts.js");
/**
 * @module ol/style/Style
 */






/**
 * A function that takes an {@link module:ol/Feature~Feature} and a `{number}`
 * representing the view's resolution. The function should return a
 * {@link module:ol/style/Style~Style} or an array of them. This way e.g. a
 * vector layer can be styled. If the function returns `undefined`, the
 * feature will not be rendered.
 *
 * @typedef {function(import("../Feature.js").FeatureLike, number):(Style|Array<Style>|void)} StyleFunction
 */

/**
 * A {@link Style}, an array of {@link Style}, or a {@link StyleFunction}.
 * @typedef {Style|Array<Style>|StyleFunction} StyleLike
 */

/**
 * A function that takes an {@link module:ol/Feature~Feature} as argument and returns an
 * {@link module:ol/geom/Geometry~Geometry} that will be rendered and styled for the feature.
 *
 * @typedef {function(import("../Feature.js").FeatureLike):
 *     (import("../geom/Geometry.js").default|import("../render/Feature.js").default|undefined)} GeometryFunction
 */

/**
 * Custom renderer function. Takes two arguments:
 *
 * 1. The pixel coordinates of the geometry in GeoJSON notation.
 * 2. The {@link module:ol/render~State} of the layer renderer.
 *
 * @typedef {function((import("../coordinate.js").Coordinate|Array<import("../coordinate.js").Coordinate>|Array<Array<import("../coordinate.js").Coordinate>>|Array<Array<Array<import("../coordinate.js").Coordinate>>>),import("../render.js").State): void} RenderFunction
 */

/**
 * @typedef {Object} Options
 * @property {string|import("../geom/Geometry.js").default|GeometryFunction} [geometry] Feature property or geometry
 * or function returning a geometry to render for this style.
 * @property {import("./Fill.js").default} [fill] Fill style.
 * @property {import("./Image.js").default} [image] Image style.
 * @property {RenderFunction} [renderer] Custom renderer. When configured, `fill`, `stroke` and `image` will be
 * ignored, and the provided function will be called with each render frame for each geometry.
 * @property {RenderFunction} [hitDetectionRenderer] Custom renderer for hit detection. If provided will be used
 * in hit detection rendering.
 * @property {import("./Stroke.js").default} [stroke] Stroke style.
 * @property {import("./Text.js").default} [text] Text style.
 * @property {number} [zIndex] Z index.
 */

/**
 * @classdesc
 * Container for vector feature rendering styles. Any changes made to the style
 * or its children through `set*()` methods will not take effect until the
 * feature or layer that uses the style is re-rendered.
 *
 * ## Feature styles
 *
 * If no style is defined, the following default style is used:
 * ```js
 *  import {Circle, Fill, Stroke, Style} from 'ol/style.js';
 *
 *  const fill = new Fill({
 *    color: 'rgba(255,255,255,0.4)',
 *  });
 *  const stroke = new Stroke({
 *    color: '#3399CC',
 *    width: 1.25,
 *  });
 *  const styles = [
 *    new Style({
 *      image: new Circle({
 *        fill: fill,
 *        stroke: stroke,
 *        radius: 5,
 *      }),
 *      fill: fill,
 *      stroke: stroke,
 *    }),
 *  ];
 * ```
 *
 * A separate editing style has the following defaults:
 * ```js
 *  import {Circle, Fill, Stroke, Style} from 'ol/style.js';
 *
 *  const styles = {};
 *  const white = [255, 255, 255, 1];
 *  const blue = [0, 153, 255, 1];
 *  const width = 3;
 *  styles['Polygon'] = [
 *    new Style({
 *      fill: new Fill({
 *        color: [255, 255, 255, 0.5],
 *      }),
 *    }),
 *  ];
 *  styles['MultiPolygon'] =
 *      styles['Polygon'];
 *  styles['LineString'] = [
 *    new Style({
 *      stroke: new Stroke({
 *        color: white,
 *        width: width + 2,
 *      }),
 *    }),
 *    new Style({
 *      stroke: new Stroke({
 *        color: blue,
 *        width: width,
 *      }),
 *    }),
 *  ];
 *  styles['MultiLineString'] = styles['LineString'];
 *
 *  styles['Circle'] = styles['Polygon'].concat(
 *    styles['LineString']
 *  );
 *
 *  styles['Point'] = [
 *    new Style({
 *      image: new Circle({
 *        radius: width * 2,
 *        fill: new Fill({
 *          color: blue,
 *        }),
 *        stroke: new Stroke({
 *          color: white,
 *          width: width / 2,
 *        }),
 *      }),
 *      zIndex: Infinity,
 *    }),
 *  ];
 *  styles['MultiPoint'] =
 *      styles['Point'];
 *  styles['GeometryCollection'] =
 *      styles['Polygon'].concat(
 *          styles['LineString'],
 *          styles['Point']
 *      );
 * ```
 *
 * @api
 */
class Style {
  /**
   * @param {Options} [options] Style options.
   */
  constructor(options) {
    options = options || {};

    /**
     * @private
     * @type {string|import("../geom/Geometry.js").default|GeometryFunction}
     */
    this.geometry_ = null;

    /**
     * @private
     * @type {!GeometryFunction}
     */
    this.geometryFunction_ = defaultGeometryFunction;

    if (options.geometry !== undefined) {
      this.setGeometry(options.geometry);
    }

    /**
     * @private
     * @type {import("./Fill.js").default}
     */
    this.fill_ = options.fill !== undefined ? options.fill : null;

    /**
     * @private
     * @type {import("./Image.js").default}
     */
    this.image_ = options.image !== undefined ? options.image : null;

    /**
     * @private
     * @type {RenderFunction|null}
     */
    this.renderer_ = options.renderer !== undefined ? options.renderer : null;

    /**
     * @private
     * @type {RenderFunction|null}
     */
    this.hitDetectionRenderer_ =
      options.hitDetectionRenderer !== undefined
        ? options.hitDetectionRenderer
        : null;

    /**
     * @private
     * @type {import("./Stroke.js").default}
     */
    this.stroke_ = options.stroke !== undefined ? options.stroke : null;

    /**
     * @private
     * @type {import("./Text.js").default}
     */
    this.text_ = options.text !== undefined ? options.text : null;

    /**
     * @private
     * @type {number|undefined}
     */
    this.zIndex_ = options.zIndex;
  }

  /**
   * Clones the style.
   * @return {Style} The cloned style.
   * @api
   */
  clone() {
    let geometry = this.getGeometry();
    if (geometry && typeof geometry === 'object') {
      geometry = /** @type {import("../geom/Geometry.js").default} */ (
        geometry
      ).clone();
    }
    return new Style({
      geometry: geometry,
      fill: this.getFill() ? this.getFill().clone() : undefined,
      image: this.getImage() ? this.getImage().clone() : undefined,
      renderer: this.getRenderer(),
      stroke: this.getStroke() ? this.getStroke().clone() : undefined,
      text: this.getText() ? this.getText().clone() : undefined,
      zIndex: this.getZIndex(),
    });
  }

  /**
   * Get the custom renderer function that was configured with
   * {@link #setRenderer} or the `renderer` constructor option.
   * @return {RenderFunction|null} Custom renderer function.
   * @api
   */
  getRenderer() {
    return this.renderer_;
  }

  /**
   * Sets a custom renderer function for this style. When set, `fill`, `stroke`
   * and `image` options of the style will be ignored.
   * @param {RenderFunction|null} renderer Custom renderer function.
   * @api
   */
  setRenderer(renderer) {
    this.renderer_ = renderer;
  }

  /**
   * Sets a custom renderer function for this style used
   * in hit detection.
   * @param {RenderFunction|null} renderer Custom renderer function.
   * @api
   */
  setHitDetectionRenderer(renderer) {
    this.hitDetectionRenderer_ = renderer;
  }

  /**
   * Get the custom renderer function that was configured with
   * {@link #setHitDetectionRenderer} or the `hitDetectionRenderer` constructor option.
   * @return {RenderFunction|null} Custom renderer function.
   * @api
   */
  getHitDetectionRenderer() {
    return this.hitDetectionRenderer_;
  }

  /**
   * Get the geometry to be rendered.
   * @return {string|import("../geom/Geometry.js").default|GeometryFunction}
   * Feature property or geometry or function that returns the geometry that will
   * be rendered with this style.
   * @api
   */
  getGeometry() {
    return this.geometry_;
  }

  /**
   * Get the function used to generate a geometry for rendering.
   * @return {!GeometryFunction} Function that is called with a feature
   * and returns the geometry to render instead of the feature's geometry.
   * @api
   */
  getGeometryFunction() {
    return this.geometryFunction_;
  }

  /**
   * Get the fill style.
   * @return {import("./Fill.js").default} Fill style.
   * @api
   */
  getFill() {
    return this.fill_;
  }

  /**
   * Set the fill style.
   * @param {import("./Fill.js").default} fill Fill style.
   * @api
   */
  setFill(fill) {
    this.fill_ = fill;
  }

  /**
   * Get the image style.
   * @return {import("./Image.js").default} Image style.
   * @api
   */
  getImage() {
    return this.image_;
  }

  /**
   * Set the image style.
   * @param {import("./Image.js").default} image Image style.
   * @api
   */
  setImage(image) {
    this.image_ = image;
  }

  /**
   * Get the stroke style.
   * @return {import("./Stroke.js").default} Stroke style.
   * @api
   */
  getStroke() {
    return this.stroke_;
  }

  /**
   * Set the stroke style.
   * @param {import("./Stroke.js").default} stroke Stroke style.
   * @api
   */
  setStroke(stroke) {
    this.stroke_ = stroke;
  }

  /**
   * Get the text style.
   * @return {import("./Text.js").default} Text style.
   * @api
   */
  getText() {
    return this.text_;
  }

  /**
   * Set the text style.
   * @param {import("./Text.js").default} text Text style.
   * @api
   */
  setText(text) {
    this.text_ = text;
  }

  /**
   * Get the z-index for the style.
   * @return {number|undefined} ZIndex.
   * @api
   */
  getZIndex() {
    return this.zIndex_;
  }

  /**
   * Set a geometry that is rendered instead of the feature's geometry.
   *
   * @param {string|import("../geom/Geometry.js").default|GeometryFunction} geometry
   *     Feature property or geometry or function returning a geometry to render
   *     for this style.
   * @api
   */
  setGeometry(geometry) {
    if (typeof geometry === 'function') {
      this.geometryFunction_ = geometry;
    } else if (typeof geometry === 'string') {
      this.geometryFunction_ = function (feature) {
        return /** @type {import("../geom/Geometry.js").default} */ (
          feature.get(geometry)
        );
      };
    } else if (!geometry) {
      this.geometryFunction_ = defaultGeometryFunction;
    } else if (geometry !== undefined) {
      this.geometryFunction_ = function () {
        return /** @type {import("../geom/Geometry.js").default} */ (geometry);
      };
    }
    this.geometry_ = geometry;
  }

  /**
   * Set the z-index.
   *
   * @param {number|undefined} zIndex ZIndex.
   * @api
   */
  setZIndex(zIndex) {
    this.zIndex_ = zIndex;
  }
}

/**
 * Convert the provided object into a style function.  Functions passed through
 * unchanged.  Arrays of Style or single style objects wrapped in a
 * new style function.
 * @param {StyleFunction|Array<Style>|Style} obj
 *     A style function, a single style, or an array of styles.
 * @return {StyleFunction} A style function.
 */
function toFunction(obj) {
  let styleFunction;

  if (typeof obj === 'function') {
    styleFunction = obj;
  } else {
    /**
     * @type {Array<Style>}
     */
    let styles;
    if (Array.isArray(obj)) {
      styles = obj;
    } else {
      (0,_asserts_js__WEBPACK_IMPORTED_MODULE_0__.assert)(
        typeof (/** @type {?} */ (obj).getZIndex) === 'function',
        'Expected an `Style` or an array of `Style`'
      );
      const style = /** @type {Style} */ (obj);
      styles = [style];
    }
    styleFunction = function () {
      return styles;
    };
  }
  return styleFunction;
}

/**
 * @type {Array<Style>|null}
 */
let defaultStyles = null;

/**
 * @param {import("../Feature.js").FeatureLike} feature Feature.
 * @param {number} resolution Resolution.
 * @return {Array<Style>} Style.
 */
function createDefaultStyle(feature, resolution) {
  // We don't use an immediately-invoked function
  // and a closure so we don't get an error at script evaluation time in
  // browsers that do not support Canvas. (import("./Circle.js").CircleStyle does
  // canvas.getContext('2d') at construction time, which will cause an.error
  // in such browsers.)
  if (!defaultStyles) {
    const fill = new _Fill_js__WEBPACK_IMPORTED_MODULE_1__["default"]({
      color: 'rgba(255,255,255,0.4)',
    });
    const stroke = new _Stroke_js__WEBPACK_IMPORTED_MODULE_2__["default"]({
      color: '#3399CC',
      width: 1.25,
    });
    defaultStyles = [
      new Style({
        image: new _Circle_js__WEBPACK_IMPORTED_MODULE_3__["default"]({
          fill: fill,
          stroke: stroke,
          radius: 5,
        }),
        fill: fill,
        stroke: stroke,
      }),
    ];
  }
  return defaultStyles;
}

/**
 * Default styles for editing features.
 * @return {Object<import("../geom/Geometry.js").Type, Array<Style>>} Styles
 */
function createEditingStyle() {
  /** @type {Object<import("../geom/Geometry.js").Type, Array<Style>>} */
  const styles = {};
  const white = [255, 255, 255, 1];
  const blue = [0, 153, 255, 1];
  const width = 3;
  styles['Polygon'] = [
    new Style({
      fill: new _Fill_js__WEBPACK_IMPORTED_MODULE_1__["default"]({
        color: [255, 255, 255, 0.5],
      }),
    }),
  ];
  styles['MultiPolygon'] = styles['Polygon'];

  styles['LineString'] = [
    new Style({
      stroke: new _Stroke_js__WEBPACK_IMPORTED_MODULE_2__["default"]({
        color: white,
        width: width + 2,
      }),
    }),
    new Style({
      stroke: new _Stroke_js__WEBPACK_IMPORTED_MODULE_2__["default"]({
        color: blue,
        width: width,
      }),
    }),
  ];
  styles['MultiLineString'] = styles['LineString'];

  styles['Circle'] = styles['Polygon'].concat(styles['LineString']);

  styles['Point'] = [
    new Style({
      image: new _Circle_js__WEBPACK_IMPORTED_MODULE_3__["default"]({
        radius: width * 2,
        fill: new _Fill_js__WEBPACK_IMPORTED_MODULE_1__["default"]({
          color: blue,
        }),
        stroke: new _Stroke_js__WEBPACK_IMPORTED_MODULE_2__["default"]({
          color: white,
          width: width / 2,
        }),
      }),
      zIndex: Infinity,
    }),
  ];
  styles['MultiPoint'] = styles['Point'];

  styles['GeometryCollection'] = styles['Polygon'].concat(
    styles['LineString'],
    styles['Point']
  );

  return styles;
}

/**
 * Function that is called with a feature and returns its default geometry.
 * @param {import("../Feature.js").FeatureLike} feature Feature to get the geometry for.
 * @return {import("../geom/Geometry.js").default|import("../render/Feature.js").default|undefined} Geometry to render.
 */
function defaultGeometryFunction(feature) {
  return feature.getGeometry();
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Style);


/***/ }),

/***/ "./node_modules/ol/style/Text.js":
/*!***************************************!*\
  !*** ./node_modules/ol/style/Text.js ***!
  \***************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Fill_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Fill.js */ "./node_modules/ol/style/Fill.js");
/* harmony import */ var _size_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../size.js */ "./node_modules/ol/size.js");
/**
 * @module ol/style/Text
 */



/**
 * @typedef {'point' | 'line'} TextPlacement
 * Default text placement is `'point'`. Note that
 * `'line'` requires the underlying geometry to be a {@link module:ol/geom/LineString~LineString},
 * {@link module:ol/geom/Polygon~Polygon}, {@link module:ol/geom/MultiLineString~MultiLineString} or
 * {@link module:ol/geom/MultiPolygon~MultiPolygon}.
 */

/**
 * @typedef {'left' | 'center' | 'right'} TextJustify
 */

/**
 * The default fill color to use if no fill was set at construction time; a
 * blackish `#333`.
 *
 * @const {string}
 */
const DEFAULT_FILL_COLOR = '#333';

/**
 * @typedef {Object} Options
 * @property {string} [font] Font style as CSS `font` value, see:
 * https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/font. Default is `'10px sans-serif'`
 * @property {number} [maxAngle=Math.PI/4] When `placement` is set to `'line'`, allow a maximum angle between adjacent characters.
 * The expected value is in radians, and the default is 45° (`Math.PI / 4`).
 * @property {number} [offsetX=0] Horizontal text offset in pixels. A positive will shift the text right.
 * @property {number} [offsetY=0] Vertical text offset in pixels. A positive will shift the text down.
 * @property {boolean} [overflow=false] For polygon labels or when `placement` is set to `'line'`, allow text to exceed
 * the width of the polygon at the label position or the length of the path that it follows.
 * @property {TextPlacement} [placement='point'] Text placement.
 * @property {number} [repeat] Repeat interval. When set, the text will be repeated at this interval, which specifies
 * the distance between two text anchors in pixels. Only available when `placement` is set to `'line'`. Overrides 'textAlign'.
 * @property {number|import("../size.js").Size} [scale] Scale.
 * @property {boolean} [rotateWithView=false] Whether to rotate the text with the view.
 * @property {number} [rotation=0] Rotation in radians (positive rotation clockwise).
 * @property {string|Array<string>} [text] Text content or rich text content. For plain text provide a string, which can
 * contain line breaks (`\n`). For rich text provide an array of text/font tuples. A tuple consists of the text to
 * render and the font to use (or `''` to use the text style's font). A line break has to be a separate tuple (i.e. `'\n', ''`).
 * **Example:** `['foo', 'bold 10px sans-serif', ' bar', 'italic 10px sans-serif', ' baz', '']` will yield "**foo** *bar* baz".
 * **Note:** Rich text is not supported for `placement: 'line'` or the immediate rendering API.
 * @property {CanvasTextAlign} [textAlign] Text alignment. Possible values: `'left'`, `'right'`, `'center'`, `'end'` or `'start'`.
 * Default is `'center'` for `placement: 'point'`. For `placement: 'line'`, the default is to let the renderer choose a
 * placement where `maxAngle` is not exceeded.
 * @property {TextJustify} [justify] Text justification within the text box.
 * If not set, text is justified towards the `textAlign` anchor.
 * Otherwise, use options `'left'`, `'center'`, or `'right'` to justify the text within the text box.
 * **Note:** `justify` is ignored for immediate rendering and also for `placement: 'line'`.
 * @property {CanvasTextBaseline} [textBaseline='middle'] Text base line. Possible values: `'bottom'`, `'top'`, `'middle'`, `'alphabetic'`,
 * `'hanging'`, `'ideographic'`.
 * @property {import("./Fill.js").default|null} [fill] Fill style. If none is provided, we'll use a dark fill-style (#333). Specify `null` for no fill.
 * @property {import("./Stroke.js").default} [stroke] Stroke style.
 * @property {import("./Fill.js").default} [backgroundFill] Fill style for the text background when `placement` is
 * `'point'`. Default is no fill.
 * @property {import("./Stroke.js").default} [backgroundStroke] Stroke style for the text background  when `placement`
 * is `'point'`. Default is no stroke.
 * @property {Array<number>} [padding=[0, 0, 0, 0]] Padding in pixels around the text for decluttering and background. The order of
 * values in the array is `[top, right, bottom, left]`.
 */

/**
 * @classdesc
 * Set text style for vector features.
 * @api
 */
class Text {
  /**
   * @param {Options} [options] Options.
   */
  constructor(options) {
    options = options || {};

    /**
     * @private
     * @type {string|undefined}
     */
    this.font_ = options.font;

    /**
     * @private
     * @type {number|undefined}
     */
    this.rotation_ = options.rotation;

    /**
     * @private
     * @type {boolean|undefined}
     */
    this.rotateWithView_ = options.rotateWithView;

    /**
     * @private
     * @type {number|import("../size.js").Size|undefined}
     */
    this.scale_ = options.scale;

    /**
     * @private
     * @type {import("../size.js").Size}
     */
    this.scaleArray_ = (0,_size_js__WEBPACK_IMPORTED_MODULE_0__.toSize)(options.scale !== undefined ? options.scale : 1);

    /**
     * @private
     * @type {string|Array<string>|undefined}
     */
    this.text_ = options.text;

    /**
     * @private
     * @type {CanvasTextAlign|undefined}
     */
    this.textAlign_ = options.textAlign;

    /**
     * @private
     * @type {TextJustify|undefined}
     */
    this.justify_ = options.justify;

    /**
     * @private
     * @type {number|undefined}
     */
    this.repeat_ = options.repeat;

    /**
     * @private
     * @type {CanvasTextBaseline|undefined}
     */
    this.textBaseline_ = options.textBaseline;

    /**
     * @private
     * @type {import("./Fill.js").default}
     */
    this.fill_ =
      options.fill !== undefined
        ? options.fill
        : new _Fill_js__WEBPACK_IMPORTED_MODULE_1__["default"]({color: DEFAULT_FILL_COLOR});

    /**
     * @private
     * @type {number}
     */
    this.maxAngle_ =
      options.maxAngle !== undefined ? options.maxAngle : Math.PI / 4;

    /**
     * @private
     * @type {TextPlacement}
     */
    this.placement_ =
      options.placement !== undefined ? options.placement : 'point';

    /**
     * @private
     * @type {boolean}
     */
    this.overflow_ = !!options.overflow;

    /**
     * @private
     * @type {import("./Stroke.js").default}
     */
    this.stroke_ = options.stroke !== undefined ? options.stroke : null;

    /**
     * @private
     * @type {number}
     */
    this.offsetX_ = options.offsetX !== undefined ? options.offsetX : 0;

    /**
     * @private
     * @type {number}
     */
    this.offsetY_ = options.offsetY !== undefined ? options.offsetY : 0;

    /**
     * @private
     * @type {import("./Fill.js").default}
     */
    this.backgroundFill_ = options.backgroundFill
      ? options.backgroundFill
      : null;

    /**
     * @private
     * @type {import("./Stroke.js").default}
     */
    this.backgroundStroke_ = options.backgroundStroke
      ? options.backgroundStroke
      : null;

    /**
     * @private
     * @type {Array<number>|null}
     */
    this.padding_ = options.padding === undefined ? null : options.padding;
  }

  /**
   * Clones the style.
   * @return {Text} The cloned style.
   * @api
   */
  clone() {
    const scale = this.getScale();
    return new Text({
      font: this.getFont(),
      placement: this.getPlacement(),
      repeat: this.getRepeat(),
      maxAngle: this.getMaxAngle(),
      overflow: this.getOverflow(),
      rotation: this.getRotation(),
      rotateWithView: this.getRotateWithView(),
      scale: Array.isArray(scale) ? scale.slice() : scale,
      text: this.getText(),
      textAlign: this.getTextAlign(),
      justify: this.getJustify(),
      textBaseline: this.getTextBaseline(),
      fill: this.getFill() ? this.getFill().clone() : undefined,
      stroke: this.getStroke() ? this.getStroke().clone() : undefined,
      offsetX: this.getOffsetX(),
      offsetY: this.getOffsetY(),
      backgroundFill: this.getBackgroundFill()
        ? this.getBackgroundFill().clone()
        : undefined,
      backgroundStroke: this.getBackgroundStroke()
        ? this.getBackgroundStroke().clone()
        : undefined,
      padding: this.getPadding() || undefined,
    });
  }

  /**
   * Get the `overflow` configuration.
   * @return {boolean} Let text overflow the length of the path they follow.
   * @api
   */
  getOverflow() {
    return this.overflow_;
  }

  /**
   * Get the font name.
   * @return {string|undefined} Font.
   * @api
   */
  getFont() {
    return this.font_;
  }

  /**
   * Get the maximum angle between adjacent characters.
   * @return {number} Angle in radians.
   * @api
   */
  getMaxAngle() {
    return this.maxAngle_;
  }

  /**
   * Get the label placement.
   * @return {TextPlacement} Text placement.
   * @api
   */
  getPlacement() {
    return this.placement_;
  }

  /**
   * Get the repeat interval of the text.
   * @return {number|undefined} Repeat interval in pixels.
   * @api
   */
  getRepeat() {
    return this.repeat_;
  }

  /**
   * Get the x-offset for the text.
   * @return {number} Horizontal text offset.
   * @api
   */
  getOffsetX() {
    return this.offsetX_;
  }

  /**
   * Get the y-offset for the text.
   * @return {number} Vertical text offset.
   * @api
   */
  getOffsetY() {
    return this.offsetY_;
  }

  /**
   * Get the fill style for the text.
   * @return {import("./Fill.js").default} Fill style.
   * @api
   */
  getFill() {
    return this.fill_;
  }

  /**
   * Determine whether the text rotates with the map.
   * @return {boolean|undefined} Rotate with map.
   * @api
   */
  getRotateWithView() {
    return this.rotateWithView_;
  }

  /**
   * Get the text rotation.
   * @return {number|undefined} Rotation.
   * @api
   */
  getRotation() {
    return this.rotation_;
  }

  /**
   * Get the text scale.
   * @return {number|import("../size.js").Size|undefined} Scale.
   * @api
   */
  getScale() {
    return this.scale_;
  }

  /**
   * Get the symbolizer scale array.
   * @return {import("../size.js").Size} Scale array.
   */
  getScaleArray() {
    return this.scaleArray_;
  }

  /**
   * Get the stroke style for the text.
   * @return {import("./Stroke.js").default} Stroke style.
   * @api
   */
  getStroke() {
    return this.stroke_;
  }

  /**
   * Get the text to be rendered.
   * @return {string|Array<string>|undefined} Text.
   * @api
   */
  getText() {
    return this.text_;
  }

  /**
   * Get the text alignment.
   * @return {CanvasTextAlign|undefined} Text align.
   * @api
   */
  getTextAlign() {
    return this.textAlign_;
  }

  /**
   * Get the justification.
   * @return {TextJustify|undefined} Justification.
   * @api
   */
  getJustify() {
    return this.justify_;
  }

  /**
   * Get the text baseline.
   * @return {CanvasTextBaseline|undefined} Text baseline.
   * @api
   */
  getTextBaseline() {
    return this.textBaseline_;
  }

  /**
   * Get the background fill style for the text.
   * @return {import("./Fill.js").default} Fill style.
   * @api
   */
  getBackgroundFill() {
    return this.backgroundFill_;
  }

  /**
   * Get the background stroke style for the text.
   * @return {import("./Stroke.js").default} Stroke style.
   * @api
   */
  getBackgroundStroke() {
    return this.backgroundStroke_;
  }

  /**
   * Get the padding for the text.
   * @return {Array<number>|null} Padding.
   * @api
   */
  getPadding() {
    return this.padding_;
  }

  /**
   * Set the `overflow` property.
   *
   * @param {boolean} overflow Let text overflow the path that it follows.
   * @api
   */
  setOverflow(overflow) {
    this.overflow_ = overflow;
  }

  /**
   * Set the font.
   *
   * @param {string|undefined} font Font.
   * @api
   */
  setFont(font) {
    this.font_ = font;
  }

  /**
   * Set the maximum angle between adjacent characters.
   *
   * @param {number} maxAngle Angle in radians.
   * @api
   */
  setMaxAngle(maxAngle) {
    this.maxAngle_ = maxAngle;
  }

  /**
   * Set the x offset.
   *
   * @param {number} offsetX Horizontal text offset.
   * @api
   */
  setOffsetX(offsetX) {
    this.offsetX_ = offsetX;
  }

  /**
   * Set the y offset.
   *
   * @param {number} offsetY Vertical text offset.
   * @api
   */
  setOffsetY(offsetY) {
    this.offsetY_ = offsetY;
  }

  /**
   * Set the text placement.
   *
   * @param {TextPlacement} placement Placement.
   * @api
   */
  setPlacement(placement) {
    this.placement_ = placement;
  }

  /**
   * Set the repeat interval of the text.
   * @param {number|undefined} [repeat] Repeat interval in pixels.
   * @api
   */
  setRepeat(repeat) {
    this.repeat_ = repeat;
  }

  /**
   * Set whether to rotate the text with the view.
   *
   * @param {boolean} rotateWithView Rotate with map.
   * @api
   */
  setRotateWithView(rotateWithView) {
    this.rotateWithView_ = rotateWithView;
  }

  /**
   * Set the fill.
   *
   * @param {import("./Fill.js").default} fill Fill style.
   * @api
   */
  setFill(fill) {
    this.fill_ = fill;
  }

  /**
   * Set the rotation.
   *
   * @param {number|undefined} rotation Rotation.
   * @api
   */
  setRotation(rotation) {
    this.rotation_ = rotation;
  }

  /**
   * Set the scale.
   *
   * @param {number|import("../size.js").Size|undefined} scale Scale.
   * @api
   */
  setScale(scale) {
    this.scale_ = scale;
    this.scaleArray_ = (0,_size_js__WEBPACK_IMPORTED_MODULE_0__.toSize)(scale !== undefined ? scale : 1);
  }

  /**
   * Set the stroke.
   *
   * @param {import("./Stroke.js").default} stroke Stroke style.
   * @api
   */
  setStroke(stroke) {
    this.stroke_ = stroke;
  }

  /**
   * Set the text.
   *
   * @param {string|Array<string>|undefined} text Text.
   * @api
   */
  setText(text) {
    this.text_ = text;
  }

  /**
   * Set the text alignment.
   *
   * @param {CanvasTextAlign|undefined} textAlign Text align.
   * @api
   */
  setTextAlign(textAlign) {
    this.textAlign_ = textAlign;
  }

  /**
   * Set the justification.
   *
   * @param {TextJustify|undefined} justify Justification.
   * @api
   */
  setJustify(justify) {
    this.justify_ = justify;
  }

  /**
   * Set the text baseline.
   *
   * @param {CanvasTextBaseline|undefined} textBaseline Text baseline.
   * @api
   */
  setTextBaseline(textBaseline) {
    this.textBaseline_ = textBaseline;
  }

  /**
   * Set the background fill.
   *
   * @param {import("./Fill.js").default} fill Fill style.
   * @api
   */
  setBackgroundFill(fill) {
    this.backgroundFill_ = fill;
  }

  /**
   * Set the background stroke.
   *
   * @param {import("./Stroke.js").default} stroke Stroke style.
   * @api
   */
  setBackgroundStroke(stroke) {
    this.backgroundStroke_ = stroke;
  }

  /**
   * Set the padding (`[top, right, bottom, left]`).
   *
   * @param {Array<number>|null} padding Padding.
   * @api
   */
  setPadding(padding) {
    this.padding_ = padding;
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Text);


/***/ }),

/***/ "./node_modules/ol/tilecoord.js":
/*!**************************************!*\
  !*** ./node_modules/ol/tilecoord.js ***!
  \**************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createOrUpdate: () => (/* binding */ createOrUpdate),
/* harmony export */   fromKey: () => (/* binding */ fromKey),
/* harmony export */   getCacheKeyForTileKey: () => (/* binding */ getCacheKeyForTileKey),
/* harmony export */   getKey: () => (/* binding */ getKey),
/* harmony export */   getKeyZXY: () => (/* binding */ getKeyZXY),
/* harmony export */   hash: () => (/* binding */ hash),
/* harmony export */   withinExtentAndZ: () => (/* binding */ withinExtentAndZ)
/* harmony export */ });
/**
 * @module ol/tilecoord
 */

/**
 * An array of three numbers representing the location of a tile in a tile
 * grid. The order is `z` (zoom level), `x` (column), and `y` (row).
 * @typedef {Array<number>} TileCoord
 * @api
 */

/**
 * @param {number} z Z.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {TileCoord} [tileCoord] Tile coordinate.
 * @return {TileCoord} Tile coordinate.
 */
function createOrUpdate(z, x, y, tileCoord) {
  if (tileCoord !== undefined) {
    tileCoord[0] = z;
    tileCoord[1] = x;
    tileCoord[2] = y;
    return tileCoord;
  }
  return [z, x, y];
}

/**
 * @param {number} z Z.
 * @param {number} x X.
 * @param {number} y Y.
 * @return {string} Key.
 */
function getKeyZXY(z, x, y) {
  return z + '/' + x + '/' + y;
}

/**
 * Get the key for a tile coord.
 * @param {TileCoord} tileCoord The tile coord.
 * @return {string} Key.
 */
function getKey(tileCoord) {
  return getKeyZXY(tileCoord[0], tileCoord[1], tileCoord[2]);
}

/**
 * Get the tile cache key for a tile key obtained through `tile.getKey()`.
 * @param {string} tileKey The tile key.
 * @return {string} The cache key.
 */
function getCacheKeyForTileKey(tileKey) {
  const [z, x, y] = tileKey
    .substring(tileKey.lastIndexOf('/') + 1, tileKey.length)
    .split(',')
    .map(Number);
  return getKeyZXY(z, x, y);
}

/**
 * Get a tile coord given a key.
 * @param {string} key The tile coord key.
 * @return {TileCoord} The tile coord.
 */
function fromKey(key) {
  return key.split('/').map(Number);
}

/**
 * @param {TileCoord} tileCoord Tile coord.
 * @return {number} Hash.
 */
function hash(tileCoord) {
  return (tileCoord[1] << tileCoord[0]) + tileCoord[2];
}

/**
 * @param {TileCoord} tileCoord Tile coordinate.
 * @param {!import("./tilegrid/TileGrid.js").default} tileGrid Tile grid.
 * @return {boolean} Tile coordinate is within extent and zoom level range.
 */
function withinExtentAndZ(tileCoord, tileGrid) {
  const z = tileCoord[0];
  const x = tileCoord[1];
  const y = tileCoord[2];

  if (tileGrid.getMinZoom() > z || z > tileGrid.getMaxZoom()) {
    return false;
  }
  const tileRange = tileGrid.getFullTileRange(z);
  if (!tileRange) {
    return true;
  }
  return tileRange.containsXY(x, y);
}


/***/ }),

/***/ "./node_modules/ol/tilegrid.js":
/*!*************************************!*\
  !*** ./node_modules/ol/tilegrid.js ***!
  \*************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createForExtent: () => (/* binding */ createForExtent),
/* harmony export */   createForProjection: () => (/* binding */ createForProjection),
/* harmony export */   createXYZ: () => (/* binding */ createXYZ),
/* harmony export */   extentFromProjection: () => (/* binding */ extentFromProjection),
/* harmony export */   getForProjection: () => (/* binding */ getForProjection),
/* harmony export */   wrapX: () => (/* binding */ wrapX)
/* harmony export */ });
/* harmony import */ var _tilegrid_TileGrid_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./tilegrid/TileGrid.js */ "./node_modules/ol/tilegrid/TileGrid.js");
/* harmony import */ var _tilegrid_common_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./tilegrid/common.js */ "./node_modules/ol/tilegrid/common.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./proj.js */ "./node_modules/ol/proj.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _size_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./size.js */ "./node_modules/ol/size.js");
/**
 * @module ol/tilegrid
 */






/**
 * @param {import("./proj/Projection.js").default} projection Projection.
 * @return {!TileGrid} Default tile grid for the
 * passed projection.
 */
function getForProjection(projection) {
  let tileGrid = projection.getDefaultTileGrid();
  if (!tileGrid) {
    tileGrid = createForProjection(projection);
    projection.setDefaultTileGrid(tileGrid);
  }
  return tileGrid;
}

/**
 * @param {TileGrid} tileGrid Tile grid.
 * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
 * @param {import("./proj/Projection.js").default} projection Projection.
 * @return {import("./tilecoord.js").TileCoord} Tile coordinate.
 */
function wrapX(tileGrid, tileCoord, projection) {
  const z = tileCoord[0];
  const center = tileGrid.getTileCoordCenter(tileCoord);
  const projectionExtent = extentFromProjection(projection);
  if (!(0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.containsCoordinate)(projectionExtent, center)) {
    const worldWidth = (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.getWidth)(projectionExtent);
    const worldsAway = Math.ceil(
      (projectionExtent[0] - center[0]) / worldWidth
    );
    center[0] += worldWidth * worldsAway;
    return tileGrid.getTileCoordForCoordAndZ(center, z);
  }
  return tileCoord;
}

/**
 * @param {import("./extent.js").Extent} extent Extent.
 * @param {number} [maxZoom] Maximum zoom level (default is
 *     DEFAULT_MAX_ZOOM).
 * @param {number|import("./size.js").Size} [tileSize] Tile size (default uses
 *     DEFAULT_TILE_SIZE).
 * @param {import("./extent.js").Corner} [corner] Extent corner (default is `'top-left'`).
 * @return {!TileGrid} TileGrid instance.
 */
function createForExtent(extent, maxZoom, tileSize, corner) {
  corner = corner !== undefined ? corner : 'top-left';

  const resolutions = resolutionsFromExtent(extent, maxZoom, tileSize);

  return new _tilegrid_TileGrid_js__WEBPACK_IMPORTED_MODULE_2__["default"]({
    extent: extent,
    origin: (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.getCorner)(extent, corner),
    resolutions: resolutions,
    tileSize: tileSize,
  });
}

/**
 * @typedef {Object} XYZOptions
 * @property {import("./extent.js").Extent} [extent] Extent for the tile grid. The origin for an XYZ tile grid is the
 * top-left corner of the extent. If `maxResolution` is not provided the zero level of the grid is defined by the resolution
 * at which one tile fits in the provided extent. If not provided, the extent of the EPSG:3857 projection is used.
 * @property {number} [maxResolution] Resolution at level zero.
 * @property {number} [maxZoom] Maximum zoom. The default is `42`. This determines the number of levels
 * in the grid set. For example, a `maxZoom` of 21 means there are 22 levels in the grid set.
 * @property {number} [minZoom=0] Minimum zoom.
 * @property {number|import("./size.js").Size} [tileSize=[256, 256]] Tile size in pixels.
 */

/**
 * Creates a tile grid with a standard XYZ tiling scheme.
 * @param {XYZOptions} [options] Tile grid options.
 * @return {!TileGrid} Tile grid instance.
 * @api
 */
function createXYZ(options) {
  const xyzOptions = options || {};

  const extent = xyzOptions.extent || (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.get)('EPSG:3857').getExtent();

  const gridOptions = {
    extent: extent,
    minZoom: xyzOptions.minZoom,
    tileSize: xyzOptions.tileSize,
    resolutions: resolutionsFromExtent(
      extent,
      xyzOptions.maxZoom,
      xyzOptions.tileSize,
      xyzOptions.maxResolution
    ),
  };
  return new _tilegrid_TileGrid_js__WEBPACK_IMPORTED_MODULE_2__["default"](gridOptions);
}

/**
 * Create a resolutions array from an extent.  A zoom factor of 2 is assumed.
 * @param {import("./extent.js").Extent} extent Extent.
 * @param {number} [maxZoom] Maximum zoom level (default is
 *     DEFAULT_MAX_ZOOM).
 * @param {number|import("./size.js").Size} [tileSize] Tile size (default uses
 *     DEFAULT_TILE_SIZE).
 * @param {number} [maxResolution] Resolution at level zero.
 * @return {!Array<number>} Resolutions array.
 */
function resolutionsFromExtent(extent, maxZoom, tileSize, maxResolution) {
  maxZoom = maxZoom !== undefined ? maxZoom : _tilegrid_common_js__WEBPACK_IMPORTED_MODULE_3__.DEFAULT_MAX_ZOOM;
  tileSize = (0,_size_js__WEBPACK_IMPORTED_MODULE_4__.toSize)(tileSize !== undefined ? tileSize : _tilegrid_common_js__WEBPACK_IMPORTED_MODULE_3__.DEFAULT_TILE_SIZE);

  const height = (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.getHeight)(extent);
  const width = (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.getWidth)(extent);

  maxResolution =
    maxResolution > 0
      ? maxResolution
      : Math.max(width / tileSize[0], height / tileSize[1]);

  const length = maxZoom + 1;
  const resolutions = new Array(length);
  for (let z = 0; z < length; ++z) {
    resolutions[z] = maxResolution / Math.pow(2, z);
  }
  return resolutions;
}

/**
 * @param {import("./proj.js").ProjectionLike} projection Projection.
 * @param {number} [maxZoom] Maximum zoom level (default is
 *     DEFAULT_MAX_ZOOM).
 * @param {number|import("./size.js").Size} [tileSize] Tile size (default uses
 *     DEFAULT_TILE_SIZE).
 * @param {import("./extent.js").Corner} [corner] Extent corner (default is `'top-left'`).
 * @return {!TileGrid} TileGrid instance.
 */
function createForProjection(projection, maxZoom, tileSize, corner) {
  const extent = extentFromProjection(projection);
  return createForExtent(extent, maxZoom, tileSize, corner);
}

/**
 * Generate a tile grid extent from a projection.  If the projection has an
 * extent, it is used.  If not, a global extent is assumed.
 * @param {import("./proj.js").ProjectionLike} projection Projection.
 * @return {import("./extent.js").Extent} Extent.
 */
function extentFromProjection(projection) {
  projection = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.get)(projection);
  let extent = projection.getExtent();
  if (!extent) {
    const half =
      (180 * _proj_js__WEBPACK_IMPORTED_MODULE_0__.METERS_PER_UNIT.degrees) / projection.getMetersPerUnit();
    extent = (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.createOrUpdate)(-half, -half, half, half);
  }
  return extent;
}


/***/ }),

/***/ "./node_modules/ol/tilegrid/TileGrid.js":
/*!**********************************************!*\
  !*** ./node_modules/ol/tilegrid/TileGrid.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _TileRange_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../TileRange.js */ "./node_modules/ol/TileRange.js");
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./common.js */ "./node_modules/ol/tilegrid/common.js");
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../asserts.js */ "./node_modules/ol/asserts.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../math.js */ "./node_modules/ol/math.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _tilecoord_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../tilecoord.js */ "./node_modules/ol/tilecoord.js");
/* harmony import */ var _geom_flat_intersectsextent_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../geom/flat/intersectsextent.js */ "./node_modules/ol/geom/flat/intersectsextent.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _size_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../size.js */ "./node_modules/ol/size.js");
/**
 * @module ol/tilegrid/TileGrid
 */










/**
 * @private
 * @type {import("../tilecoord.js").TileCoord}
 */
const tmpTileCoord = [0, 0, 0];

/**
 * Number of decimal digits to consider in integer values when rounding.
 * @type {number}
 */
const DECIMALS = 5;

/**
 * @typedef {Object} Options
 * @property {import("../extent.js").Extent} [extent] Extent for the tile grid. No tiles outside this
 * extent will be requested by {@link module:ol/source/Tile~TileSource} sources. When no `origin` or
 * `origins` are configured, the `origin` will be set to the top-left corner of the extent.
 * @property {number} [minZoom=0] Minimum zoom.
 * @property {import("../coordinate.js").Coordinate} [origin] The tile grid origin, i.e. where the `x`
 * and `y` axes meet (`[z, 0, 0]`). Tile coordinates increase left to right and downwards. If not
 * specified, `extent` or `origins` must be provided.
 * @property {Array<import("../coordinate.js").Coordinate>} [origins] Tile grid origins, i.e. where
 * the `x` and `y` axes meet (`[z, 0, 0]`), for each zoom level. If given, the array length
 * should match the length of the `resolutions` array, i.e. each resolution can have a different
 * origin. Tile coordinates increase left to right and downwards. If not specified, `extent` or
 * `origin` must be provided.
 * @property {!Array<number>} resolutions Resolutions. The array index of each resolution needs
 * to match the zoom level. This means that even if a `minZoom` is configured, the resolutions
 * array will have a length of `maxZoom + 1`.
 * @property {Array<import("../size.js").Size>} [sizes] Number of tile rows and columns
 * of the grid for each zoom level. If specified the values
 * define each zoom level's extent together with the `origin` or `origins`.
 * A grid `extent` can be configured in addition, and will further limit the extent
 * for which tile requests are made by sources. If the bottom-left corner of
 * an extent is used as `origin` or `origins`, then the `y` value must be
 * negative because OpenLayers tile coordinates use the top left as the origin.
 * @property {number|import("../size.js").Size} [tileSize] Tile size.
 * Default is `[256, 256]`.
 * @property {Array<number|import("../size.js").Size>} [tileSizes] Tile sizes. If given, the array length
 * should match the length of the `resolutions` array, i.e. each resolution can have a different
 * tile size.
 */

/**
 * @classdesc
 * Base class for setting the grid pattern for sources accessing tiled-image
 * servers.
 * @api
 */
class TileGrid {
  /**
   * @param {Options} options Tile grid options.
   */
  constructor(options) {
    /**
     * @protected
     * @type {number}
     */
    this.minZoom = options.minZoom !== undefined ? options.minZoom : 0;

    /**
     * @private
     * @type {!Array<number>}
     */
    this.resolutions_ = options.resolutions;
    (0,_asserts_js__WEBPACK_IMPORTED_MODULE_0__.assert)(
      (0,_array_js__WEBPACK_IMPORTED_MODULE_1__.isSorted)(
        this.resolutions_,
        function (a, b) {
          return b - a;
        },
        true
      ),
      '`resolutions` must be sorted in descending order'
    );

    // check if we've got a consistent zoom factor and origin
    let zoomFactor;
    if (!options.origins) {
      for (let i = 0, ii = this.resolutions_.length - 1; i < ii; ++i) {
        if (!zoomFactor) {
          zoomFactor = this.resolutions_[i] / this.resolutions_[i + 1];
        } else {
          if (this.resolutions_[i] / this.resolutions_[i + 1] !== zoomFactor) {
            zoomFactor = undefined;
            break;
          }
        }
      }
    }

    /**
     * @private
     * @type {number|undefined}
     */
    this.zoomFactor_ = zoomFactor;

    /**
     * @protected
     * @type {number}
     */
    this.maxZoom = this.resolutions_.length - 1;

    /**
     * @private
     * @type {import("../coordinate.js").Coordinate|null}
     */
    this.origin_ = options.origin !== undefined ? options.origin : null;

    /**
     * @private
     * @type {Array<import("../coordinate.js").Coordinate>}
     */
    this.origins_ = null;
    if (options.origins !== undefined) {
      this.origins_ = options.origins;
      (0,_asserts_js__WEBPACK_IMPORTED_MODULE_0__.assert)(
        this.origins_.length == this.resolutions_.length,
        'Number of `origins` and `resolutions` must be equal'
      );
    }

    const extent = options.extent;

    if (extent !== undefined && !this.origin_ && !this.origins_) {
      this.origin_ = (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.getTopLeft)(extent);
    }

    (0,_asserts_js__WEBPACK_IMPORTED_MODULE_0__.assert)(
      (!this.origin_ && this.origins_) || (this.origin_ && !this.origins_),
      'Either `origin` or `origins` must be configured, never both'
    );

    /**
     * @private
     * @type {Array<number|import("../size.js").Size>}
     */
    this.tileSizes_ = null;
    if (options.tileSizes !== undefined) {
      this.tileSizes_ = options.tileSizes;
      (0,_asserts_js__WEBPACK_IMPORTED_MODULE_0__.assert)(
        this.tileSizes_.length == this.resolutions_.length,
        'Number of `tileSizes` and `resolutions` must be equal'
      );
    }

    /**
     * @private
     * @type {number|import("../size.js").Size}
     */
    this.tileSize_ =
      options.tileSize !== undefined
        ? options.tileSize
        : !this.tileSizes_
        ? _common_js__WEBPACK_IMPORTED_MODULE_3__.DEFAULT_TILE_SIZE
        : null;
    (0,_asserts_js__WEBPACK_IMPORTED_MODULE_0__.assert)(
      (!this.tileSize_ && this.tileSizes_) ||
        (this.tileSize_ && !this.tileSizes_),
      'Either `tileSize` or `tileSizes` must be configured, never both'
    );

    /**
     * @private
     * @type {import("../extent.js").Extent}
     */
    this.extent_ = extent !== undefined ? extent : null;

    /**
     * @private
     * @type {Array<import("../TileRange.js").default>}
     */
    this.fullTileRanges_ = null;

    /**
     * @private
     * @type {import("../size.js").Size}
     */
    this.tmpSize_ = [0, 0];

    /**
     * @private
     * @type {import("../extent.js").Extent}
     */
    this.tmpExtent_ = [0, 0, 0, 0];

    if (options.sizes !== undefined) {
      this.fullTileRanges_ = options.sizes.map(function (size, z) {
        const tileRange = new _TileRange_js__WEBPACK_IMPORTED_MODULE_4__["default"](
          Math.min(0, size[0]),
          Math.max(size[0] - 1, -1),
          Math.min(0, size[1]),
          Math.max(size[1] - 1, -1)
        );
        if (extent) {
          const restrictedTileRange = this.getTileRangeForExtentAndZ(extent, z);
          tileRange.minX = Math.max(restrictedTileRange.minX, tileRange.minX);
          tileRange.maxX = Math.min(restrictedTileRange.maxX, tileRange.maxX);
          tileRange.minY = Math.max(restrictedTileRange.minY, tileRange.minY);
          tileRange.maxY = Math.min(restrictedTileRange.maxY, tileRange.maxY);
        }
        return tileRange;
      }, this);
    } else if (extent) {
      this.calculateTileRanges_(extent);
    }
  }

  /**
   * Call a function with each tile coordinate for a given extent and zoom level.
   *
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} zoom Integer zoom level.
   * @param {function(import("../tilecoord.js").TileCoord): void} callback Function called with each tile coordinate.
   * @api
   */
  forEachTileCoord(extent, zoom, callback) {
    const tileRange = this.getTileRangeForExtentAndZ(extent, zoom);
    for (let i = tileRange.minX, ii = tileRange.maxX; i <= ii; ++i) {
      for (let j = tileRange.minY, jj = tileRange.maxY; j <= jj; ++j) {
        callback([zoom, i, j]);
      }
    }
  }

  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {function(number, import("../TileRange.js").default): boolean} callback Callback.
   * @param {import("../TileRange.js").default} [tempTileRange] Temporary import("../TileRange.js").default object.
   * @param {import("../extent.js").Extent} [tempExtent] Temporary import("../extent.js").Extent object.
   * @return {boolean} Callback succeeded.
   */
  forEachTileCoordParentTileRange(
    tileCoord,
    callback,
    tempTileRange,
    tempExtent
  ) {
    let tileRange, x, y;
    let tileCoordExtent = null;
    let z = tileCoord[0] - 1;
    if (this.zoomFactor_ === 2) {
      x = tileCoord[1];
      y = tileCoord[2];
    } else {
      tileCoordExtent = this.getTileCoordExtent(tileCoord, tempExtent);
    }
    while (z >= this.minZoom) {
      if (this.zoomFactor_ === 2) {
        x = Math.floor(x / 2);
        y = Math.floor(y / 2);
        tileRange = (0,_TileRange_js__WEBPACK_IMPORTED_MODULE_4__.createOrUpdate)(x, x, y, y, tempTileRange);
      } else {
        tileRange = this.getTileRangeForExtentAndZ(
          tileCoordExtent,
          z,
          tempTileRange
        );
      }
      if (callback(z, tileRange)) {
        return true;
      }
      --z;
    }
    return false;
  }

  /**
   * Get the extent for this tile grid, if it was configured.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */
  getExtent() {
    return this.extent_;
  }

  /**
   * Get the maximum zoom level for the grid.
   * @return {number} Max zoom.
   * @api
   */
  getMaxZoom() {
    return this.maxZoom;
  }

  /**
   * Get the minimum zoom level for the grid.
   * @return {number} Min zoom.
   * @api
   */
  getMinZoom() {
    return this.minZoom;
  }

  /**
   * Get the origin for the grid at the given zoom level.
   * @param {number} z Integer zoom level.
   * @return {import("../coordinate.js").Coordinate} Origin.
   * @api
   */
  getOrigin(z) {
    if (this.origin_) {
      return this.origin_;
    }
    return this.origins_[z];
  }

  /**
   * Get the resolution for the given zoom level.
   * @param {number} z Integer zoom level.
   * @return {number} Resolution.
   * @api
   */
  getResolution(z) {
    return this.resolutions_[z];
  }

  /**
   * Get the list of resolutions for the tile grid.
   * @return {Array<number>} Resolutions.
   * @api
   */
  getResolutions() {
    return this.resolutions_;
  }

  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("../TileRange.js").default} [tempTileRange] Temporary import("../TileRange.js").default object.
   * @param {import("../extent.js").Extent} [tempExtent] Temporary import("../extent.js").Extent object.
   * @return {import("../TileRange.js").default|null} Tile range.
   */
  getTileCoordChildTileRange(tileCoord, tempTileRange, tempExtent) {
    if (tileCoord[0] < this.maxZoom) {
      if (this.zoomFactor_ === 2) {
        const minX = tileCoord[1] * 2;
        const minY = tileCoord[2] * 2;
        return (0,_TileRange_js__WEBPACK_IMPORTED_MODULE_4__.createOrUpdate)(
          minX,
          minX + 1,
          minY,
          minY + 1,
          tempTileRange
        );
      }
      const tileCoordExtent = this.getTileCoordExtent(
        tileCoord,
        tempExtent || this.tmpExtent_
      );
      return this.getTileRangeForExtentAndZ(
        tileCoordExtent,
        tileCoord[0] + 1,
        tempTileRange
      );
    }
    return null;
  }

  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {number} z Integer zoom level.
   * @param {import("../TileRange.js").default} [tempTileRange] Temporary import("../TileRange.js").default object.
   * @return {import("../TileRange.js").default|null} Tile range.
   */
  getTileRangeForTileCoordAndZ(tileCoord, z, tempTileRange) {
    if (z > this.maxZoom || z < this.minZoom) {
      return null;
    }

    const tileCoordZ = tileCoord[0];
    const tileCoordX = tileCoord[1];
    const tileCoordY = tileCoord[2];

    if (z === tileCoordZ) {
      return (0,_TileRange_js__WEBPACK_IMPORTED_MODULE_4__.createOrUpdate)(
        tileCoordX,
        tileCoordY,
        tileCoordX,
        tileCoordY,
        tempTileRange
      );
    }

    if (this.zoomFactor_) {
      const factor = Math.pow(this.zoomFactor_, z - tileCoordZ);
      const minX = Math.floor(tileCoordX * factor);
      const minY = Math.floor(tileCoordY * factor);
      if (z < tileCoordZ) {
        return (0,_TileRange_js__WEBPACK_IMPORTED_MODULE_4__.createOrUpdate)(minX, minX, minY, minY, tempTileRange);
      }

      const maxX = Math.floor(factor * (tileCoordX + 1)) - 1;
      const maxY = Math.floor(factor * (tileCoordY + 1)) - 1;
      return (0,_TileRange_js__WEBPACK_IMPORTED_MODULE_4__.createOrUpdate)(minX, maxX, minY, maxY, tempTileRange);
    }

    const tileCoordExtent = this.getTileCoordExtent(tileCoord, this.tmpExtent_);
    return this.getTileRangeForExtentAndZ(tileCoordExtent, z, tempTileRange);
  }

  /**
   * Get a tile range for the given extent and integer zoom level.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} z Integer zoom level.
   * @param {import("../TileRange.js").default} [tempTileRange] Temporary tile range object.
   * @return {import("../TileRange.js").default} Tile range.
   */
  getTileRangeForExtentAndZ(extent, z, tempTileRange) {
    this.getTileCoordForXYAndZ_(extent[0], extent[3], z, false, tmpTileCoord);
    const minX = tmpTileCoord[1];
    const minY = tmpTileCoord[2];
    this.getTileCoordForXYAndZ_(extent[2], extent[1], z, true, tmpTileCoord);
    const maxX = tmpTileCoord[1];
    const maxY = tmpTileCoord[2];
    return (0,_TileRange_js__WEBPACK_IMPORTED_MODULE_4__.createOrUpdate)(minX, maxX, minY, maxY, tempTileRange);
  }

  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @return {import("../coordinate.js").Coordinate} Tile center.
   */
  getTileCoordCenter(tileCoord) {
    const origin = this.getOrigin(tileCoord[0]);
    const resolution = this.getResolution(tileCoord[0]);
    const tileSize = (0,_size_js__WEBPACK_IMPORTED_MODULE_5__.toSize)(this.getTileSize(tileCoord[0]), this.tmpSize_);
    return [
      origin[0] + (tileCoord[1] + 0.5) * tileSize[0] * resolution,
      origin[1] - (tileCoord[2] + 0.5) * tileSize[1] * resolution,
    ];
  }

  /**
   * Get the extent of a tile coordinate.
   *
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("../extent.js").Extent} [tempExtent] Temporary extent object.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */
  getTileCoordExtent(tileCoord, tempExtent) {
    const origin = this.getOrigin(tileCoord[0]);
    const resolution = this.getResolution(tileCoord[0]);
    const tileSize = (0,_size_js__WEBPACK_IMPORTED_MODULE_5__.toSize)(this.getTileSize(tileCoord[0]), this.tmpSize_);
    const minX = origin[0] + tileCoord[1] * tileSize[0] * resolution;
    const minY = origin[1] - (tileCoord[2] + 1) * tileSize[1] * resolution;
    const maxX = minX + tileSize[0] * resolution;
    const maxY = minY + tileSize[1] * resolution;
    return (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.createOrUpdate)(minX, minY, maxX, maxY, tempExtent);
  }

  /**
   * Get the tile coordinate for the given map coordinate and resolution.  This
   * method considers that coordinates that intersect tile boundaries should be
   * assigned the higher tile coordinate.
   *
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {number} resolution Resolution.
   * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Destination import("../tilecoord.js").TileCoord object.
   * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
   * @api
   */
  getTileCoordForCoordAndResolution(coordinate, resolution, opt_tileCoord) {
    return this.getTileCoordForXYAndResolution_(
      coordinate[0],
      coordinate[1],
      resolution,
      false,
      opt_tileCoord
    );
  }

  /**
   * Note that this method should not be called for resolutions that correspond
   * to an integer zoom level.  Instead call the `getTileCoordForXYAndZ_` method.
   * @param {number} x X.
   * @param {number} y Y.
   * @param {number} resolution Resolution (for a non-integer zoom level).
   * @param {boolean} reverseIntersectionPolicy Instead of letting edge
   *     intersections go to the higher tile coordinate, let edge intersections
   *     go to the lower tile coordinate.
   * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Temporary import("../tilecoord.js").TileCoord object.
   * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
   * @private
   */
  getTileCoordForXYAndResolution_(
    x,
    y,
    resolution,
    reverseIntersectionPolicy,
    opt_tileCoord
  ) {
    const z = this.getZForResolution(resolution);
    const scale = resolution / this.getResolution(z);
    const origin = this.getOrigin(z);
    const tileSize = (0,_size_js__WEBPACK_IMPORTED_MODULE_5__.toSize)(this.getTileSize(z), this.tmpSize_);

    let tileCoordX = (scale * (x - origin[0])) / resolution / tileSize[0];
    let tileCoordY = (scale * (origin[1] - y)) / resolution / tileSize[1];

    if (reverseIntersectionPolicy) {
      tileCoordX = (0,_math_js__WEBPACK_IMPORTED_MODULE_6__.ceil)(tileCoordX, DECIMALS) - 1;
      tileCoordY = (0,_math_js__WEBPACK_IMPORTED_MODULE_6__.ceil)(tileCoordY, DECIMALS) - 1;
    } else {
      tileCoordX = (0,_math_js__WEBPACK_IMPORTED_MODULE_6__.floor)(tileCoordX, DECIMALS);
      tileCoordY = (0,_math_js__WEBPACK_IMPORTED_MODULE_6__.floor)(tileCoordY, DECIMALS);
    }

    return (0,_tilecoord_js__WEBPACK_IMPORTED_MODULE_7__.createOrUpdate)(z, tileCoordX, tileCoordY, opt_tileCoord);
  }

  /**
   * Although there is repetition between this method and `getTileCoordForXYAndResolution_`,
   * they should have separate implementations.  This method is for integer zoom
   * levels.  The other method should only be called for resolutions corresponding
   * to non-integer zoom levels.
   * @param {number} x Map x coordinate.
   * @param {number} y Map y coordinate.
   * @param {number} z Integer zoom level.
   * @param {boolean} reverseIntersectionPolicy Instead of letting edge
   *     intersections go to the higher tile coordinate, let edge intersections
   *     go to the lower tile coordinate.
   * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Temporary import("../tilecoord.js").TileCoord object.
   * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
   * @private
   */
  getTileCoordForXYAndZ_(x, y, z, reverseIntersectionPolicy, opt_tileCoord) {
    const origin = this.getOrigin(z);
    const resolution = this.getResolution(z);
    const tileSize = (0,_size_js__WEBPACK_IMPORTED_MODULE_5__.toSize)(this.getTileSize(z), this.tmpSize_);

    let tileCoordX = (x - origin[0]) / resolution / tileSize[0];
    let tileCoordY = (origin[1] - y) / resolution / tileSize[1];

    if (reverseIntersectionPolicy) {
      tileCoordX = (0,_math_js__WEBPACK_IMPORTED_MODULE_6__.ceil)(tileCoordX, DECIMALS) - 1;
      tileCoordY = (0,_math_js__WEBPACK_IMPORTED_MODULE_6__.ceil)(tileCoordY, DECIMALS) - 1;
    } else {
      tileCoordX = (0,_math_js__WEBPACK_IMPORTED_MODULE_6__.floor)(tileCoordX, DECIMALS);
      tileCoordY = (0,_math_js__WEBPACK_IMPORTED_MODULE_6__.floor)(tileCoordY, DECIMALS);
    }

    return (0,_tilecoord_js__WEBPACK_IMPORTED_MODULE_7__.createOrUpdate)(z, tileCoordX, tileCoordY, opt_tileCoord);
  }

  /**
   * Get a tile coordinate given a map coordinate and zoom level.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {number} z Zoom level.
   * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Destination import("../tilecoord.js").TileCoord object.
   * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
   * @api
   */
  getTileCoordForCoordAndZ(coordinate, z, opt_tileCoord) {
    return this.getTileCoordForXYAndZ_(
      coordinate[0],
      coordinate[1],
      z,
      false,
      opt_tileCoord
    );
  }

  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @return {number} Tile resolution.
   */
  getTileCoordResolution(tileCoord) {
    return this.resolutions_[tileCoord[0]];
  }

  /**
   * Get the tile size for a zoom level. The type of the return value matches the
   * `tileSize` or `tileSizes` that the tile grid was configured with. To always
   * get an {@link import("../size.js").Size}, run the result through {@link module:ol/size.toSize}.
   * @param {number} z Z.
   * @return {number|import("../size.js").Size} Tile size.
   * @api
   */
  getTileSize(z) {
    if (this.tileSize_) {
      return this.tileSize_;
    }
    return this.tileSizes_[z];
  }

  /**
   * @param {number} z Zoom level.
   * @return {import("../TileRange.js").default} Extent tile range for the specified zoom level.
   */
  getFullTileRange(z) {
    if (!this.fullTileRanges_) {
      return this.extent_
        ? this.getTileRangeForExtentAndZ(this.extent_, z)
        : null;
    }
    return this.fullTileRanges_[z];
  }

  /**
   * @param {number} resolution Resolution.
   * @param {number|import("../array.js").NearestDirectionFunction} [opt_direction]
   *     If 0, the nearest resolution will be used.
   *     If 1, the nearest higher resolution (lower Z) will be used. If -1, the
   *     nearest lower resolution (higher Z) will be used. Default is 0.
   *     Use a {@link module:ol/array~NearestDirectionFunction} for more precise control.
   *
   * For example to change tile Z at the midpoint of zoom levels
   * ```js
   * function(value, high, low) {
   *   return value - low * Math.sqrt(high / low);
   * }
   * ```
   * @return {number} Z.
   * @api
   */
  getZForResolution(resolution, opt_direction) {
    const z = (0,_array_js__WEBPACK_IMPORTED_MODULE_1__.linearFindNearest)(
      this.resolutions_,
      resolution,
      opt_direction || 0
    );
    return (0,_math_js__WEBPACK_IMPORTED_MODULE_6__.clamp)(z, this.minZoom, this.maxZoom);
  }

  /**
   * The tile with the provided tile coordinate intersects the given viewport.
   * @param {import('../tilecoord.js').TileCoord} tileCoord Tile coordinate.
   * @param {Array<number>} viewport Viewport as returned from {@link module:ol/extent.getRotatedViewport}.
   * @return {boolean} The tile with the provided tile coordinate intersects the given viewport.
   */
  tileCoordIntersectsViewport(tileCoord, viewport) {
    return (0,_geom_flat_intersectsextent_js__WEBPACK_IMPORTED_MODULE_8__.intersectsLinearRing)(
      viewport,
      0,
      viewport.length,
      2,
      this.getTileCoordExtent(tileCoord)
    );
  }

  /**
   * @param {!import("../extent.js").Extent} extent Extent for this tile grid.
   * @private
   */
  calculateTileRanges_(extent) {
    const length = this.resolutions_.length;
    const fullTileRanges = new Array(length);
    for (let z = this.minZoom; z < length; ++z) {
      fullTileRanges[z] = this.getTileRangeForExtentAndZ(extent, z);
    }
    this.fullTileRanges_ = fullTileRanges;
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (TileGrid);


/***/ }),

/***/ "./node_modules/ol/tilegrid/common.js":
/*!********************************************!*\
  !*** ./node_modules/ol/tilegrid/common.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DEFAULT_MAX_ZOOM: () => (/* binding */ DEFAULT_MAX_ZOOM),
/* harmony export */   DEFAULT_TILE_SIZE: () => (/* binding */ DEFAULT_TILE_SIZE)
/* harmony export */ });
/**
 * @module ol/tilegrid/common
 */

/**
 * Default maximum zoom for default tile grids.
 * @type {number}
 */
const DEFAULT_MAX_ZOOM = 42;

/**
 * Default tile size.
 * @type {number}
 */
const DEFAULT_TILE_SIZE = 256;


/***/ }),

/***/ "./node_modules/ol/tileurlfunction.js":
/*!********************************************!*\
  !*** ./node_modules/ol/tileurlfunction.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createFromTemplate: () => (/* binding */ createFromTemplate),
/* harmony export */   createFromTemplates: () => (/* binding */ createFromTemplates),
/* harmony export */   createFromTileUrlFunctions: () => (/* binding */ createFromTileUrlFunctions),
/* harmony export */   expandUrl: () => (/* binding */ expandUrl),
/* harmony export */   nullTileUrlFunction: () => (/* binding */ nullTileUrlFunction)
/* harmony export */ });
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./asserts.js */ "./node_modules/ol/asserts.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./math.js */ "./node_modules/ol/math.js");
/* harmony import */ var _tilecoord_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./tilecoord.js */ "./node_modules/ol/tilecoord.js");
/**
 * @module ol/tileurlfunction
 */




/**
 * @param {string} template Template.
 * @param {import("./tilegrid/TileGrid.js").default} tileGrid Tile grid.
 * @return {import("./Tile.js").UrlFunction} Tile URL function.
 */
function createFromTemplate(template, tileGrid) {
  const zRegEx = /\{z\}/g;
  const xRegEx = /\{x\}/g;
  const yRegEx = /\{y\}/g;
  const dashYRegEx = /\{-y\}/g;
  return (
    /**
     * @param {import("./tilecoord.js").TileCoord} tileCoord Tile Coordinate.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("./proj/Projection.js").default} projection Projection.
     * @return {string|undefined} Tile URL.
     */
    function (tileCoord, pixelRatio, projection) {
      if (!tileCoord) {
        return undefined;
      }
      return template
        .replace(zRegEx, tileCoord[0].toString())
        .replace(xRegEx, tileCoord[1].toString())
        .replace(yRegEx, tileCoord[2].toString())
        .replace(dashYRegEx, function () {
          const z = tileCoord[0];
          const range = tileGrid.getFullTileRange(z);
          (0,_asserts_js__WEBPACK_IMPORTED_MODULE_0__.assert)(
            range,
            'The {-y} placeholder requires a tile grid with extent'
          );
          const y = range.getHeight() - tileCoord[2] - 1;
          return y.toString();
        });
    }
  );
}

/**
 * @param {Array<string>} templates Templates.
 * @param {import("./tilegrid/TileGrid.js").default} tileGrid Tile grid.
 * @return {import("./Tile.js").UrlFunction} Tile URL function.
 */
function createFromTemplates(templates, tileGrid) {
  const len = templates.length;
  const tileUrlFunctions = new Array(len);
  for (let i = 0; i < len; ++i) {
    tileUrlFunctions[i] = createFromTemplate(templates[i], tileGrid);
  }
  return createFromTileUrlFunctions(tileUrlFunctions);
}

/**
 * @param {Array<import("./Tile.js").UrlFunction>} tileUrlFunctions Tile URL Functions.
 * @return {import("./Tile.js").UrlFunction} Tile URL function.
 */
function createFromTileUrlFunctions(tileUrlFunctions) {
  if (tileUrlFunctions.length === 1) {
    return tileUrlFunctions[0];
  }
  return (
    /**
     * @param {import("./tilecoord.js").TileCoord} tileCoord Tile Coordinate.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("./proj/Projection.js").default} projection Projection.
     * @return {string|undefined} Tile URL.
     */
    function (tileCoord, pixelRatio, projection) {
      if (!tileCoord) {
        return undefined;
      }
      const h = (0,_tilecoord_js__WEBPACK_IMPORTED_MODULE_1__.hash)(tileCoord);
      const index = (0,_math_js__WEBPACK_IMPORTED_MODULE_2__.modulo)(h, tileUrlFunctions.length);
      return tileUrlFunctions[index](tileCoord, pixelRatio, projection);
    }
  );
}

/**
 * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
 * @param {number} pixelRatio Pixel ratio.
 * @param {import("./proj/Projection.js").default} projection Projection.
 * @return {string|undefined} Tile URL.
 */
function nullTileUrlFunction(tileCoord, pixelRatio, projection) {
  return undefined;
}

/**
 * @param {string} url URL.
 * @return {Array<string>} Array of urls.
 */
function expandUrl(url) {
  const urls = [];
  let match = /\{([a-z])-([a-z])\}/.exec(url);
  if (match) {
    // char range
    const startCharCode = match[1].charCodeAt(0);
    const stopCharCode = match[2].charCodeAt(0);
    let charCode;
    for (charCode = startCharCode; charCode <= stopCharCode; ++charCode) {
      urls.push(url.replace(match[0], String.fromCharCode(charCode)));
    }
    return urls;
  }
  match = /\{(\d+)-(\d+)\}/.exec(url);
  if (match) {
    // number range
    const stop = parseInt(match[2], 10);
    for (let i = parseInt(match[1], 10); i <= stop; i++) {
      urls.push(url.replace(match[0], i.toString()));
    }
    return urls;
  }
  urls.push(url);
  return urls;
}


/***/ }),

/***/ "./node_modules/ol/transform.js":
/*!**************************************!*\
  !*** ./node_modules/ol/transform.js ***!
  \**************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   apply: () => (/* binding */ apply),
/* harmony export */   compose: () => (/* binding */ compose),
/* harmony export */   composeCssTransform: () => (/* binding */ composeCssTransform),
/* harmony export */   create: () => (/* binding */ create),
/* harmony export */   determinant: () => (/* binding */ determinant),
/* harmony export */   invert: () => (/* binding */ invert),
/* harmony export */   makeInverse: () => (/* binding */ makeInverse),
/* harmony export */   makeScale: () => (/* binding */ makeScale),
/* harmony export */   multiply: () => (/* binding */ multiply),
/* harmony export */   reset: () => (/* binding */ reset),
/* harmony export */   rotate: () => (/* binding */ rotate),
/* harmony export */   scale: () => (/* binding */ scale),
/* harmony export */   set: () => (/* binding */ set),
/* harmony export */   setFromArray: () => (/* binding */ setFromArray),
/* harmony export */   toString: () => (/* binding */ toString),
/* harmony export */   translate: () => (/* binding */ translate)
/* harmony export */ });
/* harmony import */ var _has_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./has.js */ "./node_modules/ol/has.js");
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./asserts.js */ "./node_modules/ol/asserts.js");
/**
 * @module ol/transform
 */



/**
 * An array representing an affine 2d transformation for use with
 * {@link module:ol/transform} functions. The array has 6 elements.
 * @typedef {!Array<number>} Transform
 * @api
 */

/**
 * Collection of affine 2d transformation functions. The functions work on an
 * array of 6 elements. The element order is compatible with the [SVGMatrix
 * interface](https://developer.mozilla.org/en-US/docs/Web/API/SVGMatrix) and is
 * a subset (elements a to f) of a 3×3 matrix:
 * ```
 * [ a c e ]
 * [ b d f ]
 * [ 0 0 1 ]
 * ```
 */

/**
 * @private
 * @type {Transform}
 */
const tmp_ = new Array(6);

/**
 * Create an identity transform.
 * @return {!Transform} Identity transform.
 */
function create() {
  return [1, 0, 0, 1, 0, 0];
}

/**
 * Resets the given transform to an identity transform.
 * @param {!Transform} transform Transform.
 * @return {!Transform} Transform.
 */
function reset(transform) {
  return set(transform, 1, 0, 0, 1, 0, 0);
}

/**
 * Multiply the underlying matrices of two transforms and return the result in
 * the first transform.
 * @param {!Transform} transform1 Transform parameters of matrix 1.
 * @param {!Transform} transform2 Transform parameters of matrix 2.
 * @return {!Transform} transform1 multiplied with transform2.
 */
function multiply(transform1, transform2) {
  const a1 = transform1[0];
  const b1 = transform1[1];
  const c1 = transform1[2];
  const d1 = transform1[3];
  const e1 = transform1[4];
  const f1 = transform1[5];
  const a2 = transform2[0];
  const b2 = transform2[1];
  const c2 = transform2[2];
  const d2 = transform2[3];
  const e2 = transform2[4];
  const f2 = transform2[5];

  transform1[0] = a1 * a2 + c1 * b2;
  transform1[1] = b1 * a2 + d1 * b2;
  transform1[2] = a1 * c2 + c1 * d2;
  transform1[3] = b1 * c2 + d1 * d2;
  transform1[4] = a1 * e2 + c1 * f2 + e1;
  transform1[5] = b1 * e2 + d1 * f2 + f1;

  return transform1;
}

/**
 * Set the transform components a-f on a given transform.
 * @param {!Transform} transform Transform.
 * @param {number} a The a component of the transform.
 * @param {number} b The b component of the transform.
 * @param {number} c The c component of the transform.
 * @param {number} d The d component of the transform.
 * @param {number} e The e component of the transform.
 * @param {number} f The f component of the transform.
 * @return {!Transform} Matrix with transform applied.
 */
function set(transform, a, b, c, d, e, f) {
  transform[0] = a;
  transform[1] = b;
  transform[2] = c;
  transform[3] = d;
  transform[4] = e;
  transform[5] = f;
  return transform;
}

/**
 * Set transform on one matrix from another matrix.
 * @param {!Transform} transform1 Matrix to set transform to.
 * @param {!Transform} transform2 Matrix to set transform from.
 * @return {!Transform} transform1 with transform from transform2 applied.
 */
function setFromArray(transform1, transform2) {
  transform1[0] = transform2[0];
  transform1[1] = transform2[1];
  transform1[2] = transform2[2];
  transform1[3] = transform2[3];
  transform1[4] = transform2[4];
  transform1[5] = transform2[5];
  return transform1;
}

/**
 * Transforms the given coordinate with the given transform returning the
 * resulting, transformed coordinate. The coordinate will be modified in-place.
 *
 * @param {Transform} transform The transformation.
 * @param {import("./coordinate.js").Coordinate|import("./pixel.js").Pixel} coordinate The coordinate to transform.
 * @return {import("./coordinate.js").Coordinate|import("./pixel.js").Pixel} return coordinate so that operations can be
 *     chained together.
 */
function apply(transform, coordinate) {
  const x = coordinate[0];
  const y = coordinate[1];
  coordinate[0] = transform[0] * x + transform[2] * y + transform[4];
  coordinate[1] = transform[1] * x + transform[3] * y + transform[5];
  return coordinate;
}

/**
 * Applies rotation to the given transform.
 * @param {!Transform} transform Transform.
 * @param {number} angle Angle in radians.
 * @return {!Transform} The rotated transform.
 */
function rotate(transform, angle) {
  const cos = Math.cos(angle);
  const sin = Math.sin(angle);
  return multiply(transform, set(tmp_, cos, sin, -sin, cos, 0, 0));
}

/**
 * Applies scale to a given transform.
 * @param {!Transform} transform Transform.
 * @param {number} x Scale factor x.
 * @param {number} y Scale factor y.
 * @return {!Transform} The scaled transform.
 */
function scale(transform, x, y) {
  return multiply(transform, set(tmp_, x, 0, 0, y, 0, 0));
}

/**
 * Creates a scale transform.
 * @param {!Transform} target Transform to overwrite.
 * @param {number} x Scale factor x.
 * @param {number} y Scale factor y.
 * @return {!Transform} The scale transform.
 */
function makeScale(target, x, y) {
  return set(target, x, 0, 0, y, 0, 0);
}

/**
 * Applies translation to the given transform.
 * @param {!Transform} transform Transform.
 * @param {number} dx Translation x.
 * @param {number} dy Translation y.
 * @return {!Transform} The translated transform.
 */
function translate(transform, dx, dy) {
  return multiply(transform, set(tmp_, 1, 0, 0, 1, dx, dy));
}

/**
 * Creates a composite transform given an initial translation, scale, rotation, and
 * final translation (in that order only, not commutative).
 * @param {!Transform} transform The transform (will be modified in place).
 * @param {number} dx1 Initial translation x.
 * @param {number} dy1 Initial translation y.
 * @param {number} sx Scale factor x.
 * @param {number} sy Scale factor y.
 * @param {number} angle Rotation (in counter-clockwise radians).
 * @param {number} dx2 Final translation x.
 * @param {number} dy2 Final translation y.
 * @return {!Transform} The composite transform.
 */
function compose(transform, dx1, dy1, sx, sy, angle, dx2, dy2) {
  const sin = Math.sin(angle);
  const cos = Math.cos(angle);
  transform[0] = sx * cos;
  transform[1] = sy * sin;
  transform[2] = -sx * sin;
  transform[3] = sy * cos;
  transform[4] = dx2 * sx * cos - dy2 * sx * sin + dx1;
  transform[5] = dx2 * sy * sin + dy2 * sy * cos + dy1;
  return transform;
}

/**
 * Creates a composite transform given an initial translation, scale, rotation, and
 * final translation (in that order only, not commutative). The resulting transform
 * string can be applied as `transform` property of an HTMLElement's style.
 * @param {number} dx1 Initial translation x.
 * @param {number} dy1 Initial translation y.
 * @param {number} sx Scale factor x.
 * @param {number} sy Scale factor y.
 * @param {number} angle Rotation (in counter-clockwise radians).
 * @param {number} dx2 Final translation x.
 * @param {number} dy2 Final translation y.
 * @return {string} The composite css transform.
 * @api
 */
function composeCssTransform(dx1, dy1, sx, sy, angle, dx2, dy2) {
  return toString(compose(create(), dx1, dy1, sx, sy, angle, dx2, dy2));
}

/**
 * Invert the given transform.
 * @param {!Transform} source The source transform to invert.
 * @return {!Transform} The inverted (source) transform.
 */
function invert(source) {
  return makeInverse(source, source);
}

/**
 * Invert the given transform.
 * @param {!Transform} target Transform to be set as the inverse of
 *     the source transform.
 * @param {!Transform} source The source transform to invert.
 * @return {!Transform} The inverted (target) transform.
 */
function makeInverse(target, source) {
  const det = determinant(source);
  (0,_asserts_js__WEBPACK_IMPORTED_MODULE_0__.assert)(det !== 0, 'Transformation matrix cannot be inverted');

  const a = source[0];
  const b = source[1];
  const c = source[2];
  const d = source[3];
  const e = source[4];
  const f = source[5];

  target[0] = d / det;
  target[1] = -b / det;
  target[2] = -c / det;
  target[3] = a / det;
  target[4] = (c * f - d * e) / det;
  target[5] = -(a * f - b * e) / det;

  return target;
}

/**
 * Returns the determinant of the given matrix.
 * @param {!Transform} mat Matrix.
 * @return {number} Determinant.
 */
function determinant(mat) {
  return mat[0] * mat[3] - mat[1] * mat[2];
}

/**
 * @type {HTMLElement}
 * @private
 */
let transformStringDiv;

/**
 * A rounded string version of the transform.  This can be used
 * for CSS transforms.
 * @param {!Transform} mat Matrix.
 * @return {string} The transform as a string.
 */
function toString(mat) {
  const transformString = 'matrix(' + mat.join(', ') + ')';
  if (_has_js__WEBPACK_IMPORTED_MODULE_1__.WORKER_OFFSCREEN_CANVAS) {
    return transformString;
  }
  const node =
    transformStringDiv || (transformStringDiv = document.createElement('div'));
  node.style.transform = transformString;
  return node.style.transform;
}


/***/ }),

/***/ "./node_modules/ol/util.js":
/*!*********************************!*\
  !*** ./node_modules/ol/util.js ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   VERSION: () => (/* binding */ VERSION),
/* harmony export */   abstract: () => (/* binding */ abstract),
/* harmony export */   getUid: () => (/* binding */ getUid)
/* harmony export */ });
/**
 * @module ol/util
 */

/**
 * @return {never} Any return.
 */
function abstract() {
  throw new Error('Unimplemented abstract method.');
}

/**
 * Counter for getUid.
 * @type {number}
 * @private
 */
let uidCounter_ = 0;

/**
 * Gets a unique ID for an object. This mutates the object so that further calls
 * with the same object as a parameter returns the same value. Unique IDs are generated
 * as a strictly increasing sequence. Adapted from goog.getUid.
 *
 * @param {Object} obj The object to get the unique ID for.
 * @return {string} The unique ID for the object.
 * @api
 */
function getUid(obj) {
  return obj.ol_uid || (obj.ol_uid = String(++uidCounter_));
}

/**
 * OpenLayers version.
 * @type {string}
 */
const VERSION = '8.0.0';


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
/*!*********************!*\
  !*** ./src/main.js ***!
  \*********************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var ol_format_GeoJSON_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ol/format/GeoJSON.js */ "./node_modules/ol/format/GeoJSON.js");
/* harmony import */ var ol_Map_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ol/Map.js */ "./node_modules/ol/Map.js");
/* harmony import */ var ol_View_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ol/View.js */ "./node_modules/ol/View.js");
/* harmony import */ var ol_style_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ol/style.js */ "./node_modules/ol/style/Text.js");
/* harmony import */ var ol_style_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ol/style.js */ "./node_modules/ol/style/Style.js");
/* harmony import */ var ol_style_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ol/style.js */ "./node_modules/ol/style/Stroke.js");
/* harmony import */ var ol_style_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ol/style.js */ "./node_modules/ol/style/Fill.js");
/* harmony import */ var ol_source_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ol/source.js */ "./node_modules/ol/source/Vector.js");
/* harmony import */ var ol_source_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ol/source.js */ "./node_modules/ol/source/OSM.js");
/* harmony import */ var ol_layer_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ol/layer.js */ "./node_modules/ol/layer/Vector.js");
/* harmony import */ var ol_layer_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ol/layer.js */ "./node_modules/ol/layer/Tile.js");
/* harmony import */ var ol_Feature_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ol/Feature.js */ "./node_modules/ol/Feature.js");
/* harmony import */ var ol_proj__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ol/proj */ "./node_modules/ol/proj.js");
/* harmony import */ var ol_geom__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ol/geom */ "./node_modules/ol/geom/Circle.js");
/* harmony import */ var _data_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./data.js */ "./src/data.js");









//import { Tooltip } from 'bootstrap';



const getText = function(feature) {
  return feature.get('name');
};

const createTextStyle = function(feature) {

  return new ol_style_js__WEBPACK_IMPORTED_MODULE_2__["default"]({      
    text: getText(feature),
    font : "bold 10px/1 Verdana" ,
    overflow : true      
  });
}

const styleFunction = function(feature) {
  console.log(feature.getGeometry().getType());
    return new ol_style_js__WEBPACK_IMPORTED_MODULE_3__["default"]({
        stroke: new ol_style_js__WEBPACK_IMPORTED_MODULE_4__["default"]({
          color: 'blue',
          lineDash: [],
          width: 1,
        }),
        fill: new ol_style_js__WEBPACK_IMPORTED_MODULE_5__["default"]({
          color: 'rgba(0, 0, 255, 0.1)',
        }),
        text : createTextStyle(feature)
      });

};

const features = new ol_format_GeoJSON_js__WEBPACK_IMPORTED_MODULE_6__["default"]({
  dataProjection: 'EPSG:4326',
  featureProjection: 'EPSG:3857'
}).readFeatures(_data_js__WEBPACK_IMPORTED_MODULE_1__["default"]);

const vectorSource = new ol_source_js__WEBPACK_IMPORTED_MODULE_7__["default"]({
    features: features,
  });
  


vectorSource.addFeature(new ol_Feature_js__WEBPACK_IMPORTED_MODULE_8__["default"](new ol_geom__WEBPACK_IMPORTED_MODULE_9__["default"]([5e6, 7e6], 1e6)));      
  
const vectorLayer = new ol_layer_js__WEBPACK_IMPORTED_MODULE_10__["default"]({
    source: vectorSource,
    style: styleFunction
  });

var raster = new ol_layer_js__WEBPACK_IMPORTED_MODULE_11__["default"]({
    source: new ol_source_js__WEBPACK_IMPORTED_MODULE_12__["default"]()
    });


const fillTable = function() {
    document.getElementById('header');

}

window.onload = function(e){ 

  const info = document.getElementById('info');
info.style.pointerEvents = 'none';
/*
const tooltip = new bootstrap.Tooltip(info, {
  animation: false,
  customClass: 'pe-none',
  offset: [0, 0],
  title: '-',
  trigger: 'manual',
});
*/

var map = new ol_Map_js__WEBPACK_IMPORTED_MODULE_13__["default"]({
  layers: [raster,vectorLayer],
  target: document.getElementById('map'),
  view: new ol_View_js__WEBPACK_IMPORTED_MODULE_14__["default"]({
  center: (0,ol_proj__WEBPACK_IMPORTED_MODULE_0__.fromLonLat)([0.1086709, 52.2507585]),
  zoom: 13
  })
});

  let currentFeature;
  const displayFeatureInfo = function (pixel, target) {
    const feature = target.closest('.ol-control')
      ? undefined
      : map.forEachFeatureAtPixel(pixel, function (feature) {
          return feature;
        });
    if (feature) {
      info.style.left = pixel[0] + 'px';
      info.style.top = pixel[1] + 'px';
      if (feature !== currentFeature) {
        tooltip.setContent({'.tooltip-inner': feature.get('name')});
      }
      if (currentFeature) {
        tooltip.update();
      } else {
        tooltip.show();
      }
    } else {
      tooltip.hide();
    }
    currentFeature = feature;
  };

  map.on('pointermove', function (evt) {
    if (evt.dragging) {
      tooltip.hide();
      currentFeature = undefined;
      return;
    }
    const pixel = map.getEventPixel(evt.originalEvent);
    //console.log('pixel', pixel[0], ' ', pixel[1]);
    //displayFeatureInfo(pixel, evt.originalEvent.target);
  });

  map.on('click', function (evt) {
    //displayFeatureInfo(evt.pixel, evt.originalEvent.target);
  });

  map.getTargetElement().addEventListener('pointerleave', function () {
    //tooltip.hide();
    currentFeature = undefined;
  });

  fillTable();
}

})();

/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSx1REFBa0I7O0FBRTVCO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLHVDQUF1QyxxREFBZTs7QUFFdEQ7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLHVDQUF1QyxxREFBZTs7QUFFdEQ7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7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QTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSx1RUFBdUU7QUFDcEYsYUFBYSx3Q0FBd0M7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sdURBQWlCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sdURBQWlCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSw0RUFBNEU7QUFDekYsYUFBYSx3Q0FBd0M7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sdURBQWlCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sdURBQWlCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYyxpREFBaUQ7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLHdDQUF3QztBQUNyRCxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUVBQWUsa0JBQWtCLEVBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM5UWxDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFZ0Q7QUFDRDtBQUluQjtBQWFOO0FBQ2dCO0FBQ0s7QUFDTDtBQUNtQjtBQUNJOztBQUU3RDtBQUNBO0FBQ0EsMkJBQTJCLG9EQUFvRDtBQUMvRTtBQUNBO0FBQ0E7QUFDQSxJQUFJLDBDQUEwQztBQUM5QztBQUNBO0FBQ0Esc0NBQXNDLHlEQUFhO0FBQ25EO0FBQ0EsYUFBYSwwQkFBMEI7QUFDdkMsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsa0NBQWtDO0FBQy9DLGFBQWEsd0NBQXdDO0FBQ3JELGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSwyQ0FBMkM7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsUUFBUSxpREFBTztBQUNmOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLDhCQUE4QixxREFBZTtBQUM3Qzs7QUFFQTtBQUNBLGFBQWEsZUFBZTtBQUM1QixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsb0VBQVc7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxRQUFRO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsc0RBQWdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLGVBQWU7QUFDNUIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsb0VBQVc7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsZUFBZTtBQUM1QixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFNBQVM7QUFDdEI7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLG9FQUFXO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixZQUFZO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxlQUFlO0FBQzVCLGFBQWEsUUFBUTtBQUNyQixhQUFhLGVBQWU7QUFDNUIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQSxzQ0FBc0MsUUFBUTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsd0NBQXdDO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHdDQUF3QztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLHNEQUFVO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQix3RUFBZTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHdDQUF3QztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsd0NBQXdDO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNLDhGQUE4RjtBQUNwRztBQUNBLGFBQWEsMEVBQTBFO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHVDQUF1QztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiw0Q0FBNEM7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIseUNBQXlDO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDRDQUE0QztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixpREFBaUQ7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDhDQUE4QztBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixvREFBb0Q7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHdDQUF3QztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSwwQ0FBMEM7QUFDaEQ7QUFDQSxhQUFhLG9DQUFvQztBQUNqRCxhQUFhLHdDQUF3QztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsb0RBQW9EO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsdUVBQXVFO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix1Q0FBdUM7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSw0RUFBNEU7QUFDekY7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDRDQUE0QztBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLDRFQUE0RTtBQUN6RjtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsNENBQTRDO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsc0RBQVU7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxpRkFBaUY7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsaURBQWlEO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxzREFBVTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixlQUFlO0FBQzdDO0FBQ0E7QUFDQSx3Q0FBd0MsUUFBUTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHlFQUF5RTtBQUN0RjtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIseUNBQXlDO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsc0RBQVU7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixlQUFlO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSw4Q0FBOEM7QUFDM0Q7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDhDQUE4QztBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLHNEQUFVO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxRQUFRO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsa0NBQWtDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsb0NBQW9DO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpREFBTTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxrQ0FBa0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHdEQUFnQjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsdUNBQXVDO0FBQ3BELGFBQWEseUNBQXlDO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxtQkFBbUIsMERBQVc7QUFDOUIsNENBQTRDLHdEQUFnQjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsdURBQWU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHNEQUFjO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyw2REFBcUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0EsY0FBYyx1REFBZTtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxjQUFjLHdEQUFnQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQSxjQUFjLHlEQUFpQjtBQUMvQixxQkFBcUIsMERBQVc7QUFDaEMsZ0RBQWdELDBEQUFrQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsd0NBQXdDO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHVDQUF1QztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLHFCQUFxQiwwREFBVztBQUNoQyxzREFBc0Qsd0RBQWdCO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isc0RBQWM7QUFDOUI7QUFDQTtBQUNBLGNBQWMsdURBQWU7QUFDN0I7QUFDQTtBQUNBLGNBQWMsNkRBQXFCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix1REFBZTtBQUMvQjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isd0RBQWdCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix5REFBaUI7QUFDakMsdUJBQXVCLDBEQUFXO0FBQ2xDLDBEQUEwRCwwREFBa0I7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsbURBQVc7QUFDN0Q7QUFDQSx3REFBd0Qsd0RBQWdCO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBLGNBQWMsMkRBQW1CO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpRUFBZSx1QkFBdUIsRUFBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMzcEN2QztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDTzs7QUFFUDtBQUNBLFVBQVU7QUFDVjtBQUNPOztBQUVQO0FBQ0EsVUFBVTtBQUNWO0FBQ087O0FBRVA7QUFDQSxVQUFVO0FBQ1Y7QUFDTzs7QUFFUCxpRUFBZSxXQUFXLEVBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMzQzNCO0FBQ0E7QUFDQTtBQUN5QztBQUlmO0FBQzBDOztBQUVwRSxzQ0FBc0MsbURBQWE7QUFDbkQ7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxrQ0FBa0M7QUFDL0MsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsZUFBZTtBQUM1QixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLHVEQUFpQjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsNEVBQTRFO0FBQ3pGLGFBQWEsd0NBQXdDO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsdURBQWlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHVEQUFlO0FBQ3ZCLFFBQVEsNkRBQXFCO0FBQzdCO0FBQ0EsTUFBTSxpRUFBb0I7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLDhEQUFpQjtBQUN4RDtBQUNBOztBQUVBO0FBQ0EsYUFBYSxpRkFBaUY7QUFDOUYsYUFBYSx3Q0FBd0M7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx1REFBaUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsdURBQWU7QUFDdkIsUUFBUSw2REFBcUI7QUFDN0I7QUFDQSxNQUFNLGlFQUFvQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFFBQVE7QUFDOUM7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLDhEQUFpQjtBQUN4RDtBQUNBOztBQUVBO0FBQ0EsY0FBYyxpREFBaUQ7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsOERBQWlCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLHdDQUF3QztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsOERBQWlCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGlFQUFvQjtBQUMvQztBQUNBOztBQUVBLGlFQUFlLHVCQUF1QixFQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2xLdkM7QUFDQTtBQUNBO0FBQ3lDO0FBTWY7QUFLSjtBQUMyQjs7QUFFakQsbUNBQW1DLG1EQUFhO0FBQ2hEO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsa0NBQWtDO0FBQy9DLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLGVBQWU7QUFDNUIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsZUFBZTtBQUM1QixhQUFhLFFBQVE7QUFDckI7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGlFQUFvQjtBQUMvQyx1Q0FBdUMsaUVBQW9CO0FBQzNELG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHVEQUFpQjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGlFQUFvQjtBQUNuRCwyQ0FBMkMsaUVBQW9CO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDREQUFlO0FBQzVDLHlDQUF5Qyw0REFBZTtBQUN4RDtBQUNBO0FBQ0EsNkJBQTZCLDhEQUFpQjtBQUM5Qyx5Q0FBeUMsOERBQWlCO0FBQzFEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsd0NBQXdDO0FBQ3JELGFBQWEsb0NBQW9DO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsdURBQWlCO0FBQ3pCLFFBQVEsd0RBQWdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx1REFBaUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsdURBQWU7QUFDdkIsUUFBUSw2REFBcUI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsdURBQWlCO0FBQ2hELDJCQUEyQixpRUFBb0I7QUFDL0MsdUNBQXVDLGlFQUFvQjtBQUMzRDtBQUNBLDZCQUE2Qiw0REFBZTtBQUM1Qyx5Q0FBeUMsNERBQWU7QUFDeEQ7QUFDQTtBQUNBLDZCQUE2Qiw4REFBaUI7QUFDOUMseUNBQXlDLDhEQUFpQjtBQUMxRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLHlFQUF5RTtBQUN0RixhQUFhLHdDQUF3QztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHVEQUFpQjtBQUN6QixRQUFRLHdEQUFnQjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsdURBQWlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHVEQUFlO0FBQ3ZCLFFBQVEsNkRBQXFCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsZUFBZTtBQUNoQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsOENBQThDO0FBQzNELGFBQWEsd0NBQXdDO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsdURBQWlCO0FBQ3pCLFFBQVEsd0RBQWdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx1REFBaUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsdURBQWU7QUFDdkIsUUFBUSw2REFBcUI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFFBQVE7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYyxpREFBaUQ7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxRQUFRO0FBQ3ZELHlCQUF5Qiw0REFBSTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlFQUFlLG9CQUFvQixFQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDcFFwQztBQUNBO0FBQ0E7QUFDeUM7QUFDUTtBQUNGO0FBZXpCO0FBQ2U7QUFDTTtBQUNZO0FBQ1E7QUFDL0Q7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0NBQWdDLG1EQUFhO0FBQzdDO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsa0NBQWtDO0FBQy9DLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0Esb0JBQW9CLHdEQUFnQixLQUFLLFdBQVcsd0RBQWdCOztBQUVwRTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsaUNBQWlDLGtDQUFrQyxNQUFNOztBQUV6RTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLGlEQUFpRDtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxnRkFBZ0Y7QUFDN0YsYUFBYSx3Q0FBd0M7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsc0RBQVU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLDBCQUEwQixpREFBaUQ7QUFDM0U7QUFDQTtBQUNBLFFBQVE7QUFDUiwwQkFBMEIseUNBQXlDO0FBQ25FO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxxQkFBcUIsOENBQThDO0FBQ25FO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxRQUFRO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsUUFBUTtBQUNoRDtBQUNBO0FBQ0EsbUJBQW1CLGtFQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsNENBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsMEVBQWE7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGNBQWM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsNENBQTRDO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsNENBQTRDO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsd0NBQXdDO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsaURBQWlEO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix5Q0FBeUM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDhDQUE4QztBQUNyRTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsUUFBUTtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixzREFBYztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2REFBNkQ7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHVEQUFpQjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsc0RBQWM7QUFDakMsWUFBWSxzREFBYztBQUMxQjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0Isd0RBQWdCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLFFBQVEsdURBQWlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix3REFBZ0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsd0RBQWdCO0FBQzFEO0FBQ0EsZ0RBQWdELDJEQUFtQjtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTSx1REFBaUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSx1REFBaUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isd0RBQWdCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSx1Q0FBdUM7QUFDcEQsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLGlDQUFpQyxrQ0FBa0MsTUFBTTtBQUN6RTtBQUNBO0FBQ0EsOEJBQThCLDBEQUFXO0FBQ3pDLHNDQUFzQyx3REFBZ0I7QUFDdEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsbUNBQW1DLG9DQUFvQyxNQUFNO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxzREFBYztBQUM1RSw2REFBNkQsdURBQWU7QUFDNUU7QUFDQSx5Q0FBeUMsNkRBQXFCO0FBQzlELGdFQUFnRSx1REFBZTtBQUMvRTtBQUNBLG9DQUFvQyx3REFBZ0I7QUFDcEQ7QUFDQSxxQ0FBcUMseURBQWlCO0FBQ3RELGtDQUFrQywwREFBVztBQUM3Qyx3Q0FBd0MsMERBQWtCO0FBQzFEO0FBQ0E7O0FBRUE7QUFDQSwwQ0FBMEMsbURBQVc7QUFDckQsTUFBTSx3REFBWTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsMkRBQW1CO0FBQzFEO0FBQ0E7QUFDQSxvREFBb0Qsc0RBQWM7QUFDbEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyxnREFBTTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGdEQUFNO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUVBQWUsaUJBQWlCLEVBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3JwQmpDO0FBQ0E7QUFDQTs7QUFFcUQ7QUFDakI7QUFDSztBQUNMO0FBQ2U7QUFDUjs7QUFFcEM7O0FBRVA7QUFDQSxXQUFXLDhCQUE4QjtBQUN6QyxXQUFXLCtDQUErQztBQUMxRDtBQUNBO0FBQ0EsV0FBVywrQ0FBK0M7QUFDMUQ7QUFDQSxXQUFXLHdEQUF3RDtBQUNuRTtBQUNBLFdBQVcsa0NBQWtDO0FBQzdDLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsWUFBWSxXQUFXO0FBQ3ZCO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiw4REFBcUI7QUFDdkM7QUFDQTtBQUNBLHVCQUF1QixxREFBdUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsbUJBQW1CO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsUUFBUTtBQUNoRDtBQUNBO0FBQ0Esd0JBQXdCLHNEQUFVO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJCQUEyQiw4REFBcUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGlEQUFJO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixvREFBb0Q7QUFDekU7QUFDQTtBQUNBLGdEQUFnRCxRQUFRO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvRUFBb0UsZ0RBQVM7QUFDN0UsMENBQTBDLFFBQVE7QUFDbEQ7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFFBQVE7QUFDeEQ7QUFDQSxnREFBZ0QsUUFBUTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyw2QkFBNkI7QUFDeEM7QUFDQSxXQUFXLFVBQVU7QUFDckI7QUFDQSxXQUFXLFdBQVc7QUFDdEI7QUFDQSxZQUFZLFVBQVU7QUFDdEIsY0FBYyx3Q0FBd0M7QUFDdEQ7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLCtDQUFLO0FBQ1osUUFBUSwrQ0FBSztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2xNQTtBQUNBO0FBQ0E7O0FBRTJDO0FBQ0o7QUFDQTtBQUNnQjtBQUNaO0FBQ0Y7QUFDRjtBQVFMO0FBQ3NDO0FBQ25DOztBQUVyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEseUNBQXlDO0FBQ3REOztBQUVBO0FBQ0EsYUFBYSxzREFBc0Q7QUFDbkU7O0FBRUE7QUFDQSxhQUFhLG1EQUFtRDtBQUNoRTs7QUFFQTtBQUNBLGFBQWEsbURBQW1EO0FBQ2hFOztBQUVBO0FBQ0EsYUFBYSwrQ0FBK0M7QUFDNUQ7O0FBRUE7QUFDQSxhQUFhLGlEQUFpRDtBQUM5RDs7QUFFQTtBQUNBLFdBQVcsbUJBQW1CO0FBQzlCLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVywyQ0FBMkM7QUFDdEQsWUFBWSw4Q0FBOEM7QUFDMUQ7QUFDTztBQUNQLHlCQUF5QixzRUFBaUI7QUFDMUM7QUFDQSw0QkFBNEIsa0VBQW9CO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnREFBZ0Q7QUFDM0QsWUFBWSw4Q0FBOEM7QUFDMUQ7QUFDTztBQUNQLHlCQUF5QixzRUFBaUI7QUFDMUM7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLGtCQUFrQixZQUFZO0FBQzlCO0FBQ0E7QUFDQSw0QkFBNEIsa0VBQW9COztBQUVoRDtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixZQUFZO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLDBDQUEwQztBQUN2RDs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjLHFCQUFxQjtBQUNuQyxjQUFjLHVCQUF1QjtBQUNyQzs7QUFFQTtBQUNBLFdBQVcsMkNBQTJDO0FBQ3RELFdBQVcsZ0JBQWdCO0FBQzNCLFlBQVksa0JBQWtCO0FBQzlCO0FBQ087QUFDUDs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBLGtCQUFrQixZQUFZO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLFVBQVUsNkRBQWUsY0FBYyw0REFBVztBQUNsRDs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGlCQUFpQjtBQUN2QztBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUEsd0JBQXdCO0FBQ3hCOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixZQUFZO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsbUNBQW1DO0FBQ2hEOztBQUVBO0FBQ0EsV0FBVyxXQUFXO0FBQ3RCLFdBQVcsZ0JBQWdCO0FBQzNCLFlBQVksZ0JBQWdCO0FBQzVCO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLHVEQUFLO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsa0NBQWtDO0FBQy9DOztBQUVBO0FBQ0EsV0FBVyxXQUFXO0FBQ3RCLFdBQVcsUUFBUTtBQUNuQixXQUFXLGdCQUFnQjtBQUMzQixZQUFZLGdCQUFnQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsc0RBQUk7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxvQ0FBb0M7QUFDakQ7O0FBRUE7QUFDQSxXQUFXLFdBQVc7QUFDdEIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsZ0JBQWdCO0FBQzNCLFlBQVksa0JBQWtCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsd0RBQU07QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLGtDQUFrQztBQUMvQzs7QUFFQTtBQUNBLFdBQVcsV0FBVztBQUN0QixXQUFXLGdCQUFnQjtBQUMzQixZQUFZLGdCQUFnQjtBQUM1QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsc0RBQUksR0FBRztBQUMxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxRQUFRO0FBQ3ZEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLEdBQUc7QUFDaEIsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtB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Q0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsTUFBTTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGVBQWU7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGVBQWU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLDZCQUE2QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYyxnREFBZ0Q7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYyxRQUFR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QUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsY0FBYztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyxlQUFlO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyw2QkFBNkI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSw2QkFBNkI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYyxtQkFBbUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjLG1CQUFtQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Is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QUssK0NBQU07QUFDOUM7QUFDQSx3QkFBd0Isb0RBQVc7QUFDbkM7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLGlCQUFpQixvREFBUztBQUMxQixnQkFBZ0IscURBQUc7QUFDbkIsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsY0FBYyxrREFBRztBQUNqQjtBQUNBO0FBQ0EsWUFBWSxtREFBSTtBQUNoQixVQUFVLG1EQUFVO0FBQ3BCO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixzQ0FBc0M7QUFDbEU7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGlscC8uL25vZGVfbW9kdWxlcy9yYnVzaC9yYnVzaC5taW4uanMiLCJ3ZWJwYWNrOi8vaGlscC8uL3NyYy9kYXRhLmpzIiwid2VicGFjazovL2hpbHAvLi9ub2RlX21vZHVsZXMvb2wvQ29sbGVjdGlvbi5qcyIsIndlYnBhY2s6Ly9oaWxwLy4vbm9kZV9tb2R1bGVzL29sL0NvbGxlY3Rpb25FdmVudFR5cGUuanMiLCJ3ZWJwYWNrOi8vaGlscC8uL25vZGVfbW9kdWxlcy9vbC9EaXNwb3NhYmxlLmpzIiwid2VicGFjazovL2hpbHAvLi9ub2RlX21vZHVsZXMvb2wvRmVhdHVyZS5qcyIsIndlYnBhY2s6Ly9oaWxwLy4vbm9kZV9tb2R1bGVzL29sL0ltYWdlLmpzIiwid2VicGFjazovL2hpbHAvLi9ub2RlX21vZHVsZXMvb2wvSW1hZ2VTdGF0ZS5qcyIsIndlYnBhY2s6Ly9oaWxwLy4vbm9kZV9tb2R1bGVzL29sL0ltYWdlVGlsZS5qcyIsIndlYnBhY2s6Ly9oaWxwLy4vbm9kZV9tb2R1bGVzL29sL0tpbmV0aWMuanMiLCJ3ZWJwYWNrOi8vaGlscC8uL25vZGVfbW9kdWxlcy9vbC9NYXAuanMiLCJ3ZWJwYWNrOi8vaGlscC8uL25vZGVfbW9kdWxlcy9vbC9NYXBCcm93c2VyRXZlbnQuanMiLCJ3ZWJwYWNrOi8vaGlscC8uL25vZGVfbW9kdWxlcy9vbC9NYXBCcm93c2VyRXZlbnRIYW5kbGVyLmpzIiwid2VicGFjazovL2hpbHAvLi9ub2RlX21vZHVsZXMvb2wvTWFwQnJvd3NlckV2ZW50VHlwZS5qcyIsIndlYnBhY2s6Ly9oaWxwLy4vbm9kZV9tb2R1bGVzL29sL01hcEV2ZW50LmpzIiwid2VicGFjazovL2hpbHAvLi9ub2RlX21vZHVsZXMvb2wvTWFwRXZlbnRUeXBlLmpzIiwid2VicGFjazovL2hpbHAvLi9ub2RlX21vZHVsZXMvb2wvTWFwUHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vaGlscC8uL25vZGVfbW9kdWxlcy9vbC9PYmplY3QuanMiLCJ3ZWJwYWNrOi8vaGlscC8uL25vZGVfbW9kdWxlcy9vbC9PYmplY3RFdmVudFR5cGUuanMiLCJ3ZWJwYWNrOi8vaGlscC8uL25vZGVfbW9kdWxlcy9vbC9PYnNlcnZhYmxlLmpzIiwid2VicGFjazovL2hpbHAvLi9ub2RlX21vZHVsZXMvb2wvVGlsZS5qcyIsIndlYnBhY2s6Ly9oaWxwLy4vbm9kZV9tb2R1bGVzL29sL1RpbGVDYWNoZS5qcyIsIndlYnBhY2s6Ly9oaWxwLy4vbm9kZV9tb2R1bGVzL29sL1RpbGVRdWV1ZS5qcyIsIndlYnBhY2s6Ly9oaWxwLy4vbm9kZV9tb2R1bGVzL29sL1RpbGVSYW5nZS5qcyIsIndlYnBhY2s6Ly9oaWxwLy4vbm9kZV9tb2R1bGVzL29sL1RpbGVTdGF0ZS5qcyIsIndlYnBhY2s6Ly9oaWxwLy4vbm9kZV9tb2R1bGVzL29sL1ZpZXcuanMiLCJ3ZWJwYWNrOi8vaGlscC8uL25vZGVfbW9kdWxlcy9vbC9WaWV3SGludC5qcyIsIndlYnBhY2s6Ly9oaWxwLy4vbm9kZV9tb2R1bGVzL29sL1ZpZXdQcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly9oaWxwLy4vbm9kZV9tb2R1bGVzL29sL2FycmF5LmpzIiwid2VicGFjazovL2hpbHAvLi9ub2RlX21vZHVsZXMvb2wvYXNzZXJ0cy5qcyIsIndlYnBhY2s6Ly9oaWxwLy4vbm9kZV9tb2R1bGVzL29sL2NlbnRlcmNvbnN0cmFpbnQuanMiLCJ3ZWJwYWNrOi8vaGlscC8uL25vZGVfbW9kdWxlcy9vbC9jb2xvci5qcyIsIndlYnBhY2s6Ly9oaWxwLy4vbm9kZV9tb2R1bGVzL29sL2NvbG9ybGlrZS5qcyIsIndlYnBhY2s6Ly9oaWxwLy4vbm9kZV9tb2R1bGVzL29sL2NvbnNvbGUuanMiLCJ3ZWJwYWNrOi8vaGlscC8uL25vZGVfbW9kdWxlcy9vbC9jb250cm9sL0F0dHJpYnV0aW9uLmpzIiwid2VicGFjazovL2hpbHAvLi9ub2RlX21vZHVsZXMvb2wvY29udHJvbC9Db250cm9sLmpzIiwid2VicGFjazovL2hpbHAvLi9ub2RlX21vZHVsZXMvb2wvY29udHJvbC9Sb3RhdGUuanMiLCJ3ZWJwYWNrOi8vaGlscC8uL25vZGVfbW9kdWxlcy9vbC9jb250cm9sL1pvb20uanMiLCJ3ZWJwYWNrOi8vaGlscC8uL25vZGVfbW9kdWxlcy9vbC9jb250cm9sL2RlZmF1bHRzLmpzIiwid2VicGFjazovL2hpbHAvLi9ub2RlX21vZHVsZXMvb2wvY29vcmRpbmF0ZS5qcyIsIndlYnBhY2s6Ly9oaWxwLy4vbm9kZV9tb2R1bGVzL29sL2Nzcy5qcyIsIndlYnBhY2s6Ly9oaWxwLy4vbm9kZV9tb2R1bGVzL29sL2RvbS5qcyIsIndlYnBhY2s6Ly9oaWxwLy4vbm9kZV9tb2R1bGVzL29sL2Vhc2luZy5qcyIsIndlYnBhY2s6Ly9oaWxwLy4vbm9kZV9tb2R1bGVzL29sL2V2ZW50cy5qcyIsIndlYnBhY2s6Ly9oaWxwLy4vbm9kZV9tb2R1bGVzL29sL2V2ZW50cy9FdmVudC5qcyIsIndlYnBhY2s6Ly9oaWxwLy4vbm9kZV9tb2R1bGVzL29sL2V2ZW50cy9FdmVudFR5cGUuanMiLCJ3ZWJwYWNrOi8vaGlscC8uL25vZGVfbW9kdWxlcy9vbC9ldmVudHMvS2V5LmpzIiwid2VicGFjazovL2hpbHAvLi9ub2RlX21vZHVsZXMvb2wvZXZlbnRzL1RhcmdldC5qcyIsIndlYnBhY2s6Ly9oaWxwLy4vbm9kZV9tb2R1bGVzL29sL2V2ZW50cy9jb25kaXRpb24uanMiLCJ3ZWJwYWNrOi8vaGlscC8uL25vZGVfbW9kdWxlcy9vbC9leHByL2NwdS5qcyIsIndlYnBhY2s6Ly9oaWxwLy4vbm9kZV9tb2R1bGVzL29sL2V4cHIvZXhwcmVzc2lvbi5qcyIsIndlYnBhY2s6Ly9oaWxwLy4vbm9kZV9tb2R1bGVzL29sL2V4dGVudC5qcyIsIndlYnBhY2s6Ly9oaWxwLy4vbm9kZV9tb2R1bGVzL29sL2V4dGVudC9SZWxhdGlvbnNoaXAuanMiLCJ3ZWJwYWNrOi8vaGlscC8uL25vZGVfbW9kdWxlcy9vbC9mZWF0dXJlbG9hZGVyLmpzIiwid2VicGFjazovL2hpbHAvLi9ub2RlX21vZHVsZXMvb2wvZm9ybWF0L0ZlYXR1cmUuanMiLCJ3ZWJwYWNrOi8vaGlscC8uL25vZGVfbW9kdWxlcy9vbC9mb3JtYXQvR2VvSlNPTi5qcyIsIndlYnBhY2s6Ly9oaWxwLy4vbm9kZV9tb2R1bGVzL29sL2Zvcm1hdC9KU09ORmVhdHVyZS5qcyIsIndlYnBhY2s6Ly9oaWxwLy4vbm9kZV9tb2R1bGVzL29sL2Z1bmN0aW9ucy5qcyIsIndlYnBhY2s6Ly9oaWxwLy4vbm9kZV9tb2R1bGVzL29sL2dlb20vQ2lyY2xlLmpzIiwid2VicGFjazovL2hpbHAvLi9ub2RlX21vZHVsZXMvb2wvZ2VvbS9HZW9tZXRyeS5qcyIsIndlYnBhY2s6Ly9oaWxwLy4vbm9kZV9tb2R1bGVzL29sL2dlb20vR2VvbWV0cnlDb2xsZWN0aW9uLmpzIiwid2VicGFjazovL2hpbHAvLi9ub2RlX21vZHVsZXMvb2wvZ2VvbS9MaW5lU3RyaW5nLmpzIiwid2VicGFjazovL2hpbHAvLi9ub2RlX21vZHVsZXMvb2wvZ2VvbS9MaW5lYXJSaW5nLmpzIiwid2VicGFjazovL2hpbHAvLi9ub2RlX21vZHVsZXMvb2wvZ2VvbS9NdWx0aUxpbmVTdHJpbmcuanMiLCJ3ZWJwYWNrOi8vaGlscC8uL25vZGVfbW9kdWxlcy9vbC9nZW9tL011bHRpUG9pbnQuanMiLCJ3ZWJwYWNrOi8vaGlscC8uL25vZGVfbW9kdWxlcy9vbC9nZW9tL011bHRpUG9seWdvbi5qcyIsIndlYnBhY2s6Ly9oaWxwLy4vbm9kZV9tb2R1bGVzL29sL2dlb20vUG9pbnQuanMiLCJ3ZWJwYWNrOi8vaGlscC8uL25vZGVfbW9kdWxlcy9vbC9nZW9tL1BvbHlnb24uanMiLCJ3ZWJwYWNrOi8vaGlscC8uL25vZGVfbW9kdWxlcy9vbC9nZW9tL1NpbXBsZUdlb21ldHJ5LmpzIiwid2VicGFjazovL2hpbHAvLi9ub2RlX21vZHVsZXMvb2wvZ2VvbS9mbGF0L2FyZWEuanMiLCJ3ZWJwYWNrOi8vaGlscC8uL25vZGVfbW9kdWxlcy9vbC9nZW9tL2ZsYXQvY2VudGVyLmpzIiwid2VicGFjazovL2hpbHAvLi9ub2RlX21vZHVsZXMvb2wvZ2VvbS9mbGF0L2Nsb3Nlc3QuanMiLCJ3ZWJwYWNrOi8vaGlscC8uL25vZGVfbW9kdWxlcy9vbC9nZW9tL2ZsYXQvY29udGFpbnMuanMiLCJ3ZWJwYWNrOi8vaGlscC8uL25vZGVfbW9kdWxlcy9vbC9nZW9tL2ZsYXQvZGVmbGF0ZS5qcyIsIndlYnBhY2s6Ly9oaWxwLy4vbm9kZV9tb2R1bGVzL29sL2dlb20vZmxhdC9pbmZsYXRlLmpzIiwid2VicGFjazovL2hpbHAvLi9ub2RlX21vZHVsZXMvb2wvZ2VvbS9mbGF0L2ludGVyaW9ycG9pbnQuanMiLCJ3ZWJwYWNrOi8vaGlscC8uL25vZGVfbW9kdWxlcy9vbC9nZW9tL2ZsYXQvaW50ZXJwb2xhdGUuanMiLCJ3ZWJwYWNrOi8vaGlscC8uL25vZGVfbW9kdWxlcy9vbC9nZW9tL2ZsYXQvaW50ZXJzZWN0c2V4dGVudC5qcyIsIndlYnBhY2s6Ly9oaWxwLy4vbm9kZV9tb2R1bGVzL29sL2dlb20vZmxhdC9sZW5ndGguanMiLCJ3ZWJwYWNrOi8vaGlscC8uL25vZGVfbW9kdWxlcy9vbC9nZW9tL2ZsYXQvbGluZWNodW5rLmpzIiwid2VicGFjazovL2hpbHAvLi9ub2RlX21vZHVsZXMvb2wvZ2VvbS9mbGF0L29yaWVudC5qcyIsIndlYnBhY2s6Ly9oaWxwLy4vbm9kZV9tb2R1bGVzL29sL2dlb20vZmxhdC9yZXZlcnNlLmpzIiwid2VicGFjazovL2hpbHAvLi9ub2RlX21vZHVsZXMvb2wvZ2VvbS9mbGF0L3NlZ21lbnRzLmpzIiwid2VicGFjazovL2hpbHAvLi9ub2RlX21vZHVsZXMvb2wvZ2VvbS9mbGF0L3NpbXBsaWZ5LmpzIiwid2VicGFjazovL2hpbHAvLi9ub2RlX21vZHVsZXMvb2wvZ2VvbS9mbGF0L3N0cmFpZ2h0Y2h1bmsuanMiLCJ3ZWJwYWNrOi8vaGlscC8uL25vZGVfbW9kdWxlcy9vbC9nZW9tL2ZsYXQvdGV4dHBhdGguanMiLCJ3ZWJwYWNrOi8vaGlscC8uL25vZGVfbW9kdWxlcy9vbC9nZW9tL2ZsYXQvdHJhbnNmb3JtLmpzIiwid2VicGFjazovL2hpbHAvLi9ub2RlX21vZHVsZXMvb2wvaGFzLmpzIiwid2VicGFjazovL2hpbHAvLi9ub2RlX21vZHVsZXMvb2wvaW50ZXJhY3Rpb24vRG91YmxlQ2xpY2tab29tLmpzIiwid2VicGFjazovL2hpbHAvLi9ub2RlX21vZHVsZXMvb2wvaW50ZXJhY3Rpb24vRHJhZ0JveC5qcyIsIndlYnBhY2s6Ly9oaWxwLy4vbm9kZV9tb2R1bGVzL29sL2ludGVyYWN0aW9uL0RyYWdQYW4uanMiLCJ3ZWJwYWNrOi8vaGlscC8uL25vZGVfbW9kdWxlcy9vbC9pbnRlcmFjdGlvbi9EcmFnUm90YXRlLmpzIiwid2VicGFjazovL2hpbHAvLi9ub2RlX21vZHVsZXMvb2wvaW50ZXJhY3Rpb24vRHJhZ1pvb20uanMiLCJ3ZWJwYWNrOi8vaGlscC8uL25vZGVfbW9kdWxlcy9vbC9pbnRlcmFjdGlvbi9JbnRlcmFjdGlvbi5qcyIsIndlYnBhY2s6Ly9oaWxwLy4vbm9kZV9tb2R1bGVzL29sL2ludGVyYWN0aW9uL0tleWJvYXJkUGFuLmpzIiwid2VicGFjazovL2hpbHAvLi9ub2RlX21vZHVsZXMvb2wvaW50ZXJhY3Rpb24vS2V5Ym9hcmRab29tLmpzIiwid2VicGFjazovL2hpbHAvLi9ub2RlX21vZHVsZXMvb2wvaW50ZXJhY3Rpb24vTW91c2VXaGVlbFpvb20uanMiLCJ3ZWJwYWNrOi8vaGlscC8uL25vZGVfbW9kdWxlcy9vbC9pbnRlcmFjdGlvbi9QaW5jaFJvdGF0ZS5qcyIsIndlYnBhY2s6Ly9oaWxwLy4vbm9kZV9tb2R1bGVzL29sL2ludGVyYWN0aW9uL1BpbmNoWm9vbS5qcyIsIndlYnBhY2s6Ly9oaWxwLy4vbm9kZV9tb2R1bGVzL29sL2ludGVyYWN0aW9uL1BvaW50ZXIuanMiLCJ3ZWJwYWNrOi8vaGlscC8uL25vZGVfbW9kdWxlcy9vbC9pbnRlcmFjdGlvbi9Qcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly9oaWxwLy4vbm9kZV9tb2R1bGVzL29sL2ludGVyYWN0aW9uL2RlZmF1bHRzLmpzIiwid2VicGFjazovL2hpbHAvLi9ub2RlX21vZHVsZXMvb2wvbGF5ZXIvQmFzZS5qcyIsIndlYnBhY2s6Ly9oaWxwLy4vbm9kZV9tb2R1bGVzL29sL2xheWVyL0Jhc2VUaWxlLmpzIiwid2VicGFjazovL2hpbHAvLi9ub2RlX21vZHVsZXMvb2wvbGF5ZXIvQmFzZVZlY3Rvci5qcyIsIndlYnBhY2s6Ly9oaWxwLy4vbm9kZV9tb2R1bGVzL29sL2xheWVyL0dyb3VwLmpzIiwid2VicGFjazovL2hpbHAvLi9ub2RlX21vZHVsZXMvb2wvbGF5ZXIvTGF5ZXIuanMiLCJ3ZWJwYWNrOi8vaGlscC8uL25vZGVfbW9kdWxlcy9vbC9sYXllci9Qcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly9oaWxwLy4vbm9kZV9tb2R1bGVzL29sL2xheWVyL1RpbGUuanMiLCJ3ZWJwYWNrOi8vaGlscC8uL25vZGVfbW9kdWxlcy9vbC9sYXllci9UaWxlUHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vaGlscC8uL25vZGVfbW9kdWxlcy9vbC9sYXllci9WZWN0b3IuanMiLCJ3ZWJwYWNrOi8vaGlscC8uL25vZGVfbW9kdWxlcy9vbC9sb2FkaW5nc3RyYXRlZ3kuanMiLCJ3ZWJwYWNrOi8vaGlscC8uL25vZGVfbW9kdWxlcy9vbC9tYXRoLmpzIiwid2VicGFjazovL2hpbHAvLi9ub2RlX21vZHVsZXMvb2wvb2JqLmpzIiwid2VicGFjazovL2hpbHAvLi9ub2RlX21vZHVsZXMvb2wvcG9pbnRlci9FdmVudFR5cGUuanMiLCJ3ZWJwYWNrOi8vaGlscC8uL25vZGVfbW9kdWxlcy9vbC9wcm9qLmpzIiwid2VicGFjazovL2hpbHAvLi9ub2RlX21vZHVsZXMvb2wvcHJvai9Qcm9qZWN0aW9uLmpzIiwid2VicGFjazovL2hpbHAvLi9ub2RlX21vZHVsZXMvb2wvcHJvai9Vbml0cy5qcyIsIndlYnBhY2s6Ly9oaWxwLy4vbm9kZV9tb2R1bGVzL29sL3Byb2ovZXBzZzM4NTcuanMiLCJ3ZWJwYWNrOi8vaGlscC8uL25vZGVfbW9kdWxlcy9vbC9wcm9qL2Vwc2c0MzI2LmpzIiwid2VicGFjazovL2hpbHAvLi9ub2RlX21vZHVsZXMvb2wvcHJvai9wcm9qZWN0aW9ucy5qcyIsIndlYnBhY2s6Ly9oaWxwLy4vbm9kZV9tb2R1bGVzL29sL3Byb2ovdHJhbnNmb3Jtcy5qcyIsIndlYnBhY2s6Ly9oaWxwLy4vbm9kZV9tb2R1bGVzL29sL3JlbmRlci9Cb3guanMiLCJ3ZWJwYWNrOi8vaGlscC8uL25vZGVfbW9kdWxlcy9vbC9yZW5kZXIvRXZlbnQuanMiLCJ3ZWJwYWNrOi8vaGlscC8uL25vZGVfbW9kdWxlcy9vbC9yZW5kZXIvRXZlbnRUeXBlLmpzIiwid2VicGFjazovL2hpbHAvLi9ub2RlX21vZHVsZXMvb2wvcmVuZGVyL1ZlY3RvckNvbnRleHQuanMiLCJ3ZWJwYWNrOi8vaGlscC8uL25vZGVfbW9kdWxlcy9vbC9yZW5kZXIvY2FudmFzLmpzIiwid2VicGFjazovL2hpbHAvLi9ub2RlX21vZHVsZXMvb2wvcmVuZGVyL2NhbnZhcy9CdWlsZGVyLmpzIiwid2VicGFjazovL2hpbHAvLi9ub2RlX21vZHVsZXMvb2wvcmVuZGVyL2NhbnZhcy9CdWlsZGVyR3JvdXAuanMiLCJ3ZWJwYWNrOi8vaGlscC8uL25vZGVfbW9kdWxlcy9vbC9yZW5kZXIvY2FudmFzL0V4ZWN1dG9yLmpzIiwid2VicGFjazovL2hpbHAvLi9ub2RlX21vZHVsZXMvb2wvcmVuZGVyL2NhbnZhcy9FeGVjdXRvckdyb3VwLmpzIiwid2VicGFjazovL2hpbHAvLi9ub2RlX21vZHVsZXMvb2wvcmVuZGVyL2NhbnZhcy9JbWFnZUJ1aWxkZXIuanMiLCJ3ZWJwYWNrOi8vaGlscC8uL25vZGVfbW9kdWxlcy9vbC9yZW5kZXIvY2FudmFzL0ltbWVkaWF0ZS5qcyIsIndlYnBhY2s6Ly9oaWxwLy4vbm9kZV9tb2R1bGVzL29sL3JlbmRlci9jYW52YXMvSW5zdHJ1Y3Rpb24uanMiLCJ3ZWJwYWNrOi8vaGlscC8uL25vZGVfbW9kdWxlcy9vbC9yZW5kZXIvY2FudmFzL0xpbmVTdHJpbmdCdWlsZGVyLmpzIiwid2VicGFjazovL2hpbHAvLi9ub2RlX21vZHVsZXMvb2wvcmVuZGVyL2NhbnZhcy9Qb2x5Z29uQnVpbGRlci5qcyIsIndlYnBhY2s6Ly9oaWxwLy4vbm9kZV9tb2R1bGVzL29sL3JlbmRlci9jYW52YXMvVGV4dEJ1aWxkZXIuanMiLCJ3ZWJwYWNrOi8vaGlscC8uL25vZGVfbW9kdWxlcy9vbC9yZW5kZXIvY2FudmFzL2hpdGRldGVjdC5qcyIsIndlYnBhY2s6Ly9oaWxwLy4vbm9kZV9tb2R1bGVzL29sL3JlbmRlci9jYW52YXMvc3R5bGUuanMiLCJ3ZWJwYWNrOi8vaGlscC8uL25vZGVfbW9kdWxlcy9vbC9yZW5kZXJlci9Db21wb3NpdGUuanMiLCJ3ZWJwYWNrOi8vaGlscC8uL25vZGVfbW9kdWxlcy9vbC9yZW5kZXJlci9MYXllci5qcyIsIndlYnBhY2s6Ly9oaWxwLy4vbm9kZV9tb2R1bGVzL29sL3JlbmRlcmVyL01hcC5qcyIsIndlYnBhY2s6Ly9oaWxwLy4vbm9kZV9tb2R1bGVzL29sL3JlbmRlcmVyL2NhbnZhcy9MYXllci5qcyIsIndlYnBhY2s6Ly9oaWxwLy4vbm9kZV9tb2R1bGVzL29sL3JlbmRlcmVyL2NhbnZhcy9UaWxlTGF5ZXIuanMiLCJ3ZWJwYWNrOi8vaGlscC8uL25vZGVfbW9kdWxlcy9vbC9yZW5kZXJlci9jYW52YXMvVmVjdG9yTGF5ZXIuanMiLCJ3ZWJwYWNrOi8vaGlscC8uL25vZGVfbW9kdWxlcy9vbC9yZW5kZXJlci92ZWN0b3IuanMiLCJ3ZWJwYWNrOi8vaGlscC8uL25vZGVfbW9kdWxlcy9vbC9yZXByb2ouanMiLCJ3ZWJwYWNrOi8vaGlscC8uL25vZGVfbW9kdWxlcy9vbC9yZXByb2ovVGlsZS5qcyIsIndlYnBhY2s6Ly9oaWxwLy4vbm9kZV9tb2R1bGVzL29sL3JlcHJvai9Ucmlhbmd1bGF0aW9uLmpzIiwid2VicGFjazovL2hpbHAvLi9ub2RlX21vZHVsZXMvb2wvcmVwcm9qL2NvbW1vbi5qcyIsIndlYnBhY2s6Ly9oaWxwLy4vbm9kZV9tb2R1bGVzL29sL3Jlc29sdXRpb25jb25zdHJhaW50LmpzIiwid2VicGFjazovL2hpbHAvLi9ub2RlX21vZHVsZXMvb2wvcm90YXRpb25jb25zdHJhaW50LmpzIiwid2VicGFjazovL2hpbHAvLi9ub2RlX21vZHVsZXMvb2wvc2l6ZS5qcyIsIndlYnBhY2s6Ly9oaWxwLy4vbm9kZV9tb2R1bGVzL29sL3NvdXJjZS9PU00uanMiLCJ3ZWJwYWNrOi8vaGlscC8uL25vZGVfbW9kdWxlcy9vbC9zb3VyY2UvU291cmNlLmpzIiwid2VicGFjazovL2hpbHAvLi9ub2RlX21vZHVsZXMvb2wvc291cmNlL1RpbGUuanMiLCJ3ZWJwYWNrOi8vaGlscC8uL25vZGVfbW9kdWxlcy9vbC9zb3VyY2UvVGlsZUV2ZW50VHlwZS5qcyIsIndlYnBhY2s6Ly9oaWxwLy4vbm9kZV9tb2R1bGVzL29sL3NvdXJjZS9UaWxlSW1hZ2UuanMiLCJ3ZWJwYWNrOi8vaGlscC8uL25vZGVfbW9kdWxlcy9vbC9zb3VyY2UvVXJsVGlsZS5qcyIsIndlYnBhY2s6Ly9oaWxwLy4vbm9kZV9tb2R1bGVzL29sL3NvdXJjZS9WZWN0b3IuanMiLCJ3ZWJwYWNrOi8vaGlscC8uL25vZGVfbW9kdWxlcy9vbC9zb3VyY2UvVmVjdG9yRXZlbnRUeXBlLmpzIiwid2VicGFjazovL2hpbHAvLi9ub2RlX21vZHVsZXMvb2wvc291cmNlL1hZWi5qcyIsIndlYnBhY2s6Ly9oaWxwLy4vbm9kZV9tb2R1bGVzL29sL3NwaGVyZS5qcyIsIndlYnBhY2s6Ly9oaWxwLy4vbm9kZV9tb2R1bGVzL29sL3N0cmluZy5qcyIsIndlYnBhY2s6Ly9oaWxwLy4vbm9kZV9tb2R1bGVzL29sL3N0cnVjdHMvTFJVQ2FjaGUuanMiLCJ3ZWJwYWNrOi8vaGlscC8uL25vZGVfbW9kdWxlcy9vbC9zdHJ1Y3RzL1ByaW9yaXR5UXVldWUuanMiLCJ3ZWJwYWNrOi8vaGlscC8uL25vZGVfbW9kdWxlcy9vbC9zdHJ1Y3RzL1JCdXNoLmpzIiwid2VicGFjazovL2hpbHAvLi9ub2RlX21vZHVsZXMvb2wvc3R5bGUvQ2lyY2xlLmpzIiwid2VicGFjazovL2hpbHAvLi9ub2RlX21vZHVsZXMvb2wvc3R5bGUvRmlsbC5qcyIsIndlYnBhY2s6Ly9oaWxwLy4vbm9kZV9tb2R1bGVzL29sL3N0eWxlL0ljb24uanMiLCJ3ZWJwYWNrOi8vaGlscC8uL25vZGVfbW9kdWxlcy9vbC9zdHlsZS9JY29uSW1hZ2UuanMiLCJ3ZWJwYWNrOi8vaGlscC8uL25vZGVfbW9kdWxlcy9vbC9zdHlsZS9JY29uSW1hZ2VDYWNoZS5qcyIsIndlYnBhY2s6Ly9oaWxwLy4vbm9kZV9tb2R1bGVzL29sL3N0eWxlL0ltYWdlLmpzIiwid2VicGFjazovL2hpbHAvLi9ub2RlX21vZHVsZXMvb2wvc3R5bGUvUmVndWxhclNoYXBlLmpzIiwid2VicGFjazovL2hpbHAvLi9ub2RlX21vZHVsZXMvb2wvc3R5bGUvU3Ryb2tlLmpzIiwid2VicGFjazovL2hpbHAvLi9ub2RlX21vZHVsZXMvb2wvc3R5bGUvU3R5bGUuanMiLCJ3ZWJwYWNrOi8vaGlscC8uL25vZGVfbW9kdWxlcy9vbC9zdHlsZS9UZXh0LmpzIiwid2VicGFjazovL2hpbHAvLi9ub2RlX21vZHVsZXMvb2wvdGlsZWNvb3JkLmpzIiwid2VicGFjazovL2hpbHAvLi9ub2RlX21vZHVsZXMvb2wvdGlsZWdyaWQuanMiLCJ3ZWJwYWNrOi8vaGlscC8uL25vZGVfbW9kdWxlcy9vbC90aWxlZ3JpZC9UaWxlR3JpZC5qcyIsIndlYnBhY2s6Ly9oaWxwLy4vbm9kZV9tb2R1bGVzL29sL3RpbGVncmlkL2NvbW1vbi5qcyIsIndlYnBhY2s6Ly9oaWxwLy4vbm9kZV9tb2R1bGVzL29sL3RpbGV1cmxmdW5jdGlvbi5qcyIsIndlYnBhY2s6Ly9oaWxwLy4vbm9kZV9tb2R1bGVzL29sL3RyYW5zZm9ybS5qcyIsIndlYnBhY2s6Ly9oaWxwLy4vbm9kZV9tb2R1bGVzL29sL3V0aWwuanMiLCJ3ZWJwYWNrOi8vaGlscC93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly9oaWxwL3dlYnBhY2svcnVudGltZS9kZWZpbmUgcHJvcGVydHkgZ2V0dGVycyIsIndlYnBhY2s6Ly9oaWxwL3dlYnBhY2svcnVudGltZS9oYXNPd25Qcm9wZXJ0eSBzaG9ydGhhbmQiLCJ3ZWJwYWNrOi8vaGlscC93ZWJwYWNrL3J1bnRpbWUvbWFrZSBuYW1lc3BhY2Ugb2JqZWN0Iiwid2VicGFjazovL2hpbHAvLi9zcmMvbWFpbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIhZnVuY3Rpb24odCxpKXtcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cyYmXCJ1bmRlZmluZWRcIiE9dHlwZW9mIG1vZHVsZT9tb2R1bGUuZXhwb3J0cz1pKCk6XCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShpKToodD10fHxzZWxmKS5SQnVzaD1pKCl9KHRoaXMsZnVuY3Rpb24oKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiB0KHQscixlLGEsaCl7IWZ1bmN0aW9uIHQobixyLGUsYSxoKXtmb3IoO2E+ZTspe2lmKGEtZT42MDApe3ZhciBvPWEtZSsxLHM9ci1lKzEsbD1NYXRoLmxvZyhvKSxmPS41Kk1hdGguZXhwKDIqbC8zKSx1PS41Kk1hdGguc3FydChsKmYqKG8tZikvbykqKHMtby8yPDA/LTE6MSksbT1NYXRoLm1heChlLE1hdGguZmxvb3Ioci1zKmYvbyt1KSksYz1NYXRoLm1pbihhLE1hdGguZmxvb3Iocisoby1zKSpmL28rdSkpO3QobixyLG0sYyxoKX12YXIgcD1uW3JdLGQ9ZSx4PWE7Zm9yKGkobixlLHIpLGgoblthXSxwKT4wJiZpKG4sZSxhKTtkPHg7KXtmb3IoaShuLGQseCksZCsrLHgtLTtoKG5bZF0scCk8MDspZCsrO2Zvcig7aChuW3hdLHApPjA7KXgtLX0wPT09aChuW2VdLHApP2kobixlLHgpOmkobiwrK3gsYSkseDw9ciYmKGU9eCsxKSxyPD14JiYoYT14LTEpfX0odCxyLGV8fDAsYXx8dC5sZW5ndGgtMSxofHxuKX1mdW5jdGlvbiBpKHQsaSxuKXt2YXIgcj10W2ldO3RbaV09dFtuXSx0W25dPXJ9ZnVuY3Rpb24gbih0LGkpe3JldHVybiB0PGk/LTE6dD5pPzE6MH12YXIgcj1mdW5jdGlvbih0KXt2b2lkIDA9PT10JiYodD05KSx0aGlzLl9tYXhFbnRyaWVzPU1hdGgubWF4KDQsdCksdGhpcy5fbWluRW50cmllcz1NYXRoLm1heCgyLE1hdGguY2VpbCguNCp0aGlzLl9tYXhFbnRyaWVzKSksdGhpcy5jbGVhcigpfTtmdW5jdGlvbiBlKHQsaSxuKXtpZighbilyZXR1cm4gaS5pbmRleE9mKHQpO2Zvcih2YXIgcj0wO3I8aS5sZW5ndGg7cisrKWlmKG4odCxpW3JdKSlyZXR1cm4gcjtyZXR1cm4tMX1mdW5jdGlvbiBhKHQsaSl7aCh0LDAsdC5jaGlsZHJlbi5sZW5ndGgsaSx0KX1mdW5jdGlvbiBoKHQsaSxuLHIsZSl7ZXx8KGU9cChudWxsKSksZS5taW5YPTEvMCxlLm1pblk9MS8wLGUubWF4WD0tMS8wLGUubWF4WT0tMS8wO2Zvcih2YXIgYT1pO2E8bjthKyspe3ZhciBoPXQuY2hpbGRyZW5bYV07byhlLHQubGVhZj9yKGgpOmgpfXJldHVybiBlfWZ1bmN0aW9uIG8odCxpKXtyZXR1cm4gdC5taW5YPU1hdGgubWluKHQubWluWCxpLm1pblgpLHQubWluWT1NYXRoLm1pbih0Lm1pblksaS5taW5ZKSx0Lm1heFg9TWF0aC5tYXgodC5tYXhYLGkubWF4WCksdC5tYXhZPU1hdGgubWF4KHQubWF4WSxpLm1heFkpLHR9ZnVuY3Rpb24gcyh0LGkpe3JldHVybiB0Lm1pblgtaS5taW5YfWZ1bmN0aW9uIGwodCxpKXtyZXR1cm4gdC5taW5ZLWkubWluWX1mdW5jdGlvbiBmKHQpe3JldHVybih0Lm1heFgtdC5taW5YKSoodC5tYXhZLXQubWluWSl9ZnVuY3Rpb24gdSh0KXtyZXR1cm4gdC5tYXhYLXQubWluWCsodC5tYXhZLXQubWluWSl9ZnVuY3Rpb24gbSh0LGkpe3JldHVybiB0Lm1pblg8PWkubWluWCYmdC5taW5ZPD1pLm1pblkmJmkubWF4WDw9dC5tYXhYJiZpLm1heFk8PXQubWF4WX1mdW5jdGlvbiBjKHQsaSl7cmV0dXJuIGkubWluWDw9dC5tYXhYJiZpLm1pblk8PXQubWF4WSYmaS5tYXhYPj10Lm1pblgmJmkubWF4WT49dC5taW5ZfWZ1bmN0aW9uIHAodCl7cmV0dXJue2NoaWxkcmVuOnQsaGVpZ2h0OjEsbGVhZjohMCxtaW5YOjEvMCxtaW5ZOjEvMCxtYXhYOi0xLzAsbWF4WTotMS8wfX1mdW5jdGlvbiBkKGksbixyLGUsYSl7Zm9yKHZhciBoPVtuLHJdO2gubGVuZ3RoOylpZighKChyPWgucG9wKCkpLShuPWgucG9wKCkpPD1lKSl7dmFyIG89bitNYXRoLmNlaWwoKHItbikvZS8yKSplO3QoaSxvLG4scixhKSxoLnB1c2gobixvLG8scil9fXJldHVybiByLnByb3RvdHlwZS5hbGw9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fYWxsKHRoaXMuZGF0YSxbXSl9LHIucHJvdG90eXBlLnNlYXJjaD1mdW5jdGlvbih0KXt2YXIgaT10aGlzLmRhdGEsbj1bXTtpZighYyh0LGkpKXJldHVybiBuO2Zvcih2YXIgcj10aGlzLnRvQkJveCxlPVtdO2k7KXtmb3IodmFyIGE9MDthPGkuY2hpbGRyZW4ubGVuZ3RoO2ErKyl7dmFyIGg9aS5jaGlsZHJlblthXSxvPWkubGVhZj9yKGgpOmg7Yyh0LG8pJiYoaS5sZWFmP24ucHVzaChoKTptKHQsbyk/dGhpcy5fYWxsKGgsbik6ZS5wdXNoKGgpKX1pPWUucG9wKCl9cmV0dXJuIG59LHIucHJvdG90eXBlLmNvbGxpZGVzPWZ1bmN0aW9uKHQpe3ZhciBpPXRoaXMuZGF0YTtpZighYyh0LGkpKXJldHVybiExO2Zvcih2YXIgbj1bXTtpOyl7Zm9yKHZhciByPTA7cjxpLmNoaWxkcmVuLmxlbmd0aDtyKyspe3ZhciBlPWkuY2hpbGRyZW5bcl0sYT1pLmxlYWY/dGhpcy50b0JCb3goZSk6ZTtpZihjKHQsYSkpe2lmKGkubGVhZnx8bSh0LGEpKXJldHVybiEwO24ucHVzaChlKX19aT1uLnBvcCgpfXJldHVybiExfSxyLnByb3RvdHlwZS5sb2FkPWZ1bmN0aW9uKHQpe2lmKCF0fHwhdC5sZW5ndGgpcmV0dXJuIHRoaXM7aWYodC5sZW5ndGg8dGhpcy5fbWluRW50cmllcyl7Zm9yKHZhciBpPTA7aTx0Lmxlbmd0aDtpKyspdGhpcy5pbnNlcnQodFtpXSk7cmV0dXJuIHRoaXN9dmFyIG49dGhpcy5fYnVpbGQodC5zbGljZSgpLDAsdC5sZW5ndGgtMSwwKTtpZih0aGlzLmRhdGEuY2hpbGRyZW4ubGVuZ3RoKWlmKHRoaXMuZGF0YS5oZWlnaHQ9PT1uLmhlaWdodCl0aGlzLl9zcGxpdFJvb3QodGhpcy5kYXRhLG4pO2Vsc2V7aWYodGhpcy5kYXRhLmhlaWdodDxuLmhlaWdodCl7dmFyIHI9dGhpcy5kYXRhO3RoaXMuZGF0YT1uLG49cn10aGlzLl9pbnNlcnQobix0aGlzLmRhdGEuaGVpZ2h0LW4uaGVpZ2h0LTEsITApfWVsc2UgdGhpcy5kYXRhPW47cmV0dXJuIHRoaXN9LHIucHJvdG90eXBlLmluc2VydD1mdW5jdGlvbih0KXtyZXR1cm4gdCYmdGhpcy5faW5zZXJ0KHQsdGhpcy5kYXRhLmhlaWdodC0xKSx0aGlzfSxyLnByb3RvdHlwZS5jbGVhcj1mdW5jdGlvbigpe3JldHVybiB0aGlzLmRhdGE9cChbXSksdGhpc30sci5wcm90b3R5cGUucmVtb3ZlPWZ1bmN0aW9uKHQsaSl7aWYoIXQpcmV0dXJuIHRoaXM7Zm9yKHZhciBuLHIsYSxoPXRoaXMuZGF0YSxvPXRoaXMudG9CQm94KHQpLHM9W10sbD1bXTtofHxzLmxlbmd0aDspe2lmKGh8fChoPXMucG9wKCkscj1zW3MubGVuZ3RoLTFdLG49bC5wb3AoKSxhPSEwKSxoLmxlYWYpe3ZhciBmPWUodCxoLmNoaWxkcmVuLGkpO2lmKC0xIT09ZilyZXR1cm4gaC5jaGlsZHJlbi5zcGxpY2UoZiwxKSxzLnB1c2goaCksdGhpcy5fY29uZGVuc2UocyksdGhpc31hfHxoLmxlYWZ8fCFtKGgsbyk/cj8obisrLGg9ci5jaGlsZHJlbltuXSxhPSExKTpoPW51bGw6KHMucHVzaChoKSxsLnB1c2gobiksbj0wLHI9aCxoPWguY2hpbGRyZW5bMF0pfXJldHVybiB0aGlzfSxyLnByb3RvdHlwZS50b0JCb3g9ZnVuY3Rpb24odCl7cmV0dXJuIHR9LHIucHJvdG90eXBlLmNvbXBhcmVNaW5YPWZ1bmN0aW9uKHQsaSl7cmV0dXJuIHQubWluWC1pLm1pblh9LHIucHJvdG90eXBlLmNvbXBhcmVNaW5ZPWZ1bmN0aW9uKHQsaSl7cmV0dXJuIHQubWluWS1pLm1pbll9LHIucHJvdG90eXBlLnRvSlNPTj1mdW5jdGlvbigpe3JldHVybiB0aGlzLmRhdGF9LHIucHJvdG90eXBlLmZyb21KU09OPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmRhdGE9dCx0aGlzfSxyLnByb3RvdHlwZS5fYWxsPWZ1bmN0aW9uKHQsaSl7Zm9yKHZhciBuPVtdO3Q7KXQubGVhZj9pLnB1c2guYXBwbHkoaSx0LmNoaWxkcmVuKTpuLnB1c2guYXBwbHkobix0LmNoaWxkcmVuKSx0PW4ucG9wKCk7cmV0dXJuIGl9LHIucHJvdG90eXBlLl9idWlsZD1mdW5jdGlvbih0LGksbixyKXt2YXIgZSxoPW4taSsxLG89dGhpcy5fbWF4RW50cmllcztpZihoPD1vKXJldHVybiBhKGU9cCh0LnNsaWNlKGksbisxKSksdGhpcy50b0JCb3gpLGU7cnx8KHI9TWF0aC5jZWlsKE1hdGgubG9nKGgpL01hdGgubG9nKG8pKSxvPU1hdGguY2VpbChoL01hdGgucG93KG8sci0xKSkpLChlPXAoW10pKS5sZWFmPSExLGUuaGVpZ2h0PXI7dmFyIHM9TWF0aC5jZWlsKGgvbyksbD1zKk1hdGguY2VpbChNYXRoLnNxcnQobykpO2QodCxpLG4sbCx0aGlzLmNvbXBhcmVNaW5YKTtmb3IodmFyIGY9aTtmPD1uO2YrPWwpe3ZhciB1PU1hdGgubWluKGYrbC0xLG4pO2QodCxmLHUscyx0aGlzLmNvbXBhcmVNaW5ZKTtmb3IodmFyIG09ZjttPD11O20rPXMpe3ZhciBjPU1hdGgubWluKG0rcy0xLHUpO2UuY2hpbGRyZW4ucHVzaCh0aGlzLl9idWlsZCh0LG0sYyxyLTEpKX19cmV0dXJuIGEoZSx0aGlzLnRvQkJveCksZX0sci5wcm90b3R5cGUuX2Nob29zZVN1YnRyZWU9ZnVuY3Rpb24odCxpLG4scil7Zm9yKDtyLnB1c2goaSksIWkubGVhZiYmci5sZW5ndGgtMSE9PW47KXtmb3IodmFyIGU9MS8wLGE9MS8wLGg9dm9pZCAwLG89MDtvPGkuY2hpbGRyZW4ubGVuZ3RoO28rKyl7dmFyIHM9aS5jaGlsZHJlbltvXSxsPWYocyksdT0obT10LGM9cywoTWF0aC5tYXgoYy5tYXhYLG0ubWF4WCktTWF0aC5taW4oYy5taW5YLG0ubWluWCkpKihNYXRoLm1heChjLm1heFksbS5tYXhZKS1NYXRoLm1pbihjLm1pblksbS5taW5ZKSktbCk7dTxhPyhhPXUsZT1sPGU/bDplLGg9cyk6dT09PWEmJmw8ZSYmKGU9bCxoPXMpfWk9aHx8aS5jaGlsZHJlblswXX12YXIgbSxjO3JldHVybiBpfSxyLnByb3RvdHlwZS5faW5zZXJ0PWZ1bmN0aW9uKHQsaSxuKXt2YXIgcj1uP3Q6dGhpcy50b0JCb3godCksZT1bXSxhPXRoaXMuX2Nob29zZVN1YnRyZWUocix0aGlzLmRhdGEsaSxlKTtmb3IoYS5jaGlsZHJlbi5wdXNoKHQpLG8oYSxyKTtpPj0wJiZlW2ldLmNoaWxkcmVuLmxlbmd0aD50aGlzLl9tYXhFbnRyaWVzOyl0aGlzLl9zcGxpdChlLGkpLGktLTt0aGlzLl9hZGp1c3RQYXJlbnRCQm94ZXMocixlLGkpfSxyLnByb3RvdHlwZS5fc3BsaXQ9ZnVuY3Rpb24odCxpKXt2YXIgbj10W2ldLHI9bi5jaGlsZHJlbi5sZW5ndGgsZT10aGlzLl9taW5FbnRyaWVzO3RoaXMuX2Nob29zZVNwbGl0QXhpcyhuLGUscik7dmFyIGg9dGhpcy5fY2hvb3NlU3BsaXRJbmRleChuLGUsciksbz1wKG4uY2hpbGRyZW4uc3BsaWNlKGgsbi5jaGlsZHJlbi5sZW5ndGgtaCkpO28uaGVpZ2h0PW4uaGVpZ2h0LG8ubGVhZj1uLmxlYWYsYShuLHRoaXMudG9CQm94KSxhKG8sdGhpcy50b0JCb3gpLGk/dFtpLTFdLmNoaWxkcmVuLnB1c2gobyk6dGhpcy5fc3BsaXRSb290KG4sbyl9LHIucHJvdG90eXBlLl9zcGxpdFJvb3Q9ZnVuY3Rpb24odCxpKXt0aGlzLmRhdGE9cChbdCxpXSksdGhpcy5kYXRhLmhlaWdodD10LmhlaWdodCsxLHRoaXMuZGF0YS5sZWFmPSExLGEodGhpcy5kYXRhLHRoaXMudG9CQm94KX0sci5wcm90b3R5cGUuX2Nob29zZVNwbGl0SW5kZXg9ZnVuY3Rpb24odCxpLG4pe2Zvcih2YXIgcixlLGEsbyxzLGwsdSxtPTEvMCxjPTEvMCxwPWk7cDw9bi1pO3ArKyl7dmFyIGQ9aCh0LDAscCx0aGlzLnRvQkJveCkseD1oKHQscCxuLHRoaXMudG9CQm94KSx2PShlPWQsYT14LG89dm9pZCAwLHM9dm9pZCAwLGw9dm9pZCAwLHU9dm9pZCAwLG89TWF0aC5tYXgoZS5taW5YLGEubWluWCkscz1NYXRoLm1heChlLm1pblksYS5taW5ZKSxsPU1hdGgubWluKGUubWF4WCxhLm1heFgpLHU9TWF0aC5taW4oZS5tYXhZLGEubWF4WSksTWF0aC5tYXgoMCxsLW8pKk1hdGgubWF4KDAsdS1zKSksTT1mKGQpK2YoeCk7djxtPyhtPXYscj1wLGM9TTxjP006Yyk6dj09PW0mJk08YyYmKGM9TSxyPXApfXJldHVybiByfHxuLWl9LHIucHJvdG90eXBlLl9jaG9vc2VTcGxpdEF4aXM9ZnVuY3Rpb24odCxpLG4pe3ZhciByPXQubGVhZj90aGlzLmNvbXBhcmVNaW5YOnMsZT10LmxlYWY/dGhpcy5jb21wYXJlTWluWTpsO3RoaXMuX2FsbERpc3RNYXJnaW4odCxpLG4scik8dGhpcy5fYWxsRGlzdE1hcmdpbih0LGksbixlKSYmdC5jaGlsZHJlbi5zb3J0KHIpfSxyLnByb3RvdHlwZS5fYWxsRGlzdE1hcmdpbj1mdW5jdGlvbih0LGksbixyKXt0LmNoaWxkcmVuLnNvcnQocik7Zm9yKHZhciBlPXRoaXMudG9CQm94LGE9aCh0LDAsaSxlKSxzPWgodCxuLWksbixlKSxsPXUoYSkrdShzKSxmPWk7ZjxuLWk7ZisrKXt2YXIgbT10LmNoaWxkcmVuW2ZdO28oYSx0LmxlYWY/ZShtKTptKSxsKz11KGEpfWZvcih2YXIgYz1uLWktMTtjPj1pO2MtLSl7dmFyIHA9dC5jaGlsZHJlbltjXTtvKHMsdC5sZWFmP2UocCk6cCksbCs9dShzKX1yZXR1cm4gbH0sci5wcm90b3R5cGUuX2FkanVzdFBhcmVudEJCb3hlcz1mdW5jdGlvbih0LGksbil7Zm9yKHZhciByPW47cj49MDtyLS0pbyhpW3JdLHQpfSxyLnByb3RvdHlwZS5fY29uZGVuc2U9ZnVuY3Rpb24odCl7Zm9yKHZhciBpPXQubGVuZ3RoLTEsbj12b2lkIDA7aT49MDtpLS0pMD09PXRbaV0uY2hpbGRyZW4ubGVuZ3RoP2k+MD8obj10W2ktMV0uY2hpbGRyZW4pLnNwbGljZShuLmluZGV4T2YodFtpXSksMSk6dGhpcy5jbGVhcigpOmEodFtpXSx0aGlzLnRvQkJveCl9LHJ9KTtcbiIsImV4cG9ydCBkZWZhdWx0IHtcclxuICAgICd0eXBlJzogJ0ZlYXR1cmVDb2xsZWN0aW9uJyxcclxuICAgICdjcnMnOiB7XHJcbiAgICAgICd0eXBlJzogJ25hbWUnLFxyXG4gICAgICAncHJvcGVydGllcyc6IHtcclxuICAgICAgICAnbmFtZSc6ICdFUFNHOjQzMjYnLFxyXG4gICAgICB9LFxyXG4gICAgfSxcclxuICAgICdmZWF0dXJlcyc6IFtcclxuICAgICAgICB7IFwidHlwZVwiOiBcIkZlYXR1cmVcIiwgXCJwcm9wZXJ0aWVzXCI6IHsgXCJmaWRcIjogOCwgXCJuYW1lXCI6IFwiQ29tbXVuaXR5IE9yY2hhcmRcIiB9LCBcImdlb21ldHJ5XCI6IHsgXCJ0eXBlXCI6IFwiUG9seWdvblwiLCBcImNvb3JkaW5hdGVzXCI6IFsgWyBbIDAuMDk4NzIyNywgNTIuMjQ5NDk5OCBdLCBbIDAuMDk5NTMwNSwgNTIuMjQ4OTU4NyBdLCBbIDAuMTAwMjk0OSwgNTIuMjQ5NTgxOSBdLCBbIDAuMDk5OTMwOCwgNTIuMjQ5NzE2IF0sIFsgMC4wOTk1MDUyLCA1Mi4yNDk3NDcxIF0sIFsgMC4wOTkwMjM0LCA1Mi4yNDk2NTYyIF0sIFsgMC4wOTg3MjI3LCA1Mi4yNDk0OTk4IF0gXSBdIH0gfSxcclxuICAgICAgICB7IFwidHlwZVwiOiBcIkZlYXR1cmVcIiwgXCJwcm9wZXJ0aWVzXCI6IHsgXCJmaWRcIjogOSwgXCJuYW1lXCI6IFwiSG9saWRheSBJbm4gRmllbGRcIiB9LCBcImdlb21ldHJ5XCI6IHsgXCJ0eXBlXCI6IFwiUG9seWdvblwiLCBcImNvb3JkaW5hdGVzXCI6IFsgWyBbIDAuMTEzNTIwNywgNTIuMjQxMDc2OSBdLCBbIDAuMTEzMTY1NywgNTIuMjQwMjA3NCBdLCBbIDAuMTEzNzUyNSwgNTIuMjQwMTE0MiBdLCBbIDAuMTEzNjM2NiwgNTIuMjM5MzkxMSBdLCBbIDAuMTE1MDEzMiwgNTIuMjM5MDY3MiBdLCBbIDAuMTE0NDc3LCA1Mi4yMzc5MTgxIF0sIFsgMC4xMjA2MDYzLCA1Mi4yMzY2MjI1IF0sIFsgMC4xMjEzODg4LCA1Mi4yMzg0MjgzIF0sIFsgMC4xMTU4NjgxLCA1Mi4yNDAzMjI3IF0sIFsgMC4xMTM1MjA3LCA1Mi4yNDEwNzY5IF0gXSBdIH0gfSxcclxuICAgICAgICB7IFwidHlwZVwiOiBcIkZlYXR1cmVcIiwgXCJwcm9wZXJ0aWVzXCI6IHsgXCJmaWRcIjogMTAsIFwibmFtZVwiOiBcIldJIFdvb2RzXCIgfSwgXCJnZW9tZXRyeVwiOiB7IFwidHlwZVwiOiBcIlBvbHlnb25cIiwgXCJjb29yZGluYXRlc1wiOiBbIFsgWyAwLjA5NjA0OTMsIDUyLjI1MTA3NzcgXSwgWyAwLjA5NDcwODksIDUyLjI0OTk4NjYgXSwgWyAwLjA5NzA5OTgsIDUyLjI0OTAzMyBdLCBbIDAuMDk4MTQzMSwgNTIuMjQ4Njg3IF0sIFsgMC4wOTkyMzcxLCA1Mi4yNDg1NDUgXSwgWyAwLjA5OTQwMzcsIDUyLjI0ODc3NTcgXSwgWyAwLjA5NjA0OTMsIDUyLjI1MTA3NzcgXSBdIF0gfSB9LFxyXG4gICAgICAgIHsgXCJ0eXBlXCI6IFwiRmVhdHVyZVwiLCBcInByb3BlcnRpZXNcIjogeyBcImZpZFwiOiAxMSwgXCJuYW1lXCI6IFwiQ3JvZnQgQ2xvc2UgU2V0LUFzaWRlXCIgfSwgXCJnZW9tZXRyeVwiOiB7IFwidHlwZVwiOiBcIlBvbHlnb25cIiwgXCJjb29yZGluYXRlc1wiOiBbIFsgWyAwLjA5OTk2ODgsIDUyLjI2MDcxNDkgXSwgWyAwLjA5OTQ4MzQsIDUyLjI1OTkxIF0sIFsgMC4wOTkzODIsIDUyLjI1ODE5ODIgXSwgWyAwLjEwMTkzMjIsIDUyLjI1NzcwMTYgXSwgWyAwLjEwMjgyMzQsIDUyLjI1ODQ5NTQgXSwgWyAwLjEwMTcwNzcsIDUyLjI1OTEwOTYgXSwgWyAwLjA5OTk2ODgsIDUyLjI2MDcxNDkgXSBdIF0gfSB9LFxyXG4gICAgICAgIHsgXCJ0eXBlXCI6IFwiRmVhdHVyZVwiLCBcInByb3BlcnRpZXNcIjogeyBcImZpZFwiOiAxNCwgXCJuYW1lXCI6IFwiTG9uZyBNZWFkb3dcIiB9LCBcImdlb21ldHJ5XCI6IHsgXCJ0eXBlXCI6IFwiUG9seWdvblwiLCBcImNvb3JkaW5hdGVzXCI6IFsgWyBbIDAuMDkzNjEyNywgNTIuMjU1OTcwNiBdLCBbIDAuMDkzMjI4NywgNTIuMjU1MjM0NCBdLCBbIDAuMDk2NTY4NywgNTIuMjU0MjAxIF0sIFsgMC4wOTY4OTQ3LCA1Mi4yNTQ2OTc4IF0sIFsgMC4wOTUyMzU2LCA1Mi4yNTUxNzIzIF0sIFsgMC4wOTM2MTI3LCA1Mi4yNTU5NzA2IF0gXSBdIH0gfSxcclxuICAgICAgICB7IFwidHlwZVwiOiBcIkZlYXR1cmVcIiwgXCJwcm9wZXJ0aWVzXCI6IHsgXCJmaWRcIjogMTUsIFwibmFtZVwiOiBcIlJlY1wiIH0sIFwiZ2VvbWV0cnlcIjogeyBcInR5cGVcIjogXCJQb2x5Z29uXCIsIFwiY29vcmRpbmF0ZXNcIjogWyBbIFsgMC4xMTIzNTkyLCA1Mi4yNDQ1OTM1IF0sIFsgMC4xMTE5MTczLCA1Mi4yNDM4NzQ5IF0sIFsgMC4xMTI5NzUsIDUyLjI0MjUzNTEgXSwgWyAwLjExNDEyNywgNTIuMjQyNzM0OCBdLCBbIDAuMTE1NDMxMSwgNTIuMjQyNDIyIF0sIFsgMC4xMTQ0ODIsIDUyLjI0MTIxNTMgXSwgWyAwLjExNTQ2NzMsIDUyLjI0MDg5MTUgXSwgWyAwLjExNjMwMDUsIDUyLjI0MTU3OTEgXSwgWyAwLjExNjQ3NDQsIDUyLjI0MjE3NTggXSwgWyAwLjExNjkyMzYsIDUyLjI0MzQ1MzQgXSwgWyAwLjExMjM1OTIsIDUyLjI0NDU5MzUgXSBdIF0gfSB9LFxyXG4gICAgICAgIHsgXCJ0eXBlXCI6IFwiRmVhdHVyZVwiLCBcInByb3BlcnRpZXNcIjogeyBcImZpZFwiOiAxNiwgXCJuYW1lXCI6IFwiTWFub3IgRmllbGRcIiB9LCBcImdlb21ldHJ5XCI6IHsgXCJ0eXBlXCI6IFwiUG9seWdvblwiLCBcImNvb3JkaW5hdGVzXCI6IFsgWyBbIDAuMDk3ODQyLCA1Mi4yNTA3NTM3IF0sIFsgMC4wOTc2NTcyLCA1Mi4yNTAxNjE2IF0sIFsgMC4wOTg2ODc4LCA1Mi4yNDk1MDUxIF0sIFsgMC4wOTkwMDY2LCA1Mi4yNDk2NzM3IF0sIFsgMC4wOTk0ODg0LCA1Mi4yNDk3NTU3IF0sIFsgMC4wOTk5NDEyLCA1Mi4yNDk3MjY5IF0sIFsgMC4xMDAzMTM0LCA1Mi4yNDk1OTM4IF0sIFsgMC4xMDA3Njk5LCA1Mi4yNDk5NzA4IF0sIFsgMC4xMDAzMzk3LCA1Mi4yNTAwODE3IF0sIFsgMC4wOTk1MDI5LCA1Mi4yNTAyOTQ2IF0sIFsgMC4wOTkxNjQyLCA1Mi4yNTA0NjEgXSwgWyAwLjA5Nzg0MiwgNTIuMjUwNzUzNyBdIF0gXSB9IH0sXHJcbiAgICAgICAgeyBcInR5cGVcIjogXCJGZWF0dXJlXCIsIFwicHJvcGVydGllc1wiOiB7IFwiZmlkXCI6IDEsIFwibmFtZVwiOiBcIkJ1c3dheVwiIH0sIFwiZ2VvbWV0cnlcIjogeyBcInR5cGVcIjogXCJMaW5lU3RyaW5nXCIsIFwiY29vcmRpbmF0ZXNcIjogWyBbIDAuMDc5NTc1OSwgNTIuMjYyMjY5NSBdLCBbIDAuMDgyNzE0OCwgNTIuMjYwMDQ5NiBdLCBbIDAuMDkwOTgxLCA1Mi4yNTQ1NzQgXSwgWyAwLjA5NzY1NSwgNTIuMjUwMTQ5MyBdLCBbIDAuMTA2MjA0NSwgNTIuMjQ0NDY3MyBdLCBbIDAuMTA4ODg2MywgNTIuMjQyODIzNCBdLCBbIDAuMTEwNDE2NiwgNTIuMjQyMTU0NiBdLCBbIDAuMTExOTM4OSwgNTIuMjQxNzM4NyBdLCBbIDAuMTI0NTMyMiwgNTIuMjM3NTUwNiBdLCBbIDAuMTMwMDUyLCA1Mi4yMzU3NzM2IF0gXSB9IH0sXHJcbnsgXCJ0eXBlXCI6IFwiRmVhdHVyZVwiLCBcInByb3BlcnRpZXNcIjogeyBcImZpZFwiOiAyLCBcIm5hbWVcIjogXCJHaXJ0b24gQnJpZGxlIFBhdGhcIiB9LCBcImdlb21ldHJ5XCI6IHsgXCJ0eXBlXCI6IFwiTGluZVN0cmluZ1wiLCBcImNvb3JkaW5hdGVzXCI6IFsgWyAwLjA5NDc4NSwgNTIuMjUwMzMzMyBdLCBbIDAuMDkxNzcyNiwgNTIuMjUwOTA5NyBdLCBbIDAuMDkxNzA3OSwgNTIuMjUwOTE2NiBdLCBbIDAuMDkxNjM5LCA1Mi4yNTA4ODgzIF0sIFsgMC4wODk1NjM0LCA1Mi4yNDk0NTYzIF0sIFsgMC4wODg0ODUxLCA1Mi4yNDg3Mzc0IF0sIFsgMC4wODg0MTQsIDUyLjI0ODcwNDkgXSwgWyAwLjA4ODMzMzQsIDUyLjI0ODcxMSBdLCBbIDAuMDg4MTM1LCA1Mi4yNDg3OTExIF0sIFsgMC4wODY4MzczLCA1Mi4yNDkzMjA5IF0sIFsgMC4wODY3NDQ5LCA1Mi4yNDkzNDUzIF0sIFsgMC4wODY1NzU1LCA1Mi4yNDkzMTcgXSwgWyAwLjA4NjUxMzEsIDUyLjI0OTI3MjcgXSwgWyAwLjA4NjQyMzYsIDUyLjI0OTE3NzYgXSwgWyAwLjA4NjM2MzksIDUyLjI0OTExOTkgXSwgWyAwLjA4NjM2ODQsIDUyLjI0ODk2NDcgXSwgWyAwLjA4NjMzNzYsIDUyLjI0ODg5MzcgXSwgWyAwLjA4NjE4NTQsIDUyLjI0ODc5NTkgXSwgWyAwLjA4NjA5MDYsIDUyLjI0ODc0MzIgXSwgWyAwLjA4NjA0NjIsIDUyLjI0ODQzOTMgXSwgWyAwLjA4NTc2ODIsIDUyLjI0ODI2NSBdLCBbIDAuMDg1NzE0NywgNTIuMjQ4MjIxMiBdLCBbIDAuMDg1NDc0MywgNTIuMjQ3OTkxNyBdLCBbIDAuMDg1Mjk1OSwgNTIuMjQ3OTE0MSBdLCBbIDAuMDg1MTE1MywgNTIuMjQ3ODM3MyBdLCBbIDAuMDg0NzkzLCA1Mi4yNDc2NTc5IF0sIFsgMC4wODQ3Njg2LCA1Mi4yNDc2NDM1IF0sIFsgMC4wODQ3Njk1LCA1Mi4yNDc2NDM1IF0gXSB9IH0sXHJcbnsgXCJ0eXBlXCI6IFwiRmVhdHVyZVwiLCBcInByb3BlcnRpZXNcIjogeyBcImZpZFwiOiAzLCBcIm5hbWVcIjogXCJIaXN0b24tR2lydG9uIEZvb3RwYXRoXCIgfSwgXCJnZW9tZXRyeVwiOiB7IFwidHlwZVwiOiBcIkxpbmVTdHJpbmdcIiwgXCJjb29yZGluYXRlc1wiOiBbIFsgMC4wOTU5NzAzLCA1Mi4yNTExNDY1IF0sIFsgMC4wOTQ4Mjc0LCA1Mi4yNTAzMjI2IF0sIFsgMC4wOTQ2NjgsIDUyLjI1MDM0NDggXSwgWyAwLjA5NDMzMjksIDUyLjI1MDA1MzIgXSwgWyAwLjA5MzAxOTMsIDUyLjI0ODg3MTYgXSwgWyAwLjA5MTA3MzQsIDUyLjI0ODUwMDIgXSwgWyAwLjA5MDIzNjYsIDUyLjI0NzcyNzIgXSwgWyAwLjA5MDE2OTUsIDUyLjI0NzY2NjIgXSwgWyAwLjA5MDA1NTksIDUyLjI0NzYxNzQgXSwgWyAwLjA4OTU4NSwgNTIuMjQ3NjIxOSBdLCBbIDAuMDg5NDQ5MSwgNTIuMjQ3NjAxOSBdLCBbIDAuMDg5MzI0MSwgNTIuMjQ3NTEzOCBdLCBbIDAuMDg3OTQ0LCA1Mi4yNDY1NDM3IF0sIFsgMC4wODc3NDI0LCA1Mi4yNDYzOTEyIF0gXSB9IH0sXHJcbnsgXCJ0eXBlXCI6IFwiRmVhdHVyZVwiLCBcInByb3BlcnRpZXNcIjogeyBcImZpZFwiOiA0LCBcIm5hbWVcIjogXCJHaXJ0b24gV29vZCBFYXN0XCIgfSwgXCJnZW9tZXRyeVwiOiB7IFwidHlwZVwiOiBcIkxpbmVTdHJpbmdcIiwgXCJjb29yZGluYXRlc1wiOiBbIFsgMC4wOTY3MTE5LCA1Mi4yNDkxMjY2IF0sIFsgMC4wOTY1OTMzLCA1Mi4yNDkwMDUxIF0sIFsgMC4wOTQ5MDcsIDUyLjI0NzM0NCBdLCBbIDAuMDk0NDc2OCwgNTIuMjQ2OTE3IF0sIFsgMC4wOTM0Nzg4LCA1Mi4yNDcyNjA0IF0sIFsgMC4wOTMzNDEyLCA1Mi4yNDcxOTQ3IF0sIFsgMC4wOTMxMTQ4LCA1Mi4yNDcwNzkyIF0sIFsgMC4wOTMxMjQ3LCA1Mi4yNDY5NDk5IF0sIFsgMC4wOTMwNDU1LCA1Mi4yNDY4NjgxIF0sIFsgMC4wOTIyMzcyLCA1Mi4yNDYwMzEyIF0sIFsgMC4wOTIxNDg0LCA1Mi4yNDU4ODMyIF0sIFsgMC4wOTE5NjY5LCA1Mi4yNDU3MDIxIF0sIFsgMC4wOTE2NTA4LCA1Mi4yNDUzOTc0IF0sIFsgMC4wOTAxNDExLCA1Mi4yNDM5MzgyIF0sIFsgMC4wODkxNzc1LCA1Mi4yNDMwMTEzIF0sIFsgMC4wODg0OTg4LCA1Mi4yNDIzNzU5IF0gXSB9IH0sXHJcbnsgXCJ0eXBlXCI6IFwiRmVhdHVyZVwiLCBcInByb3BlcnRpZXNcIjogeyBcImZpZFwiOiA1LCBcIm5hbWVcIjogXCJNZXJlIFdheSBCcmlkbGUgUGF0aFwiIH0sIFwiZ2VvbWV0cnlcIjogeyBcInR5cGVcIjogXCJMaW5lU3RyaW5nXCIsIFwiY29vcmRpbmF0ZXNcIjogWyBbIDAuMTMwMDMyNywgNTIuMjM1Nzc1OCBdLCBbIDAuMTMwMzYyNCwgNTIuMjM2MTYwNyBdLCBbIDAuMTMwNTkyNCwgNTIuMjM2NDQ0NyBdLCBbIDAuMTMwNzEyLCA1Mi4yMzY0ODc5IF0sIFsgMC4xMzE1OTUsIDUyLjIzNjYwMTEgXSwgWyAwLjEzMTQ5OSwgNTIuMjM3MDcxNCBdLCBbIDAuMTMxNjEzMSwgNTIuMjM3MjU3NyBdLCBbIDAuMTMxNzI1NCwgNTIuMjM3NjA4MiBdLCBbIDAuMTMxOTExOSwgNTIuMjM3ODQ0NSBdLCBbIDAuMTMyMjg1LCA1Mi4yMzgzMjgxIF0sIFsgMC4xMzM0MzM0LCA1Mi4yMzk2NTY5IF0sIFsgMC4xMzM4NDQ1LCA1Mi4yNDAxMTMzIF0sIFsgMC4xMzcxNzY0LCA1Mi4yNDM4ODAzIF0sIFsgMC4xNDIzMjQ5LCA1Mi4yNDkzNDIgXSwgWyAwLjE0MjQ1OTgsIDUyLjI0OTU4NyBdLCBbIDAuMTQyODAwMywgNTIuMjUwMTI5OCBdLCBbIDAuMTQzNTA5MiwgNTIuMjUwODkxMSBdLCBbIDAuMTQ0Njg5NywgNTIuMjUyMTU1NiBdLCBbIDAuMTQ0ODYxOCwgNTIuMjUyMzQ1MiBdLCBbIDAuMTQ1Mzg4OCwgNTIuMjUyOTAyNCBdLCBbIDAuMTQ1OTc4NCwgNTIuMjUzNTI2MSBdIF0gfSB9LFxyXG57IFwidHlwZVwiOiBcIkZlYXR1cmVcIiwgXCJwcm9wZXJ0aWVzXCI6IHsgXCJmaWRcIjogNiwgXCJuYW1lXCI6IFwiQ2FtYnJpZGdlIFJkIHRvIEdpcnRvblwiIH0sIFwiZ2VvbWV0cnlcIjogeyBcInR5cGVcIjogXCJMaW5lU3RyaW5nXCIsIFwiY29vcmRpbmF0ZXNcIjogWyBbIDAuMTExMzQzNSwgNTIuMjMwNzU3NyBdLCBbIDAuMTEwODE2NCwgNTIuMjMwODcyIF0sIFsgMC4xMDc4MzUxLCA1Mi4yMzA2NDQ2IF0sIFsgMC4xMDc2NzAzLCA1Mi4yMzA1MTQyIF0sIFsgMC4xMDc2NjEyLCA1Mi4yMzA0MTIyIF0sIFsgMC4xMDc0NjIsIDUyLjIzMDM4IF0sIFsgMC4xMDY0NTg1LCA1Mi4yMjk3ODgxIF0sIFsgMC4xMDU4MTkyLCA1Mi4yMjkzOTc2IF0sIFsgMC4xMDUzMzM3LCA1Mi4yMjkxMTIgXSwgWyAwLjEwNDYzNDYsIDUyLjIyODc0NyBdLCBbIDAuMTAyNzE0NywgNTIuMjI3NzYxMiBdLCBbIDAuMTAxMTk4NiwgNTIuMjI3MDc4NCBdLCBbIDAuMTAxMTMxNiwgNTIuMjI2OTc4NSBdLCBbIDAuMTAwMDA5NSwgNTIuMjI2NDc1OSBdLCBbIDAuMDk5MzQ5MywgNTIuMjI2MTgyNSBdIF0gfSB9LFxyXG57IFwidHlwZVwiOiBcIkZlYXR1cmVcIiwgXCJwcm9wZXJ0aWVzXCI6IHsgXCJmaWRcIjogNywgXCJuYW1lXCI6IFwiR2F0ZWhvdXNlIC0gV2VzdHdpY2sgQnJpZGxlIFdheVwiIH0sIFwiZ2VvbWV0cnlcIjogeyBcInR5cGVcIjogXCJMaW5lU3RyaW5nXCIsIFwiY29vcmRpbmF0ZXNcIjogWyBbIDAuMDgzNTY0MiwgNTIuMjUyMzY3OCBdLCBbIDAuMDgzNDg2MywgNTIuMjUyNTg4NCBdLCBbIDAuMDgzNTc2OSwgNTIuMjUyNjc0OSBdLCBbIDAuMDgzNTUxNSwgNTIuMjUyNzgzNiBdLCBbIDAuMDgzMTE4NiwgNTIuMjUzMjAxNiBdLCBbIDAuMDgyNjc0OSwgNTIuMjUzNjQ1MSBdLCBbIDAuMDgyMjYxLCA1Mi4yNTQyNDg5IF0sIFsgMC4wODE5NDU5LCA1Mi4yNTQ0NDYyIF0sIFsgMC4wODE3MTQ5LCA1Mi4yNTQ2Mzk3IF0sIFsgMC4wODExMDYzLCA1Mi4yNTUzMTc3IF0sIFsgMC4wNzk5MTYzLCA1Mi4yNTY2NTMyIF0sIFsgMC4wNzg2MzIyLCA1Mi4yNTY2MDc3IF0sIFsgMC4wNzY3OTM3LCA1Mi4yNTY4OTgyIF0sIFsgMC4wNzY2NDE2LCA1Mi4yNTcxNjIxIF0sIFsgMC4wNzY3OTM3LCA1Mi4yNTc1NTQ1IF0sIFsgMC4wNzY5ODU3LCA1Mi4yNTc4NDcyIF0sIFsgMC4wNzcyNzczLCA1Mi4yNTgxODQ4IF0sIFsgMC4wNzc3NzU0LCA1Mi4yNTg1NTk2IF0sIFsgMC4wNzgyOTM5LCA1Mi4yNTg5MzczIF0sIFsgMC4wNzg0MzA3LCA1Mi4yNTkwODQyIF0sIFsgMC4wNzg0MjUyLCA1Mi4yNTkxMjM2IF0sIFsgMC4wNzc5OTMyLCA1Mi4yNTk2MjU1IF0sIFsgMC4wNzgwMjY3LCA1Mi4yNTk2ODcxIF0sIFsgMC4wNzkxODg3LCA1Mi4yNjAyMjk1IF0sIFsgMC4wNzkyNDEyLCA1Mi4yNjAyODk5IF0sIFsgMC4wNzkwNjAxLCA1Mi4yNjA1ODk1IF0sIFsgMC4wNzg4NzQ0LCA1Mi4yNjA4NTA2IF0sIFsgMC4wNzg2MzcxLCA1Mi4yNjExMjcyIF0sIFsgMC4wNzg0OTQsIDUyLjI2MTI5NTQgXSwgWyAwLjA3ODM1NTUsIDUyLjI2MTQxMTMgXSwgWyAwLjA3ODE2NDQsIDUyLjI2MTQ2MzkgXSwgWyAwLjA3ODA0NjIsIDUyLjI2MTUyNDMgXSwgWyAwLjA3Nzk3NTYsIDUyLjI2MTY0NTIgXSwgWyAwLjA3ODAzNTMsIDUyLjI2MTY4OTUgXSwgWyAwLjA3ODAzNTMsIDUyLjI2MTY4OTUgXSBdIH0gfSxcclxueyBcInR5cGVcIjogXCJGZWF0dXJlXCIsIFwicHJvcGVydGllc1wiOiB7IFwiZmlkXCI6IDgsIFwibmFtZVwiOiBcIlN0IEF1ZHJleSdzIHRvIE5ldyBTY2hvb2wgUmRcIiB9LCBcImdlb21ldHJ5XCI6IHsgXCJ0eXBlXCI6IFwiTGluZVN0cmluZ1wiLCBcImNvb3JkaW5hdGVzXCI6IFsgWyAwLjA5NzUyODEsIDUyLjI1MjMzNzYgXSwgWyAwLjA5NzQyMDMsIDUyLjI1MjE2ODcgXSwgWyAwLjA5NzMwNTMsIDUyLjI1MTk4MDYgXSwgWyAwLjA5Njc3NDQsIDUyLjI1MTEwOTcgXSwgWyAwLjA5NzI5NTEsIDUyLjI1MDkyNzUgXSwgWyAwLjA5NzY2NjksIDUyLjI1MDgwMjIgXSwgWyAwLjA5NzY5MzIsIDUyLjI1MDc3MDEgXSwgWyAwLjA5ODY1MzEsIDUyLjI1MDU2OTQgXSwgWyAwLjA5OTEyMzIsIDUyLjI1MDQ2NTQgXSwgWyAwLjA5OTU0MDIsIDUyLjI1MDI4OTIgXSwgWyAwLjA5OTc1OCwgNTIuMjUwMTk1OSBdLCBbIDAuMTAwMjE3OCwgNTIuMjUwMDg0OCBdLCBbIDAuMTAwNTgyNiwgNTIuMjQ5OTk1OSBdLCBbIDAuMTAwODU2OCwgNTIuMjQ5OTMyIF0sIFsgMC4xMDExMzY2LCA1Mi4yNDk4Njg4IF0sIFsgMC4xMDE5MDg2LCA1Mi4yNDk2OTkzIF0sIFsgMC4xMDIzNjc4LCA1Mi4yNDk1OTY3IF0sIFsgMC4xMDI5Nzc1LCA1Mi4yNDk0NTYgXSwgWyAwLjEwNDEwMzIsIDUyLjI0OTIxNjIgXSwgWyAwLjEwNDEyMDksIDUyLjI0OTE5MjEgXSwgWyAwLjEwNDEyMDksIDUyLjI0OTE2MDggXSwgWyAwLjEwMzk3OTYsIDUyLjI0ODk4MjQgXSwgWyAwLjEwMzg0MjQsIDUyLjI0ODgwNDMgXSwgWyAwLjEwMzU1MzksIDUyLjI0ODQzIF0sIFsgMC4xMDM2MTY0LCA1Mi4yNDg0MDk1IF0gXSB9IH0sXHJcbnsgXCJ0eXBlXCI6IFwiRmVhdHVyZVwiLCBcInByb3BlcnRpZXNcIjogeyBcImZpZFwiOiA5LCBcIm5hbWVcIjogXCJDcm9mdCBDbG9zZSBTZXQtYXNpZGUgdG8gV2VzdHdpY2tcIiB9LCBcImdlb21ldHJ5XCI6IHsgXCJ0eXBlXCI6IFwiTGluZVN0cmluZ1wiLCBcImNvb3JkaW5hdGVzXCI6IFsgWyAwLjA5OTI3OCwgNTIuMjU4NjA0MSBdLCBbIDAuMDk2NTI5NCwgNTIuMjU5MDk1MiBdLCBbIDAuMDk0MjI0NiwgNTIuMjU5NTIyNiBdLCBbIDAuMDkyNjg5NiwgNTIuMjU5ODI1OCBdLCBbIDAuMDkyMDE0LCA1Mi4yNTkyOTQ4IF0sIFsgMC4wOTE0MTcyLCA1Mi4yNTg4MzU4IF0sIFsgMC4wOTAzNzY2LCA1Mi4yNTkyMzMyIF0sIFsgMC4wODk5Mzg3LCA1Mi4yNTk0MjY4IF0sIFsgMC4wODkwNzExLCA1Mi4yNTk4MDk5IF0sIFsgMC4wODg0MDQ2LCA1Mi4yNjAwNDA1IF0sIFsgMC4wODU3OTA1LCA1Mi4yNjA5MDk2IF0sIFsgMC4wODQwNzUsIDUyLjI2MTUxNDQgXSwgWyAwLjA4MzY4MTksIDUyLjI2MTU4MjUgXSwgWyAwLjA4MzI0MTgsIDUyLjI2MTcwODYgXSwgWyAwLjA4MjMyMjEsIDUyLjI2MTk4IF0sIFsgMC4wODIxNzUsIDUyLjI2MjAyNiBdLCBbIDAuMDgxODcwNywgNTIuMjYyMTI5MSBdLCBbIDAuMDgxNDI1MSwgNTIuMjYyMzQ0MSBdLCBbIDAuMDgwNTA3LCA1Mi4yNjI4MDI4IF0sIFsgMC4wODAwNTQ3LCA1Mi4yNjMwMzA3IF0gXSB9IH0sXHJcbnsgXCJ0eXBlXCI6IFwiRmVhdHVyZVwiLCBcInByb3BlcnRpZXNcIjogeyBcImZpZFwiOiAxMCwgXCJuYW1lXCI6IFwiR3VubnMgV2F5IC0gQnJpZGxlIFBhdGhcIiB9LCBcImdlb21ldHJ5XCI6IHsgXCJ0eXBlXCI6IFwiTGluZVN0cmluZ1wiLCBcImNvb3JkaW5hdGVzXCI6IFsgWyAwLjEwMzQ5MjgsIDUyLjI1Nzk5MTIgXSwgWyAwLjEwMzMwOTksIDUyLjI1ODIxMTkgXSwgWyAwLjEwMjk4ODgsIDUyLjI1ODQ1OTEgXSwgWyAwLjEwMjM1MjIsIDUyLjI1ODgwOTIgXSwgWyAwLjEwMTg5ODksIDUyLjI1OTA3NjYgXSwgWyAwLjEwMTU1MzksIDUyLjI1OTQwNTMgXSwgWyAwLjEwMDYxMjksIDUyLjI2MDM1MjcgXSwgWyAwLjEwMDMwODYsIDUyLjI2MDU4NDYgXSwgWyAwLjA5OTk0MTgsIDUyLjI2MDc4MzEgXSwgWyAwLjA5OTc2OTMsIDUyLjI2MDg4NTQgXSwgWyAwLjA5OTQ1NjksIDUyLjI2MTAyMzkgXSwgWyAwLjA5ODYzOTUsIDUyLjI2MTQ5MjYgXSwgWyAwLjA5ODE0NDIsIDUyLjI2MTcwNjYgXSwgWyAwLjA5Njk5NTgsIDUyLjI2MjM2NzggXSwgWyAwLjA5NjYzNjMsIDUyLjI2MjU0NjIgXSwgWyAwLjA5NjMyOTUsIDUyLjI2Mjc1MjIgXSwgWyAwLjA5NTg0NzcsIDUyLjI2MzI4OTMgXSwgWyAwLjA5NTY1MDEsIDUyLjI2MzM5NDQgXSwgWyAwLjA5NTMxMjcsIDUyLjI2MzgxMTYgXSwgWyAwLjA5NTM1NjIsIDUyLjI2NDAwMzQgXSwgWyAwLjA5NTI2MTgsIDUyLjI2NDE5NTEgXSwgWyAwLjA5NDI0NzksIDUyLjI2NTE2NTQgXSwgWyAwLjA5Mzk5OCwgNTIuMjY1MzU3NiBdLCBbIDAuMDkzMDg2MiwgNTIuMjY1ODg2NiBdIF0gfSB9XHJcbiAgICAgICAgICAgIF0gICAgICAgIFxyXG59O1xyXG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvQ29sbGVjdGlvblxuICovXG5pbXBvcnQgQmFzZU9iamVjdCBmcm9tICcuL09iamVjdC5qcyc7XG5pbXBvcnQgQ29sbGVjdGlvbkV2ZW50VHlwZSBmcm9tICcuL0NvbGxlY3Rpb25FdmVudFR5cGUuanMnO1xuaW1wb3J0IEV2ZW50IGZyb20gJy4vZXZlbnRzL0V2ZW50LmpzJztcblxuLyoqXG4gKiBAZW51bSB7c3RyaW5nfVxuICogQHByaXZhdGVcbiAqL1xuY29uc3QgUHJvcGVydHkgPSB7XG4gIExFTkdUSDogJ2xlbmd0aCcsXG59O1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEV2ZW50cyBlbWl0dGVkIGJ5IHtAbGluayBtb2R1bGU6b2wvQ29sbGVjdGlvbn5Db2xsZWN0aW9ufSBpbnN0YW5jZXMgYXJlIGluc3RhbmNlcyBvZiB0aGlzXG4gKiB0eXBlLlxuICogQHRlbXBsYXRlIFRcbiAqL1xuZXhwb3J0IGNsYXNzIENvbGxlY3Rpb25FdmVudCBleHRlbmRzIEV2ZW50IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9Db2xsZWN0aW9uRXZlbnRUeXBlLmpzXCIpLmRlZmF1bHR9IHR5cGUgVHlwZS5cbiAgICogQHBhcmFtIHtUfSBlbGVtZW50IEVsZW1lbnQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBUaGUgaW5kZXggb2YgdGhlIGFkZGVkIG9yIHJlbW92ZWQgZWxlbWVudC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHR5cGUsIGVsZW1lbnQsIGluZGV4KSB7XG4gICAgc3VwZXIodHlwZSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZWxlbWVudCB0aGF0IGlzIGFkZGVkIHRvIG9yIHJlbW92ZWQgZnJvbSB0aGUgY29sbGVjdGlvbi5cbiAgICAgKiBAdHlwZSB7VH1cbiAgICAgKiBAYXBpXG4gICAgICovXG4gICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBpbmRleCBvZiB0aGUgYWRkZWQgb3IgcmVtb3ZlZCBlbGVtZW50LlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQGFwaVxuICAgICAqL1xuICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgfVxufVxuXG4vKioqXG4gKiBAdGVtcGxhdGUgVFxuICogQHRlbXBsYXRlIFJldHVyblxuICogQHR5cGVkZWYge2ltcG9ydChcIi4vT2JzZXJ2YWJsZVwiKS5PblNpZ25hdHVyZTxpbXBvcnQoXCIuL09ic2VydmFibGVcIikuRXZlbnRUeXBlcywgaW1wb3J0KFwiLi9ldmVudHMvRXZlbnQuanNcIikuZGVmYXVsdCwgUmV0dXJuPiAmXG4gKiAgIGltcG9ydChcIi4vT2JzZXJ2YWJsZVwiKS5PblNpZ25hdHVyZTxpbXBvcnQoXCIuL09iamVjdEV2ZW50VHlwZVwiKS5UeXBlc3wnY2hhbmdlOmxlbmd0aCcsIGltcG9ydChcIi4vT2JqZWN0XCIpLk9iamVjdEV2ZW50LCBSZXR1cm4+ICZcbiAqICAgaW1wb3J0KFwiLi9PYnNlcnZhYmxlXCIpLk9uU2lnbmF0dXJlPCdhZGQnfCdyZW1vdmUnLCBDb2xsZWN0aW9uRXZlbnQ8VD4sIFJldHVybj4gJlxuICogICBpbXBvcnQoXCIuL09ic2VydmFibGVcIikuQ29tYmluZWRPblNpZ25hdHVyZTxpbXBvcnQoXCIuL09ic2VydmFibGVcIikuRXZlbnRUeXBlc3xpbXBvcnQoXCIuL09iamVjdEV2ZW50VHlwZVwiKS5UeXBlc3xcbiAqICAgICAnY2hhbmdlOmxlbmd0aCd8J2FkZCd8J3JlbW92ZScsUmV0dXJuPn0gQ29sbGVjdGlvbk9uU2lnbmF0dXJlXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFt1bmlxdWU9ZmFsc2VdIERpc2FsbG93IHRoZSBzYW1lIGl0ZW0gZnJvbSBiZWluZyBhZGRlZCB0b1xuICogdGhlIGNvbGxlY3Rpb24gdHdpY2UuXG4gKi9cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBBbiBleHBhbmRlZCB2ZXJzaW9uIG9mIHN0YW5kYXJkIEpTIEFycmF5LCBhZGRpbmcgY29udmVuaWVuY2UgbWV0aG9kcyBmb3JcbiAqIG1hbmlwdWxhdGlvbi4gQWRkIGFuZCByZW1vdmUgY2hhbmdlcyB0byB0aGUgQ29sbGVjdGlvbiB0cmlnZ2VyIGEgQ29sbGVjdGlvblxuICogZXZlbnQuIE5vdGUgdGhhdCB0aGlzIGRvZXMgbm90IGNvdmVyIGNoYW5nZXMgdG8gdGhlIG9iamVjdHMgX3dpdGhpbl8gdGhlXG4gKiBDb2xsZWN0aW9uOyB0aGV5IHRyaWdnZXIgZXZlbnRzIG9uIHRoZSBhcHByb3ByaWF0ZSBvYmplY3QsIG5vdCBvbiB0aGVcbiAqIENvbGxlY3Rpb24gYXMgYSB3aG9sZS5cbiAqXG4gKiBAZmlyZXMgQ29sbGVjdGlvbkV2ZW50XG4gKlxuICogQHRlbXBsYXRlIFRcbiAqIEBhcGlcbiAqL1xuY2xhc3MgQ29sbGVjdGlvbiBleHRlbmRzIEJhc2VPYmplY3Qge1xuICAvKipcbiAgICogQHBhcmFtIHtBcnJheTxUPn0gW2FycmF5XSBBcnJheS5cbiAgICogQHBhcmFtIHtPcHRpb25zfSBbb3B0aW9uc10gQ29sbGVjdGlvbiBvcHRpb25zLlxuICAgKi9cbiAgY29uc3RydWN0b3IoYXJyYXksIG9wdGlvbnMpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgLyoqKlxuICAgICAqIEB0eXBlIHtDb2xsZWN0aW9uT25TaWduYXR1cmU8VCwgaW1wb3J0KFwiLi9ldmVudHNcIikuRXZlbnRzS2V5Pn1cbiAgICAgKi9cbiAgICB0aGlzLm9uO1xuXG4gICAgLyoqKlxuICAgICAqIEB0eXBlIHtDb2xsZWN0aW9uT25TaWduYXR1cmU8VCwgaW1wb3J0KFwiLi9ldmVudHNcIikuRXZlbnRzS2V5Pn1cbiAgICAgKi9cbiAgICB0aGlzLm9uY2U7XG5cbiAgICAvKioqXG4gICAgICogQHR5cGUge0NvbGxlY3Rpb25PblNpZ25hdHVyZTxULCB2b2lkPn1cbiAgICAgKi9cbiAgICB0aGlzLnVuO1xuXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMudW5pcXVlXyA9ICEhb3B0aW9ucy51bmlxdWU7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHshQXJyYXk8VD59XG4gICAgICovXG4gICAgdGhpcy5hcnJheV8gPSBhcnJheSA/IGFycmF5IDogW107XG5cbiAgICBpZiAodGhpcy51bmlxdWVfKSB7XG4gICAgICBmb3IgKGxldCBpID0gMCwgaWkgPSB0aGlzLmFycmF5Xy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0VW5pcXVlXyh0aGlzLmFycmF5X1tpXSwgaSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy51cGRhdGVMZW5ndGhfKCk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGFsbCBlbGVtZW50cyBmcm9tIHRoZSBjb2xsZWN0aW9uLlxuICAgKiBAYXBpXG4gICAqL1xuICBjbGVhcigpIHtcbiAgICB3aGlsZSAodGhpcy5nZXRMZW5ndGgoKSA+IDApIHtcbiAgICAgIHRoaXMucG9wKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBlbGVtZW50cyB0byB0aGUgY29sbGVjdGlvbi4gIFRoaXMgcHVzaGVzIGVhY2ggaXRlbSBpbiB0aGUgcHJvdmlkZWQgYXJyYXlcbiAgICogdG8gdGhlIGVuZCBvZiB0aGUgY29sbGVjdGlvbi5cbiAgICogQHBhcmFtIHshQXJyYXk8VD59IGFyciBBcnJheS5cbiAgICogQHJldHVybiB7Q29sbGVjdGlvbjxUPn0gVGhpcyBjb2xsZWN0aW9uLlxuICAgKiBAYXBpXG4gICAqL1xuICBleHRlbmQoYXJyKSB7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gYXJyLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgIHRoaXMucHVzaChhcnJbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBJdGVyYXRlIG92ZXIgZWFjaCBlbGVtZW50LCBjYWxsaW5nIHRoZSBwcm92aWRlZCBjYWxsYmFjay5cbiAgICogQHBhcmFtIHtmdW5jdGlvbihULCBudW1iZXIsIEFycmF5PFQ+KTogKn0gZiBUaGUgZnVuY3Rpb24gdG8gY2FsbFxuICAgKiAgICAgZm9yIGV2ZXJ5IGVsZW1lbnQuIFRoaXMgZnVuY3Rpb24gdGFrZXMgMyBhcmd1bWVudHMgKHRoZSBlbGVtZW50LCB0aGVcbiAgICogICAgIGluZGV4IGFuZCB0aGUgYXJyYXkpLiBUaGUgcmV0dXJuIHZhbHVlIGlzIGlnbm9yZWQuXG4gICAqIEBhcGlcbiAgICovXG4gIGZvckVhY2goZikge1xuICAgIGNvbnN0IGFycmF5ID0gdGhpcy5hcnJheV87XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gYXJyYXkubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgZihhcnJheVtpXSwgaSwgYXJyYXkpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYSByZWZlcmVuY2UgdG8gdGhlIHVuZGVybHlpbmcgQXJyYXkgb2JqZWN0LiBXYXJuaW5nOiBpZiB0aGUgYXJyYXlcbiAgICogaXMgbXV0YXRlZCwgbm8gZXZlbnRzIHdpbGwgYmUgZGlzcGF0Y2hlZCBieSB0aGUgY29sbGVjdGlvbiwgYW5kIHRoZVxuICAgKiBjb2xsZWN0aW9uJ3MgXCJsZW5ndGhcIiBwcm9wZXJ0eSB3b24ndCBiZSBpbiBzeW5jIHdpdGggdGhlIGFjdHVhbCBsZW5ndGhcbiAgICogb2YgdGhlIGFycmF5LlxuICAgKiBAcmV0dXJuIHshQXJyYXk8VD59IEFycmF5LlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRBcnJheSgpIHtcbiAgICByZXR1cm4gdGhpcy5hcnJheV87XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBlbGVtZW50IGF0IHRoZSBwcm92aWRlZCBpbmRleC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IEluZGV4LlxuICAgKiBAcmV0dXJuIHtUfSBFbGVtZW50LlxuICAgKiBAYXBpXG4gICAqL1xuICBpdGVtKGluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMuYXJyYXlfW2luZGV4XTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGxlbmd0aCBvZiB0aGlzIGNvbGxlY3Rpb24uXG4gICAqIEByZXR1cm4ge251bWJlcn0gVGhlIGxlbmd0aCBvZiB0aGUgYXJyYXkuXG4gICAqIEBvYnNlcnZhYmxlXG4gICAqIEBhcGlcbiAgICovXG4gIGdldExlbmd0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoUHJvcGVydHkuTEVOR1RIKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnNlcnQgYW4gZWxlbWVudCBhdCB0aGUgcHJvdmlkZWQgaW5kZXguXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBJbmRleC5cbiAgICogQHBhcmFtIHtUfSBlbGVtIEVsZW1lbnQuXG4gICAqIEBhcGlcbiAgICovXG4gIGluc2VydEF0KGluZGV4LCBlbGVtKSB7XG4gICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+IHRoaXMuZ2V0TGVuZ3RoKCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5kZXggb3V0IG9mIGJvdW5kczogJyArIGluZGV4KTtcbiAgICB9XG4gICAgaWYgKHRoaXMudW5pcXVlXykge1xuICAgICAgdGhpcy5hc3NlcnRVbmlxdWVfKGVsZW0pO1xuICAgIH1cbiAgICB0aGlzLmFycmF5Xy5zcGxpY2UoaW5kZXgsIDAsIGVsZW0pO1xuICAgIHRoaXMudXBkYXRlTGVuZ3RoXygpO1xuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChcbiAgICAgIG5ldyBDb2xsZWN0aW9uRXZlbnQoQ29sbGVjdGlvbkV2ZW50VHlwZS5BREQsIGVsZW0sIGluZGV4KVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIHRoZSBsYXN0IGVsZW1lbnQgb2YgdGhlIGNvbGxlY3Rpb24gYW5kIHJldHVybiBpdC5cbiAgICogUmV0dXJuIGB1bmRlZmluZWRgIGlmIHRoZSBjb2xsZWN0aW9uIGlzIGVtcHR5LlxuICAgKiBAcmV0dXJuIHtUfHVuZGVmaW5lZH0gRWxlbWVudC5cbiAgICogQGFwaVxuICAgKi9cbiAgcG9wKCkge1xuICAgIHJldHVybiB0aGlzLnJlbW92ZUF0KHRoaXMuZ2V0TGVuZ3RoKCkgLSAxKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnNlcnQgdGhlIHByb3ZpZGVkIGVsZW1lbnQgYXQgdGhlIGVuZCBvZiB0aGUgY29sbGVjdGlvbi5cbiAgICogQHBhcmFtIHtUfSBlbGVtIEVsZW1lbnQuXG4gICAqIEByZXR1cm4ge251bWJlcn0gTmV3IGxlbmd0aCBvZiB0aGUgY29sbGVjdGlvbi5cbiAgICogQGFwaVxuICAgKi9cbiAgcHVzaChlbGVtKSB7XG4gICAgaWYgKHRoaXMudW5pcXVlXykge1xuICAgICAgdGhpcy5hc3NlcnRVbmlxdWVfKGVsZW0pO1xuICAgIH1cbiAgICBjb25zdCBuID0gdGhpcy5nZXRMZW5ndGgoKTtcbiAgICB0aGlzLmluc2VydEF0KG4sIGVsZW0pO1xuICAgIHJldHVybiB0aGlzLmdldExlbmd0aCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSB0aGUgZmlyc3Qgb2NjdXJyZW5jZSBvZiBhbiBlbGVtZW50IGZyb20gdGhlIGNvbGxlY3Rpb24uXG4gICAqIEBwYXJhbSB7VH0gZWxlbSBFbGVtZW50LlxuICAgKiBAcmV0dXJuIHtUfHVuZGVmaW5lZH0gVGhlIHJlbW92ZWQgZWxlbWVudCBvciB1bmRlZmluZWQgaWYgbm9uZSBmb3VuZC5cbiAgICogQGFwaVxuICAgKi9cbiAgcmVtb3ZlKGVsZW0pIHtcbiAgICBjb25zdCBhcnIgPSB0aGlzLmFycmF5XztcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBhcnIubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgaWYgKGFycltpXSA9PT0gZWxlbSkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZW1vdmVBdChpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgdGhlIGVsZW1lbnQgYXQgdGhlIHByb3ZpZGVkIGluZGV4IGFuZCByZXR1cm4gaXQuXG4gICAqIFJldHVybiBgdW5kZWZpbmVkYCBpZiB0aGUgY29sbGVjdGlvbiBkb2VzIG5vdCBjb250YWluIHRoaXMgaW5kZXguXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBJbmRleC5cbiAgICogQHJldHVybiB7VHx1bmRlZmluZWR9IFZhbHVlLlxuICAgKiBAYXBpXG4gICAqL1xuICByZW1vdmVBdChpbmRleCkge1xuICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPj0gdGhpcy5nZXRMZW5ndGgoKSkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY29uc3QgcHJldiA9IHRoaXMuYXJyYXlfW2luZGV4XTtcbiAgICB0aGlzLmFycmF5Xy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIHRoaXMudXBkYXRlTGVuZ3RoXygpO1xuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChcbiAgICAgIC8qKiBAdHlwZSB7Q29sbGVjdGlvbkV2ZW50PFQ+fSAqLyAoXG4gICAgICAgIG5ldyBDb2xsZWN0aW9uRXZlbnQoQ29sbGVjdGlvbkV2ZW50VHlwZS5SRU1PVkUsIHByZXYsIGluZGV4KVxuICAgICAgKVxuICAgICk7XG4gICAgcmV0dXJuIHByZXY7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBlbGVtZW50IGF0IHRoZSBwcm92aWRlZCBpbmRleC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IEluZGV4LlxuICAgKiBAcGFyYW0ge1R9IGVsZW0gRWxlbWVudC5cbiAgICogQGFwaVxuICAgKi9cbiAgc2V0QXQoaW5kZXgsIGVsZW0pIHtcbiAgICBjb25zdCBuID0gdGhpcy5nZXRMZW5ndGgoKTtcbiAgICBpZiAoaW5kZXggPj0gbikge1xuICAgICAgdGhpcy5pbnNlcnRBdChpbmRleCwgZWxlbSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5kZXggb3V0IG9mIGJvdW5kczogJyArIGluZGV4KTtcbiAgICB9XG4gICAgaWYgKHRoaXMudW5pcXVlXykge1xuICAgICAgdGhpcy5hc3NlcnRVbmlxdWVfKGVsZW0sIGluZGV4KTtcbiAgICB9XG4gICAgY29uc3QgcHJldiA9IHRoaXMuYXJyYXlfW2luZGV4XTtcbiAgICB0aGlzLmFycmF5X1tpbmRleF0gPSBlbGVtO1xuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChcbiAgICAgIC8qKiBAdHlwZSB7Q29sbGVjdGlvbkV2ZW50PFQ+fSAqLyAoXG4gICAgICAgIG5ldyBDb2xsZWN0aW9uRXZlbnQoQ29sbGVjdGlvbkV2ZW50VHlwZS5SRU1PVkUsIHByZXYsIGluZGV4KVxuICAgICAgKVxuICAgICk7XG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KFxuICAgICAgLyoqIEB0eXBlIHtDb2xsZWN0aW9uRXZlbnQ8VD59ICovIChcbiAgICAgICAgbmV3IENvbGxlY3Rpb25FdmVudChDb2xsZWN0aW9uRXZlbnRUeXBlLkFERCwgZWxlbSwgaW5kZXgpXG4gICAgICApXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdXBkYXRlTGVuZ3RoXygpIHtcbiAgICB0aGlzLnNldChQcm9wZXJ0eS5MRU5HVEgsIHRoaXMuYXJyYXlfLmxlbmd0aCk7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtUfSBlbGVtIEVsZW1lbnQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbZXhjZXB0XSBPcHRpb25hbCBpbmRleCB0byBpZ25vcmUuXG4gICAqL1xuICBhc3NlcnRVbmlxdWVfKGVsZW0sIGV4Y2VwdCkge1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IHRoaXMuYXJyYXlfLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgIGlmICh0aGlzLmFycmF5X1tpXSA9PT0gZWxlbSAmJiBpICE9PSBleGNlcHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEdXBsaWNhdGUgaXRlbSBhZGRlZCB0byBhIHVuaXF1ZSBjb2xsZWN0aW9uJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IENvbGxlY3Rpb247XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvQ29sbGVjdGlvbkV2ZW50VHlwZVxuICovXG5cbi8qKlxuICogQGVudW0ge3N0cmluZ31cbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICAvKipcbiAgICogVHJpZ2dlcmVkIHdoZW4gYW4gaXRlbSBpcyBhZGRlZCB0byB0aGUgY29sbGVjdGlvbi5cbiAgICogQGV2ZW50IG1vZHVsZTpvbC9Db2xsZWN0aW9uLkNvbGxlY3Rpb25FdmVudCNhZGRcbiAgICogQGFwaVxuICAgKi9cbiAgQUREOiAnYWRkJyxcbiAgLyoqXG4gICAqIFRyaWdnZXJlZCB3aGVuIGFuIGl0ZW0gaXMgcmVtb3ZlZCBmcm9tIHRoZSBjb2xsZWN0aW9uLlxuICAgKiBAZXZlbnQgbW9kdWxlOm9sL0NvbGxlY3Rpb24uQ29sbGVjdGlvbkV2ZW50I3JlbW92ZVxuICAgKiBAYXBpXG4gICAqL1xuICBSRU1PVkU6ICdyZW1vdmUnLFxufTtcbiIsIi8qKlxuICogQG1vZHVsZSBvbC9EaXNwb3NhYmxlXG4gKi9cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBPYmplY3RzIHRoYXQgbmVlZCB0byBjbGVhbiB1cCBhZnRlciB0aGVtc2VsdmVzLlxuICovXG5jbGFzcyBEaXNwb3NhYmxlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgLyoqXG4gICAgICogVGhlIG9iamVjdCBoYXMgYWxyZWFkeSBiZWVuIGRpc3Bvc2VkLlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICB0aGlzLmRpc3Bvc2VkID0gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogQ2xlYW4gdXAuXG4gICAqL1xuICBkaXNwb3NlKCkge1xuICAgIGlmICghdGhpcy5kaXNwb3NlZCkge1xuICAgICAgdGhpcy5kaXNwb3NlZCA9IHRydWU7XG4gICAgICB0aGlzLmRpc3Bvc2VJbnRlcm5hbCgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBFeHRlbnNpb24gcG9pbnQgZm9yIGRpc3Bvc2FibGUgb2JqZWN0cy5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgZGlzcG9zZUludGVybmFsKCkge31cbn1cblxuZXhwb3J0IGRlZmF1bHQgRGlzcG9zYWJsZTtcbiIsIi8qKlxuICogQG1vZHVsZSBvbC9GZWF0dXJlXG4gKi9cbmltcG9ydCBCYXNlT2JqZWN0IGZyb20gJy4vT2JqZWN0LmpzJztcbmltcG9ydCBFdmVudFR5cGUgZnJvbSAnLi9ldmVudHMvRXZlbnRUeXBlLmpzJztcbmltcG9ydCB7YXNzZXJ0fSBmcm9tICcuL2Fzc2VydHMuanMnO1xuaW1wb3J0IHtsaXN0ZW4sIHVubGlzdGVuQnlLZXl9IGZyb20gJy4vZXZlbnRzLmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7dHlwZW9mIEZlYXR1cmV8dHlwZW9mIGltcG9ydChcIi4vcmVuZGVyL0ZlYXR1cmUuanNcIikuZGVmYXVsdH0gRmVhdHVyZUNsYXNzXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7RmVhdHVyZXxpbXBvcnQoXCIuL3JlbmRlci9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9IEZlYXR1cmVMaWtlXG4gKi9cblxuLyoqKlxuICogQHRlbXBsYXRlIFJldHVyblxuICogQHR5cGVkZWYge2ltcG9ydChcIi4vT2JzZXJ2YWJsZVwiKS5PblNpZ25hdHVyZTxpbXBvcnQoXCIuL09ic2VydmFibGVcIikuRXZlbnRUeXBlcywgaW1wb3J0KFwiLi9ldmVudHMvRXZlbnQuanNcIikuZGVmYXVsdCwgUmV0dXJuPiAmXG4gKiAgIGltcG9ydChcIi4vT2JzZXJ2YWJsZVwiKS5PblNpZ25hdHVyZTxpbXBvcnQoXCIuL09iamVjdEV2ZW50VHlwZVwiKS5UeXBlc3wnY2hhbmdlOmdlb21ldHJ5JywgaW1wb3J0KFwiLi9PYmplY3RcIikuT2JqZWN0RXZlbnQsIFJldHVybj4gJlxuICogICBpbXBvcnQoXCIuL09ic2VydmFibGVcIikuQ29tYmluZWRPblNpZ25hdHVyZTxpbXBvcnQoXCIuL09ic2VydmFibGVcIikuRXZlbnRUeXBlc3xpbXBvcnQoXCIuL09iamVjdEV2ZW50VHlwZVwiKS5UeXBlc1xuICogICAgIHwnY2hhbmdlOmdlb21ldHJ5JywgUmV0dXJuPn0gRmVhdHVyZU9uU2lnbmF0dXJlXG4gKi9cblxuLyoqKlxuICogQHRlbXBsYXRlIEdlb21ldHJ5XG4gKiBAdHlwZWRlZiB7T2JqZWN0PHN0cmluZywgKj4gJiB7IGdlb21ldHJ5PzogR2VvbWV0cnkgfX0gT2JqZWN0V2l0aEdlb21ldHJ5XG4gKi9cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBBIHZlY3RvciBvYmplY3QgZm9yIGdlb2dyYXBoaWMgZmVhdHVyZXMgd2l0aCBhIGdlb21ldHJ5IGFuZCBvdGhlclxuICogYXR0cmlidXRlIHByb3BlcnRpZXMsIHNpbWlsYXIgdG8gdGhlIGZlYXR1cmVzIGluIHZlY3RvciBmaWxlIGZvcm1hdHMgbGlrZVxuICogR2VvSlNPTi5cbiAqXG4gKiBGZWF0dXJlcyBjYW4gYmUgc3R5bGVkIGluZGl2aWR1YWxseSB3aXRoIGBzZXRTdHlsZWA7IG90aGVyd2lzZSB0aGV5IHVzZSB0aGVcbiAqIHN0eWxlIG9mIHRoZWlyIHZlY3RvciBsYXllci5cbiAqXG4gKiBOb3RlIHRoYXQgYXR0cmlidXRlIHByb3BlcnRpZXMgYXJlIHNldCBhcyB7QGxpbmsgbW9kdWxlOm9sL09iamVjdH5CYXNlT2JqZWN0fSBwcm9wZXJ0aWVzIG9uXG4gKiB0aGUgZmVhdHVyZSBvYmplY3QsIHNvIHRoZXkgYXJlIG9ic2VydmFibGUsIGFuZCBoYXZlIGdldC9zZXQgYWNjZXNzb3JzLlxuICpcbiAqIFR5cGljYWxseSwgYSBmZWF0dXJlIGhhcyBhIHNpbmdsZSBnZW9tZXRyeSBwcm9wZXJ0eS4gWW91IGNhbiBzZXQgdGhlXG4gKiBnZW9tZXRyeSB1c2luZyB0aGUgYHNldEdlb21ldHJ5YCBtZXRob2QgYW5kIGdldCBpdCB3aXRoIGBnZXRHZW9tZXRyeWAuXG4gKiBJdCBpcyBwb3NzaWJsZSB0byBzdG9yZSBtb3JlIHRoYW4gb25lIGdlb21ldHJ5IG9uIGEgZmVhdHVyZSB1c2luZyBhdHRyaWJ1dGVcbiAqIHByb3BlcnRpZXMuIEJ5IGRlZmF1bHQsIHRoZSBnZW9tZXRyeSB1c2VkIGZvciByZW5kZXJpbmcgaXMgaWRlbnRpZmllZCBieVxuICogdGhlIHByb3BlcnR5IG5hbWUgYGdlb21ldHJ5YC4gSWYgeW91IHdhbnQgdG8gdXNlIGFub3RoZXIgZ2VvbWV0cnkgcHJvcGVydHlcbiAqIGZvciByZW5kZXJpbmcsIHVzZSB0aGUgYHNldEdlb21ldHJ5TmFtZWAgbWV0aG9kIHRvIGNoYW5nZSB0aGUgYXR0cmlidXRlXG4gKiBwcm9wZXJ0eSBhc3NvY2lhdGVkIHdpdGggdGhlIGdlb21ldHJ5IGZvciB0aGUgZmVhdHVyZS4gIEZvciBleGFtcGxlOlxuICpcbiAqIGBgYGpzXG4gKlxuICogaW1wb3J0IEZlYXR1cmUgZnJvbSAnb2wvRmVhdHVyZS5qcyc7XG4gKiBpbXBvcnQgUG9seWdvbiBmcm9tICdvbC9nZW9tL1BvbHlnb24uanMnO1xuICogaW1wb3J0IFBvaW50IGZyb20gJ29sL2dlb20vUG9pbnQuanMnO1xuICpcbiAqIGNvbnN0IGZlYXR1cmUgPSBuZXcgRmVhdHVyZSh7XG4gKiAgIGdlb21ldHJ5OiBuZXcgUG9seWdvbihwb2x5Q29vcmRzKSxcbiAqICAgbGFiZWxQb2ludDogbmV3IFBvaW50KGxhYmVsQ29vcmRzKSxcbiAqICAgbmFtZTogJ015IFBvbHlnb24nLFxuICogfSk7XG4gKlxuICogLy8gZ2V0IHRoZSBwb2x5Z29uIGdlb21ldHJ5XG4gKiBjb25zdCBwb2x5ID0gZmVhdHVyZS5nZXRHZW9tZXRyeSgpO1xuICpcbiAqIC8vIFJlbmRlciB0aGUgZmVhdHVyZSBhcyBhIHBvaW50IHVzaW5nIHRoZSBjb29yZGluYXRlcyBmcm9tIGxhYmVsUG9pbnRcbiAqIGZlYXR1cmUuc2V0R2VvbWV0cnlOYW1lKCdsYWJlbFBvaW50Jyk7XG4gKlxuICogLy8gZ2V0IHRoZSBwb2ludCBnZW9tZXRyeVxuICogY29uc3QgcG9pbnQgPSBmZWF0dXJlLmdldEdlb21ldHJ5KCk7XG4gKiBgYGBcbiAqXG4gKiBAYXBpXG4gKiBAdGVtcGxhdGUge2ltcG9ydChcIi4vZ2VvbS9HZW9tZXRyeS5qc1wiKS5kZWZhdWx0fSBbR2VvbWV0cnk9aW1wb3J0KFwiLi9nZW9tL0dlb21ldHJ5LmpzXCIpLmRlZmF1bHRdXG4gKi9cbmNsYXNzIEZlYXR1cmUgZXh0ZW5kcyBCYXNlT2JqZWN0IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7R2VvbWV0cnl8T2JqZWN0V2l0aEdlb21ldHJ5PEdlb21ldHJ5Pn0gW2dlb21ldHJ5T3JQcm9wZXJ0aWVzXVxuICAgKiAgICAgWW91IG1heSBwYXNzIGEgR2VvbWV0cnkgb2JqZWN0IGRpcmVjdGx5LCBvciBhbiBvYmplY3QgbGl0ZXJhbCBjb250YWluaW5nXG4gICAqICAgICBwcm9wZXJ0aWVzLiBJZiB5b3UgcGFzcyBhbiBvYmplY3QgbGl0ZXJhbCwgeW91IG1heSBpbmNsdWRlIGEgR2VvbWV0cnlcbiAgICogICAgIGFzc29jaWF0ZWQgd2l0aCBhIGBnZW9tZXRyeWAga2V5LlxuICAgKi9cbiAgY29uc3RydWN0b3IoZ2VvbWV0cnlPclByb3BlcnRpZXMpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgLyoqKlxuICAgICAqIEB0eXBlIHtGZWF0dXJlT25TaWduYXR1cmU8aW1wb3J0KFwiLi9ldmVudHNcIikuRXZlbnRzS2V5Pn1cbiAgICAgKi9cbiAgICB0aGlzLm9uO1xuXG4gICAgLyoqKlxuICAgICAqIEB0eXBlIHtGZWF0dXJlT25TaWduYXR1cmU8aW1wb3J0KFwiLi9ldmVudHNcIikuRXZlbnRzS2V5Pn1cbiAgICAgKi9cbiAgICB0aGlzLm9uY2U7XG5cbiAgICAvKioqXG4gICAgICogQHR5cGUge0ZlYXR1cmVPblNpZ25hdHVyZTx2b2lkPn1cbiAgICAgKi9cbiAgICB0aGlzLnVuO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfHN0cmluZ3x1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5pZF8gPSB1bmRlZmluZWQ7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5nZW9tZXRyeU5hbWVfID0gJ2dlb21ldHJ5JztcblxuICAgIC8qKlxuICAgICAqIFVzZXIgcHJvdmlkZWQgc3R5bGUuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi9zdHlsZS9TdHlsZS5qc1wiKS5TdHlsZUxpa2V9XG4gICAgICovXG4gICAgdGhpcy5zdHlsZV8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi9zdHlsZS9TdHlsZS5qc1wiKS5TdHlsZUZ1bmN0aW9ufHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLnN0eWxlRnVuY3Rpb25fID0gdW5kZWZpbmVkO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7P2ltcG9ydChcIi4vZXZlbnRzLmpzXCIpLkV2ZW50c0tleX1cbiAgICAgKi9cbiAgICB0aGlzLmdlb21ldHJ5Q2hhbmdlS2V5XyA9IG51bGw7XG5cbiAgICB0aGlzLmFkZENoYW5nZUxpc3RlbmVyKHRoaXMuZ2VvbWV0cnlOYW1lXywgdGhpcy5oYW5kbGVHZW9tZXRyeUNoYW5nZWRfKTtcblxuICAgIGlmIChnZW9tZXRyeU9yUHJvcGVydGllcykge1xuICAgICAgaWYgKFxuICAgICAgICB0eXBlb2YgKFxuICAgICAgICAgIC8qKiBAdHlwZSB7P30gKi8gKGdlb21ldHJ5T3JQcm9wZXJ0aWVzKS5nZXRTaW1wbGlmaWVkR2VvbWV0cnlcbiAgICAgICAgKSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgKSB7XG4gICAgICAgIGNvbnN0IGdlb21ldHJ5ID0gLyoqIEB0eXBlIHtHZW9tZXRyeX0gKi8gKGdlb21ldHJ5T3JQcm9wZXJ0aWVzKTtcbiAgICAgICAgdGhpcy5zZXRHZW9tZXRyeShnZW9tZXRyeSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvKiogQHR5cGUge09iamVjdDxzdHJpbmcsICo+fSAqL1xuICAgICAgICBjb25zdCBwcm9wZXJ0aWVzID0gZ2VvbWV0cnlPclByb3BlcnRpZXM7XG4gICAgICAgIHRoaXMuc2V0UHJvcGVydGllcyhwcm9wZXJ0aWVzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2xvbmUgdGhpcyBmZWF0dXJlLiBJZiB0aGUgb3JpZ2luYWwgZmVhdHVyZSBoYXMgYSBnZW9tZXRyeSBpdFxuICAgKiBpcyBhbHNvIGNsb25lZC4gVGhlIGZlYXR1cmUgaWQgaXMgbm90IHNldCBpbiB0aGUgY2xvbmUuXG4gICAqIEByZXR1cm4ge0ZlYXR1cmU8R2VvbWV0cnk+fSBUaGUgY2xvbmUuXG4gICAqIEBhcGlcbiAgICovXG4gIGNsb25lKCkge1xuICAgIGNvbnN0IGNsb25lID0gLyoqIEB0eXBlIHtGZWF0dXJlPEdlb21ldHJ5Pn0gKi8gKFxuICAgICAgbmV3IEZlYXR1cmUodGhpcy5oYXNQcm9wZXJ0aWVzKCkgPyB0aGlzLmdldFByb3BlcnRpZXMoKSA6IG51bGwpXG4gICAgKTtcbiAgICBjbG9uZS5zZXRHZW9tZXRyeU5hbWUodGhpcy5nZXRHZW9tZXRyeU5hbWUoKSk7XG4gICAgY29uc3QgZ2VvbWV0cnkgPSB0aGlzLmdldEdlb21ldHJ5KCk7XG4gICAgaWYgKGdlb21ldHJ5KSB7XG4gICAgICBjbG9uZS5zZXRHZW9tZXRyeSgvKiogQHR5cGUge0dlb21ldHJ5fSAqLyAoZ2VvbWV0cnkuY2xvbmUoKSkpO1xuICAgIH1cbiAgICBjb25zdCBzdHlsZSA9IHRoaXMuZ2V0U3R5bGUoKTtcbiAgICBpZiAoc3R5bGUpIHtcbiAgICAgIGNsb25lLnNldFN0eWxlKHN0eWxlKTtcbiAgICB9XG4gICAgcmV0dXJuIGNsb25lO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZmVhdHVyZSdzIGRlZmF1bHQgZ2VvbWV0cnkuICBBIGZlYXR1cmUgbWF5IGhhdmUgYW55IG51bWJlciBvZiBuYW1lZFxuICAgKiBnZW9tZXRyaWVzLiAgVGhlIFwiZGVmYXVsdFwiIGdlb21ldHJ5ICh0aGUgb25lIHRoYXQgaXMgcmVuZGVyZWQgYnkgZGVmYXVsdCkgaXNcbiAgICogc2V0IHdoZW4gY2FsbGluZyB7QGxpbmsgbW9kdWxlOm9sL0ZlYXR1cmV+RmVhdHVyZSNzZXRHZW9tZXRyeX0uXG4gICAqIEByZXR1cm4ge0dlb21ldHJ5fHVuZGVmaW5lZH0gVGhlIGRlZmF1bHQgZ2VvbWV0cnkgZm9yIHRoZSBmZWF0dXJlLlxuICAgKiBAYXBpXG4gICAqIEBvYnNlcnZhYmxlXG4gICAqL1xuICBnZXRHZW9tZXRyeSgpIHtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHtHZW9tZXRyeXx1bmRlZmluZWR9ICovICh0aGlzLmdldCh0aGlzLmdlb21ldHJ5TmFtZV8pKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGZlYXR1cmUgaWRlbnRpZmllci4gIFRoaXMgaXMgYSBzdGFibGUgaWRlbnRpZmllciBmb3IgdGhlIGZlYXR1cmUgYW5kXG4gICAqIGlzIGVpdGhlciBzZXQgd2hlbiByZWFkaW5nIGRhdGEgZnJvbSBhIHJlbW90ZSBzb3VyY2Ugb3Igc2V0IGV4cGxpY2l0bHkgYnlcbiAgICogY2FsbGluZyB7QGxpbmsgbW9kdWxlOm9sL0ZlYXR1cmV+RmVhdHVyZSNzZXRJZH0uXG4gICAqIEByZXR1cm4ge251bWJlcnxzdHJpbmd8dW5kZWZpbmVkfSBJZC5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0SWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaWRfO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbmFtZSBvZiB0aGUgZmVhdHVyZSdzIGRlZmF1bHQgZ2VvbWV0cnkuICBCeSBkZWZhdWx0LCB0aGUgZGVmYXVsdFxuICAgKiBnZW9tZXRyeSBpcyBuYW1lZCBgZ2VvbWV0cnlgLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IEdldCB0aGUgcHJvcGVydHkgbmFtZSBhc3NvY2lhdGVkIHdpdGggdGhlIGRlZmF1bHQgZ2VvbWV0cnlcbiAgICogICAgIGZvciB0aGlzIGZlYXR1cmUuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldEdlb21ldHJ5TmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5nZW9tZXRyeU5hbWVfO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZmVhdHVyZSdzIHN0eWxlLiBXaWxsIHJldHVybiB3aGF0IHdhcyBwcm92aWRlZCB0byB0aGVcbiAgICoge0BsaW5rIG1vZHVsZTpvbC9GZWF0dXJlfkZlYXR1cmUjc2V0U3R5bGV9IG1ldGhvZC5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi9zdHlsZS9TdHlsZS5qc1wiKS5TdHlsZUxpa2V8dW5kZWZpbmVkfSBUaGUgZmVhdHVyZSBzdHlsZS5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0U3R5bGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3R5bGVfO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZmVhdHVyZSdzIHN0eWxlIGZ1bmN0aW9uLlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuL3N0eWxlL1N0eWxlLmpzXCIpLlN0eWxlRnVuY3Rpb258dW5kZWZpbmVkfSBSZXR1cm4gYSBmdW5jdGlvblxuICAgKiByZXByZXNlbnRpbmcgdGhlIGN1cnJlbnQgc3R5bGUgb2YgdGhpcyBmZWF0dXJlLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRTdHlsZUZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnN0eWxlRnVuY3Rpb25fO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBoYW5kbGVHZW9tZXRyeUNoYW5nZV8oKSB7XG4gICAgdGhpcy5jaGFuZ2VkKCk7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGhhbmRsZUdlb21ldHJ5Q2hhbmdlZF8oKSB7XG4gICAgaWYgKHRoaXMuZ2VvbWV0cnlDaGFuZ2VLZXlfKSB7XG4gICAgICB1bmxpc3RlbkJ5S2V5KHRoaXMuZ2VvbWV0cnlDaGFuZ2VLZXlfKTtcbiAgICAgIHRoaXMuZ2VvbWV0cnlDaGFuZ2VLZXlfID0gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgZ2VvbWV0cnkgPSB0aGlzLmdldEdlb21ldHJ5KCk7XG4gICAgaWYgKGdlb21ldHJ5KSB7XG4gICAgICB0aGlzLmdlb21ldHJ5Q2hhbmdlS2V5XyA9IGxpc3RlbihcbiAgICAgICAgZ2VvbWV0cnksXG4gICAgICAgIEV2ZW50VHlwZS5DSEFOR0UsXG4gICAgICAgIHRoaXMuaGFuZGxlR2VvbWV0cnlDaGFuZ2VfLFxuICAgICAgICB0aGlzXG4gICAgICApO1xuICAgIH1cbiAgICB0aGlzLmNoYW5nZWQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGRlZmF1bHQgZ2VvbWV0cnkgZm9yIHRoZSBmZWF0dXJlLiAgVGhpcyB3aWxsIHVwZGF0ZSB0aGUgcHJvcGVydHlcbiAgICogd2l0aCB0aGUgbmFtZSByZXR1cm5lZCBieSB7QGxpbmsgbW9kdWxlOm9sL0ZlYXR1cmV+RmVhdHVyZSNnZXRHZW9tZXRyeU5hbWV9LlxuICAgKiBAcGFyYW0ge0dlb21ldHJ5fHVuZGVmaW5lZH0gZ2VvbWV0cnkgVGhlIG5ldyBnZW9tZXRyeS5cbiAgICogQGFwaVxuICAgKiBAb2JzZXJ2YWJsZVxuICAgKi9cbiAgc2V0R2VvbWV0cnkoZ2VvbWV0cnkpIHtcbiAgICB0aGlzLnNldCh0aGlzLmdlb21ldHJ5TmFtZV8sIGdlb21ldHJ5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHN0eWxlIGZvciB0aGUgZmVhdHVyZSB0byBvdmVycmlkZSB0aGUgbGF5ZXIgc3R5bGUuICBUaGlzIGNhbiBiZSBhXG4gICAqIHNpbmdsZSBzdHlsZSBvYmplY3QsIGFuIGFycmF5IG9mIHN0eWxlcywgb3IgYSBmdW5jdGlvbiB0aGF0IHRha2VzIGFcbiAgICogcmVzb2x1dGlvbiBhbmQgcmV0dXJucyBhbiBhcnJheSBvZiBzdHlsZXMuIFRvIHVuc2V0IHRoZSBmZWF0dXJlIHN0eWxlLCBjYWxsXG4gICAqIGBzZXRTdHlsZSgpYCB3aXRob3V0IGFyZ3VtZW50cyBvciBhIGZhbHNleSB2YWx1ZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL3N0eWxlL1N0eWxlLmpzXCIpLlN0eWxlTGlrZX0gW3N0eWxlXSBTdHlsZSBmb3IgdGhpcyBmZWF0dXJlLlxuICAgKiBAYXBpXG4gICAqIEBmaXJlcyBtb2R1bGU6b2wvZXZlbnRzL0V2ZW50fkJhc2VFdmVudCNldmVudDpjaGFuZ2VcbiAgICovXG4gIHNldFN0eWxlKHN0eWxlKSB7XG4gICAgdGhpcy5zdHlsZV8gPSBzdHlsZTtcbiAgICB0aGlzLnN0eWxlRnVuY3Rpb25fID0gIXN0eWxlID8gdW5kZWZpbmVkIDogY3JlYXRlU3R5bGVGdW5jdGlvbihzdHlsZSk7XG4gICAgdGhpcy5jaGFuZ2VkKCk7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBmZWF0dXJlIGlkLiAgVGhlIGZlYXR1cmUgaWQgaXMgY29uc2lkZXJlZCBzdGFibGUgYW5kIG1heSBiZSB1c2VkIHdoZW5cbiAgICogcmVxdWVzdGluZyBmZWF0dXJlcyBvciBjb21wYXJpbmcgaWRlbnRpZmllcnMgcmV0dXJuZWQgZnJvbSBhIHJlbW90ZSBzb3VyY2UuXG4gICAqIFRoZSBmZWF0dXJlIGlkIGNhbiBiZSB1c2VkIHdpdGggdGhlXG4gICAqIHtAbGluayBtb2R1bGU6b2wvc291cmNlL1ZlY3Rvcn5WZWN0b3JTb3VyY2UjZ2V0RmVhdHVyZUJ5SWR9IG1ldGhvZC5cbiAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfHVuZGVmaW5lZH0gaWQgVGhlIGZlYXR1cmUgaWQuXG4gICAqIEBhcGlcbiAgICogQGZpcmVzIG1vZHVsZTpvbC9ldmVudHMvRXZlbnR+QmFzZUV2ZW50I2V2ZW50OmNoYW5nZVxuICAgKi9cbiAgc2V0SWQoaWQpIHtcbiAgICB0aGlzLmlkXyA9IGlkO1xuICAgIHRoaXMuY2hhbmdlZCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgcHJvcGVydHkgbmFtZSB0byBiZSB1c2VkIHdoZW4gZ2V0dGluZyB0aGUgZmVhdHVyZSdzIGRlZmF1bHQgZ2VvbWV0cnkuXG4gICAqIFdoZW4gY2FsbGluZyB7QGxpbmsgbW9kdWxlOm9sL0ZlYXR1cmV+RmVhdHVyZSNnZXRHZW9tZXRyeX0sIHRoZSB2YWx1ZSBvZiB0aGUgcHJvcGVydHkgd2l0aFxuICAgKiB0aGlzIG5hbWUgd2lsbCBiZSByZXR1cm5lZC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIHByb3BlcnR5IG5hbWUgb2YgdGhlIGRlZmF1bHQgZ2VvbWV0cnkuXG4gICAqIEBhcGlcbiAgICovXG4gIHNldEdlb21ldHJ5TmFtZShuYW1lKSB7XG4gICAgdGhpcy5yZW1vdmVDaGFuZ2VMaXN0ZW5lcih0aGlzLmdlb21ldHJ5TmFtZV8sIHRoaXMuaGFuZGxlR2VvbWV0cnlDaGFuZ2VkXyk7XG4gICAgdGhpcy5nZW9tZXRyeU5hbWVfID0gbmFtZTtcbiAgICB0aGlzLmFkZENoYW5nZUxpc3RlbmVyKHRoaXMuZ2VvbWV0cnlOYW1lXywgdGhpcy5oYW5kbGVHZW9tZXRyeUNoYW5nZWRfKTtcbiAgICB0aGlzLmhhbmRsZUdlb21ldHJ5Q2hhbmdlZF8oKTtcbiAgfVxufVxuXG4vKipcbiAqIENvbnZlcnQgdGhlIHByb3ZpZGVkIG9iamVjdCBpbnRvIGEgZmVhdHVyZSBzdHlsZSBmdW5jdGlvbi4gIEZ1bmN0aW9ucyBwYXNzZWRcbiAqIHRocm91Z2ggdW5jaGFuZ2VkLiAgQXJyYXlzIG9mIFN0eWxlIG9yIHNpbmdsZSBzdHlsZSBvYmplY3RzIHdyYXBwZWRcbiAqIGluIGEgbmV3IGZlYXR1cmUgc3R5bGUgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyFpbXBvcnQoXCIuL3N0eWxlL1N0eWxlLmpzXCIpLlN0eWxlRnVuY3Rpb258IUFycmF5PGltcG9ydChcIi4vc3R5bGUvU3R5bGUuanNcIikuZGVmYXVsdD58IWltcG9ydChcIi4vc3R5bGUvU3R5bGUuanNcIikuZGVmYXVsdH0gb2JqXG4gKiAgICAgQSBmZWF0dXJlIHN0eWxlIGZ1bmN0aW9uLCBhIHNpbmdsZSBzdHlsZSwgb3IgYW4gYXJyYXkgb2Ygc3R5bGVzLlxuICogQHJldHVybiB7aW1wb3J0KFwiLi9zdHlsZS9TdHlsZS5qc1wiKS5TdHlsZUZ1bmN0aW9ufSBBIHN0eWxlIGZ1bmN0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU3R5bGVGdW5jdGlvbihvYmopIHtcbiAgaWYgKHR5cGVvZiBvYmogPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gb2JqO1xuICB9XG4gIC8qKlxuICAgKiBAdHlwZSB7QXJyYXk8aW1wb3J0KFwiLi9zdHlsZS9TdHlsZS5qc1wiKS5kZWZhdWx0Pn1cbiAgICovXG4gIGxldCBzdHlsZXM7XG4gIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICBzdHlsZXMgPSBvYmo7XG4gIH0gZWxzZSB7XG4gICAgYXNzZXJ0KFxuICAgICAgdHlwZW9mICgvKiogQHR5cGUgez99ICovIChvYmopLmdldFpJbmRleCkgPT09ICdmdW5jdGlvbicsXG4gICAgICAnRXhwZWN0ZWQgYW4gYG9sL3N0eWxlL1N0eWxlYCBvciBhbiBhcnJheSBvZiBgb2wvc3R5bGUvU3R5bGUuanNgJ1xuICAgICk7XG4gICAgY29uc3Qgc3R5bGUgPSAvKiogQHR5cGUge2ltcG9ydChcIi4vc3R5bGUvU3R5bGUuanNcIikuZGVmYXVsdH0gKi8gKG9iaik7XG4gICAgc3R5bGVzID0gW3N0eWxlXTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBzdHlsZXM7XG4gIH07XG59XG5leHBvcnQgZGVmYXVsdCBGZWF0dXJlO1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL0ltYWdlXG4gKi9cbmltcG9ydCBFdmVudFRhcmdldCBmcm9tICcuL2V2ZW50cy9UYXJnZXQuanMnO1xuaW1wb3J0IEV2ZW50VHlwZSBmcm9tICcuL2V2ZW50cy9FdmVudFR5cGUuanMnO1xuaW1wb3J0IEltYWdlU3RhdGUgZnJvbSAnLi9JbWFnZVN0YXRlLmpzJztcbmltcG9ydCB7Q1JFQVRFX0lNQUdFX0JJVE1BUCwgSU1BR0VfREVDT0RFfSBmcm9tICcuL2hhcy5qcyc7XG5pbXBvcnQge2xpc3Rlbk9uY2UsIHVubGlzdGVuQnlLZXl9IGZyb20gJy4vZXZlbnRzLmpzJztcbmltcG9ydCB7dG9Qcm9taXNlfSBmcm9tICcuL2Z1bmN0aW9ucy5qcyc7XG5cbi8qKlxuICogQSBmdW5jdGlvbiB0aGF0IHRha2VzIGFuIHtAbGluayBtb2R1bGU6b2wvSW1hZ2V+SW1hZ2VXcmFwcGVyfSBmb3IgdGhlIGltYWdlIGFuZCBhXG4gKiBge3N0cmluZ31gIGZvciB0aGUgc3JjIGFzIGFyZ3VtZW50cy4gSXQgaXMgc3VwcG9zZWQgdG8gbWFrZSBpdCBzbyB0aGVcbiAqIHVuZGVybHlpbmcgaW1hZ2Uge0BsaW5rIG1vZHVsZTpvbC9JbWFnZX5JbWFnZVdyYXBwZXIjZ2V0SW1hZ2V9IGlzIGFzc2lnbmVkIHRoZVxuICogY29udGVudCBzcGVjaWZpZWQgYnkgdGhlIHNyYy4gSWYgbm90IHNwZWNpZmllZCwgdGhlIGRlZmF1bHQgaXNcbiAqXG4gKiAgICAgZnVuY3Rpb24oaW1hZ2UsIHNyYykge1xuICogICAgICAgaW1hZ2UuZ2V0SW1hZ2UoKS5zcmMgPSBzcmM7XG4gKiAgICAgfVxuICpcbiAqIFByb3ZpZGluZyBhIGN1c3RvbSBgaW1hZ2VMb2FkRnVuY3Rpb25gIGNhbiBiZSB1c2VmdWwgdG8gbG9hZCBpbWFnZXMgd2l0aFxuICogcG9zdCByZXF1ZXN0cyBvciAtIGluIGdlbmVyYWwgLSB0aHJvdWdoIFhIUiByZXF1ZXN0cywgd2hlcmUgdGhlIHNyYyBvZiB0aGVcbiAqIGltYWdlIGVsZW1lbnQgd291bGQgYmUgc2V0IHRvIGEgZGF0YSBVUkkgd2hlbiB0aGUgY29udGVudCBpcyBsb2FkZWQuXG4gKlxuICogQHR5cGVkZWYge2Z1bmN0aW9uKGltcG9ydChcIi4vSW1hZ2UuanNcIikuZGVmYXVsdCwgc3RyaW5nKTogdm9pZH0gTG9hZEZ1bmN0aW9uXG4gKiBAYXBpXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBJbWFnZU9iamVjdFxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL2V4dGVudC5qc1wiKS5FeHRlbnR9IFtleHRlbnRdIEV4dGVudCwgaWYgZGlmZmVyZW50IGZyb20gdGhlIHJlcXVlc3RlZCBvbmUuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4vcmVzb2x1dGlvbi5qc1wiKS5SZXNvbHV0aW9uTGlrZX0gW3Jlc29sdXRpb25dIFJlc29sdXRpb24sIGlmIGRpZmZlcmVudCBmcm9tIHRoZSByZXF1ZXN0ZWQgb25lLlxuICogV2hlbiB4IGFuZCB5IHJlc29sdXRpb24gYXJlIGRpZmZlcmVudCwgdXNlIHRoZSBhcnJheSB0eXBlIChgW3hSZXNvbHV0aW9uLCB5UmVzb2x1dGlvbl1gKS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbcGl4ZWxSYXRpb10gUGl4ZWwgcmF0aW8sIGlmIGRpZmZlcmVudCBmcm9tIHRoZSByZXF1ZXN0ZWQgb25lLlxuICogQHByb3BlcnR5IHtpbXBvcnQoJy4vRGF0YVRpbGUuanMnKS5JbWFnZUxpa2V9IGltYWdlIEltYWdlLlxuICovXG5cbi8qKlxuICogTG9hZGVyIGZ1bmN0aW9uIHVzZWQgZm9yIGltYWdlIHNvdXJjZXMuIFJlY2VpdmVzIGV4dGVudCwgcmVzb2x1dGlvbiBhbmQgcGl4ZWwgcmF0aW8gYXMgYXJndW1lbnRzLlxuICogRm9yIGltYWdlcyB0aGF0IGNvdmVyIGFueSBleHRlbnQgYW5kIHJlc29sdXRpb24gKHN0YXRpYyBpbWFnZXMpLCB0aGUgbG9hZGVyIGZ1bmN0aW9uIHNob3VsZCBub3QgYWNjZXB0XG4gKiBhbnkgYXJndW1lbnRzLiBUaGUgZnVuY3Rpb24gcmV0dXJucyBhbiB7QGxpbmsgaW1wb3J0KFwiLi9EYXRhVGlsZS5qc1wiKS5JbWFnZUxpa2UgaW1hZ2V9LCBhblxuICoge0BsaW5rIGltcG9ydChcIi4vSW1hZ2UuanNcIikuSW1hZ2VPYmplY3QgaW1hZ2Ugb2JqZWN0fSwgb3IgYSBwcm9taXNlIGZvciB0aGUgc2FtZS5cbiAqIEZvciBsb2FkZXJzIHRoYXQgZ2VuZXJhdGUgaW1hZ2VzLCB0aGUgcHJvbWlzZSBzaG91bGQgbm90IHJlc29sdmUgdW50aWwgdGhlIGltYWdlIGlzIGxvYWRlZC5cbiAqIElmIHRoZSByZXR1cm5lZCBpbWFnZSBkb2VzIG5vdCBtYXRjaCB0aGUgZXh0ZW50LCByZXNvbHV0aW9uIG9yIHBpeGVsIHJhdGlvIHBhc3NlZCB0byB0aGUgbG9hZGVyLFxuICogaXQgaGFzIHRvIHJldHVybiBhbiB7QGxpbmsgaW1wb3J0KFwiLi9JbWFnZS5qc1wiKS5JbWFnZU9iamVjdCBpbWFnZSBvYmplY3R9IHdpdGggdGhlIGBpbWFnZWAgYW5kIHRoZVxuICogY29ycmVjdCBgZXh0ZW50YCwgYHJlc29sdXRpb25gIGFuZCBgcGl4ZWxSYXRpb2AuXG4gKlxuICogQHR5cGVkZWYge2Z1bmN0aW9uKGltcG9ydChcIi4vZXh0ZW50LmpzXCIpLkV4dGVudCwgbnVtYmVyLCBudW1iZXIsIChmdW5jdGlvbihIVE1MSW1hZ2VFbGVtZW50LCBzdHJpbmcpOiB2b2lkKT0pOiBpbXBvcnQoXCIuL0RhdGFUaWxlLmpzXCIpLkltYWdlTGlrZXxJbWFnZU9iamVjdHxQcm9taXNlPGltcG9ydChcIi4vRGF0YVRpbGUuanNcIikuSW1hZ2VMaWtlfEltYWdlT2JqZWN0Pn0gTG9hZGVyXG4gKiBAYXBpXG4gKi9cblxuLyoqXG4gKiBMb2FkZXIgZnVuY3Rpb24gdXNlZCBmb3IgaW1hZ2Ugc291cmNlcy4gUmVjZWl2ZXMgZXh0ZW50LCByZXNvbHV0aW9uIGFuZCBwaXhlbCByYXRpbyBhcyBhcmd1bWVudHMuXG4gKiBUaGUgZnVuY3Rpb24gcmV0dXJucyBhIHByb21pc2UgZm9yIGFuICB7QGxpbmsgaW1wb3J0KFwiLi9JbWFnZS5qc1wiKS5JbWFnZU9iamVjdCBpbWFnZSBvYmplY3R9LlxuICpcbiAqIEB0eXBlZGVmIHtmdW5jdGlvbihpbXBvcnQoXCIuL2V4dGVudC5qc1wiKS5FeHRlbnQsIG51bWJlciwgbnVtYmVyLCAoZnVuY3Rpb24oSFRNTEltYWdlRWxlbWVudCwgc3RyaW5nKTogdm9pZCk9KTogaW1wb3J0KFwiLi9EYXRhVGlsZS5qc1wiKS5JbWFnZUxpa2V8SW1hZ2VPYmplY3R8UHJvbWlzZTxpbXBvcnQoXCIuL0RhdGFUaWxlLmpzXCIpLkltYWdlTGlrZXxJbWFnZU9iamVjdD59IEltYWdlT2JqZWN0UHJvbWlzZUxvYWRlclxuICovXG5cbmNsYXNzIEltYWdlV3JhcHBlciBleHRlbmRzIEV2ZW50VGFyZ2V0IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9leHRlbnQuanNcIikuRXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICAgKiBAcGFyYW0ge251bWJlcnxBcnJheTxudW1iZXI+fHVuZGVmaW5lZH0gcmVzb2x1dGlvbiBSZXNvbHV0aW9uLiBJZiBwcm92aWRlZCBhcyBhcnJheSwgeCBhbmQgeVxuICAgKiByZXNvbHV0aW9uIHdpbGwgYmUgYXNzdW1lZC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHBpeGVsUmF0aW8gUGl4ZWwgcmF0aW8uXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9JbWFnZVN0YXRlLmpzXCIpLmRlZmF1bHR8aW1wb3J0KFwiLi9JbWFnZS5qc1wiKS5Mb2FkZXJ9IHN0YXRlT3JMb2FkZXIgU3RhdGUuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihleHRlbnQsIHJlc29sdXRpb24sIHBpeGVsUmF0aW8sIHN0YXRlT3JMb2FkZXIpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuL2V4dGVudC5qc1wiKS5FeHRlbnR9XG4gICAgICovXG4gICAgdGhpcy5leHRlbnQgPSBleHRlbnQ7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5waXhlbFJhdGlvXyA9IHBpeGVsUmF0aW87XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHR5cGUge251bWJlcnxBcnJheTxudW1iZXI+fHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLnJlc29sdXRpb24gPSByZXNvbHV0aW9uO1xuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuL0ltYWdlU3RhdGUuanNcIikuZGVmYXVsdH1cbiAgICAgKi9cbiAgICB0aGlzLnN0YXRlID1cbiAgICAgIHR5cGVvZiBzdGF0ZU9yTG9hZGVyID09PSAnZnVuY3Rpb24nID8gSW1hZ2VTdGF0ZS5JRExFIDogc3RhdGVPckxvYWRlcjtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydCgnLi9EYXRhVGlsZS5qcycpLkltYWdlTGlrZXxudWxsfVxuICAgICAqL1xuICAgIHRoaXMuaW1hZ2VfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi9JbWFnZS5qc1wiKS5Mb2FkZXJ9XG4gICAgICovXG4gICAgdGhpcy5sb2FkZXIgPSB0eXBlb2Ygc3RhdGVPckxvYWRlciA9PT0gJ2Z1bmN0aW9uJyA/IHN0YXRlT3JMb2FkZXIgOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIGNoYW5nZWQoKSB7XG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KEV2ZW50VHlwZS5DSEFOR0UpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gRXh0ZW50LlxuICAgKi9cbiAgZ2V0RXh0ZW50KCkge1xuICAgIHJldHVybiB0aGlzLmV4dGVudDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoJy4vRGF0YVRpbGUuanMnKS5JbWFnZUxpa2V9IEltYWdlLlxuICAgKi9cbiAgZ2V0SW1hZ2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW1hZ2VfO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn0gUGl4ZWxSYXRpby5cbiAgICovXG4gIGdldFBpeGVsUmF0aW8oKSB7XG4gICAgcmV0dXJuIHRoaXMucGl4ZWxSYXRpb187XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfEFycmF5PG51bWJlcj59IFJlc29sdXRpb24uXG4gICAqL1xuICBnZXRSZXNvbHV0aW9uKCkge1xuICAgIHJldHVybiAvKiogQHR5cGUge251bWJlcn0gKi8gKHRoaXMucmVzb2x1dGlvbik7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi9JbWFnZVN0YXRlLmpzXCIpLmRlZmF1bHR9IFN0YXRlLlxuICAgKi9cbiAgZ2V0U3RhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGU7XG4gIH1cblxuICAvKipcbiAgICogTG9hZCBub3QgeWV0IGxvYWRlZCBVUkkuXG4gICAqL1xuICBsb2FkKCkge1xuICAgIGlmICh0aGlzLnN0YXRlID09IEltYWdlU3RhdGUuSURMRSkge1xuICAgICAgaWYgKHRoaXMubG9hZGVyKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBJbWFnZVN0YXRlLkxPQURJTkc7XG4gICAgICAgIHRoaXMuY2hhbmdlZCgpO1xuICAgICAgICBjb25zdCByZXNvbHV0aW9uID0gdGhpcy5nZXRSZXNvbHV0aW9uKCk7XG4gICAgICAgIGNvbnN0IHJlcXVlc3RSZXNvbHV0aW9uID0gQXJyYXkuaXNBcnJheShyZXNvbHV0aW9uKVxuICAgICAgICAgID8gcmVzb2x1dGlvblswXVxuICAgICAgICAgIDogcmVzb2x1dGlvbjtcbiAgICAgICAgdG9Qcm9taXNlKCgpID0+XG4gICAgICAgICAgdGhpcy5sb2FkZXIodGhpcy5nZXRFeHRlbnQoKSwgcmVxdWVzdFJlc29sdXRpb24sIHRoaXMuZ2V0UGl4ZWxSYXRpbygpKVxuICAgICAgICApXG4gICAgICAgICAgLnRoZW4oKGltYWdlKSA9PiB7XG4gICAgICAgICAgICBpZiAoJ2ltYWdlJyBpbiBpbWFnZSkge1xuICAgICAgICAgICAgICB0aGlzLmltYWdlXyA9IGltYWdlLmltYWdlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCdleHRlbnQnIGluIGltYWdlKSB7XG4gICAgICAgICAgICAgIHRoaXMuZXh0ZW50ID0gaW1hZ2UuZXh0ZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCdyZXNvbHV0aW9uJyBpbiBpbWFnZSkge1xuICAgICAgICAgICAgICB0aGlzLnJlc29sdXRpb24gPSBpbWFnZS5yZXNvbHV0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCdwaXhlbFJhdGlvJyBpbiBpbWFnZSkge1xuICAgICAgICAgICAgICB0aGlzLnBpeGVsUmF0aW9fID0gaW1hZ2UucGl4ZWxSYXRpbztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgaW1hZ2UgaW5zdGFuY2VvZiBIVE1MSW1hZ2VFbGVtZW50IHx8XG4gICAgICAgICAgICAgIGltYWdlIGluc3RhbmNlb2YgSW1hZ2VCaXRtYXAgfHxcbiAgICAgICAgICAgICAgaW1hZ2UgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudCB8fFxuICAgICAgICAgICAgICBpbWFnZSBpbnN0YW5jZW9mIEhUTUxWaWRlb0VsZW1lbnRcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICB0aGlzLmltYWdlXyA9IGltYWdlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IEltYWdlU3RhdGUuTE9BREVEO1xuICAgICAgICAgIH0pXG4gICAgICAgICAgLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IEltYWdlU3RhdGUuRVJST1I7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zb2xlXG4gICAgICAgICAgfSlcbiAgICAgICAgICAuZmluYWxseSgoKSA9PiB0aGlzLmNoYW5nZWQoKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KCcuL0RhdGFUaWxlLmpzJykuSW1hZ2VMaWtlfSBpbWFnZSBUaGUgaW1hZ2UuXG4gICAqL1xuICBzZXRJbWFnZShpbWFnZSkge1xuICAgIHRoaXMuaW1hZ2VfID0gaW1hZ2U7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ8QXJyYXk8bnVtYmVyPn0gcmVzb2x1dGlvbiBSZXNvbHV0aW9uLlxuICAgKi9cbiAgc2V0UmVzb2x1dGlvbihyZXNvbHV0aW9uKSB7XG4gICAgdGhpcy5yZXNvbHV0aW9uID0gcmVzb2x1dGlvbjtcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL0RhdGFUaWxlLmpzJykuSW1hZ2VMaWtlfSBpbWFnZSBJbWFnZSBlbGVtZW50LlxuICogQHBhcmFtIHtmdW5jdGlvbigpOmFueX0gbG9hZEhhbmRsZXIgTG9hZCBjYWxsYmFjayBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKTphbnl9IGVycm9ySGFuZGxlciBFcnJvciBjYWxsYmFjayBmdW5jdGlvbi5cbiAqIEByZXR1cm4ge2Z1bmN0aW9uKCk6dm9pZH0gQ2FsbGJhY2sgdG8gc3RvcCBsaXN0ZW5pbmcuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsaXN0ZW5JbWFnZShpbWFnZSwgbG9hZEhhbmRsZXIsIGVycm9ySGFuZGxlcikge1xuICBjb25zdCBpbWcgPSAvKiogQHR5cGUge0hUTUxJbWFnZUVsZW1lbnR9ICovIChpbWFnZSk7XG4gIGxldCBsaXN0ZW5pbmcgPSB0cnVlO1xuICBsZXQgZGVjb2RpbmcgPSBmYWxzZTtcbiAgbGV0IGxvYWRlZCA9IGZhbHNlO1xuXG4gIGNvbnN0IGxpc3RlbmVyS2V5cyA9IFtcbiAgICBsaXN0ZW5PbmNlKGltZywgRXZlbnRUeXBlLkxPQUQsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGxvYWRlZCA9IHRydWU7XG4gICAgICBpZiAoIWRlY29kaW5nKSB7XG4gICAgICAgIGxvYWRIYW5kbGVyKCk7XG4gICAgICB9XG4gICAgfSksXG4gIF07XG5cbiAgaWYgKGltZy5zcmMgJiYgSU1BR0VfREVDT0RFKSB7XG4gICAgZGVjb2RpbmcgPSB0cnVlO1xuICAgIGltZ1xuICAgICAgLmRlY29kZSgpXG4gICAgICAudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChsaXN0ZW5pbmcpIHtcbiAgICAgICAgICBsb2FkSGFuZGxlcigpO1xuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICBpZiAobGlzdGVuaW5nKSB7XG4gICAgICAgICAgaWYgKGxvYWRlZCkge1xuICAgICAgICAgICAgbG9hZEhhbmRsZXIoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXJyb3JIYW5kbGVyKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBsaXN0ZW5lcktleXMucHVzaChsaXN0ZW5PbmNlKGltZywgRXZlbnRUeXBlLkVSUk9SLCBlcnJvckhhbmRsZXIpKTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiB1bmxpc3RlbigpIHtcbiAgICBsaXN0ZW5pbmcgPSBmYWxzZTtcbiAgICBsaXN0ZW5lcktleXMuZm9yRWFjaCh1bmxpc3RlbkJ5S2V5KTtcbiAgfTtcbn1cblxuLyoqXG4gKiBMb2FkcyBhbiBpbWFnZS5cbiAqIEBwYXJhbSB7SFRNTEltYWdlRWxlbWVudH0gaW1hZ2UgSW1hZ2UsIG5vdCB5ZXQgbG9hZGVkLlxuICogQHBhcmFtIHtzdHJpbmd9IFtzcmNdIGBzcmNgIGF0dHJpYnV0ZSBvZiB0aGUgaW1hZ2UuIE9wdGlvbmFsLCBub3QgcmVxdWlyZWQgaWYgYWxyZWFkeSBwcmVzZW50LlxuICogQHJldHVybiB7UHJvbWlzZTxIVE1MSW1hZ2VFbGVtZW50Pn0gUHJvbWlzZSByZXNvbHZpbmcgdG8gYW4gYEhUTUxJbWFnZUVsZW1lbnRgLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gbG9hZChpbWFnZSwgc3JjKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgZnVuY3Rpb24gaGFuZGxlTG9hZCgpIHtcbiAgICAgIHVubGlzdGVuKCk7XG4gICAgICByZXNvbHZlKGltYWdlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaGFuZGxlRXJyb3IoKSB7XG4gICAgICB1bmxpc3RlbigpO1xuICAgICAgcmVqZWN0KG5ldyBFcnJvcignSW1hZ2UgbG9hZCBlcnJvcicpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdW5saXN0ZW4oKSB7XG4gICAgICBpbWFnZS5yZW1vdmVFdmVudExpc3RlbmVyKCdsb2FkJywgaGFuZGxlTG9hZCk7XG4gICAgICBpbWFnZS5yZW1vdmVFdmVudExpc3RlbmVyKCdlcnJvcicsIGhhbmRsZUVycm9yKTtcbiAgICB9XG4gICAgaW1hZ2UuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIGhhbmRsZUxvYWQpO1xuICAgIGltYWdlLmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgaGFuZGxlRXJyb3IpO1xuICAgIGlmIChzcmMpIHtcbiAgICAgIGltYWdlLnNyYyA9IHNyYztcbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7SFRNTEltYWdlRWxlbWVudH0gaW1hZ2UgSW1hZ2UsIG5vdCB5ZXQgbG9hZGVkLlxuICogQHBhcmFtIHtzdHJpbmd9IFtzcmNdIGBzcmNgIGF0dHJpYnV0ZSBvZiB0aGUgaW1hZ2UuIE9wdGlvbmFsLCBub3QgcmVxdWlyZWQgaWYgYWxyZWFkeSBwcmVzZW50LlxuICogQHJldHVybiB7UHJvbWlzZTxIVE1MSW1hZ2VFbGVtZW50Pn0gUHJvbWlzZSByZXNvbHZpbmcgdG8gYW4gYEhUTUxJbWFnZUVsZW1lbnRgLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlRmFsbGJhY2soaW1hZ2UsIHNyYykge1xuICBpZiAoc3JjKSB7XG4gICAgaW1hZ2Uuc3JjID0gc3JjO1xuICB9XG4gIHJldHVybiBJTUFHRV9ERUNPREVcbiAgICA/IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+XG4gICAgICAgIGltYWdlLmRlY29kZSgpLnRoZW4oKCkgPT4gcmVzb2x2ZShpbWFnZSksIHJlamVjdClcbiAgICAgIClcbiAgICA6IGxvYWQoaW1hZ2UpO1xufVxuXG4vKipcbiAqIExvYWRzIGFuIGltYWdlIGFuZCBkZWNvZGVzIGl0IHRvIGFuIGBJbWFnZUJpdG1hcGAgaWYgYGNyZWF0ZUltYWdlQml0bWFwKClgIGlzIHN1cHBvcnRlZC4gUmV0dXJuc1xuICogdGhlIGxvYWRlZCBpbWFnZSBvdGhlcndpc2UuXG4gKiBAcGFyYW0ge0hUTUxJbWFnZUVsZW1lbnR9IGltYWdlIEltYWdlLCBub3QgeWV0IGxvYWRlZC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbc3JjXSBgc3JjYCBhdHRyaWJ1dGUgb2YgdGhlIGltYWdlLiBPcHRpb25hbCwgbm90IHJlcXVpcmVkIGlmIGFscmVhZHkgcHJlc2VudC5cbiAqIEByZXR1cm4ge1Byb21pc2U8SW1hZ2VCaXRtYXB8SFRNTEltYWdlRWxlbWVudD59IFByb21pc2UgcmVzb2x2aW5nIHRvIGFuIGBJbWFnZUJpdG1hcGAgb3IgYW5cbiAqIGBIVE1MSW1hZ2VFbGVtZW50YCBpZiBgY3JlYXRlSW1hZ2VCaXRtYXAoKWAgaXMgbm90IHN1cHBvcnRlZC5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZShpbWFnZSwgc3JjKSB7XG4gIGlmIChzcmMpIHtcbiAgICBpbWFnZS5zcmMgPSBzcmM7XG4gIH1cbiAgcmV0dXJuIElNQUdFX0RFQ09ERSAmJiBDUkVBVEVfSU1BR0VfQklUTUFQXG4gICAgPyBpbWFnZS5kZWNvZGUoKS50aGVuKCgpID0+IGNyZWF0ZUltYWdlQml0bWFwKGltYWdlKSlcbiAgICA6IGRlY29kZUZhbGxiYWNrKGltYWdlKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgSW1hZ2VXcmFwcGVyO1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL0ltYWdlU3RhdGVcbiAqL1xuXG4vKipcbiAqIEBlbnVtIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IHtcbiAgSURMRTogMCxcbiAgTE9BRElORzogMSxcbiAgTE9BREVEOiAyLFxuICBFUlJPUjogMyxcbiAgRU1QVFk6IDQsXG59O1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL0ltYWdlVGlsZVxuICovXG5pbXBvcnQgVGlsZSBmcm9tICcuL1RpbGUuanMnO1xuaW1wb3J0IFRpbGVTdGF0ZSBmcm9tICcuL1RpbGVTdGF0ZS5qcyc7XG5pbXBvcnQge2NyZWF0ZUNhbnZhc0NvbnRleHQyRH0gZnJvbSAnLi9kb20uanMnO1xuaW1wb3J0IHtsaXN0ZW5JbWFnZX0gZnJvbSAnLi9JbWFnZS5qcyc7XG5cbmNsYXNzIEltYWdlVGlsZSBleHRlbmRzIFRpbGUge1xuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL3RpbGVjb29yZC5qc1wiKS5UaWxlQ29vcmR9IHRpbGVDb29yZCBUaWxlIGNvb3JkaW5hdGUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9UaWxlU3RhdGUuanNcIikuZGVmYXVsdH0gc3RhdGUgU3RhdGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzcmMgSW1hZ2Ugc291cmNlIFVSSS5cbiAgICogQHBhcmFtIHs/c3RyaW5nfSBjcm9zc09yaWdpbiBDcm9zcyBvcmlnaW4uXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9UaWxlLmpzXCIpLkxvYWRGdW5jdGlvbn0gdGlsZUxvYWRGdW5jdGlvbiBUaWxlIGxvYWQgZnVuY3Rpb24uXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9UaWxlLmpzXCIpLk9wdGlvbnN9IFtvcHRpb25zXSBUaWxlIG9wdGlvbnMuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih0aWxlQ29vcmQsIHN0YXRlLCBzcmMsIGNyb3NzT3JpZ2luLCB0aWxlTG9hZEZ1bmN0aW9uLCBvcHRpb25zKSB7XG4gICAgc3VwZXIodGlsZUNvb3JkLCBzdGF0ZSwgb3B0aW9ucyk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHs/c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuY3Jvc3NPcmlnaW5fID0gY3Jvc3NPcmlnaW47XG5cbiAgICAvKipcbiAgICAgKiBJbWFnZSBVUklcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLnNyY18gPSBzcmM7XG5cbiAgICB0aGlzLmtleSA9IHNyYztcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0hUTUxJbWFnZUVsZW1lbnR8SFRNTENhbnZhc0VsZW1lbnR9XG4gICAgICovXG4gICAgdGhpcy5pbWFnZV8gPSBuZXcgSW1hZ2UoKTtcbiAgICBpZiAoY3Jvc3NPcmlnaW4gIT09IG51bGwpIHtcbiAgICAgIHRoaXMuaW1hZ2VfLmNyb3NzT3JpZ2luID0gY3Jvc3NPcmlnaW47XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7P2Z1bmN0aW9uKCk6dm9pZH1cbiAgICAgKi9cbiAgICB0aGlzLnVubGlzdGVuXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuL1RpbGUuanNcIikuTG9hZEZ1bmN0aW9ufVxuICAgICAqL1xuICAgIHRoaXMudGlsZUxvYWRGdW5jdGlvbl8gPSB0aWxlTG9hZEZ1bmN0aW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgSFRNTCBpbWFnZSBlbGVtZW50IGZvciB0aGlzIHRpbGUgKG1heSBiZSBhIENhbnZhcywgSW1hZ2UsIG9yIFZpZGVvKS5cbiAgICogQHJldHVybiB7SFRNTENhbnZhc0VsZW1lbnR8SFRNTEltYWdlRWxlbWVudHxIVE1MVmlkZW9FbGVtZW50fSBJbWFnZS5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0SW1hZ2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW1hZ2VfO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgYW4gSFRNTCBpbWFnZSBlbGVtZW50IGZvciB0aGlzIHRpbGUgKG1heSBiZSBhIENhbnZhcyBvciBwcmVsb2FkZWQgSW1hZ2UpLlxuICAgKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50fEhUTUxJbWFnZUVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudC5cbiAgICovXG4gIHNldEltYWdlKGVsZW1lbnQpIHtcbiAgICB0aGlzLmltYWdlXyA9IGVsZW1lbnQ7XG4gICAgdGhpcy5zdGF0ZSA9IFRpbGVTdGF0ZS5MT0FERUQ7XG4gICAgdGhpcy51bmxpc3RlbkltYWdlXygpO1xuICAgIHRoaXMuY2hhbmdlZCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRyYWNrcyBsb2FkaW5nIG9yIHJlYWQgZXJyb3JzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaGFuZGxlSW1hZ2VFcnJvcl8oKSB7XG4gICAgdGhpcy5zdGF0ZSA9IFRpbGVTdGF0ZS5FUlJPUjtcbiAgICB0aGlzLnVubGlzdGVuSW1hZ2VfKCk7XG4gICAgdGhpcy5pbWFnZV8gPSBnZXRCbGFua0ltYWdlKCk7XG4gICAgdGhpcy5jaGFuZ2VkKCk7XG4gIH1cblxuICAvKipcbiAgICogVHJhY2tzIHN1Y2Nlc3NmdWwgaW1hZ2UgbG9hZC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGhhbmRsZUltYWdlTG9hZF8oKSB7XG4gICAgY29uc3QgaW1hZ2UgPSAvKiogQHR5cGUge0hUTUxJbWFnZUVsZW1lbnR9ICovICh0aGlzLmltYWdlXyk7XG4gICAgaWYgKGltYWdlLm5hdHVyYWxXaWR0aCAmJiBpbWFnZS5uYXR1cmFsSGVpZ2h0KSB7XG4gICAgICB0aGlzLnN0YXRlID0gVGlsZVN0YXRlLkxPQURFRDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zdGF0ZSA9IFRpbGVTdGF0ZS5FTVBUWTtcbiAgICB9XG4gICAgdGhpcy51bmxpc3RlbkltYWdlXygpO1xuICAgIHRoaXMuY2hhbmdlZCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIExvYWQgdGhlIGltYWdlIG9yIHJldHJ5IGlmIGxvYWRpbmcgcHJldmlvdXNseSBmYWlsZWQuXG4gICAqIExvYWRpbmcgaXMgdGFrZW4gY2FyZSBvZiBieSB0aGUgdGlsZSBxdWV1ZSwgYW5kIGNhbGxpbmcgdGhpcyBtZXRob2QgaXNcbiAgICogb25seSBuZWVkZWQgZm9yIHByZWxvYWRpbmcgb3IgZm9yIHJlbG9hZGluZyBpbiBjYXNlIG9mIGFuIGVycm9yLlxuICAgKlxuICAgKiBUbyByZXRyeSBsb2FkaW5nIHRpbGVzIG9uIGZhaWxlZCByZXF1ZXN0cywgdXNlIGEgY3VzdG9tIGB0aWxlTG9hZEZ1bmN0aW9uYFxuICAgKiB0aGF0IGNoZWNrcyBmb3IgZXJyb3Igc3RhdHVzIGNvZGVzIGFuZCByZWxvYWRzIG9ubHkgd2hlbiB0aGUgc3RhdHVzIGNvZGUgaXNcbiAgICogNDA4LCA0MjksIDUwMCwgNTAyLCA1MDMgYW5kIDUwNCwgYW5kIG9ubHkgd2hlbiBub3QgdG9vIG1hbnkgcmV0cmllcyBoYXZlIGJlZW5cbiAgICogbWFkZSBhbHJlYWR5OlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiBjb25zdCByZXRyeUNvZGVzID0gWzQwOCwgNDI5LCA1MDAsIDUwMiwgNTAzLCA1MDRdO1xuICAgKiBjb25zdCByZXRyaWVzID0ge307XG4gICAqIHNvdXJjZS5zZXRUaWxlTG9hZEZ1bmN0aW9uKCh0aWxlLCBzcmMpID0+IHtcbiAgICogICBjb25zdCBpbWFnZSA9IHRpbGUuZ2V0SW1hZ2UoKTtcbiAgICogICBmZXRjaChzcmMpXG4gICAqICAgICAudGhlbigocmVzcG9uc2UpID0+IHtcbiAgICogICAgICAgaWYgKHJldHJ5Q29kZXMuaW5jbHVkZXMocmVzcG9uc2Uuc3RhdHVzKSkge1xuICAgKiAgICAgICAgIHJldHJpZXNbc3JjXSA9IChyZXRyaWVzW3NyY10gfHwgMCkgKyAxO1xuICAgKiAgICAgICAgIGlmIChyZXRyaWVzW3NyY10gPD0gMykge1xuICAgKiAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB0aWxlLmxvYWQoKSwgcmV0cmllc1tzcmNdICogMTAwMCk7XG4gICAqICAgICAgICAgfVxuICAgKiAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCgpO1xuICAgKiAgICAgICB9XG4gICAqICAgICAgIHJldHVybiByZXNwb25zZS5ibG9iKCk7XG4gICAqICAgICB9KVxuICAgKiAgICAgLnRoZW4oKGJsb2IpID0+IHtcbiAgICogICAgICAgY29uc3QgaW1hZ2VVcmwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuICAgKiAgICAgICBpbWFnZS5zcmMgPSBpbWFnZVVybDtcbiAgICogICAgICAgc2V0VGltZW91dCgoKSA9PiBVUkwucmV2b2tlT2JqZWN0VVJMKGltYWdlVXJsKSwgNTAwMCk7XG4gICAqICAgICB9KVxuICAgKiAgICAgLmNhdGNoKCgpID0+IHRpbGUuc2V0U3RhdGUoMykpOyAvLyBlcnJvclxuICAgKiB9KTtcbiAgICogYGBgXG4gICAqXG4gICAqIEBhcGlcbiAgICovXG4gIGxvYWQoKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUgPT0gVGlsZVN0YXRlLkVSUk9SKSB7XG4gICAgICB0aGlzLnN0YXRlID0gVGlsZVN0YXRlLklETEU7XG4gICAgICB0aGlzLmltYWdlXyA9IG5ldyBJbWFnZSgpO1xuICAgICAgaWYgKHRoaXMuY3Jvc3NPcmlnaW5fICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuaW1hZ2VfLmNyb3NzT3JpZ2luID0gdGhpcy5jcm9zc09yaWdpbl87XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLnN0YXRlID09IFRpbGVTdGF0ZS5JRExFKSB7XG4gICAgICB0aGlzLnN0YXRlID0gVGlsZVN0YXRlLkxPQURJTkc7XG4gICAgICB0aGlzLmNoYW5nZWQoKTtcbiAgICAgIHRoaXMudGlsZUxvYWRGdW5jdGlvbl8odGhpcywgdGhpcy5zcmNfKTtcbiAgICAgIHRoaXMudW5saXN0ZW5fID0gbGlzdGVuSW1hZ2UoXG4gICAgICAgIHRoaXMuaW1hZ2VfLFxuICAgICAgICB0aGlzLmhhbmRsZUltYWdlTG9hZF8uYmluZCh0aGlzKSxcbiAgICAgICAgdGhpcy5oYW5kbGVJbWFnZUVycm9yXy5iaW5kKHRoaXMpXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEaXNjYXJkcyBldmVudCBoYW5kbGVycyB3aGljaCBsaXN0ZW4gZm9yIGxvYWQgY29tcGxldGlvbiBvciBlcnJvcnMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB1bmxpc3RlbkltYWdlXygpIHtcbiAgICBpZiAodGhpcy51bmxpc3Rlbl8pIHtcbiAgICAgIHRoaXMudW5saXN0ZW5fKCk7XG4gICAgICB0aGlzLnVubGlzdGVuXyA9IG51bGw7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogR2V0IGEgMS1waXhlbCBibGFuayBpbWFnZS5cbiAqIEByZXR1cm4ge0hUTUxDYW52YXNFbGVtZW50fSBCbGFuayBpbWFnZS5cbiAqL1xuZnVuY3Rpb24gZ2V0QmxhbmtJbWFnZSgpIHtcbiAgY29uc3QgY3R4ID0gY3JlYXRlQ2FudmFzQ29udGV4dDJEKDEsIDEpO1xuICBjdHguZmlsbFN0eWxlID0gJ3JnYmEoMCwwLDAsMCknO1xuICBjdHguZmlsbFJlY3QoMCwgMCwgMSwgMSk7XG4gIHJldHVybiBjdHguY2FudmFzO1xufVxuXG5leHBvcnQgZGVmYXVsdCBJbWFnZVRpbGU7XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvS2luZXRpY1xuICovXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogSW1wbGVtZW50YXRpb24gb2YgaW5lcnRpYWwgZGVjZWxlcmF0aW9uIGZvciBtYXAgbW92ZW1lbnQuXG4gKlxuICogQGFwaVxuICovXG5jbGFzcyBLaW5ldGljIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkZWNheSBSYXRlIG9mIGRlY2F5IChtdXN0IGJlIG5lZ2F0aXZlKS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG1pblZlbG9jaXR5IE1pbmltdW0gdmVsb2NpdHkgKHBpeGVscy9taWxsaXNlY29uZCkuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkZWxheSBEZWxheSB0byBjb25zaWRlciB0byBjYWxjdWxhdGUgdGhlIGtpbmV0aWNcbiAgICogICAgIGluaXRpYWwgdmFsdWVzIChtaWxsaXNlY29uZHMpLlxuICAgKi9cbiAgY29uc3RydWN0b3IoZGVjYXksIG1pblZlbG9jaXR5LCBkZWxheSkge1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmRlY2F5XyA9IGRlY2F5O1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubWluVmVsb2NpdHlfID0gbWluVmVsb2NpdHk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5kZWxheV8gPSBkZWxheTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0FycmF5PG51bWJlcj59XG4gICAgICovXG4gICAgdGhpcy5wb2ludHNfID0gW107XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5hbmdsZV8gPSAwO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuaW5pdGlhbFZlbG9jaXR5XyA9IDA7XG4gIH1cblxuICAvKipcbiAgICogRklYTUUgZW1wdHkgZGVzY3JpcHRpb24gZm9yIGpzZG9jXG4gICAqL1xuICBiZWdpbigpIHtcbiAgICB0aGlzLnBvaW50c18ubGVuZ3RoID0gMDtcbiAgICB0aGlzLmFuZ2xlXyA9IDA7XG4gICAgdGhpcy5pbml0aWFsVmVsb2NpdHlfID0gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0geCBYLlxuICAgKiBAcGFyYW0ge251bWJlcn0geSBZLlxuICAgKi9cbiAgdXBkYXRlKHgsIHkpIHtcbiAgICB0aGlzLnBvaW50c18ucHVzaCh4LCB5LCBEYXRlLm5vdygpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHdlIHNob3VsZCBkbyBraW5ldGljIGFuaW1hdGlvbi5cbiAgICovXG4gIGVuZCgpIHtcbiAgICBpZiAodGhpcy5wb2ludHNfLmxlbmd0aCA8IDYpIHtcbiAgICAgIC8vIGF0IGxlYXN0IDIgcG9pbnRzIGFyZSByZXF1aXJlZCAoaS5lLiB0aGVyZSBtdXN0IGJlIGF0IGxlYXN0IDYgZWxlbWVudHNcbiAgICAgIC8vIGluIHRoZSBhcnJheSlcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgZGVsYXkgPSBEYXRlLm5vdygpIC0gdGhpcy5kZWxheV87XG4gICAgY29uc3QgbGFzdEluZGV4ID0gdGhpcy5wb2ludHNfLmxlbmd0aCAtIDM7XG4gICAgaWYgKHRoaXMucG9pbnRzX1tsYXN0SW5kZXggKyAyXSA8IGRlbGF5KSB7XG4gICAgICAvLyB0aGUgbGFzdCB0cmFja2VkIHBvaW50IGlzIHRvbyBvbGQsIHdoaWNoIG1lYW5zIHRoYXQgdGhlIHVzZXIgc3RvcHBlZFxuICAgICAgLy8gcGFubmluZyBiZWZvcmUgcmVsZWFzaW5nIHRoZSBtYXBcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBnZXQgdGhlIGZpcnN0IHBvaW50IHdoaWNoIHN0aWxsIGZhbGxzIGludG8gdGhlIGRlbGF5IHRpbWVcbiAgICBsZXQgZmlyc3RJbmRleCA9IGxhc3RJbmRleCAtIDM7XG4gICAgd2hpbGUgKGZpcnN0SW5kZXggPiAwICYmIHRoaXMucG9pbnRzX1tmaXJzdEluZGV4ICsgMl0gPiBkZWxheSkge1xuICAgICAgZmlyc3RJbmRleCAtPSAzO1xuICAgIH1cblxuICAgIGNvbnN0IGR1cmF0aW9uID0gdGhpcy5wb2ludHNfW2xhc3RJbmRleCArIDJdIC0gdGhpcy5wb2ludHNfW2ZpcnN0SW5kZXggKyAyXTtcbiAgICAvLyB3ZSBkb24ndCB3YW50IGEgZHVyYXRpb24gb2YgMCAoZGl2aWRlIGJ5IHplcm8pXG4gICAgLy8gd2UgYWxzbyBtYWtlIHN1cmUgdGhlIHVzZXIgcGFubmVkIGZvciBhIGR1cmF0aW9uIG9mIGF0IGxlYXN0IG9uZSBmcmFtZVxuICAgIC8vICgxLzYwcykgdG8gY29tcHV0ZSBzYW5lIGRpc3BsYWNlbWVudCB2YWx1ZXNcbiAgICBpZiAoZHVyYXRpb24gPCAxMDAwIC8gNjApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCBkeCA9IHRoaXMucG9pbnRzX1tsYXN0SW5kZXhdIC0gdGhpcy5wb2ludHNfW2ZpcnN0SW5kZXhdO1xuICAgIGNvbnN0IGR5ID0gdGhpcy5wb2ludHNfW2xhc3RJbmRleCArIDFdIC0gdGhpcy5wb2ludHNfW2ZpcnN0SW5kZXggKyAxXTtcbiAgICB0aGlzLmFuZ2xlXyA9IE1hdGguYXRhbjIoZHksIGR4KTtcbiAgICB0aGlzLmluaXRpYWxWZWxvY2l0eV8gPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpIC8gZHVyYXRpb247XG4gICAgcmV0dXJuIHRoaXMuaW5pdGlhbFZlbG9jaXR5XyA+IHRoaXMubWluVmVsb2NpdHlfO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn0gVG90YWwgZGlzdGFuY2UgdHJhdmVsbGVkIChwaXhlbHMpLlxuICAgKi9cbiAgZ2V0RGlzdGFuY2UoKSB7XG4gICAgcmV0dXJuICh0aGlzLm1pblZlbG9jaXR5XyAtIHRoaXMuaW5pdGlhbFZlbG9jaXR5XykgLyB0aGlzLmRlY2F5XztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IEFuZ2xlIG9mIHRoZSBraW5ldGljIHBhbm5pbmcgYW5pbWF0aW9uIChyYWRpYW5zKS5cbiAgICovXG4gIGdldEFuZ2xlKCkge1xuICAgIHJldHVybiB0aGlzLmFuZ2xlXztcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBLaW5ldGljO1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL01hcFxuICovXG5pbXBvcnQgQmFzZU9iamVjdCBmcm9tICcuL09iamVjdC5qcyc7XG5pbXBvcnQgQ29sbGVjdGlvbiBmcm9tICcuL0NvbGxlY3Rpb24uanMnO1xuaW1wb3J0IENvbGxlY3Rpb25FdmVudFR5cGUgZnJvbSAnLi9Db2xsZWN0aW9uRXZlbnRUeXBlLmpzJztcbmltcG9ydCBDb21wb3NpdGVNYXBSZW5kZXJlciBmcm9tICcuL3JlbmRlcmVyL0NvbXBvc2l0ZS5qcyc7XG5pbXBvcnQgRXZlbnRUeXBlIGZyb20gJy4vZXZlbnRzL0V2ZW50VHlwZS5qcyc7XG5pbXBvcnQgTGF5ZXIgZnJvbSAnLi9sYXllci9MYXllci5qcyc7XG5pbXBvcnQgTGF5ZXJHcm91cCwge0dyb3VwRXZlbnR9IGZyb20gJy4vbGF5ZXIvR3JvdXAuanMnO1xuaW1wb3J0IE1hcEJyb3dzZXJFdmVudCBmcm9tICcuL01hcEJyb3dzZXJFdmVudC5qcyc7XG5pbXBvcnQgTWFwQnJvd3NlckV2ZW50SGFuZGxlciBmcm9tICcuL01hcEJyb3dzZXJFdmVudEhhbmRsZXIuanMnO1xuaW1wb3J0IE1hcEJyb3dzZXJFdmVudFR5cGUgZnJvbSAnLi9NYXBCcm93c2VyRXZlbnRUeXBlLmpzJztcbmltcG9ydCBNYXBFdmVudCBmcm9tICcuL01hcEV2ZW50LmpzJztcbmltcG9ydCBNYXBFdmVudFR5cGUgZnJvbSAnLi9NYXBFdmVudFR5cGUuanMnO1xuaW1wb3J0IE1hcFByb3BlcnR5IGZyb20gJy4vTWFwUHJvcGVydHkuanMnO1xuaW1wb3J0IE9iamVjdEV2ZW50VHlwZSBmcm9tICcuL09iamVjdEV2ZW50VHlwZS5qcyc7XG5pbXBvcnQgUG9pbnRlckV2ZW50VHlwZSBmcm9tICcuL3BvaW50ZXIvRXZlbnRUeXBlLmpzJztcbmltcG9ydCBSZW5kZXJFdmVudFR5cGUgZnJvbSAnLi9yZW5kZXIvRXZlbnRUeXBlLmpzJztcbmltcG9ydCBUaWxlUXVldWUsIHtnZXRUaWxlUHJpb3JpdHl9IGZyb20gJy4vVGlsZVF1ZXVlLmpzJztcbmltcG9ydCBWaWV3IGZyb20gJy4vVmlldy5qcyc7XG5pbXBvcnQgVmlld0hpbnQgZnJvbSAnLi9WaWV3SGludC5qcyc7XG5pbXBvcnQge0RFVklDRV9QSVhFTF9SQVRJTywgUEFTU0lWRV9FVkVOVF9MSVNURU5FUlN9IGZyb20gJy4vaGFzLmpzJztcbmltcG9ydCB7VFJVRX0gZnJvbSAnLi9mdW5jdGlvbnMuanMnO1xuaW1wb3J0IHtcbiAgYXBwbHkgYXMgYXBwbHlUcmFuc2Zvcm0sXG4gIGNyZWF0ZSBhcyBjcmVhdGVUcmFuc2Zvcm0sXG59IGZyb20gJy4vdHJhbnNmb3JtLmpzJztcbmltcG9ydCB7YXNzZXJ0fSBmcm9tICcuL2Fzc2VydHMuanMnO1xuaW1wb3J0IHtcbiAgY2xvbmUsXG4gIGNyZWF0ZU9yVXBkYXRlRW1wdHksXG4gIGVxdWFscyBhcyBlcXVhbHNFeHRlbnQsXG4gIGdldEZvclZpZXdBbmRTaXplLFxuICBpc0VtcHR5LFxufSBmcm9tICcuL2V4dGVudC5qcyc7XG5pbXBvcnQge2RlZmF1bHRzIGFzIGRlZmF1bHRDb250cm9sc30gZnJvbSAnLi9jb250cm9sL2RlZmF1bHRzLmpzJztcbmltcG9ydCB7ZGVmYXVsdHMgYXMgZGVmYXVsdEludGVyYWN0aW9uc30gZnJvbSAnLi9pbnRlcmFjdGlvbi9kZWZhdWx0cy5qcyc7XG5pbXBvcnQge2VxdWFsc30gZnJvbSAnLi9hcnJheS5qcyc7XG5pbXBvcnQge2Zyb21Vc2VyQ29vcmRpbmF0ZSwgdG9Vc2VyQ29vcmRpbmF0ZX0gZnJvbSAnLi9wcm9qLmpzJztcbmltcG9ydCB7Z2V0VWlkfSBmcm9tICcuL3V0aWwuanMnO1xuaW1wb3J0IHtoYXNBcmVhfSBmcm9tICcuL3NpemUuanMnO1xuaW1wb3J0IHtsaXN0ZW4sIHVubGlzdGVuQnlLZXl9IGZyb20gJy4vZXZlbnRzLmpzJztcbmltcG9ydCB7cmVtb3ZlTm9kZX0gZnJvbSAnLi9kb20uanMnO1xuaW1wb3J0IHt3YXJufSBmcm9tICcuL2NvbnNvbGUuanMnO1xuXG4vKipcbiAqIFN0YXRlIG9mIHRoZSBjdXJyZW50IGZyYW1lLiBPbmx5IGBwaXhlbFJhdGlvYCwgYHRpbWVgIGFuZCBgdmlld1N0YXRlYCBzaG91bGRcbiAqIGJlIHVzZWQgaW4gYXBwbGljYXRpb25zLlxuICogQHR5cGVkZWYge09iamVjdH0gRnJhbWVTdGF0ZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IHBpeGVsUmF0aW8gVGhlIHBpeGVsIHJhdGlvIG9mIHRoZSBmcmFtZS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB0aW1lIFRoZSB0aW1lIHdoZW4gcmVuZGVyaW5nIG9mIHRoZSBmcmFtZSB3YXMgcmVxdWVzdGVkLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL1ZpZXcuanNcIikuU3RhdGV9IHZpZXdTdGF0ZSBUaGUgc3RhdGUgb2YgdGhlIGN1cnJlbnQgdmlldy5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gYW5pbWF0ZSBBbmltYXRlLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL3RyYW5zZm9ybS5qc1wiKS5UcmFuc2Zvcm19IGNvb3JkaW5hdGVUb1BpeGVsVHJhbnNmb3JtIENvb3JkaW5hdGVUb1BpeGVsVHJhbnNmb3JtLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCJyYnVzaFwiKS5kZWZhdWx0fSBkZWNsdXR0ZXJUcmVlIERlY2x1dHRlclRyZWUuXG4gKiBAcHJvcGVydHkge251bGx8aW1wb3J0KFwiLi9leHRlbnQuanNcIikuRXh0ZW50fSBleHRlbnQgRXh0ZW50IChpbiB2aWV3IHByb2plY3Rpb24gY29vcmRpbmF0ZXMpLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL2V4dGVudC5qc1wiKS5FeHRlbnR9IFtuZXh0RXh0ZW50XSBOZXh0IGV4dGVudCBkdXJpbmcgYW4gYW5pbWF0aW9uIHNlcmllcy5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBpbmRleCBJbmRleC5cbiAqIEBwcm9wZXJ0eSB7QXJyYXk8aW1wb3J0KFwiLi9sYXllci9MYXllci5qc1wiKS5TdGF0ZT59IGxheWVyU3RhdGVzQXJyYXkgTGF5ZXJTdGF0ZXNBcnJheS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBsYXllckluZGV4IExheWVySW5kZXguXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4vdHJhbnNmb3JtLmpzXCIpLlRyYW5zZm9ybX0gcGl4ZWxUb0Nvb3JkaW5hdGVUcmFuc2Zvcm0gUGl4ZWxUb0Nvb3JkaW5hdGVUcmFuc2Zvcm0uXG4gKiBAcHJvcGVydHkge0FycmF5PFBvc3RSZW5kZXJGdW5jdGlvbj59IHBvc3RSZW5kZXJGdW5jdGlvbnMgUG9zdFJlbmRlckZ1bmN0aW9ucy5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi9zaXplLmpzXCIpLlNpemV9IHNpemUgU2l6ZS5cbiAqIEBwcm9wZXJ0eSB7VGlsZVF1ZXVlfSB0aWxlUXVldWUgVGlsZVF1ZXVlLlxuICogQHByb3BlcnR5IHshT2JqZWN0PHN0cmluZywgT2JqZWN0PHN0cmluZywgYm9vbGVhbj4+fSB1c2VkVGlsZXMgVXNlZFRpbGVzLlxuICogQHByb3BlcnR5IHtBcnJheTxudW1iZXI+fSB2aWV3SGludHMgVmlld0hpbnRzLlxuICogQHByb3BlcnR5IHshT2JqZWN0PHN0cmluZywgT2JqZWN0PHN0cmluZywgYm9vbGVhbj4+fSB3YW50ZWRUaWxlcyBXYW50ZWRUaWxlcy5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBtYXBJZCBUaGUgaWQgb2YgdGhlIG1hcC5cbiAqIEBwcm9wZXJ0eSB7T2JqZWN0PHN0cmluZywgYm9vbGVhbj59IHJlbmRlclRhcmdldHMgSWRlbnRpZmllcnMgb2YgcHJldmlvdXNseSByZW5kZXJlZCBlbGVtZW50cy5cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtmdW5jdGlvbihNYXAsID9GcmFtZVN0YXRlKTogYW55fSBQb3N0UmVuZGVyRnVuY3Rpb25cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEF0UGl4ZWxPcHRpb25zXG4gKiBAcHJvcGVydHkge3VuZGVmaW5lZHxmdW5jdGlvbihpbXBvcnQoXCIuL2xheWVyL0xheWVyLmpzXCIpLmRlZmF1bHQ8aW1wb3J0KFwiLi9zb3VyY2UvU291cmNlXCIpLmRlZmF1bHQ+KTogYm9vbGVhbn0gW2xheWVyRmlsdGVyXSBMYXllciBmaWx0ZXJcbiAqIGZ1bmN0aW9uLiBUaGUgZmlsdGVyIGZ1bmN0aW9uIHdpbGwgcmVjZWl2ZSBvbmUgYXJndW1lbnQsIHRoZVxuICoge0BsaW5rIG1vZHVsZTpvbC9sYXllci9MYXllcn5MYXllciBsYXllci1jYW5kaWRhdGV9IGFuZCBpdCBzaG91bGQgcmV0dXJuIGEgYm9vbGVhbiB2YWx1ZS5cbiAqIE9ubHkgbGF5ZXJzIHdoaWNoIGFyZSB2aXNpYmxlIGFuZCBmb3Igd2hpY2ggdGhpcyBmdW5jdGlvbiByZXR1cm5zIGB0cnVlYFxuICogd2lsbCBiZSB0ZXN0ZWQgZm9yIGZlYXR1cmVzLiBCeSBkZWZhdWx0LCBhbGwgdmlzaWJsZSBsYXllcnMgd2lsbCBiZSB0ZXN0ZWQuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2hpdFRvbGVyYW5jZT0wXSBIaXQtZGV0ZWN0aW9uIHRvbGVyYW5jZSBpbiBjc3MgcGl4ZWxzLiBQaXhlbHNcbiAqIGluc2lkZSB0aGUgcmFkaXVzIGFyb3VuZCB0aGUgZ2l2ZW4gcG9zaXRpb24gd2lsbCBiZSBjaGVja2VkIGZvciBmZWF0dXJlcy5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2NoZWNrV3JhcHBlZD10cnVlXSBDaGVjay1XcmFwcGVkIFdpbGwgY2hlY2sgZm9yIHdyYXBwZWQgZ2VvbWV0cmllcyBpbnNpZGUgdGhlIHJhbmdlIG9mXG4gKiAgICsvLSAxIHdvcmxkIHdpZHRoLiBXb3JrcyBvbmx5IGlmIGEgcHJvamVjdGlvbiBpcyB1c2VkIHRoYXQgY2FuIGJlIHdyYXBwZWQuXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBNYXBPcHRpb25zSW50ZXJuYWxcbiAqIEBwcm9wZXJ0eSB7Q29sbGVjdGlvbjxpbXBvcnQoXCIuL2NvbnRyb2wvQ29udHJvbC5qc1wiKS5kZWZhdWx0Pn0gW2NvbnRyb2xzXSBDb250cm9scy5cbiAqIEBwcm9wZXJ0eSB7Q29sbGVjdGlvbjxpbXBvcnQoXCIuL2ludGVyYWN0aW9uL0ludGVyYWN0aW9uLmpzXCIpLmRlZmF1bHQ+fSBbaW50ZXJhY3Rpb25zXSBJbnRlcmFjdGlvbnMuXG4gKiBAcHJvcGVydHkge0hUTUxFbGVtZW50fERvY3VtZW50fSBrZXlib2FyZEV2ZW50VGFyZ2V0IEtleWJvYXJkRXZlbnRUYXJnZXQuXG4gKiBAcHJvcGVydHkge0NvbGxlY3Rpb248aW1wb3J0KFwiLi9PdmVybGF5LmpzXCIpLmRlZmF1bHQ+fSBvdmVybGF5cyBPdmVybGF5cy5cbiAqIEBwcm9wZXJ0eSB7T2JqZWN0PHN0cmluZywgKj59IHZhbHVlcyBWYWx1ZXMuXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KFwiLi9PYmplY3RFdmVudFR5cGVcIikuVHlwZXN8J2NoYW5nZTpsYXllcmdyb3VwJ3wnY2hhbmdlOnNpemUnfCdjaGFuZ2U6dGFyZ2V0J3wnY2hhbmdlOnZpZXcnfSBNYXBPYmplY3RFdmVudFR5cGVzXG4gKi9cblxuLyoqKlxuICogQHRlbXBsYXRlIFJldHVyblxuICogQHR5cGVkZWYge2ltcG9ydChcIi4vT2JzZXJ2YWJsZVwiKS5PblNpZ25hdHVyZTxpbXBvcnQoXCIuL09ic2VydmFibGVcIikuRXZlbnRUeXBlcywgaW1wb3J0KFwiLi9ldmVudHMvRXZlbnQuanNcIikuZGVmYXVsdCwgUmV0dXJuPiAmXG4gKiAgICBpbXBvcnQoXCIuL09ic2VydmFibGVcIikuT25TaWduYXR1cmU8TWFwT2JqZWN0RXZlbnRUeXBlcywgaW1wb3J0KFwiLi9PYmplY3RcIikuT2JqZWN0RXZlbnQsIFJldHVybj4gJlxuICogICAgaW1wb3J0KFwiLi9PYnNlcnZhYmxlXCIpLk9uU2lnbmF0dXJlPGltcG9ydChcIi4vTWFwQnJvd3NlckV2ZW50VHlwZVwiKS5UeXBlcywgaW1wb3J0KFwiLi9NYXBCcm93c2VyRXZlbnRcIikuZGVmYXVsdCwgUmV0dXJuPiAmXG4gKiAgICBpbXBvcnQoXCIuL09ic2VydmFibGVcIikuT25TaWduYXR1cmU8aW1wb3J0KFwiLi9NYXBFdmVudFR5cGVcIikuVHlwZXMsIGltcG9ydChcIi4vTWFwRXZlbnRcIikuZGVmYXVsdCwgUmV0dXJuPiAmXG4gKiAgICBpbXBvcnQoXCIuL09ic2VydmFibGVcIikuT25TaWduYXR1cmU8aW1wb3J0KFwiLi9yZW5kZXIvRXZlbnRUeXBlXCIpLk1hcFJlbmRlckV2ZW50VHlwZXMsIGltcG9ydChcIi4vcmVuZGVyL0V2ZW50XCIpLmRlZmF1bHQsIFJldHVybj4gJlxuICogICAgaW1wb3J0KFwiLi9PYnNlcnZhYmxlXCIpLkNvbWJpbmVkT25TaWduYXR1cmU8aW1wb3J0KFwiLi9PYnNlcnZhYmxlXCIpLkV2ZW50VHlwZXN8TWFwT2JqZWN0RXZlbnRUeXBlc3xcbiAqICAgICAgaW1wb3J0KFwiLi9NYXBCcm93c2VyRXZlbnRUeXBlXCIpLlR5cGVzfGltcG9ydChcIi4vTWFwRXZlbnRUeXBlXCIpLlR5cGVzfFxuICogICAgICBpbXBvcnQoXCIuL3JlbmRlci9FdmVudFR5cGVcIikuTWFwUmVuZGVyRXZlbnRUeXBlcywgUmV0dXJuPn0gTWFwRXZlbnRIYW5kbGVyXG4gKi9cblxuLyoqXG4gKiBPYmplY3QgbGl0ZXJhbCB3aXRoIGNvbmZpZyBvcHRpb25zIGZvciB0aGUgbWFwLlxuICogQHR5cGVkZWYge09iamVjdH0gTWFwT3B0aW9uc1xuICogQHByb3BlcnR5IHtDb2xsZWN0aW9uPGltcG9ydChcIi4vY29udHJvbC9Db250cm9sLmpzXCIpLmRlZmF1bHQ+fEFycmF5PGltcG9ydChcIi4vY29udHJvbC9Db250cm9sLmpzXCIpLmRlZmF1bHQ+fSBbY29udHJvbHNdXG4gKiBDb250cm9scyBpbml0aWFsbHkgYWRkZWQgdG8gdGhlIG1hcC4gSWYgbm90IHNwZWNpZmllZCxcbiAqIHtAbGluayBtb2R1bGU6b2wvY29udHJvbC9kZWZhdWx0cy5kZWZhdWx0c30gaXMgdXNlZC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbcGl4ZWxSYXRpbz13aW5kb3cuZGV2aWNlUGl4ZWxSYXRpb10gVGhlIHJhdGlvIGJldHdlZW5cbiAqIHBoeXNpY2FsIHBpeGVscyBhbmQgZGV2aWNlLWluZGVwZW5kZW50IHBpeGVscyAoZGlwcykgb24gdGhlIGRldmljZS5cbiAqIEBwcm9wZXJ0eSB7Q29sbGVjdGlvbjxpbXBvcnQoXCIuL2ludGVyYWN0aW9uL0ludGVyYWN0aW9uLmpzXCIpLmRlZmF1bHQ+fEFycmF5PGltcG9ydChcIi4vaW50ZXJhY3Rpb24vSW50ZXJhY3Rpb24uanNcIikuZGVmYXVsdD59IFtpbnRlcmFjdGlvbnNdXG4gKiBJbnRlcmFjdGlvbnMgdGhhdCBhcmUgaW5pdGlhbGx5IGFkZGVkIHRvIHRoZSBtYXAuIElmIG5vdCBzcGVjaWZpZWQsXG4gKiB7QGxpbmsgbW9kdWxlOm9sL2ludGVyYWN0aW9uL2RlZmF1bHRzLmRlZmF1bHRzfSBpcyB1c2VkLlxuICogQHByb3BlcnR5IHtIVE1MRWxlbWVudHxEb2N1bWVudHxzdHJpbmd9IFtrZXlib2FyZEV2ZW50VGFyZ2V0XSBUaGUgZWxlbWVudCB0b1xuICogbGlzdGVuIHRvIGtleWJvYXJkIGV2ZW50cyBvbi4gVGhpcyBkZXRlcm1pbmVzIHdoZW4gdGhlIGBLZXlib2FyZFBhbmAgYW5kXG4gKiBgS2V5Ym9hcmRab29tYCBpbnRlcmFjdGlvbnMgdHJpZ2dlci4gRm9yIGV4YW1wbGUsIGlmIHRoaXMgb3B0aW9uIGlzIHNldCB0b1xuICogYGRvY3VtZW50YCB0aGUga2V5Ym9hcmQgaW50ZXJhY3Rpb25zIHdpbGwgYWx3YXlzIHRyaWdnZXIuIElmIHRoaXMgb3B0aW9uIGlzXG4gKiBub3Qgc3BlY2lmaWVkLCB0aGUgZWxlbWVudCB0aGUgbGlicmFyeSBsaXN0ZW5zIHRvIGtleWJvYXJkIGV2ZW50cyBvbiBpcyB0aGVcbiAqIG1hcCB0YXJnZXQgKGkuZS4gdGhlIHVzZXItcHJvdmlkZWQgZGl2IGZvciB0aGUgbWFwKS4gSWYgdGhpcyBpcyBub3RcbiAqIGBkb2N1bWVudGAsIHRoZSB0YXJnZXQgZWxlbWVudCBuZWVkcyB0byBiZSBmb2N1c2VkIGZvciBrZXkgZXZlbnRzIHRvIGJlXG4gKiBlbWl0dGVkLCByZXF1aXJpbmcgdGhhdCB0aGUgdGFyZ2V0IGVsZW1lbnQgaGFzIGEgYHRhYmluZGV4YCBhdHRyaWJ1dGUuXG4gKiBAcHJvcGVydHkge0FycmF5PGltcG9ydChcIi4vbGF5ZXIvQmFzZS5qc1wiKS5kZWZhdWx0PnxDb2xsZWN0aW9uPGltcG9ydChcIi4vbGF5ZXIvQmFzZS5qc1wiKS5kZWZhdWx0PnxMYXllckdyb3VwfSBbbGF5ZXJzXVxuICogTGF5ZXJzLiBJZiB0aGlzIGlzIG5vdCBkZWZpbmVkLCBhIG1hcCB3aXRoIG5vIGxheWVycyB3aWxsIGJlIHJlbmRlcmVkLiBOb3RlXG4gKiB0aGF0IGxheWVycyBhcmUgcmVuZGVyZWQgaW4gdGhlIG9yZGVyIHN1cHBsaWVkLCBzbyBpZiB5b3Ugd2FudCwgZm9yIGV4YW1wbGUsXG4gKiBhIHZlY3RvciBsYXllciB0byBhcHBlYXIgb24gdG9wIG9mIGEgdGlsZSBsYXllciwgaXQgbXVzdCBjb21lIGFmdGVyIHRoZSB0aWxlXG4gKiBsYXllci5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbWF4VGlsZXNMb2FkaW5nPTE2XSBNYXhpbXVtIG51bWJlciB0aWxlcyB0byBsb2FkXG4gKiBzaW11bHRhbmVvdXNseS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbW92ZVRvbGVyYW5jZT0xXSBUaGUgbWluaW11bSBkaXN0YW5jZSBpbiBwaXhlbHMgdGhlXG4gKiBjdXJzb3IgbXVzdCBtb3ZlIHRvIGJlIGRldGVjdGVkIGFzIGEgbWFwIG1vdmUgZXZlbnQgaW5zdGVhZCBvZiBhIGNsaWNrLlxuICogSW5jcmVhc2luZyB0aGlzIHZhbHVlIGNhbiBtYWtlIGl0IGVhc2llciB0byBjbGljayBvbiB0aGUgbWFwLlxuICogQHByb3BlcnR5IHtDb2xsZWN0aW9uPGltcG9ydChcIi4vT3ZlcmxheS5qc1wiKS5kZWZhdWx0PnxBcnJheTxpbXBvcnQoXCIuL092ZXJsYXkuanNcIikuZGVmYXVsdD59IFtvdmVybGF5c11cbiAqIE92ZXJsYXlzIGluaXRpYWxseSBhZGRlZCB0byB0aGUgbWFwLiBCeSBkZWZhdWx0LCBubyBvdmVybGF5cyBhcmUgYWRkZWQuXG4gKiBAcHJvcGVydHkge0hUTUxFbGVtZW50fHN0cmluZ30gW3RhcmdldF0gVGhlIGNvbnRhaW5lciBmb3IgdGhlIG1hcCwgZWl0aGVyIHRoZVxuICogZWxlbWVudCBpdHNlbGYgb3IgdGhlIGBpZGAgb2YgdGhlIGVsZW1lbnQuIElmIG5vdCBzcGVjaWZpZWQgYXQgY29uc3RydWN0aW9uXG4gKiB0aW1lLCB7QGxpbmsgbW9kdWxlOm9sL01hcH5NYXAjc2V0VGFyZ2V0fSBtdXN0IGJlIGNhbGxlZCBmb3IgdGhlIG1hcCB0byBiZVxuICogcmVuZGVyZWQuIElmIHBhc3NlZCBieSBlbGVtZW50LCB0aGUgY29udGFpbmVyIGNhbiBiZSBpbiBhIHNlY29uZGFyeSBkb2N1bWVudC5cbiAqICoqTm90ZToqKiBDU1MgYHRyYW5zZm9ybWAgc3VwcG9ydCBmb3IgdGhlIHRhcmdldCBlbGVtZW50IGlzIGxpbWl0ZWQgdG8gYHNjYWxlYC5cbiAqIEBwcm9wZXJ0eSB7Vmlld3xQcm9taXNlPGltcG9ydChcIi4vVmlldy5qc1wiKS5WaWV3T3B0aW9ucz59IFt2aWV3XSBUaGUgbWFwJ3Mgdmlldy4gIE5vIGxheWVyIHNvdXJjZXMgd2lsbCBiZVxuICogZmV0Y2hlZCB1bmxlc3MgdGhpcyBpcyBzcGVjaWZpZWQgYXQgY29uc3RydWN0aW9uIHRpbWUgb3IgdGhyb3VnaFxuICoge0BsaW5rIG1vZHVsZTpvbC9NYXB+TWFwI3NldFZpZXd9LlxuICovXG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL2xheWVyL0Jhc2UuanNcIikuZGVmYXVsdH0gbGF5ZXIgTGF5ZXIuXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUxheWVyTWFwUHJvcGVydHkobGF5ZXIpIHtcbiAgaWYgKGxheWVyIGluc3RhbmNlb2YgTGF5ZXIpIHtcbiAgICBsYXllci5zZXRNYXBJbnRlcm5hbChudWxsKTtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGxheWVyIGluc3RhbmNlb2YgTGF5ZXJHcm91cCkge1xuICAgIGxheWVyLmdldExheWVycygpLmZvckVhY2gocmVtb3ZlTGF5ZXJNYXBQcm9wZXJ0eSk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vbGF5ZXIvQmFzZS5qc1wiKS5kZWZhdWx0fSBsYXllciBMYXllci5cbiAqIEBwYXJhbSB7TWFwfSBtYXAgTWFwLlxuICovXG5mdW5jdGlvbiBzZXRMYXllck1hcFByb3BlcnR5KGxheWVyLCBtYXApIHtcbiAgaWYgKGxheWVyIGluc3RhbmNlb2YgTGF5ZXIpIHtcbiAgICBsYXllci5zZXRNYXBJbnRlcm5hbChtYXApO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAobGF5ZXIgaW5zdGFuY2VvZiBMYXllckdyb3VwKSB7XG4gICAgY29uc3QgbGF5ZXJzID0gbGF5ZXIuZ2V0TGF5ZXJzKCkuZ2V0QXJyYXkoKTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBsYXllcnMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgc2V0TGF5ZXJNYXBQcm9wZXJ0eShsYXllcnNbaV0sIG1hcCk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogVGhlIG1hcCBpcyB0aGUgY29yZSBjb21wb25lbnQgb2YgT3BlbkxheWVycy4gRm9yIGEgbWFwIHRvIHJlbmRlciwgYSB2aWV3LFxuICogb25lIG9yIG1vcmUgbGF5ZXJzLCBhbmQgYSB0YXJnZXQgY29udGFpbmVyIGFyZSBuZWVkZWQ6XG4gKlxuICogICAgIGltcG9ydCBNYXAgZnJvbSAnb2wvTWFwLmpzJztcbiAqICAgICBpbXBvcnQgVmlldyBmcm9tICdvbC9WaWV3LmpzJztcbiAqICAgICBpbXBvcnQgVGlsZUxheWVyIGZyb20gJ29sL2xheWVyL1RpbGUuanMnO1xuICogICAgIGltcG9ydCBPU00gZnJvbSAnb2wvc291cmNlL09TTS5qcyc7XG4gKlxuICogICAgIGNvbnN0IG1hcCA9IG5ldyBNYXAoe1xuICogICAgICAgdmlldzogbmV3IFZpZXcoe1xuICogICAgICAgICBjZW50ZXI6IFswLCAwXSxcbiAqICAgICAgICAgem9vbTogMSxcbiAqICAgICAgIH0pLFxuICogICAgICAgbGF5ZXJzOiBbXG4gKiAgICAgICAgIG5ldyBUaWxlTGF5ZXIoe1xuICogICAgICAgICAgIHNvdXJjZTogbmV3IE9TTSgpLFxuICogICAgICAgICB9KSxcbiAqICAgICAgIF0sXG4gKiAgICAgICB0YXJnZXQ6ICdtYXAnLFxuICogICAgIH0pO1xuICpcbiAqIFRoZSBhYm92ZSBzbmlwcGV0IGNyZWF0ZXMgYSBtYXAgdXNpbmcgYSB7QGxpbmsgbW9kdWxlOm9sL2xheWVyL1RpbGV+VGlsZUxheWVyfSB0b1xuICogZGlzcGxheSB7QGxpbmsgbW9kdWxlOm9sL3NvdXJjZS9PU01+T1NNfSBPU00gZGF0YSBhbmQgcmVuZGVyIGl0IHRvIGEgRE9NXG4gKiBlbGVtZW50IHdpdGggdGhlIGlkIGBtYXBgLlxuICpcbiAqIFRoZSBjb25zdHJ1Y3RvciBwbGFjZXMgYSB2aWV3cG9ydCBjb250YWluZXIgKHdpdGggQ1NTIGNsYXNzIG5hbWVcbiAqIGBvbC12aWV3cG9ydGApIGluIHRoZSB0YXJnZXQgZWxlbWVudCAoc2VlIGBnZXRWaWV3cG9ydCgpYCksIGFuZCB0aGVuIHR3b1xuICogZnVydGhlciBlbGVtZW50cyB3aXRoaW4gdGhlIHZpZXdwb3J0OiBvbmUgd2l0aCBDU1MgY2xhc3MgbmFtZVxuICogYG9sLW92ZXJsYXljb250YWluZXItc3RvcGV2ZW50YCBmb3IgY29udHJvbHMgYW5kIHNvbWUgb3ZlcmxheXMsIGFuZCBvbmUgd2l0aFxuICogQ1NTIGNsYXNzIG5hbWUgYG9sLW92ZXJsYXljb250YWluZXJgIGZvciBvdGhlciBvdmVybGF5cyAoc2VlIHRoZSBgc3RvcEV2ZW50YFxuICogb3B0aW9uIG9mIHtAbGluayBtb2R1bGU6b2wvT3ZlcmxheX5PdmVybGF5fSBmb3IgdGhlIGRpZmZlcmVuY2UpLiBUaGUgbWFwXG4gKiBpdHNlbGYgaXMgcGxhY2VkIGluIGEgZnVydGhlciBlbGVtZW50IHdpdGhpbiB0aGUgdmlld3BvcnQuXG4gKlxuICogTGF5ZXJzIGFyZSBzdG9yZWQgYXMgYSB7QGxpbmsgbW9kdWxlOm9sL0NvbGxlY3Rpb25+Q29sbGVjdGlvbn0gaW5cbiAqIGxheWVyR3JvdXBzLiBBIHRvcC1sZXZlbCBncm91cCBpcyBwcm92aWRlZCBieSB0aGUgbGlicmFyeS4gVGhpcyBpcyB3aGF0IGlzXG4gKiBhY2Nlc3NlZCBieSBgZ2V0TGF5ZXJHcm91cGAgYW5kIGBzZXRMYXllckdyb3VwYC4gTGF5ZXJzIGVudGVyZWQgaW4gdGhlXG4gKiBvcHRpb25zIGFyZSBhZGRlZCB0byB0aGlzIGdyb3VwLCBhbmQgYGFkZExheWVyYCBhbmQgYHJlbW92ZUxheWVyYCBjaGFuZ2UgdGhlXG4gKiBsYXllciBjb2xsZWN0aW9uIGluIHRoZSBncm91cC4gYGdldExheWVyc2AgaXMgYSBjb252ZW5pZW5jZSBmdW5jdGlvbiBmb3JcbiAqIGBnZXRMYXllckdyb3VwKCkuZ2V0TGF5ZXJzKClgLiBOb3RlIHRoYXQge0BsaW5rIG1vZHVsZTpvbC9sYXllci9Hcm91cH5MYXllckdyb3VwfVxuICogaXMgYSBzdWJjbGFzcyBvZiB7QGxpbmsgbW9kdWxlOm9sL2xheWVyL0Jhc2V+QmFzZUxheWVyfSwgc28gbGF5ZXJzIGVudGVyZWQgaW4gdGhlXG4gKiBvcHRpb25zIG9yIGFkZGVkIHdpdGggYGFkZExheWVyYCBjYW4gYmUgZ3JvdXBzLCB3aGljaCBjYW4gY29udGFpbiBmdXJ0aGVyXG4gKiBncm91cHMsIGFuZCBzbyBvbi5cbiAqXG4gKiBAZmlyZXMgaW1wb3J0KFwiLi9NYXBCcm93c2VyRXZlbnQuanNcIikuTWFwQnJvd3NlckV2ZW50XG4gKiBAZmlyZXMgaW1wb3J0KFwiLi9NYXBFdmVudC5qc1wiKS5NYXBFdmVudFxuICogQGZpcmVzIGltcG9ydChcIi4vcmVuZGVyL0V2ZW50LmpzXCIpLmRlZmF1bHQjcHJlY29tcG9zZVxuICogQGZpcmVzIGltcG9ydChcIi4vcmVuZGVyL0V2ZW50LmpzXCIpLmRlZmF1bHQjcG9zdGNvbXBvc2VcbiAqIEBmaXJlcyBpbXBvcnQoXCIuL3JlbmRlci9FdmVudC5qc1wiKS5kZWZhdWx0I3JlbmRlcmNvbXBsZXRlXG4gKiBAYXBpXG4gKi9cbmNsYXNzIE1hcCBleHRlbmRzIEJhc2VPYmplY3Qge1xuICAvKipcbiAgICogQHBhcmFtIHtNYXBPcHRpb25zfSBbb3B0aW9uc10gTWFwIG9wdGlvbnMuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgLyoqKlxuICAgICAqIEB0eXBlIHtNYXBFdmVudEhhbmRsZXI8aW1wb3J0KFwiLi9ldmVudHNcIikuRXZlbnRzS2V5Pn1cbiAgICAgKi9cbiAgICB0aGlzLm9uO1xuXG4gICAgLyoqKlxuICAgICAqIEB0eXBlIHtNYXBFdmVudEhhbmRsZXI8aW1wb3J0KFwiLi9ldmVudHNcIikuRXZlbnRzS2V5Pn1cbiAgICAgKi9cbiAgICB0aGlzLm9uY2U7XG5cbiAgICAvKioqXG4gICAgICogQHR5cGUge01hcEV2ZW50SGFuZGxlcjx2b2lkPn1cbiAgICAgKi9cbiAgICB0aGlzLnVuO1xuXG4gICAgY29uc3Qgb3B0aW9uc0ludGVybmFsID0gY3JlYXRlT3B0aW9uc0ludGVybmFsKG9wdGlvbnMpO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbnx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5yZW5kZXJDb21wbGV0ZV87XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMubG9hZGVkXyA9IHRydWU7XG5cbiAgICAvKiogQHByaXZhdGUgKi9cbiAgICB0aGlzLmJvdW5kSGFuZGxlQnJvd3NlckV2ZW50XyA9IHRoaXMuaGFuZGxlQnJvd3NlckV2ZW50LmJpbmQodGhpcyk7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5tYXhUaWxlc0xvYWRpbmdfID1cbiAgICAgIG9wdGlvbnMubWF4VGlsZXNMb2FkaW5nICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm1heFRpbGVzTG9hZGluZyA6IDE2O1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucGl4ZWxSYXRpb18gPVxuICAgICAgb3B0aW9ucy5waXhlbFJhdGlvICE9PSB1bmRlZmluZWRcbiAgICAgICAgPyBvcHRpb25zLnBpeGVsUmF0aW9cbiAgICAgICAgOiBERVZJQ0VfUElYRUxfUkFUSU87XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtSZXR1cm5UeXBlPHR5cGVvZiBzZXRUaW1lb3V0Pn1cbiAgICAgKi9cbiAgICB0aGlzLnBvc3RSZW5kZXJUaW1lb3V0SGFuZGxlXztcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcnx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5hbmltYXRpb25EZWxheUtleV87XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuYW5pbWF0aW9uRGVsYXlfID0gdGhpcy5hbmltYXRpb25EZWxheV8uYmluZCh0aGlzKTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4vdHJhbnNmb3JtLmpzXCIpLlRyYW5zZm9ybX1cbiAgICAgKi9cbiAgICB0aGlzLmNvb3JkaW5hdGVUb1BpeGVsVHJhbnNmb3JtXyA9IGNyZWF0ZVRyYW5zZm9ybSgpO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi90cmFuc2Zvcm0uanNcIikuVHJhbnNmb3JtfVxuICAgICAqL1xuICAgIHRoaXMucGl4ZWxUb0Nvb3JkaW5hdGVUcmFuc2Zvcm1fID0gY3JlYXRlVHJhbnNmb3JtKCk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5mcmFtZUluZGV4XyA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHs/RnJhbWVTdGF0ZX1cbiAgICAgKi9cbiAgICB0aGlzLmZyYW1lU3RhdGVfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBleHRlbnQgYXQgdGhlIHByZXZpb3VzICdtb3ZlZW5kJyBldmVudC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuL2V4dGVudC5qc1wiKS5FeHRlbnR9XG4gICAgICovXG4gICAgdGhpcy5wcmV2aW91c0V4dGVudF8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7P2ltcG9ydChcIi4vZXZlbnRzLmpzXCIpLkV2ZW50c0tleX1cbiAgICAgKi9cbiAgICB0aGlzLnZpZXdQcm9wZXJ0eUxpc3RlbmVyS2V5XyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHs/aW1wb3J0KFwiLi9ldmVudHMuanNcIikuRXZlbnRzS2V5fVxuICAgICAqL1xuICAgIHRoaXMudmlld0NoYW5nZUxpc3RlbmVyS2V5XyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHs/QXJyYXk8aW1wb3J0KFwiLi9ldmVudHMuanNcIikuRXZlbnRzS2V5Pn1cbiAgICAgKi9cbiAgICB0aGlzLmxheWVyR3JvdXBQcm9wZXJ0eUxpc3RlbmVyS2V5c18gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7IUhUTUxFbGVtZW50fVxuICAgICAqL1xuICAgIHRoaXMudmlld3BvcnRfID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGhpcy52aWV3cG9ydF8uY2xhc3NOYW1lID1cbiAgICAgICdvbC12aWV3cG9ydCcgKyAoJ29udG91Y2hzdGFydCcgaW4gd2luZG93ID8gJyBvbC10b3VjaCcgOiAnJyk7XG4gICAgdGhpcy52aWV3cG9ydF8uc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xuICAgIHRoaXMudmlld3BvcnRfLnN0eWxlLm92ZXJmbG93ID0gJ2hpZGRlbic7XG4gICAgdGhpcy52aWV3cG9ydF8uc3R5bGUud2lkdGggPSAnMTAwJSc7XG4gICAgdGhpcy52aWV3cG9ydF8uc3R5bGUuaGVpZ2h0ID0gJzEwMCUnO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7IUhUTUxFbGVtZW50fVxuICAgICAqL1xuICAgIHRoaXMub3ZlcmxheUNvbnRhaW5lcl8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0aGlzLm92ZXJsYXlDb250YWluZXJfLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICB0aGlzLm92ZXJsYXlDb250YWluZXJfLnN0eWxlLnpJbmRleCA9ICcwJztcbiAgICB0aGlzLm92ZXJsYXlDb250YWluZXJfLnN0eWxlLndpZHRoID0gJzEwMCUnO1xuICAgIHRoaXMub3ZlcmxheUNvbnRhaW5lcl8uc3R5bGUuaGVpZ2h0ID0gJzEwMCUnO1xuICAgIHRoaXMub3ZlcmxheUNvbnRhaW5lcl8uc3R5bGUucG9pbnRlckV2ZW50cyA9ICdub25lJztcbiAgICB0aGlzLm92ZXJsYXlDb250YWluZXJfLmNsYXNzTmFtZSA9ICdvbC1vdmVybGF5Y29udGFpbmVyJztcbiAgICB0aGlzLnZpZXdwb3J0Xy5hcHBlbmRDaGlsZCh0aGlzLm92ZXJsYXlDb250YWluZXJfKTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgeyFIVE1MRWxlbWVudH1cbiAgICAgKi9cbiAgICB0aGlzLm92ZXJsYXlDb250YWluZXJTdG9wRXZlbnRfID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGhpcy5vdmVybGF5Q29udGFpbmVyU3RvcEV2ZW50Xy5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgdGhpcy5vdmVybGF5Q29udGFpbmVyU3RvcEV2ZW50Xy5zdHlsZS56SW5kZXggPSAnMCc7XG4gICAgdGhpcy5vdmVybGF5Q29udGFpbmVyU3RvcEV2ZW50Xy5zdHlsZS53aWR0aCA9ICcxMDAlJztcbiAgICB0aGlzLm92ZXJsYXlDb250YWluZXJTdG9wRXZlbnRfLnN0eWxlLmhlaWdodCA9ICcxMDAlJztcbiAgICB0aGlzLm92ZXJsYXlDb250YWluZXJTdG9wRXZlbnRfLnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnbm9uZSc7XG4gICAgdGhpcy5vdmVybGF5Q29udGFpbmVyU3RvcEV2ZW50Xy5jbGFzc05hbWUgPSAnb2wtb3ZlcmxheWNvbnRhaW5lci1zdG9wZXZlbnQnO1xuICAgIHRoaXMudmlld3BvcnRfLmFwcGVuZENoaWxkKHRoaXMub3ZlcmxheUNvbnRhaW5lclN0b3BFdmVudF8pO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7TWFwQnJvd3NlckV2ZW50SGFuZGxlcn1cbiAgICAgKi9cbiAgICB0aGlzLm1hcEJyb3dzZXJFdmVudEhhbmRsZXJfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLm1vdmVUb2xlcmFuY2VfID0gb3B0aW9ucy5tb3ZlVG9sZXJhbmNlO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR8RG9jdW1lbnR9XG4gICAgICovXG4gICAgdGhpcy5rZXlib2FyZEV2ZW50VGFyZ2V0XyA9IG9wdGlvbnNJbnRlcm5hbC5rZXlib2FyZEV2ZW50VGFyZ2V0O1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7P0FycmF5PGltcG9ydChcIi4vZXZlbnRzLmpzXCIpLkV2ZW50c0tleT59XG4gICAgICovXG4gICAgdGhpcy50YXJnZXRDaGFuZ2VIYW5kbGVyS2V5c18gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR8bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLnRhcmdldEVsZW1lbnRfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtSZXNpemVPYnNlcnZlcn1cbiAgICAgKi9cbiAgICB0aGlzLnJlc2l6ZU9ic2VydmVyXyA9IG5ldyBSZXNpemVPYnNlcnZlcigoKSA9PiB0aGlzLnVwZGF0ZVNpemUoKSk7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7Q29sbGVjdGlvbjxpbXBvcnQoXCIuL2NvbnRyb2wvQ29udHJvbC5qc1wiKS5kZWZhdWx0Pn1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgdGhpcy5jb250cm9scyA9IG9wdGlvbnNJbnRlcm5hbC5jb250cm9scyB8fCBkZWZhdWx0Q29udHJvbHMoKTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtDb2xsZWN0aW9uPGltcG9ydChcIi4vaW50ZXJhY3Rpb24vSW50ZXJhY3Rpb24uanNcIikuZGVmYXVsdD59XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHRoaXMuaW50ZXJhY3Rpb25zID1cbiAgICAgIG9wdGlvbnNJbnRlcm5hbC5pbnRlcmFjdGlvbnMgfHxcbiAgICAgIGRlZmF1bHRJbnRlcmFjdGlvbnMoe1xuICAgICAgICBvbkZvY3VzT25seTogdHJ1ZSxcbiAgICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge0NvbGxlY3Rpb248aW1wb3J0KFwiLi9PdmVybGF5LmpzXCIpLmRlZmF1bHQ+fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5vdmVybGF5c18gPSBvcHRpb25zSW50ZXJuYWwub3ZlcmxheXM7XG5cbiAgICAvKipcbiAgICAgKiBBIGxvb2t1cCBvZiBvdmVybGF5cyBieSBpZC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBpbXBvcnQoXCIuL092ZXJsYXkuanNcIikuZGVmYXVsdD59XG4gICAgICovXG4gICAgdGhpcy5vdmVybGF5SWRJbmRleF8gPSB7fTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuL3JlbmRlcmVyL01hcC5qc1wiKS5kZWZhdWx0fG51bGx9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLnJlbmRlcmVyXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHshQXJyYXk8UG9zdFJlbmRlckZ1bmN0aW9uPn1cbiAgICAgKi9cbiAgICB0aGlzLnBvc3RSZW5kZXJGdW5jdGlvbnNfID0gW107XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtUaWxlUXVldWV9XG4gICAgICovXG4gICAgdGhpcy50aWxlUXVldWVfID0gbmV3IFRpbGVRdWV1ZShcbiAgICAgIHRoaXMuZ2V0VGlsZVByaW9yaXR5LmJpbmQodGhpcyksXG4gICAgICB0aGlzLmhhbmRsZVRpbGVDaGFuZ2VfLmJpbmQodGhpcylcbiAgICApO1xuXG4gICAgdGhpcy5hZGRDaGFuZ2VMaXN0ZW5lcihcbiAgICAgIE1hcFByb3BlcnR5LkxBWUVSR1JPVVAsXG4gICAgICB0aGlzLmhhbmRsZUxheWVyR3JvdXBDaGFuZ2VkX1xuICAgICk7XG4gICAgdGhpcy5hZGRDaGFuZ2VMaXN0ZW5lcihNYXBQcm9wZXJ0eS5WSUVXLCB0aGlzLmhhbmRsZVZpZXdDaGFuZ2VkXyk7XG4gICAgdGhpcy5hZGRDaGFuZ2VMaXN0ZW5lcihNYXBQcm9wZXJ0eS5TSVpFLCB0aGlzLmhhbmRsZVNpemVDaGFuZ2VkXyk7XG4gICAgdGhpcy5hZGRDaGFuZ2VMaXN0ZW5lcihNYXBQcm9wZXJ0eS5UQVJHRVQsIHRoaXMuaGFuZGxlVGFyZ2V0Q2hhbmdlZF8pO1xuXG4gICAgLy8gc2V0UHJvcGVydGllcyB3aWxsIHRyaWdnZXIgdGhlIHJlbmRlcmluZyBvZiB0aGUgbWFwIGlmIHRoZSBtYXBcbiAgICAvLyBpcyBcImRlZmluZWRcIiBhbHJlYWR5LlxuICAgIHRoaXMuc2V0UHJvcGVydGllcyhvcHRpb25zSW50ZXJuYWwudmFsdWVzKTtcblxuICAgIGNvbnN0IG1hcCA9IHRoaXM7XG4gICAgaWYgKG9wdGlvbnMudmlldyAmJiAhKG9wdGlvbnMudmlldyBpbnN0YW5jZW9mIFZpZXcpKSB7XG4gICAgICBvcHRpb25zLnZpZXcudGhlbihmdW5jdGlvbiAodmlld09wdGlvbnMpIHtcbiAgICAgICAgbWFwLnNldFZpZXcobmV3IFZpZXcodmlld09wdGlvbnMpKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMuY29udHJvbHMuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgIENvbGxlY3Rpb25FdmVudFR5cGUuQURELFxuICAgICAgLyoqXG4gICAgICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vQ29sbGVjdGlvbi5qc1wiKS5Db2xsZWN0aW9uRXZlbnQ8aW1wb3J0KFwiLi9jb250cm9sL0NvbnRyb2wuanNcIikuZGVmYXVsdD59IGV2ZW50IENvbGxlY3Rpb25FdmVudFxuICAgICAgICovXG4gICAgICAoZXZlbnQpID0+IHtcbiAgICAgICAgZXZlbnQuZWxlbWVudC5zZXRNYXAodGhpcyk7XG4gICAgICB9XG4gICAgKTtcblxuICAgIHRoaXMuY29udHJvbHMuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgIENvbGxlY3Rpb25FdmVudFR5cGUuUkVNT1ZFLFxuICAgICAgLyoqXG4gICAgICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vQ29sbGVjdGlvbi5qc1wiKS5Db2xsZWN0aW9uRXZlbnQ8aW1wb3J0KFwiLi9jb250cm9sL0NvbnRyb2wuanNcIikuZGVmYXVsdD59IGV2ZW50IENvbGxlY3Rpb25FdmVudC5cbiAgICAgICAqL1xuICAgICAgKGV2ZW50KSA9PiB7XG4gICAgICAgIGV2ZW50LmVsZW1lbnQuc2V0TWFwKG51bGwpO1xuICAgICAgfVxuICAgICk7XG5cbiAgICB0aGlzLmludGVyYWN0aW9ucy5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgQ29sbGVjdGlvbkV2ZW50VHlwZS5BREQsXG4gICAgICAvKipcbiAgICAgICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9Db2xsZWN0aW9uLmpzXCIpLkNvbGxlY3Rpb25FdmVudDxpbXBvcnQoXCIuL2ludGVyYWN0aW9uL0ludGVyYWN0aW9uLmpzXCIpLmRlZmF1bHQ+fSBldmVudCBDb2xsZWN0aW9uRXZlbnQuXG4gICAgICAgKi9cbiAgICAgIChldmVudCkgPT4ge1xuICAgICAgICBldmVudC5lbGVtZW50LnNldE1hcCh0aGlzKTtcbiAgICAgIH1cbiAgICApO1xuXG4gICAgdGhpcy5pbnRlcmFjdGlvbnMuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgIENvbGxlY3Rpb25FdmVudFR5cGUuUkVNT1ZFLFxuICAgICAgLyoqXG4gICAgICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vQ29sbGVjdGlvbi5qc1wiKS5Db2xsZWN0aW9uRXZlbnQ8aW1wb3J0KFwiLi9pbnRlcmFjdGlvbi9JbnRlcmFjdGlvbi5qc1wiKS5kZWZhdWx0Pn0gZXZlbnQgQ29sbGVjdGlvbkV2ZW50LlxuICAgICAgICovXG4gICAgICAoZXZlbnQpID0+IHtcbiAgICAgICAgZXZlbnQuZWxlbWVudC5zZXRNYXAobnVsbCk7XG4gICAgICB9XG4gICAgKTtcblxuICAgIHRoaXMub3ZlcmxheXNfLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICBDb2xsZWN0aW9uRXZlbnRUeXBlLkFERCxcbiAgICAgIC8qKlxuICAgICAgICogQHBhcmFtIHtpbXBvcnQoXCIuL0NvbGxlY3Rpb24uanNcIikuQ29sbGVjdGlvbkV2ZW50PGltcG9ydChcIi4vT3ZlcmxheS5qc1wiKS5kZWZhdWx0Pn0gZXZlbnQgQ29sbGVjdGlvbkV2ZW50LlxuICAgICAgICovXG4gICAgICAoZXZlbnQpID0+IHtcbiAgICAgICAgdGhpcy5hZGRPdmVybGF5SW50ZXJuYWxfKGV2ZW50LmVsZW1lbnQpO1xuICAgICAgfVxuICAgICk7XG5cbiAgICB0aGlzLm92ZXJsYXlzXy5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgQ29sbGVjdGlvbkV2ZW50VHlwZS5SRU1PVkUsXG4gICAgICAvKipcbiAgICAgICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9Db2xsZWN0aW9uLmpzXCIpLkNvbGxlY3Rpb25FdmVudDxpbXBvcnQoXCIuL092ZXJsYXkuanNcIikuZGVmYXVsdD59IGV2ZW50IENvbGxlY3Rpb25FdmVudC5cbiAgICAgICAqL1xuICAgICAgKGV2ZW50KSA9PiB7XG4gICAgICAgIGNvbnN0IGlkID0gZXZlbnQuZWxlbWVudC5nZXRJZCgpO1xuICAgICAgICBpZiAoaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLm92ZXJsYXlJZEluZGV4X1tpZC50b1N0cmluZygpXTtcbiAgICAgICAgfVxuICAgICAgICBldmVudC5lbGVtZW50LnNldE1hcChudWxsKTtcbiAgICAgIH1cbiAgICApO1xuXG4gICAgdGhpcy5jb250cm9scy5mb3JFYWNoKFxuICAgICAgLyoqXG4gICAgICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vY29udHJvbC9Db250cm9sLmpzXCIpLmRlZmF1bHR9IGNvbnRyb2wgQ29udHJvbC5cbiAgICAgICAqL1xuICAgICAgKGNvbnRyb2wpID0+IHtcbiAgICAgICAgY29udHJvbC5zZXRNYXAodGhpcyk7XG4gICAgICB9XG4gICAgKTtcblxuICAgIHRoaXMuaW50ZXJhY3Rpb25zLmZvckVhY2goXG4gICAgICAvKipcbiAgICAgICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9pbnRlcmFjdGlvbi9JbnRlcmFjdGlvbi5qc1wiKS5kZWZhdWx0fSBpbnRlcmFjdGlvbiBJbnRlcmFjdGlvbi5cbiAgICAgICAqL1xuICAgICAgKGludGVyYWN0aW9uKSA9PiB7XG4gICAgICAgIGludGVyYWN0aW9uLnNldE1hcCh0aGlzKTtcbiAgICAgIH1cbiAgICApO1xuXG4gICAgdGhpcy5vdmVybGF5c18uZm9yRWFjaCh0aGlzLmFkZE92ZXJsYXlJbnRlcm5hbF8uYmluZCh0aGlzKSk7XG4gIH1cblxuICAvKipcbiAgICogQWRkIHRoZSBnaXZlbiBjb250cm9sIHRvIHRoZSBtYXAuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9jb250cm9sL0NvbnRyb2wuanNcIikuZGVmYXVsdH0gY29udHJvbCBDb250cm9sLlxuICAgKiBAYXBpXG4gICAqL1xuICBhZGRDb250cm9sKGNvbnRyb2wpIHtcbiAgICB0aGlzLmdldENvbnRyb2xzKCkucHVzaChjb250cm9sKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgdGhlIGdpdmVuIGludGVyYWN0aW9uIHRvIHRoZSBtYXAuIElmIHlvdSB3YW50IHRvIGFkZCBhbiBpbnRlcmFjdGlvblxuICAgKiBhdCBhbm90aGVyIHBvaW50IG9mIHRoZSBjb2xsZWN0aW9uIHVzZSBgZ2V0SW50ZXJhY3Rpb25zKClgIGFuZCB0aGUgbWV0aG9kc1xuICAgKiBhdmFpbGFibGUgb24ge0BsaW5rIG1vZHVsZTpvbC9Db2xsZWN0aW9ufkNvbGxlY3Rpb259LiBUaGlzIGNhbiBiZSB1c2VkIHRvXG4gICAqIHN0b3AgdGhlIGV2ZW50IHByb3BhZ2F0aW9uIGZyb20gdGhlIGhhbmRsZUV2ZW50IGZ1bmN0aW9uLiBUaGUgaW50ZXJhY3Rpb25zXG4gICAqIGdldCB0byBoYW5kbGUgdGhlIGV2ZW50cyBpbiB0aGUgcmV2ZXJzZSBvcmRlciBvZiB0aGlzIGNvbGxlY3Rpb24uXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9pbnRlcmFjdGlvbi9JbnRlcmFjdGlvbi5qc1wiKS5kZWZhdWx0fSBpbnRlcmFjdGlvbiBJbnRlcmFjdGlvbiB0byBhZGQuXG4gICAqIEBhcGlcbiAgICovXG4gIGFkZEludGVyYWN0aW9uKGludGVyYWN0aW9uKSB7XG4gICAgdGhpcy5nZXRJbnRlcmFjdGlvbnMoKS5wdXNoKGludGVyYWN0aW9uKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIHRoZSBnaXZlbiBsYXllciB0byB0aGUgdG9wIG9mIHRoaXMgbWFwLiBJZiB5b3Ugd2FudCB0byBhZGQgYSBsYXllclxuICAgKiBlbHNld2hlcmUgaW4gdGhlIHN0YWNrLCB1c2UgYGdldExheWVycygpYCBhbmQgdGhlIG1ldGhvZHMgYXZhaWxhYmxlIG9uXG4gICAqIHtAbGluayBtb2R1bGU6b2wvQ29sbGVjdGlvbn5Db2xsZWN0aW9ufS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL2xheWVyL0Jhc2UuanNcIikuZGVmYXVsdH0gbGF5ZXIgTGF5ZXIuXG4gICAqIEBhcGlcbiAgICovXG4gIGFkZExheWVyKGxheWVyKSB7XG4gICAgY29uc3QgbGF5ZXJzID0gdGhpcy5nZXRMYXllckdyb3VwKCkuZ2V0TGF5ZXJzKCk7XG4gICAgbGF5ZXJzLnB1c2gobGF5ZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9sYXllci9Hcm91cC5qc1wiKS5Hcm91cEV2ZW50fSBldmVudCBUaGUgbGF5ZXIgYWRkIGV2ZW50LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaGFuZGxlTGF5ZXJBZGRfKGV2ZW50KSB7XG4gICAgc2V0TGF5ZXJNYXBQcm9wZXJ0eShldmVudC5sYXllciwgdGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogQWRkIHRoZSBnaXZlbiBvdmVybGF5IHRvIHRoZSBtYXAuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9PdmVybGF5LmpzXCIpLmRlZmF1bHR9IG92ZXJsYXkgT3ZlcmxheS5cbiAgICogQGFwaVxuICAgKi9cbiAgYWRkT3ZlcmxheShvdmVybGF5KSB7XG4gICAgdGhpcy5nZXRPdmVybGF5cygpLnB1c2gob3ZlcmxheSk7XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBkZWFscyB3aXRoIG1hcCdzIG92ZXJsYXkgY29sbGVjdGlvbiBjaGFuZ2VzLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vT3ZlcmxheS5qc1wiKS5kZWZhdWx0fSBvdmVybGF5IE92ZXJsYXkuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBhZGRPdmVybGF5SW50ZXJuYWxfKG92ZXJsYXkpIHtcbiAgICBjb25zdCBpZCA9IG92ZXJsYXkuZ2V0SWQoKTtcbiAgICBpZiAoaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5vdmVybGF5SWRJbmRleF9baWQudG9TdHJpbmcoKV0gPSBvdmVybGF5O1xuICAgIH1cbiAgICBvdmVybGF5LnNldE1hcCh0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBDbGVhbiB1cC5cbiAgICovXG4gIGRpc3Bvc2VJbnRlcm5hbCgpIHtcbiAgICB0aGlzLmNvbnRyb2xzLmNsZWFyKCk7XG4gICAgdGhpcy5pbnRlcmFjdGlvbnMuY2xlYXIoKTtcbiAgICB0aGlzLm92ZXJsYXlzXy5jbGVhcigpO1xuICAgIHRoaXMucmVzaXplT2JzZXJ2ZXJfLmRpc2Nvbm5lY3QoKTtcbiAgICB0aGlzLnNldFRhcmdldChudWxsKTtcbiAgICBzdXBlci5kaXNwb3NlSW50ZXJuYWwoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlY3QgZmVhdHVyZXMgdGhhdCBpbnRlcnNlY3QgYSBwaXhlbCBvbiB0aGUgdmlld3BvcnQsIGFuZCBleGVjdXRlIGFcbiAgICogY2FsbGJhY2sgd2l0aCBlYWNoIGludGVyc2VjdGluZyBmZWF0dXJlLiBMYXllcnMgaW5jbHVkZWQgaW4gdGhlIGRldGVjdGlvbiBjYW5cbiAgICogYmUgY29uZmlndXJlZCB0aHJvdWdoIHRoZSBgbGF5ZXJGaWx0ZXJgIG9wdGlvbiBpbiBgb3B0aW9uc2AuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9waXhlbC5qc1wiKS5QaXhlbH0gcGl4ZWwgUGl4ZWwuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oaW1wb3J0KFwiLi9GZWF0dXJlLmpzXCIpLkZlYXR1cmVMaWtlLCBpbXBvcnQoXCIuL2xheWVyL0xheWVyLmpzXCIpLmRlZmF1bHQ8aW1wb3J0KFwiLi9zb3VyY2UvU291cmNlXCIpLmRlZmF1bHQ+LCBpbXBvcnQoXCIuL2dlb20vU2ltcGxlR2VvbWV0cnkuanNcIikuZGVmYXVsdCk6IFR9IGNhbGxiYWNrIEZlYXR1cmUgY2FsbGJhY2suIFRoZSBjYWxsYmFjayB3aWxsIGJlXG4gICAqICAgICBjYWxsZWQgd2l0aCB0d28gYXJndW1lbnRzLiBUaGUgZmlyc3QgYXJndW1lbnQgaXMgb25lXG4gICAqICAgICB7QGxpbmsgbW9kdWxlOm9sL0ZlYXR1cmV+RmVhdHVyZSBmZWF0dXJlfSBvclxuICAgKiAgICAge0BsaW5rIG1vZHVsZTpvbC9yZW5kZXIvRmVhdHVyZX5SZW5kZXJGZWF0dXJlIHJlbmRlciBmZWF0dXJlfSBhdCB0aGUgcGl4ZWwsIHRoZSBzZWNvbmQgaXNcbiAgICogICAgIHRoZSB7QGxpbmsgbW9kdWxlOm9sL2xheWVyL0xheWVyfkxheWVyIGxheWVyfSBvZiB0aGUgZmVhdHVyZSBhbmQgd2lsbCBiZSBudWxsIGZvclxuICAgKiAgICAgdW5tYW5hZ2VkIGxheWVycy4gVG8gc3RvcCBkZXRlY3Rpb24sIGNhbGxiYWNrIGZ1bmN0aW9ucyBjYW4gcmV0dXJuIGFcbiAgICogICAgIHRydXRoeSB2YWx1ZS5cbiAgICogQHBhcmFtIHtBdFBpeGVsT3B0aW9uc30gW29wdGlvbnNdIE9wdGlvbmFsIG9wdGlvbnMuXG4gICAqIEByZXR1cm4ge1R8dW5kZWZpbmVkfSBDYWxsYmFjayByZXN1bHQsIGkuZS4gdGhlIHJldHVybiB2YWx1ZSBvZiBsYXN0XG4gICAqIGNhbGxiYWNrIGV4ZWN1dGlvbiwgb3IgdGhlIGZpcnN0IHRydXRoeSBjYWxsYmFjayByZXR1cm4gdmFsdWUuXG4gICAqIEB0ZW1wbGF0ZSBUXG4gICAqIEBhcGlcbiAgICovXG4gIGZvckVhY2hGZWF0dXJlQXRQaXhlbChwaXhlbCwgY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICBpZiAoIXRoaXMuZnJhbWVTdGF0ZV8gfHwgIXRoaXMucmVuZGVyZXJfKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGNvb3JkaW5hdGUgPSB0aGlzLmdldENvb3JkaW5hdGVGcm9tUGl4ZWxJbnRlcm5hbChwaXhlbCk7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMgOiB7fTtcbiAgICBjb25zdCBoaXRUb2xlcmFuY2UgPVxuICAgICAgb3B0aW9ucy5oaXRUb2xlcmFuY2UgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuaGl0VG9sZXJhbmNlIDogMDtcbiAgICBjb25zdCBsYXllckZpbHRlciA9XG4gICAgICBvcHRpb25zLmxheWVyRmlsdGVyICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmxheWVyRmlsdGVyIDogVFJVRTtcbiAgICBjb25zdCBjaGVja1dyYXBwZWQgPSBvcHRpb25zLmNoZWNrV3JhcHBlZCAhPT0gZmFsc2U7XG4gICAgcmV0dXJuIHRoaXMucmVuZGVyZXJfLmZvckVhY2hGZWF0dXJlQXRDb29yZGluYXRlKFxuICAgICAgY29vcmRpbmF0ZSxcbiAgICAgIHRoaXMuZnJhbWVTdGF0ZV8sXG4gICAgICBoaXRUb2xlcmFuY2UsXG4gICAgICBjaGVja1dyYXBwZWQsXG4gICAgICBjYWxsYmFjayxcbiAgICAgIG51bGwsXG4gICAgICBsYXllckZpbHRlcixcbiAgICAgIG51bGxcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhbGwgZmVhdHVyZXMgdGhhdCBpbnRlcnNlY3QgYSBwaXhlbCBvbiB0aGUgdmlld3BvcnQuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9waXhlbC5qc1wiKS5QaXhlbH0gcGl4ZWwgUGl4ZWwuXG4gICAqIEBwYXJhbSB7QXRQaXhlbE9wdGlvbnN9IFtvcHRpb25zXSBPcHRpb25hbCBvcHRpb25zLlxuICAgKiBAcmV0dXJuIHtBcnJheTxpbXBvcnQoXCIuL0ZlYXR1cmUuanNcIikuRmVhdHVyZUxpa2U+fSBUaGUgZGV0ZWN0ZWQgZmVhdHVyZXMgb3JcbiAgICogYW4gZW1wdHkgYXJyYXkgaWYgbm9uZSB3ZXJlIGZvdW5kLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRGZWF0dXJlc0F0UGl4ZWwocGl4ZWwsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBmZWF0dXJlcyA9IFtdO1xuICAgIHRoaXMuZm9yRWFjaEZlYXR1cmVBdFBpeGVsKFxuICAgICAgcGl4ZWwsXG4gICAgICBmdW5jdGlvbiAoZmVhdHVyZSkge1xuICAgICAgICBmZWF0dXJlcy5wdXNoKGZlYXR1cmUpO1xuICAgICAgfSxcbiAgICAgIG9wdGlvbnNcbiAgICApO1xuICAgIHJldHVybiBmZWF0dXJlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYWxsIGxheWVycyBmcm9tIGFsbCBsYXllciBncm91cHMuXG4gICAqIEByZXR1cm4ge0FycmF5PGltcG9ydChcIi4vbGF5ZXIvTGF5ZXIuanNcIikuZGVmYXVsdD59IExheWVycy5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0QWxsTGF5ZXJzKCkge1xuICAgIGNvbnN0IGxheWVycyA9IFtdO1xuICAgIGZ1bmN0aW9uIGFkZExheWVyc0Zyb20obGF5ZXJHcm91cCkge1xuICAgICAgbGF5ZXJHcm91cC5mb3JFYWNoKGZ1bmN0aW9uIChsYXllcikge1xuICAgICAgICBpZiAobGF5ZXIgaW5zdGFuY2VvZiBMYXllckdyb3VwKSB7XG4gICAgICAgICAgYWRkTGF5ZXJzRnJvbShsYXllci5nZXRMYXllcnMoKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGF5ZXJzLnB1c2gobGF5ZXIpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgYWRkTGF5ZXJzRnJvbSh0aGlzLmdldExheWVycygpKTtcbiAgICByZXR1cm4gbGF5ZXJzO1xuICB9XG5cbiAgLyoqXG4gICAqIERldGVjdCBpZiBmZWF0dXJlcyBpbnRlcnNlY3QgYSBwaXhlbCBvbiB0aGUgdmlld3BvcnQuIExheWVycyBpbmNsdWRlZCBpbiB0aGVcbiAgICogZGV0ZWN0aW9uIGNhbiBiZSBjb25maWd1cmVkIHRocm91Z2ggdGhlIGBsYXllckZpbHRlcmAgb3B0aW9uLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vcGl4ZWwuanNcIikuUGl4ZWx9IHBpeGVsIFBpeGVsLlxuICAgKiBAcGFyYW0ge0F0UGl4ZWxPcHRpb25zfSBbb3B0aW9uc10gT3B0aW9uYWwgb3B0aW9ucy5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gSXMgdGhlcmUgYSBmZWF0dXJlIGF0IHRoZSBnaXZlbiBwaXhlbD9cbiAgICogQGFwaVxuICAgKi9cbiAgaGFzRmVhdHVyZUF0UGl4ZWwocGl4ZWwsIG9wdGlvbnMpIHtcbiAgICBpZiAoIXRoaXMuZnJhbWVTdGF0ZV8gfHwgIXRoaXMucmVuZGVyZXJfKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGNvb3JkaW5hdGUgPSB0aGlzLmdldENvb3JkaW5hdGVGcm9tUGl4ZWxJbnRlcm5hbChwaXhlbCk7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMgOiB7fTtcbiAgICBjb25zdCBsYXllckZpbHRlciA9XG4gICAgICBvcHRpb25zLmxheWVyRmlsdGVyICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmxheWVyRmlsdGVyIDogVFJVRTtcbiAgICBjb25zdCBoaXRUb2xlcmFuY2UgPVxuICAgICAgb3B0aW9ucy5oaXRUb2xlcmFuY2UgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuaGl0VG9sZXJhbmNlIDogMDtcbiAgICBjb25zdCBjaGVja1dyYXBwZWQgPSBvcHRpb25zLmNoZWNrV3JhcHBlZCAhPT0gZmFsc2U7XG4gICAgcmV0dXJuIHRoaXMucmVuZGVyZXJfLmhhc0ZlYXR1cmVBdENvb3JkaW5hdGUoXG4gICAgICBjb29yZGluYXRlLFxuICAgICAgdGhpcy5mcmFtZVN0YXRlXyxcbiAgICAgIGhpdFRvbGVyYW5jZSxcbiAgICAgIGNoZWNrV3JhcHBlZCxcbiAgICAgIGxheWVyRmlsdGVyLFxuICAgICAgbnVsbFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY29vcmRpbmF0ZSBpbiB1c2VyIHByb2plY3Rpb24gZm9yIGEgYnJvd3NlciBldmVudC5cbiAgICogQHBhcmFtIHtNb3VzZUV2ZW50fSBldmVudCBFdmVudC5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IENvb3JkaW5hdGUuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldEV2ZW50Q29vcmRpbmF0ZShldmVudCkge1xuICAgIHJldHVybiB0aGlzLmdldENvb3JkaW5hdGVGcm9tUGl4ZWwodGhpcy5nZXRFdmVudFBpeGVsKGV2ZW50KSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY29vcmRpbmF0ZSBpbiB2aWV3IHByb2plY3Rpb24gZm9yIGEgYnJvd3NlciBldmVudC5cbiAgICogQHBhcmFtIHtNb3VzZUV2ZW50fSBldmVudCBFdmVudC5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IENvb3JkaW5hdGUuXG4gICAqL1xuICBnZXRFdmVudENvb3JkaW5hdGVJbnRlcm5hbChldmVudCkge1xuICAgIHJldHVybiB0aGlzLmdldENvb3JkaW5hdGVGcm9tUGl4ZWxJbnRlcm5hbCh0aGlzLmdldEV2ZW50UGl4ZWwoZXZlbnQpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBtYXAgcGl4ZWwgcG9zaXRpb24gZm9yIGEgYnJvd3NlciBldmVudCByZWxhdGl2ZSB0byB0aGUgdmlld3BvcnQuXG4gICAqIEBwYXJhbSB7VUlFdmVudHx7Y2xpZW50WDogbnVtYmVyLCBjbGllbnRZOiBudW1iZXJ9fSBldmVudCBFdmVudC5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi9waXhlbC5qc1wiKS5QaXhlbH0gUGl4ZWwuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldEV2ZW50UGl4ZWwoZXZlbnQpIHtcbiAgICBjb25zdCB2aWV3cG9ydCA9IHRoaXMudmlld3BvcnRfO1xuICAgIGNvbnN0IHZpZXdwb3J0UG9zaXRpb24gPSB2aWV3cG9ydC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBjb25zdCB2aWV3cG9ydFNpemUgPSB0aGlzLmdldFNpemUoKTtcbiAgICBjb25zdCBzY2FsZVggPSB2aWV3cG9ydFBvc2l0aW9uLndpZHRoIC8gdmlld3BvcnRTaXplWzBdO1xuICAgIGNvbnN0IHNjYWxlWSA9IHZpZXdwb3J0UG9zaXRpb24uaGVpZ2h0IC8gdmlld3BvcnRTaXplWzFdO1xuICAgIGNvbnN0IGV2ZW50UG9zaXRpb24gPVxuICAgICAgLy9GSVhNRSBBcmUgd2UgcmVhbGx5IGNhbGxpbmcgdGhpcyB3aXRoIGEgVG91Y2hFdmVudCBhbnl3aGVyZT9cbiAgICAgICdjaGFuZ2VkVG91Y2hlcycgaW4gZXZlbnRcbiAgICAgICAgPyAvKiogQHR5cGUge1RvdWNoRXZlbnR9ICovIChldmVudCkuY2hhbmdlZFRvdWNoZXNbMF1cbiAgICAgICAgOiAvKiogQHR5cGUge01vdXNlRXZlbnR9ICovIChldmVudCk7XG5cbiAgICByZXR1cm4gW1xuICAgICAgKGV2ZW50UG9zaXRpb24uY2xpZW50WCAtIHZpZXdwb3J0UG9zaXRpb24ubGVmdCkgLyBzY2FsZVgsXG4gICAgICAoZXZlbnRQb3NpdGlvbi5jbGllbnRZIC0gdmlld3BvcnRQb3NpdGlvbi50b3ApIC8gc2NhbGVZLFxuICAgIF07XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB0YXJnZXQgaW4gd2hpY2ggdGhpcyBtYXAgaXMgcmVuZGVyZWQuXG4gICAqIE5vdGUgdGhhdCB0aGlzIHJldHVybnMgd2hhdCBpcyBlbnRlcmVkIGFzIGFuIG9wdGlvbiBvciBpbiBzZXRUYXJnZXQ6XG4gICAqIGlmIHRoYXQgd2FzIGFuIGVsZW1lbnQsIGl0IHJldHVybnMgYW4gZWxlbWVudDsgaWYgYSBzdHJpbmcsIGl0IHJldHVybnMgdGhhdC5cbiAgICogQHJldHVybiB7SFRNTEVsZW1lbnR8c3RyaW5nfHVuZGVmaW5lZH0gVGhlIEVsZW1lbnQgb3IgaWQgb2YgdGhlIEVsZW1lbnQgdGhhdCB0aGVcbiAgICogICAgIG1hcCBpcyByZW5kZXJlZCBpbi5cbiAgICogQG9ic2VydmFibGVcbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0VGFyZ2V0KCkge1xuICAgIHJldHVybiAvKiogQHR5cGUge0hUTUxFbGVtZW50fHN0cmluZ3x1bmRlZmluZWR9ICovIChcbiAgICAgIHRoaXMuZ2V0KE1hcFByb3BlcnR5LlRBUkdFVClcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgRE9NIGVsZW1lbnQgaW50byB3aGljaCB0aGlzIG1hcCBpcyByZW5kZXJlZC4gSW4gY29udHJhc3QgdG9cbiAgICogYGdldFRhcmdldGAgdGhpcyBtZXRob2QgYWx3YXlzIHJldHVybiBhbiBgRWxlbWVudGAsIG9yIGBudWxsYCBpZiB0aGVcbiAgICogbWFwIGhhcyBubyB0YXJnZXQuXG4gICAqIEByZXR1cm4ge0hUTUxFbGVtZW50fSBUaGUgZWxlbWVudCB0aGF0IHRoZSBtYXAgaXMgcmVuZGVyZWQgaW4uXG4gICAqIEBhcGlcbiAgICovXG4gIGdldFRhcmdldEVsZW1lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMudGFyZ2V0RWxlbWVudF87XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBjb29yZGluYXRlIGZvciBhIGdpdmVuIHBpeGVsLiAgVGhpcyByZXR1cm5zIGEgY29vcmRpbmF0ZSBpbiB0aGVcbiAgICogdXNlciBwcm9qZWN0aW9uLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vcGl4ZWwuanNcIikuUGl4ZWx9IHBpeGVsIFBpeGVsIHBvc2l0aW9uIGluIHRoZSBtYXAgdmlld3BvcnQuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBUaGUgY29vcmRpbmF0ZSBmb3IgdGhlIHBpeGVsIHBvc2l0aW9uLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRDb29yZGluYXRlRnJvbVBpeGVsKHBpeGVsKSB7XG4gICAgcmV0dXJuIHRvVXNlckNvb3JkaW5hdGUoXG4gICAgICB0aGlzLmdldENvb3JkaW5hdGVGcm9tUGl4ZWxJbnRlcm5hbChwaXhlbCksXG4gICAgICB0aGlzLmdldFZpZXcoKS5nZXRQcm9qZWN0aW9uKClcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgY29vcmRpbmF0ZSBmb3IgYSBnaXZlbiBwaXhlbC4gIFRoaXMgcmV0dXJucyBhIGNvb3JkaW5hdGUgaW4gdGhlXG4gICAqIG1hcCB2aWV3IHByb2plY3Rpb24uXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9waXhlbC5qc1wiKS5QaXhlbH0gcGl4ZWwgUGl4ZWwgcG9zaXRpb24gaW4gdGhlIG1hcCB2aWV3cG9ydC5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IFRoZSBjb29yZGluYXRlIGZvciB0aGUgcGl4ZWwgcG9zaXRpb24uXG4gICAqL1xuICBnZXRDb29yZGluYXRlRnJvbVBpeGVsSW50ZXJuYWwocGl4ZWwpIHtcbiAgICBjb25zdCBmcmFtZVN0YXRlID0gdGhpcy5mcmFtZVN0YXRlXztcbiAgICBpZiAoIWZyYW1lU3RhdGUpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gYXBwbHlUcmFuc2Zvcm0oZnJhbWVTdGF0ZS5waXhlbFRvQ29vcmRpbmF0ZVRyYW5zZm9ybSwgcGl4ZWwuc2xpY2UoKSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBtYXAgY29udHJvbHMuIE1vZGlmeWluZyB0aGlzIGNvbGxlY3Rpb24gY2hhbmdlcyB0aGUgY29udHJvbHNcbiAgICogYXNzb2NpYXRlZCB3aXRoIHRoZSBtYXAuXG4gICAqIEByZXR1cm4ge0NvbGxlY3Rpb248aW1wb3J0KFwiLi9jb250cm9sL0NvbnRyb2wuanNcIikuZGVmYXVsdD59IENvbnRyb2xzLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRDb250cm9scygpIHtcbiAgICByZXR1cm4gdGhpcy5jb250cm9scztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG1hcCBvdmVybGF5cy4gTW9kaWZ5aW5nIHRoaXMgY29sbGVjdGlvbiBjaGFuZ2VzIHRoZSBvdmVybGF5c1xuICAgKiBhc3NvY2lhdGVkIHdpdGggdGhlIG1hcC5cbiAgICogQHJldHVybiB7Q29sbGVjdGlvbjxpbXBvcnQoXCIuL092ZXJsYXkuanNcIikuZGVmYXVsdD59IE92ZXJsYXlzLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRPdmVybGF5cygpIHtcbiAgICByZXR1cm4gdGhpcy5vdmVybGF5c187XG4gIH1cblxuICAvKipcbiAgICogR2V0IGFuIG92ZXJsYXkgYnkgaXRzIGlkZW50aWZpZXIgKHRoZSB2YWx1ZSByZXR1cm5lZCBieSBvdmVybGF5LmdldElkKCkpLlxuICAgKiBOb3RlIHRoYXQgdGhlIGluZGV4IHRyZWF0cyBzdHJpbmcgYW5kIG51bWVyaWMgaWRlbnRpZmllcnMgYXMgdGhlIHNhbWUuIFNvXG4gICAqIGBtYXAuZ2V0T3ZlcmxheUJ5SWQoMilgIHdpbGwgcmV0dXJuIGFuIG92ZXJsYXkgd2l0aCBpZCBgJzInYCBvciBgMmAuXG4gICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gaWQgT3ZlcmxheSBpZGVudGlmaWVyLlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuL092ZXJsYXkuanNcIikuZGVmYXVsdH0gT3ZlcmxheS5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0T3ZlcmxheUJ5SWQoaWQpIHtcbiAgICBjb25zdCBvdmVybGF5ID0gdGhpcy5vdmVybGF5SWRJbmRleF9baWQudG9TdHJpbmcoKV07XG4gICAgcmV0dXJuIG92ZXJsYXkgIT09IHVuZGVmaW5lZCA/IG92ZXJsYXkgOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbWFwIGludGVyYWN0aW9ucy4gTW9kaWZ5aW5nIHRoaXMgY29sbGVjdGlvbiBjaGFuZ2VzIHRoZSBpbnRlcmFjdGlvbnNcbiAgICogYXNzb2NpYXRlZCB3aXRoIHRoZSBtYXAuXG4gICAqXG4gICAqIEludGVyYWN0aW9ucyBhcmUgdXNlZCBmb3IgZS5nLiBwYW4sIHpvb20gYW5kIHJvdGF0ZS5cbiAgICogQHJldHVybiB7Q29sbGVjdGlvbjxpbXBvcnQoXCIuL2ludGVyYWN0aW9uL0ludGVyYWN0aW9uLmpzXCIpLmRlZmF1bHQ+fSBJbnRlcmFjdGlvbnMuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldEludGVyYWN0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5pbnRlcmFjdGlvbnM7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBsYXllcmdyb3VwIGFzc29jaWF0ZWQgd2l0aCB0aGlzIG1hcC5cbiAgICogQHJldHVybiB7TGF5ZXJHcm91cH0gQSBsYXllciBncm91cCBjb250YWluaW5nIHRoZSBsYXllcnMgaW4gdGhpcyBtYXAuXG4gICAqIEBvYnNlcnZhYmxlXG4gICAqIEBhcGlcbiAgICovXG4gIGdldExheWVyR3JvdXAoKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7TGF5ZXJHcm91cH0gKi8gKHRoaXMuZ2V0KE1hcFByb3BlcnR5LkxBWUVSR1JPVVApKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhciBhbnkgZXhpc3RpbmcgbGF5ZXJzIGFuZCBhZGQgbGF5ZXJzIHRvIHRoZSBtYXAuXG4gICAqIEBwYXJhbSB7QXJyYXk8aW1wb3J0KFwiLi9sYXllci9CYXNlLmpzXCIpLmRlZmF1bHQ+fENvbGxlY3Rpb248aW1wb3J0KFwiLi9sYXllci9CYXNlLmpzXCIpLmRlZmF1bHQ+fSBsYXllcnMgVGhlIGxheWVycyB0byBiZSBhZGRlZCB0byB0aGUgbWFwLlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRMYXllcnMobGF5ZXJzKSB7XG4gICAgY29uc3QgZ3JvdXAgPSB0aGlzLmdldExheWVyR3JvdXAoKTtcbiAgICBpZiAobGF5ZXJzIGluc3RhbmNlb2YgQ29sbGVjdGlvbikge1xuICAgICAgZ3JvdXAuc2V0TGF5ZXJzKGxheWVycyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgY29sbGVjdGlvbiA9IGdyb3VwLmdldExheWVycygpO1xuICAgIGNvbGxlY3Rpb24uY2xlYXIoKTtcbiAgICBjb2xsZWN0aW9uLmV4dGVuZChsYXllcnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgY29sbGVjdGlvbiBvZiBsYXllcnMgYXNzb2NpYXRlZCB3aXRoIHRoaXMgbWFwLlxuICAgKiBAcmV0dXJuIHshQ29sbGVjdGlvbjxpbXBvcnQoXCIuL2xheWVyL0Jhc2UuanNcIikuZGVmYXVsdD59IExheWVycy5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0TGF5ZXJzKCkge1xuICAgIGNvbnN0IGxheWVycyA9IHRoaXMuZ2V0TGF5ZXJHcm91cCgpLmdldExheWVycygpO1xuICAgIHJldHVybiBsYXllcnM7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gTGF5ZXJzIGhhdmUgc291cmNlcyB0aGF0IGFyZSBzdGlsbCBsb2FkaW5nLlxuICAgKi9cbiAgZ2V0TG9hZGluZ09yTm90UmVhZHkoKSB7XG4gICAgY29uc3QgbGF5ZXJTdGF0ZXNBcnJheSA9IHRoaXMuZ2V0TGF5ZXJHcm91cCgpLmdldExheWVyU3RhdGVzQXJyYXkoKTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBsYXllclN0YXRlc0FycmF5Lmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgIGNvbnN0IHN0YXRlID0gbGF5ZXJTdGF0ZXNBcnJheVtpXTtcbiAgICAgIGlmICghc3RhdGUudmlzaWJsZSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlbmRlcmVyID0gc3RhdGUubGF5ZXIuZ2V0UmVuZGVyZXIoKTtcbiAgICAgIGlmIChyZW5kZXJlciAmJiAhcmVuZGVyZXIucmVhZHkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBjb25zdCBzb3VyY2UgPSBzdGF0ZS5sYXllci5nZXRTb3VyY2UoKTtcbiAgICAgIGlmIChzb3VyY2UgJiYgc291cmNlLmxvYWRpbmcpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHBpeGVsIGZvciBhIGNvb3JkaW5hdGUuICBUaGlzIHRha2VzIGEgY29vcmRpbmF0ZSBpbiB0aGUgdXNlclxuICAgKiBwcm9qZWN0aW9uIGFuZCByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIHBpeGVsLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBjb29yZGluYXRlIEEgbWFwIGNvb3JkaW5hdGUuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4vcGl4ZWwuanNcIikuUGl4ZWx9IEEgcGl4ZWwgcG9zaXRpb24gaW4gdGhlIG1hcCB2aWV3cG9ydC5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0UGl4ZWxGcm9tQ29vcmRpbmF0ZShjb29yZGluYXRlKSB7XG4gICAgY29uc3Qgdmlld0Nvb3JkaW5hdGUgPSBmcm9tVXNlckNvb3JkaW5hdGUoXG4gICAgICBjb29yZGluYXRlLFxuICAgICAgdGhpcy5nZXRWaWV3KCkuZ2V0UHJvamVjdGlvbigpXG4gICAgKTtcbiAgICByZXR1cm4gdGhpcy5nZXRQaXhlbEZyb21Db29yZGluYXRlSW50ZXJuYWwodmlld0Nvb3JkaW5hdGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgcGl4ZWwgZm9yIGEgY29vcmRpbmF0ZS4gIFRoaXMgdGFrZXMgYSBjb29yZGluYXRlIGluIHRoZSBtYXAgdmlld1xuICAgKiBwcm9qZWN0aW9uIGFuZCByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIHBpeGVsLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBjb29yZGluYXRlIEEgbWFwIGNvb3JkaW5hdGUuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4vcGl4ZWwuanNcIikuUGl4ZWx9IEEgcGl4ZWwgcG9zaXRpb24gaW4gdGhlIG1hcCB2aWV3cG9ydC5cbiAgICovXG4gIGdldFBpeGVsRnJvbUNvb3JkaW5hdGVJbnRlcm5hbChjb29yZGluYXRlKSB7XG4gICAgY29uc3QgZnJhbWVTdGF0ZSA9IHRoaXMuZnJhbWVTdGF0ZV87XG4gICAgaWYgKCFmcmFtZVN0YXRlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGFwcGx5VHJhbnNmb3JtKFxuICAgICAgZnJhbWVTdGF0ZS5jb29yZGluYXRlVG9QaXhlbFRyYW5zZm9ybSxcbiAgICAgIGNvb3JkaW5hdGUuc2xpY2UoMCwgMilcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbWFwIHJlbmRlcmVyLlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuL3JlbmRlcmVyL01hcC5qc1wiKS5kZWZhdWx0fG51bGx9IFJlbmRlcmVyXG4gICAqL1xuICBnZXRSZW5kZXJlcigpIHtcbiAgICByZXR1cm4gdGhpcy5yZW5kZXJlcl87XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBzaXplIG9mIHRoaXMgbWFwLlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuL3NpemUuanNcIikuU2l6ZXx1bmRlZmluZWR9IFRoZSBzaXplIGluIHBpeGVscyBvZiB0aGUgbWFwIGluIHRoZSBET00uXG4gICAqIEBvYnNlcnZhYmxlXG4gICAqIEBhcGlcbiAgICovXG4gIGdldFNpemUoKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7aW1wb3J0KFwiLi9zaXplLmpzXCIpLlNpemV8dW5kZWZpbmVkfSAqLyAoXG4gICAgICB0aGlzLmdldChNYXBQcm9wZXJ0eS5TSVpFKVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB2aWV3IGFzc29jaWF0ZWQgd2l0aCB0aGlzIG1hcC4gQSB2aWV3IG1hbmFnZXMgcHJvcGVydGllcyBzdWNoIGFzXG4gICAqIGNlbnRlciBhbmQgcmVzb2x1dGlvbi5cbiAgICogQHJldHVybiB7Vmlld30gVGhlIHZpZXcgdGhhdCBjb250cm9scyB0aGlzIG1hcC5cbiAgICogQG9ic2VydmFibGVcbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0VmlldygpIHtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHtWaWV3fSAqLyAodGhpcy5nZXQoTWFwUHJvcGVydHkuVklFVykpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZWxlbWVudCB0aGF0IHNlcnZlcyBhcyB0aGUgbWFwIHZpZXdwb3J0LlxuICAgKiBAcmV0dXJuIHtIVE1MRWxlbWVudH0gVmlld3BvcnQuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldFZpZXdwb3J0KCkge1xuICAgIHJldHVybiB0aGlzLnZpZXdwb3J0XztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGVsZW1lbnQgdGhhdCBzZXJ2ZXMgYXMgdGhlIGNvbnRhaW5lciBmb3Igb3ZlcmxheXMuICBFbGVtZW50cyBhZGRlZCB0b1xuICAgKiB0aGlzIGNvbnRhaW5lciB3aWxsIGxldCBtb3VzZWRvd24gYW5kIHRvdWNoc3RhcnQgZXZlbnRzIHRocm91Z2ggdG8gdGhlIG1hcCxcbiAgICogc28gY2xpY2tzIGFuZCBnZXN0dXJlcyBvbiBhbiBvdmVybGF5IHdpbGwgdHJpZ2dlciB7QGxpbmsgbW9kdWxlOm9sL01hcEJyb3dzZXJFdmVudH5NYXBCcm93c2VyRXZlbnR9XG4gICAqIGV2ZW50cy5cbiAgICogQHJldHVybiB7IUhUTUxFbGVtZW50fSBUaGUgbWFwJ3Mgb3ZlcmxheSBjb250YWluZXIuXG4gICAqL1xuICBnZXRPdmVybGF5Q29udGFpbmVyKCkge1xuICAgIHJldHVybiB0aGlzLm92ZXJsYXlDb250YWluZXJfO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZWxlbWVudCB0aGF0IHNlcnZlcyBhcyBhIGNvbnRhaW5lciBmb3Igb3ZlcmxheXMgdGhhdCBkb24ndCBhbGxvd1xuICAgKiBldmVudCBwcm9wYWdhdGlvbi4gRWxlbWVudHMgYWRkZWQgdG8gdGhpcyBjb250YWluZXIgd29uJ3QgbGV0IG1vdXNlZG93biBhbmRcbiAgICogdG91Y2hzdGFydCBldmVudHMgdGhyb3VnaCB0byB0aGUgbWFwLCBzbyBjbGlja3MgYW5kIGdlc3R1cmVzIG9uIGFuIG92ZXJsYXlcbiAgICogZG9uJ3QgdHJpZ2dlciBhbnkge0BsaW5rIG1vZHVsZTpvbC9NYXBCcm93c2VyRXZlbnR+TWFwQnJvd3NlckV2ZW50fS5cbiAgICogQHJldHVybiB7IUhUTUxFbGVtZW50fSBUaGUgbWFwJ3Mgb3ZlcmxheSBjb250YWluZXIgdGhhdCBzdG9wcyBldmVudHMuXG4gICAqL1xuICBnZXRPdmVybGF5Q29udGFpbmVyU3RvcEV2ZW50KCkge1xuICAgIHJldHVybiB0aGlzLm92ZXJsYXlDb250YWluZXJTdG9wRXZlbnRfO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4geyFEb2N1bWVudH0gVGhlIGRvY3VtZW50IHdoZXJlIHRoZSBtYXAgaXMgZGlzcGxheWVkLlxuICAgKi9cbiAgZ2V0T3duZXJEb2N1bWVudCgpIHtcbiAgICBjb25zdCB0YXJnZXRFbGVtZW50ID0gdGhpcy5nZXRUYXJnZXRFbGVtZW50KCk7XG4gICAgcmV0dXJuIHRhcmdldEVsZW1lbnQgPyB0YXJnZXRFbGVtZW50Lm93bmVyRG9jdW1lbnQgOiBkb2N1bWVudDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vVGlsZS5qc1wiKS5kZWZhdWx0fSB0aWxlIFRpbGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0aWxlU291cmNlS2V5IFRpbGUgc291cmNlIGtleS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gdGlsZUNlbnRlciBUaWxlIGNlbnRlci5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHRpbGVSZXNvbHV0aW9uIFRpbGUgcmVzb2x1dGlvbi5cbiAgICogQHJldHVybiB7bnVtYmVyfSBUaWxlIHByaW9yaXR5LlxuICAgKi9cbiAgZ2V0VGlsZVByaW9yaXR5KHRpbGUsIHRpbGVTb3VyY2VLZXksIHRpbGVDZW50ZXIsIHRpbGVSZXNvbHV0aW9uKSB7XG4gICAgcmV0dXJuIGdldFRpbGVQcmlvcml0eShcbiAgICAgIHRoaXMuZnJhbWVTdGF0ZV8sXG4gICAgICB0aWxlLFxuICAgICAgdGlsZVNvdXJjZUtleSxcbiAgICAgIHRpbGVDZW50ZXIsXG4gICAgICB0aWxlUmVzb2x1dGlvblxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtVSUV2ZW50fSBicm93c2VyRXZlbnQgQnJvd3NlciBldmVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFt0eXBlXSBUeXBlLlxuICAgKi9cbiAgaGFuZGxlQnJvd3NlckV2ZW50KGJyb3dzZXJFdmVudCwgdHlwZSkge1xuICAgIHR5cGUgPSB0eXBlIHx8IGJyb3dzZXJFdmVudC50eXBlO1xuICAgIGNvbnN0IG1hcEJyb3dzZXJFdmVudCA9IG5ldyBNYXBCcm93c2VyRXZlbnQodHlwZSwgdGhpcywgYnJvd3NlckV2ZW50KTtcbiAgICB0aGlzLmhhbmRsZU1hcEJyb3dzZXJFdmVudChtYXBCcm93c2VyRXZlbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7TWFwQnJvd3NlckV2ZW50fSBtYXBCcm93c2VyRXZlbnQgVGhlIGV2ZW50IHRvIGhhbmRsZS5cbiAgICovXG4gIGhhbmRsZU1hcEJyb3dzZXJFdmVudChtYXBCcm93c2VyRXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuZnJhbWVTdGF0ZV8pIHtcbiAgICAgIC8vIFdpdGggbm8gdmlldyBkZWZpbmVkLCB3ZSBjYW5ub3QgdHJhbnNsYXRlIHBpeGVscyBpbnRvIGdlb2dyYXBoaWNhbFxuICAgICAgLy8gY29vcmRpbmF0ZXMgc28gaW50ZXJhY3Rpb25zIGNhbm5vdCBiZSB1c2VkLlxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBvcmlnaW5hbEV2ZW50ID0gLyoqIEB0eXBlIHtQb2ludGVyRXZlbnR9ICovIChcbiAgICAgIG1hcEJyb3dzZXJFdmVudC5vcmlnaW5hbEV2ZW50XG4gICAgKTtcbiAgICBjb25zdCBldmVudFR5cGUgPSBvcmlnaW5hbEV2ZW50LnR5cGU7XG4gICAgaWYgKFxuICAgICAgZXZlbnRUeXBlID09PSBQb2ludGVyRXZlbnRUeXBlLlBPSU5URVJET1dOIHx8XG4gICAgICBldmVudFR5cGUgPT09IEV2ZW50VHlwZS5XSEVFTCB8fFxuICAgICAgZXZlbnRUeXBlID09PSBFdmVudFR5cGUuS0VZRE9XTlxuICAgICkge1xuICAgICAgY29uc3QgZG9jID0gdGhpcy5nZXRPd25lckRvY3VtZW50KCk7XG4gICAgICBjb25zdCByb290Tm9kZSA9IHRoaXMudmlld3BvcnRfLmdldFJvb3ROb2RlXG4gICAgICAgID8gdGhpcy52aWV3cG9ydF8uZ2V0Um9vdE5vZGUoKVxuICAgICAgICA6IGRvYztcbiAgICAgIGNvbnN0IHRhcmdldCA9IC8qKiBAdHlwZSB7Tm9kZX0gKi8gKG9yaWdpbmFsRXZlbnQudGFyZ2V0KTtcbiAgICAgIGlmIChcbiAgICAgICAgLy8gQWJvcnQgaWYgdGhlIHRhcmdldCBpcyBhIGNoaWxkIG9mIHRoZSBjb250YWluZXIgZm9yIGVsZW1lbnRzIHdob3NlIGV2ZW50cyBhcmUgbm90IG1lYW50XG4gICAgICAgIC8vIHRvIGJlIGhhbmRsZWQgYnkgbWFwIGludGVyYWN0aW9ucy5cbiAgICAgICAgdGhpcy5vdmVybGF5Q29udGFpbmVyU3RvcEV2ZW50Xy5jb250YWlucyh0YXJnZXQpIHx8XG4gICAgICAgIC8vIEFib3J0IGlmIHRoZSBldmVudCB0YXJnZXQgaXMgYSBjaGlsZCBvZiB0aGUgY29udGFpbmVyIHRoYXQgaXMgbm8gbG9uZ2VyIGluIHRoZSBwYWdlLlxuICAgICAgICAvLyBJdCdzIHBvc3NpYmxlIGZvciB0aGUgdGFyZ2V0IHRvIG5vIGxvbmdlciBiZSBpbiB0aGUgcGFnZSBpZiBpdCBoYXMgYmVlbiByZW1vdmVkIGluIGFuXG4gICAgICAgIC8vIGV2ZW50IGxpc3RlbmVyLCB0aGlzIG1pZ2h0IGhhcHBlbiBpbiBhIENvbnRyb2wgdGhhdCByZWNyZWF0ZXMgaXQncyBjb250ZW50IGJhc2VkIG9uXG4gICAgICAgIC8vIHVzZXIgaW50ZXJhY3Rpb24gZWl0aGVyIG1hbnVhbGx5IG9yIHZpYSBhIHJlbmRlciBpbiBzb21ldGhpbmcgbGlrZSBodHRwczovL3JlYWN0anMub3JnL1xuICAgICAgICAhKHJvb3ROb2RlID09PSBkb2MgPyBkb2MuZG9jdW1lbnRFbGVtZW50IDogcm9vdE5vZGUpLmNvbnRhaW5zKHRhcmdldClcbiAgICAgICkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIG1hcEJyb3dzZXJFdmVudC5mcmFtZVN0YXRlID0gdGhpcy5mcmFtZVN0YXRlXztcbiAgICBpZiAodGhpcy5kaXNwYXRjaEV2ZW50KG1hcEJyb3dzZXJFdmVudCkgIT09IGZhbHNlKSB7XG4gICAgICBjb25zdCBpbnRlcmFjdGlvbnNBcnJheSA9IHRoaXMuZ2V0SW50ZXJhY3Rpb25zKCkuZ2V0QXJyYXkoKS5zbGljZSgpO1xuICAgICAgZm9yIChsZXQgaSA9IGludGVyYWN0aW9uc0FycmF5Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGNvbnN0IGludGVyYWN0aW9uID0gaW50ZXJhY3Rpb25zQXJyYXlbaV07XG4gICAgICAgIGlmIChcbiAgICAgICAgICBpbnRlcmFjdGlvbi5nZXRNYXAoKSAhPT0gdGhpcyB8fFxuICAgICAgICAgICFpbnRlcmFjdGlvbi5nZXRBY3RpdmUoKSB8fFxuICAgICAgICAgICF0aGlzLmdldFRhcmdldEVsZW1lbnQoKVxuICAgICAgICApIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb250ID0gaW50ZXJhY3Rpb24uaGFuZGxlRXZlbnQobWFwQnJvd3NlckV2ZW50KTtcbiAgICAgICAgaWYgKCFjb250IHx8IG1hcEJyb3dzZXJFdmVudC5wcm9wYWdhdGlvblN0b3BwZWQpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBoYW5kbGVQb3N0UmVuZGVyKCkge1xuICAgIGNvbnN0IGZyYW1lU3RhdGUgPSB0aGlzLmZyYW1lU3RhdGVfO1xuXG4gICAgLy8gTWFuYWdlIHRoZSB0aWxlIHF1ZXVlXG4gICAgLy8gSW1hZ2UgbG9hZHMgYXJlIGV4cGVuc2l2ZSBhbmQgYSBsaW1pdGVkIHJlc291cmNlLCBzbyB0cnkgdG8gdXNlIHRoZW1cbiAgICAvLyBlZmZpY2llbnRseTpcbiAgICAvLyAqIFdoZW4gdGhlIHZpZXcgaXMgc3RhdGljIHdlIGFsbG93IGEgbGFyZ2UgbnVtYmVyIG9mIHBhcmFsbGVsIHRpbGUgbG9hZHNcbiAgICAvLyAgIHRvIGNvbXBsZXRlIHRoZSBmcmFtZSBhcyBxdWlja2x5IGFzIHBvc3NpYmxlLlxuICAgIC8vICogV2hlbiBhbmltYXRpbmcgb3IgaW50ZXJhY3RpbmcsIGltYWdlIGxvYWRzIGNhbiBjYXVzZSBqYW5rcywgc28gd2UgcmVkdWNlXG4gICAgLy8gICB0aGUgbWF4aW11bSBudW1iZXIgb2YgbG9hZHMgcGVyIGZyYW1lIGFuZCBsaW1pdCB0aGUgbnVtYmVyIG9mIHBhcmFsbGVsXG4gICAgLy8gICB0aWxlIGxvYWRzIHRvIHJlbWFpbiByZWFjdGl2ZSB0byB2aWV3IGNoYW5nZXMgYW5kIHRvIHJlZHVjZSB0aGUgY2hhbmNlIG9mXG4gICAgLy8gICBsb2FkaW5nIHRpbGVzIHRoYXQgd2lsbCBxdWlja2x5IGRpc2FwcGVhciBmcm9tIHZpZXcuXG4gICAgY29uc3QgdGlsZVF1ZXVlID0gdGhpcy50aWxlUXVldWVfO1xuICAgIGlmICghdGlsZVF1ZXVlLmlzRW1wdHkoKSkge1xuICAgICAgbGV0IG1heFRvdGFsTG9hZGluZyA9IHRoaXMubWF4VGlsZXNMb2FkaW5nXztcbiAgICAgIGxldCBtYXhOZXdMb2FkcyA9IG1heFRvdGFsTG9hZGluZztcbiAgICAgIGlmIChmcmFtZVN0YXRlKSB7XG4gICAgICAgIGNvbnN0IGhpbnRzID0gZnJhbWVTdGF0ZS52aWV3SGludHM7XG4gICAgICAgIGlmIChoaW50c1tWaWV3SGludC5BTklNQVRJTkddIHx8IGhpbnRzW1ZpZXdIaW50LklOVEVSQUNUSU5HXSkge1xuICAgICAgICAgIGNvbnN0IGxvd09uRnJhbWVCdWRnZXQgPSBEYXRlLm5vdygpIC0gZnJhbWVTdGF0ZS50aW1lID4gODtcbiAgICAgICAgICBtYXhUb3RhbExvYWRpbmcgPSBsb3dPbkZyYW1lQnVkZ2V0ID8gMCA6IDg7XG4gICAgICAgICAgbWF4TmV3TG9hZHMgPSBsb3dPbkZyYW1lQnVkZ2V0ID8gMCA6IDI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0aWxlUXVldWUuZ2V0VGlsZXNMb2FkaW5nKCkgPCBtYXhUb3RhbExvYWRpbmcpIHtcbiAgICAgICAgdGlsZVF1ZXVlLnJlcHJpb3JpdGl6ZSgpOyAvLyBGSVhNRSBvbmx5IGNhbGwgaWYgdmlldyBoYXMgY2hhbmdlZFxuICAgICAgICB0aWxlUXVldWUubG9hZE1vcmVUaWxlcyhtYXhUb3RhbExvYWRpbmcsIG1heE5ld0xvYWRzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZnJhbWVTdGF0ZSAmJiB0aGlzLnJlbmRlcmVyXyAmJiAhZnJhbWVTdGF0ZS5hbmltYXRlKSB7XG4gICAgICBpZiAodGhpcy5yZW5kZXJDb21wbGV0ZV8gPT09IHRydWUpIHtcbiAgICAgICAgaWYgKHRoaXMuaGFzTGlzdGVuZXIoUmVuZGVyRXZlbnRUeXBlLlJFTkRFUkNPTVBMRVRFKSkge1xuICAgICAgICAgIHRoaXMucmVuZGVyZXJfLmRpc3BhdGNoUmVuZGVyRXZlbnQoXG4gICAgICAgICAgICBSZW5kZXJFdmVudFR5cGUuUkVOREVSQ09NUExFVEUsXG4gICAgICAgICAgICBmcmFtZVN0YXRlXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5sb2FkZWRfID09PSBmYWxzZSkge1xuICAgICAgICAgIHRoaXMubG9hZGVkXyA9IHRydWU7XG4gICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KFxuICAgICAgICAgICAgbmV3IE1hcEV2ZW50KE1hcEV2ZW50VHlwZS5MT0FERU5ELCB0aGlzLCBmcmFtZVN0YXRlKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodGhpcy5sb2FkZWRfID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMubG9hZGVkXyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoXG4gICAgICAgICAgbmV3IE1hcEV2ZW50KE1hcEV2ZW50VHlwZS5MT0FEU1RBUlQsIHRoaXMsIGZyYW1lU3RhdGUpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgcG9zdFJlbmRlckZ1bmN0aW9ucyA9IHRoaXMucG9zdFJlbmRlckZ1bmN0aW9uc187XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gcG9zdFJlbmRlckZ1bmN0aW9ucy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICBwb3N0UmVuZGVyRnVuY3Rpb25zW2ldKHRoaXMsIGZyYW1lU3RhdGUpO1xuICAgIH1cbiAgICBwb3N0UmVuZGVyRnVuY3Rpb25zLmxlbmd0aCA9IDA7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGhhbmRsZVNpemVDaGFuZ2VkXygpIHtcbiAgICBpZiAodGhpcy5nZXRWaWV3KCkgJiYgIXRoaXMuZ2V0VmlldygpLmdldEFuaW1hdGluZygpKSB7XG4gICAgICB0aGlzLmdldFZpZXcoKS5yZXNvbHZlQ29uc3RyYWludHMoMCk7XG4gICAgfVxuXG4gICAgdGhpcy5yZW5kZXIoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaGFuZGxlVGFyZ2V0Q2hhbmdlZF8oKSB7XG4gICAgaWYgKHRoaXMubWFwQnJvd3NlckV2ZW50SGFuZGxlcl8pIHtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IHRoaXMudGFyZ2V0Q2hhbmdlSGFuZGxlcktleXNfLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgdW5saXN0ZW5CeUtleSh0aGlzLnRhcmdldENoYW5nZUhhbmRsZXJLZXlzX1tpXSk7XG4gICAgICB9XG4gICAgICB0aGlzLnRhcmdldENoYW5nZUhhbmRsZXJLZXlzXyA9IG51bGw7XG4gICAgICB0aGlzLnZpZXdwb3J0Xy5yZW1vdmVFdmVudExpc3RlbmVyKFxuICAgICAgICBFdmVudFR5cGUuQ09OVEVYVE1FTlUsXG4gICAgICAgIHRoaXMuYm91bmRIYW5kbGVCcm93c2VyRXZlbnRfXG4gICAgICApO1xuICAgICAgdGhpcy52aWV3cG9ydF8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgRXZlbnRUeXBlLldIRUVMLFxuICAgICAgICB0aGlzLmJvdW5kSGFuZGxlQnJvd3NlckV2ZW50X1xuICAgICAgKTtcbiAgICAgIHRoaXMubWFwQnJvd3NlckV2ZW50SGFuZGxlcl8uZGlzcG9zZSgpO1xuICAgICAgdGhpcy5tYXBCcm93c2VyRXZlbnRIYW5kbGVyXyA9IG51bGw7XG4gICAgICByZW1vdmVOb2RlKHRoaXMudmlld3BvcnRfKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy50YXJnZXRFbGVtZW50Xykge1xuICAgICAgdGhpcy5yZXNpemVPYnNlcnZlcl8udW5vYnNlcnZlKHRoaXMudGFyZ2V0RWxlbWVudF8pO1xuICAgICAgY29uc3Qgcm9vdE5vZGUgPSB0aGlzLnRhcmdldEVsZW1lbnRfLmdldFJvb3ROb2RlKCk7XG4gICAgICBpZiAocm9vdE5vZGUgaW5zdGFuY2VvZiBTaGFkb3dSb290KSB7XG4gICAgICAgIHRoaXMucmVzaXplT2JzZXJ2ZXJfLnVub2JzZXJ2ZShyb290Tm9kZS5ob3N0KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2V0U2l6ZSh1bmRlZmluZWQpO1xuICAgIH1cblxuICAgIC8vIHRhcmdldCBtYXkgYmUgdW5kZWZpbmVkLCBudWxsLCBhIHN0cmluZyBvciBhbiBFbGVtZW50LlxuICAgIC8vIElmIGl0J3MgYSBzdHJpbmcgd2UgY29udmVydCBpdCB0byBhbiBFbGVtZW50IGJlZm9yZSBwcm9jZWVkaW5nLlxuICAgIC8vIElmIGl0J3Mgbm90IG5vdyBhbiBFbGVtZW50IHdlIHJlbW92ZSB0aGUgdmlld3BvcnQgZnJvbSB0aGUgRE9NLlxuICAgIC8vIElmIGl0J3MgYW4gRWxlbWVudCB3ZSBhcHBlbmQgdGhlIHZpZXdwb3J0IGVsZW1lbnQgdG8gaXQuXG5cbiAgICBjb25zdCB0YXJnZXQgPSB0aGlzLmdldFRhcmdldCgpO1xuICAgIGNvbnN0IHRhcmdldEVsZW1lbnQgPVxuICAgICAgdHlwZW9mIHRhcmdldCA9PT0gJ3N0cmluZycgPyBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0YXJnZXQpIDogdGFyZ2V0O1xuICAgIHRoaXMudGFyZ2V0RWxlbWVudF8gPSB0YXJnZXRFbGVtZW50O1xuICAgIGlmICghdGFyZ2V0RWxlbWVudCkge1xuICAgICAgaWYgKHRoaXMucmVuZGVyZXJfKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnBvc3RSZW5kZXJUaW1lb3V0SGFuZGxlXyk7XG4gICAgICAgIHRoaXMucG9zdFJlbmRlclRpbWVvdXRIYW5kbGVfID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnBvc3RSZW5kZXJGdW5jdGlvbnNfLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMucmVuZGVyZXJfLmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy5yZW5kZXJlcl8gPSBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuYW5pbWF0aW9uRGVsYXlLZXlfKSB7XG4gICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuYW5pbWF0aW9uRGVsYXlLZXlfKTtcbiAgICAgICAgdGhpcy5hbmltYXRpb25EZWxheUtleV8gPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRhcmdldEVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy52aWV3cG9ydF8pO1xuICAgICAgaWYgKCF0aGlzLnJlbmRlcmVyXykge1xuICAgICAgICB0aGlzLnJlbmRlcmVyXyA9IG5ldyBDb21wb3NpdGVNYXBSZW5kZXJlcih0aGlzKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5tYXBCcm93c2VyRXZlbnRIYW5kbGVyXyA9IG5ldyBNYXBCcm93c2VyRXZlbnRIYW5kbGVyKFxuICAgICAgICB0aGlzLFxuICAgICAgICB0aGlzLm1vdmVUb2xlcmFuY2VfXG4gICAgICApO1xuICAgICAgZm9yIChjb25zdCBrZXkgaW4gTWFwQnJvd3NlckV2ZW50VHlwZSkge1xuICAgICAgICB0aGlzLm1hcEJyb3dzZXJFdmVudEhhbmRsZXJfLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgICAgTWFwQnJvd3NlckV2ZW50VHlwZVtrZXldLFxuICAgICAgICAgIHRoaXMuaGFuZGxlTWFwQnJvd3NlckV2ZW50LmJpbmQodGhpcylcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHRoaXMudmlld3BvcnRfLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgIEV2ZW50VHlwZS5DT05URVhUTUVOVSxcbiAgICAgICAgdGhpcy5ib3VuZEhhbmRsZUJyb3dzZXJFdmVudF8sXG4gICAgICAgIGZhbHNlXG4gICAgICApO1xuICAgICAgdGhpcy52aWV3cG9ydF8uYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgRXZlbnRUeXBlLldIRUVMLFxuICAgICAgICB0aGlzLmJvdW5kSGFuZGxlQnJvd3NlckV2ZW50XyxcbiAgICAgICAgUEFTU0lWRV9FVkVOVF9MSVNURU5FUlMgPyB7cGFzc2l2ZTogZmFsc2V9IDogZmFsc2VcbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IGtleWJvYXJkRXZlbnRUYXJnZXQgPSAhdGhpcy5rZXlib2FyZEV2ZW50VGFyZ2V0X1xuICAgICAgICA/IHRhcmdldEVsZW1lbnRcbiAgICAgICAgOiB0aGlzLmtleWJvYXJkRXZlbnRUYXJnZXRfO1xuICAgICAgdGhpcy50YXJnZXRDaGFuZ2VIYW5kbGVyS2V5c18gPSBbXG4gICAgICAgIGxpc3RlbihcbiAgICAgICAgICBrZXlib2FyZEV2ZW50VGFyZ2V0LFxuICAgICAgICAgIEV2ZW50VHlwZS5LRVlET1dOLFxuICAgICAgICAgIHRoaXMuaGFuZGxlQnJvd3NlckV2ZW50LFxuICAgICAgICAgIHRoaXNcbiAgICAgICAgKSxcbiAgICAgICAgbGlzdGVuKFxuICAgICAgICAgIGtleWJvYXJkRXZlbnRUYXJnZXQsXG4gICAgICAgICAgRXZlbnRUeXBlLktFWVBSRVNTLFxuICAgICAgICAgIHRoaXMuaGFuZGxlQnJvd3NlckV2ZW50LFxuICAgICAgICAgIHRoaXNcbiAgICAgICAgKSxcbiAgICAgIF07XG4gICAgICBjb25zdCByb290Tm9kZSA9IHRhcmdldEVsZW1lbnQuZ2V0Um9vdE5vZGUoKTtcbiAgICAgIGlmIChyb290Tm9kZSBpbnN0YW5jZW9mIFNoYWRvd1Jvb3QpIHtcbiAgICAgICAgdGhpcy5yZXNpemVPYnNlcnZlcl8ub2JzZXJ2ZShyb290Tm9kZS5ob3N0KTtcbiAgICAgIH1cbiAgICAgIHRoaXMucmVzaXplT2JzZXJ2ZXJfLm9ic2VydmUodGFyZ2V0RWxlbWVudCk7XG4gICAgfVxuXG4gICAgdGhpcy51cGRhdGVTaXplKCk7XG4gICAgLy8gdXBkYXRlU2l6ZSBjYWxscyBzZXRTaXplLCBzbyBubyBuZWVkIHRvIGNhbGwgdGhpcy5yZW5kZXJcbiAgICAvLyBvdXJzZWx2ZXMgaGVyZS5cbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaGFuZGxlVGlsZUNoYW5nZV8oKSB7XG4gICAgdGhpcy5yZW5kZXIoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaGFuZGxlVmlld1Byb3BlcnR5Q2hhbmdlZF8oKSB7XG4gICAgdGhpcy5yZW5kZXIoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaGFuZGxlVmlld0NoYW5nZWRfKCkge1xuICAgIGlmICh0aGlzLnZpZXdQcm9wZXJ0eUxpc3RlbmVyS2V5Xykge1xuICAgICAgdW5saXN0ZW5CeUtleSh0aGlzLnZpZXdQcm9wZXJ0eUxpc3RlbmVyS2V5Xyk7XG4gICAgICB0aGlzLnZpZXdQcm9wZXJ0eUxpc3RlbmVyS2V5XyA9IG51bGw7XG4gICAgfVxuICAgIGlmICh0aGlzLnZpZXdDaGFuZ2VMaXN0ZW5lcktleV8pIHtcbiAgICAgIHVubGlzdGVuQnlLZXkodGhpcy52aWV3Q2hhbmdlTGlzdGVuZXJLZXlfKTtcbiAgICAgIHRoaXMudmlld0NoYW5nZUxpc3RlbmVyS2V5XyA9IG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHZpZXcgPSB0aGlzLmdldFZpZXcoKTtcbiAgICBpZiAodmlldykge1xuICAgICAgdGhpcy51cGRhdGVWaWV3cG9ydFNpemVfKCk7XG5cbiAgICAgIHRoaXMudmlld1Byb3BlcnR5TGlzdGVuZXJLZXlfID0gbGlzdGVuKFxuICAgICAgICB2aWV3LFxuICAgICAgICBPYmplY3RFdmVudFR5cGUuUFJPUEVSVFlDSEFOR0UsXG4gICAgICAgIHRoaXMuaGFuZGxlVmlld1Byb3BlcnR5Q2hhbmdlZF8sXG4gICAgICAgIHRoaXNcbiAgICAgICk7XG4gICAgICB0aGlzLnZpZXdDaGFuZ2VMaXN0ZW5lcktleV8gPSBsaXN0ZW4oXG4gICAgICAgIHZpZXcsXG4gICAgICAgIEV2ZW50VHlwZS5DSEFOR0UsXG4gICAgICAgIHRoaXMuaGFuZGxlVmlld1Byb3BlcnR5Q2hhbmdlZF8sXG4gICAgICAgIHRoaXNcbiAgICAgICk7XG5cbiAgICAgIHZpZXcucmVzb2x2ZUNvbnN0cmFpbnRzKDApO1xuICAgIH1cbiAgICB0aGlzLnJlbmRlcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBoYW5kbGVMYXllckdyb3VwQ2hhbmdlZF8oKSB7XG4gICAgaWYgKHRoaXMubGF5ZXJHcm91cFByb3BlcnR5TGlzdGVuZXJLZXlzXykge1xuICAgICAgdGhpcy5sYXllckdyb3VwUHJvcGVydHlMaXN0ZW5lcktleXNfLmZvckVhY2godW5saXN0ZW5CeUtleSk7XG4gICAgICB0aGlzLmxheWVyR3JvdXBQcm9wZXJ0eUxpc3RlbmVyS2V5c18gPSBudWxsO1xuICAgIH1cbiAgICBjb25zdCBsYXllckdyb3VwID0gdGhpcy5nZXRMYXllckdyb3VwKCk7XG4gICAgaWYgKGxheWVyR3JvdXApIHtcbiAgICAgIHRoaXMuaGFuZGxlTGF5ZXJBZGRfKG5ldyBHcm91cEV2ZW50KCdhZGRsYXllcicsIGxheWVyR3JvdXApKTtcbiAgICAgIHRoaXMubGF5ZXJHcm91cFByb3BlcnR5TGlzdGVuZXJLZXlzXyA9IFtcbiAgICAgICAgbGlzdGVuKGxheWVyR3JvdXAsIE9iamVjdEV2ZW50VHlwZS5QUk9QRVJUWUNIQU5HRSwgdGhpcy5yZW5kZXIsIHRoaXMpLFxuICAgICAgICBsaXN0ZW4obGF5ZXJHcm91cCwgRXZlbnRUeXBlLkNIQU5HRSwgdGhpcy5yZW5kZXIsIHRoaXMpLFxuICAgICAgICBsaXN0ZW4obGF5ZXJHcm91cCwgJ2FkZGxheWVyJywgdGhpcy5oYW5kbGVMYXllckFkZF8sIHRoaXMpLFxuICAgICAgICBsaXN0ZW4obGF5ZXJHcm91cCwgJ3JlbW92ZWxheWVyJywgdGhpcy5oYW5kbGVMYXllclJlbW92ZV8sIHRoaXMpLFxuICAgICAgXTtcbiAgICB9XG4gICAgdGhpcy5yZW5kZXIoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBJcyByZW5kZXJlZC5cbiAgICovXG4gIGlzUmVuZGVyZWQoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5mcmFtZVN0YXRlXztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYW5pbWF0aW9uRGVsYXlfKCkge1xuICAgIHRoaXMuYW5pbWF0aW9uRGVsYXlLZXlfID0gdW5kZWZpbmVkO1xuICAgIHRoaXMucmVuZGVyRnJhbWVfKERhdGUubm93KCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlcXVlc3RzIGFuIGltbWVkaWF0ZSByZW5kZXIgaW4gYSBzeW5jaHJvbm91cyBtYW5uZXIuXG4gICAqIEBhcGlcbiAgICovXG4gIHJlbmRlclN5bmMoKSB7XG4gICAgaWYgKHRoaXMuYW5pbWF0aW9uRGVsYXlLZXlfKSB7XG4gICAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLmFuaW1hdGlvbkRlbGF5S2V5Xyk7XG4gICAgfVxuICAgIHRoaXMuYW5pbWF0aW9uRGVsYXlfKCk7XG4gIH1cblxuICAvKipcbiAgICogUmVkcmF3cyBhbGwgdGV4dCBhZnRlciBuZXcgZm9udHMgaGF2ZSBsb2FkZWRcbiAgICovXG4gIHJlZHJhd1RleHQoKSB7XG4gICAgY29uc3QgbGF5ZXJTdGF0ZXMgPSB0aGlzLmdldExheWVyR3JvdXAoKS5nZXRMYXllclN0YXRlc0FycmF5KCk7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gbGF5ZXJTdGF0ZXMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgY29uc3QgbGF5ZXIgPSBsYXllclN0YXRlc1tpXS5sYXllcjtcbiAgICAgIGlmIChsYXllci5oYXNSZW5kZXJlcigpKSB7XG4gICAgICAgIGxheWVyLmdldFJlbmRlcmVyKCkuaGFuZGxlRm9udHNDaGFuZ2VkKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlcXVlc3QgYSBtYXAgcmVuZGVyaW5nIChhdCB0aGUgbmV4dCBhbmltYXRpb24gZnJhbWUpLlxuICAgKiBAYXBpXG4gICAqL1xuICByZW5kZXIoKSB7XG4gICAgaWYgKHRoaXMucmVuZGVyZXJfICYmIHRoaXMuYW5pbWF0aW9uRGVsYXlLZXlfID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuYW5pbWF0aW9uRGVsYXlLZXlfID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuYW5pbWF0aW9uRGVsYXlfKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgaXMgbWVhbnQgdG8gYmUgY2FsbGVkIGluIGEgbGF5ZXIncyBgcHJlcmVuZGVyYCBsaXN0ZW5lci4gSXQgY2F1c2VzIGFsbCBjb2xsZWN0ZWRcbiAgICogZGVjbHV0dGVyIGl0ZW1zIHRvIGJlIGRlY2x1dHRlcmVkIGFuZCByZW5kZXJlZCBvbiB0aGUgbWFwIGltbWVkaWF0ZWx5LiBUaGlzIGlzIHVzZWZ1bCBmb3JcbiAgICogbGF5ZXJzIHRoYXQgbmVlZCB0byBhcHBlYXIgZW50aXJlbHkgYWJvdmUgdGhlIGRlY2x1dHRlcmVkIGl0ZW1zIG9mIGxheWVycyBsb3dlciBpbiB0aGUgbGF5ZXJcbiAgICogc3RhY2suXG4gICAqIEBhcGlcbiAgICovXG4gIGZsdXNoRGVjbHV0dGVySXRlbXMoKSB7XG4gICAgY29uc3QgZnJhbWVTdGF0ZSA9IHRoaXMuZnJhbWVTdGF0ZV87XG4gICAgaWYgKCFmcmFtZVN0YXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMucmVuZGVyZXJfLmZsdXNoRGVjbHV0dGVySXRlbXMoZnJhbWVTdGF0ZSk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIHRoZSBnaXZlbiBjb250cm9sIGZyb20gdGhlIG1hcC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL2NvbnRyb2wvQ29udHJvbC5qc1wiKS5kZWZhdWx0fSBjb250cm9sIENvbnRyb2wuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4vY29udHJvbC9Db250cm9sLmpzXCIpLmRlZmF1bHR8dW5kZWZpbmVkfSBUaGUgcmVtb3ZlZCBjb250cm9sIChvciB1bmRlZmluZWRcbiAgICogICAgIGlmIHRoZSBjb250cm9sIHdhcyBub3QgZm91bmQpLlxuICAgKiBAYXBpXG4gICAqL1xuICByZW1vdmVDb250cm9sKGNvbnRyb2wpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRDb250cm9scygpLnJlbW92ZShjb250cm9sKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgdGhlIGdpdmVuIGludGVyYWN0aW9uIGZyb20gdGhlIG1hcC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL2ludGVyYWN0aW9uL0ludGVyYWN0aW9uLmpzXCIpLmRlZmF1bHR9IGludGVyYWN0aW9uIEludGVyYWN0aW9uIHRvIHJlbW92ZS5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi9pbnRlcmFjdGlvbi9JbnRlcmFjdGlvbi5qc1wiKS5kZWZhdWx0fHVuZGVmaW5lZH0gVGhlIHJlbW92ZWQgaW50ZXJhY3Rpb24gKG9yXG4gICAqICAgICB1bmRlZmluZWQgaWYgdGhlIGludGVyYWN0aW9uIHdhcyBub3QgZm91bmQpLlxuICAgKiBAYXBpXG4gICAqL1xuICByZW1vdmVJbnRlcmFjdGlvbihpbnRlcmFjdGlvbikge1xuICAgIHJldHVybiB0aGlzLmdldEludGVyYWN0aW9ucygpLnJlbW92ZShpbnRlcmFjdGlvbik7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyB0aGUgZ2l2ZW4gbGF5ZXIgZnJvbSB0aGUgbWFwLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vbGF5ZXIvQmFzZS5qc1wiKS5kZWZhdWx0fSBsYXllciBMYXllci5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi9sYXllci9CYXNlLmpzXCIpLmRlZmF1bHR8dW5kZWZpbmVkfSBUaGUgcmVtb3ZlZCBsYXllciAob3IgdW5kZWZpbmVkIGlmIHRoZVxuICAgKiAgICAgbGF5ZXIgd2FzIG5vdCBmb3VuZCkuXG4gICAqIEBhcGlcbiAgICovXG4gIHJlbW92ZUxheWVyKGxheWVyKSB7XG4gICAgY29uc3QgbGF5ZXJzID0gdGhpcy5nZXRMYXllckdyb3VwKCkuZ2V0TGF5ZXJzKCk7XG4gICAgcmV0dXJuIGxheWVycy5yZW1vdmUobGF5ZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9sYXllci9Hcm91cC5qc1wiKS5Hcm91cEV2ZW50fSBldmVudCBUaGUgbGF5ZXIgcmVtb3ZlIGV2ZW50LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaGFuZGxlTGF5ZXJSZW1vdmVfKGV2ZW50KSB7XG4gICAgcmVtb3ZlTGF5ZXJNYXBQcm9wZXJ0eShldmVudC5sYXllcik7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIHRoZSBnaXZlbiBvdmVybGF5IGZyb20gdGhlIG1hcC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL092ZXJsYXkuanNcIikuZGVmYXVsdH0gb3ZlcmxheSBPdmVybGF5LlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuL092ZXJsYXkuanNcIikuZGVmYXVsdHx1bmRlZmluZWR9IFRoZSByZW1vdmVkIG92ZXJsYXkgKG9yIHVuZGVmaW5lZFxuICAgKiAgICAgaWYgdGhlIG92ZXJsYXkgd2FzIG5vdCBmb3VuZCkuXG4gICAqIEBhcGlcbiAgICovXG4gIHJlbW92ZU92ZXJsYXkob3ZlcmxheSkge1xuICAgIHJldHVybiB0aGlzLmdldE92ZXJsYXlzKCkucmVtb3ZlKG92ZXJsYXkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lIFRpbWUuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICByZW5kZXJGcmFtZV8odGltZSkge1xuICAgIGNvbnN0IHNpemUgPSB0aGlzLmdldFNpemUoKTtcbiAgICBjb25zdCB2aWV3ID0gdGhpcy5nZXRWaWV3KCk7XG4gICAgY29uc3QgcHJldmlvdXNGcmFtZVN0YXRlID0gdGhpcy5mcmFtZVN0YXRlXztcbiAgICAvKiogQHR5cGUgez9GcmFtZVN0YXRlfSAqL1xuICAgIGxldCBmcmFtZVN0YXRlID0gbnVsbDtcbiAgICBpZiAoc2l6ZSAhPT0gdW5kZWZpbmVkICYmIGhhc0FyZWEoc2l6ZSkgJiYgdmlldyAmJiB2aWV3LmlzRGVmKCkpIHtcbiAgICAgIGNvbnN0IHZpZXdIaW50cyA9IHZpZXcuZ2V0SGludHMoXG4gICAgICAgIHRoaXMuZnJhbWVTdGF0ZV8gPyB0aGlzLmZyYW1lU3RhdGVfLnZpZXdIaW50cyA6IHVuZGVmaW5lZFxuICAgICAgKTtcbiAgICAgIGNvbnN0IHZpZXdTdGF0ZSA9IHZpZXcuZ2V0U3RhdGUoKTtcbiAgICAgIGZyYW1lU3RhdGUgPSB7XG4gICAgICAgIGFuaW1hdGU6IGZhbHNlLFxuICAgICAgICBjb29yZGluYXRlVG9QaXhlbFRyYW5zZm9ybTogdGhpcy5jb29yZGluYXRlVG9QaXhlbFRyYW5zZm9ybV8sXG4gICAgICAgIGRlY2x1dHRlclRyZWU6IG51bGwsXG4gICAgICAgIGV4dGVudDogZ2V0Rm9yVmlld0FuZFNpemUoXG4gICAgICAgICAgdmlld1N0YXRlLmNlbnRlcixcbiAgICAgICAgICB2aWV3U3RhdGUucmVzb2x1dGlvbixcbiAgICAgICAgICB2aWV3U3RhdGUucm90YXRpb24sXG4gICAgICAgICAgc2l6ZVxuICAgICAgICApLFxuICAgICAgICBpbmRleDogdGhpcy5mcmFtZUluZGV4XysrLFxuICAgICAgICBsYXllckluZGV4OiAwLFxuICAgICAgICBsYXllclN0YXRlc0FycmF5OiB0aGlzLmdldExheWVyR3JvdXAoKS5nZXRMYXllclN0YXRlc0FycmF5KCksXG4gICAgICAgIHBpeGVsUmF0aW86IHRoaXMucGl4ZWxSYXRpb18sXG4gICAgICAgIHBpeGVsVG9Db29yZGluYXRlVHJhbnNmb3JtOiB0aGlzLnBpeGVsVG9Db29yZGluYXRlVHJhbnNmb3JtXyxcbiAgICAgICAgcG9zdFJlbmRlckZ1bmN0aW9uczogW10sXG4gICAgICAgIHNpemU6IHNpemUsXG4gICAgICAgIHRpbGVRdWV1ZTogdGhpcy50aWxlUXVldWVfLFxuICAgICAgICB0aW1lOiB0aW1lLFxuICAgICAgICB1c2VkVGlsZXM6IHt9LFxuICAgICAgICB2aWV3U3RhdGU6IHZpZXdTdGF0ZSxcbiAgICAgICAgdmlld0hpbnRzOiB2aWV3SGludHMsXG4gICAgICAgIHdhbnRlZFRpbGVzOiB7fSxcbiAgICAgICAgbWFwSWQ6IGdldFVpZCh0aGlzKSxcbiAgICAgICAgcmVuZGVyVGFyZ2V0czoge30sXG4gICAgICB9O1xuICAgICAgaWYgKHZpZXdTdGF0ZS5uZXh0Q2VudGVyICYmIHZpZXdTdGF0ZS5uZXh0UmVzb2x1dGlvbikge1xuICAgICAgICBjb25zdCByb3RhdGlvbiA9IGlzTmFOKHZpZXdTdGF0ZS5uZXh0Um90YXRpb24pXG4gICAgICAgICAgPyB2aWV3U3RhdGUucm90YXRpb25cbiAgICAgICAgICA6IHZpZXdTdGF0ZS5uZXh0Um90YXRpb247XG5cbiAgICAgICAgZnJhbWVTdGF0ZS5uZXh0RXh0ZW50ID0gZ2V0Rm9yVmlld0FuZFNpemUoXG4gICAgICAgICAgdmlld1N0YXRlLm5leHRDZW50ZXIsXG4gICAgICAgICAgdmlld1N0YXRlLm5leHRSZXNvbHV0aW9uLFxuICAgICAgICAgIHJvdGF0aW9uLFxuICAgICAgICAgIHNpemVcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmZyYW1lU3RhdGVfID0gZnJhbWVTdGF0ZTtcbiAgICB0aGlzLnJlbmRlcmVyXy5yZW5kZXJGcmFtZShmcmFtZVN0YXRlKTtcblxuICAgIGlmIChmcmFtZVN0YXRlKSB7XG4gICAgICBpZiAoZnJhbWVTdGF0ZS5hbmltYXRlKSB7XG4gICAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgICB9XG4gICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShcbiAgICAgICAgdGhpcy5wb3N0UmVuZGVyRnVuY3Rpb25zXyxcbiAgICAgICAgZnJhbWVTdGF0ZS5wb3N0UmVuZGVyRnVuY3Rpb25zXG4gICAgICApO1xuXG4gICAgICBpZiAocHJldmlvdXNGcmFtZVN0YXRlKSB7XG4gICAgICAgIGNvbnN0IG1vdmVTdGFydCA9XG4gICAgICAgICAgIXRoaXMucHJldmlvdXNFeHRlbnRfIHx8XG4gICAgICAgICAgKCFpc0VtcHR5KHRoaXMucHJldmlvdXNFeHRlbnRfKSAmJlxuICAgICAgICAgICAgIWVxdWFsc0V4dGVudChmcmFtZVN0YXRlLmV4dGVudCwgdGhpcy5wcmV2aW91c0V4dGVudF8pKTtcbiAgICAgICAgaWYgKG1vdmVTdGFydCkge1xuICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChcbiAgICAgICAgICAgIG5ldyBNYXBFdmVudChNYXBFdmVudFR5cGUuTU9WRVNUQVJULCB0aGlzLCBwcmV2aW91c0ZyYW1lU3RhdGUpXG4gICAgICAgICAgKTtcbiAgICAgICAgICB0aGlzLnByZXZpb3VzRXh0ZW50XyA9IGNyZWF0ZU9yVXBkYXRlRW1wdHkodGhpcy5wcmV2aW91c0V4dGVudF8pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGlkbGUgPVxuICAgICAgICB0aGlzLnByZXZpb3VzRXh0ZW50XyAmJlxuICAgICAgICAhZnJhbWVTdGF0ZS52aWV3SGludHNbVmlld0hpbnQuQU5JTUFUSU5HXSAmJlxuICAgICAgICAhZnJhbWVTdGF0ZS52aWV3SGludHNbVmlld0hpbnQuSU5URVJBQ1RJTkddICYmXG4gICAgICAgICFlcXVhbHNFeHRlbnQoZnJhbWVTdGF0ZS5leHRlbnQsIHRoaXMucHJldmlvdXNFeHRlbnRfKTtcblxuICAgICAgaWYgKGlkbGUpIHtcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KFxuICAgICAgICAgIG5ldyBNYXBFdmVudChNYXBFdmVudFR5cGUuTU9WRUVORCwgdGhpcywgZnJhbWVTdGF0ZSlcbiAgICAgICAgKTtcbiAgICAgICAgY2xvbmUoZnJhbWVTdGF0ZS5leHRlbnQsIHRoaXMucHJldmlvdXNFeHRlbnRfKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IE1hcEV2ZW50KE1hcEV2ZW50VHlwZS5QT1NUUkVOREVSLCB0aGlzLCBmcmFtZVN0YXRlKSk7XG5cbiAgICB0aGlzLnJlbmRlckNvbXBsZXRlXyA9XG4gICAgICB0aGlzLmhhc0xpc3RlbmVyKE1hcEV2ZW50VHlwZS5MT0FEU1RBUlQpIHx8XG4gICAgICB0aGlzLmhhc0xpc3RlbmVyKE1hcEV2ZW50VHlwZS5MT0FERU5EKSB8fFxuICAgICAgdGhpcy5oYXNMaXN0ZW5lcihSZW5kZXJFdmVudFR5cGUuUkVOREVSQ09NUExFVEUpXG4gICAgICAgID8gIXRoaXMudGlsZVF1ZXVlXy5nZXRUaWxlc0xvYWRpbmcoKSAmJlxuICAgICAgICAgICF0aGlzLnRpbGVRdWV1ZV8uZ2V0Q291bnQoKSAmJlxuICAgICAgICAgICF0aGlzLmdldExvYWRpbmdPck5vdFJlYWR5KClcbiAgICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICBpZiAoIXRoaXMucG9zdFJlbmRlclRpbWVvdXRIYW5kbGVfKSB7XG4gICAgICB0aGlzLnBvc3RSZW5kZXJUaW1lb3V0SGFuZGxlXyA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLnBvc3RSZW5kZXJUaW1lb3V0SGFuZGxlXyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5oYW5kbGVQb3N0UmVuZGVyKCk7XG4gICAgICB9LCAwKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgbGF5ZXJncm91cCBvZiB0aGlzIG1hcC5cbiAgICogQHBhcmFtIHtMYXllckdyb3VwfSBsYXllckdyb3VwIEEgbGF5ZXIgZ3JvdXAgY29udGFpbmluZyB0aGUgbGF5ZXJzIGluIHRoaXMgbWFwLlxuICAgKiBAb2JzZXJ2YWJsZVxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRMYXllckdyb3VwKGxheWVyR3JvdXApIHtcbiAgICBjb25zdCBvbGRMYXllckdyb3VwID0gdGhpcy5nZXRMYXllckdyb3VwKCk7XG4gICAgaWYgKG9sZExheWVyR3JvdXApIHtcbiAgICAgIHRoaXMuaGFuZGxlTGF5ZXJSZW1vdmVfKG5ldyBHcm91cEV2ZW50KCdyZW1vdmVsYXllcicsIG9sZExheWVyR3JvdXApKTtcbiAgICB9XG4gICAgdGhpcy5zZXQoTWFwUHJvcGVydHkuTEFZRVJHUk9VUCwgbGF5ZXJHcm91cCk7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBzaXplIG9mIHRoaXMgbWFwLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vc2l6ZS5qc1wiKS5TaXplfHVuZGVmaW5lZH0gc2l6ZSBUaGUgc2l6ZSBpbiBwaXhlbHMgb2YgdGhlIG1hcCBpbiB0aGUgRE9NLlxuICAgKiBAb2JzZXJ2YWJsZVxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRTaXplKHNpemUpIHtcbiAgICB0aGlzLnNldChNYXBQcm9wZXJ0eS5TSVpFLCBzaXplKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHRhcmdldCBlbGVtZW50IHRvIHJlbmRlciB0aGlzIG1hcCBpbnRvLlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fHN0cmluZ30gW3RhcmdldF0gVGhlIEVsZW1lbnQgb3IgaWQgb2YgdGhlIEVsZW1lbnRcbiAgICogICAgIHRoYXQgdGhlIG1hcCBpcyByZW5kZXJlZCBpbi5cbiAgICogQG9ic2VydmFibGVcbiAgICogQGFwaVxuICAgKi9cbiAgc2V0VGFyZ2V0KHRhcmdldCkge1xuICAgIHRoaXMuc2V0KE1hcFByb3BlcnR5LlRBUkdFVCwgdGFyZ2V0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHZpZXcgZm9yIHRoaXMgbWFwLlxuICAgKiBAcGFyYW0ge1ZpZXd8UHJvbWlzZTxpbXBvcnQoXCIuL1ZpZXcuanNcIikuVmlld09wdGlvbnM+fSB2aWV3IFRoZSB2aWV3IHRoYXQgY29udHJvbHMgdGhpcyBtYXAuXG4gICAqIEl0IGlzIGFsc28gcG9zc2libGUgdG8gcGFzcyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBvcHRpb25zIGZvciBjb25zdHJ1Y3RpbmcgYSB2aWV3LiAgVGhpc1xuICAgKiBhbHRlcm5hdGl2ZSBhbGxvd3MgdmlldyBwcm9wZXJ0aWVzIHRvIGJlIHJlc29sdmVkIGJ5IHNvdXJjZXMgb3Igb3RoZXIgY29tcG9uZW50cyB0aGF0IGxvYWRcbiAgICogdmlldy1yZWxhdGVkIG1ldGFkYXRhLlxuICAgKiBAb2JzZXJ2YWJsZVxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRWaWV3KHZpZXcpIHtcbiAgICBpZiAoIXZpZXcgfHwgdmlldyBpbnN0YW5jZW9mIFZpZXcpIHtcbiAgICAgIHRoaXMuc2V0KE1hcFByb3BlcnR5LlZJRVcsIHZpZXcpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnNldChNYXBQcm9wZXJ0eS5WSUVXLCBuZXcgVmlldygpKTtcblxuICAgIGNvbnN0IG1hcCA9IHRoaXM7XG4gICAgdmlldy50aGVuKGZ1bmN0aW9uICh2aWV3T3B0aW9ucykge1xuICAgICAgbWFwLnNldFZpZXcobmV3IFZpZXcodmlld09wdGlvbnMpKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGb3JjZSBhIHJlY2FsY3VsYXRpb24gb2YgdGhlIG1hcCB2aWV3cG9ydCBzaXplLiAgVGhpcyBzaG91bGQgYmUgY2FsbGVkIHdoZW5cbiAgICogdGhpcmQtcGFydHkgY29kZSBjaGFuZ2VzIHRoZSBzaXplIG9mIHRoZSBtYXAgdmlld3BvcnQuXG4gICAqIEBhcGlcbiAgICovXG4gIHVwZGF0ZVNpemUoKSB7XG4gICAgY29uc3QgdGFyZ2V0RWxlbWVudCA9IHRoaXMuZ2V0VGFyZ2V0RWxlbWVudCgpO1xuXG4gICAgbGV0IHNpemUgPSB1bmRlZmluZWQ7XG4gICAgaWYgKHRhcmdldEVsZW1lbnQpIHtcbiAgICAgIGNvbnN0IGNvbXB1dGVkU3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKHRhcmdldEVsZW1lbnQpO1xuICAgICAgY29uc3Qgd2lkdGggPVxuICAgICAgICB0YXJnZXRFbGVtZW50Lm9mZnNldFdpZHRoIC1cbiAgICAgICAgcGFyc2VGbG9hdChjb21wdXRlZFN0eWxlWydib3JkZXJMZWZ0V2lkdGgnXSkgLVxuICAgICAgICBwYXJzZUZsb2F0KGNvbXB1dGVkU3R5bGVbJ3BhZGRpbmdMZWZ0J10pIC1cbiAgICAgICAgcGFyc2VGbG9hdChjb21wdXRlZFN0eWxlWydwYWRkaW5nUmlnaHQnXSkgLVxuICAgICAgICBwYXJzZUZsb2F0KGNvbXB1dGVkU3R5bGVbJ2JvcmRlclJpZ2h0V2lkdGgnXSk7XG4gICAgICBjb25zdCBoZWlnaHQgPVxuICAgICAgICB0YXJnZXRFbGVtZW50Lm9mZnNldEhlaWdodCAtXG4gICAgICAgIHBhcnNlRmxvYXQoY29tcHV0ZWRTdHlsZVsnYm9yZGVyVG9wV2lkdGgnXSkgLVxuICAgICAgICBwYXJzZUZsb2F0KGNvbXB1dGVkU3R5bGVbJ3BhZGRpbmdUb3AnXSkgLVxuICAgICAgICBwYXJzZUZsb2F0KGNvbXB1dGVkU3R5bGVbJ3BhZGRpbmdCb3R0b20nXSkgLVxuICAgICAgICBwYXJzZUZsb2F0KGNvbXB1dGVkU3R5bGVbJ2JvcmRlckJvdHRvbVdpZHRoJ10pO1xuICAgICAgaWYgKCFpc05hTih3aWR0aCkgJiYgIWlzTmFOKGhlaWdodCkpIHtcbiAgICAgICAgc2l6ZSA9IFt3aWR0aCwgaGVpZ2h0XTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICFoYXNBcmVhKHNpemUpICYmXG4gICAgICAgICAgISEoXG4gICAgICAgICAgICB0YXJnZXRFbGVtZW50Lm9mZnNldFdpZHRoIHx8XG4gICAgICAgICAgICB0YXJnZXRFbGVtZW50Lm9mZnNldEhlaWdodCB8fFxuICAgICAgICAgICAgdGFyZ2V0RWxlbWVudC5nZXRDbGllbnRSZWN0cygpLmxlbmd0aFxuICAgICAgICAgIClcbiAgICAgICAgKSB7XG4gICAgICAgICAgd2FybihcbiAgICAgICAgICAgIFwiTm8gbWFwIHZpc2libGUgYmVjYXVzZSB0aGUgbWFwIGNvbnRhaW5lcidzIHdpZHRoIG9yIGhlaWdodCBhcmUgMC5cIlxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBvbGRTaXplID0gdGhpcy5nZXRTaXplKCk7XG4gICAgaWYgKHNpemUgJiYgKCFvbGRTaXplIHx8ICFlcXVhbHMoc2l6ZSwgb2xkU2l6ZSkpKSB7XG4gICAgICB0aGlzLnNldFNpemUoc2l6ZSk7XG4gICAgICB0aGlzLnVwZGF0ZVZpZXdwb3J0U2l6ZV8oKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVjb21wdXRlcyB0aGUgdmlld3BvcnQgc2l6ZSBhbmQgc2F2ZSBpdCBvbiB0aGUgdmlldyBvYmplY3QgKGlmIGFueSlcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHVwZGF0ZVZpZXdwb3J0U2l6ZV8oKSB7XG4gICAgY29uc3QgdmlldyA9IHRoaXMuZ2V0VmlldygpO1xuICAgIGlmICh2aWV3KSB7XG4gICAgICBsZXQgc2l6ZSA9IHVuZGVmaW5lZDtcbiAgICAgIGNvbnN0IGNvbXB1dGVkU3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKHRoaXMudmlld3BvcnRfKTtcbiAgICAgIGlmIChjb21wdXRlZFN0eWxlLndpZHRoICYmIGNvbXB1dGVkU3R5bGUuaGVpZ2h0KSB7XG4gICAgICAgIHNpemUgPSBbXG4gICAgICAgICAgcGFyc2VJbnQoY29tcHV0ZWRTdHlsZS53aWR0aCwgMTApLFxuICAgICAgICAgIHBhcnNlSW50KGNvbXB1dGVkU3R5bGUuaGVpZ2h0LCAxMCksXG4gICAgICAgIF07XG4gICAgICB9XG4gICAgICB2aWV3LnNldFZpZXdwb3J0U2l6ZShzaXplKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge01hcE9wdGlvbnN9IG9wdGlvbnMgTWFwIG9wdGlvbnMuXG4gKiBAcmV0dXJuIHtNYXBPcHRpb25zSW50ZXJuYWx9IEludGVybmFsIG1hcCBvcHRpb25zLlxuICovXG5mdW5jdGlvbiBjcmVhdGVPcHRpb25zSW50ZXJuYWwob3B0aW9ucykge1xuICAvKipcbiAgICogQHR5cGUge0hUTUxFbGVtZW50fERvY3VtZW50fVxuICAgKi9cbiAgbGV0IGtleWJvYXJkRXZlbnRUYXJnZXQgPSBudWxsO1xuICBpZiAob3B0aW9ucy5rZXlib2FyZEV2ZW50VGFyZ2V0ICE9PSB1bmRlZmluZWQpIHtcbiAgICBrZXlib2FyZEV2ZW50VGFyZ2V0ID1cbiAgICAgIHR5cGVvZiBvcHRpb25zLmtleWJvYXJkRXZlbnRUYXJnZXQgPT09ICdzdHJpbmcnXG4gICAgICAgID8gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQob3B0aW9ucy5rZXlib2FyZEV2ZW50VGFyZ2V0KVxuICAgICAgICA6IG9wdGlvbnMua2V5Ym9hcmRFdmVudFRhcmdldDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgKj59XG4gICAqL1xuICBjb25zdCB2YWx1ZXMgPSB7fTtcblxuICBjb25zdCBsYXllckdyb3VwID1cbiAgICBvcHRpb25zLmxheWVycyAmJlxuICAgIHR5cGVvZiAoLyoqIEB0eXBlIHs/fSAqLyAob3B0aW9ucy5sYXllcnMpLmdldExheWVycykgPT09ICdmdW5jdGlvbidcbiAgICAgID8gLyoqIEB0eXBlIHtMYXllckdyb3VwfSAqLyAob3B0aW9ucy5sYXllcnMpXG4gICAgICA6IG5ldyBMYXllckdyb3VwKHtcbiAgICAgICAgICBsYXllcnM6XG4gICAgICAgICAgICAvKiogQHR5cGUge0NvbGxlY3Rpb248aW1wb3J0KFwiLi9sYXllci9CYXNlLmpzXCIpLmRlZmF1bHQ+fEFycmF5PGltcG9ydChcIi4vbGF5ZXIvQmFzZS5qc1wiKS5kZWZhdWx0Pn0gKi8gKFxuICAgICAgICAgICAgICBvcHRpb25zLmxheWVyc1xuICAgICAgICAgICAgKSxcbiAgICAgICAgfSk7XG4gIHZhbHVlc1tNYXBQcm9wZXJ0eS5MQVlFUkdST1VQXSA9IGxheWVyR3JvdXA7XG5cbiAgdmFsdWVzW01hcFByb3BlcnR5LlRBUkdFVF0gPSBvcHRpb25zLnRhcmdldDtcblxuICB2YWx1ZXNbTWFwUHJvcGVydHkuVklFV10gPVxuICAgIG9wdGlvbnMudmlldyBpbnN0YW5jZW9mIFZpZXcgPyBvcHRpb25zLnZpZXcgOiBuZXcgVmlldygpO1xuXG4gIC8qKiBAdHlwZSB7Q29sbGVjdGlvbjxpbXBvcnQoXCIuL2NvbnRyb2wvQ29udHJvbC5qc1wiKS5kZWZhdWx0Pn0gKi9cbiAgbGV0IGNvbnRyb2xzO1xuICBpZiAob3B0aW9ucy5jb250cm9scyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucy5jb250cm9scykpIHtcbiAgICAgIGNvbnRyb2xzID0gbmV3IENvbGxlY3Rpb24ob3B0aW9ucy5jb250cm9scy5zbGljZSgpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXNzZXJ0KFxuICAgICAgICB0eXBlb2YgKC8qKiBAdHlwZSB7P30gKi8gKG9wdGlvbnMuY29udHJvbHMpLmdldEFycmF5KSA9PT0gJ2Z1bmN0aW9uJyxcbiAgICAgICAgJ0V4cGVjdGVkIGBjb250cm9sc2AgdG8gYmUgYW4gYXJyYXkgb3IgYW4gYG9sL0NvbGxlY3Rpb24uanNgJ1xuICAgICAgKTtcbiAgICAgIGNvbnRyb2xzID0gb3B0aW9ucy5jb250cm9scztcbiAgICB9XG4gIH1cblxuICAvKiogQHR5cGUge0NvbGxlY3Rpb248aW1wb3J0KFwiLi9pbnRlcmFjdGlvbi9JbnRlcmFjdGlvblwiKS5kZWZhdWx0Pn0gKi9cbiAgbGV0IGludGVyYWN0aW9ucztcbiAgaWYgKG9wdGlvbnMuaW50ZXJhY3Rpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zLmludGVyYWN0aW9ucykpIHtcbiAgICAgIGludGVyYWN0aW9ucyA9IG5ldyBDb2xsZWN0aW9uKG9wdGlvbnMuaW50ZXJhY3Rpb25zLnNsaWNlKCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhc3NlcnQoXG4gICAgICAgIHR5cGVvZiAoLyoqIEB0eXBlIHs/fSAqLyAob3B0aW9ucy5pbnRlcmFjdGlvbnMpLmdldEFycmF5KSA9PT1cbiAgICAgICAgICAnZnVuY3Rpb24nLFxuICAgICAgICAnRXhwZWN0ZWQgYGludGVyYWN0aW9uc2AgdG8gYmUgYW4gYXJyYXkgb3IgYW4gYG9sL0NvbGxlY3Rpb24uanNgJ1xuICAgICAgKTtcbiAgICAgIGludGVyYWN0aW9ucyA9IG9wdGlvbnMuaW50ZXJhY3Rpb25zO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBAdHlwZSB7Q29sbGVjdGlvbjxpbXBvcnQoXCIuL092ZXJsYXkuanNcIikuZGVmYXVsdD59ICovXG4gIGxldCBvdmVybGF5cztcbiAgaWYgKG9wdGlvbnMub3ZlcmxheXMgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KG9wdGlvbnMub3ZlcmxheXMpKSB7XG4gICAgICBvdmVybGF5cyA9IG5ldyBDb2xsZWN0aW9uKG9wdGlvbnMub3ZlcmxheXMuc2xpY2UoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFzc2VydChcbiAgICAgICAgdHlwZW9mICgvKiogQHR5cGUgez99ICovIChvcHRpb25zLm92ZXJsYXlzKS5nZXRBcnJheSkgPT09ICdmdW5jdGlvbicsXG4gICAgICAgICdFeHBlY3RlZCBgb3ZlcmxheXNgIHRvIGJlIGFuIGFycmF5IG9yIGFuIGBvbC9Db2xsZWN0aW9uLmpzYCdcbiAgICAgICk7XG4gICAgICBvdmVybGF5cyA9IG9wdGlvbnMub3ZlcmxheXM7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG92ZXJsYXlzID0gbmV3IENvbGxlY3Rpb24oKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgY29udHJvbHM6IGNvbnRyb2xzLFxuICAgIGludGVyYWN0aW9uczogaW50ZXJhY3Rpb25zLFxuICAgIGtleWJvYXJkRXZlbnRUYXJnZXQ6IGtleWJvYXJkRXZlbnRUYXJnZXQsXG4gICAgb3ZlcmxheXM6IG92ZXJsYXlzLFxuICAgIHZhbHVlczogdmFsdWVzLFxuICB9O1xufVxuZXhwb3J0IGRlZmF1bHQgTWFwO1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL01hcEJyb3dzZXJFdmVudFxuICovXG5pbXBvcnQgTWFwRXZlbnQgZnJvbSAnLi9NYXBFdmVudC5qcyc7XG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogRXZlbnRzIGVtaXR0ZWQgYXMgbWFwIGJyb3dzZXIgZXZlbnRzIGFyZSBpbnN0YW5jZXMgb2YgdGhpcyB0eXBlLlxuICogU2VlIHtAbGluayBtb2R1bGU6b2wvTWFwfk1hcH0gZm9yIHdoaWNoIGV2ZW50cyB0cmlnZ2VyIGEgbWFwIGJyb3dzZXIgZXZlbnQuXG4gKiBAdGVtcGxhdGUge1VJRXZlbnR9IEVWRU5UXG4gKi9cbmNsYXNzIE1hcEJyb3dzZXJFdmVudCBleHRlbmRzIE1hcEV2ZW50IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIEV2ZW50IHR5cGUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9NYXAuanNcIikuZGVmYXVsdH0gbWFwIE1hcC5cbiAgICogQHBhcmFtIHtFVkVOVH0gb3JpZ2luYWxFdmVudCBPcmlnaW5hbCBldmVudC5cbiAgICogQHBhcmFtIHtib29sZWFufSBbZHJhZ2dpbmddIElzIHRoZSBtYXAgY3VycmVudGx5IGJlaW5nIGRyYWdnZWQ/XG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9NYXAuanNcIikuRnJhbWVTdGF0ZX0gW2ZyYW1lU3RhdGVdIEZyYW1lIHN0YXRlLlxuICAgKiBAcGFyYW0ge0FycmF5PFBvaW50ZXJFdmVudD59IFthY3RpdmVQb2ludGVyc10gQWN0aXZlIHBvaW50ZXJzLlxuICAgKi9cbiAgY29uc3RydWN0b3IodHlwZSwgbWFwLCBvcmlnaW5hbEV2ZW50LCBkcmFnZ2luZywgZnJhbWVTdGF0ZSwgYWN0aXZlUG9pbnRlcnMpIHtcbiAgICBzdXBlcih0eXBlLCBtYXAsIGZyYW1lU3RhdGUpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG9yaWdpbmFsIGJyb3dzZXIgZXZlbnQuXG4gICAgICogQGNvbnN0XG4gICAgICogQHR5cGUge0VWRU5UfVxuICAgICAqIEBhcGlcbiAgICAgKi9cbiAgICB0aGlzLm9yaWdpbmFsRXZlbnQgPSBvcmlnaW5hbEV2ZW50O1xuXG4gICAgLyoqXG4gICAgICogVGhlIG1hcCBwaXhlbCByZWxhdGl2ZSB0byB0aGUgdmlld3BvcnQgY29ycmVzcG9uZGluZyB0byB0aGUgb3JpZ2luYWwgYnJvd3NlciBldmVudC5cbiAgICAgKiBAdHlwZSB7P2ltcG9ydChcIi4vcGl4ZWwuanNcIikuUGl4ZWx9XG4gICAgICovXG4gICAgdGhpcy5waXhlbF8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGNvb3JkaW5hdGUgaW4gdGhlIHVzZXIgcHJvamVjdGlvbiBjb3JyZXNwb25kaW5nIHRvIHRoZSBvcmlnaW5hbCBicm93c2VyIGV2ZW50LlxuICAgICAqIEB0eXBlIHs/aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9XG4gICAgICovXG4gICAgdGhpcy5jb29yZGluYXRlXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgaWYgdGhlIG1hcCBpcyBjdXJyZW50bHkgYmVpbmcgZHJhZ2dlZC4gT25seSBzZXQgZm9yXG4gICAgICogYFBPSU5URVJEUkFHYCBhbmQgYFBPSU5URVJNT1ZFYCBldmVudHMuIERlZmF1bHQgaXMgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBhcGlcbiAgICAgKi9cbiAgICB0aGlzLmRyYWdnaW5nID0gZHJhZ2dpbmcgIT09IHVuZGVmaW5lZCA/IGRyYWdnaW5nIDogZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QXJyYXk8UG9pbnRlckV2ZW50Pnx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5hY3RpdmVQb2ludGVycyA9IGFjdGl2ZVBvaW50ZXJzO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBtYXAgcGl4ZWwgcmVsYXRpdmUgdG8gdGhlIHZpZXdwb3J0IGNvcnJlc3BvbmRpbmcgdG8gdGhlIG9yaWdpbmFsIGV2ZW50LlxuICAgKiBAdHlwZSB7aW1wb3J0KFwiLi9waXhlbC5qc1wiKS5QaXhlbH1cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0IHBpeGVsKCkge1xuICAgIGlmICghdGhpcy5waXhlbF8pIHtcbiAgICAgIHRoaXMucGl4ZWxfID0gdGhpcy5tYXAuZ2V0RXZlbnRQaXhlbCh0aGlzLm9yaWdpbmFsRXZlbnQpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5waXhlbF87XG4gIH1cbiAgc2V0IHBpeGVsKHBpeGVsKSB7XG4gICAgdGhpcy5waXhlbF8gPSBwaXhlbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgY29vcmRpbmF0ZSBjb3JyZXNwb25kaW5nIHRvIHRoZSBvcmlnaW5hbCBicm93c2VyIGV2ZW50LiAgVGhpcyB3aWxsIGJlIGluIHRoZSB1c2VyXG4gICAqIHByb2plY3Rpb24gaWYgb25lIGlzIHNldC4gIE90aGVyd2lzZSBpdCB3aWxsIGJlIGluIHRoZSB2aWV3IHByb2plY3Rpb24uXG4gICAqIEB0eXBlIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX1cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0IGNvb3JkaW5hdGUoKSB7XG4gICAgaWYgKCF0aGlzLmNvb3JkaW5hdGVfKSB7XG4gICAgICB0aGlzLmNvb3JkaW5hdGVfID0gdGhpcy5tYXAuZ2V0Q29vcmRpbmF0ZUZyb21QaXhlbCh0aGlzLnBpeGVsKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY29vcmRpbmF0ZV87XG4gIH1cbiAgc2V0IGNvb3JkaW5hdGUoY29vcmRpbmF0ZSkge1xuICAgIHRoaXMuY29vcmRpbmF0ZV8gPSBjb29yZGluYXRlO1xuICB9XG5cbiAgLyoqXG4gICAqIFByZXZlbnRzIHRoZSBkZWZhdWx0IGJyb3dzZXIgYWN0aW9uLlxuICAgKiBTZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL2V2ZW50LnByZXZlbnREZWZhdWx0LlxuICAgKiBAYXBpXG4gICAqL1xuICBwcmV2ZW50RGVmYXVsdCgpIHtcbiAgICBzdXBlci5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGlmICgncHJldmVudERlZmF1bHQnIGluIHRoaXMub3JpZ2luYWxFdmVudCkge1xuICAgICAgLyoqIEB0eXBlIHtVSUV2ZW50fSAqLyAodGhpcy5vcmlnaW5hbEV2ZW50KS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBQcmV2ZW50cyBmdXJ0aGVyIHByb3BhZ2F0aW9uIG9mIHRoZSBjdXJyZW50IGV2ZW50LlxuICAgKiBTZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL2V2ZW50LnN0b3BQcm9wYWdhdGlvbi5cbiAgICogQGFwaVxuICAgKi9cbiAgc3RvcFByb3BhZ2F0aW9uKCkge1xuICAgIHN1cGVyLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIGlmICgnc3RvcFByb3BhZ2F0aW9uJyBpbiB0aGlzLm9yaWdpbmFsRXZlbnQpIHtcbiAgICAgIC8qKiBAdHlwZSB7VUlFdmVudH0gKi8gKHRoaXMub3JpZ2luYWxFdmVudCkuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1hcEJyb3dzZXJFdmVudDtcbiIsIi8qKlxuICogQG1vZHVsZSBvbC9NYXBCcm93c2VyRXZlbnRIYW5kbGVyXG4gKi9cblxuaW1wb3J0IEV2ZW50VHlwZSBmcm9tICcuL2V2ZW50cy9FdmVudFR5cGUuanMnO1xuaW1wb3J0IE1hcEJyb3dzZXJFdmVudCBmcm9tICcuL01hcEJyb3dzZXJFdmVudC5qcyc7XG5pbXBvcnQgTWFwQnJvd3NlckV2ZW50VHlwZSBmcm9tICcuL01hcEJyb3dzZXJFdmVudFR5cGUuanMnO1xuaW1wb3J0IFBvaW50ZXJFdmVudFR5cGUgZnJvbSAnLi9wb2ludGVyL0V2ZW50VHlwZS5qcyc7XG5pbXBvcnQgVGFyZ2V0IGZyb20gJy4vZXZlbnRzL1RhcmdldC5qcyc7XG5pbXBvcnQge1BBU1NJVkVfRVZFTlRfTElTVEVORVJTfSBmcm9tICcuL2hhcy5qcyc7XG5pbXBvcnQge2xpc3RlbiwgdW5saXN0ZW5CeUtleX0gZnJvbSAnLi9ldmVudHMuanMnO1xuXG5jbGFzcyBNYXBCcm93c2VyRXZlbnRIYW5kbGVyIGV4dGVuZHMgVGFyZ2V0IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9NYXAuanNcIikuZGVmYXVsdH0gbWFwIFRoZSBtYXAgd2l0aCB0aGUgdmlld3BvcnQgdG8gbGlzdGVuIHRvIGV2ZW50cyBvbi5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFttb3ZlVG9sZXJhbmNlXSBUaGUgbWluaW1hbCBkaXN0YW5jZSB0aGUgcG9pbnRlciBtdXN0IHRyYXZlbCB0byB0cmlnZ2VyIGEgbW92ZS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG1hcCwgbW92ZVRvbGVyYW5jZSkge1xuICAgIHN1cGVyKG1hcCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGlzIHRoZSBlbGVtZW50IHRoYXQgd2Ugd2lsbCBsaXN0ZW4gdG8gdGhlIHJlYWwgZXZlbnRzIG9uLlxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuL01hcC5qc1wiKS5kZWZhdWx0fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5tYXBfID0gbWFwO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge1JldHVyblR5cGU8dHlwZW9mIHNldFRpbWVvdXQ+fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5jbGlja1RpbWVvdXRJZF87XG5cbiAgICAvKipcbiAgICAgKiBFbXVsYXRlIGRibGNsaWNrIGFuZCBzaW5nbGVjbGljay4gV2lsbCBiZSB0cnVlIHdoZW4gb25seSBvbmUgcG9pbnRlciBpcyBhY3RpdmUuXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5lbXVsYXRlQ2xpY2tzXyA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmRyYWdnaW5nXyA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUgeyFBcnJheTxpbXBvcnQoXCIuL2V2ZW50cy5qc1wiKS5FdmVudHNLZXk+fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5kcmFnTGlzdGVuZXJLZXlzXyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMubW92ZVRvbGVyYW5jZV8gPSBtb3ZlVG9sZXJhbmNlID09PSB1bmRlZmluZWQgPyAxIDogbW92ZVRvbGVyYW5jZTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBtb3N0IHJlY2VudCBcImRvd25cIiB0eXBlIGV2ZW50IChvciBudWxsIGlmIG5vbmUgaGF2ZSBvY2N1cnJlZCkuXG4gICAgICogU2V0IG9uIHBvaW50ZXJkb3duLlxuICAgICAqIEB0eXBlIHtQb2ludGVyRXZlbnR8bnVsbH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuZG93bl8gPSBudWxsO1xuXG4gICAgY29uc3QgZWxlbWVudCA9IHRoaXMubWFwXy5nZXRWaWV3cG9ydCgpO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge0FycmF5PFBvaW50ZXJFdmVudD59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmFjdGl2ZVBvaW50ZXJzXyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUgeyFPYmplY3Q8bnVtYmVyLCBFdmVudD59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLnRyYWNrZWRUb3VjaGVzXyA9IHt9O1xuXG4gICAgdGhpcy5lbGVtZW50XyA9IGVsZW1lbnQ7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7P2ltcG9ydChcIi4vZXZlbnRzLmpzXCIpLkV2ZW50c0tleX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMucG9pbnRlcmRvd25MaXN0ZW5lcktleV8gPSBsaXN0ZW4oXG4gICAgICBlbGVtZW50LFxuICAgICAgUG9pbnRlckV2ZW50VHlwZS5QT0lOVEVSRE9XTixcbiAgICAgIHRoaXMuaGFuZGxlUG9pbnRlckRvd25fLFxuICAgICAgdGhpc1xuICAgICk7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7UG9pbnRlckV2ZW50fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5vcmlnaW5hbFBvaW50ZXJNb3ZlRXZlbnRfO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUgez9pbXBvcnQoXCIuL2V2ZW50cy5qc1wiKS5FdmVudHNLZXl9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLnJlbGF5ZWRMaXN0ZW5lcktleV8gPSBsaXN0ZW4oXG4gICAgICBlbGVtZW50LFxuICAgICAgUG9pbnRlckV2ZW50VHlwZS5QT0lOVEVSTU9WRSxcbiAgICAgIHRoaXMucmVsYXlNb3ZlRXZlbnRfLFxuICAgICAgdGhpc1xuICAgICk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuYm91bmRIYW5kbGVUb3VjaE1vdmVfID0gdGhpcy5oYW5kbGVUb3VjaE1vdmVfLmJpbmQodGhpcyk7XG5cbiAgICB0aGlzLmVsZW1lbnRfLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICBFdmVudFR5cGUuVE9VQ0hNT1ZFLFxuICAgICAgdGhpcy5ib3VuZEhhbmRsZVRvdWNoTW92ZV8sXG4gICAgICBQQVNTSVZFX0VWRU5UX0xJU1RFTkVSUyA/IHtwYXNzaXZlOiBmYWxzZX0gOiBmYWxzZVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtQb2ludGVyRXZlbnR9IHBvaW50ZXJFdmVudCBQb2ludGVyXG4gICAqIGV2ZW50LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZW11bGF0ZUNsaWNrXyhwb2ludGVyRXZlbnQpIHtcbiAgICBsZXQgbmV3RXZlbnQgPSBuZXcgTWFwQnJvd3NlckV2ZW50KFxuICAgICAgTWFwQnJvd3NlckV2ZW50VHlwZS5DTElDSyxcbiAgICAgIHRoaXMubWFwXyxcbiAgICAgIHBvaW50ZXJFdmVudFxuICAgICk7XG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ld0V2ZW50KTtcbiAgICBpZiAodGhpcy5jbGlja1RpbWVvdXRJZF8gIT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gZG91YmxlLWNsaWNrXG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5jbGlja1RpbWVvdXRJZF8pO1xuICAgICAgdGhpcy5jbGlja1RpbWVvdXRJZF8gPSB1bmRlZmluZWQ7XG4gICAgICBuZXdFdmVudCA9IG5ldyBNYXBCcm93c2VyRXZlbnQoXG4gICAgICAgIE1hcEJyb3dzZXJFdmVudFR5cGUuREJMQ0xJQ0ssXG4gICAgICAgIHRoaXMubWFwXyxcbiAgICAgICAgcG9pbnRlckV2ZW50XG4gICAgICApO1xuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ld0V2ZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gY2xpY2tcbiAgICAgIHRoaXMuY2xpY2tUaW1lb3V0SWRfID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMuY2xpY2tUaW1lb3V0SWRfID0gdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBuZXdFdmVudCA9IG5ldyBNYXBCcm93c2VyRXZlbnQoXG4gICAgICAgICAgTWFwQnJvd3NlckV2ZW50VHlwZS5TSU5HTEVDTElDSyxcbiAgICAgICAgICB0aGlzLm1hcF8sXG4gICAgICAgICAgcG9pbnRlckV2ZW50XG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXdFdmVudCk7XG4gICAgICB9LCAyNTApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBLZWVwcyB0cmFjayBvbiBob3cgbWFueSBwb2ludGVycyBhcmUgY3VycmVudGx5IGFjdGl2ZS5cbiAgICpcbiAgICogQHBhcmFtIHtQb2ludGVyRXZlbnR9IHBvaW50ZXJFdmVudCBQb2ludGVyXG4gICAqIGV2ZW50LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdXBkYXRlQWN0aXZlUG9pbnRlcnNfKHBvaW50ZXJFdmVudCkge1xuICAgIGNvbnN0IGV2ZW50ID0gcG9pbnRlckV2ZW50O1xuICAgIGNvbnN0IGlkID0gZXZlbnQucG9pbnRlcklkO1xuXG4gICAgaWYgKFxuICAgICAgZXZlbnQudHlwZSA9PSBNYXBCcm93c2VyRXZlbnRUeXBlLlBPSU5URVJVUCB8fFxuICAgICAgZXZlbnQudHlwZSA9PSBNYXBCcm93c2VyRXZlbnRUeXBlLlBPSU5URVJDQU5DRUxcbiAgICApIHtcbiAgICAgIGRlbGV0ZSB0aGlzLnRyYWNrZWRUb3VjaGVzX1tpZF07XG4gICAgICBmb3IgKGNvbnN0IHBvaW50ZXJJZCBpbiB0aGlzLnRyYWNrZWRUb3VjaGVzXykge1xuICAgICAgICBpZiAodGhpcy50cmFja2VkVG91Y2hlc19bcG9pbnRlcklkXS50YXJnZXQgIT09IGV2ZW50LnRhcmdldCkge1xuICAgICAgICAgIC8vIFNvbWUgcGxhdGZvcm1zIGFzc2lnbiBhIG5ldyBwb2ludGVySWQgd2hlbiB0aGUgdGFyZ2V0IGNoYW5nZXMuXG4gICAgICAgICAgLy8gSWYgdGhpcyBoYXBwZW5zLCBkZWxldGUgb25lIHRyYWNrZWQgcG9pbnRlci4gSWYgdGhlcmUgaXMgbW9yZVxuICAgICAgICAgIC8vIHRoYW4gb25lIHRyYWNrZWQgcG9pbnRlciBmb3IgdGhlIG9sZCB0YXJnZXQsIGl0IHdpbGwgYmUgY2xlYXJlZFxuICAgICAgICAgIC8vIGJ5IHN1YnNlcXVlbnQgUE9JTlRFUlVQIGV2ZW50cyBmcm9tIG90aGVyIHBvaW50ZXJzLlxuICAgICAgICAgIGRlbGV0ZSB0aGlzLnRyYWNrZWRUb3VjaGVzX1twb2ludGVySWRdO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIGV2ZW50LnR5cGUgPT0gTWFwQnJvd3NlckV2ZW50VHlwZS5QT0lOVEVSRE9XTiB8fFxuICAgICAgZXZlbnQudHlwZSA9PSBNYXBCcm93c2VyRXZlbnRUeXBlLlBPSU5URVJNT1ZFXG4gICAgKSB7XG4gICAgICB0aGlzLnRyYWNrZWRUb3VjaGVzX1tpZF0gPSBldmVudDtcbiAgICB9XG4gICAgdGhpcy5hY3RpdmVQb2ludGVyc18gPSBPYmplY3QudmFsdWVzKHRoaXMudHJhY2tlZFRvdWNoZXNfKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1BvaW50ZXJFdmVudH0gcG9pbnRlckV2ZW50IFBvaW50ZXJcbiAgICogZXZlbnQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBoYW5kbGVQb2ludGVyVXBfKHBvaW50ZXJFdmVudCkge1xuICAgIHRoaXMudXBkYXRlQWN0aXZlUG9pbnRlcnNfKHBvaW50ZXJFdmVudCk7XG4gICAgY29uc3QgbmV3RXZlbnQgPSBuZXcgTWFwQnJvd3NlckV2ZW50KFxuICAgICAgTWFwQnJvd3NlckV2ZW50VHlwZS5QT0lOVEVSVVAsXG4gICAgICB0aGlzLm1hcF8sXG4gICAgICBwb2ludGVyRXZlbnQsXG4gICAgICB1bmRlZmluZWQsXG4gICAgICB1bmRlZmluZWQsXG4gICAgICB0aGlzLmFjdGl2ZVBvaW50ZXJzX1xuICAgICk7XG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ld0V2ZW50KTtcblxuICAgIC8vIFdlIGVtdWxhdGUgY2xpY2sgZXZlbnRzIG9uIGxlZnQgbW91c2UgYnV0dG9uIGNsaWNrLCB0b3VjaCBjb250YWN0LCBhbmQgcGVuXG4gICAgLy8gY29udGFjdC4gaXNNb3VzZUFjdGlvbkJ1dHRvbiByZXR1cm5zIHRydWUgaW4gdGhlc2UgY2FzZXMgKGV2dC5idXR0b24gaXMgc2V0XG4gICAgLy8gdG8gMCkuXG4gICAgLy8gU2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL3BvaW50ZXJldmVudHMvI2J1dHRvbi1zdGF0ZXNcbiAgICAvLyBXZSBvbmx5IGZpcmUgY2xpY2ssIHNpbmdsZWNsaWNrLCBhbmQgZG91YmxlY2xpY2sgaWYgbm9ib2R5IGhhcyBjYWxsZWRcbiAgICAvLyBldmVudC5wcmV2ZW50RGVmYXVsdCgpLlxuICAgIGlmIChcbiAgICAgIHRoaXMuZW11bGF0ZUNsaWNrc18gJiZcbiAgICAgICFuZXdFdmVudC5kZWZhdWx0UHJldmVudGVkICYmXG4gICAgICAhdGhpcy5kcmFnZ2luZ18gJiZcbiAgICAgIHRoaXMuaXNNb3VzZUFjdGlvbkJ1dHRvbl8ocG9pbnRlckV2ZW50KVxuICAgICkge1xuICAgICAgdGhpcy5lbXVsYXRlQ2xpY2tfKHRoaXMuZG93bl8pO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmFjdGl2ZVBvaW50ZXJzXy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMuZHJhZ0xpc3RlbmVyS2V5c18uZm9yRWFjaCh1bmxpc3RlbkJ5S2V5KTtcbiAgICAgIHRoaXMuZHJhZ0xpc3RlbmVyS2V5c18ubGVuZ3RoID0gMDtcbiAgICAgIHRoaXMuZHJhZ2dpbmdfID0gZmFsc2U7XG4gICAgICB0aGlzLmRvd25fID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtQb2ludGVyRXZlbnR9IHBvaW50ZXJFdmVudCBQb2ludGVyXG4gICAqIGV2ZW50LlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBJZiB0aGUgbGVmdCBtb3VzZSBidXR0b24gd2FzIHByZXNzZWQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBpc01vdXNlQWN0aW9uQnV0dG9uXyhwb2ludGVyRXZlbnQpIHtcbiAgICByZXR1cm4gcG9pbnRlckV2ZW50LmJ1dHRvbiA9PT0gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1BvaW50ZXJFdmVudH0gcG9pbnRlckV2ZW50IFBvaW50ZXJcbiAgICogZXZlbnQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBoYW5kbGVQb2ludGVyRG93bl8ocG9pbnRlckV2ZW50KSB7XG4gICAgdGhpcy5lbXVsYXRlQ2xpY2tzXyA9IHRoaXMuYWN0aXZlUG9pbnRlcnNfLmxlbmd0aCA9PT0gMDtcbiAgICB0aGlzLnVwZGF0ZUFjdGl2ZVBvaW50ZXJzXyhwb2ludGVyRXZlbnQpO1xuICAgIGNvbnN0IG5ld0V2ZW50ID0gbmV3IE1hcEJyb3dzZXJFdmVudChcbiAgICAgIE1hcEJyb3dzZXJFdmVudFR5cGUuUE9JTlRFUkRPV04sXG4gICAgICB0aGlzLm1hcF8sXG4gICAgICBwb2ludGVyRXZlbnQsXG4gICAgICB1bmRlZmluZWQsXG4gICAgICB1bmRlZmluZWQsXG4gICAgICB0aGlzLmFjdGl2ZVBvaW50ZXJzX1xuICAgICk7XG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ld0V2ZW50KTtcblxuICAgIHRoaXMuZG93bl8gPSBuZXcgUG9pbnRlckV2ZW50KHBvaW50ZXJFdmVudC50eXBlLCBwb2ludGVyRXZlbnQpO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLmRvd25fLCAndGFyZ2V0Jywge1xuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IHBvaW50ZXJFdmVudC50YXJnZXQsXG4gICAgfSk7XG5cbiAgICBpZiAodGhpcy5kcmFnTGlzdGVuZXJLZXlzXy5sZW5ndGggPT09IDApIHtcbiAgICAgIGNvbnN0IGRvYyA9IHRoaXMubWFwXy5nZXRPd25lckRvY3VtZW50KCk7XG4gICAgICB0aGlzLmRyYWdMaXN0ZW5lcktleXNfLnB1c2goXG4gICAgICAgIGxpc3RlbihcbiAgICAgICAgICBkb2MsXG4gICAgICAgICAgTWFwQnJvd3NlckV2ZW50VHlwZS5QT0lOVEVSTU9WRSxcbiAgICAgICAgICB0aGlzLmhhbmRsZVBvaW50ZXJNb3ZlXyxcbiAgICAgICAgICB0aGlzXG4gICAgICAgICksXG4gICAgICAgIGxpc3Rlbihkb2MsIE1hcEJyb3dzZXJFdmVudFR5cGUuUE9JTlRFUlVQLCB0aGlzLmhhbmRsZVBvaW50ZXJVcF8sIHRoaXMpLFxuICAgICAgICAvKiBOb3RlIHRoYXQgdGhlIGxpc3RlbmVyIGZvciBgcG9pbnRlcmNhbmNlbCBpcyBzZXQgdXAgb25cbiAgICAgICAgICogYHBvaW50ZXJFdmVudEhhbmRsZXJfYCBhbmQgbm90IGBkb2N1bWVudFBvaW50ZXJFdmVudEhhbmRsZXJfYCBsaWtlXG4gICAgICAgICAqIHRoZSBgcG9pbnRlcnVwYCBhbmQgYHBvaW50ZXJtb3ZlYCBsaXN0ZW5lcnMuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSByZWFzb24gZm9yIHRoaXMgaXMgdGhlIGZvbGxvd2luZzogYFRvdWNoU291cmNlLnZhY3V1bVRvdWNoZXNfKClgXG4gICAgICAgICAqIGlzc3VlcyBgcG9pbnRlcmNhbmNlbGAgZXZlbnRzLCB3aGVuIHRoZXJlIHdhcyBubyBgdG91Y2hlbmRgIGZvciBhXG4gICAgICAgICAqIGB0b3VjaHN0YXJ0YC4gTm93LCBsZXQncyBzYXkgYSBmaXJzdCBgdG91Y2hzdGFydGAgaXMgcmVnaXN0ZXJlZCBvblxuICAgICAgICAgKiBgcG9pbnRlckV2ZW50SGFuZGxlcl9gLiBUaGUgYGRvY3VtZW50UG9pbnRlckV2ZW50SGFuZGxlcl9gIGlzIHNldCB1cC5cbiAgICAgICAgICogQnV0IGBkb2N1bWVudFBvaW50ZXJFdmVudEhhbmRsZXJfYCBkb2Vzbid0IGtub3cgYWJvdXQgdGhlIGZpcnN0XG4gICAgICAgICAqIGB0b3VjaHN0YXJ0YC4gSWYgdGhlcmUgaXMgbm8gYHRvdWNoZW5kYCBmb3IgdGhlIGB0b3VjaHN0YXJ0YCwgd2UgY2FuXG4gICAgICAgICAqIG9ubHkgcmVjZWl2ZSBhIGB0b3VjaGNhbmNlbGAgZnJvbSBgcG9pbnRlckV2ZW50SGFuZGxlcl9gLCBiZWNhdXNlIGl0IGlzXG4gICAgICAgICAqIG9ubHkgcmVnaXN0ZXJlZCB0aGVyZS5cbiAgICAgICAgICovXG4gICAgICAgIGxpc3RlbihcbiAgICAgICAgICB0aGlzLmVsZW1lbnRfLFxuICAgICAgICAgIE1hcEJyb3dzZXJFdmVudFR5cGUuUE9JTlRFUkNBTkNFTCxcbiAgICAgICAgICB0aGlzLmhhbmRsZVBvaW50ZXJVcF8sXG4gICAgICAgICAgdGhpc1xuICAgICAgICApXG4gICAgICApO1xuICAgICAgaWYgKHRoaXMuZWxlbWVudF8uZ2V0Um9vdE5vZGUgJiYgdGhpcy5lbGVtZW50Xy5nZXRSb290Tm9kZSgpICE9PSBkb2MpIHtcbiAgICAgICAgdGhpcy5kcmFnTGlzdGVuZXJLZXlzXy5wdXNoKFxuICAgICAgICAgIGxpc3RlbihcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudF8uZ2V0Um9vdE5vZGUoKSxcbiAgICAgICAgICAgIE1hcEJyb3dzZXJFdmVudFR5cGUuUE9JTlRFUlVQLFxuICAgICAgICAgICAgdGhpcy5oYW5kbGVQb2ludGVyVXBfLFxuICAgICAgICAgICAgdGhpc1xuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtQb2ludGVyRXZlbnR9IHBvaW50ZXJFdmVudCBQb2ludGVyXG4gICAqIGV2ZW50LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaGFuZGxlUG9pbnRlck1vdmVfKHBvaW50ZXJFdmVudCkge1xuICAgIC8vIEJldHdlZW4gcG9pbnRlcmRvd24gYW5kIHBvaW50ZXJ1cCwgcG9pbnRlcm1vdmUgZXZlbnRzIGFyZSB0cmlnZ2VyZWQuXG4gICAgLy8gVG8gYXZvaWQgYSAnZmFsc2UnIHRvdWNobW92ZSBldmVudCB0byBiZSBkaXNwYXRjaGVkLCB3ZSB0ZXN0IGlmIHRoZSBwb2ludGVyXG4gICAgLy8gbW92ZWQgYSBzaWduaWZpY2FudCBkaXN0YW5jZS5cbiAgICBpZiAodGhpcy5pc01vdmluZ18ocG9pbnRlckV2ZW50KSkge1xuICAgICAgdGhpcy51cGRhdGVBY3RpdmVQb2ludGVyc18ocG9pbnRlckV2ZW50KTtcbiAgICAgIHRoaXMuZHJhZ2dpbmdfID0gdHJ1ZTtcbiAgICAgIGNvbnN0IG5ld0V2ZW50ID0gbmV3IE1hcEJyb3dzZXJFdmVudChcbiAgICAgICAgTWFwQnJvd3NlckV2ZW50VHlwZS5QT0lOVEVSRFJBRyxcbiAgICAgICAgdGhpcy5tYXBfLFxuICAgICAgICBwb2ludGVyRXZlbnQsXG4gICAgICAgIHRoaXMuZHJhZ2dpbmdfLFxuICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgIHRoaXMuYWN0aXZlUG9pbnRlcnNfXG4gICAgICApO1xuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ld0V2ZW50KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogV3JhcCBhbmQgcmVsYXkgYSBwb2ludGVybW92ZSBldmVudC5cbiAgICogQHBhcmFtIHtQb2ludGVyRXZlbnR9IHBvaW50ZXJFdmVudCBQb2ludGVyXG4gICAqIGV2ZW50LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcmVsYXlNb3ZlRXZlbnRfKHBvaW50ZXJFdmVudCkge1xuICAgIHRoaXMub3JpZ2luYWxQb2ludGVyTW92ZUV2ZW50XyA9IHBvaW50ZXJFdmVudDtcbiAgICBjb25zdCBkcmFnZ2luZyA9ICEhKHRoaXMuZG93bl8gJiYgdGhpcy5pc01vdmluZ18ocG9pbnRlckV2ZW50KSk7XG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KFxuICAgICAgbmV3IE1hcEJyb3dzZXJFdmVudChcbiAgICAgICAgTWFwQnJvd3NlckV2ZW50VHlwZS5QT0lOVEVSTU9WRSxcbiAgICAgICAgdGhpcy5tYXBfLFxuICAgICAgICBwb2ludGVyRXZlbnQsXG4gICAgICAgIGRyYWdnaW5nXG4gICAgICApXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGbGV4aWJsZSBoYW5kbGluZyBvZiBhIGB0b3VjaC1hY3Rpb246IG5vbmVgIGNzcyBlcXVpdmFsZW50OiBiZWNhdXNlIGNhbGxpbmdcbiAgICogYHByZXZlbnREZWZhdWx0KClgIG9uIGEgYHBvaW50ZXJtb3ZlYCBldmVudCBkb2VzIG5vdCBzdG9wIG5hdGl2ZSBwYWdlIHNjcm9sbGluZ1xuICAgKiBhbmQgem9vbWluZywgd2UgYWxzbyBsaXN0ZW4gZm9yIGB0b3VjaG1vdmVgIGFuZCBjYWxsIGBwcmV2ZW50RGVmYXVsdCgpYCBvbiBpdFxuICAgKiB3aGVuIGFuIGludGVyYWN0aW9uIChjdXJyZW50bHkgYERyYWdQYW5gIGhhbmRsZXMgdGhlIGV2ZW50LlxuICAgKiBAcGFyYW0ge1RvdWNoRXZlbnR9IGV2ZW50IEV2ZW50LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaGFuZGxlVG91Y2hNb3ZlXyhldmVudCkge1xuICAgIC8vIER1ZSB0byBodHRwczovL2dpdGh1Yi5jb20vbXBpemVuYmVyZy9lbG0tcGVwL2lzc3Vlcy8yLCBgdGhpcy5vcmlnaW5hbFBvaW50ZXJNb3ZlRXZlbnRfYFxuICAgIC8vIG1heSBub3QgYmUgaW5pdGlhbGl6ZWQgeWV0IHdoZW4gd2UgZ2V0IGhlcmUgb24gYSBwbGF0Zm9ybSB3aXRob3V0IG5hdGl2ZSBwb2ludGVyIGV2ZW50cyxcbiAgICAvLyB3aGVuIGVsbS1wZXAgaXMgdXNlZCBhcyBwb2ludGVyIGV2ZW50cyBwb2x5ZmlsbC5cbiAgICBjb25zdCBvcmlnaW5hbEV2ZW50ID0gdGhpcy5vcmlnaW5hbFBvaW50ZXJNb3ZlRXZlbnRfO1xuICAgIGlmIChcbiAgICAgICghb3JpZ2luYWxFdmVudCB8fCBvcmlnaW5hbEV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpICYmXG4gICAgICAodHlwZW9mIGV2ZW50LmNhbmNlbGFibGUgIT09ICdib29sZWFuJyB8fCBldmVudC5jYW5jZWxhYmxlID09PSB0cnVlKVxuICAgICkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtQb2ludGVyRXZlbnR9IHBvaW50ZXJFdmVudCBQb2ludGVyXG4gICAqIGV2ZW50LlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBJcyBtb3ZpbmcuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBpc01vdmluZ18ocG9pbnRlckV2ZW50KSB7XG4gICAgcmV0dXJuIChcbiAgICAgIHRoaXMuZHJhZ2dpbmdfIHx8XG4gICAgICBNYXRoLmFicyhwb2ludGVyRXZlbnQuY2xpZW50WCAtIHRoaXMuZG93bl8uY2xpZW50WCkgPlxuICAgICAgICB0aGlzLm1vdmVUb2xlcmFuY2VfIHx8XG4gICAgICBNYXRoLmFicyhwb2ludGVyRXZlbnQuY2xpZW50WSAtIHRoaXMuZG93bl8uY2xpZW50WSkgPiB0aGlzLm1vdmVUb2xlcmFuY2VfXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhbiB1cC5cbiAgICovXG4gIGRpc3Bvc2VJbnRlcm5hbCgpIHtcbiAgICBpZiAodGhpcy5yZWxheWVkTGlzdGVuZXJLZXlfKSB7XG4gICAgICB1bmxpc3RlbkJ5S2V5KHRoaXMucmVsYXllZExpc3RlbmVyS2V5Xyk7XG4gICAgICB0aGlzLnJlbGF5ZWRMaXN0ZW5lcktleV8gPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLmVsZW1lbnRfLnJlbW92ZUV2ZW50TGlzdGVuZXIoXG4gICAgICBFdmVudFR5cGUuVE9VQ0hNT1ZFLFxuICAgICAgdGhpcy5ib3VuZEhhbmRsZVRvdWNoTW92ZV9cbiAgICApO1xuXG4gICAgaWYgKHRoaXMucG9pbnRlcmRvd25MaXN0ZW5lcktleV8pIHtcbiAgICAgIHVubGlzdGVuQnlLZXkodGhpcy5wb2ludGVyZG93bkxpc3RlbmVyS2V5Xyk7XG4gICAgICB0aGlzLnBvaW50ZXJkb3duTGlzdGVuZXJLZXlfID0gbnVsbDtcbiAgICB9XG5cbiAgICB0aGlzLmRyYWdMaXN0ZW5lcktleXNfLmZvckVhY2godW5saXN0ZW5CeUtleSk7XG4gICAgdGhpcy5kcmFnTGlzdGVuZXJLZXlzXy5sZW5ndGggPSAwO1xuXG4gICAgdGhpcy5lbGVtZW50XyA9IG51bGw7XG4gICAgc3VwZXIuZGlzcG9zZUludGVybmFsKCk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTWFwQnJvd3NlckV2ZW50SGFuZGxlcjtcbiIsIi8qKlxuICogQG1vZHVsZSBvbC9NYXBCcm93c2VyRXZlbnRUeXBlXG4gKi9cbmltcG9ydCBFdmVudFR5cGUgZnJvbSAnLi9ldmVudHMvRXZlbnRUeXBlLmpzJztcblxuLyoqXG4gKiBDb25zdGFudHMgZm9yIGV2ZW50IG5hbWVzLlxuICogQGVudW0ge3N0cmluZ31cbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICAvKipcbiAgICogQSB0cnVlIHNpbmdsZSBjbGljayB3aXRoIG5vIGRyYWdnaW5nIGFuZCBubyBkb3VibGUgY2xpY2suIE5vdGUgdGhhdCB0aGlzXG4gICAqIGV2ZW50IGlzIGRlbGF5ZWQgYnkgMjUwIG1zIHRvIGVuc3VyZSB0aGF0IGl0IGlzIG5vdCBhIGRvdWJsZSBjbGljay5cbiAgICogQGV2ZW50IG1vZHVsZTpvbC9NYXBCcm93c2VyRXZlbnR+TWFwQnJvd3NlckV2ZW50I3NpbmdsZWNsaWNrXG4gICAqIEBhcGlcbiAgICovXG4gIFNJTkdMRUNMSUNLOiAnc2luZ2xlY2xpY2snLFxuXG4gIC8qKlxuICAgKiBBIGNsaWNrIHdpdGggbm8gZHJhZ2dpbmcuIEEgZG91YmxlIGNsaWNrIHdpbGwgZmlyZSB0d28gb2YgdGhpcy5cbiAgICogQGV2ZW50IG1vZHVsZTpvbC9NYXBCcm93c2VyRXZlbnR+TWFwQnJvd3NlckV2ZW50I2NsaWNrXG4gICAqIEBhcGlcbiAgICovXG4gIENMSUNLOiBFdmVudFR5cGUuQ0xJQ0ssXG5cbiAgLyoqXG4gICAqIEEgdHJ1ZSBkb3VibGUgY2xpY2ssIHdpdGggbm8gZHJhZ2dpbmcuXG4gICAqIEBldmVudCBtb2R1bGU6b2wvTWFwQnJvd3NlckV2ZW50fk1hcEJyb3dzZXJFdmVudCNkYmxjbGlja1xuICAgKiBAYXBpXG4gICAqL1xuICBEQkxDTElDSzogRXZlbnRUeXBlLkRCTENMSUNLLFxuXG4gIC8qKlxuICAgKiBUcmlnZ2VyZWQgd2hlbiBhIHBvaW50ZXIgaXMgZHJhZ2dlZC5cbiAgICogQGV2ZW50IG1vZHVsZTpvbC9NYXBCcm93c2VyRXZlbnR+TWFwQnJvd3NlckV2ZW50I3BvaW50ZXJkcmFnXG4gICAqIEBhcGlcbiAgICovXG4gIFBPSU5URVJEUkFHOiAncG9pbnRlcmRyYWcnLFxuXG4gIC8qKlxuICAgKiBUcmlnZ2VyZWQgd2hlbiBhIHBvaW50ZXIgaXMgbW92ZWQuIE5vdGUgdGhhdCBvbiB0b3VjaCBkZXZpY2VzIHRoaXMgaXNcbiAgICogdHJpZ2dlcmVkIHdoZW4gdGhlIG1hcCBpcyBwYW5uZWQsIHNvIGlzIG5vdCB0aGUgc2FtZSBhcyBtb3VzZW1vdmUuXG4gICAqIEBldmVudCBtb2R1bGU6b2wvTWFwQnJvd3NlckV2ZW50fk1hcEJyb3dzZXJFdmVudCNwb2ludGVybW92ZVxuICAgKiBAYXBpXG4gICAqL1xuICBQT0lOVEVSTU9WRTogJ3BvaW50ZXJtb3ZlJyxcblxuICBQT0lOVEVSRE9XTjogJ3BvaW50ZXJkb3duJyxcbiAgUE9JTlRFUlVQOiAncG9pbnRlcnVwJyxcbiAgUE9JTlRFUk9WRVI6ICdwb2ludGVyb3ZlcicsXG4gIFBPSU5URVJPVVQ6ICdwb2ludGVyb3V0JyxcbiAgUE9JTlRFUkVOVEVSOiAncG9pbnRlcmVudGVyJyxcbiAgUE9JTlRFUkxFQVZFOiAncG9pbnRlcmxlYXZlJyxcbiAgUE9JTlRFUkNBTkNFTDogJ3BvaW50ZXJjYW5jZWwnLFxufTtcblxuLyoqKlxuICogQHR5cGVkZWYgeydzaW5nbGVjbGljayd8J2NsaWNrJ3wnZGJsY2xpY2snfCdwb2ludGVyZHJhZyd8J3BvaW50ZXJtb3ZlJ30gVHlwZXNcbiAqL1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL01hcEV2ZW50XG4gKi9cbmltcG9ydCBFdmVudCBmcm9tICcuL2V2ZW50cy9FdmVudC5qcyc7XG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogRXZlbnRzIGVtaXR0ZWQgYXMgbWFwIGV2ZW50cyBhcmUgaW5zdGFuY2VzIG9mIHRoaXMgdHlwZS5cbiAqIFNlZSB7QGxpbmsgbW9kdWxlOm9sL01hcH5NYXB9IGZvciB3aGljaCBldmVudHMgdHJpZ2dlciBhIG1hcCBldmVudC5cbiAqL1xuY2xhc3MgTWFwRXZlbnQgZXh0ZW5kcyBFdmVudCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBFdmVudCB0eXBlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vTWFwLmpzXCIpLmRlZmF1bHR9IG1hcCBNYXAuXG4gICAqIEBwYXJhbSB7P2ltcG9ydChcIi4vTWFwLmpzXCIpLkZyYW1lU3RhdGV9IFtmcmFtZVN0YXRlXSBGcmFtZSBzdGF0ZS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHR5cGUsIG1hcCwgZnJhbWVTdGF0ZSkge1xuICAgIHN1cGVyKHR5cGUpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG1hcCB3aGVyZSB0aGUgZXZlbnQgb2NjdXJyZWQuXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4vTWFwLmpzXCIpLmRlZmF1bHR9XG4gICAgICogQGFwaVxuICAgICAqL1xuICAgIHRoaXMubWFwID0gbWFwO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGZyYW1lIHN0YXRlIGF0IHRoZSB0aW1lIG9mIHRoZSBldmVudC5cbiAgICAgKiBAdHlwZSB7P2ltcG9ydChcIi4vTWFwLmpzXCIpLkZyYW1lU3RhdGV9XG4gICAgICogQGFwaVxuICAgICAqL1xuICAgIHRoaXMuZnJhbWVTdGF0ZSA9IGZyYW1lU3RhdGUgIT09IHVuZGVmaW5lZCA/IGZyYW1lU3RhdGUgOiBudWxsO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1hcEV2ZW50O1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL01hcEV2ZW50VHlwZVxuICovXG5cbi8qKlxuICogQGVudW0ge3N0cmluZ31cbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICAvKipcbiAgICogVHJpZ2dlcmVkIGFmdGVyIGEgbWFwIGZyYW1lIGlzIHJlbmRlcmVkLlxuICAgKiBAZXZlbnQgbW9kdWxlOm9sL01hcEV2ZW50fk1hcEV2ZW50I3Bvc3RyZW5kZXJcbiAgICogQGFwaVxuICAgKi9cbiAgUE9TVFJFTkRFUjogJ3Bvc3RyZW5kZXInLFxuXG4gIC8qKlxuICAgKiBUcmlnZ2VyZWQgd2hlbiB0aGUgbWFwIHN0YXJ0cyBtb3ZpbmcuXG4gICAqIEBldmVudCBtb2R1bGU6b2wvTWFwRXZlbnR+TWFwRXZlbnQjbW92ZXN0YXJ0XG4gICAqIEBhcGlcbiAgICovXG4gIE1PVkVTVEFSVDogJ21vdmVzdGFydCcsXG5cbiAgLyoqXG4gICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgbWFwIGlzIG1vdmVkLlxuICAgKiBAZXZlbnQgbW9kdWxlOm9sL01hcEV2ZW50fk1hcEV2ZW50I21vdmVlbmRcbiAgICogQGFwaVxuICAgKi9cbiAgTU9WRUVORDogJ21vdmVlbmQnLFxuXG4gIC8qKlxuICAgKiBUcmlnZ2VyZWQgd2hlbiBsb2FkaW5nIG9mIGFkZGl0aW9uYWwgbWFwIGRhdGEgKHRpbGVzLCBpbWFnZXMsIGZlYXR1cmVzKSBzdGFydHMuXG4gICAqIEBldmVudCBtb2R1bGU6b2wvTWFwRXZlbnR+TWFwRXZlbnQjbG9hZHN0YXJ0XG4gICAqIEBhcGlcbiAgICovXG4gIExPQURTVEFSVDogJ2xvYWRzdGFydCcsXG5cbiAgLyoqXG4gICAqIFRyaWdnZXJlZCB3aGVuIGxvYWRpbmcgb2YgYWRkaXRpb25hbCBtYXAgZGF0YSBoYXMgY29tcGxldGVkLlxuICAgKiBAZXZlbnQgbW9kdWxlOm9sL01hcEV2ZW50fk1hcEV2ZW50I2xvYWRlbmRcbiAgICogQGFwaVxuICAgKi9cbiAgTE9BREVORDogJ2xvYWRlbmQnLFxufTtcblxuLyoqKlxuICogQHR5cGVkZWYgeydwb3N0cmVuZGVyJ3wnbW92ZXN0YXJ0J3wnbW92ZWVuZCd8J2xvYWRzdGFydCd8J2xvYWRlbmQnfSBUeXBlc1xuICovXG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvTWFwUHJvcGVydHlcbiAqL1xuXG4vKipcbiAqIEBlbnVtIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IHtcbiAgTEFZRVJHUk9VUDogJ2xheWVyZ3JvdXAnLFxuICBTSVpFOiAnc2l6ZScsXG4gIFRBUkdFVDogJ3RhcmdldCcsXG4gIFZJRVc6ICd2aWV3Jyxcbn07XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvT2JqZWN0XG4gKi9cbmltcG9ydCBFdmVudCBmcm9tICcuL2V2ZW50cy9FdmVudC5qcyc7XG5pbXBvcnQgT2JqZWN0RXZlbnRUeXBlIGZyb20gJy4vT2JqZWN0RXZlbnRUeXBlLmpzJztcbmltcG9ydCBPYnNlcnZhYmxlIGZyb20gJy4vT2JzZXJ2YWJsZS5qcyc7XG5pbXBvcnQge2dldFVpZH0gZnJvbSAnLi91dGlsLmpzJztcbmltcG9ydCB7aXNFbXB0eX0gZnJvbSAnLi9vYmouanMnO1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEV2ZW50cyBlbWl0dGVkIGJ5IHtAbGluayBtb2R1bGU6b2wvT2JqZWN0fkJhc2VPYmplY3R9IGluc3RhbmNlcyBhcmUgaW5zdGFuY2VzIG9mIHRoaXMgdHlwZS5cbiAqL1xuZXhwb3J0IGNsYXNzIE9iamVjdEV2ZW50IGV4dGVuZHMgRXZlbnQge1xuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgVGhlIGV2ZW50IHR5cGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIHByb3BlcnR5IG5hbWUuXG4gICAqIEBwYXJhbSB7Kn0gb2xkVmFsdWUgVGhlIG9sZCB2YWx1ZSBmb3IgYGtleWAuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih0eXBlLCBrZXksIG9sZFZhbHVlKSB7XG4gICAgc3VwZXIodHlwZSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgd2hvc2UgdmFsdWUgaXMgY2hhbmdpbmcuXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAYXBpXG4gICAgICovXG4gICAgdGhpcy5rZXkgPSBrZXk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb2xkIHZhbHVlLiBUbyBnZXQgdGhlIG5ldyB2YWx1ZSB1c2UgYGUudGFyZ2V0LmdldChlLmtleSlgIHdoZXJlXG4gICAgICogYGVgIGlzIHRoZSBldmVudCBvYmplY3QuXG4gICAgICogQHR5cGUgeyp9XG4gICAgICogQGFwaVxuICAgICAqL1xuICAgIHRoaXMub2xkVmFsdWUgPSBvbGRWYWx1ZTtcbiAgfVxufVxuXG4vKioqXG4gKiBAdGVtcGxhdGUgUmV0dXJuXG4gKiBAdHlwZWRlZiB7aW1wb3J0KFwiLi9PYnNlcnZhYmxlXCIpLk9uU2lnbmF0dXJlPGltcG9ydChcIi4vT2JzZXJ2YWJsZVwiKS5FdmVudFR5cGVzLCBpbXBvcnQoXCIuL2V2ZW50cy9FdmVudC5qc1wiKS5kZWZhdWx0LCBSZXR1cm4+ICZcbiAqICAgIGltcG9ydChcIi4vT2JzZXJ2YWJsZVwiKS5PblNpZ25hdHVyZTxpbXBvcnQoXCIuL09iamVjdEV2ZW50VHlwZVwiKS5UeXBlcywgT2JqZWN0RXZlbnQsIFJldHVybj4gJlxuICogICAgaW1wb3J0KFwiLi9PYnNlcnZhYmxlXCIpLkNvbWJpbmVkT25TaWduYXR1cmU8aW1wb3J0KFwiLi9PYnNlcnZhYmxlXCIpLkV2ZW50VHlwZXN8aW1wb3J0KFwiLi9PYmplY3RFdmVudFR5cGVcIikuVHlwZXMsIFJldHVybj59IE9iamVjdE9uU2lnbmF0dXJlXG4gKi9cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBBYnN0cmFjdCBiYXNlIGNsYXNzOyBub3JtYWxseSBvbmx5IHVzZWQgZm9yIGNyZWF0aW5nIHN1YmNsYXNzZXMgYW5kIG5vdFxuICogaW5zdGFudGlhdGVkIGluIGFwcHMuXG4gKiBNb3N0IG5vbi10cml2aWFsIGNsYXNzZXMgaW5oZXJpdCBmcm9tIHRoaXMuXG4gKlxuICogVGhpcyBleHRlbmRzIHtAbGluayBtb2R1bGU6b2wvT2JzZXJ2YWJsZX5PYnNlcnZhYmxlfSB3aXRoIG9ic2VydmFibGVcbiAqIHByb3BlcnRpZXMsIHdoZXJlIGVhY2ggcHJvcGVydHkgaXMgb2JzZXJ2YWJsZSBhcyB3ZWxsIGFzIHRoZSBvYmplY3QgYXMgYVxuICogd2hvbGUuXG4gKlxuICogQ2xhc3NlcyB0aGF0IGluaGVyaXQgZnJvbSB0aGlzIGhhdmUgcHJlLWRlZmluZWQgcHJvcGVydGllcywgdG8gd2hpY2ggeW91IGNhblxuICogYWRkIHlvdXIgb3ducy4gVGhlIHByZS1kZWZpbmVkIHByb3BlcnRpZXMgYXJlIGxpc3RlZCBpbiB0aGlzIGRvY3VtZW50YXRpb24gYXNcbiAqICdPYnNlcnZhYmxlIFByb3BlcnRpZXMnLCBhbmQgaGF2ZSB0aGVpciBvd24gYWNjZXNzb3JzOyBmb3IgZXhhbXBsZSxcbiAqIHtAbGluayBtb2R1bGU6b2wvTWFwfk1hcH0gaGFzIGEgYHRhcmdldGAgcHJvcGVydHksIGFjY2Vzc2VkIHdpdGhcbiAqIGBnZXRUYXJnZXQoKWAgYW5kIGNoYW5nZWQgd2l0aCBgc2V0VGFyZ2V0KClgLiBOb3QgYWxsIHByb3BlcnRpZXMgYXJlIGhvd2V2ZXJcbiAqIHNldHRhYmxlLiBUaGVyZSBhcmUgYWxzbyBnZW5lcmFsLXB1cnBvc2UgYWNjZXNzb3JzIGBnZXQoKWAgYW5kIGBzZXQoKWAuIEZvclxuICogZXhhbXBsZSwgYGdldCgndGFyZ2V0JylgIGlzIGVxdWl2YWxlbnQgdG8gYGdldFRhcmdldCgpYC5cbiAqXG4gKiBUaGUgYHNldGAgYWNjZXNzb3JzIHRyaWdnZXIgYSBjaGFuZ2UgZXZlbnQsIGFuZCB5b3UgY2FuIG1vbml0b3IgdGhpcyBieVxuICogcmVnaXN0ZXJpbmcgYSBsaXN0ZW5lci4gRm9yIGV4YW1wbGUsIHtAbGluayBtb2R1bGU6b2wvVmlld35WaWV3fSBoYXMgYVxuICogYGNlbnRlcmAgcHJvcGVydHksIHNvIGB2aWV3Lm9uKCdjaGFuZ2U6Y2VudGVyJywgZnVuY3Rpb24oZXZ0KSB7Li4ufSk7YCB3b3VsZFxuICogY2FsbCB0aGUgZnVuY3Rpb24gd2hlbmV2ZXIgdGhlIHZhbHVlIG9mIHRoZSBjZW50ZXIgcHJvcGVydHkgY2hhbmdlcy4gV2l0aGluXG4gKiB0aGUgZnVuY3Rpb24sIGBldnQudGFyZ2V0YCB3b3VsZCBiZSB0aGUgdmlldywgc28gYGV2dC50YXJnZXQuZ2V0Q2VudGVyKClgXG4gKiB3b3VsZCByZXR1cm4gdGhlIG5ldyBjZW50ZXIuXG4gKlxuICogWW91IGNhbiBhZGQgeW91ciBvd24gb2JzZXJ2YWJsZSBwcm9wZXJ0aWVzIHdpdGhcbiAqIGBvYmplY3Quc2V0KCdwcm9wJywgJ3ZhbHVlJylgLCBhbmQgcmV0cmlldmUgdGhhdCB3aXRoIGBvYmplY3QuZ2V0KCdwcm9wJylgLlxuICogWW91IGNhbiBsaXN0ZW4gZm9yIGNoYW5nZXMgb24gdGhhdCBwcm9wZXJ0eSB2YWx1ZSB3aXRoXG4gKiBgb2JqZWN0Lm9uKCdjaGFuZ2U6cHJvcCcsIGxpc3RlbmVyKWAuIFlvdSBjYW4gZ2V0IGEgbGlzdCBvZiBhbGxcbiAqIHByb3BlcnRpZXMgd2l0aCB7QGxpbmsgbW9kdWxlOm9sL09iamVjdH5CYXNlT2JqZWN0I2dldFByb3BlcnRpZXN9LlxuICpcbiAqIE5vdGUgdGhhdCB0aGUgb2JzZXJ2YWJsZSBwcm9wZXJ0aWVzIGFyZSBzZXBhcmF0ZSBmcm9tIHN0YW5kYXJkIEpTIHByb3BlcnRpZXMuXG4gKiBZb3UgY2FuLCBmb3IgZXhhbXBsZSwgZ2l2ZSB5b3VyIG1hcCBvYmplY3QgYSB0aXRsZSB3aXRoXG4gKiBgbWFwLnRpdGxlPSdOZXcgdGl0bGUnYCBhbmQgd2l0aCBgbWFwLnNldCgndGl0bGUnLCAnQW5vdGhlciB0aXRsZScpYC4gVGhlXG4gKiBmaXJzdCB3aWxsIGJlIGEgYGhhc093blByb3BlcnR5YDsgdGhlIHNlY29uZCB3aWxsIGFwcGVhciBpblxuICogYGdldFByb3BlcnRpZXMoKWAuIE9ubHkgdGhlIHNlY29uZCBpcyBvYnNlcnZhYmxlLlxuICpcbiAqIFByb3BlcnRpZXMgY2FuIGJlIGRlbGV0ZWQgYnkgdXNpbmcgdGhlIHVuc2V0IG1ldGhvZC4gRS5nLlxuICogb2JqZWN0LnVuc2V0KCdmb28nKS5cbiAqXG4gKiBAZmlyZXMgT2JqZWN0RXZlbnRcbiAqIEBhcGlcbiAqL1xuY2xhc3MgQmFzZU9iamVjdCBleHRlbmRzIE9ic2VydmFibGUge1xuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLCAqPn0gW3ZhbHVlc10gQW4gb2JqZWN0IHdpdGgga2V5LXZhbHVlIHBhaXJzLlxuICAgKi9cbiAgY29uc3RydWN0b3IodmFsdWVzKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIC8qKipcbiAgICAgKiBAdHlwZSB7T2JqZWN0T25TaWduYXR1cmU8aW1wb3J0KFwiLi9ldmVudHNcIikuRXZlbnRzS2V5Pn1cbiAgICAgKi9cbiAgICB0aGlzLm9uO1xuXG4gICAgLyoqKlxuICAgICAqIEB0eXBlIHtPYmplY3RPblNpZ25hdHVyZTxpbXBvcnQoXCIuL2V2ZW50c1wiKS5FdmVudHNLZXk+fVxuICAgICAqL1xuICAgIHRoaXMub25jZTtcblxuICAgIC8qKipcbiAgICAgKiBAdHlwZSB7T2JqZWN0T25TaWduYXR1cmU8dm9pZD59XG4gICAgICovXG4gICAgdGhpcy51bjtcblxuICAgIC8vIENhbGwge0BsaW5rIG1vZHVsZTpvbC91dGlsLmdldFVpZH0gdG8gZW5zdXJlIHRoYXQgdGhlIG9yZGVyIG9mIG9iamVjdHMnIGlkcyBpc1xuICAgIC8vIHRoZSBzYW1lIGFzIHRoZSBvcmRlciBpbiB3aGljaCB0aGV5IHdlcmUgY3JlYXRlZC4gIFRoaXMgYWxzbyBoZWxwcyB0b1xuICAgIC8vIGVuc3VyZSB0aGF0IG9iamVjdCBwcm9wZXJ0aWVzIGFyZSBhbHdheXMgYWRkZWQgaW4gdGhlIHNhbWUgb3JkZXIsIHdoaWNoXG4gICAgLy8gaGVscHMgbWFueSBKYXZhU2NyaXB0IGVuZ2luZXMgZ2VuZXJhdGUgZmFzdGVyIGNvZGUuXG4gICAgZ2V0VWlkKHRoaXMpO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgKj59XG4gICAgICovXG4gICAgdGhpcy52YWx1ZXNfID0gbnVsbDtcblxuICAgIGlmICh2YWx1ZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5zZXRQcm9wZXJ0aWVzKHZhbHVlcyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgYSB2YWx1ZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBLZXkgbmFtZS5cbiAgICogQHJldHVybiB7Kn0gVmFsdWUuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldChrZXkpIHtcbiAgICBsZXQgdmFsdWU7XG4gICAgaWYgKHRoaXMudmFsdWVzXyAmJiB0aGlzLnZhbHVlc18uaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgdmFsdWUgPSB0aGlzLnZhbHVlc19ba2V5XTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhIGxpc3Qgb2Ygb2JqZWN0IHByb3BlcnR5IG5hbWVzLlxuICAgKiBAcmV0dXJuIHtBcnJheTxzdHJpbmc+fSBMaXN0IG9mIHByb3BlcnR5IG5hbWVzLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRLZXlzKCkge1xuICAgIHJldHVybiAodGhpcy52YWx1ZXNfICYmIE9iamVjdC5rZXlzKHRoaXMudmFsdWVzXykpIHx8IFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhbiBvYmplY3Qgb2YgYWxsIHByb3BlcnR5IG5hbWVzIGFuZCB2YWx1ZXMuXG4gICAqIEByZXR1cm4ge09iamVjdDxzdHJpbmcsICo+fSBPYmplY3QuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldFByb3BlcnRpZXMoKSB7XG4gICAgcmV0dXJuICh0aGlzLnZhbHVlc18gJiYgT2JqZWN0LmFzc2lnbih7fSwgdGhpcy52YWx1ZXNfKSkgfHwge307XG4gIH1cblxuICAvKipcbiAgICogR2V0IGFuIG9iamVjdCBvZiBhbGwgcHJvcGVydHkgbmFtZXMgYW5kIHZhbHVlcy5cbiAgICogQHJldHVybiB7T2JqZWN0PHN0cmluZywgKj4/fSBPYmplY3QuXG4gICAqL1xuICBnZXRQcm9wZXJ0aWVzSW50ZXJuYWwoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWVzXztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUaGUgb2JqZWN0IGhhcyBwcm9wZXJ0aWVzLlxuICAgKi9cbiAgaGFzUHJvcGVydGllcygpIHtcbiAgICByZXR1cm4gISF0aGlzLnZhbHVlc187XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBLZXkgbmFtZS5cbiAgICogQHBhcmFtIHsqfSBvbGRWYWx1ZSBPbGQgdmFsdWUuXG4gICAqL1xuICBub3RpZnkoa2V5LCBvbGRWYWx1ZSkge1xuICAgIGxldCBldmVudFR5cGU7XG4gICAgZXZlbnRUeXBlID0gYGNoYW5nZToke2tleX1gO1xuICAgIGlmICh0aGlzLmhhc0xpc3RlbmVyKGV2ZW50VHlwZSkpIHtcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgT2JqZWN0RXZlbnQoZXZlbnRUeXBlLCBrZXksIG9sZFZhbHVlKSk7XG4gICAgfVxuICAgIGV2ZW50VHlwZSA9IE9iamVjdEV2ZW50VHlwZS5QUk9QRVJUWUNIQU5HRTtcbiAgICBpZiAodGhpcy5oYXNMaXN0ZW5lcihldmVudFR5cGUpKSB7XG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IE9iamVjdEV2ZW50KGV2ZW50VHlwZSwga2V5LCBvbGRWYWx1ZSkpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IEtleSBuYW1lLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vZXZlbnRzLmpzXCIpLkxpc3RlbmVyfSBsaXN0ZW5lciBMaXN0ZW5lci5cbiAgICovXG4gIGFkZENoYW5nZUxpc3RlbmVyKGtleSwgbGlzdGVuZXIpIHtcbiAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoYGNoYW5nZToke2tleX1gLCBsaXN0ZW5lcik7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBLZXkgbmFtZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL2V2ZW50cy5qc1wiKS5MaXN0ZW5lcn0gbGlzdGVuZXIgTGlzdGVuZXIuXG4gICAqL1xuICByZW1vdmVDaGFuZ2VMaXN0ZW5lcihrZXksIGxpc3RlbmVyKSB7XG4gICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKGBjaGFuZ2U6JHtrZXl9YCwgbGlzdGVuZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgYSB2YWx1ZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBLZXkgbmFtZS5cbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZS5cbiAgICogQHBhcmFtIHtib29sZWFufSBbc2lsZW50XSBVcGRhdGUgd2l0aG91dCB0cmlnZ2VyaW5nIGFuIGV2ZW50LlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXQoa2V5LCB2YWx1ZSwgc2lsZW50KSB7XG4gICAgY29uc3QgdmFsdWVzID0gdGhpcy52YWx1ZXNfIHx8ICh0aGlzLnZhbHVlc18gPSB7fSk7XG4gICAgaWYgKHNpbGVudCkge1xuICAgICAgdmFsdWVzW2tleV0gPSB2YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgb2xkVmFsdWUgPSB2YWx1ZXNba2V5XTtcbiAgICAgIHZhbHVlc1trZXldID0gdmFsdWU7XG4gICAgICBpZiAob2xkVmFsdWUgIT09IHZhbHVlKSB7XG4gICAgICAgIHRoaXMubm90aWZ5KGtleSwgb2xkVmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIGEgY29sbGVjdGlvbiBvZiBrZXktdmFsdWUgcGFpcnMuICBOb3RlIHRoYXQgdGhpcyBjaGFuZ2VzIGFueSBleGlzdGluZ1xuICAgKiBwcm9wZXJ0aWVzIGFuZCBhZGRzIG5ldyBvbmVzIChpdCBkb2VzIG5vdCByZW1vdmUgYW55IGV4aXN0aW5nIHByb3BlcnRpZXMpLlxuICAgKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsICo+fSB2YWx1ZXMgVmFsdWVzLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtzaWxlbnRdIFVwZGF0ZSB3aXRob3V0IHRyaWdnZXJpbmcgYW4gZXZlbnQuXG4gICAqIEBhcGlcbiAgICovXG4gIHNldFByb3BlcnRpZXModmFsdWVzLCBzaWxlbnQpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiB2YWx1ZXMpIHtcbiAgICAgIHRoaXMuc2V0KGtleSwgdmFsdWVzW2tleV0sIHNpbGVudCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFwcGx5IGFueSBwcm9wZXJ0aWVzIGZyb20gYW5vdGhlciBvYmplY3Qgd2l0aG91dCB0cmlnZ2VyaW5nIGV2ZW50cy5cbiAgICogQHBhcmFtIHtCYXNlT2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIGFwcGx5UHJvcGVydGllcyhzb3VyY2UpIHtcbiAgICBpZiAoIXNvdXJjZS52YWx1ZXNfKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIE9iamVjdC5hc3NpZ24odGhpcy52YWx1ZXNfIHx8ICh0aGlzLnZhbHVlc18gPSB7fSksIHNvdXJjZS52YWx1ZXNfKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVbnNldHMgYSBwcm9wZXJ0eS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBLZXkgbmFtZS5cbiAgICogQHBhcmFtIHtib29sZWFufSBbc2lsZW50XSBVbnNldCB3aXRob3V0IHRyaWdnZXJpbmcgYW4gZXZlbnQuXG4gICAqIEBhcGlcbiAgICovXG4gIHVuc2V0KGtleSwgc2lsZW50KSB7XG4gICAgaWYgKHRoaXMudmFsdWVzXyAmJiBrZXkgaW4gdGhpcy52YWx1ZXNfKSB7XG4gICAgICBjb25zdCBvbGRWYWx1ZSA9IHRoaXMudmFsdWVzX1trZXldO1xuICAgICAgZGVsZXRlIHRoaXMudmFsdWVzX1trZXldO1xuICAgICAgaWYgKGlzRW1wdHkodGhpcy52YWx1ZXNfKSkge1xuICAgICAgICB0aGlzLnZhbHVlc18gPSBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKCFzaWxlbnQpIHtcbiAgICAgICAgdGhpcy5ub3RpZnkoa2V5LCBvbGRWYWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEJhc2VPYmplY3Q7XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvT2JqZWN0RXZlbnRUeXBlXG4gKi9cblxuLyoqXG4gKiBAZW51bSB7c3RyaW5nfVxuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gIC8qKlxuICAgKiBUcmlnZ2VyZWQgd2hlbiBhIHByb3BlcnR5IGlzIGNoYW5nZWQuXG4gICAqIEBldmVudCBtb2R1bGU6b2wvT2JqZWN0Lk9iamVjdEV2ZW50I3Byb3BlcnR5Y2hhbmdlXG4gICAqIEBhcGlcbiAgICovXG4gIFBST1BFUlRZQ0hBTkdFOiAncHJvcGVydHljaGFuZ2UnLFxufTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7J3Byb3BlcnR5Y2hhbmdlJ30gVHlwZXNcbiAqL1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL09ic2VydmFibGVcbiAqL1xuaW1wb3J0IEV2ZW50VGFyZ2V0IGZyb20gJy4vZXZlbnRzL1RhcmdldC5qcyc7XG5pbXBvcnQgRXZlbnRUeXBlIGZyb20gJy4vZXZlbnRzL0V2ZW50VHlwZS5qcyc7XG5pbXBvcnQge2xpc3RlbiwgbGlzdGVuT25jZSwgdW5saXN0ZW5CeUtleX0gZnJvbSAnLi9ldmVudHMuanMnO1xuXG4vKioqXG4gKiBAdGVtcGxhdGUge3N0cmluZ30gVHlwZVxuICogQHRlbXBsYXRlIHtFdmVudHxpbXBvcnQoXCIuL2V2ZW50cy9FdmVudC5qc1wiKS5kZWZhdWx0fSBFdmVudENsYXNzXG4gKiBAdGVtcGxhdGUgUmV0dXJuXG4gKiBAdHlwZWRlZiB7KHR5cGU6IFR5cGUsIGxpc3RlbmVyOiAoZXZlbnQ6IEV2ZW50Q2xhc3MpID0+ID8pID0+IFJldHVybn0gT25TaWduYXR1cmVcbiAqL1xuXG4vKioqXG4gKiBAdGVtcGxhdGUge3N0cmluZ30gVHlwZVxuICogQHRlbXBsYXRlIFJldHVyblxuICogQHR5cGVkZWYgeyh0eXBlOiBUeXBlW10sIGxpc3RlbmVyOiAoZXZlbnQ6IEV2ZW50fGltcG9ydChcIi4vZXZlbnRzL0V2ZW50XCIpLmRlZmF1bHQpID0+ID8pID0+IFJldHVybiBleHRlbmRzIHZvaWQgPyB2b2lkIDogUmV0dXJuW119IENvbWJpbmVkT25TaWduYXR1cmVcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHsnY2hhbmdlJ3wnZXJyb3InfSBFdmVudFR5cGVzXG4gKi9cblxuLyoqKlxuICogQHRlbXBsYXRlIFJldHVyblxuICogQHR5cGVkZWYge09uU2lnbmF0dXJlPEV2ZW50VHlwZXMsIGltcG9ydChcIi4vZXZlbnRzL0V2ZW50LmpzXCIpLmRlZmF1bHQsIFJldHVybj4gJiBDb21iaW5lZE9uU2lnbmF0dXJlPEV2ZW50VHlwZXMsIFJldHVybj59IE9ic2VydmFibGVPblNpZ25hdHVyZVxuICovXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQWJzdHJhY3QgYmFzZSBjbGFzczsgbm9ybWFsbHkgb25seSB1c2VkIGZvciBjcmVhdGluZyBzdWJjbGFzc2VzIGFuZCBub3RcbiAqIGluc3RhbnRpYXRlZCBpbiBhcHBzLlxuICogQW4gZXZlbnQgdGFyZ2V0IHByb3ZpZGluZyBjb252ZW5pZW50IG1ldGhvZHMgZm9yIGxpc3RlbmVyIHJlZ2lzdHJhdGlvblxuICogYW5kIHVucmVnaXN0cmF0aW9uLiBBIGdlbmVyaWMgYGNoYW5nZWAgZXZlbnQgaXMgYWx3YXlzIGF2YWlsYWJsZSB0aHJvdWdoXG4gKiB7QGxpbmsgbW9kdWxlOm9sL09ic2VydmFibGV+T2JzZXJ2YWJsZSNjaGFuZ2VkfS5cbiAqXG4gKiBAZmlyZXMgaW1wb3J0KFwiLi9ldmVudHMvRXZlbnQuanNcIikuZGVmYXVsdFxuICogQGFwaVxuICovXG5jbGFzcyBPYnNlcnZhYmxlIGV4dGVuZHMgRXZlbnRUYXJnZXQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5vbiA9XG4gICAgICAvKiogQHR5cGUge09ic2VydmFibGVPblNpZ25hdHVyZTxpbXBvcnQoXCIuL2V2ZW50c1wiKS5FdmVudHNLZXk+fSAqLyAoXG4gICAgICAgIHRoaXMub25JbnRlcm5hbFxuICAgICAgKTtcblxuICAgIHRoaXMub25jZSA9XG4gICAgICAvKiogQHR5cGUge09ic2VydmFibGVPblNpZ25hdHVyZTxpbXBvcnQoXCIuL2V2ZW50c1wiKS5FdmVudHNLZXk+fSAqLyAoXG4gICAgICAgIHRoaXMub25jZUludGVybmFsXG4gICAgICApO1xuXG4gICAgdGhpcy51biA9IC8qKiBAdHlwZSB7T2JzZXJ2YWJsZU9uU2lnbmF0dXJlPHZvaWQ+fSAqLyAodGhpcy51bkludGVybmFsKTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnJldmlzaW9uXyA9IDA7XG4gIH1cblxuICAvKipcbiAgICogSW5jcmVhc2VzIHRoZSByZXZpc2lvbiBjb3VudGVyIGFuZCBkaXNwYXRjaGVzIGEgJ2NoYW5nZScgZXZlbnQuXG4gICAqIEBhcGlcbiAgICovXG4gIGNoYW5nZWQoKSB7XG4gICAgKyt0aGlzLnJldmlzaW9uXztcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoRXZlbnRUeXBlLkNIQU5HRSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB2ZXJzaW9uIG51bWJlciBmb3IgdGhpcyBvYmplY3QuICBFYWNoIHRpbWUgdGhlIG9iamVjdCBpcyBtb2RpZmllZCxcbiAgICogaXRzIHZlcnNpb24gbnVtYmVyIHdpbGwgYmUgaW5jcmVtZW50ZWQuXG4gICAqIEByZXR1cm4ge251bWJlcn0gUmV2aXNpb24uXG4gICAqIEBhcGlcbiAgICovXG4gIGdldFJldmlzaW9uKCkge1xuICAgIHJldHVybiB0aGlzLnJldmlzaW9uXztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ3xBcnJheTxzdHJpbmc+fSB0eXBlIFR5cGUuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oKEV2ZW50fGltcG9ydChcIi4vZXZlbnRzL0V2ZW50XCIpLmRlZmF1bHQpKTogP30gbGlzdGVuZXIgTGlzdGVuZXIuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4vZXZlbnRzLmpzXCIpLkV2ZW50c0tleXxBcnJheTxpbXBvcnQoXCIuL2V2ZW50cy5qc1wiKS5FdmVudHNLZXk+fSBFdmVudCBrZXkuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIG9uSW50ZXJuYWwodHlwZSwgbGlzdGVuZXIpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh0eXBlKSkge1xuICAgICAgY29uc3QgbGVuID0gdHlwZS5sZW5ndGg7XG4gICAgICBjb25zdCBrZXlzID0gbmV3IEFycmF5KGxlbik7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIGtleXNbaV0gPSBsaXN0ZW4odGhpcywgdHlwZVtpXSwgbGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGtleXM7XG4gICAgfVxuICAgIHJldHVybiBsaXN0ZW4odGhpcywgLyoqIEB0eXBlIHtzdHJpbmd9ICovICh0eXBlKSwgbGlzdGVuZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfEFycmF5PHN0cmluZz59IHR5cGUgVHlwZS5cbiAgICogQHBhcmFtIHtmdW5jdGlvbigoRXZlbnR8aW1wb3J0KFwiLi9ldmVudHMvRXZlbnRcIikuZGVmYXVsdCkpOiA/fSBsaXN0ZW5lciBMaXN0ZW5lci5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi9ldmVudHMuanNcIikuRXZlbnRzS2V5fEFycmF5PGltcG9ydChcIi4vZXZlbnRzLmpzXCIpLkV2ZW50c0tleT59IEV2ZW50IGtleS5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgb25jZUludGVybmFsKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgbGV0IGtleTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh0eXBlKSkge1xuICAgICAgY29uc3QgbGVuID0gdHlwZS5sZW5ndGg7XG4gICAgICBrZXkgPSBuZXcgQXJyYXkobGVuKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAga2V5W2ldID0gbGlzdGVuT25jZSh0aGlzLCB0eXBlW2ldLCBsaXN0ZW5lcik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGtleSA9IGxpc3Rlbk9uY2UodGhpcywgLyoqIEB0eXBlIHtzdHJpbmd9ICovICh0eXBlKSwgbGlzdGVuZXIpO1xuICAgIH1cbiAgICAvKiogQHR5cGUge09iamVjdH0gKi8gKGxpc3RlbmVyKS5vbF9rZXkgPSBrZXk7XG4gICAgcmV0dXJuIGtleTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVbmxpc3RlbiBmb3IgYSBjZXJ0YWluIHR5cGUgb2YgZXZlbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfEFycmF5PHN0cmluZz59IHR5cGUgVHlwZS5cbiAgICogQHBhcmFtIHtmdW5jdGlvbigoRXZlbnR8aW1wb3J0KFwiLi9ldmVudHMvRXZlbnRcIikuZGVmYXVsdCkpOiA/fSBsaXN0ZW5lciBMaXN0ZW5lci5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgdW5JbnRlcm5hbCh0eXBlLCBsaXN0ZW5lcikge1xuICAgIGNvbnN0IGtleSA9IC8qKiBAdHlwZSB7T2JqZWN0fSAqLyAobGlzdGVuZXIpLm9sX2tleTtcbiAgICBpZiAoa2V5KSB7XG4gICAgICB1bkJ5S2V5KGtleSk7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHR5cGUpKSB7XG4gICAgICBmb3IgKGxldCBpID0gMCwgaWkgPSB0eXBlLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGVbaV0sIGxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBMaXN0ZW4gZm9yIGEgY2VydGFpbiB0eXBlIG9mIGV2ZW50LlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ3xBcnJheTxzdHJpbmc+fSB0eXBlIFRoZSBldmVudCB0eXBlIG9yIGFycmF5IG9mIGV2ZW50IHR5cGVzLlxuICogQHBhcmFtIHtmdW5jdGlvbigoRXZlbnR8aW1wb3J0KFwiLi9ldmVudHMvRXZlbnRcIikuZGVmYXVsdCkpOiA/fSBsaXN0ZW5lciBUaGUgbGlzdGVuZXIgZnVuY3Rpb24uXG4gKiBAcmV0dXJuIHtpbXBvcnQoXCIuL2V2ZW50cy5qc1wiKS5FdmVudHNLZXl8QXJyYXk8aW1wb3J0KFwiLi9ldmVudHMuanNcIikuRXZlbnRzS2V5Pn0gVW5pcXVlIGtleSBmb3IgdGhlIGxpc3RlbmVyLiBJZlxuICogICAgIGNhbGxlZCB3aXRoIGFuIGFycmF5IG9mIGV2ZW50IHR5cGVzIGFzIHRoZSBmaXJzdCBhcmd1bWVudCwgdGhlIHJldHVyblxuICogICAgIHdpbGwgYmUgYW4gYXJyYXkgb2Yga2V5cy5cbiAqIEBhcGlcbiAqL1xuT2JzZXJ2YWJsZS5wcm90b3R5cGUub247XG5cbi8qKlxuICogTGlzdGVuIG9uY2UgZm9yIGEgY2VydGFpbiB0eXBlIG9mIGV2ZW50LlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ3xBcnJheTxzdHJpbmc+fSB0eXBlIFRoZSBldmVudCB0eXBlIG9yIGFycmF5IG9mIGV2ZW50IHR5cGVzLlxuICogQHBhcmFtIHtmdW5jdGlvbigoRXZlbnR8aW1wb3J0KFwiLi9ldmVudHMvRXZlbnRcIikuZGVmYXVsdCkpOiA/fSBsaXN0ZW5lciBUaGUgbGlzdGVuZXIgZnVuY3Rpb24uXG4gKiBAcmV0dXJuIHtpbXBvcnQoXCIuL2V2ZW50cy5qc1wiKS5FdmVudHNLZXl8QXJyYXk8aW1wb3J0KFwiLi9ldmVudHMuanNcIikuRXZlbnRzS2V5Pn0gVW5pcXVlIGtleSBmb3IgdGhlIGxpc3RlbmVyLiBJZlxuICogICAgIGNhbGxlZCB3aXRoIGFuIGFycmF5IG9mIGV2ZW50IHR5cGVzIGFzIHRoZSBmaXJzdCBhcmd1bWVudCwgdGhlIHJldHVyblxuICogICAgIHdpbGwgYmUgYW4gYXJyYXkgb2Yga2V5cy5cbiAqIEBhcGlcbiAqL1xuT2JzZXJ2YWJsZS5wcm90b3R5cGUub25jZTtcblxuLyoqXG4gKiBVbmxpc3RlbiBmb3IgYSBjZXJ0YWluIHR5cGUgb2YgZXZlbnQuXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7c3RyaW5nfEFycmF5PHN0cmluZz59IHR5cGUgVGhlIGV2ZW50IHR5cGUgb3IgYXJyYXkgb2YgZXZlbnQgdHlwZXMuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKChFdmVudHxpbXBvcnQoXCIuL2V2ZW50cy9FdmVudFwiKS5kZWZhdWx0KSk6ID99IGxpc3RlbmVyIFRoZSBsaXN0ZW5lciBmdW5jdGlvbi5cbiAqIEBhcGlcbiAqL1xuT2JzZXJ2YWJsZS5wcm90b3R5cGUudW47XG5cbi8qKlxuICogUmVtb3ZlcyBhbiBldmVudCBsaXN0ZW5lciB1c2luZyB0aGUga2V5IHJldHVybmVkIGJ5IGBvbigpYCBvciBgb25jZSgpYC5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9ldmVudHMuanNcIikuRXZlbnRzS2V5fEFycmF5PGltcG9ydChcIi4vZXZlbnRzLmpzXCIpLkV2ZW50c0tleT59IGtleSBUaGUga2V5IHJldHVybmVkIGJ5IGBvbigpYFxuICogICAgIG9yIGBvbmNlKClgIChvciBhbiBhcnJheSBvZiBrZXlzKS5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVuQnlLZXkoa2V5KSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGtleSkpIHtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBrZXkubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgdW5saXN0ZW5CeUtleShrZXlbaV0pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB1bmxpc3RlbkJ5S2V5KC8qKiBAdHlwZSB7aW1wb3J0KFwiLi9ldmVudHMuanNcIikuRXZlbnRzS2V5fSAqLyAoa2V5KSk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgT2JzZXJ2YWJsZTtcbiIsIi8qKlxuICogQG1vZHVsZSBvbC9UaWxlXG4gKi9cbmltcG9ydCBFdmVudFRhcmdldCBmcm9tICcuL2V2ZW50cy9UYXJnZXQuanMnO1xuaW1wb3J0IEV2ZW50VHlwZSBmcm9tICcuL2V2ZW50cy9FdmVudFR5cGUuanMnO1xuaW1wb3J0IFRpbGVTdGF0ZSBmcm9tICcuL1RpbGVTdGF0ZS5qcyc7XG5pbXBvcnQge2Fic3RyYWN0fSBmcm9tICcuL3V0aWwuanMnO1xuaW1wb3J0IHtlYXNlSW59IGZyb20gJy4vZWFzaW5nLmpzJztcblxuLyoqXG4gKiBBIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYW4ge0BsaW5rIG1vZHVsZTpvbC9UaWxlflRpbGV9IGZvciB0aGUgdGlsZSBhbmQgYVxuICogYHtzdHJpbmd9YCBmb3IgdGhlIHVybCBhcyBhcmd1bWVudHMuIFRoZSBkZWZhdWx0IGlzXG4gKiBgYGBqc1xuICogc291cmNlLnNldFRpbGVMb2FkRnVuY3Rpb24oZnVuY3Rpb24odGlsZSwgc3JjKSB7XG4gKiAgIHRpbGUuZ2V0SW1hZ2UoKS5zcmMgPSBzcmM7XG4gKiB9KTtcbiAqIGBgYFxuICogRm9yIG1vcmUgZmluZSBncmFpbmVkIGNvbnRyb2wsIHRoZSBsb2FkIGZ1bmN0aW9uIGNhbiB1c2UgZmV0Y2ggb3IgWE1MSHR0cFJlcXVlc3QgYW5kIGludm9sdmVcbiAqIGVycm9yIGhhbmRsaW5nOlxuICpcbiAqIGBgYGpzXG4gKiBpbXBvcnQgVGlsZVN0YXRlIGZyb20gJ29sL1RpbGVTdGF0ZS5qcyc7XG4gKlxuICogc291cmNlLnNldFRpbGVMb2FkRnVuY3Rpb24oZnVuY3Rpb24odGlsZSwgc3JjKSB7XG4gKiAgIGNvbnN0IHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICogICB4aHIucmVzcG9uc2VUeXBlID0gJ2Jsb2InO1xuICogICB4aHIuYWRkRXZlbnRMaXN0ZW5lcignbG9hZGVuZCcsIGZ1bmN0aW9uIChldnQpIHtcbiAqICAgICBjb25zdCBkYXRhID0gdGhpcy5yZXNwb25zZTtcbiAqICAgICBpZiAoZGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gKiAgICAgICB0aWxlLmdldEltYWdlKCkuc3JjID0gVVJMLmNyZWF0ZU9iamVjdFVSTChkYXRhKTtcbiAqICAgICB9IGVsc2Uge1xuICogICAgICAgdGlsZS5zZXRTdGF0ZShUaWxlU3RhdGUuRVJST1IpO1xuICogICAgIH1cbiAqICAgfSk7XG4gKiAgIHhoci5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIGZ1bmN0aW9uICgpIHtcbiAqICAgICB0aWxlLnNldFN0YXRlKFRpbGVTdGF0ZS5FUlJPUik7XG4gKiAgIH0pO1xuICogICB4aHIub3BlbignR0VUJywgc3JjKTtcbiAqICAgeGhyLnNlbmQoKTtcbiAqIH0pO1xuICogYGBgXG4gKlxuICogQHR5cGVkZWYge2Z1bmN0aW9uKFRpbGUsIHN0cmluZyk6IHZvaWR9IExvYWRGdW5jdGlvblxuICogQGFwaVxuICovXG5cbi8qKlxuICoge0BsaW5rIG1vZHVsZTpvbC9zb3VyY2UvVGlsZX5UaWxlU291cmNlfSBzb3VyY2VzIHVzZSBhIGZ1bmN0aW9uIG9mIHRoaXMgdHlwZSB0byBnZXRcbiAqIHRoZSB1cmwgdGhhdCBwcm92aWRlcyBhIHRpbGUgZm9yIGEgZ2l2ZW4gdGlsZSBjb29yZGluYXRlLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gdGFrZXMgYW4ge0BsaW5rIG1vZHVsZTpvbC90aWxlY29vcmR+VGlsZUNvb3JkfSBmb3IgdGhlIHRpbGVcbiAqIGNvb3JkaW5hdGUsIGEgYHtudW1iZXJ9YCByZXByZXNlbnRpbmcgdGhlIHBpeGVsIHJhdGlvIGFuZCBhXG4gKiB7QGxpbmsgbW9kdWxlOm9sL3Byb2ovUHJvamVjdGlvbn5Qcm9qZWN0aW9ufSBmb3IgdGhlIHByb2plY3Rpb24gIGFzIGFyZ3VtZW50c1xuICogYW5kIHJldHVybnMgYSBge3N0cmluZ31gIHJlcHJlc2VudGluZyB0aGUgdGlsZSBVUkwsIG9yIHVuZGVmaW5lZCBpZiBubyB0aWxlXG4gKiBzaG91bGQgYmUgcmVxdWVzdGVkIGZvciB0aGUgcGFzc2VkIHRpbGUgY29vcmRpbmF0ZS5cbiAqXG4gKiBAdHlwZWRlZiB7ZnVuY3Rpb24oaW1wb3J0KFwiLi90aWxlY29vcmQuanNcIikuVGlsZUNvb3JkLCBudW1iZXIsXG4gKiAgICAgICAgICAgaW1wb3J0KFwiLi9wcm9qL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdCk6IChzdHJpbmd8dW5kZWZpbmVkKX0gVXJsRnVuY3Rpb25cbiAqIEBhcGlcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbdHJhbnNpdGlvbj0yNTBdIEEgZHVyYXRpb24gZm9yIHRpbGUgb3BhY2l0eVxuICogdHJhbnNpdGlvbnMgaW4gbWlsbGlzZWNvbmRzLiBBIGR1cmF0aW9uIG9mIDAgZGlzYWJsZXMgdGhlIG9wYWNpdHkgdHJhbnNpdGlvbi5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2ludGVycG9sYXRlPWZhbHNlXSBVc2UgaW50ZXJwb2xhdGVkIHZhbHVlcyB3aGVuIHJlc2FtcGxpbmcuICBCeSBkZWZhdWx0LFxuICogdGhlIG5lYXJlc3QgbmVpZ2hib3IgaXMgdXNlZCB3aGVuIHJlc2FtcGxpbmcuXG4gKiBAYXBpXG4gKi9cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBCYXNlIGNsYXNzIGZvciB0aWxlcy5cbiAqXG4gKiBAYWJzdHJhY3RcbiAqL1xuY2xhc3MgVGlsZSBleHRlbmRzIEV2ZW50VGFyZ2V0IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi90aWxlY29vcmQuanNcIikuVGlsZUNvb3JkfSB0aWxlQ29vcmQgVGlsZSBjb29yZGluYXRlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vVGlsZVN0YXRlLmpzXCIpLmRlZmF1bHR9IHN0YXRlIFN0YXRlLlxuICAgKiBAcGFyYW0ge09wdGlvbnN9IFtvcHRpb25zXSBUaWxlIG9wdGlvbnMuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih0aWxlQ29vcmQsIHN0YXRlLCBvcHRpb25zKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIG9wdGlvbnMgPSBvcHRpb25zID8gb3B0aW9ucyA6IHt9O1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4vdGlsZWNvb3JkLmpzXCIpLlRpbGVDb29yZH1cbiAgICAgKi9cbiAgICB0aGlzLnRpbGVDb29yZCA9IHRpbGVDb29yZDtcblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi9UaWxlU3RhdGUuanNcIikuZGVmYXVsdH1cbiAgICAgKi9cbiAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG5cbiAgICAvKipcbiAgICAgKiBBbiBcImludGVyaW1cIiB0aWxlIGZvciB0aGlzIHRpbGUuIFRoZSBpbnRlcmltIHRpbGUgbWF5IGJlIHVzZWQgd2hpbGUgdGhpc1xuICAgICAqIG9uZSBpcyBsb2FkaW5nLCBmb3IgXCJzbW9vdGhcIiB0cmFuc2l0aW9ucyB3aGVuIGNoYW5naW5nIHBhcmFtcy9kaW1lbnNpb25zXG4gICAgICogb24gdGhlIHNvdXJjZS5cbiAgICAgKiBAdHlwZSB7VGlsZX1cbiAgICAgKi9cbiAgICB0aGlzLmludGVyaW1UaWxlID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEEga2V5IGFzc2lnbmVkIHRvIHRoZSB0aWxlLiBUaGlzIGlzIHVzZWQgYnkgdGhlIHRpbGUgc291cmNlIHRvIGRldGVybWluZVxuICAgICAqIGlmIHRoaXMgdGlsZSBjYW4gZWZmZWN0aXZlbHkgYmUgdXNlZCwgb3IgaWYgYSBuZXcgdGlsZSBzaG91bGQgYmUgY3JlYXRlZFxuICAgICAqIGFuZCB0aGlzIG9uZSBiZSB1c2VkIGFzIGFuIGludGVyaW0gdGlsZSBmb3IgdGhpcyBuZXcgdGlsZS5cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMua2V5ID0gJyc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZHVyYXRpb24gZm9yIHRoZSBvcGFjaXR5IHRyYW5zaXRpb24uXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnRyYW5zaXRpb25fID1cbiAgICAgIG9wdGlvbnMudHJhbnNpdGlvbiA9PT0gdW5kZWZpbmVkID8gMjUwIDogb3B0aW9ucy50cmFuc2l0aW9uO1xuXG4gICAgLyoqXG4gICAgICogTG9va3VwIG9mIHN0YXJ0IHRpbWVzIGZvciByZW5kZXJpbmcgdHJhbnNpdGlvbnMuICBJZiB0aGUgc3RhcnQgdGltZSBpc1xuICAgICAqIGVxdWFsIHRvIC0xLCB0aGUgdHJhbnNpdGlvbiBpcyBjb21wbGV0ZS5cbiAgICAgKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgbnVtYmVyPn1cbiAgICAgKi9cbiAgICB0aGlzLnRyYW5zaXRpb25TdGFydHNfID0ge307XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmludGVycG9sYXRlID0gISFvcHRpb25zLmludGVycG9sYXRlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIGNoYW5nZWQoKSB7XG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KEV2ZW50VHlwZS5DSEFOR0UpO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGxlZCBieSB0aGUgdGlsZSBjYWNoZSB3aGVuIHRoZSB0aWxlIGlzIHJlbW92ZWQgZnJvbSB0aGUgY2FjaGUgZHVlIHRvIGV4cGlyeVxuICAgKi9cbiAgcmVsZWFzZSgpIHtcbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gVGlsZVN0YXRlLkVSUk9SKSB7XG4gICAgICAvLyB0byByZW1vdmUgdGhlIGBjaGFuZ2VgIGxpc3RlbmVyIG9uIHRoaXMgdGlsZSBpbiBgb2wvVGlsZVF1ZXVlI2hhbmRsZVRpbGVDaGFuZ2VgXG4gICAgICB0aGlzLnNldFN0YXRlKFRpbGVTdGF0ZS5FTVBUWSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge3N0cmluZ30gS2V5LlxuICAgKi9cbiAgZ2V0S2V5KCkge1xuICAgIHJldHVybiB0aGlzLmtleSArICcvJyArIHRoaXMudGlsZUNvb3JkO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgaW50ZXJpbSB0aWxlIG1vc3Qgc3VpdGFibGUgZm9yIHJlbmRlcmluZyB1c2luZyB0aGUgY2hhaW4gb2YgaW50ZXJpbVxuICAgKiB0aWxlcy4gVGhpcyBjb3JyZXNwb25kcyB0byB0aGUgIG1vc3QgcmVjZW50IHRpbGUgdGhhdCBoYXMgYmVlbiBsb2FkZWQsIGlmIG5vXG4gICAqIHN1Y2ggdGlsZSBleGlzdHMsIHRoZSBvcmlnaW5hbCB0aWxlIGlzIHJldHVybmVkLlxuICAgKiBAcmV0dXJuIHshVGlsZX0gQmVzdCB0aWxlIGZvciByZW5kZXJpbmcuXG4gICAqL1xuICBnZXRJbnRlcmltVGlsZSgpIHtcbiAgICBpZiAoIXRoaXMuaW50ZXJpbVRpbGUpIHtcbiAgICAgIC8vZW1wdHkgY2hhaW5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBsZXQgdGlsZSA9IHRoaXMuaW50ZXJpbVRpbGU7XG5cbiAgICAvLyBmaW5kIHRoZSBmaXJzdCBsb2FkZWQgdGlsZSBhbmQgcmV0dXJuIGl0LiBTaW5jZSB0aGUgY2hhaW4gaXMgc29ydGVkIGluXG4gICAgLy8gZGVjcmVhc2luZyBvcmRlciBvZiBjcmVhdGlvbiB0aW1lLCB0aGVyZSBpcyBubyBuZWVkIHRvIHNlYXJjaCB0aGUgcmVtYWluZGVyXG4gICAgLy8gb2YgdGhlIGxpc3QgKGFsbCB0aG9zZSB0aWxlcyBjb3JyZXNwb25kIHRvIG9sZGVyIHJlcXVlc3RzIGFuZCB3aWxsIGJlXG4gICAgLy8gY2xlYW5lZCB1cCBieSByZWZyZXNoSW50ZXJpbUNoYWluKVxuICAgIGRvIHtcbiAgICAgIGlmICh0aWxlLmdldFN0YXRlKCkgPT0gVGlsZVN0YXRlLkxPQURFRCkge1xuICAgICAgICAvLyBTaG93IHRpbGUgaW1tZWRpYXRlbHkgaW5zdGVhZCBvZiBmYWRpbmcgaXQgaW4gYWZ0ZXIgbG9hZGluZywgYmVjYXVzZVxuICAgICAgICAvLyB0aGUgaW50ZXJpbSB0aWxlIGlzIGluIHBsYWNlIGFscmVhZHlcbiAgICAgICAgdGhpcy50cmFuc2l0aW9uXyA9IDA7XG4gICAgICAgIHJldHVybiB0aWxlO1xuICAgICAgfVxuICAgICAgdGlsZSA9IHRpbGUuaW50ZXJpbVRpbGU7XG4gICAgfSB3aGlsZSAodGlsZSk7XG5cbiAgICAvLyB3ZSBjYW4gbm90IGZpbmQgYSBiZXR0ZXIgdGlsZVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEdvZXMgdGhyb3VnaCB0aGUgY2hhaW4gb2YgaW50ZXJpbSB0aWxlcyBhbmQgZGlzY2FyZHMgc2VjdGlvbnMgb2YgdGhlIGNoYWluXG4gICAqIHRoYXQgYXJlIG5vIGxvbmdlciByZWxldmFudC5cbiAgICovXG4gIHJlZnJlc2hJbnRlcmltQ2hhaW4oKSB7XG4gICAgaWYgKCF0aGlzLmludGVyaW1UaWxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGV0IHRpbGUgPSB0aGlzLmludGVyaW1UaWxlO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge1RpbGV9XG4gICAgICovXG4gICAgbGV0IHByZXYgPSB0aGlzO1xuXG4gICAgZG8ge1xuICAgICAgaWYgKHRpbGUuZ2V0U3RhdGUoKSA9PSBUaWxlU3RhdGUuTE9BREVEKSB7XG4gICAgICAgIC8vd2UgaGF2ZSBhIGxvYWRlZCB0aWxlLCB3ZSBjYW4gZGlzY2FyZCB0aGUgcmVzdCBvZiB0aGUgbGlzdFxuICAgICAgICAvL3dlIHdvdWxkIGNvdWxkIGFib3J0IGFueSBMT0FESU5HIHRpbGUgcmVxdWVzdFxuICAgICAgICAvL29sZGVyIHRoYW4gdGhpcyB0aWxlIChpLmUuIGFueSBMT0FESU5HIHRpbGUgZm9sbG93aW5nIHRoaXMgZW50cnkgaW4gdGhlIGNoYWluKVxuICAgICAgICB0aWxlLmludGVyaW1UaWxlID0gbnVsbDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGVsc2UgaWYgKHRpbGUuZ2V0U3RhdGUoKSA9PSBUaWxlU3RhdGUuTE9BRElORykge1xuICAgICAgICAvL2tlZXAgdGhpcyBMT0FESU5HIHRpbGUgYW55IGxvYWRlZCB0aWxlcyBsYXRlciBpbiB0aGUgY2hhaW4gYXJlXG4gICAgICAgIC8vb2xkZXIgdGhhbiB0aGlzIHRpbGUsIHNvIHdlJ3JlIHN0aWxsIGludGVyZXN0ZWQgaW4gdGhlIHJlcXVlc3RcbiAgICAgICAgcHJldiA9IHRpbGU7XG4gICAgICB9IGVsc2UgaWYgKHRpbGUuZ2V0U3RhdGUoKSA9PSBUaWxlU3RhdGUuSURMRSkge1xuICAgICAgICAvL3RoZSBoZWFkIG9mIHRoZSBsaXN0IGlzIHRoZSBtb3N0IGN1cnJlbnQgdGlsZSwgd2UgZG9uJ3QgbmVlZFxuICAgICAgICAvL3RvIHN0YXJ0IGFueSBvdGhlciByZXF1ZXN0cyBmb3IgdGhpcyBjaGFpblxuICAgICAgICBwcmV2LmludGVyaW1UaWxlID0gdGlsZS5pbnRlcmltVGlsZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByZXYgPSB0aWxlO1xuICAgICAgfVxuICAgICAgdGlsZSA9IHByZXYuaW50ZXJpbVRpbGU7XG4gICAgfSB3aGlsZSAodGlsZSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB0aWxlIGNvb3JkaW5hdGUgZm9yIHRoaXMgdGlsZS5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi90aWxlY29vcmQuanNcIikuVGlsZUNvb3JkfSBUaGUgdGlsZSBjb29yZGluYXRlLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRUaWxlQ29vcmQoKSB7XG4gICAgcmV0dXJuIHRoaXMudGlsZUNvb3JkO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4vVGlsZVN0YXRlLmpzXCIpLmRlZmF1bHR9IFN0YXRlLlxuICAgKi9cbiAgZ2V0U3RhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGU7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgc3RhdGUgb2YgdGhpcyB0aWxlLiBJZiB5b3Ugd3JpdGUgeW91ciBvd24ge0BsaW5rIG1vZHVsZTpvbC9UaWxlfkxvYWRGdW5jdGlvbiB0aWxlTG9hZEZ1bmN0aW9ufSAsXG4gICAqIGl0IGlzIGltcG9ydGFudCB0byBzZXQgdGhlIHN0YXRlIGNvcnJlY3RseSB0byB7QGxpbmsgbW9kdWxlOm9sL1RpbGVTdGF0ZX5FUlJPUn1cbiAgICogd2hlbiB0aGUgdGlsZSBjYW5ub3QgYmUgbG9hZGVkLiBPdGhlcndpc2UgdGhlIHRpbGUgY2Fubm90IGJlIHJlbW92ZWQgZnJvbVxuICAgKiB0aGUgdGlsZSBxdWV1ZSBhbmQgd2lsbCBibG9jayBvdGhlciByZXF1ZXN0cy5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL1RpbGVTdGF0ZS5qc1wiKS5kZWZhdWx0fSBzdGF0ZSBTdGF0ZS5cbiAgICogQGFwaVxuICAgKi9cbiAgc2V0U3RhdGUoc3RhdGUpIHtcbiAgICBpZiAodGhpcy5zdGF0ZSAhPT0gVGlsZVN0YXRlLkVSUk9SICYmIHRoaXMuc3RhdGUgPiBzdGF0ZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaWxlIGxvYWQgc2VxdWVuY2UgdmlvbGF0aW9uJyk7XG4gICAgfVxuICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICB0aGlzLmNoYW5nZWQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2FkIHRoZSBpbWFnZSBvciByZXRyeSBpZiBsb2FkaW5nIHByZXZpb3VzbHkgZmFpbGVkLlxuICAgKiBMb2FkaW5nIGlzIHRha2VuIGNhcmUgb2YgYnkgdGhlIHRpbGUgcXVldWUsIGFuZCBjYWxsaW5nIHRoaXMgbWV0aG9kIGlzXG4gICAqIG9ubHkgbmVlZGVkIGZvciBwcmVsb2FkaW5nIG9yIGZvciByZWxvYWRpbmcgaW4gY2FzZSBvZiBhbiBlcnJvci5cbiAgICogQGFic3RyYWN0XG4gICAqIEBhcGlcbiAgICovXG4gIGxvYWQoKSB7XG4gICAgYWJzdHJhY3QoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGFscGhhIHZhbHVlIGZvciByZW5kZXJpbmcuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBBbiBpZCBmb3IgdGhlIHJlbmRlcmVyLlxuICAgKiBAcGFyYW0ge251bWJlcn0gdGltZSBUaGUgcmVuZGVyIGZyYW1lIHRpbWUuXG4gICAqIEByZXR1cm4ge251bWJlcn0gQSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxLlxuICAgKi9cbiAgZ2V0QWxwaGEoaWQsIHRpbWUpIHtcbiAgICBpZiAoIXRoaXMudHJhbnNpdGlvbl8pIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cblxuICAgIGxldCBzdGFydCA9IHRoaXMudHJhbnNpdGlvblN0YXJ0c19baWRdO1xuICAgIGlmICghc3RhcnQpIHtcbiAgICAgIHN0YXJ0ID0gdGltZTtcbiAgICAgIHRoaXMudHJhbnNpdGlvblN0YXJ0c19baWRdID0gc3RhcnQ7XG4gICAgfSBlbHNlIGlmIChzdGFydCA9PT0gLTEpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cblxuICAgIGNvbnN0IGRlbHRhID0gdGltZSAtIHN0YXJ0ICsgMTAwMCAvIDYwOyAvLyBhdm9pZCByZW5kZXJpbmcgYXQgMFxuICAgIGlmIChkZWx0YSA+PSB0aGlzLnRyYW5zaXRpb25fKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgcmV0dXJuIGVhc2VJbihkZWx0YSAvIHRoaXMudHJhbnNpdGlvbl8pO1xuICB9XG5cbiAgLyoqXG4gICAqIERldGVybWluZSBpZiBhIHRpbGUgaXMgaW4gYW4gYWxwaGEgdHJhbnNpdGlvbi4gIEEgdGlsZSBpcyBjb25zaWRlcmVkIGluXG4gICAqIHRyYW5zaXRpb24gaWYgdGlsZS5nZXRBbHBoYSgpIGhhcyBub3QgeWV0IGJlZW4gY2FsbGVkIG9yIGhhcyBiZWVuIGNhbGxlZFxuICAgKiBhbmQgcmV0dXJuZWQgMS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGlkIEFuIGlkIGZvciB0aGUgcmVuZGVyZXIuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSB0aWxlIGlzIGluIHRyYW5zaXRpb24uXG4gICAqL1xuICBpblRyYW5zaXRpb24oaWQpIHtcbiAgICBpZiAoIXRoaXMudHJhbnNpdGlvbl8pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudHJhbnNpdGlvblN0YXJ0c19baWRdICE9PSAtMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNYXJrIGEgdHJhbnNpdGlvbiBhcyBjb21wbGV0ZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGlkIEFuIGlkIGZvciB0aGUgcmVuZGVyZXIuXG4gICAqL1xuICBlbmRUcmFuc2l0aW9uKGlkKSB7XG4gICAgaWYgKHRoaXMudHJhbnNpdGlvbl8pIHtcbiAgICAgIHRoaXMudHJhbnNpdGlvblN0YXJ0c19baWRdID0gLTE7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFRpbGU7XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvVGlsZUNhY2hlXG4gKi9cbmltcG9ydCBMUlVDYWNoZSBmcm9tICcuL3N0cnVjdHMvTFJVQ2FjaGUuanMnO1xuaW1wb3J0IHtmcm9tS2V5LCBnZXRLZXl9IGZyb20gJy4vdGlsZWNvb3JkLmpzJztcblxuY2xhc3MgVGlsZUNhY2hlIGV4dGVuZHMgTFJVQ2FjaGUge1xuICBjbGVhcigpIHtcbiAgICB3aGlsZSAodGhpcy5nZXRDb3VudCgpID4gMCkge1xuICAgICAgdGhpcy5wb3AoKS5yZWxlYXNlKCk7XG4gICAgfVxuICAgIHN1cGVyLmNsZWFyKCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHshT2JqZWN0PHN0cmluZywgYm9vbGVhbj59IHVzZWRUaWxlcyBVc2VkIHRpbGVzLlxuICAgKi9cbiAgZXhwaXJlQ2FjaGUodXNlZFRpbGVzKSB7XG4gICAgd2hpbGUgKHRoaXMuY2FuRXhwaXJlQ2FjaGUoKSkge1xuICAgICAgY29uc3QgdGlsZSA9IHRoaXMucGVla0xhc3QoKTtcbiAgICAgIGlmICh0aWxlLmdldEtleSgpIGluIHVzZWRUaWxlcykge1xuICAgICAgICBicmVhaztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucG9wKCkucmVsZWFzZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBQcnVuZSBhbGwgdGlsZXMgZnJvbSB0aGUgY2FjaGUgdGhhdCBkb24ndCBoYXZlIHRoZSBzYW1lIHogYXMgdGhlIG5ld2VzdCB0aWxlLlxuICAgKi9cbiAgcHJ1bmVFeGNlcHROZXdlc3RaKCkge1xuICAgIGlmICh0aGlzLmdldENvdW50KCkgPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qga2V5ID0gdGhpcy5wZWVrRmlyc3RLZXkoKTtcbiAgICBjb25zdCB0aWxlQ29vcmQgPSBmcm9tS2V5KGtleSk7XG4gICAgY29uc3QgeiA9IHRpbGVDb29yZFswXTtcbiAgICB0aGlzLmZvckVhY2goKHRpbGUpID0+IHtcbiAgICAgIGlmICh0aWxlLnRpbGVDb29yZFswXSAhPT0geikge1xuICAgICAgICB0aGlzLnJlbW92ZShnZXRLZXkodGlsZS50aWxlQ29vcmQpKTtcbiAgICAgICAgdGlsZS5yZWxlYXNlKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgVGlsZUNhY2hlO1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL1RpbGVRdWV1ZVxuICovXG5pbXBvcnQgRXZlbnRUeXBlIGZyb20gJy4vZXZlbnRzL0V2ZW50VHlwZS5qcyc7XG5pbXBvcnQgUHJpb3JpdHlRdWV1ZSwge0RST1B9IGZyb20gJy4vc3RydWN0cy9Qcmlvcml0eVF1ZXVlLmpzJztcbmltcG9ydCBUaWxlU3RhdGUgZnJvbSAnLi9UaWxlU3RhdGUuanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtmdW5jdGlvbihpbXBvcnQoXCIuL1RpbGUuanNcIikuZGVmYXVsdCwgc3RyaW5nLCBpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZSwgbnVtYmVyKTogbnVtYmVyfSBQcmlvcml0eUZ1bmN0aW9uXG4gKi9cblxuY2xhc3MgVGlsZVF1ZXVlIGV4dGVuZHMgUHJpb3JpdHlRdWV1ZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1ByaW9yaXR5RnVuY3Rpb259IHRpbGVQcmlvcml0eUZ1bmN0aW9uIFRpbGUgcHJpb3JpdHkgZnVuY3Rpb24uXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oKTogP30gdGlsZUNoYW5nZUNhbGxiYWNrIEZ1bmN0aW9uIGNhbGxlZCBvbiBlYWNoIHRpbGUgY2hhbmdlIGV2ZW50LlxuICAgKi9cbiAgY29uc3RydWN0b3IodGlsZVByaW9yaXR5RnVuY3Rpb24sIHRpbGVDaGFuZ2VDYWxsYmFjaykge1xuICAgIHN1cGVyKFxuICAgICAgLyoqXG4gICAgICAgKiBAcGFyYW0ge0FycmF5fSBlbGVtZW50IEVsZW1lbnQuXG4gICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IFByaW9yaXR5LlxuICAgICAgICovXG4gICAgICBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICByZXR1cm4gdGlsZVByaW9yaXR5RnVuY3Rpb24uYXBwbHkobnVsbCwgZWxlbWVudCk7XG4gICAgICB9LFxuICAgICAgLyoqXG4gICAgICAgKiBAcGFyYW0ge0FycmF5fSBlbGVtZW50IEVsZW1lbnQuXG4gICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IEtleS5cbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIC8qKiBAdHlwZSB7aW1wb3J0KFwiLi9UaWxlLmpzXCIpLmRlZmF1bHR9ICovIChlbGVtZW50WzBdKS5nZXRLZXkoKTtcbiAgICAgIH1cbiAgICApO1xuXG4gICAgLyoqIEBwcml2YXRlICovXG4gICAgdGhpcy5ib3VuZEhhbmRsZVRpbGVDaGFuZ2VfID0gdGhpcy5oYW5kbGVUaWxlQ2hhbmdlLmJpbmQodGhpcyk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtmdW5jdGlvbigpOiA/fVxuICAgICAqL1xuICAgIHRoaXMudGlsZUNoYW5nZUNhbGxiYWNrXyA9IHRpbGVDaGFuZ2VDYWxsYmFjaztcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnRpbGVzTG9hZGluZ18gPSAwO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7IU9iamVjdDxzdHJpbmcsYm9vbGVhbj59XG4gICAgICovXG4gICAgdGhpcy50aWxlc0xvYWRpbmdLZXlzXyA9IHt9O1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7QXJyYXl9IGVsZW1lbnQgRWxlbWVudC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVGhlIGVsZW1lbnQgd2FzIGFkZGVkIHRvIHRoZSBxdWV1ZS5cbiAgICovXG4gIGVucXVldWUoZWxlbWVudCkge1xuICAgIGNvbnN0IGFkZGVkID0gc3VwZXIuZW5xdWV1ZShlbGVtZW50KTtcbiAgICBpZiAoYWRkZWQpIHtcbiAgICAgIGNvbnN0IHRpbGUgPSBlbGVtZW50WzBdO1xuICAgICAgdGlsZS5hZGRFdmVudExpc3RlbmVyKEV2ZW50VHlwZS5DSEFOR0UsIHRoaXMuYm91bmRIYW5kbGVUaWxlQ2hhbmdlXyk7XG4gICAgfVxuICAgIHJldHVybiBhZGRlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IE51bWJlciBvZiB0aWxlcyBsb2FkaW5nLlxuICAgKi9cbiAgZ2V0VGlsZXNMb2FkaW5nKCkge1xuICAgIHJldHVybiB0aGlzLnRpbGVzTG9hZGluZ187XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL2V2ZW50cy9FdmVudC5qc1wiKS5kZWZhdWx0fSBldmVudCBFdmVudC5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgaGFuZGxlVGlsZUNoYW5nZShldmVudCkge1xuICAgIGNvbnN0IHRpbGUgPSAvKiogQHR5cGUge2ltcG9ydChcIi4vVGlsZS5qc1wiKS5kZWZhdWx0fSAqLyAoZXZlbnQudGFyZ2V0KTtcbiAgICBjb25zdCBzdGF0ZSA9IHRpbGUuZ2V0U3RhdGUoKTtcbiAgICBpZiAoXG4gICAgICBzdGF0ZSA9PT0gVGlsZVN0YXRlLkxPQURFRCB8fFxuICAgICAgc3RhdGUgPT09IFRpbGVTdGF0ZS5FUlJPUiB8fFxuICAgICAgc3RhdGUgPT09IFRpbGVTdGF0ZS5FTVBUWVxuICAgICkge1xuICAgICAgaWYgKHN0YXRlICE9PSBUaWxlU3RhdGUuRVJST1IpIHtcbiAgICAgICAgdGlsZS5yZW1vdmVFdmVudExpc3RlbmVyKEV2ZW50VHlwZS5DSEFOR0UsIHRoaXMuYm91bmRIYW5kbGVUaWxlQ2hhbmdlXyk7XG4gICAgICB9XG4gICAgICBjb25zdCB0aWxlS2V5ID0gdGlsZS5nZXRLZXkoKTtcbiAgICAgIGlmICh0aWxlS2V5IGluIHRoaXMudGlsZXNMb2FkaW5nS2V5c18pIHtcbiAgICAgICAgZGVsZXRlIHRoaXMudGlsZXNMb2FkaW5nS2V5c19bdGlsZUtleV07XG4gICAgICAgIC0tdGhpcy50aWxlc0xvYWRpbmdfO1xuICAgICAgfVxuICAgICAgdGhpcy50aWxlQ2hhbmdlQ2FsbGJhY2tfKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtYXhUb3RhbExvYWRpbmcgTWF4aW11bSBudW1iZXIgdGlsZXMgdG8gbG9hZCBzaW11bHRhbmVvdXNseS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG1heE5ld0xvYWRzIE1heGltdW0gbnVtYmVyIG9mIG5ldyB0aWxlcyB0byBsb2FkLlxuICAgKi9cbiAgbG9hZE1vcmVUaWxlcyhtYXhUb3RhbExvYWRpbmcsIG1heE5ld0xvYWRzKSB7XG4gICAgbGV0IG5ld0xvYWRzID0gMDtcbiAgICBsZXQgc3RhdGUsIHRpbGUsIHRpbGVLZXk7XG4gICAgd2hpbGUgKFxuICAgICAgdGhpcy50aWxlc0xvYWRpbmdfIDwgbWF4VG90YWxMb2FkaW5nICYmXG4gICAgICBuZXdMb2FkcyA8IG1heE5ld0xvYWRzICYmXG4gICAgICB0aGlzLmdldENvdW50KCkgPiAwXG4gICAgKSB7XG4gICAgICB0aWxlID0gLyoqIEB0eXBlIHtpbXBvcnQoXCIuL1RpbGUuanNcIikuZGVmYXVsdH0gKi8gKHRoaXMuZGVxdWV1ZSgpWzBdKTtcbiAgICAgIHRpbGVLZXkgPSB0aWxlLmdldEtleSgpO1xuICAgICAgc3RhdGUgPSB0aWxlLmdldFN0YXRlKCk7XG4gICAgICBpZiAoc3RhdGUgPT09IFRpbGVTdGF0ZS5JRExFICYmICEodGlsZUtleSBpbiB0aGlzLnRpbGVzTG9hZGluZ0tleXNfKSkge1xuICAgICAgICB0aGlzLnRpbGVzTG9hZGluZ0tleXNfW3RpbGVLZXldID0gdHJ1ZTtcbiAgICAgICAgKyt0aGlzLnRpbGVzTG9hZGluZ187XG4gICAgICAgICsrbmV3TG9hZHM7XG4gICAgICAgIHRpbGUubG9hZCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBUaWxlUXVldWU7XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoJy4vTWFwLmpzJykuRnJhbWVTdGF0ZX0gZnJhbWVTdGF0ZSBGcmFtZSBzdGF0ZS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9UaWxlLmpzXCIpLmRlZmF1bHR9IHRpbGUgVGlsZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0aWxlU291cmNlS2V5IFRpbGUgc291cmNlIGtleS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IHRpbGVDZW50ZXIgVGlsZSBjZW50ZXIuXG4gKiBAcGFyYW0ge251bWJlcn0gdGlsZVJlc29sdXRpb24gVGlsZSByZXNvbHV0aW9uLlxuICogQHJldHVybiB7bnVtYmVyfSBUaWxlIHByaW9yaXR5LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0VGlsZVByaW9yaXR5KFxuICBmcmFtZVN0YXRlLFxuICB0aWxlLFxuICB0aWxlU291cmNlS2V5LFxuICB0aWxlQ2VudGVyLFxuICB0aWxlUmVzb2x1dGlvblxuKSB7XG4gIC8vIEZpbHRlciBvdXQgdGlsZXMgYXQgaGlnaGVyIHpvb20gbGV2ZWxzIHRoYW4gdGhlIGN1cnJlbnQgem9vbSBsZXZlbCwgb3IgdGhhdFxuICAvLyBhcmUgb3V0c2lkZSB0aGUgdmlzaWJsZSBleHRlbnQuXG4gIGlmICghZnJhbWVTdGF0ZSB8fCAhKHRpbGVTb3VyY2VLZXkgaW4gZnJhbWVTdGF0ZS53YW50ZWRUaWxlcykpIHtcbiAgICByZXR1cm4gRFJPUDtcbiAgfVxuICBpZiAoIWZyYW1lU3RhdGUud2FudGVkVGlsZXNbdGlsZVNvdXJjZUtleV1bdGlsZS5nZXRLZXkoKV0pIHtcbiAgICByZXR1cm4gRFJPUDtcbiAgfVxuICAvLyBQcmlvcml0aXplIHRoZSBoaWdoZXN0IHpvb20gbGV2ZWwgdGlsZXMgY2xvc2VzdCB0byB0aGUgZm9jdXMuXG4gIC8vIFRpbGVzIGF0IGhpZ2hlciB6b29tIGxldmVscyBhcmUgcHJpb3JpdGl6ZWQgdXNpbmcgTWF0aC5sb2codGlsZVJlc29sdXRpb24pLlxuICAvLyBXaXRoaW4gYSB6b29tIGxldmVsLCB0aWxlcyBhcmUgcHJpb3JpdGl6ZWQgYnkgdGhlIGRpc3RhbmNlIGluIHBpeGVscyBiZXR3ZWVuXG4gIC8vIHRoZSBjZW50ZXIgb2YgdGhlIHRpbGUgYW5kIHRoZSBjZW50ZXIgb2YgdGhlIHZpZXdwb3J0LiAgVGhlIGZhY3RvciBvZiA2NTUzNlxuICAvLyBtZWFucyB0aGF0IHRoZSBwcmlvcml0aXphdGlvbiBzaG91bGQgYmVoYXZlIGFzIGRlc2lyZWQgZm9yIHRpbGVzIHVwIHRvXG4gIC8vIDY1NTM2ICogTWF0aC5sb2coMikgPSA0NTQyNiBwaXhlbHMgZnJvbSB0aGUgZm9jdXMuXG4gIGNvbnN0IGNlbnRlciA9IGZyYW1lU3RhdGUudmlld1N0YXRlLmNlbnRlcjtcbiAgY29uc3QgZGVsdGFYID0gdGlsZUNlbnRlclswXSAtIGNlbnRlclswXTtcbiAgY29uc3QgZGVsdGFZID0gdGlsZUNlbnRlclsxXSAtIGNlbnRlclsxXTtcbiAgcmV0dXJuIChcbiAgICA2NTUzNiAqIE1hdGgubG9nKHRpbGVSZXNvbHV0aW9uKSArXG4gICAgTWF0aC5zcXJ0KGRlbHRhWCAqIGRlbHRhWCArIGRlbHRhWSAqIGRlbHRhWSkgLyB0aWxlUmVzb2x1dGlvblxuICApO1xufVxuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL1RpbGVSYW5nZVxuICovXG5cbi8qKlxuICogQSByZXByZXNlbnRhdGlvbiBvZiBhIGNvbnRpZ3VvdXMgYmxvY2sgb2YgdGlsZXMuICBBIHRpbGUgcmFuZ2UgaXMgc3BlY2lmaWVkXG4gKiBieSBpdHMgbWluL21heCB0aWxlIGNvb3JkaW5hdGVzIGFuZCBpcyBpbmNsdXNpdmUgb2YgY29vcmRpbmF0ZXMuXG4gKi9cbmNsYXNzIFRpbGVSYW5nZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gbWluWCBNaW5pbXVtIFguXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtYXhYIE1heGltdW0gWC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG1pblkgTWluaW11bSBZLlxuICAgKiBAcGFyYW0ge251bWJlcn0gbWF4WSBNYXhpbXVtIFkuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihtaW5YLCBtYXhYLCBtaW5ZLCBtYXhZKSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLm1pblggPSBtaW5YO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLm1heFggPSBtYXhYO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLm1pblkgPSBtaW5ZO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLm1heFkgPSBtYXhZO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi90aWxlY29vcmQuanNcIikuVGlsZUNvb3JkfSB0aWxlQ29vcmQgVGlsZSBjb29yZGluYXRlLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBDb250YWlucyB0aWxlIGNvb3JkaW5hdGUuXG4gICAqL1xuICBjb250YWlucyh0aWxlQ29vcmQpIHtcbiAgICByZXR1cm4gdGhpcy5jb250YWluc1hZKHRpbGVDb29yZFsxXSwgdGlsZUNvb3JkWzJdKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1RpbGVSYW5nZX0gdGlsZVJhbmdlIFRpbGUgcmFuZ2UuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IENvbnRhaW5zLlxuICAgKi9cbiAgY29udGFpbnNUaWxlUmFuZ2UodGlsZVJhbmdlKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIHRoaXMubWluWCA8PSB0aWxlUmFuZ2UubWluWCAmJlxuICAgICAgdGlsZVJhbmdlLm1heFggPD0gdGhpcy5tYXhYICYmXG4gICAgICB0aGlzLm1pblkgPD0gdGlsZVJhbmdlLm1pblkgJiZcbiAgICAgIHRpbGVSYW5nZS5tYXhZIDw9IHRoaXMubWF4WVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHggVGlsZSBjb29yZGluYXRlIHguXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5IFRpbGUgY29vcmRpbmF0ZSB5LlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBDb250YWlucyBjb29yZGluYXRlLlxuICAgKi9cbiAgY29udGFpbnNYWSh4LCB5KSB7XG4gICAgcmV0dXJuIHRoaXMubWluWCA8PSB4ICYmIHggPD0gdGhpcy5tYXhYICYmIHRoaXMubWluWSA8PSB5ICYmIHkgPD0gdGhpcy5tYXhZO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VGlsZVJhbmdlfSB0aWxlUmFuZ2UgVGlsZSByYW5nZS5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gRXF1YWxzLlxuICAgKi9cbiAgZXF1YWxzKHRpbGVSYW5nZSkge1xuICAgIHJldHVybiAoXG4gICAgICB0aGlzLm1pblggPT0gdGlsZVJhbmdlLm1pblggJiZcbiAgICAgIHRoaXMubWluWSA9PSB0aWxlUmFuZ2UubWluWSAmJlxuICAgICAgdGhpcy5tYXhYID09IHRpbGVSYW5nZS5tYXhYICYmXG4gICAgICB0aGlzLm1heFkgPT0gdGlsZVJhbmdlLm1heFlcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VGlsZVJhbmdlfSB0aWxlUmFuZ2UgVGlsZSByYW5nZS5cbiAgICovXG4gIGV4dGVuZCh0aWxlUmFuZ2UpIHtcbiAgICBpZiAodGlsZVJhbmdlLm1pblggPCB0aGlzLm1pblgpIHtcbiAgICAgIHRoaXMubWluWCA9IHRpbGVSYW5nZS5taW5YO1xuICAgIH1cbiAgICBpZiAodGlsZVJhbmdlLm1heFggPiB0aGlzLm1heFgpIHtcbiAgICAgIHRoaXMubWF4WCA9IHRpbGVSYW5nZS5tYXhYO1xuICAgIH1cbiAgICBpZiAodGlsZVJhbmdlLm1pblkgPCB0aGlzLm1pblkpIHtcbiAgICAgIHRoaXMubWluWSA9IHRpbGVSYW5nZS5taW5ZO1xuICAgIH1cbiAgICBpZiAodGlsZVJhbmdlLm1heFkgPiB0aGlzLm1heFkpIHtcbiAgICAgIHRoaXMubWF4WSA9IHRpbGVSYW5nZS5tYXhZO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IEhlaWdodC5cbiAgICovXG4gIGdldEhlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy5tYXhZIC0gdGhpcy5taW5ZICsgMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuL3NpemUuanNcIikuU2l6ZX0gU2l6ZS5cbiAgICovXG4gIGdldFNpemUoKSB7XG4gICAgcmV0dXJuIFt0aGlzLmdldFdpZHRoKCksIHRoaXMuZ2V0SGVpZ2h0KCldO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn0gV2lkdGguXG4gICAqL1xuICBnZXRXaWR0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5tYXhYIC0gdGhpcy5taW5YICsgMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1RpbGVSYW5nZX0gdGlsZVJhbmdlIFRpbGUgcmFuZ2UuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IEludGVyc2VjdHMuXG4gICAqL1xuICBpbnRlcnNlY3RzKHRpbGVSYW5nZSkge1xuICAgIHJldHVybiAoXG4gICAgICB0aGlzLm1pblggPD0gdGlsZVJhbmdlLm1heFggJiZcbiAgICAgIHRoaXMubWF4WCA+PSB0aWxlUmFuZ2UubWluWCAmJlxuICAgICAgdGhpcy5taW5ZIDw9IHRpbGVSYW5nZS5tYXhZICYmXG4gICAgICB0aGlzLm1heFkgPj0gdGlsZVJhbmdlLm1pbllcbiAgICApO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IG1pblggTWluaW11bSBYLlxuICogQHBhcmFtIHtudW1iZXJ9IG1heFggTWF4aW11bSBYLlxuICogQHBhcmFtIHtudW1iZXJ9IG1pblkgTWluaW11bSBZLlxuICogQHBhcmFtIHtudW1iZXJ9IG1heFkgTWF4aW11bSBZLlxuICogQHBhcmFtIHtUaWxlUmFuZ2V9IFt0aWxlUmFuZ2VdIFRpbGVSYW5nZS5cbiAqIEByZXR1cm4ge1RpbGVSYW5nZX0gVGlsZSByYW5nZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZU9yVXBkYXRlKG1pblgsIG1heFgsIG1pblksIG1heFksIHRpbGVSYW5nZSkge1xuICBpZiAodGlsZVJhbmdlICE9PSB1bmRlZmluZWQpIHtcbiAgICB0aWxlUmFuZ2UubWluWCA9IG1pblg7XG4gICAgdGlsZVJhbmdlLm1heFggPSBtYXhYO1xuICAgIHRpbGVSYW5nZS5taW5ZID0gbWluWTtcbiAgICB0aWxlUmFuZ2UubWF4WSA9IG1heFk7XG4gICAgcmV0dXJuIHRpbGVSYW5nZTtcbiAgfVxuICByZXR1cm4gbmV3IFRpbGVSYW5nZShtaW5YLCBtYXhYLCBtaW5ZLCBtYXhZKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgVGlsZVJhbmdlO1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL1RpbGVTdGF0ZVxuICovXG5cbi8qKlxuICogQGVudW0ge251bWJlcn1cbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICBJRExFOiAwLFxuICBMT0FESU5HOiAxLFxuICBMT0FERUQ6IDIsXG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgdGhhdCB0aWxlIGxvYWRpbmcgZmFpbGVkXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBFUlJPUjogMyxcbiAgRU1QVFk6IDQsXG59O1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL1ZpZXdcbiAqL1xuaW1wb3J0IEJhc2VPYmplY3QgZnJvbSAnLi9PYmplY3QuanMnO1xuaW1wb3J0IFZpZXdIaW50IGZyb20gJy4vVmlld0hpbnQuanMnO1xuaW1wb3J0IFZpZXdQcm9wZXJ0eSBmcm9tICcuL1ZpZXdQcm9wZXJ0eS5qcyc7XG5pbXBvcnQge0RFRkFVTFRfVElMRV9TSVpFfSBmcm9tICcuL3RpbGVncmlkL2NvbW1vbi5qcyc7XG5pbXBvcnQge1xuICBNRVRFUlNfUEVSX1VOSVQsXG4gIGNyZWF0ZVByb2plY3Rpb24sXG4gIGRpc2FibGVDb29yZGluYXRlV2FybmluZyxcbiAgZnJvbVVzZXJDb29yZGluYXRlLFxuICBmcm9tVXNlckV4dGVudCxcbiAgZ2V0VXNlclByb2plY3Rpb24sXG4gIHRvVXNlckNvb3JkaW5hdGUsXG4gIHRvVXNlckV4dGVudCxcbn0gZnJvbSAnLi9wcm9qLmpzJztcbmltcG9ydCB7Vk9JRH0gZnJvbSAnLi9mdW5jdGlvbnMuanMnO1xuaW1wb3J0IHtcbiAgYWRkIGFzIGFkZENvb3JkaW5hdGUsXG4gIGVxdWFscyBhcyBjb29yZGluYXRlc0VxdWFsLFxuICBlcXVhbHMsXG4gIHJvdGF0ZSBhcyByb3RhdGVDb29yZGluYXRlLFxufSBmcm9tICcuL2Nvb3JkaW5hdGUuanMnO1xuaW1wb3J0IHthc3NlcnR9IGZyb20gJy4vYXNzZXJ0cy5qcyc7XG5pbXBvcnQge25vbmUgYXMgY2VudGVyTm9uZSwgY3JlYXRlRXh0ZW50fSBmcm9tICcuL2NlbnRlcmNvbnN0cmFpbnQuanMnO1xuaW1wb3J0IHtjbGFtcCwgbW9kdWxvfSBmcm9tICcuL21hdGguanMnO1xuaW1wb3J0IHtcbiAgY3JlYXRlTWluTWF4UmVzb2x1dGlvbixcbiAgY3JlYXRlU25hcFRvUG93ZXIsXG4gIGNyZWF0ZVNuYXBUb1Jlc29sdXRpb25zLFxufSBmcm9tICcuL3Jlc29sdXRpb25jb25zdHJhaW50LmpzJztcbmltcG9ydCB7XG4gIGNyZWF0ZVNuYXBUb04sXG4gIGNyZWF0ZVNuYXBUb1plcm8sXG4gIGRpc2FibGUsXG4gIG5vbmUgYXMgcm90YXRpb25Ob25lLFxufSBmcm9tICcuL3JvdGF0aW9uY29uc3RyYWludC5qcyc7XG5pbXBvcnQge2Vhc2VPdXQsIGluQW5kT3V0fSBmcm9tICcuL2Vhc2luZy5qcyc7XG5pbXBvcnQge1xuICBnZXRDZW50ZXIsXG4gIGdldEZvclZpZXdBbmRTaXplLFxuICBnZXRIZWlnaHQsXG4gIGdldFdpZHRoLFxuICBpc0VtcHR5LFxufSBmcm9tICcuL2V4dGVudC5qcyc7XG5pbXBvcnQge2xpbmVhckZpbmROZWFyZXN0fSBmcm9tICcuL2FycmF5LmpzJztcbmltcG9ydCB7ZnJvbUV4dGVudCBhcyBwb2x5Z29uRnJvbUV4dGVudH0gZnJvbSAnLi9nZW9tL1BvbHlnb24uanMnO1xuXG4vKipcbiAqIEFuIGFuaW1hdGlvbiBjb25maWd1cmF0aW9uXG4gKlxuICogQHR5cGVkZWYge09iamVjdH0gQW5pbWF0aW9uXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBbc291cmNlQ2VudGVyXSBTb3VyY2UgY2VudGVyLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gW3RhcmdldENlbnRlcl0gVGFyZ2V0IGNlbnRlci5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbc291cmNlUmVzb2x1dGlvbl0gU291cmNlIHJlc29sdXRpb24uXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3RhcmdldFJlc29sdXRpb25dIFRhcmdldCByZXNvbHV0aW9uLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtzb3VyY2VSb3RhdGlvbl0gU291cmNlIHJvdGF0aW9uLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFt0YXJnZXRSb3RhdGlvbl0gVGFyZ2V0IHJvdGF0aW9uLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gW2FuY2hvcl0gQW5jaG9yLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IHN0YXJ0IFN0YXJ0LlxuICogQHByb3BlcnR5IHtudW1iZXJ9IGR1cmF0aW9uIER1cmF0aW9uLlxuICogQHByb3BlcnR5IHtib29sZWFufSBjb21wbGV0ZSBDb21wbGV0ZS5cbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb24obnVtYmVyKTpudW1iZXJ9IGVhc2luZyBFYXNpbmcuXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9uKGJvb2xlYW4pOnZvaWR9IGNhbGxiYWNrIENhbGxiYWNrLlxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gQ29uc3RyYWludHNcbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi9jZW50ZXJjb25zdHJhaW50LmpzXCIpLlR5cGV9IGNlbnRlciBDZW50ZXIuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4vcmVzb2x1dGlvbmNvbnN0cmFpbnQuanNcIikuVHlwZX0gcmVzb2x1dGlvbiBSZXNvbHV0aW9uLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL3JvdGF0aW9uY29uc3RyYWludC5qc1wiKS5UeXBlfSByb3RhdGlvbiBSb3RhdGlvbi5cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEZpdE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi9zaXplLmpzXCIpLlNpemV9IFtzaXplXSBUaGUgc2l6ZSBpbiBwaXhlbHMgb2YgdGhlIGJveCB0byBmaXRcbiAqIHRoZSBleHRlbnQgaW50by4gRGVmYXVsdCBpcyB0aGUgY3VycmVudCBzaXplIG9mIHRoZSBmaXJzdCBtYXAgaW4gdGhlIERPTSB0aGF0XG4gKiB1c2VzIHRoaXMgdmlldywgb3IgYFsxMDAsIDEwMF1gIGlmIG5vIHN1Y2ggbWFwIGlzIGZvdW5kLlxuICogQHByb3BlcnR5IHshQXJyYXk8bnVtYmVyPn0gW3BhZGRpbmc9WzAsIDAsIDAsIDBdXSBQYWRkaW5nIChpbiBwaXhlbHMpIHRvIGJlXG4gKiBjbGVhcmVkIGluc2lkZSB0aGUgdmlldy4gVmFsdWVzIGluIHRoZSBhcnJheSBhcmUgdG9wLCByaWdodCwgYm90dG9tIGFuZCBsZWZ0XG4gKiBwYWRkaW5nLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbbmVhcmVzdD1mYWxzZV0gSWYgdGhlIHZpZXcgYGNvbnN0cmFpblJlc29sdXRpb25gIG9wdGlvbiBpcyBgdHJ1ZWAsXG4gKiBnZXQgdGhlIG5lYXJlc3QgZXh0ZW50IGluc3RlYWQgb2YgdGhlIGNsb3Nlc3QgdGhhdCBhY3R1YWxseSBmaXRzIHRoZSB2aWV3LlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFttaW5SZXNvbHV0aW9uPTBdIE1pbmltdW0gcmVzb2x1dGlvbiB0aGF0IHdlIHpvb20gdG8uXG4gKiBAcHJvcGVydHkge251bWJlcn0gW21heFpvb21dIE1heGltdW0gem9vbSBsZXZlbCB0aGF0IHdlIHpvb20gdG8uIElmXG4gKiBgbWluUmVzb2x1dGlvbmAgaXMgZ2l2ZW4sIHRoaXMgcHJvcGVydHkgaXMgaWdub3JlZC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbZHVyYXRpb25dIFRoZSBkdXJhdGlvbiBvZiB0aGUgYW5pbWF0aW9uIGluIG1pbGxpc2Vjb25kcy5cbiAqIEJ5IGRlZmF1bHQsIHRoZXJlIGlzIG5vIGFuaW1hdGlvbiB0byB0aGUgdGFyZ2V0IGV4dGVudC5cbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb24obnVtYmVyKTpudW1iZXJ9IFtlYXNpbmddIFRoZSBlYXNpbmcgZnVuY3Rpb24gdXNlZCBkdXJpbmdcbiAqIHRoZSBhbmltYXRpb24gKGRlZmF1bHRzIHRvIHtAbGluayBtb2R1bGU6b2wvZWFzaW5nLmluQW5kT3V0fSkuXG4gKiBUaGUgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgZm9yIGVhY2ggZnJhbWUgd2l0aCBhIG51bWJlciByZXByZXNlbnRpbmcgYVxuICogZnJhY3Rpb24gb2YgdGhlIGFuaW1hdGlvbidzIGR1cmF0aW9uLiAgVGhlIGZ1bmN0aW9uIHNob3VsZCByZXR1cm4gYSBudW1iZXJcbiAqIGJldHdlZW4gMCBhbmQgMSByZXByZXNlbnRpbmcgdGhlIHByb2dyZXNzIHRvd2FyZCB0aGUgZGVzdGluYXRpb24gc3RhdGUuXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9uKGJvb2xlYW4pOnZvaWR9IFtjYWxsYmFja10gRnVuY3Rpb24gY2FsbGVkIHdoZW4gdGhlIHZpZXcgaXMgaW5cbiAqIGl0cyBmaW5hbCBwb3NpdGlvbi4gVGhlIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIHdpdGggYHRydWVgIGlmIHRoZSBhbmltYXRpb25cbiAqIHNlcmllcyBjb21wbGV0ZWQgb24gaXRzIG93biBvciBgZmFsc2VgIGlmIGl0IHdhcyBjYW5jZWxsZWQuXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBWaWV3T3B0aW9uc1xuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gW2NlbnRlcl0gVGhlIGluaXRpYWwgY2VudGVyIGZvclxuICogdGhlIHZpZXcuIElmIGEgdXNlciBwcm9qZWN0aW9uIGlzIG5vdCBzZXQsIHRoZSBjb29yZGluYXRlIHN5c3RlbSBmb3IgdGhlIGNlbnRlciBpc1xuICogc3BlY2lmaWVkIHdpdGggdGhlIGBwcm9qZWN0aW9uYCBvcHRpb24uIExheWVyIHNvdXJjZXMgd2lsbCBub3QgYmUgZmV0Y2hlZCBpZiB0aGlzXG4gKiBpcyBub3Qgc2V0LCBidXQgdGhlIGNlbnRlciBjYW4gYmUgc2V0IGxhdGVyIHdpdGgge0BsaW5rICNzZXRDZW50ZXJ9LlxuICogQHByb3BlcnR5IHtib29sZWFufG51bWJlcn0gW2NvbnN0cmFpblJvdGF0aW9uPXRydWVdIFJvdGF0aW9uIGNvbnN0cmFpbnQuXG4gKiBgZmFsc2VgIG1lYW5zIG5vIGNvbnN0cmFpbnQuIGB0cnVlYCBtZWFucyBubyBjb25zdHJhaW50LCBidXQgc25hcCB0byB6ZXJvXG4gKiBuZWFyIHplcm8uIEEgbnVtYmVyIGNvbnN0cmFpbnMgdGhlIHJvdGF0aW9uIHRvIHRoYXQgbnVtYmVyIG9mIHZhbHVlcy4gRm9yXG4gKiBleGFtcGxlLCBgNGAgd2lsbCBjb25zdHJhaW4gdGhlIHJvdGF0aW9uIHRvIDAsIDkwLCAxODAsIGFuZCAyNzAgZGVncmVlcy5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2VuYWJsZVJvdGF0aW9uPXRydWVdIEVuYWJsZSByb3RhdGlvbi5cbiAqIElmIGBmYWxzZWAsIGEgcm90YXRpb24gY29uc3RyYWludCB0aGF0IGFsd2F5cyBzZXRzIHRoZSByb3RhdGlvbiB0byB6ZXJvIGlzXG4gKiB1c2VkLiBUaGUgYGNvbnN0cmFpblJvdGF0aW9uYCBvcHRpb24gaGFzIG5vIGVmZmVjdCBpZiBgZW5hYmxlUm90YXRpb25gIGlzXG4gKiBgZmFsc2VgLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL2V4dGVudC5qc1wiKS5FeHRlbnR9IFtleHRlbnRdIFRoZSBleHRlbnQgdGhhdCBjb25zdHJhaW5zIHRoZVxuICogdmlldywgaW4gb3RoZXIgd29yZHMsIG5vdGhpbmcgb3V0c2lkZSBvZiB0aGlzIGV4dGVudCBjYW4gYmUgdmlzaWJsZSBvbiB0aGUgbWFwLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbY29uc3RyYWluT25seUNlbnRlcj1mYWxzZV0gSWYgdHJ1ZSwgdGhlIGV4dGVudFxuICogY29uc3RyYWludCB3aWxsIG9ubHkgYXBwbHkgdG8gdGhlIHZpZXcgY2VudGVyIGFuZCBub3QgdGhlIHdob2xlIGV4dGVudC5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3Ntb290aEV4dGVudENvbnN0cmFpbnQ9dHJ1ZV0gSWYgdHJ1ZSwgdGhlIGV4dGVudFxuICogY29uc3RyYWludCB3aWxsIGJlIGFwcGxpZWQgc21vb3RobHksIGkuZS4gYWxsb3cgdGhlIHZpZXcgdG8gZ28gc2xpZ2h0bHkgb3V0c2lkZVxuICogb2YgdGhlIGdpdmVuIGBleHRlbnRgLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFttYXhSZXNvbHV0aW9uXSBUaGUgbWF4aW11bSByZXNvbHV0aW9uIHVzZWQgdG8gZGV0ZXJtaW5lXG4gKiB0aGUgcmVzb2x1dGlvbiBjb25zdHJhaW50LiBJdCBpcyB1c2VkIHRvZ2V0aGVyIHdpdGggYG1pblJlc29sdXRpb25gIChvclxuICogYG1heFpvb21gKSBhbmQgYHpvb21GYWN0b3JgLiBJZiB1bnNwZWNpZmllZCBpdCBpcyBjYWxjdWxhdGVkIGluIHN1Y2ggYSB3YXlcbiAqIHRoYXQgdGhlIHByb2plY3Rpb24ncyB2YWxpZGl0eSBleHRlbnQgZml0cyBpbiBhIDI1NngyNTYgcHggdGlsZS4gSWYgdGhlXG4gKiBwcm9qZWN0aW9uIGlzIFNwaGVyaWNhbCBNZXJjYXRvciAodGhlIGRlZmF1bHQpIHRoZW4gYG1heFJlc29sdXRpb25gIGRlZmF1bHRzXG4gKiB0byBgNDAwNzUwMTYuNjg1NTc4NDkgLyAyNTYgPSAxNTY1NDMuMDMzOTI4MDQwOTdgLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFttaW5SZXNvbHV0aW9uXSBUaGUgbWluaW11bSByZXNvbHV0aW9uIHVzZWQgdG8gZGV0ZXJtaW5lXG4gKiB0aGUgcmVzb2x1dGlvbiBjb25zdHJhaW50LiAgSXQgaXMgdXNlZCB0b2dldGhlciB3aXRoIGBtYXhSZXNvbHV0aW9uYCAob3JcbiAqIGBtaW5ab29tYCkgYW5kIGB6b29tRmFjdG9yYC4gIElmIHVuc3BlY2lmaWVkIGl0IGlzIGNhbGN1bGF0ZWQgYXNzdW1pbmcgMjlcbiAqIHpvb20gbGV2ZWxzICh3aXRoIGEgZmFjdG9yIG9mIDIpLiBJZiB0aGUgcHJvamVjdGlvbiBpcyBTcGhlcmljYWwgTWVyY2F0b3JcbiAqICh0aGUgZGVmYXVsdCkgdGhlbiBgbWluUmVzb2x1dGlvbmAgZGVmYXVsdHMgdG9cbiAqIGA0MDA3NTAxNi42ODU1Nzg0OSAvIDI1NiAvIE1hdGgucG93KDIsIDI4KSA9IDAuMDAwNTgzMTY4MjQ1NTgzOTI1M2AuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW21heFpvb209MjhdIFRoZSBtYXhpbXVtIHpvb20gbGV2ZWwgdXNlZCB0byBkZXRlcm1pbmUgdGhlXG4gKiByZXNvbHV0aW9uIGNvbnN0cmFpbnQuIEl0IGlzIHVzZWQgdG9nZXRoZXIgd2l0aCBgbWluWm9vbWAgKG9yXG4gKiBgbWF4UmVzb2x1dGlvbmApIGFuZCBgem9vbUZhY3RvcmAuICBOb3RlIHRoYXQgaWYgYG1pblJlc29sdXRpb25gIGlzIGFsc29cbiAqIHByb3ZpZGVkLCBpdCBpcyBnaXZlbiBwcmVjZWRlbmNlIG92ZXIgYG1heFpvb21gLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFttaW5ab29tPTBdIFRoZSBtaW5pbXVtIHpvb20gbGV2ZWwgdXNlZCB0byBkZXRlcm1pbmUgdGhlXG4gKiByZXNvbHV0aW9uIGNvbnN0cmFpbnQuIEl0IGlzIHVzZWQgdG9nZXRoZXIgd2l0aCBgbWF4Wm9vbWAgKG9yXG4gKiBgbWluUmVzb2x1dGlvbmApIGFuZCBgem9vbUZhY3RvcmAuICBOb3RlIHRoYXQgaWYgYG1heFJlc29sdXRpb25gIGlzIGFsc29cbiAqIHByb3ZpZGVkLCBpdCBpcyBnaXZlbiBwcmVjZWRlbmNlIG92ZXIgYG1pblpvb21gLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbbXVsdGlXb3JsZD1mYWxzZV0gSWYgYGZhbHNlYCB0aGUgdmlldyBpcyBjb25zdHJhaW5lZCBzb1xuICogb25seSBvbmUgd29ybGQgaXMgdmlzaWJsZSwgYW5kIHlvdSBjYW5ub3QgcGFuIG9mZiB0aGUgZWRnZS4gIElmIGB0cnVlYCB0aGUgbWFwXG4gKiBtYXkgc2hvdyBtdWx0aXBsZSB3b3JsZHMgYXQgbG93IHpvb20gbGV2ZWxzLiAgT25seSB1c2VkIGlmIHRoZSBgcHJvamVjdGlvbmAgaXNcbiAqIGdsb2JhbC4gIE5vdGUgdGhhdCBpZiBgZXh0ZW50YCBpcyBhbHNvIHByb3ZpZGVkIGl0IGlzIGdpdmVuIHByZWNlZGVuY2UuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtjb25zdHJhaW5SZXNvbHV0aW9uPWZhbHNlXSBJZiB0cnVlLCB0aGUgdmlldyB3aWxsIGFsd2F5c1xuICogYW5pbWF0ZSB0byB0aGUgY2xvc2VzdCB6b29tIGxldmVsIGFmdGVyIGFuIGludGVyYWN0aW9uOyBmYWxzZSBtZWFuc1xuICogaW50ZXJtZWRpYXJ5IHpvb20gbGV2ZWxzIGFyZSBhbGxvd2VkLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbc21vb3RoUmVzb2x1dGlvbkNvbnN0cmFpbnQ9dHJ1ZV0gSWYgdHJ1ZSwgdGhlIHJlc29sdXRpb25cbiAqIG1pbi9tYXggdmFsdWVzIHdpbGwgYmUgYXBwbGllZCBzbW9vdGhseSwgaS4gZS4gYWxsb3cgdGhlIHZpZXcgdG8gZXhjZWVkIHNsaWdodGx5XG4gKiB0aGUgZ2l2ZW4gcmVzb2x1dGlvbiBvciB6b29tIGJvdW5kcy5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3Nob3dGdWxsRXh0ZW50PWZhbHNlXSBBbGxvdyB0aGUgdmlldyB0byBiZSB6b29tZWQgb3V0IHRvXG4gKiBzaG93IHRoZSBmdWxsIGNvbmZpZ3VyZWQgZXh0ZW50LiBCeSBkZWZhdWx0LCB3aGVuIGEgdmlldyBpcyBjb25maWd1cmVkIHdpdGggYW5cbiAqIGV4dGVudCwgdXNlcnMgd2lsbCBub3QgYmUgYWJsZSB0byB6b29tIG91dCBzbyB0aGUgdmlld3BvcnQgZXhjZWVkcyB0aGUgZXh0ZW50IGluXG4gKiBlaXRoZXIgZGltZW5zaW9uLiBUaGlzIG1lYW5zIHRoZSBmdWxsIGV4dGVudCBtYXkgbm90IGJlIHZpc2libGUgaWYgdGhlIHZpZXdwb3J0XG4gKiBpcyB0YWxsZXIgb3Igd2lkZXIgdGhhbiB0aGUgYXNwZWN0IHJhdGlvIG9mIHRoZSBjb25maWd1cmVkIGV4dGVudC4gSWZcbiAqIHNob3dGdWxsRXh0ZW50IGlzIHRydWUsIHRoZSB1c2VyIHdpbGwgYmUgYWJsZSB0byB6b29tIG91dCBzbyB0aGF0IHRoZSB2aWV3cG9ydFxuICogZXhjZWVkcyB0aGUgaGVpZ2h0IG9yIHdpZHRoIG9mIHRoZSBjb25maWd1cmVkIGV4dGVudCwgYnV0IG5vdCBib3RoLCBhbGxvd2luZyB0aGVcbiAqIGZ1bGwgZXh0ZW50IHRvIGJlIHNob3duLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL3Byb2ouanNcIikuUHJvamVjdGlvbkxpa2V9IFtwcm9qZWN0aW9uPSdFUFNHOjM4NTcnXSBUaGVcbiAqIHByb2plY3Rpb24uIFRoZSBkZWZhdWx0IGlzIFNwaGVyaWNhbCBNZXJjYXRvci5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbcmVzb2x1dGlvbl0gVGhlIGluaXRpYWwgcmVzb2x1dGlvbiBmb3IgdGhlIHZpZXcuIFRoZVxuICogdW5pdHMgYXJlIGBwcm9qZWN0aW9uYCB1bml0cyBwZXIgcGl4ZWwgKGUuZy4gbWV0ZXJzIHBlciBwaXhlbCkuIEFuXG4gKiBhbHRlcm5hdGl2ZSB0byBzZXR0aW5nIHRoaXMgaXMgdG8gc2V0IGB6b29tYC4gTGF5ZXIgc291cmNlcyB3aWxsIG5vdCBiZVxuICogZmV0Y2hlZCBpZiBuZWl0aGVyIHRoaXMgbm9yIGB6b29tYCBhcmUgZGVmaW5lZCwgYnV0IHRoZXkgY2FuIGJlIHNldCBsYXRlclxuICogd2l0aCB7QGxpbmsgI3NldFpvb219IG9yIHtAbGluayAjc2V0UmVzb2x1dGlvbn0uXG4gKiBAcHJvcGVydHkge0FycmF5PG51bWJlcj59IFtyZXNvbHV0aW9uc10gUmVzb2x1dGlvbnMgdGhhdCBkZXRlcm1pbmUgdGhlXG4gKiB6b29tIGxldmVscyBpZiBzcGVjaWZpZWQuIFRoZSBpbmRleCBpbiB0aGUgYXJyYXkgY29ycmVzcG9uZHMgdG8gdGhlIHpvb20gbGV2ZWwsXG4gKiB0aGVyZWZvcmUgdGhlIHJlc29sdXRpb24gdmFsdWVzIGhhdmUgdG8gYmUgaW4gZGVzY2VuZGluZyBvcmRlci4gSXQgYWxzbyBjb25zdHJhaW5zXG4gKiB0aGUgcmVzb2x1dGlvbiBieSB0aGUgbWluaW11bSBhbmQgbWF4aW11bSB2YWx1ZS4gSWYgc2V0IHRoZSBgbWF4UmVzb2x1dGlvbmAsXG4gKiBgbWluUmVzb2x1dGlvbmAsIGBtaW5ab29tYCwgYG1heFpvb21gLCBhbmQgYHpvb21GYWN0b3JgIG9wdGlvbnMgYXJlIGlnbm9yZWQuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3JvdGF0aW9uPTBdIFRoZSBpbml0aWFsIHJvdGF0aW9uIGZvciB0aGUgdmlldyBpbiByYWRpYW5zXG4gKiAocG9zaXRpdmUgcm90YXRpb24gY2xvY2t3aXNlLCAwIG1lYW5zIE5vcnRoKS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbem9vbV0gT25seSB1c2VkIGlmIGByZXNvbHV0aW9uYCBpcyBub3QgZGVmaW5lZC4gWm9vbVxuICogbGV2ZWwgdXNlZCB0byBjYWxjdWxhdGUgdGhlIGluaXRpYWwgcmVzb2x1dGlvbiBmb3IgdGhlIHZpZXcuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3pvb21GYWN0b3I9Ml0gVGhlIHpvb20gZmFjdG9yIHVzZWQgdG8gY29tcHV0ZSB0aGVcbiAqIGNvcnJlc3BvbmRpbmcgcmVzb2x1dGlvbi5cbiAqIEBwcm9wZXJ0eSB7IUFycmF5PG51bWJlcj59IFtwYWRkaW5nPVswLCAwLCAwLCAwXV0gUGFkZGluZyAoaW4gY3NzIHBpeGVscykuXG4gKiBJZiB0aGUgbWFwIHZpZXdwb3J0IGlzIHBhcnRpYWxseSBjb3ZlcmVkIHdpdGggb3RoZXIgY29udGVudCAob3ZlcmxheXMpIGFsb25nXG4gKiBpdHMgZWRnZXMsIHRoaXMgc2V0dGluZyBhbGxvd3MgdG8gc2hpZnQgdGhlIGNlbnRlciBvZiB0aGUgdmlld3BvcnQgYXdheSBmcm9tXG4gKiB0aGF0IGNvbnRlbnQuIFRoZSBvcmRlciBvZiB0aGUgdmFsdWVzIGlzIHRvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdC5cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEFuaW1hdGlvbk9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IFtjZW50ZXJdIFRoZSBjZW50ZXIgb2YgdGhlIHZpZXcgYXQgdGhlIGVuZCBvZlxuICogdGhlIGFuaW1hdGlvbi5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbem9vbV0gVGhlIHpvb20gbGV2ZWwgb2YgdGhlIHZpZXcgYXQgdGhlIGVuZCBvZiB0aGVcbiAqIGFuaW1hdGlvbi4gVGhpcyB0YWtlcyBwcmVjZWRlbmNlIG92ZXIgYHJlc29sdXRpb25gLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtyZXNvbHV0aW9uXSBUaGUgcmVzb2x1dGlvbiBvZiB0aGUgdmlldyBhdCB0aGUgZW5kXG4gKiBvZiB0aGUgYW5pbWF0aW9uLiAgSWYgYHpvb21gIGlzIGFsc28gcHJvdmlkZWQsIHRoaXMgb3B0aW9uIHdpbGwgYmUgaWdub3JlZC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbcm90YXRpb25dIFRoZSByb3RhdGlvbiBvZiB0aGUgdmlldyBhdCB0aGUgZW5kIG9mXG4gKiB0aGUgYW5pbWF0aW9uLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gW2FuY2hvcl0gT3B0aW9uYWwgYW5jaG9yIHRvIHJlbWFpbiBmaXhlZFxuICogZHVyaW5nIGEgcm90YXRpb24gb3IgcmVzb2x1dGlvbiBhbmltYXRpb24uXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2R1cmF0aW9uPTEwMDBdIFRoZSBkdXJhdGlvbiBvZiB0aGUgYW5pbWF0aW9uIGluIG1pbGxpc2Vjb25kcy5cbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb24obnVtYmVyKTpudW1iZXJ9IFtlYXNpbmddIFRoZSBlYXNpbmcgZnVuY3Rpb24gdXNlZFxuICogZHVyaW5nIHRoZSBhbmltYXRpb24gKGRlZmF1bHRzIHRvIHtAbGluayBtb2R1bGU6b2wvZWFzaW5nLmluQW5kT3V0fSkuXG4gKiBUaGUgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgZm9yIGVhY2ggZnJhbWUgd2l0aCBhIG51bWJlciByZXByZXNlbnRpbmcgYVxuICogZnJhY3Rpb24gb2YgdGhlIGFuaW1hdGlvbidzIGR1cmF0aW9uLiAgVGhlIGZ1bmN0aW9uIHNob3VsZCByZXR1cm4gYSBudW1iZXJcbiAqIGJldHdlZW4gMCBhbmQgMSByZXByZXNlbnRpbmcgdGhlIHByb2dyZXNzIHRvd2FyZCB0aGUgZGVzdGluYXRpb24gc3RhdGUuXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBTdGF0ZVxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gY2VudGVyIENlbnRlciAoaW4gdmlldyBwcm9qZWN0aW9uIGNvb3JkaW5hdGVzKS5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi9wcm9qL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdH0gcHJvamVjdGlvbiBQcm9qZWN0aW9uLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IHJlc29sdXRpb24gUmVzb2x1dGlvbi5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IFtuZXh0Q2VudGVyXSBUaGUgbmV4dCBjZW50ZXIgZHVyaW5nIGFuIGFuaW1hdGlvbiBzZXJpZXMuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW25leHRSZXNvbHV0aW9uXSBUaGUgbmV4dCByZXNvbHV0aW9uIGR1cmluZyBhbiBhbmltYXRpb24gc2VyaWVzLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtuZXh0Um90YXRpb25dIFRoZSBuZXh0IHJvdGF0aW9uIGR1cmluZyBhbiBhbmltYXRpb24gc2VyaWVzLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IHJvdGF0aW9uIFJvdGF0aW9uLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IHpvb20gWm9vbS5cbiAqL1xuXG4vKipcbiAqIExpa2Uge0BsaW5rIGltcG9ydChcIi4vTWFwLmpzXCIpLkZyYW1lU3RhdGV9LCBidXQganVzdCBgdmlld1N0YXRlYCBhbmQgYGV4dGVudGAuXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBWaWV3U3RhdGVMYXllclN0YXRlRXh0ZW50XG4gKiBAcHJvcGVydHkge1N0YXRlfSB2aWV3U3RhdGUgVmlldyBzdGF0ZS5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi9leHRlbnQuanNcIikuRXh0ZW50fSBleHRlbnQgRXh0ZW50IChpbiB1c2VyIHByb2plY3Rpb24gY29vcmRpbmF0ZXMpLlxuICogQHByb3BlcnR5IHtBcnJheTxpbXBvcnQoXCIuL2xheWVyL0xheWVyLmpzXCIpLlN0YXRlPn0gW2xheWVyU3RhdGVzQXJyYXldIExheWVyIHN0YXRlcy5cbiAqL1xuXG4vKipcbiAqIERlZmF1bHQgbWluIHpvb20gbGV2ZWwgZm9yIHRoZSBtYXAgdmlldy5cbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmNvbnN0IERFRkFVTFRfTUlOX1pPT00gPSAwO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoXCIuL09iamVjdEV2ZW50VHlwZVwiKS5UeXBlc3wnY2hhbmdlOmNlbnRlcid8J2NoYW5nZTpyZXNvbHV0aW9uJ3wnY2hhbmdlOnJvdGF0aW9uJ30gVmlld09iamVjdEV2ZW50VHlwZXNcbiAqL1xuXG4vKioqXG4gKiBAdGVtcGxhdGUgUmV0dXJuXG4gKiBAdHlwZWRlZiB7aW1wb3J0KFwiLi9PYnNlcnZhYmxlXCIpLk9uU2lnbmF0dXJlPGltcG9ydChcIi4vT2JzZXJ2YWJsZVwiKS5FdmVudFR5cGVzLCBpbXBvcnQoXCIuL2V2ZW50cy9FdmVudC5qc1wiKS5kZWZhdWx0LCBSZXR1cm4+ICZcbiAqICAgaW1wb3J0KFwiLi9PYnNlcnZhYmxlXCIpLk9uU2lnbmF0dXJlPFZpZXdPYmplY3RFdmVudFR5cGVzLCBpbXBvcnQoXCIuL09iamVjdFwiKS5PYmplY3RFdmVudCwgUmV0dXJuPiAmXG4gKiAgIGltcG9ydChcIi4vT2JzZXJ2YWJsZVwiKS5Db21iaW5lZE9uU2lnbmF0dXJlPGltcG9ydChcIi4vT2JzZXJ2YWJsZVwiKS5FdmVudFR5cGVzfFZpZXdPYmplY3RFdmVudFR5cGVzLCBSZXR1cm4+fSBWaWV3T25TaWduYXR1cmVcbiAqL1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEEgVmlldyBvYmplY3QgcmVwcmVzZW50cyBhIHNpbXBsZSAyRCB2aWV3IG9mIHRoZSBtYXAuXG4gKlxuICogVGhpcyBpcyB0aGUgb2JqZWN0IHRvIGFjdCB1cG9uIHRvIGNoYW5nZSB0aGUgY2VudGVyLCByZXNvbHV0aW9uLFxuICogYW5kIHJvdGF0aW9uIG9mIHRoZSBtYXAuXG4gKlxuICogQSBWaWV3IGhhcyBhIGBwcm9qZWN0aW9uYC4gVGhlIHByb2plY3Rpb24gZGV0ZXJtaW5lcyB0aGVcbiAqIGNvb3JkaW5hdGUgc3lzdGVtIG9mIHRoZSBjZW50ZXIsIGFuZCBpdHMgdW5pdHMgZGV0ZXJtaW5lIHRoZSB1bml0cyBvZiB0aGVcbiAqIHJlc29sdXRpb24gKHByb2plY3Rpb24gdW5pdHMgcGVyIHBpeGVsKS4gVGhlIGRlZmF1bHQgcHJvamVjdGlvbiBpc1xuICogV2ViIE1lcmNhdG9yIChFUFNHOjM4NTcpLlxuICpcbiAqICMjIyBUaGUgdmlldyBzdGF0ZXNcbiAqXG4gKiBBIFZpZXcgaXMgZGV0ZXJtaW5lZCBieSB0aHJlZSBzdGF0ZXM6IGBjZW50ZXJgLCBgcmVzb2x1dGlvbmAsXG4gKiBhbmQgYHJvdGF0aW9uYC4gRWFjaCBzdGF0ZSBoYXMgYSBjb3JyZXNwb25kaW5nIGdldHRlciBhbmQgc2V0dGVyLCBlLmcuXG4gKiBgZ2V0Q2VudGVyYCBhbmQgYHNldENlbnRlcmAgZm9yIHRoZSBgY2VudGVyYCBzdGF0ZS5cbiAqXG4gKiBUaGUgYHpvb21gIHN0YXRlIGlzIGFjdHVhbGx5IG5vdCBzYXZlZCBvbiB0aGUgdmlldzogYWxsIGNvbXB1dGF0aW9uc1xuICogaW50ZXJuYWxseSB1c2UgdGhlIGByZXNvbHV0aW9uYCBzdGF0ZS4gU3RpbGwsIHRoZSBgc2V0Wm9vbWAgYW5kIGBnZXRab29tYFxuICogbWV0aG9kcyBhcmUgYXZhaWxhYmxlLCBhcyB3ZWxsIGFzIGBnZXRSZXNvbHV0aW9uRm9yWm9vbWAgYW5kXG4gKiBgZ2V0Wm9vbUZvclJlc29sdXRpb25gIHRvIHN3aXRjaCBmcm9tIG9uZSBzeXN0ZW0gdG8gdGhlIG90aGVyLlxuICpcbiAqICMjIyBUaGUgY29uc3RyYWludHNcbiAqXG4gKiBgc2V0Q2VudGVyYCwgYHNldFJlc29sdXRpb25gIGFuZCBgc2V0Um90YXRpb25gIGNhbiBiZSB1c2VkIHRvIGNoYW5nZSB0aGVcbiAqIHN0YXRlcyBvZiB0aGUgdmlldywgYnV0IGFueSBjb25zdHJhaW50IGRlZmluZWQgaW4gdGhlIGNvbnN0cnVjdG9yIHdpbGxcbiAqIGJlIGFwcGxpZWQgYWxvbmcgdGhlIHdheS5cbiAqXG4gKiBBIFZpZXcgb2JqZWN0IGNhbiBoYXZlIGEgKnJlc29sdXRpb24gY29uc3RyYWludCosIGEgKnJvdGF0aW9uIGNvbnN0cmFpbnQqXG4gKiBhbmQgYSAqY2VudGVyIGNvbnN0cmFpbnQqLlxuICpcbiAqIFRoZSAqcmVzb2x1dGlvbiBjb25zdHJhaW50KiB0eXBpY2FsbHkgcmVzdHJpY3RzIG1pbi9tYXggdmFsdWVzIGFuZFxuICogc25hcHMgdG8gc3BlY2lmaWMgcmVzb2x1dGlvbnMuIEl0IGlzIGRldGVybWluZWQgYnkgdGhlIGZvbGxvd2luZ1xuICogb3B0aW9uczogYHJlc29sdXRpb25zYCwgYG1heFJlc29sdXRpb25gLCBgbWF4Wm9vbWAgYW5kIGB6b29tRmFjdG9yYC5cbiAqIElmIGByZXNvbHV0aW9uc2AgaXMgc2V0LCB0aGUgb3RoZXIgdGhyZWUgb3B0aW9ucyBhcmUgaWdub3JlZC4gU2VlXG4gKiBkb2N1bWVudGF0aW9uIGZvciBlYWNoIG9wdGlvbiBmb3IgbW9yZSBpbmZvcm1hdGlvbi4gQnkgZGVmYXVsdCwgdGhlIHZpZXdcbiAqIG9ubHkgaGFzIGEgbWluL21heCByZXN0cmljdGlvbiBhbmQgYWxsb3cgaW50ZXJtZWRpYXJ5IHpvb20gbGV2ZWxzIHdoZW5cbiAqIHBpbmNoLXpvb21pbmcgZm9yIGV4YW1wbGUuXG4gKlxuICogVGhlICpyb3RhdGlvbiBjb25zdHJhaW50KiBzbmFwcyB0byBzcGVjaWZpYyBhbmdsZXMuIEl0IGlzIGRldGVybWluZWRcbiAqIGJ5IHRoZSBmb2xsb3dpbmcgb3B0aW9uczogYGVuYWJsZVJvdGF0aW9uYCBhbmQgYGNvbnN0cmFpblJvdGF0aW9uYC5cbiAqIEJ5IGRlZmF1bHQgcm90YXRpb24gaXMgYWxsb3dlZCBhbmQgaXRzIHZhbHVlIGlzIHNuYXBwZWQgdG8gemVybyB3aGVuIGFwcHJvYWNoaW5nIHRoZVxuICogaG9yaXpvbnRhbC5cbiAqXG4gKiBUaGUgKmNlbnRlciBjb25zdHJhaW50KiBpcyBkZXRlcm1pbmVkIGJ5IHRoZSBgZXh0ZW50YCBvcHRpb24uIEJ5XG4gKiBkZWZhdWx0IHRoZSB2aWV3IGNlbnRlciBpcyBub3QgY29uc3RyYWluZWQgYXQgYWxsLlxuICpcbiAqICMjIyBDaGFuZ2luZyB0aGUgdmlldyBzdGF0ZVxuICpcbiAqIEl0IGlzIGltcG9ydGFudCB0byBub3RlIHRoYXQgYHNldFpvb21gLCBgc2V0UmVzb2x1dGlvbmAsIGBzZXRDZW50ZXJgIGFuZFxuICogYHNldFJvdGF0aW9uYCBhcmUgc3ViamVjdCB0byB0aGUgYWJvdmUgbWVudGlvbmVkIGNvbnN0cmFpbnRzLiBBcyBzdWNoLCBpdFxuICogbWF5IHNvbWV0aW1lcyBub3QgYmUgcG9zc2libGUgdG8ga25vdyBpbiBhZHZhbmNlIHRoZSByZXN1bHRpbmcgc3RhdGUgb2YgdGhlXG4gKiBWaWV3LiBGb3IgZXhhbXBsZSwgY2FsbGluZyBgc2V0UmVzb2x1dGlvbigxMClgIGRvZXMgbm90IGd1YXJhbnRlZSB0aGF0XG4gKiBgZ2V0UmVzb2x1dGlvbigpYCB3aWxsIHJldHVybiBgMTBgLlxuICpcbiAqIEEgY29uc2VxdWVuY2Ugb2YgdGhpcyBpcyB0aGF0LCB3aGVuIGFwcGx5aW5nIGEgZGVsdGEgb24gdGhlIHZpZXcgc3RhdGUsIG9uZVxuICogc2hvdWxkIHVzZSBgYWRqdXN0Q2VudGVyYCwgYGFkanVzdFJvdGF0aW9uYCwgYGFkanVzdFpvb21gIGFuZCBgYWRqdXN0UmVzb2x1dGlvbmBcbiAqIHJhdGhlciB0aGFuIHRoZSBjb3JyZXNwb25kaW5nIHNldHRlcnMuIFRoaXMgd2lsbCBsZXQgdmlldyBkbyBpdHMgaW50ZXJuYWxcbiAqIGNvbXB1dGF0aW9ucy4gQmVzaWRlcywgdGhlIGBhZGp1c3QqYCBtZXRob2RzIGFsc28gdGFrZSBhbiBgYW5jaG9yYFxuICogYXJndW1lbnQgd2hpY2ggYWxsb3dzIHNwZWNpZnlpbmcgYW4gb3JpZ2luIGZvciB0aGUgdHJhbnNmb3JtYXRpb24uXG4gKlxuICogIyMjIEludGVyYWN0aW5nIHdpdGggdGhlIHZpZXdcbiAqXG4gKiBWaWV3IGNvbnN0cmFpbnRzIGFyZSB1c3VhbGx5IG9ubHkgYXBwbGllZCB3aGVuIHRoZSB2aWV3IGlzICphdCByZXN0KiwgbWVhbmluZyB0aGF0XG4gKiBubyBpbnRlcmFjdGlvbiBvciBhbmltYXRpb24gaXMgb25nb2luZy4gQXMgc3VjaCwgaWYgdGhlIHVzZXIgcHV0cyB0aGUgdmlldyBpbiBhXG4gKiBzdGF0ZSB0aGF0IGlzIG5vdCBlcXVpdmFsZW50IHRvIGEgY29uc3RyYWluZWQgb25lIChlLmcuIHJvdGF0aW5nIHRoZSB2aWV3IHdoZW5cbiAqIHRoZSBzbmFwIGFuZ2xlIGlzIDApLCBhbiBhbmltYXRpb24gd2lsbCBiZSB0cmlnZ2VyZWQgYXQgdGhlIGludGVyYWN0aW9uIGVuZCB0b1xuICogcHV0IGJhY2sgdGhlIHZpZXcgdG8gYSBzdGFibGUgc3RhdGU7XG4gKlxuICogQGFwaVxuICovXG5jbGFzcyBWaWV3IGV4dGVuZHMgQmFzZU9iamVjdCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1ZpZXdPcHRpb25zfSBbb3B0aW9uc10gVmlldyBvcHRpb25zLlxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHN1cGVyKCk7XG5cbiAgICAvKioqXG4gICAgICogQHR5cGUge1ZpZXdPblNpZ25hdHVyZTxpbXBvcnQoXCIuL2V2ZW50c1wiKS5FdmVudHNLZXk+fVxuICAgICAqL1xuICAgIHRoaXMub247XG5cbiAgICAvKioqXG4gICAgICogQHR5cGUge1ZpZXdPblNpZ25hdHVyZTxpbXBvcnQoXCIuL2V2ZW50c1wiKS5FdmVudHNLZXk+fVxuICAgICAqL1xuICAgIHRoaXMub25jZTtcblxuICAgIC8qKipcbiAgICAgKiBAdHlwZSB7Vmlld09uU2lnbmF0dXJlPHZvaWQ+fVxuICAgICAqL1xuICAgIHRoaXMudW47XG5cbiAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtBcnJheTxudW1iZXI+fVxuICAgICAqL1xuICAgIHRoaXMuaGludHNfID0gWzAsIDBdO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7QXJyYXk8QXJyYXk8QW5pbWF0aW9uPj59XG4gICAgICovXG4gICAgdGhpcy5hbmltYXRpb25zXyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLnVwZGF0ZUFuaW1hdGlvbktleV87XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBjb25zdFxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuL3Byb2ovUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0fVxuICAgICAqL1xuICAgIHRoaXMucHJvamVjdGlvbl8gPSBjcmVhdGVQcm9qZWN0aW9uKG9wdGlvbnMucHJvamVjdGlvbiwgJ0VQU0c6Mzg1NycpO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi9zaXplLmpzXCIpLlNpemV9XG4gICAgICovXG4gICAgdGhpcy52aWV3cG9ydFNpemVfID0gWzEwMCwgMTAwXTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLnRhcmdldENlbnRlcl8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLnRhcmdldFJlc29sdXRpb25fO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLnRhcmdldFJvdGF0aW9uXztcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfVxuICAgICAqL1xuICAgIHRoaXMubmV4dENlbnRlcl8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubmV4dFJlc29sdXRpb25fO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubmV4dFJvdGF0aW9uXztcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLmNhbmNlbEFuY2hvcl8gPSB1bmRlZmluZWQ7XG5cbiAgICBpZiAob3B0aW9ucy5wcm9qZWN0aW9uKSB7XG4gICAgICBkaXNhYmxlQ29vcmRpbmF0ZVdhcm5pbmcoKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuY2VudGVyKSB7XG4gICAgICBvcHRpb25zLmNlbnRlciA9IGZyb21Vc2VyQ29vcmRpbmF0ZShvcHRpb25zLmNlbnRlciwgdGhpcy5wcm9qZWN0aW9uXyk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmV4dGVudCkge1xuICAgICAgb3B0aW9ucy5leHRlbnQgPSBmcm9tVXNlckV4dGVudChvcHRpb25zLmV4dGVudCwgdGhpcy5wcm9qZWN0aW9uXyk7XG4gICAgfVxuXG4gICAgdGhpcy5hcHBseU9wdGlvbnNfKG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB1cCB0aGUgdmlldyB3aXRoIHRoZSBnaXZlbiBvcHRpb25zLlxuICAgKiBAcGFyYW0ge1ZpZXdPcHRpb25zfSBvcHRpb25zIFZpZXcgb3B0aW9ucy5cbiAgICovXG4gIGFwcGx5T3B0aW9uc18ob3B0aW9ucykge1xuICAgIGNvbnN0IHByb3BlcnRpZXMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBWaWV3UHJvcGVydHkpIHtcbiAgICAgIGRlbGV0ZSBwcm9wZXJ0aWVzW2tleV07XG4gICAgfVxuICAgIHRoaXMuc2V0UHJvcGVydGllcyhwcm9wZXJ0aWVzLCB0cnVlKTtcblxuICAgIGNvbnN0IHJlc29sdXRpb25Db25zdHJhaW50SW5mbyA9IGNyZWF0ZVJlc29sdXRpb25Db25zdHJhaW50KG9wdGlvbnMpO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubWF4UmVzb2x1dGlvbl8gPSByZXNvbHV0aW9uQ29uc3RyYWludEluZm8ubWF4UmVzb2x1dGlvbjtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLm1pblJlc29sdXRpb25fID0gcmVzb2x1dGlvbkNvbnN0cmFpbnRJbmZvLm1pblJlc29sdXRpb247XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy56b29tRmFjdG9yXyA9IHJlc29sdXRpb25Db25zdHJhaW50SW5mby56b29tRmFjdG9yO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7QXJyYXk8bnVtYmVyPnx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5yZXNvbHV0aW9uc18gPSBvcHRpb25zLnJlc29sdXRpb25zO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge0FycmF5PG51bWJlcj58dW5kZWZpbmVkfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5wYWRkaW5nXyA9IG9wdGlvbnMucGFkZGluZztcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLm1pblpvb21fID0gcmVzb2x1dGlvbkNvbnN0cmFpbnRJbmZvLm1pblpvb207XG5cbiAgICBjb25zdCBjZW50ZXJDb25zdHJhaW50ID0gY3JlYXRlQ2VudGVyQ29uc3RyYWludChvcHRpb25zKTtcbiAgICBjb25zdCByZXNvbHV0aW9uQ29uc3RyYWludCA9IHJlc29sdXRpb25Db25zdHJhaW50SW5mby5jb25zdHJhaW50O1xuICAgIGNvbnN0IHJvdGF0aW9uQ29uc3RyYWludCA9IGNyZWF0ZVJvdGF0aW9uQ29uc3RyYWludChvcHRpb25zKTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0NvbnN0cmFpbnRzfVxuICAgICAqL1xuICAgIHRoaXMuY29uc3RyYWludHNfID0ge1xuICAgICAgY2VudGVyOiBjZW50ZXJDb25zdHJhaW50LFxuICAgICAgcmVzb2x1dGlvbjogcmVzb2x1dGlvbkNvbnN0cmFpbnQsXG4gICAgICByb3RhdGlvbjogcm90YXRpb25Db25zdHJhaW50LFxuICAgIH07XG5cbiAgICB0aGlzLnNldFJvdGF0aW9uKG9wdGlvbnMucm90YXRpb24gIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMucm90YXRpb24gOiAwKTtcbiAgICB0aGlzLnNldENlbnRlckludGVybmFsKFxuICAgICAgb3B0aW9ucy5jZW50ZXIgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuY2VudGVyIDogbnVsbFxuICAgICk7XG4gICAgaWYgKG9wdGlvbnMucmVzb2x1dGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLnNldFJlc29sdXRpb24ob3B0aW9ucy5yZXNvbHV0aW9uKTtcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMuem9vbSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLnNldFpvb20ob3B0aW9ucy56b29tKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUGFkZGluZyAoaW4gY3NzIHBpeGVscykuXG4gICAqIElmIHRoZSBtYXAgdmlld3BvcnQgaXMgcGFydGlhbGx5IGNvdmVyZWQgd2l0aCBvdGhlciBjb250ZW50IChvdmVybGF5cykgYWxvbmdcbiAgICogaXRzIGVkZ2VzLCB0aGlzIHNldHRpbmcgYWxsb3dzIHRvIHNoaWZ0IHRoZSBjZW50ZXIgb2YgdGhlIHZpZXdwb3J0IGF3YXkgZnJvbSB0aGF0XG4gICAqIGNvbnRlbnQuIFRoZSBvcmRlciBvZiB0aGUgdmFsdWVzIGluIHRoZSBhcnJheSBpcyB0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnQuXG4gICAqIFRoZSBkZWZhdWx0IGlzIG5vIHBhZGRpbmcsIHdoaWNoIGlzIGVxdWl2YWxlbnQgdG8gYFswLCAwLCAwLCAwXWAuXG4gICAqIEB0eXBlIHtBcnJheTxudW1iZXI+fHVuZGVmaW5lZH1cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0IHBhZGRpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMucGFkZGluZ187XG4gIH1cbiAgc2V0IHBhZGRpbmcocGFkZGluZykge1xuICAgIGxldCBvbGRQYWRkaW5nID0gdGhpcy5wYWRkaW5nXztcbiAgICB0aGlzLnBhZGRpbmdfID0gcGFkZGluZztcbiAgICBjb25zdCBjZW50ZXIgPSB0aGlzLmdldENlbnRlckludGVybmFsKCk7XG4gICAgaWYgKGNlbnRlcikge1xuICAgICAgY29uc3QgbmV3UGFkZGluZyA9IHBhZGRpbmcgfHwgWzAsIDAsIDAsIDBdO1xuICAgICAgb2xkUGFkZGluZyA9IG9sZFBhZGRpbmcgfHwgWzAsIDAsIDAsIDBdO1xuICAgICAgY29uc3QgcmVzb2x1dGlvbiA9IHRoaXMuZ2V0UmVzb2x1dGlvbigpO1xuICAgICAgY29uc3Qgb2Zmc2V0WCA9XG4gICAgICAgIChyZXNvbHV0aW9uIC8gMikgKlxuICAgICAgICAobmV3UGFkZGluZ1szXSAtIG9sZFBhZGRpbmdbM10gKyBvbGRQYWRkaW5nWzFdIC0gbmV3UGFkZGluZ1sxXSk7XG4gICAgICBjb25zdCBvZmZzZXRZID1cbiAgICAgICAgKHJlc29sdXRpb24gLyAyKSAqXG4gICAgICAgIChuZXdQYWRkaW5nWzBdIC0gb2xkUGFkZGluZ1swXSArIG9sZFBhZGRpbmdbMl0gLSBuZXdQYWRkaW5nWzJdKTtcbiAgICAgIHRoaXMuc2V0Q2VudGVySW50ZXJuYWwoW2NlbnRlclswXSArIG9mZnNldFgsIGNlbnRlclsxXSAtIG9mZnNldFldKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IGFuIHVwZGF0ZWQgdmVyc2lvbiBvZiB0aGUgdmlldyBvcHRpb25zIHVzZWQgdG8gY29uc3RydWN0IHRoZSB2aWV3LiAgVGhlXG4gICAqIGN1cnJlbnQgcmVzb2x1dGlvbiAob3Igem9vbSksIGNlbnRlciwgYW5kIHJvdGF0aW9uIGFyZSBhcHBsaWVkIHRvIGFueSBzdG9yZWRcbiAgICogb3B0aW9ucy4gIFRoZSBwcm92aWRlZCBvcHRpb25zIGNhbiBiZSB1c2VkIHRvIGFwcGx5IG5ldyBtaW4vbWF4IHpvb20gb3JcbiAgICogcmVzb2x1dGlvbiBsaW1pdHMuXG4gICAqIEBwYXJhbSB7Vmlld09wdGlvbnN9IG5ld09wdGlvbnMgTmV3IG9wdGlvbnMgdG8gYmUgYXBwbGllZC5cbiAgICogQHJldHVybiB7Vmlld09wdGlvbnN9IE5ldyBvcHRpb25zIHVwZGF0ZWQgd2l0aCB0aGUgY3VycmVudCB2aWV3IHN0YXRlLlxuICAgKi9cbiAgZ2V0VXBkYXRlZE9wdGlvbnNfKG5ld09wdGlvbnMpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5nZXRQcm9wZXJ0aWVzKCk7XG5cbiAgICAvLyBwcmVzZXJ2ZSByZXNvbHV0aW9uIChvciB6b29tKVxuICAgIGlmIChvcHRpb25zLnJlc29sdXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgb3B0aW9ucy5yZXNvbHV0aW9uID0gdGhpcy5nZXRSZXNvbHV0aW9uKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9wdGlvbnMuem9vbSA9IHRoaXMuZ2V0Wm9vbSgpO1xuICAgIH1cblxuICAgIC8vIHByZXNlcnZlIGNlbnRlclxuICAgIG9wdGlvbnMuY2VudGVyID0gdGhpcy5nZXRDZW50ZXJJbnRlcm5hbCgpO1xuXG4gICAgLy8gcHJlc2VydmUgcm90YXRpb25cbiAgICBvcHRpb25zLnJvdGF0aW9uID0gdGhpcy5nZXRSb3RhdGlvbigpO1xuXG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIG5ld09wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFuaW1hdGUgdGhlIHZpZXcuICBUaGUgdmlldydzIGNlbnRlciwgem9vbSAob3IgcmVzb2x1dGlvbiksIGFuZCByb3RhdGlvblxuICAgKiBjYW4gYmUgYW5pbWF0ZWQgZm9yIHNtb290aCB0cmFuc2l0aW9ucyBiZXR3ZWVuIHZpZXcgc3RhdGVzLiAgRm9yIGV4YW1wbGUsXG4gICAqIHRvIGFuaW1hdGUgdGhlIHZpZXcgdG8gYSBuZXcgem9vbSBsZXZlbDpcbiAgICpcbiAgICogICAgIHZpZXcuYW5pbWF0ZSh7em9vbTogdmlldy5nZXRab29tKCkgKyAxfSk7XG4gICAqXG4gICAqIEJ5IGRlZmF1bHQsIHRoZSBhbmltYXRpb24gbGFzdHMgb25lIHNlY29uZCBhbmQgdXNlcyBpbi1hbmQtb3V0IGVhc2luZy4gIFlvdVxuICAgKiBjYW4gY3VzdG9taXplIHRoaXMgYmVoYXZpb3IgYnkgaW5jbHVkaW5nIGBkdXJhdGlvbmAgKGluIG1pbGxpc2Vjb25kcykgYW5kXG4gICAqIGBlYXNpbmdgIG9wdGlvbnMgKHNlZSB7QGxpbmsgbW9kdWxlOm9sL2Vhc2luZ30pLlxuICAgKlxuICAgKiBUbyBjaGFpbiB0b2dldGhlciBtdWx0aXBsZSBhbmltYXRpb25zLCBjYWxsIHRoZSBtZXRob2Qgd2l0aCBtdWx0aXBsZVxuICAgKiBhbmltYXRpb24gb2JqZWN0cy4gIEZvciBleGFtcGxlLCB0byBmaXJzdCB6b29tIGFuZCB0aGVuIHBhbjpcbiAgICpcbiAgICogICAgIHZpZXcuYW5pbWF0ZSh7em9vbTogMTB9LCB7Y2VudGVyOiBbMCwgMF19KTtcbiAgICpcbiAgICogSWYgeW91IHByb3ZpZGUgYSBmdW5jdGlvbiBhcyB0aGUgbGFzdCBhcmd1bWVudCB0byB0aGUgYW5pbWF0ZSBtZXRob2QsIGl0XG4gICAqIHdpbGwgZ2V0IGNhbGxlZCBhdCB0aGUgZW5kIG9mIGFuIGFuaW1hdGlvbiBzZXJpZXMuICBUaGUgY2FsbGJhY2sgd2lsbCBiZVxuICAgKiBjYWxsZWQgd2l0aCBgdHJ1ZWAgaWYgdGhlIGFuaW1hdGlvbiBzZXJpZXMgY29tcGxldGVkIG9uIGl0cyBvd24gb3IgYGZhbHNlYFxuICAgKiBpZiBpdCB3YXMgY2FuY2VsbGVkLlxuICAgKlxuICAgKiBBbmltYXRpb25zIGFyZSBjYW5jZWxsZWQgYnkgdXNlciBpbnRlcmFjdGlvbnMgKGUuZy4gZHJhZ2dpbmcgdGhlIG1hcCkgb3IgYnlcbiAgICogY2FsbGluZyBgdmlldy5zZXRDZW50ZXIoKWAsIGB2aWV3LnNldFJlc29sdXRpb24oKWAsIG9yIGB2aWV3LnNldFJvdGF0aW9uKClgXG4gICAqIChvciBhbm90aGVyIG1ldGhvZCB0aGF0IGNhbGxzIG9uZSBvZiB0aGVzZSkuXG4gICAqXG4gICAqIEBwYXJhbSB7Li4uKEFuaW1hdGlvbk9wdGlvbnN8ZnVuY3Rpb24oYm9vbGVhbik6IHZvaWQpfSB2YXJfYXJncyBBbmltYXRpb25cbiAgICogICAgIG9wdGlvbnMuICBNdWx0aXBsZSBhbmltYXRpb25zIGNhbiBiZSBydW4gaW4gc2VyaWVzIGJ5IHBhc3NpbmcgbXVsdGlwbGVcbiAgICogICAgIG9wdGlvbnMgb2JqZWN0cy4gIFRvIHJ1biBtdWx0aXBsZSBhbmltYXRpb25zIGluIHBhcmFsbGVsLCBjYWxsIHRoZSBtZXRob2RcbiAgICogICAgIG11bHRpcGxlIHRpbWVzLiAgQW4gb3B0aW9uYWwgY2FsbGJhY2sgY2FuIGJlIHByb3ZpZGVkIGFzIGEgZmluYWxcbiAgICogICAgIGFyZ3VtZW50LiAgVGhlIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIHdpdGggYSBib29sZWFuIGluZGljYXRpbmcgd2hldGhlclxuICAgKiAgICAgdGhlIGFuaW1hdGlvbiBjb21wbGV0ZWQgd2l0aG91dCBiZWluZyBjYW5jZWxsZWQuXG4gICAqIEBhcGlcbiAgICovXG4gIGFuaW1hdGUodmFyX2FyZ3MpIHtcbiAgICBpZiAodGhpcy5pc0RlZigpICYmICF0aGlzLmdldEFuaW1hdGluZygpKSB7XG4gICAgICB0aGlzLnJlc29sdmVDb25zdHJhaW50cygwKTtcbiAgICB9XG4gICAgY29uc3QgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyArK2kpIHtcbiAgICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzW2ldO1xuICAgICAgaWYgKG9wdGlvbnMuY2VudGVyKSB7XG4gICAgICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKTtcbiAgICAgICAgb3B0aW9ucy5jZW50ZXIgPSBmcm9tVXNlckNvb3JkaW5hdGUoXG4gICAgICAgICAgb3B0aW9ucy5jZW50ZXIsXG4gICAgICAgICAgdGhpcy5nZXRQcm9qZWN0aW9uKClcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLmFuY2hvcikge1xuICAgICAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyk7XG4gICAgICAgIG9wdGlvbnMuYW5jaG9yID0gZnJvbVVzZXJDb29yZGluYXRlKFxuICAgICAgICAgIG9wdGlvbnMuYW5jaG9yLFxuICAgICAgICAgIHRoaXMuZ2V0UHJvamVjdGlvbigpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBhcmdzW2ldID0gb3B0aW9ucztcbiAgICB9XG4gICAgdGhpcy5hbmltYXRlSW50ZXJuYWwuYXBwbHkodGhpcywgYXJncyk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHsuLi4oQW5pbWF0aW9uT3B0aW9uc3xmdW5jdGlvbihib29sZWFuKTogdm9pZCl9IHZhcl9hcmdzIEFuaW1hdGlvbiBvcHRpb25zLlxuICAgKi9cbiAgYW5pbWF0ZUludGVybmFsKHZhcl9hcmdzKSB7XG4gICAgbGV0IGFuaW1hdGlvbkNvdW50ID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICBsZXQgY2FsbGJhY2s7XG4gICAgaWYgKFxuICAgICAgYW5pbWF0aW9uQ291bnQgPiAxICYmXG4gICAgICB0eXBlb2YgYXJndW1lbnRzW2FuaW1hdGlvbkNvdW50IC0gMV0gPT09ICdmdW5jdGlvbidcbiAgICApIHtcbiAgICAgIGNhbGxiYWNrID0gYXJndW1lbnRzW2FuaW1hdGlvbkNvdW50IC0gMV07XG4gICAgICAtLWFuaW1hdGlvbkNvdW50O1xuICAgIH1cblxuICAgIGxldCBpID0gMDtcbiAgICBmb3IgKDsgaSA8IGFuaW1hdGlvbkNvdW50ICYmICF0aGlzLmlzRGVmKCk7ICsraSkge1xuICAgICAgLy8gaWYgdmlldyBwcm9wZXJ0aWVzIGFyZSBub3QgeWV0IHNldCwgc2hvcnRjdXQgdG8gdGhlIGZpbmFsIHN0YXRlXG4gICAgICBjb25zdCBzdGF0ZSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIGlmIChzdGF0ZS5jZW50ZXIpIHtcbiAgICAgICAgdGhpcy5zZXRDZW50ZXJJbnRlcm5hbChzdGF0ZS5jZW50ZXIpO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXRlLnpvb20gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLnNldFpvb20oc3RhdGUuem9vbSk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLnJlc29sdXRpb24pIHtcbiAgICAgICAgdGhpcy5zZXRSZXNvbHV0aW9uKHN0YXRlLnJlc29sdXRpb24pO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXRlLnJvdGF0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5zZXRSb3RhdGlvbihzdGF0ZS5yb3RhdGlvbik7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpID09PSBhbmltYXRpb25Db3VudCkge1xuICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIGFuaW1hdGlvbkNhbGxiYWNrKGNhbGxiYWNrLCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgc3RhcnQgPSBEYXRlLm5vdygpO1xuICAgIGxldCBjZW50ZXIgPSB0aGlzLnRhcmdldENlbnRlcl8uc2xpY2UoKTtcbiAgICBsZXQgcmVzb2x1dGlvbiA9IHRoaXMudGFyZ2V0UmVzb2x1dGlvbl87XG4gICAgbGV0IHJvdGF0aW9uID0gdGhpcy50YXJnZXRSb3RhdGlvbl87XG4gICAgY29uc3Qgc2VyaWVzID0gW107XG4gICAgZm9yICg7IGkgPCBhbmltYXRpb25Db3VudDsgKytpKSB7XG4gICAgICBjb25zdCBvcHRpb25zID0gLyoqIEB0eXBlIHtBbmltYXRpb25PcHRpb25zfSAqLyAoYXJndW1lbnRzW2ldKTtcblxuICAgICAgY29uc3QgYW5pbWF0aW9uID0ge1xuICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgIGNvbXBsZXRlOiBmYWxzZSxcbiAgICAgICAgYW5jaG9yOiBvcHRpb25zLmFuY2hvcixcbiAgICAgICAgZHVyYXRpb246IG9wdGlvbnMuZHVyYXRpb24gIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZHVyYXRpb24gOiAxMDAwLFxuICAgICAgICBlYXNpbmc6IG9wdGlvbnMuZWFzaW5nIHx8IGluQW5kT3V0LFxuICAgICAgICBjYWxsYmFjazogY2FsbGJhY2ssXG4gICAgICB9O1xuXG4gICAgICBpZiAob3B0aW9ucy5jZW50ZXIpIHtcbiAgICAgICAgYW5pbWF0aW9uLnNvdXJjZUNlbnRlciA9IGNlbnRlcjtcbiAgICAgICAgYW5pbWF0aW9uLnRhcmdldENlbnRlciA9IG9wdGlvbnMuY2VudGVyLnNsaWNlKCk7XG4gICAgICAgIGNlbnRlciA9IGFuaW1hdGlvbi50YXJnZXRDZW50ZXI7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLnpvb20gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBhbmltYXRpb24uc291cmNlUmVzb2x1dGlvbiA9IHJlc29sdXRpb247XG4gICAgICAgIGFuaW1hdGlvbi50YXJnZXRSZXNvbHV0aW9uID0gdGhpcy5nZXRSZXNvbHV0aW9uRm9yWm9vbShvcHRpb25zLnpvb20pO1xuICAgICAgICByZXNvbHV0aW9uID0gYW5pbWF0aW9uLnRhcmdldFJlc29sdXRpb247XG4gICAgICB9IGVsc2UgaWYgKG9wdGlvbnMucmVzb2x1dGlvbikge1xuICAgICAgICBhbmltYXRpb24uc291cmNlUmVzb2x1dGlvbiA9IHJlc29sdXRpb247XG4gICAgICAgIGFuaW1hdGlvbi50YXJnZXRSZXNvbHV0aW9uID0gb3B0aW9ucy5yZXNvbHV0aW9uO1xuICAgICAgICByZXNvbHV0aW9uID0gYW5pbWF0aW9uLnRhcmdldFJlc29sdXRpb247XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLnJvdGF0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgYW5pbWF0aW9uLnNvdXJjZVJvdGF0aW9uID0gcm90YXRpb247XG4gICAgICAgIGNvbnN0IGRlbHRhID1cbiAgICAgICAgICBtb2R1bG8ob3B0aW9ucy5yb3RhdGlvbiAtIHJvdGF0aW9uICsgTWF0aC5QSSwgMiAqIE1hdGguUEkpIC0gTWF0aC5QSTtcbiAgICAgICAgYW5pbWF0aW9uLnRhcmdldFJvdGF0aW9uID0gcm90YXRpb24gKyBkZWx0YTtcbiAgICAgICAgcm90YXRpb24gPSBhbmltYXRpb24udGFyZ2V0Um90YXRpb247XG4gICAgICB9XG5cbiAgICAgIC8vIGNoZWNrIGlmIGFuaW1hdGlvbiBpcyBhIG5vLW9wXG4gICAgICBpZiAoaXNOb29wQW5pbWF0aW9uKGFuaW1hdGlvbikpIHtcbiAgICAgICAgYW5pbWF0aW9uLmNvbXBsZXRlID0gdHJ1ZTtcbiAgICAgICAgLy8gd2Ugc3RpbGwgcHVzaCBpdCBvbnRvIHRoZSBzZXJpZXMgZm9yIGNhbGxiYWNrIGhhbmRsaW5nXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGFydCArPSBhbmltYXRpb24uZHVyYXRpb247XG4gICAgICB9XG4gICAgICBzZXJpZXMucHVzaChhbmltYXRpb24pO1xuICAgIH1cbiAgICB0aGlzLmFuaW1hdGlvbnNfLnB1c2goc2VyaWVzKTtcbiAgICB0aGlzLnNldEhpbnQoVmlld0hpbnQuQU5JTUFUSU5HLCAxKTtcbiAgICB0aGlzLnVwZGF0ZUFuaW1hdGlvbnNfKCk7XG4gIH1cblxuICAvKipcbiAgICogRGV0ZXJtaW5lIGlmIHRoZSB2aWV3IGlzIGJlaW5nIGFuaW1hdGVkLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUaGUgdmlldyBpcyBiZWluZyBhbmltYXRlZC5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0QW5pbWF0aW5nKCkge1xuICAgIHJldHVybiB0aGlzLmhpbnRzX1tWaWV3SGludC5BTklNQVRJTkddID4gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmUgaWYgdGhlIHVzZXIgaXMgaW50ZXJhY3Rpbmcgd2l0aCB0aGUgdmlldywgc3VjaCBhcyBwYW5uaW5nIG9yIHpvb21pbmcuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSB2aWV3IGlzIGJlaW5nIGludGVyYWN0ZWQgd2l0aC5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0SW50ZXJhY3RpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGludHNfW1ZpZXdIaW50LklOVEVSQUNUSU5HXSA+IDA7XG4gIH1cblxuICAvKipcbiAgICogQ2FuY2VsIGFueSBvbmdvaW5nIGFuaW1hdGlvbnMuXG4gICAqIEBhcGlcbiAgICovXG4gIGNhbmNlbEFuaW1hdGlvbnMoKSB7XG4gICAgdGhpcy5zZXRIaW50KFZpZXdIaW50LkFOSU1BVElORywgLXRoaXMuaGludHNfW1ZpZXdIaW50LkFOSU1BVElOR10pO1xuICAgIGxldCBhbmNob3I7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gdGhpcy5hbmltYXRpb25zXy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICBjb25zdCBzZXJpZXMgPSB0aGlzLmFuaW1hdGlvbnNfW2ldO1xuICAgICAgaWYgKHNlcmllc1swXS5jYWxsYmFjaykge1xuICAgICAgICBhbmltYXRpb25DYWxsYmFjayhzZXJpZXNbMF0uY2FsbGJhY2ssIGZhbHNlKTtcbiAgICAgIH1cbiAgICAgIGlmICghYW5jaG9yKSB7XG4gICAgICAgIGZvciAobGV0IGogPSAwLCBqaiA9IHNlcmllcy5sZW5ndGg7IGogPCBqajsgKytqKSB7XG4gICAgICAgICAgY29uc3QgYW5pbWF0aW9uID0gc2VyaWVzW2pdO1xuICAgICAgICAgIGlmICghYW5pbWF0aW9uLmNvbXBsZXRlKSB7XG4gICAgICAgICAgICBhbmNob3IgPSBhbmltYXRpb24uYW5jaG9yO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuYW5pbWF0aW9uc18ubGVuZ3RoID0gMDtcbiAgICB0aGlzLmNhbmNlbEFuY2hvcl8gPSBhbmNob3I7XG4gICAgdGhpcy5uZXh0Q2VudGVyXyA9IG51bGw7XG4gICAgdGhpcy5uZXh0UmVzb2x1dGlvbl8gPSBOYU47XG4gICAgdGhpcy5uZXh0Um90YXRpb25fID0gTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBhbGwgYW5pbWF0aW9ucy5cbiAgICovXG4gIHVwZGF0ZUFuaW1hdGlvbnNfKCkge1xuICAgIGlmICh0aGlzLnVwZGF0ZUFuaW1hdGlvbktleV8gIT09IHVuZGVmaW5lZCkge1xuICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy51cGRhdGVBbmltYXRpb25LZXlfKTtcbiAgICAgIHRoaXMudXBkYXRlQW5pbWF0aW9uS2V5XyA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmdldEFuaW1hdGluZygpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgbGV0IG1vcmUgPSBmYWxzZTtcbiAgICBmb3IgKGxldCBpID0gdGhpcy5hbmltYXRpb25zXy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgY29uc3Qgc2VyaWVzID0gdGhpcy5hbmltYXRpb25zX1tpXTtcbiAgICAgIGxldCBzZXJpZXNDb21wbGV0ZSA9IHRydWU7XG4gICAgICBmb3IgKGxldCBqID0gMCwgamogPSBzZXJpZXMubGVuZ3RoOyBqIDwgamo7ICsraikge1xuICAgICAgICBjb25zdCBhbmltYXRpb24gPSBzZXJpZXNbal07XG4gICAgICAgIGlmIChhbmltYXRpb24uY29tcGxldGUpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlbGFwc2VkID0gbm93IC0gYW5pbWF0aW9uLnN0YXJ0O1xuICAgICAgICBsZXQgZnJhY3Rpb24gPVxuICAgICAgICAgIGFuaW1hdGlvbi5kdXJhdGlvbiA+IDAgPyBlbGFwc2VkIC8gYW5pbWF0aW9uLmR1cmF0aW9uIDogMTtcbiAgICAgICAgaWYgKGZyYWN0aW9uID49IDEpIHtcbiAgICAgICAgICBhbmltYXRpb24uY29tcGxldGUgPSB0cnVlO1xuICAgICAgICAgIGZyYWN0aW9uID0gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZXJpZXNDb21wbGV0ZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByb2dyZXNzID0gYW5pbWF0aW9uLmVhc2luZyhmcmFjdGlvbik7XG4gICAgICAgIGlmIChhbmltYXRpb24uc291cmNlQ2VudGVyKSB7XG4gICAgICAgICAgY29uc3QgeDAgPSBhbmltYXRpb24uc291cmNlQ2VudGVyWzBdO1xuICAgICAgICAgIGNvbnN0IHkwID0gYW5pbWF0aW9uLnNvdXJjZUNlbnRlclsxXTtcbiAgICAgICAgICBjb25zdCB4MSA9IGFuaW1hdGlvbi50YXJnZXRDZW50ZXJbMF07XG4gICAgICAgICAgY29uc3QgeTEgPSBhbmltYXRpb24udGFyZ2V0Q2VudGVyWzFdO1xuICAgICAgICAgIHRoaXMubmV4dENlbnRlcl8gPSBhbmltYXRpb24udGFyZ2V0Q2VudGVyO1xuICAgICAgICAgIGNvbnN0IHggPSB4MCArIHByb2dyZXNzICogKHgxIC0geDApO1xuICAgICAgICAgIGNvbnN0IHkgPSB5MCArIHByb2dyZXNzICogKHkxIC0geTApO1xuICAgICAgICAgIHRoaXMudGFyZ2V0Q2VudGVyXyA9IFt4LCB5XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYW5pbWF0aW9uLnNvdXJjZVJlc29sdXRpb24gJiYgYW5pbWF0aW9uLnRhcmdldFJlc29sdXRpb24pIHtcbiAgICAgICAgICBjb25zdCByZXNvbHV0aW9uID1cbiAgICAgICAgICAgIHByb2dyZXNzID09PSAxXG4gICAgICAgICAgICAgID8gYW5pbWF0aW9uLnRhcmdldFJlc29sdXRpb25cbiAgICAgICAgICAgICAgOiBhbmltYXRpb24uc291cmNlUmVzb2x1dGlvbiArXG4gICAgICAgICAgICAgICAgcHJvZ3Jlc3MgKlxuICAgICAgICAgICAgICAgICAgKGFuaW1hdGlvbi50YXJnZXRSZXNvbHV0aW9uIC0gYW5pbWF0aW9uLnNvdXJjZVJlc29sdXRpb24pO1xuICAgICAgICAgIGlmIChhbmltYXRpb24uYW5jaG9yKSB7XG4gICAgICAgICAgICBjb25zdCBzaXplID0gdGhpcy5nZXRWaWV3cG9ydFNpemVfKHRoaXMuZ2V0Um90YXRpb24oKSk7XG4gICAgICAgICAgICBjb25zdCBjb25zdHJhaW5lZFJlc29sdXRpb24gPSB0aGlzLmNvbnN0cmFpbnRzXy5yZXNvbHV0aW9uKFxuICAgICAgICAgICAgICByZXNvbHV0aW9uLFxuICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICBzaXplLFxuICAgICAgICAgICAgICB0cnVlXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdGhpcy50YXJnZXRDZW50ZXJfID0gdGhpcy5jYWxjdWxhdGVDZW50ZXJab29tKFxuICAgICAgICAgICAgICBjb25zdHJhaW5lZFJlc29sdXRpb24sXG4gICAgICAgICAgICAgIGFuaW1hdGlvbi5hbmNob3JcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMubmV4dFJlc29sdXRpb25fID0gYW5pbWF0aW9uLnRhcmdldFJlc29sdXRpb247XG4gICAgICAgICAgdGhpcy50YXJnZXRSZXNvbHV0aW9uXyA9IHJlc29sdXRpb247XG4gICAgICAgICAgdGhpcy5hcHBseVRhcmdldFN0YXRlXyh0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoXG4gICAgICAgICAgYW5pbWF0aW9uLnNvdXJjZVJvdGF0aW9uICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICBhbmltYXRpb24udGFyZ2V0Um90YXRpb24gIT09IHVuZGVmaW5lZFxuICAgICAgICApIHtcbiAgICAgICAgICBjb25zdCByb3RhdGlvbiA9XG4gICAgICAgICAgICBwcm9ncmVzcyA9PT0gMVxuICAgICAgICAgICAgICA/IG1vZHVsbyhhbmltYXRpb24udGFyZ2V0Um90YXRpb24gKyBNYXRoLlBJLCAyICogTWF0aC5QSSkgLVxuICAgICAgICAgICAgICAgIE1hdGguUElcbiAgICAgICAgICAgICAgOiBhbmltYXRpb24uc291cmNlUm90YXRpb24gK1xuICAgICAgICAgICAgICAgIHByb2dyZXNzICpcbiAgICAgICAgICAgICAgICAgIChhbmltYXRpb24udGFyZ2V0Um90YXRpb24gLSBhbmltYXRpb24uc291cmNlUm90YXRpb24pO1xuICAgICAgICAgIGlmIChhbmltYXRpb24uYW5jaG9yKSB7XG4gICAgICAgICAgICBjb25zdCBjb25zdHJhaW5lZFJvdGF0aW9uID0gdGhpcy5jb25zdHJhaW50c18ucm90YXRpb24oXG4gICAgICAgICAgICAgIHJvdGF0aW9uLFxuICAgICAgICAgICAgICB0cnVlXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdGhpcy50YXJnZXRDZW50ZXJfID0gdGhpcy5jYWxjdWxhdGVDZW50ZXJSb3RhdGUoXG4gICAgICAgICAgICAgIGNvbnN0cmFpbmVkUm90YXRpb24sXG4gICAgICAgICAgICAgIGFuaW1hdGlvbi5hbmNob3JcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMubmV4dFJvdGF0aW9uXyA9IGFuaW1hdGlvbi50YXJnZXRSb3RhdGlvbjtcbiAgICAgICAgICB0aGlzLnRhcmdldFJvdGF0aW9uXyA9IHJvdGF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYXBwbHlUYXJnZXRTdGF0ZV8odHJ1ZSk7XG4gICAgICAgIG1vcmUgPSB0cnVlO1xuICAgICAgICBpZiAoIWFuaW1hdGlvbi5jb21wbGV0ZSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoc2VyaWVzQ29tcGxldGUpIHtcbiAgICAgICAgdGhpcy5hbmltYXRpb25zX1tpXSA9IG51bGw7XG4gICAgICAgIHRoaXMuc2V0SGludChWaWV3SGludC5BTklNQVRJTkcsIC0xKTtcbiAgICAgICAgdGhpcy5uZXh0Q2VudGVyXyA9IG51bGw7XG4gICAgICAgIHRoaXMubmV4dFJlc29sdXRpb25fID0gTmFOO1xuICAgICAgICB0aGlzLm5leHRSb3RhdGlvbl8gPSBOYU47XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrID0gc2VyaWVzWzBdLmNhbGxiYWNrO1xuICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICBhbmltYXRpb25DYWxsYmFjayhjYWxsYmFjaywgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gcHJ1bmUgY29tcGxldGVkIHNlcmllc1xuICAgIHRoaXMuYW5pbWF0aW9uc18gPSB0aGlzLmFuaW1hdGlvbnNfLmZpbHRlcihCb29sZWFuKTtcbiAgICBpZiAobW9yZSAmJiB0aGlzLnVwZGF0ZUFuaW1hdGlvbktleV8gPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy51cGRhdGVBbmltYXRpb25LZXlfID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKFxuICAgICAgICB0aGlzLnVwZGF0ZUFuaW1hdGlvbnNfLmJpbmQodGhpcylcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSByb3RhdGlvbiBUYXJnZXQgcm90YXRpb24uXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGFuY2hvciBSb3RhdGlvbiBhbmNob3IuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfHVuZGVmaW5lZH0gQ2VudGVyIGZvciByb3RhdGlvbiBhbmQgYW5jaG9yLlxuICAgKi9cbiAgY2FsY3VsYXRlQ2VudGVyUm90YXRlKHJvdGF0aW9uLCBhbmNob3IpIHtcbiAgICBsZXQgY2VudGVyO1xuICAgIGNvbnN0IGN1cnJlbnRDZW50ZXIgPSB0aGlzLmdldENlbnRlckludGVybmFsKCk7XG4gICAgaWYgKGN1cnJlbnRDZW50ZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY2VudGVyID0gW2N1cnJlbnRDZW50ZXJbMF0gLSBhbmNob3JbMF0sIGN1cnJlbnRDZW50ZXJbMV0gLSBhbmNob3JbMV1dO1xuICAgICAgcm90YXRlQ29vcmRpbmF0ZShjZW50ZXIsIHJvdGF0aW9uIC0gdGhpcy5nZXRSb3RhdGlvbigpKTtcbiAgICAgIGFkZENvb3JkaW5hdGUoY2VudGVyLCBhbmNob3IpO1xuICAgIH1cbiAgICByZXR1cm4gY2VudGVyO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSByZXNvbHV0aW9uIFRhcmdldCByZXNvbHV0aW9uLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBhbmNob3IgWm9vbSBhbmNob3IuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfHVuZGVmaW5lZH0gQ2VudGVyIGZvciByZXNvbHV0aW9uIGFuZCBhbmNob3IuXG4gICAqL1xuICBjYWxjdWxhdGVDZW50ZXJab29tKHJlc29sdXRpb24sIGFuY2hvcikge1xuICAgIGxldCBjZW50ZXI7XG4gICAgY29uc3QgY3VycmVudENlbnRlciA9IHRoaXMuZ2V0Q2VudGVySW50ZXJuYWwoKTtcbiAgICBjb25zdCBjdXJyZW50UmVzb2x1dGlvbiA9IHRoaXMuZ2V0UmVzb2x1dGlvbigpO1xuICAgIGlmIChjdXJyZW50Q2VudGVyICE9PSB1bmRlZmluZWQgJiYgY3VycmVudFJlc29sdXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc3QgeCA9XG4gICAgICAgIGFuY2hvclswXSAtXG4gICAgICAgIChyZXNvbHV0aW9uICogKGFuY2hvclswXSAtIGN1cnJlbnRDZW50ZXJbMF0pKSAvIGN1cnJlbnRSZXNvbHV0aW9uO1xuICAgICAgY29uc3QgeSA9XG4gICAgICAgIGFuY2hvclsxXSAtXG4gICAgICAgIChyZXNvbHV0aW9uICogKGFuY2hvclsxXSAtIGN1cnJlbnRDZW50ZXJbMV0pKSAvIGN1cnJlbnRSZXNvbHV0aW9uO1xuICAgICAgY2VudGVyID0gW3gsIHldO1xuICAgIH1cbiAgICByZXR1cm4gY2VudGVyO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGN1cnJlbnQgdmlld3BvcnQgc2l6ZS5cbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtyb3RhdGlvbl0gVGFrZSBpbnRvIGFjY291bnQgdGhlIHJvdGF0aW9uIG9mIHRoZSB2aWV3cG9ydCB3aGVuIGdpdmluZyB0aGUgc2l6ZVxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuL3NpemUuanNcIikuU2l6ZX0gVmlld3BvcnQgc2l6ZSBvciBgWzEwMCwgMTAwXWAgd2hlbiBubyB2aWV3cG9ydCBpcyBmb3VuZC5cbiAgICovXG4gIGdldFZpZXdwb3J0U2l6ZV8ocm90YXRpb24pIHtcbiAgICBjb25zdCBzaXplID0gdGhpcy52aWV3cG9ydFNpemVfO1xuICAgIGlmIChyb3RhdGlvbikge1xuICAgICAgY29uc3QgdyA9IHNpemVbMF07XG4gICAgICBjb25zdCBoID0gc2l6ZVsxXTtcbiAgICAgIHJldHVybiBbXG4gICAgICAgIE1hdGguYWJzKHcgKiBNYXRoLmNvcyhyb3RhdGlvbikpICsgTWF0aC5hYnMoaCAqIE1hdGguc2luKHJvdGF0aW9uKSksXG4gICAgICAgIE1hdGguYWJzKHcgKiBNYXRoLnNpbihyb3RhdGlvbikpICsgTWF0aC5hYnMoaCAqIE1hdGguY29zKHJvdGF0aW9uKSksXG4gICAgICBdO1xuICAgIH1cbiAgICByZXR1cm4gc2l6ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdG9yZXMgdGhlIHZpZXdwb3J0IHNpemUgb24gdGhlIHZpZXcuIFRoZSB2aWV3cG9ydCBzaXplIGlzIG5vdCByZWFkIGV2ZXJ5IHRpbWUgZnJvbSB0aGUgRE9NXG4gICAqIHRvIGF2b2lkIHBlcmZvcm1hbmNlIGhpdCBhbmQgbGF5b3V0IHJlZmxvdy5cbiAgICogVGhpcyBzaG91bGQgYmUgZG9uZSBvbiBtYXAgc2l6ZSBjaGFuZ2UuXG4gICAqIE5vdGU6IHRoZSBjb25zdHJhaW50cyBhcmUgbm90IHJlc29sdmVkIGR1cmluZyBhbiBhbmltYXRpb24gdG8gYXZvaWQgc3RvcHBpbmcgaXRcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL3NpemUuanNcIikuU2l6ZX0gW3NpemVdIFZpZXdwb3J0IHNpemU7IGlmIHVuZGVmaW5lZCwgWzEwMCwgMTAwXSBpcyBhc3N1bWVkXG4gICAqL1xuICBzZXRWaWV3cG9ydFNpemUoc2l6ZSkge1xuICAgIHRoaXMudmlld3BvcnRTaXplXyA9IEFycmF5LmlzQXJyYXkoc2l6ZSkgPyBzaXplLnNsaWNlKCkgOiBbMTAwLCAxMDBdO1xuICAgIGlmICghdGhpcy5nZXRBbmltYXRpbmcoKSkge1xuICAgICAgdGhpcy5yZXNvbHZlQ29uc3RyYWludHMoMCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdmlldyBjZW50ZXIuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfHVuZGVmaW5lZH0gVGhlIGNlbnRlciBvZiB0aGUgdmlldy5cbiAgICogQG9ic2VydmFibGVcbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0Q2VudGVyKCkge1xuICAgIGNvbnN0IGNlbnRlciA9IHRoaXMuZ2V0Q2VudGVySW50ZXJuYWwoKTtcbiAgICBpZiAoIWNlbnRlcikge1xuICAgICAgcmV0dXJuIGNlbnRlcjtcbiAgICB9XG4gICAgcmV0dXJuIHRvVXNlckNvb3JkaW5hdGUoY2VudGVyLCB0aGlzLmdldFByb2plY3Rpb24oKSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB2aWV3IGNlbnRlciB3aXRob3V0IHRyYW5zZm9ybWluZyB0byB1c2VyIHByb2plY3Rpb24uXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfHVuZGVmaW5lZH0gVGhlIGNlbnRlciBvZiB0aGUgdmlldy5cbiAgICovXG4gIGdldENlbnRlckludGVybmFsKCkge1xuICAgIHJldHVybiAvKiogQHR5cGUge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfHVuZGVmaW5lZH0gKi8gKFxuICAgICAgdGhpcy5nZXQoVmlld1Byb3BlcnR5LkNFTlRFUilcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0NvbnN0cmFpbnRzfSBDb25zdHJhaW50cy5cbiAgICovXG4gIGdldENvbnN0cmFpbnRzKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnN0cmFpbnRzXztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBSZXNvbHV0aW9uIGNvbnN0cmFpbnQgaXMgc2V0XG4gICAqL1xuICBnZXRDb25zdHJhaW5SZXNvbHV0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmdldCgnY29uc3RyYWluUmVzb2x1dGlvbicpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gW2hpbnRzXSBEZXN0aW5hdGlvbiBhcnJheS5cbiAgICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gSGludC5cbiAgICovXG4gIGdldEhpbnRzKGhpbnRzKSB7XG4gICAgaWYgKGhpbnRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGhpbnRzWzBdID0gdGhpcy5oaW50c19bMF07XG4gICAgICBoaW50c1sxXSA9IHRoaXMuaGludHNfWzFdO1xuICAgICAgcmV0dXJuIGhpbnRzO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5oaW50c18uc2xpY2UoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdGhlIGV4dGVudCBmb3IgdGhlIGN1cnJlbnQgdmlldyBzdGF0ZSBhbmQgdGhlIHBhc3NlZCBzaXplLlxuICAgKiBUaGUgc2l6ZSBpcyB0aGUgcGl4ZWwgZGltZW5zaW9ucyBvZiB0aGUgYm94IGludG8gd2hpY2ggdGhlIGNhbGN1bGF0ZWQgZXh0ZW50XG4gICAqIHNob3VsZCBmaXQuIEluIG1vc3QgY2FzZXMgeW91IHdhbnQgdG8gZ2V0IHRoZSBleHRlbnQgb2YgdGhlIGVudGlyZSBtYXAsXG4gICAqIHRoYXQgaXMgYG1hcC5nZXRTaXplKClgLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vc2l6ZS5qc1wiKS5TaXplfSBbc2l6ZV0gQm94IHBpeGVsIHNpemUuIElmIG5vdCBwcm92aWRlZCwgdGhlIHNpemVcbiAgICogb2YgdGhlIG1hcCB0aGF0IHVzZXMgdGhpcyB2aWV3IHdpbGwgYmUgdXNlZC5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi9leHRlbnQuanNcIikuRXh0ZW50fSBFeHRlbnQuXG4gICAqIEBhcGlcbiAgICovXG4gIGNhbGN1bGF0ZUV4dGVudChzaXplKSB7XG4gICAgY29uc3QgZXh0ZW50ID0gdGhpcy5jYWxjdWxhdGVFeHRlbnRJbnRlcm5hbChzaXplKTtcbiAgICByZXR1cm4gdG9Vc2VyRXh0ZW50KGV4dGVudCwgdGhpcy5nZXRQcm9qZWN0aW9uKCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9zaXplLmpzXCIpLlNpemV9IFtzaXplXSBCb3ggcGl4ZWwgc2l6ZS4gSWYgbm90IHByb3ZpZGVkLFxuICAgKiB0aGUgbWFwJ3MgbGFzdCBrbm93biB2aWV3cG9ydCBzaXplIHdpbGwgYmUgdXNlZC5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi9leHRlbnQuanNcIikuRXh0ZW50fSBFeHRlbnQuXG4gICAqL1xuICBjYWxjdWxhdGVFeHRlbnRJbnRlcm5hbChzaXplKSB7XG4gICAgc2l6ZSA9IHNpemUgfHwgdGhpcy5nZXRWaWV3cG9ydFNpemVNaW51c1BhZGRpbmdfKCk7XG4gICAgY29uc3QgY2VudGVyID0gLyoqIEB0eXBlIHshaW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9ICovIChcbiAgICAgIHRoaXMuZ2V0Q2VudGVySW50ZXJuYWwoKVxuICAgICk7XG4gICAgYXNzZXJ0KGNlbnRlciwgJ1RoZSB2aWV3IGNlbnRlciBpcyBub3QgZGVmaW5lZCcpO1xuICAgIGNvbnN0IHJlc29sdXRpb24gPSAvKiogQHR5cGUgeyFudW1iZXJ9ICovICh0aGlzLmdldFJlc29sdXRpb24oKSk7XG4gICAgYXNzZXJ0KHJlc29sdXRpb24gIT09IHVuZGVmaW5lZCwgJ1RoZSB2aWV3IHJlc29sdXRpb24gaXMgbm90IGRlZmluZWQnKTtcbiAgICBjb25zdCByb3RhdGlvbiA9IC8qKiBAdHlwZSB7IW51bWJlcn0gKi8gKHRoaXMuZ2V0Um90YXRpb24oKSk7XG4gICAgYXNzZXJ0KHJvdGF0aW9uICE9PSB1bmRlZmluZWQsICdUaGUgdmlldyByb3RhdGlvbiBpcyBub3QgZGVmaW5lZCcpO1xuXG4gICAgcmV0dXJuIGdldEZvclZpZXdBbmRTaXplKGNlbnRlciwgcmVzb2x1dGlvbiwgcm90YXRpb24sIHNpemUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbWF4aW11bSByZXNvbHV0aW9uIG9mIHRoZSB2aWV3LlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBtYXhpbXVtIHJlc29sdXRpb24gb2YgdGhlIHZpZXcuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldE1heFJlc29sdXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMubWF4UmVzb2x1dGlvbl87XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBtaW5pbXVtIHJlc29sdXRpb24gb2YgdGhlIHZpZXcuXG4gICAqIEByZXR1cm4ge251bWJlcn0gVGhlIG1pbmltdW0gcmVzb2x1dGlvbiBvZiB0aGUgdmlldy5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0TWluUmVzb2x1dGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5taW5SZXNvbHV0aW9uXztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG1heGltdW0gem9vbSBsZXZlbCBmb3IgdGhlIHZpZXcuXG4gICAqIEByZXR1cm4ge251bWJlcn0gVGhlIG1heGltdW0gem9vbSBsZXZlbC5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0TWF4Wm9vbSgpIHtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHtudW1iZXJ9ICovIChcbiAgICAgIHRoaXMuZ2V0Wm9vbUZvclJlc29sdXRpb24odGhpcy5taW5SZXNvbHV0aW9uXylcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCBhIG5ldyBtYXhpbXVtIHpvb20gbGV2ZWwgZm9yIHRoZSB2aWV3LlxuICAgKiBAcGFyYW0ge251bWJlcn0gem9vbSBUaGUgbWF4aW11bSB6b29tIGxldmVsLlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRNYXhab29tKHpvb20pIHtcbiAgICB0aGlzLmFwcGx5T3B0aW9uc18odGhpcy5nZXRVcGRhdGVkT3B0aW9uc18oe21heFpvb206IHpvb219KSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBtaW5pbXVtIHpvb20gbGV2ZWwgZm9yIHRoZSB2aWV3LlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBtaW5pbXVtIHpvb20gbGV2ZWwuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldE1pblpvb20oKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAoXG4gICAgICB0aGlzLmdldFpvb21Gb3JSZXNvbHV0aW9uKHRoaXMubWF4UmVzb2x1dGlvbl8pXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgYSBuZXcgbWluaW11bSB6b29tIGxldmVsIGZvciB0aGUgdmlldy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHpvb20gVGhlIG1pbmltdW0gem9vbSBsZXZlbC5cbiAgICogQGFwaVxuICAgKi9cbiAgc2V0TWluWm9vbSh6b29tKSB7XG4gICAgdGhpcy5hcHBseU9wdGlvbnNfKHRoaXMuZ2V0VXBkYXRlZE9wdGlvbnNfKHttaW5ab29tOiB6b29tfSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB3aGV0aGVyIHRoZSB2aWV3IHNob3VsZCBhbGxvdyBpbnRlcm1lZGlhcnkgem9vbSBsZXZlbHMuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gZW5hYmxlZCBXaGV0aGVyIHRoZSByZXNvbHV0aW9uIGlzIGNvbnN0cmFpbmVkLlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRDb25zdHJhaW5SZXNvbHV0aW9uKGVuYWJsZWQpIHtcbiAgICB0aGlzLmFwcGx5T3B0aW9uc18odGhpcy5nZXRVcGRhdGVkT3B0aW9uc18oe2NvbnN0cmFpblJlc29sdXRpb246IGVuYWJsZWR9KSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB2aWV3IHByb2plY3Rpb24uXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4vcHJvai9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR9IFRoZSBwcm9qZWN0aW9uIG9mIHRoZSB2aWV3LlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRQcm9qZWN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnByb2plY3Rpb25fO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdmlldyByZXNvbHV0aW9uLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ8dW5kZWZpbmVkfSBUaGUgcmVzb2x1dGlvbiBvZiB0aGUgdmlldy5cbiAgICogQG9ic2VydmFibGVcbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0UmVzb2x1dGlvbigpIHtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHtudW1iZXJ8dW5kZWZpbmVkfSAqLyAodGhpcy5nZXQoVmlld1Byb3BlcnR5LlJFU09MVVRJT04pKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHJlc29sdXRpb25zIGZvciB0aGUgdmlldy4gVGhpcyByZXR1cm5zIHRoZSBhcnJheSBvZiByZXNvbHV0aW9uc1xuICAgKiBwYXNzZWQgdG8gdGhlIGNvbnN0cnVjdG9yIG9mIHRoZSBWaWV3LCBvciB1bmRlZmluZWQgaWYgbm9uZSB3ZXJlIGdpdmVuLlxuICAgKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fHVuZGVmaW5lZH0gVGhlIHJlc29sdXRpb25zIG9mIHRoZSB2aWV3LlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRSZXNvbHV0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5yZXNvbHV0aW9uc187XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSByZXNvbHV0aW9uIGZvciBhIHByb3ZpZGVkIGV4dGVudCAoaW4gbWFwIHVuaXRzKSBhbmQgc2l6ZSAoaW4gcGl4ZWxzKS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL2V4dGVudC5qc1wiKS5FeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9zaXplLmpzXCIpLlNpemV9IFtzaXplXSBCb3ggcGl4ZWwgc2l6ZS5cbiAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgcmVzb2x1dGlvbiBhdCB3aGljaCB0aGUgcHJvdmlkZWQgZXh0ZW50IHdpbGwgcmVuZGVyIGF0XG4gICAqICAgICB0aGUgZ2l2ZW4gc2l6ZS5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0UmVzb2x1dGlvbkZvckV4dGVudChleHRlbnQsIHNpemUpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRSZXNvbHV0aW9uRm9yRXh0ZW50SW50ZXJuYWwoXG4gICAgICBmcm9tVXNlckV4dGVudChleHRlbnQsIHRoaXMuZ2V0UHJvamVjdGlvbigpKSxcbiAgICAgIHNpemVcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgcmVzb2x1dGlvbiBmb3IgYSBwcm92aWRlZCBleHRlbnQgKGluIG1hcCB1bml0cykgYW5kIHNpemUgKGluIHBpeGVscykuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9leHRlbnQuanNcIikuRXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vc2l6ZS5qc1wiKS5TaXplfSBbc2l6ZV0gQm94IHBpeGVsIHNpemUuXG4gICAqIEByZXR1cm4ge251bWJlcn0gVGhlIHJlc29sdXRpb24gYXQgd2hpY2ggdGhlIHByb3ZpZGVkIGV4dGVudCB3aWxsIHJlbmRlciBhdFxuICAgKiAgICAgdGhlIGdpdmVuIHNpemUuXG4gICAqL1xuICBnZXRSZXNvbHV0aW9uRm9yRXh0ZW50SW50ZXJuYWwoZXh0ZW50LCBzaXplKSB7XG4gICAgc2l6ZSA9IHNpemUgfHwgdGhpcy5nZXRWaWV3cG9ydFNpemVNaW51c1BhZGRpbmdfKCk7XG4gICAgY29uc3QgeFJlc29sdXRpb24gPSBnZXRXaWR0aChleHRlbnQpIC8gc2l6ZVswXTtcbiAgICBjb25zdCB5UmVzb2x1dGlvbiA9IGdldEhlaWdodChleHRlbnQpIC8gc2l6ZVsxXTtcbiAgICByZXR1cm4gTWF0aC5tYXgoeFJlc29sdXRpb24sIHlSZXNvbHV0aW9uKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDEgZm9yIGFcbiAgICogcmVzb2x1dGlvbi4gRXhwb25lbnRpYWwgc2NhbGluZyBpcyBhc3N1bWVkLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW3Bvd2VyXSBQb3dlci5cbiAgICogQHJldHVybiB7ZnVuY3Rpb24obnVtYmVyKTogbnVtYmVyfSBSZXNvbHV0aW9uIGZvciB2YWx1ZSBmdW5jdGlvbi5cbiAgICovXG4gIGdldFJlc29sdXRpb25Gb3JWYWx1ZUZ1bmN0aW9uKHBvd2VyKSB7XG4gICAgcG93ZXIgPSBwb3dlciB8fCAyO1xuICAgIGNvbnN0IG1heFJlc29sdXRpb24gPSB0aGlzLmdldENvbnN0cmFpbmVkUmVzb2x1dGlvbih0aGlzLm1heFJlc29sdXRpb25fKTtcbiAgICBjb25zdCBtaW5SZXNvbHV0aW9uID0gdGhpcy5taW5SZXNvbHV0aW9uXztcbiAgICBjb25zdCBtYXggPSBNYXRoLmxvZyhtYXhSZXNvbHV0aW9uIC8gbWluUmVzb2x1dGlvbikgLyBNYXRoLmxvZyhwb3dlcik7XG4gICAgcmV0dXJuIChcbiAgICAgIC8qKlxuICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFZhbHVlLlxuICAgICAgICogQHJldHVybiB7bnVtYmVyfSBSZXNvbHV0aW9uLlxuICAgICAgICovXG4gICAgICBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgY29uc3QgcmVzb2x1dGlvbiA9IG1heFJlc29sdXRpb24gLyBNYXRoLnBvdyhwb3dlciwgdmFsdWUgKiBtYXgpO1xuICAgICAgICByZXR1cm4gcmVzb2x1dGlvbjtcbiAgICAgIH1cbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdmlldyByb3RhdGlvbi5cbiAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgcm90YXRpb24gb2YgdGhlIHZpZXcgaW4gcmFkaWFucy5cbiAgICogQG9ic2VydmFibGVcbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0Um90YXRpb24oKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAodGhpcy5nZXQoVmlld1Byb3BlcnR5LlJPVEFUSU9OKSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgcmVzb2x1dGlvbiBmb3IgYSB2YWx1ZSBiZXR3ZWVuXG4gICAqIDAgYW5kIDEuIEV4cG9uZW50aWFsIHNjYWxpbmcgaXMgYXNzdW1lZC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtwb3dlcl0gUG93ZXIuXG4gICAqIEByZXR1cm4ge2Z1bmN0aW9uKG51bWJlcik6IG51bWJlcn0gVmFsdWUgZm9yIHJlc29sdXRpb24gZnVuY3Rpb24uXG4gICAqL1xuICBnZXRWYWx1ZUZvclJlc29sdXRpb25GdW5jdGlvbihwb3dlcikge1xuICAgIGNvbnN0IGxvZ1Bvd2VyID0gTWF0aC5sb2cocG93ZXIgfHwgMik7XG4gICAgY29uc3QgbWF4UmVzb2x1dGlvbiA9IHRoaXMuZ2V0Q29uc3RyYWluZWRSZXNvbHV0aW9uKHRoaXMubWF4UmVzb2x1dGlvbl8pO1xuICAgIGNvbnN0IG1pblJlc29sdXRpb24gPSB0aGlzLm1pblJlc29sdXRpb25fO1xuICAgIGNvbnN0IG1heCA9IE1hdGgubG9nKG1heFJlc29sdXRpb24gLyBtaW5SZXNvbHV0aW9uKSAvIGxvZ1Bvd2VyO1xuICAgIHJldHVybiAoXG4gICAgICAvKipcbiAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSByZXNvbHV0aW9uIFJlc29sdXRpb24uXG4gICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IFZhbHVlLlxuICAgICAgICovXG4gICAgICBmdW5jdGlvbiAocmVzb2x1dGlvbikge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IE1hdGgubG9nKG1heFJlc29sdXRpb24gLyByZXNvbHV0aW9uKSAvIGxvZ1Bvd2VyIC8gbWF4O1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBzaXplIG9mIHRoZSB2aWV3cG9ydCBtaW51cyBwYWRkaW5nLlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge251bWJlcn0gW3JvdGF0aW9uXSBUYWtlIGludG8gYWNjb3VudCB0aGUgcm90YXRpb24gb2YgdGhlIHZpZXdwb3J0IHdoZW4gZ2l2aW5nIHRoZSBzaXplXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4vc2l6ZS5qc1wiKS5TaXplfSBWaWV3cG9ydCBzaXplIHJlZHVjZWQgYnkgdGhlIHBhZGRpbmcuXG4gICAqL1xuICBnZXRWaWV3cG9ydFNpemVNaW51c1BhZGRpbmdfKHJvdGF0aW9uKSB7XG4gICAgbGV0IHNpemUgPSB0aGlzLmdldFZpZXdwb3J0U2l6ZV8ocm90YXRpb24pO1xuICAgIGNvbnN0IHBhZGRpbmcgPSB0aGlzLnBhZGRpbmdfO1xuICAgIGlmIChwYWRkaW5nKSB7XG4gICAgICBzaXplID0gW1xuICAgICAgICBzaXplWzBdIC0gcGFkZGluZ1sxXSAtIHBhZGRpbmdbM10sXG4gICAgICAgIHNpemVbMV0gLSBwYWRkaW5nWzBdIC0gcGFkZGluZ1syXSxcbiAgICAgIF07XG4gICAgfVxuICAgIHJldHVybiBzaXplO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge1N0YXRlfSBWaWV3IHN0YXRlLlxuICAgKi9cbiAgZ2V0U3RhdGUoKSB7XG4gICAgY29uc3QgcHJvamVjdGlvbiA9IHRoaXMuZ2V0UHJvamVjdGlvbigpO1xuICAgIGNvbnN0IHJlc29sdXRpb24gPSB0aGlzLmdldFJlc29sdXRpb24oKTtcbiAgICBjb25zdCByb3RhdGlvbiA9IHRoaXMuZ2V0Um90YXRpb24oKTtcbiAgICBsZXQgY2VudGVyID0gLyoqIEB0eXBlIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gKi8gKFxuICAgICAgdGhpcy5nZXRDZW50ZXJJbnRlcm5hbCgpXG4gICAgKTtcbiAgICBjb25zdCBwYWRkaW5nID0gdGhpcy5wYWRkaW5nXztcbiAgICBpZiAocGFkZGluZykge1xuICAgICAgY29uc3QgcmVkdWNlZFNpemUgPSB0aGlzLmdldFZpZXdwb3J0U2l6ZU1pbnVzUGFkZGluZ18oKTtcbiAgICAgIGNlbnRlciA9IGNhbGN1bGF0ZUNlbnRlck9uKFxuICAgICAgICBjZW50ZXIsXG4gICAgICAgIHRoaXMuZ2V0Vmlld3BvcnRTaXplXygpLFxuICAgICAgICBbcmVkdWNlZFNpemVbMF0gLyAyICsgcGFkZGluZ1szXSwgcmVkdWNlZFNpemVbMV0gLyAyICsgcGFkZGluZ1swXV0sXG4gICAgICAgIHJlc29sdXRpb24sXG4gICAgICAgIHJvdGF0aW9uXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgY2VudGVyOiBjZW50ZXIuc2xpY2UoMCksXG4gICAgICBwcm9qZWN0aW9uOiBwcm9qZWN0aW9uICE9PSB1bmRlZmluZWQgPyBwcm9qZWN0aW9uIDogbnVsbCxcbiAgICAgIHJlc29sdXRpb246IHJlc29sdXRpb24sXG4gICAgICBuZXh0Q2VudGVyOiB0aGlzLm5leHRDZW50ZXJfLFxuICAgICAgbmV4dFJlc29sdXRpb246IHRoaXMubmV4dFJlc29sdXRpb25fLFxuICAgICAgbmV4dFJvdGF0aW9uOiB0aGlzLm5leHRSb3RhdGlvbl8sXG4gICAgICByb3RhdGlvbjogcm90YXRpb24sXG4gICAgICB6b29tOiB0aGlzLmdldFpvb20oKSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge1ZpZXdTdGF0ZUxheWVyU3RhdGVFeHRlbnR9IExpa2UgYEZyYW1lU3RhdGVgLCBidXQganVzdCBgdmlld1N0YXRlYCBhbmQgYGV4dGVudGAuXG4gICAqL1xuICBnZXRWaWV3U3RhdGVBbmRFeHRlbnQoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZpZXdTdGF0ZTogdGhpcy5nZXRTdGF0ZSgpLFxuICAgICAgZXh0ZW50OiB0aGlzLmNhbGN1bGF0ZUV4dGVudCgpLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBjdXJyZW50IHpvb20gbGV2ZWwuIFRoaXMgbWV0aG9kIG1heSByZXR1cm4gbm9uLWludGVnZXIgem9vbSBsZXZlbHNcbiAgICogaWYgdGhlIHZpZXcgZG9lcyBub3QgY29uc3RyYWluIHRoZSByZXNvbHV0aW9uLCBvciBpZiBhbiBpbnRlcmFjdGlvbiBvclxuICAgKiBhbmltYXRpb24gaXMgdW5kZXJ3YXkuXG4gICAqIEByZXR1cm4ge251bWJlcnx1bmRlZmluZWR9IFpvb20uXG4gICAqIEBhcGlcbiAgICovXG4gIGdldFpvb20oKSB7XG4gICAgbGV0IHpvb207XG4gICAgY29uc3QgcmVzb2x1dGlvbiA9IHRoaXMuZ2V0UmVzb2x1dGlvbigpO1xuICAgIGlmIChyZXNvbHV0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHpvb20gPSB0aGlzLmdldFpvb21Gb3JSZXNvbHV0aW9uKHJlc29sdXRpb24pO1xuICAgIH1cbiAgICByZXR1cm4gem9vbTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHpvb20gbGV2ZWwgZm9yIGEgcmVzb2x1dGlvbi5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHJlc29sdXRpb24gVGhlIHJlc29sdXRpb24uXG4gICAqIEByZXR1cm4ge251bWJlcnx1bmRlZmluZWR9IFRoZSB6b29tIGxldmVsIGZvciB0aGUgcHJvdmlkZWQgcmVzb2x1dGlvbi5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0Wm9vbUZvclJlc29sdXRpb24ocmVzb2x1dGlvbikge1xuICAgIGxldCBvZmZzZXQgPSB0aGlzLm1pblpvb21fIHx8IDA7XG4gICAgbGV0IG1heCwgem9vbUZhY3RvcjtcbiAgICBpZiAodGhpcy5yZXNvbHV0aW9uc18pIHtcbiAgICAgIGNvbnN0IG5lYXJlc3QgPSBsaW5lYXJGaW5kTmVhcmVzdCh0aGlzLnJlc29sdXRpb25zXywgcmVzb2x1dGlvbiwgMSk7XG4gICAgICBvZmZzZXQgPSBuZWFyZXN0O1xuICAgICAgbWF4ID0gdGhpcy5yZXNvbHV0aW9uc19bbmVhcmVzdF07XG4gICAgICBpZiAobmVhcmVzdCA9PSB0aGlzLnJlc29sdXRpb25zXy5sZW5ndGggLSAxKSB7XG4gICAgICAgIHpvb21GYWN0b3IgPSAyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgem9vbUZhY3RvciA9IG1heCAvIHRoaXMucmVzb2x1dGlvbnNfW25lYXJlc3QgKyAxXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbWF4ID0gdGhpcy5tYXhSZXNvbHV0aW9uXztcbiAgICAgIHpvb21GYWN0b3IgPSB0aGlzLnpvb21GYWN0b3JfO1xuICAgIH1cbiAgICByZXR1cm4gb2Zmc2V0ICsgTWF0aC5sb2cobWF4IC8gcmVzb2x1dGlvbikgLyBNYXRoLmxvZyh6b29tRmFjdG9yKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHJlc29sdXRpb24gZm9yIGEgem9vbSBsZXZlbC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHpvb20gWm9vbSBsZXZlbC5cbiAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgdmlldyByZXNvbHV0aW9uIGZvciB0aGUgcHJvdmlkZWQgem9vbSBsZXZlbC5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0UmVzb2x1dGlvbkZvclpvb20oem9vbSkge1xuICAgIGlmICh0aGlzLnJlc29sdXRpb25zXykge1xuICAgICAgaWYgKHRoaXMucmVzb2x1dGlvbnNfLmxlbmd0aCA8PSAxKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgICAgY29uc3QgYmFzZUxldmVsID0gY2xhbXAoXG4gICAgICAgIE1hdGguZmxvb3Ioem9vbSksXG4gICAgICAgIDAsXG4gICAgICAgIHRoaXMucmVzb2x1dGlvbnNfLmxlbmd0aCAtIDJcbiAgICAgICk7XG4gICAgICBjb25zdCB6b29tRmFjdG9yID1cbiAgICAgICAgdGhpcy5yZXNvbHV0aW9uc19bYmFzZUxldmVsXSAvIHRoaXMucmVzb2x1dGlvbnNfW2Jhc2VMZXZlbCArIDFdO1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgdGhpcy5yZXNvbHV0aW9uc19bYmFzZUxldmVsXSAvXG4gICAgICAgIE1hdGgucG93KHpvb21GYWN0b3IsIGNsYW1wKHpvb20gLSBiYXNlTGV2ZWwsIDAsIDEpKVxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIChcbiAgICAgIHRoaXMubWF4UmVzb2x1dGlvbl8gLyBNYXRoLnBvdyh0aGlzLnpvb21GYWN0b3JfLCB6b29tIC0gdGhpcy5taW5ab29tXylcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpdCB0aGUgZ2l2ZW4gZ2VvbWV0cnkgb3IgZXh0ZW50IGJhc2VkIG9uIHRoZSBnaXZlbiBtYXAgc2l6ZSBhbmQgYm9yZGVyLlxuICAgKiBUaGUgc2l6ZSBpcyBwaXhlbCBkaW1lbnNpb25zIG9mIHRoZSBib3ggdG8gZml0IHRoZSBleHRlbnQgaW50by5cbiAgICogSW4gbW9zdCBjYXNlcyB5b3Ugd2lsbCB3YW50IHRvIHVzZSB0aGUgbWFwIHNpemUsIHRoYXQgaXMgYG1hcC5nZXRTaXplKClgLlxuICAgKiBUYWtlcyBjYXJlIG9mIHRoZSBtYXAgYW5nbGUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9nZW9tL1NpbXBsZUdlb21ldHJ5LmpzXCIpLmRlZmF1bHR8aW1wb3J0KFwiLi9leHRlbnQuanNcIikuRXh0ZW50fSBnZW9tZXRyeU9yRXh0ZW50IFRoZSBnZW9tZXRyeSBvclxuICAgKiAgICAgZXh0ZW50IHRvIGZpdCB0aGUgdmlldyB0by5cbiAgICogQHBhcmFtIHtGaXRPcHRpb25zfSBbb3B0aW9uc10gT3B0aW9ucy5cbiAgICogQGFwaVxuICAgKi9cbiAgZml0KGdlb21ldHJ5T3JFeHRlbnQsIG9wdGlvbnMpIHtcbiAgICAvKiogQHR5cGUge2ltcG9ydChcIi4vZ2VvbS9TaW1wbGVHZW9tZXRyeS5qc1wiKS5kZWZhdWx0fSAqL1xuICAgIGxldCBnZW9tZXRyeTtcbiAgICBhc3NlcnQoXG4gICAgICBBcnJheS5pc0FycmF5KGdlb21ldHJ5T3JFeHRlbnQpIHx8XG4gICAgICAgIHR5cGVvZiAoLyoqIEB0eXBlIHs/fSAqLyAoZ2VvbWV0cnlPckV4dGVudCkuZ2V0U2ltcGxpZmllZEdlb21ldHJ5KSA9PT1cbiAgICAgICAgICAnZnVuY3Rpb24nLFxuICAgICAgJ0ludmFsaWQgZXh0ZW50IG9yIGdlb21ldHJ5IHByb3ZpZGVkIGFzIGBnZW9tZXRyeWAnXG4gICAgKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShnZW9tZXRyeU9yRXh0ZW50KSkge1xuICAgICAgYXNzZXJ0KFxuICAgICAgICAhaXNFbXB0eShnZW9tZXRyeU9yRXh0ZW50KSxcbiAgICAgICAgJ0Nhbm5vdCBmaXQgZW1wdHkgZXh0ZW50IHByb3ZpZGVkIGFzIGBnZW9tZXRyeWAnXG4gICAgICApO1xuICAgICAgY29uc3QgZXh0ZW50ID0gZnJvbVVzZXJFeHRlbnQoZ2VvbWV0cnlPckV4dGVudCwgdGhpcy5nZXRQcm9qZWN0aW9uKCkpO1xuICAgICAgZ2VvbWV0cnkgPSBwb2x5Z29uRnJvbUV4dGVudChleHRlbnQpO1xuICAgIH0gZWxzZSBpZiAoZ2VvbWV0cnlPckV4dGVudC5nZXRUeXBlKCkgPT09ICdDaXJjbGUnKSB7XG4gICAgICBjb25zdCBleHRlbnQgPSBmcm9tVXNlckV4dGVudChcbiAgICAgICAgZ2VvbWV0cnlPckV4dGVudC5nZXRFeHRlbnQoKSxcbiAgICAgICAgdGhpcy5nZXRQcm9qZWN0aW9uKClcbiAgICAgICk7XG4gICAgICBnZW9tZXRyeSA9IHBvbHlnb25Gcm9tRXh0ZW50KGV4dGVudCk7XG4gICAgICBnZW9tZXRyeS5yb3RhdGUodGhpcy5nZXRSb3RhdGlvbigpLCBnZXRDZW50ZXIoZXh0ZW50KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHVzZXJQcm9qZWN0aW9uID0gZ2V0VXNlclByb2plY3Rpb24oKTtcbiAgICAgIGlmICh1c2VyUHJvamVjdGlvbikge1xuICAgICAgICBnZW9tZXRyeSA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi9nZW9tL1NpbXBsZUdlb21ldHJ5LmpzXCIpLmRlZmF1bHR9ICovIChcbiAgICAgICAgICBnZW9tZXRyeU9yRXh0ZW50XG4gICAgICAgICAgICAuY2xvbmUoKVxuICAgICAgICAgICAgLnRyYW5zZm9ybSh1c2VyUHJvamVjdGlvbiwgdGhpcy5nZXRQcm9qZWN0aW9uKCkpXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBnZW9tZXRyeSA9IGdlb21ldHJ5T3JFeHRlbnQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5maXRJbnRlcm5hbChnZW9tZXRyeSwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogQ2FsY3VsYXRlIHJvdGF0ZWQgZXh0ZW50XG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9nZW9tL1NpbXBsZUdlb21ldHJ5LmpzXCIpLmRlZmF1bHR9IGdlb21ldHJ5IFRoZSBnZW9tZXRyeS5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi9leHRlbnRcIikuRXh0ZW50fSBUaGUgcm90YXRlZCBleHRlbnQgZm9yIHRoZSBnZW9tZXRyeS5cbiAgICovXG4gIHJvdGF0ZWRFeHRlbnRGb3JHZW9tZXRyeShnZW9tZXRyeSkge1xuICAgIGNvbnN0IHJvdGF0aW9uID0gdGhpcy5nZXRSb3RhdGlvbigpO1xuICAgIGNvbnN0IGNvc0FuZ2xlID0gTWF0aC5jb3Mocm90YXRpb24pO1xuICAgIGNvbnN0IHNpbkFuZ2xlID0gTWF0aC5zaW4oLXJvdGF0aW9uKTtcbiAgICBjb25zdCBjb29yZHMgPSBnZW9tZXRyeS5nZXRGbGF0Q29vcmRpbmF0ZXMoKTtcbiAgICBjb25zdCBzdHJpZGUgPSBnZW9tZXRyeS5nZXRTdHJpZGUoKTtcbiAgICBsZXQgbWluUm90WCA9ICtJbmZpbml0eTtcbiAgICBsZXQgbWluUm90WSA9ICtJbmZpbml0eTtcbiAgICBsZXQgbWF4Um90WCA9IC1JbmZpbml0eTtcbiAgICBsZXQgbWF4Um90WSA9IC1JbmZpbml0eTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBjb29yZHMubGVuZ3RoOyBpIDwgaWk7IGkgKz0gc3RyaWRlKSB7XG4gICAgICBjb25zdCByb3RYID0gY29vcmRzW2ldICogY29zQW5nbGUgLSBjb29yZHNbaSArIDFdICogc2luQW5nbGU7XG4gICAgICBjb25zdCByb3RZID0gY29vcmRzW2ldICogc2luQW5nbGUgKyBjb29yZHNbaSArIDFdICogY29zQW5nbGU7XG4gICAgICBtaW5Sb3RYID0gTWF0aC5taW4obWluUm90WCwgcm90WCk7XG4gICAgICBtaW5Sb3RZID0gTWF0aC5taW4obWluUm90WSwgcm90WSk7XG4gICAgICBtYXhSb3RYID0gTWF0aC5tYXgobWF4Um90WCwgcm90WCk7XG4gICAgICBtYXhSb3RZID0gTWF0aC5tYXgobWF4Um90WSwgcm90WSk7XG4gICAgfVxuICAgIHJldHVybiBbbWluUm90WCwgbWluUm90WSwgbWF4Um90WCwgbWF4Um90WV07XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL2dlb20vU2ltcGxlR2VvbWV0cnkuanNcIikuZGVmYXVsdH0gZ2VvbWV0cnkgVGhlIGdlb21ldHJ5LlxuICAgKiBAcGFyYW0ge0ZpdE9wdGlvbnN9IFtvcHRpb25zXSBPcHRpb25zLlxuICAgKi9cbiAgZml0SW50ZXJuYWwoZ2VvbWV0cnksIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBsZXQgc2l6ZSA9IG9wdGlvbnMuc2l6ZTtcbiAgICBpZiAoIXNpemUpIHtcbiAgICAgIHNpemUgPSB0aGlzLmdldFZpZXdwb3J0U2l6ZU1pbnVzUGFkZGluZ18oKTtcbiAgICB9XG4gICAgY29uc3QgcGFkZGluZyA9XG4gICAgICBvcHRpb25zLnBhZGRpbmcgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMucGFkZGluZyA6IFswLCAwLCAwLCAwXTtcbiAgICBjb25zdCBuZWFyZXN0ID0gb3B0aW9ucy5uZWFyZXN0ICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm5lYXJlc3QgOiBmYWxzZTtcbiAgICBsZXQgbWluUmVzb2x1dGlvbjtcbiAgICBpZiAob3B0aW9ucy5taW5SZXNvbHV0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIG1pblJlc29sdXRpb24gPSBvcHRpb25zLm1pblJlc29sdXRpb247XG4gICAgfSBlbHNlIGlmIChvcHRpb25zLm1heFpvb20gIT09IHVuZGVmaW5lZCkge1xuICAgICAgbWluUmVzb2x1dGlvbiA9IHRoaXMuZ2V0UmVzb2x1dGlvbkZvclpvb20ob3B0aW9ucy5tYXhab29tKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWluUmVzb2x1dGlvbiA9IDA7XG4gICAgfVxuXG4gICAgY29uc3Qgcm90YXRlZEV4dGVudCA9IHRoaXMucm90YXRlZEV4dGVudEZvckdlb21ldHJ5KGdlb21ldHJ5KTtcblxuICAgIC8vIGNhbGN1bGF0ZSByZXNvbHV0aW9uXG4gICAgbGV0IHJlc29sdXRpb24gPSB0aGlzLmdldFJlc29sdXRpb25Gb3JFeHRlbnRJbnRlcm5hbChyb3RhdGVkRXh0ZW50LCBbXG4gICAgICBzaXplWzBdIC0gcGFkZGluZ1sxXSAtIHBhZGRpbmdbM10sXG4gICAgICBzaXplWzFdIC0gcGFkZGluZ1swXSAtIHBhZGRpbmdbMl0sXG4gICAgXSk7XG4gICAgcmVzb2x1dGlvbiA9IGlzTmFOKHJlc29sdXRpb24pXG4gICAgICA/IG1pblJlc29sdXRpb25cbiAgICAgIDogTWF0aC5tYXgocmVzb2x1dGlvbiwgbWluUmVzb2x1dGlvbik7XG4gICAgcmVzb2x1dGlvbiA9IHRoaXMuZ2V0Q29uc3RyYWluZWRSZXNvbHV0aW9uKHJlc29sdXRpb24sIG5lYXJlc3QgPyAwIDogMSk7XG5cbiAgICAvLyBjYWxjdWxhdGUgY2VudGVyXG4gICAgY29uc3Qgcm90YXRpb24gPSB0aGlzLmdldFJvdGF0aW9uKCk7XG4gICAgY29uc3Qgc2luQW5nbGUgPSBNYXRoLnNpbihyb3RhdGlvbik7XG4gICAgY29uc3QgY29zQW5nbGUgPSBNYXRoLmNvcyhyb3RhdGlvbik7XG4gICAgY29uc3QgY2VudGVyUm90ID0gZ2V0Q2VudGVyKHJvdGF0ZWRFeHRlbnQpO1xuICAgIGNlbnRlclJvdFswXSArPSAoKHBhZGRpbmdbMV0gLSBwYWRkaW5nWzNdKSAvIDIpICogcmVzb2x1dGlvbjtcbiAgICBjZW50ZXJSb3RbMV0gKz0gKChwYWRkaW5nWzBdIC0gcGFkZGluZ1syXSkgLyAyKSAqIHJlc29sdXRpb247XG4gICAgY29uc3QgY2VudGVyWCA9IGNlbnRlclJvdFswXSAqIGNvc0FuZ2xlIC0gY2VudGVyUm90WzFdICogc2luQW5nbGU7XG4gICAgY29uc3QgY2VudGVyWSA9IGNlbnRlclJvdFsxXSAqIGNvc0FuZ2xlICsgY2VudGVyUm90WzBdICogc2luQW5nbGU7XG4gICAgY29uc3QgY2VudGVyID0gdGhpcy5nZXRDb25zdHJhaW5lZENlbnRlcihbY2VudGVyWCwgY2VudGVyWV0sIHJlc29sdXRpb24pO1xuICAgIGNvbnN0IGNhbGxiYWNrID0gb3B0aW9ucy5jYWxsYmFjayA/IG9wdGlvbnMuY2FsbGJhY2sgOiBWT0lEO1xuXG4gICAgaWYgKG9wdGlvbnMuZHVyYXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5hbmltYXRlSW50ZXJuYWwoXG4gICAgICAgIHtcbiAgICAgICAgICByZXNvbHV0aW9uOiByZXNvbHV0aW9uLFxuICAgICAgICAgIGNlbnRlcjogY2VudGVyLFxuICAgICAgICAgIGR1cmF0aW9uOiBvcHRpb25zLmR1cmF0aW9uLFxuICAgICAgICAgIGVhc2luZzogb3B0aW9ucy5lYXNpbmcsXG4gICAgICAgIH0sXG4gICAgICAgIGNhbGxiYWNrXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnRhcmdldFJlc29sdXRpb25fID0gcmVzb2x1dGlvbjtcbiAgICAgIHRoaXMudGFyZ2V0Q2VudGVyXyA9IGNlbnRlcjtcbiAgICAgIHRoaXMuYXBwbHlUYXJnZXRTdGF0ZV8oZmFsc2UsIHRydWUpO1xuICAgICAgYW5pbWF0aW9uQ2FsbGJhY2soY2FsbGJhY2ssIHRydWUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDZW50ZXIgb24gY29vcmRpbmF0ZSBhbmQgdmlldyBwb3NpdGlvbi5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gY29vcmRpbmF0ZSBDb29yZGluYXRlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vc2l6ZS5qc1wiKS5TaXplfSBzaXplIEJveCBwaXhlbCBzaXplLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vcGl4ZWwuanNcIikuUGl4ZWx9IHBvc2l0aW9uIFBvc2l0aW9uIG9uIHRoZSB2aWV3IHRvIGNlbnRlciBvbi5cbiAgICogQGFwaVxuICAgKi9cbiAgY2VudGVyT24oY29vcmRpbmF0ZSwgc2l6ZSwgcG9zaXRpb24pIHtcbiAgICB0aGlzLmNlbnRlck9uSW50ZXJuYWwoXG4gICAgICBmcm9tVXNlckNvb3JkaW5hdGUoY29vcmRpbmF0ZSwgdGhpcy5nZXRQcm9qZWN0aW9uKCkpLFxuICAgICAgc2l6ZSxcbiAgICAgIHBvc2l0aW9uXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBjb29yZGluYXRlIENvb3JkaW5hdGUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9zaXplLmpzXCIpLlNpemV9IHNpemUgQm94IHBpeGVsIHNpemUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9waXhlbC5qc1wiKS5QaXhlbH0gcG9zaXRpb24gUG9zaXRpb24gb24gdGhlIHZpZXcgdG8gY2VudGVyIG9uLlxuICAgKi9cbiAgY2VudGVyT25JbnRlcm5hbChjb29yZGluYXRlLCBzaXplLCBwb3NpdGlvbikge1xuICAgIHRoaXMuc2V0Q2VudGVySW50ZXJuYWwoXG4gICAgICBjYWxjdWxhdGVDZW50ZXJPbihcbiAgICAgICAgY29vcmRpbmF0ZSxcbiAgICAgICAgc2l6ZSxcbiAgICAgICAgcG9zaXRpb24sXG4gICAgICAgIHRoaXMuZ2V0UmVzb2x1dGlvbigpLFxuICAgICAgICB0aGlzLmdldFJvdGF0aW9uKClcbiAgICAgIClcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZXMgdGhlIHNoaWZ0IGJldHdlZW4gbWFwIGFuZCB2aWV3cG9ydCBjZW50ZXIuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGNlbnRlciBDZW50ZXIuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSByZXNvbHV0aW9uIFJlc29sdXRpb24uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSByb3RhdGlvbiBSb3RhdGlvbi5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL3NpemUuanNcIikuU2l6ZX0gc2l6ZSBTaXplLlxuICAgKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fHVuZGVmaW5lZH0gQ2VudGVyIHNoaWZ0LlxuICAgKi9cbiAgY2FsY3VsYXRlQ2VudGVyU2hpZnQoY2VudGVyLCByZXNvbHV0aW9uLCByb3RhdGlvbiwgc2l6ZSkge1xuICAgIGxldCBjZW50ZXJTaGlmdDtcbiAgICBjb25zdCBwYWRkaW5nID0gdGhpcy5wYWRkaW5nXztcbiAgICBpZiAocGFkZGluZyAmJiBjZW50ZXIpIHtcbiAgICAgIGNvbnN0IHJlZHVjZWRTaXplID0gdGhpcy5nZXRWaWV3cG9ydFNpemVNaW51c1BhZGRpbmdfKC1yb3RhdGlvbik7XG4gICAgICBjb25zdCBzaGlmdGVkQ2VudGVyID0gY2FsY3VsYXRlQ2VudGVyT24oXG4gICAgICAgIGNlbnRlcixcbiAgICAgICAgc2l6ZSxcbiAgICAgICAgW3JlZHVjZWRTaXplWzBdIC8gMiArIHBhZGRpbmdbM10sIHJlZHVjZWRTaXplWzFdIC8gMiArIHBhZGRpbmdbMF1dLFxuICAgICAgICByZXNvbHV0aW9uLFxuICAgICAgICByb3RhdGlvblxuICAgICAgKTtcbiAgICAgIGNlbnRlclNoaWZ0ID0gW1xuICAgICAgICBjZW50ZXJbMF0gLSBzaGlmdGVkQ2VudGVyWzBdLFxuICAgICAgICBjZW50ZXJbMV0gLSBzaGlmdGVkQ2VudGVyWzFdLFxuICAgICAgXTtcbiAgICB9XG4gICAgcmV0dXJuIGNlbnRlclNoaWZ0O1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IElzIGRlZmluZWQuXG4gICAqL1xuICBpc0RlZigpIHtcbiAgICByZXR1cm4gISF0aGlzLmdldENlbnRlckludGVybmFsKCkgJiYgdGhpcy5nZXRSZXNvbHV0aW9uKCkgIT09IHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIHJlbGF0aXZlIGNvb3JkaW5hdGVzIHRvIHRoZSBjZW50ZXIgb2YgdGhlIHZpZXcuIEFueSBleHRlbnQgY29uc3RyYWludCB3aWxsIGFwcGx5LlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBkZWx0YUNvb3JkaW5hdGVzIFJlbGF0aXZlIHZhbHVlIHRvIGFkZC5cbiAgICogQGFwaVxuICAgKi9cbiAgYWRqdXN0Q2VudGVyKGRlbHRhQ29vcmRpbmF0ZXMpIHtcbiAgICBjb25zdCBjZW50ZXIgPSB0b1VzZXJDb29yZGluYXRlKHRoaXMudGFyZ2V0Q2VudGVyXywgdGhpcy5nZXRQcm9qZWN0aW9uKCkpO1xuICAgIHRoaXMuc2V0Q2VudGVyKFtcbiAgICAgIGNlbnRlclswXSArIGRlbHRhQ29vcmRpbmF0ZXNbMF0sXG4gICAgICBjZW50ZXJbMV0gKyBkZWx0YUNvb3JkaW5hdGVzWzFdLFxuICAgIF0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgcmVsYXRpdmUgY29vcmRpbmF0ZXMgdG8gdGhlIGNlbnRlciBvZiB0aGUgdmlldy4gQW55IGV4dGVudCBjb25zdHJhaW50IHdpbGwgYXBwbHkuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGRlbHRhQ29vcmRpbmF0ZXMgUmVsYXRpdmUgdmFsdWUgdG8gYWRkLlxuICAgKi9cbiAgYWRqdXN0Q2VudGVySW50ZXJuYWwoZGVsdGFDb29yZGluYXRlcykge1xuICAgIGNvbnN0IGNlbnRlciA9IHRoaXMudGFyZ2V0Q2VudGVyXztcbiAgICB0aGlzLnNldENlbnRlckludGVybmFsKFtcbiAgICAgIGNlbnRlclswXSArIGRlbHRhQ29vcmRpbmF0ZXNbMF0sXG4gICAgICBjZW50ZXJbMV0gKyBkZWx0YUNvb3JkaW5hdGVzWzFdLFxuICAgIF0pO1xuICB9XG5cbiAgLyoqXG4gICAqIE11bHRpcGx5IHRoZSB2aWV3IHJlc29sdXRpb24gYnkgYSByYXRpbywgb3B0aW9uYWxseSB1c2luZyBhbiBhbmNob3IuIEFueSByZXNvbHV0aW9uXG4gICAqIGNvbnN0cmFpbnQgd2lsbCBhcHBseS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHJhdGlvIFRoZSByYXRpbyB0byBhcHBseSBvbiB0aGUgdmlldyByZXNvbHV0aW9uLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBbYW5jaG9yXSBUaGUgb3JpZ2luIG9mIHRoZSB0cmFuc2Zvcm1hdGlvbi5cbiAgICogQGFwaVxuICAgKi9cbiAgYWRqdXN0UmVzb2x1dGlvbihyYXRpbywgYW5jaG9yKSB7XG4gICAgYW5jaG9yID0gYW5jaG9yICYmIGZyb21Vc2VyQ29vcmRpbmF0ZShhbmNob3IsIHRoaXMuZ2V0UHJvamVjdGlvbigpKTtcbiAgICB0aGlzLmFkanVzdFJlc29sdXRpb25JbnRlcm5hbChyYXRpbywgYW5jaG9yKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNdWx0aXBseSB0aGUgdmlldyByZXNvbHV0aW9uIGJ5IGEgcmF0aW8sIG9wdGlvbmFsbHkgdXNpbmcgYW4gYW5jaG9yLiBBbnkgcmVzb2x1dGlvblxuICAgKiBjb25zdHJhaW50IHdpbGwgYXBwbHkuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSByYXRpbyBUaGUgcmF0aW8gdG8gYXBwbHkgb24gdGhlIHZpZXcgcmVzb2x1dGlvbi5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gW2FuY2hvcl0gVGhlIG9yaWdpbiBvZiB0aGUgdHJhbnNmb3JtYXRpb24uXG4gICAqL1xuICBhZGp1c3RSZXNvbHV0aW9uSW50ZXJuYWwocmF0aW8sIGFuY2hvcikge1xuICAgIGNvbnN0IGlzTW92aW5nID0gdGhpcy5nZXRBbmltYXRpbmcoKSB8fCB0aGlzLmdldEludGVyYWN0aW5nKCk7XG4gICAgY29uc3Qgc2l6ZSA9IHRoaXMuZ2V0Vmlld3BvcnRTaXplXyh0aGlzLmdldFJvdGF0aW9uKCkpO1xuICAgIGNvbnN0IG5ld1Jlc29sdXRpb24gPSB0aGlzLmNvbnN0cmFpbnRzXy5yZXNvbHV0aW9uKFxuICAgICAgdGhpcy50YXJnZXRSZXNvbHV0aW9uXyAqIHJhdGlvLFxuICAgICAgMCxcbiAgICAgIHNpemUsXG4gICAgICBpc01vdmluZ1xuICAgICk7XG5cbiAgICBpZiAoYW5jaG9yKSB7XG4gICAgICB0aGlzLnRhcmdldENlbnRlcl8gPSB0aGlzLmNhbGN1bGF0ZUNlbnRlclpvb20obmV3UmVzb2x1dGlvbiwgYW5jaG9yKTtcbiAgICB9XG5cbiAgICB0aGlzLnRhcmdldFJlc29sdXRpb25fICo9IHJhdGlvO1xuICAgIHRoaXMuYXBwbHlUYXJnZXRTdGF0ZV8oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGEgdmFsdWUgdG8gdGhlIHZpZXcgem9vbSBsZXZlbCwgb3B0aW9uYWxseSB1c2luZyBhbiBhbmNob3IuIEFueSByZXNvbHV0aW9uXG4gICAqIGNvbnN0cmFpbnQgd2lsbCBhcHBseS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGRlbHRhIFJlbGF0aXZlIHZhbHVlIHRvIGFkZCB0byB0aGUgem9vbSBsZXZlbC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gW2FuY2hvcl0gVGhlIG9yaWdpbiBvZiB0aGUgdHJhbnNmb3JtYXRpb24uXG4gICAqIEBhcGlcbiAgICovXG4gIGFkanVzdFpvb20oZGVsdGEsIGFuY2hvcikge1xuICAgIHRoaXMuYWRqdXN0UmVzb2x1dGlvbihNYXRoLnBvdyh0aGlzLnpvb21GYWN0b3JfLCAtZGVsdGEpLCBhbmNob3IpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYSB2YWx1ZSB0byB0aGUgdmlldyByb3RhdGlvbiwgb3B0aW9uYWxseSB1c2luZyBhbiBhbmNob3IuIEFueSByb3RhdGlvblxuICAgKiBjb25zdHJhaW50IHdpbGwgYXBwbHkuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkZWx0YSBSZWxhdGl2ZSB2YWx1ZSB0byBhZGQgdG8gdGhlIHpvb20gcm90YXRpb24sIGluIHJhZGlhbnMuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IFthbmNob3JdIFRoZSByb3RhdGlvbiBjZW50ZXIuXG4gICAqIEBhcGlcbiAgICovXG4gIGFkanVzdFJvdGF0aW9uKGRlbHRhLCBhbmNob3IpIHtcbiAgICBpZiAoYW5jaG9yKSB7XG4gICAgICBhbmNob3IgPSBmcm9tVXNlckNvb3JkaW5hdGUoYW5jaG9yLCB0aGlzLmdldFByb2plY3Rpb24oKSk7XG4gICAgfVxuICAgIHRoaXMuYWRqdXN0Um90YXRpb25JbnRlcm5hbChkZWx0YSwgYW5jaG9yKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gZGVsdGEgUmVsYXRpdmUgdmFsdWUgdG8gYWRkIHRvIHRoZSB6b29tIHJvdGF0aW9uLCBpbiByYWRpYW5zLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBbYW5jaG9yXSBUaGUgcm90YXRpb24gY2VudGVyLlxuICAgKi9cbiAgYWRqdXN0Um90YXRpb25JbnRlcm5hbChkZWx0YSwgYW5jaG9yKSB7XG4gICAgY29uc3QgaXNNb3ZpbmcgPSB0aGlzLmdldEFuaW1hdGluZygpIHx8IHRoaXMuZ2V0SW50ZXJhY3RpbmcoKTtcbiAgICBjb25zdCBuZXdSb3RhdGlvbiA9IHRoaXMuY29uc3RyYWludHNfLnJvdGF0aW9uKFxuICAgICAgdGhpcy50YXJnZXRSb3RhdGlvbl8gKyBkZWx0YSxcbiAgICAgIGlzTW92aW5nXG4gICAgKTtcbiAgICBpZiAoYW5jaG9yKSB7XG4gICAgICB0aGlzLnRhcmdldENlbnRlcl8gPSB0aGlzLmNhbGN1bGF0ZUNlbnRlclJvdGF0ZShuZXdSb3RhdGlvbiwgYW5jaG9yKTtcbiAgICB9XG4gICAgdGhpcy50YXJnZXRSb3RhdGlvbl8gKz0gZGVsdGE7XG4gICAgdGhpcy5hcHBseVRhcmdldFN0YXRlXygpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgY2VudGVyIG9mIHRoZSBjdXJyZW50IHZpZXcuIEFueSBleHRlbnQgY29uc3RyYWludCB3aWxsIGFwcGx5LlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfHVuZGVmaW5lZH0gY2VudGVyIFRoZSBjZW50ZXIgb2YgdGhlIHZpZXcuXG4gICAqIEBvYnNlcnZhYmxlXG4gICAqIEBhcGlcbiAgICovXG4gIHNldENlbnRlcihjZW50ZXIpIHtcbiAgICB0aGlzLnNldENlbnRlckludGVybmFsKFxuICAgICAgY2VudGVyID8gZnJvbVVzZXJDb29yZGluYXRlKGNlbnRlciwgdGhpcy5nZXRQcm9qZWN0aW9uKCkpIDogY2VudGVyXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGNlbnRlciB1c2luZyB0aGUgdmlldyBwcm9qZWN0aW9uIChub3QgdGhlIHVzZXIgcHJvamVjdGlvbikuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV8dW5kZWZpbmVkfSBjZW50ZXIgVGhlIGNlbnRlciBvZiB0aGUgdmlldy5cbiAgICovXG4gIHNldENlbnRlckludGVybmFsKGNlbnRlcikge1xuICAgIHRoaXMudGFyZ2V0Q2VudGVyXyA9IGNlbnRlcjtcbiAgICB0aGlzLmFwcGx5VGFyZ2V0U3RhdGVfKCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL1ZpZXdIaW50LmpzXCIpLmRlZmF1bHR9IGhpbnQgSGludC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGRlbHRhIERlbHRhLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IE5ldyB2YWx1ZS5cbiAgICovXG4gIHNldEhpbnQoaGludCwgZGVsdGEpIHtcbiAgICB0aGlzLmhpbnRzX1toaW50XSArPSBkZWx0YTtcbiAgICB0aGlzLmNoYW5nZWQoKTtcbiAgICByZXR1cm4gdGhpcy5oaW50c19baGludF07XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSByZXNvbHV0aW9uIGZvciB0aGlzIHZpZXcuIEFueSByZXNvbHV0aW9uIGNvbnN0cmFpbnQgd2lsbCBhcHBseS5cbiAgICogQHBhcmFtIHtudW1iZXJ8dW5kZWZpbmVkfSByZXNvbHV0aW9uIFRoZSByZXNvbHV0aW9uIG9mIHRoZSB2aWV3LlxuICAgKiBAb2JzZXJ2YWJsZVxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRSZXNvbHV0aW9uKHJlc29sdXRpb24pIHtcbiAgICB0aGlzLnRhcmdldFJlc29sdXRpb25fID0gcmVzb2x1dGlvbjtcbiAgICB0aGlzLmFwcGx5VGFyZ2V0U3RhdGVfKCk7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSByb3RhdGlvbiBmb3IgdGhpcyB2aWV3LiBBbnkgcm90YXRpb24gY29uc3RyYWludCB3aWxsIGFwcGx5LlxuICAgKiBAcGFyYW0ge251bWJlcn0gcm90YXRpb24gVGhlIHJvdGF0aW9uIG9mIHRoZSB2aWV3IGluIHJhZGlhbnMuXG4gICAqIEBvYnNlcnZhYmxlXG4gICAqIEBhcGlcbiAgICovXG4gIHNldFJvdGF0aW9uKHJvdGF0aW9uKSB7XG4gICAgdGhpcy50YXJnZXRSb3RhdGlvbl8gPSByb3RhdGlvbjtcbiAgICB0aGlzLmFwcGx5VGFyZ2V0U3RhdGVfKCk7XG4gIH1cblxuICAvKipcbiAgICogWm9vbSB0byBhIHNwZWNpZmljIHpvb20gbGV2ZWwuIEFueSByZXNvbHV0aW9uIGNvbnN0cmFpbiB3aWxsIGFwcGx5LlxuICAgKiBAcGFyYW0ge251bWJlcn0gem9vbSBab29tIGxldmVsLlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRab29tKHpvb20pIHtcbiAgICB0aGlzLnNldFJlc29sdXRpb24odGhpcy5nZXRSZXNvbHV0aW9uRm9yWm9vbSh6b29tKSk7XG4gIH1cblxuICAvKipcbiAgICogUmVjb21wdXRlIHJvdGF0aW9uL3Jlc29sdXRpb24vY2VudGVyIGJhc2VkIG9uIHRhcmdldCB2YWx1ZXMuXG4gICAqIE5vdGU6IHdlIGhhdmUgdG8gY29tcHV0ZSByb3RhdGlvbiBmaXJzdCwgdGhlbiByZXNvbHV0aW9uIGFuZCBjZW50ZXIgY29uc2lkZXJpbmcgdGhhdFxuICAgKiBwYXJhbWV0ZXJzIGNhbiBpbmZsdWVuY2Ugb25lIGFub3RoZXIgaW4gY2FzZSBhIHZpZXcgZXh0ZW50IGNvbnN0cmFpbnQgaXMgcHJlc2VudC5cbiAgICogQHBhcmFtIHtib29sZWFufSBbZG9Ob3RDYW5jZWxBbmltc10gRG8gbm90IGNhbmNlbCBhbmltYXRpb25zLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmb3JjZU1vdmluZ10gQXBwbHkgY29uc3RyYWludHMgYXMgaWYgdGhlIHZpZXcgaXMgbW92aW5nLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYXBwbHlUYXJnZXRTdGF0ZV8oZG9Ob3RDYW5jZWxBbmltcywgZm9yY2VNb3ZpbmcpIHtcbiAgICBjb25zdCBpc01vdmluZyA9XG4gICAgICB0aGlzLmdldEFuaW1hdGluZygpIHx8IHRoaXMuZ2V0SW50ZXJhY3RpbmcoKSB8fCBmb3JjZU1vdmluZztcblxuICAgIC8vIGNvbXB1dGUgcm90YXRpb25cbiAgICBjb25zdCBuZXdSb3RhdGlvbiA9IHRoaXMuY29uc3RyYWludHNfLnJvdGF0aW9uKFxuICAgICAgdGhpcy50YXJnZXRSb3RhdGlvbl8sXG4gICAgICBpc01vdmluZ1xuICAgICk7XG4gICAgY29uc3Qgc2l6ZSA9IHRoaXMuZ2V0Vmlld3BvcnRTaXplXyhuZXdSb3RhdGlvbik7XG4gICAgY29uc3QgbmV3UmVzb2x1dGlvbiA9IHRoaXMuY29uc3RyYWludHNfLnJlc29sdXRpb24oXG4gICAgICB0aGlzLnRhcmdldFJlc29sdXRpb25fLFxuICAgICAgMCxcbiAgICAgIHNpemUsXG4gICAgICBpc01vdmluZ1xuICAgICk7XG4gICAgY29uc3QgbmV3Q2VudGVyID0gdGhpcy5jb25zdHJhaW50c18uY2VudGVyKFxuICAgICAgdGhpcy50YXJnZXRDZW50ZXJfLFxuICAgICAgbmV3UmVzb2x1dGlvbixcbiAgICAgIHNpemUsXG4gICAgICBpc01vdmluZyxcbiAgICAgIHRoaXMuY2FsY3VsYXRlQ2VudGVyU2hpZnQoXG4gICAgICAgIHRoaXMudGFyZ2V0Q2VudGVyXyxcbiAgICAgICAgbmV3UmVzb2x1dGlvbixcbiAgICAgICAgbmV3Um90YXRpb24sXG4gICAgICAgIHNpemVcbiAgICAgIClcbiAgICApO1xuXG4gICAgaWYgKHRoaXMuZ2V0KFZpZXdQcm9wZXJ0eS5ST1RBVElPTikgIT09IG5ld1JvdGF0aW9uKSB7XG4gICAgICB0aGlzLnNldChWaWV3UHJvcGVydHkuUk9UQVRJT04sIG5ld1JvdGF0aW9uKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuZ2V0KFZpZXdQcm9wZXJ0eS5SRVNPTFVUSU9OKSAhPT0gbmV3UmVzb2x1dGlvbikge1xuICAgICAgdGhpcy5zZXQoVmlld1Byb3BlcnR5LlJFU09MVVRJT04sIG5ld1Jlc29sdXRpb24pO1xuICAgICAgdGhpcy5zZXQoJ3pvb20nLCB0aGlzLmdldFpvb20oKSwgdHJ1ZSk7XG4gICAgfVxuICAgIGlmIChcbiAgICAgICFuZXdDZW50ZXIgfHxcbiAgICAgICF0aGlzLmdldChWaWV3UHJvcGVydHkuQ0VOVEVSKSB8fFxuICAgICAgIWVxdWFscyh0aGlzLmdldChWaWV3UHJvcGVydHkuQ0VOVEVSKSwgbmV3Q2VudGVyKVxuICAgICkge1xuICAgICAgdGhpcy5zZXQoVmlld1Byb3BlcnR5LkNFTlRFUiwgbmV3Q2VudGVyKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5nZXRBbmltYXRpbmcoKSAmJiAhZG9Ob3RDYW5jZWxBbmltcykge1xuICAgICAgdGhpcy5jYW5jZWxBbmltYXRpb25zKCk7XG4gICAgfVxuICAgIHRoaXMuY2FuY2VsQW5jaG9yXyA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBJZiBhbnkgY29uc3RyYWludHMgbmVlZCB0byBiZSBhcHBsaWVkLCBhbiBhbmltYXRpb24gd2lsbCBiZSB0cmlnZ2VyZWQuXG4gICAqIFRoaXMgaXMgdHlwaWNhbGx5IGRvbmUgb24gaW50ZXJhY3Rpb24gZW5kLlxuICAgKiBOb3RlOiBjYWxsaW5nIHRoaXMgd2l0aCBhIGR1cmF0aW9uIG9mIDAgd2lsbCBhcHBseSB0aGUgY29uc3RyYWluZWQgdmFsdWVzIHN0cmFpZ2h0IGF3YXksXG4gICAqIHdpdGhvdXQgYW5pbWF0aW9uLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW2R1cmF0aW9uXSBUaGUgYW5pbWF0aW9uIGR1cmF0aW9uIGluIG1zLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW3Jlc29sdXRpb25EaXJlY3Rpb25dIFdoaWNoIGRpcmVjdGlvbiB0byB6b29tLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBbYW5jaG9yXSBUaGUgb3JpZ2luIG9mIHRoZSB0cmFuc2Zvcm1hdGlvbi5cbiAgICovXG4gIHJlc29sdmVDb25zdHJhaW50cyhkdXJhdGlvbiwgcmVzb2x1dGlvbkRpcmVjdGlvbiwgYW5jaG9yKSB7XG4gICAgZHVyYXRpb24gPSBkdXJhdGlvbiAhPT0gdW5kZWZpbmVkID8gZHVyYXRpb24gOiAyMDA7XG4gICAgY29uc3QgZGlyZWN0aW9uID0gcmVzb2x1dGlvbkRpcmVjdGlvbiB8fCAwO1xuXG4gICAgY29uc3QgbmV3Um90YXRpb24gPSB0aGlzLmNvbnN0cmFpbnRzXy5yb3RhdGlvbih0aGlzLnRhcmdldFJvdGF0aW9uXyk7XG4gICAgY29uc3Qgc2l6ZSA9IHRoaXMuZ2V0Vmlld3BvcnRTaXplXyhuZXdSb3RhdGlvbik7XG4gICAgY29uc3QgbmV3UmVzb2x1dGlvbiA9IHRoaXMuY29uc3RyYWludHNfLnJlc29sdXRpb24oXG4gICAgICB0aGlzLnRhcmdldFJlc29sdXRpb25fLFxuICAgICAgZGlyZWN0aW9uLFxuICAgICAgc2l6ZVxuICAgICk7XG4gICAgY29uc3QgbmV3Q2VudGVyID0gdGhpcy5jb25zdHJhaW50c18uY2VudGVyKFxuICAgICAgdGhpcy50YXJnZXRDZW50ZXJfLFxuICAgICAgbmV3UmVzb2x1dGlvbixcbiAgICAgIHNpemUsXG4gICAgICBmYWxzZSxcbiAgICAgIHRoaXMuY2FsY3VsYXRlQ2VudGVyU2hpZnQoXG4gICAgICAgIHRoaXMudGFyZ2V0Q2VudGVyXyxcbiAgICAgICAgbmV3UmVzb2x1dGlvbixcbiAgICAgICAgbmV3Um90YXRpb24sXG4gICAgICAgIHNpemVcbiAgICAgIClcbiAgICApO1xuXG4gICAgaWYgKGR1cmF0aW9uID09PSAwICYmICF0aGlzLmNhbmNlbEFuY2hvcl8pIHtcbiAgICAgIHRoaXMudGFyZ2V0UmVzb2x1dGlvbl8gPSBuZXdSZXNvbHV0aW9uO1xuICAgICAgdGhpcy50YXJnZXRSb3RhdGlvbl8gPSBuZXdSb3RhdGlvbjtcbiAgICAgIHRoaXMudGFyZ2V0Q2VudGVyXyA9IG5ld0NlbnRlcjtcbiAgICAgIHRoaXMuYXBwbHlUYXJnZXRTdGF0ZV8oKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBhbmNob3IgPSBhbmNob3IgfHwgKGR1cmF0aW9uID09PSAwID8gdGhpcy5jYW5jZWxBbmNob3JfIDogdW5kZWZpbmVkKTtcbiAgICB0aGlzLmNhbmNlbEFuY2hvcl8gPSB1bmRlZmluZWQ7XG5cbiAgICBpZiAoXG4gICAgICB0aGlzLmdldFJlc29sdXRpb24oKSAhPT0gbmV3UmVzb2x1dGlvbiB8fFxuICAgICAgdGhpcy5nZXRSb3RhdGlvbigpICE9PSBuZXdSb3RhdGlvbiB8fFxuICAgICAgIXRoaXMuZ2V0Q2VudGVySW50ZXJuYWwoKSB8fFxuICAgICAgIWVxdWFscyh0aGlzLmdldENlbnRlckludGVybmFsKCksIG5ld0NlbnRlcilcbiAgICApIHtcbiAgICAgIGlmICh0aGlzLmdldEFuaW1hdGluZygpKSB7XG4gICAgICAgIHRoaXMuY2FuY2VsQW5pbWF0aW9ucygpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmFuaW1hdGVJbnRlcm5hbCh7XG4gICAgICAgIHJvdGF0aW9uOiBuZXdSb3RhdGlvbixcbiAgICAgICAgY2VudGVyOiBuZXdDZW50ZXIsXG4gICAgICAgIHJlc29sdXRpb246IG5ld1Jlc29sdXRpb24sXG4gICAgICAgIGR1cmF0aW9uOiBkdXJhdGlvbixcbiAgICAgICAgZWFzaW5nOiBlYXNlT3V0LFxuICAgICAgICBhbmNob3I6IGFuY2hvcixcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBOb3RpZnkgdGhlIFZpZXcgdGhhdCBhbiBpbnRlcmFjdGlvbiBoYXMgc3RhcnRlZC5cbiAgICogVGhlIHZpZXcgc3RhdGUgd2lsbCBiZSByZXNvbHZlZCB0byBhIHN0YWJsZSBvbmUgaWYgbmVlZGVkXG4gICAqIChkZXBlbmRpbmcgb24gaXRzIGNvbnN0cmFpbnRzKS5cbiAgICogQGFwaVxuICAgKi9cbiAgYmVnaW5JbnRlcmFjdGlvbigpIHtcbiAgICB0aGlzLnJlc29sdmVDb25zdHJhaW50cygwKTtcblxuICAgIHRoaXMuc2V0SGludChWaWV3SGludC5JTlRFUkFDVElORywgMSk7XG4gIH1cblxuICAvKipcbiAgICogTm90aWZ5IHRoZSBWaWV3IHRoYXQgYW4gaW50ZXJhY3Rpb24gaGFzIGVuZGVkLiBUaGUgdmlldyBzdGF0ZSB3aWxsIGJlIHJlc29sdmVkXG4gICAqIHRvIGEgc3RhYmxlIG9uZSBpZiBuZWVkZWQgKGRlcGVuZGluZyBvbiBpdHMgY29uc3RyYWludHMpLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW2R1cmF0aW9uXSBBbmltYXRpb24gZHVyYXRpb24gaW4gbXMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbcmVzb2x1dGlvbkRpcmVjdGlvbl0gV2hpY2ggZGlyZWN0aW9uIHRvIHpvb20uXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IFthbmNob3JdIFRoZSBvcmlnaW4gb2YgdGhlIHRyYW5zZm9ybWF0aW9uLlxuICAgKiBAYXBpXG4gICAqL1xuICBlbmRJbnRlcmFjdGlvbihkdXJhdGlvbiwgcmVzb2x1dGlvbkRpcmVjdGlvbiwgYW5jaG9yKSB7XG4gICAgYW5jaG9yID0gYW5jaG9yICYmIGZyb21Vc2VyQ29vcmRpbmF0ZShhbmNob3IsIHRoaXMuZ2V0UHJvamVjdGlvbigpKTtcbiAgICB0aGlzLmVuZEludGVyYWN0aW9uSW50ZXJuYWwoZHVyYXRpb24sIHJlc29sdXRpb25EaXJlY3Rpb24sIGFuY2hvcik7XG4gIH1cblxuICAvKipcbiAgICogTm90aWZ5IHRoZSBWaWV3IHRoYXQgYW4gaW50ZXJhY3Rpb24gaGFzIGVuZGVkLiBUaGUgdmlldyBzdGF0ZSB3aWxsIGJlIHJlc29sdmVkXG4gICAqIHRvIGEgc3RhYmxlIG9uZSBpZiBuZWVkZWQgKGRlcGVuZGluZyBvbiBpdHMgY29uc3RyYWludHMpLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW2R1cmF0aW9uXSBBbmltYXRpb24gZHVyYXRpb24gaW4gbXMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbcmVzb2x1dGlvbkRpcmVjdGlvbl0gV2hpY2ggZGlyZWN0aW9uIHRvIHpvb20uXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IFthbmNob3JdIFRoZSBvcmlnaW4gb2YgdGhlIHRyYW5zZm9ybWF0aW9uLlxuICAgKi9cbiAgZW5kSW50ZXJhY3Rpb25JbnRlcm5hbChkdXJhdGlvbiwgcmVzb2x1dGlvbkRpcmVjdGlvbiwgYW5jaG9yKSB7XG4gICAgaWYgKCF0aGlzLmdldEludGVyYWN0aW5nKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5zZXRIaW50KFZpZXdIaW50LklOVEVSQUNUSU5HLCAtMSk7XG4gICAgdGhpcy5yZXNvbHZlQ29uc3RyYWludHMoZHVyYXRpb24sIHJlc29sdXRpb25EaXJlY3Rpb24sIGFuY2hvcik7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGEgdmFsaWQgcG9zaXRpb24gZm9yIHRoZSB2aWV3IGNlbnRlciBhY2NvcmRpbmcgdG8gdGhlIGN1cnJlbnQgY29uc3RyYWludHMuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV8dW5kZWZpbmVkfSB0YXJnZXRDZW50ZXIgVGFyZ2V0IGNlbnRlciBwb3NpdGlvbi5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFt0YXJnZXRSZXNvbHV0aW9uXSBUYXJnZXQgcmVzb2x1dGlvbi4gSWYgbm90IHN1cHBsaWVkLCB0aGUgY3VycmVudCBvbmUgd2lsbCBiZSB1c2VkLlxuICAgKiBUaGlzIGlzIHVzZWZ1bCB0byBndWVzcyBhIHZhbGlkIGNlbnRlciBwb3NpdGlvbiBhdCBhIGRpZmZlcmVudCB6b29tIGxldmVsLlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZXx1bmRlZmluZWR9IFZhbGlkIGNlbnRlciBwb3NpdGlvbi5cbiAgICovXG4gIGdldENvbnN0cmFpbmVkQ2VudGVyKHRhcmdldENlbnRlciwgdGFyZ2V0UmVzb2x1dGlvbikge1xuICAgIGNvbnN0IHNpemUgPSB0aGlzLmdldFZpZXdwb3J0U2l6ZV8odGhpcy5nZXRSb3RhdGlvbigpKTtcbiAgICByZXR1cm4gdGhpcy5jb25zdHJhaW50c18uY2VudGVyKFxuICAgICAgdGFyZ2V0Q2VudGVyLFxuICAgICAgdGFyZ2V0UmVzb2x1dGlvbiB8fCB0aGlzLmdldFJlc29sdXRpb24oKSxcbiAgICAgIHNpemVcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhIHZhbGlkIHpvb20gbGV2ZWwgYWNjb3JkaW5nIHRvIHRoZSBjdXJyZW50IHZpZXcgY29uc3RyYWludHMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfHVuZGVmaW5lZH0gdGFyZ2V0Wm9vbSBUYXJnZXQgem9vbS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtkaXJlY3Rpb249MF0gSW5kaWNhdGUgd2hpY2ggcmVzb2x1dGlvbiBzaG91bGQgYmUgdXNlZFxuICAgKiBieSBhIHJlbmRlcmVyIGlmIHRoZSB2aWV3IHJlc29sdXRpb24gZG9lcyBub3QgbWF0Y2ggYW55IHJlc29sdXRpb24gb2YgdGhlIHRpbGUgc291cmNlLlxuICAgKiBJZiAwLCB0aGUgbmVhcmVzdCByZXNvbHV0aW9uIHdpbGwgYmUgdXNlZC4gSWYgMSwgdGhlIG5lYXJlc3QgbG93ZXIgcmVzb2x1dGlvblxuICAgKiB3aWxsIGJlIHVzZWQuIElmIC0xLCB0aGUgbmVhcmVzdCBoaWdoZXIgcmVzb2x1dGlvbiB3aWxsIGJlIHVzZWQuXG4gICAqIEByZXR1cm4ge251bWJlcnx1bmRlZmluZWR9IFZhbGlkIHpvb20gbGV2ZWwuXG4gICAqL1xuICBnZXRDb25zdHJhaW5lZFpvb20odGFyZ2V0Wm9vbSwgZGlyZWN0aW9uKSB7XG4gICAgY29uc3QgdGFyZ2V0UmVzID0gdGhpcy5nZXRSZXNvbHV0aW9uRm9yWm9vbSh0YXJnZXRab29tKTtcbiAgICByZXR1cm4gdGhpcy5nZXRab29tRm9yUmVzb2x1dGlvbihcbiAgICAgIHRoaXMuZ2V0Q29uc3RyYWluZWRSZXNvbHV0aW9uKHRhcmdldFJlcywgZGlyZWN0aW9uKVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGEgdmFsaWQgcmVzb2x1dGlvbiBhY2NvcmRpbmcgdG8gdGhlIGN1cnJlbnQgdmlldyBjb25zdHJhaW50cy5cbiAgICogQHBhcmFtIHtudW1iZXJ8dW5kZWZpbmVkfSB0YXJnZXRSZXNvbHV0aW9uIFRhcmdldCByZXNvbHV0aW9uLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW2RpcmVjdGlvbj0wXSBJbmRpY2F0ZSB3aGljaCByZXNvbHV0aW9uIHNob3VsZCBiZSB1c2VkXG4gICAqIGJ5IGEgcmVuZGVyZXIgaWYgdGhlIHZpZXcgcmVzb2x1dGlvbiBkb2VzIG5vdCBtYXRjaCBhbnkgcmVzb2x1dGlvbiBvZiB0aGUgdGlsZSBzb3VyY2UuXG4gICAqIElmIDAsIHRoZSBuZWFyZXN0IHJlc29sdXRpb24gd2lsbCBiZSB1c2VkLiBJZiAxLCB0aGUgbmVhcmVzdCBsb3dlciByZXNvbHV0aW9uXG4gICAqIHdpbGwgYmUgdXNlZC4gSWYgLTEsIHRoZSBuZWFyZXN0IGhpZ2hlciByZXNvbHV0aW9uIHdpbGwgYmUgdXNlZC5cbiAgICogQHJldHVybiB7bnVtYmVyfHVuZGVmaW5lZH0gVmFsaWQgcmVzb2x1dGlvbi5cbiAgICovXG4gIGdldENvbnN0cmFpbmVkUmVzb2x1dGlvbih0YXJnZXRSZXNvbHV0aW9uLCBkaXJlY3Rpb24pIHtcbiAgICBkaXJlY3Rpb24gPSBkaXJlY3Rpb24gfHwgMDtcbiAgICBjb25zdCBzaXplID0gdGhpcy5nZXRWaWV3cG9ydFNpemVfKHRoaXMuZ2V0Um90YXRpb24oKSk7XG5cbiAgICByZXR1cm4gdGhpcy5jb25zdHJhaW50c18ucmVzb2x1dGlvbih0YXJnZXRSZXNvbHV0aW9uLCBkaXJlY3Rpb24sIHNpemUpO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2suXG4gKiBAcGFyYW0geyp9IHJldHVyblZhbHVlIFJldHVybiB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gYW5pbWF0aW9uQ2FsbGJhY2soY2FsbGJhY2ssIHJldHVyblZhbHVlKSB7XG4gIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgIGNhbGxiYWNrKHJldHVyblZhbHVlKTtcbiAgfSwgMCk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtWaWV3T3B0aW9uc30gb3B0aW9ucyBWaWV3IG9wdGlvbnMuXG4gKiBAcmV0dXJuIHtpbXBvcnQoXCIuL2NlbnRlcmNvbnN0cmFpbnQuanNcIikuVHlwZX0gVGhlIGNvbnN0cmFpbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVDZW50ZXJDb25zdHJhaW50KG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMuZXh0ZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICBjb25zdCBzbW9vdGggPVxuICAgICAgb3B0aW9ucy5zbW9vdGhFeHRlbnRDb25zdHJhaW50ICE9PSB1bmRlZmluZWRcbiAgICAgICAgPyBvcHRpb25zLnNtb290aEV4dGVudENvbnN0cmFpbnRcbiAgICAgICAgOiB0cnVlO1xuICAgIHJldHVybiBjcmVhdGVFeHRlbnQob3B0aW9ucy5leHRlbnQsIG9wdGlvbnMuY29uc3RyYWluT25seUNlbnRlciwgc21vb3RoKTtcbiAgfVxuXG4gIGNvbnN0IHByb2plY3Rpb24gPSBjcmVhdGVQcm9qZWN0aW9uKG9wdGlvbnMucHJvamVjdGlvbiwgJ0VQU0c6Mzg1NycpO1xuICBpZiAob3B0aW9ucy5tdWx0aVdvcmxkICE9PSB0cnVlICYmIHByb2plY3Rpb24uaXNHbG9iYWwoKSkge1xuICAgIGNvbnN0IGV4dGVudCA9IHByb2plY3Rpb24uZ2V0RXh0ZW50KCkuc2xpY2UoKTtcbiAgICBleHRlbnRbMF0gPSAtSW5maW5pdHk7XG4gICAgZXh0ZW50WzJdID0gSW5maW5pdHk7XG4gICAgcmV0dXJuIGNyZWF0ZUV4dGVudChleHRlbnQsIGZhbHNlLCBmYWxzZSk7XG4gIH1cblxuICByZXR1cm4gY2VudGVyTm9uZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1ZpZXdPcHRpb25zfSBvcHRpb25zIFZpZXcgb3B0aW9ucy5cbiAqIEByZXR1cm4ge3tjb25zdHJhaW50OiBpbXBvcnQoXCIuL3Jlc29sdXRpb25jb25zdHJhaW50LmpzXCIpLlR5cGUsIG1heFJlc29sdXRpb246IG51bWJlcixcbiAqICAgICBtaW5SZXNvbHV0aW9uOiBudW1iZXIsIG1pblpvb206IG51bWJlciwgem9vbUZhY3RvcjogbnVtYmVyfX0gVGhlIGNvbnN0cmFpbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVSZXNvbHV0aW9uQ29uc3RyYWludChvcHRpb25zKSB7XG4gIGxldCByZXNvbHV0aW9uQ29uc3RyYWludDtcbiAgbGV0IG1heFJlc29sdXRpb247XG4gIGxldCBtaW5SZXNvbHV0aW9uO1xuXG4gIC8vIFRPRE86IG1vdmUgdGhlc2UgdG8gYmUgb2wgY29uc3RhbnRzXG4gIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vb3BlbmxheWVycy9vcGVubGF5ZXJzL2lzc3Vlcy8yMDc2XG4gIGNvbnN0IGRlZmF1bHRNYXhab29tID0gMjg7XG4gIGNvbnN0IGRlZmF1bHRab29tRmFjdG9yID0gMjtcblxuICBsZXQgbWluWm9vbSA9XG4gICAgb3B0aW9ucy5taW5ab29tICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm1pblpvb20gOiBERUZBVUxUX01JTl9aT09NO1xuXG4gIGxldCBtYXhab29tID1cbiAgICBvcHRpb25zLm1heFpvb20gIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMubWF4Wm9vbSA6IGRlZmF1bHRNYXhab29tO1xuXG4gIGNvbnN0IHpvb21GYWN0b3IgPVxuICAgIG9wdGlvbnMuem9vbUZhY3RvciAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy56b29tRmFjdG9yIDogZGVmYXVsdFpvb21GYWN0b3I7XG5cbiAgY29uc3QgbXVsdGlXb3JsZCA9XG4gICAgb3B0aW9ucy5tdWx0aVdvcmxkICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm11bHRpV29ybGQgOiBmYWxzZTtcblxuICBjb25zdCBzbW9vdGggPVxuICAgIG9wdGlvbnMuc21vb3RoUmVzb2x1dGlvbkNvbnN0cmFpbnQgIT09IHVuZGVmaW5lZFxuICAgICAgPyBvcHRpb25zLnNtb290aFJlc29sdXRpb25Db25zdHJhaW50XG4gICAgICA6IHRydWU7XG5cbiAgY29uc3Qgc2hvd0Z1bGxFeHRlbnQgPVxuICAgIG9wdGlvbnMuc2hvd0Z1bGxFeHRlbnQgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuc2hvd0Z1bGxFeHRlbnQgOiBmYWxzZTtcblxuICBjb25zdCBwcm9qZWN0aW9uID0gY3JlYXRlUHJvamVjdGlvbihvcHRpb25zLnByb2plY3Rpb24sICdFUFNHOjM4NTcnKTtcbiAgY29uc3QgcHJvakV4dGVudCA9IHByb2plY3Rpb24uZ2V0RXh0ZW50KCk7XG4gIGxldCBjb25zdHJhaW5Pbmx5Q2VudGVyID0gb3B0aW9ucy5jb25zdHJhaW5Pbmx5Q2VudGVyO1xuICBsZXQgZXh0ZW50ID0gb3B0aW9ucy5leHRlbnQ7XG4gIGlmICghbXVsdGlXb3JsZCAmJiAhZXh0ZW50ICYmIHByb2plY3Rpb24uaXNHbG9iYWwoKSkge1xuICAgIGNvbnN0cmFpbk9ubHlDZW50ZXIgPSBmYWxzZTtcbiAgICBleHRlbnQgPSBwcm9qRXh0ZW50O1xuICB9XG5cbiAgaWYgKG9wdGlvbnMucmVzb2x1dGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgIGNvbnN0IHJlc29sdXRpb25zID0gb3B0aW9ucy5yZXNvbHV0aW9ucztcbiAgICBtYXhSZXNvbHV0aW9uID0gcmVzb2x1dGlvbnNbbWluWm9vbV07XG4gICAgbWluUmVzb2x1dGlvbiA9XG4gICAgICByZXNvbHV0aW9uc1ttYXhab29tXSAhPT0gdW5kZWZpbmVkXG4gICAgICAgID8gcmVzb2x1dGlvbnNbbWF4Wm9vbV1cbiAgICAgICAgOiByZXNvbHV0aW9uc1tyZXNvbHV0aW9ucy5sZW5ndGggLSAxXTtcblxuICAgIGlmIChvcHRpb25zLmNvbnN0cmFpblJlc29sdXRpb24pIHtcbiAgICAgIHJlc29sdXRpb25Db25zdHJhaW50ID0gY3JlYXRlU25hcFRvUmVzb2x1dGlvbnMoXG4gICAgICAgIHJlc29sdXRpb25zLFxuICAgICAgICBzbW9vdGgsXG4gICAgICAgICFjb25zdHJhaW5Pbmx5Q2VudGVyICYmIGV4dGVudCxcbiAgICAgICAgc2hvd0Z1bGxFeHRlbnRcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc29sdXRpb25Db25zdHJhaW50ID0gY3JlYXRlTWluTWF4UmVzb2x1dGlvbihcbiAgICAgICAgbWF4UmVzb2x1dGlvbixcbiAgICAgICAgbWluUmVzb2x1dGlvbixcbiAgICAgICAgc21vb3RoLFxuICAgICAgICAhY29uc3RyYWluT25seUNlbnRlciAmJiBleHRlbnQsXG4gICAgICAgIHNob3dGdWxsRXh0ZW50XG4gICAgICApO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBjYWxjdWxhdGUgdGhlIGRlZmF1bHQgbWluIGFuZCBtYXggcmVzb2x1dGlvblxuICAgIGNvbnN0IHNpemUgPSAhcHJvakV4dGVudFxuICAgICAgPyAvLyB1c2UgYW4gZXh0ZW50IHRoYXQgY2FuIGZpdCB0aGUgd2hvbGUgd29ybGQgaWYgbmVlZCBiZVxuICAgICAgICAoMzYwICogTUVURVJTX1BFUl9VTklULmRlZ3JlZXMpIC8gcHJvamVjdGlvbi5nZXRNZXRlcnNQZXJVbml0KClcbiAgICAgIDogTWF0aC5tYXgoZ2V0V2lkdGgocHJvakV4dGVudCksIGdldEhlaWdodChwcm9qRXh0ZW50KSk7XG5cbiAgICBjb25zdCBkZWZhdWx0TWF4UmVzb2x1dGlvbiA9XG4gICAgICBzaXplIC8gREVGQVVMVF9USUxFX1NJWkUgLyBNYXRoLnBvdyhkZWZhdWx0Wm9vbUZhY3RvciwgREVGQVVMVF9NSU5fWk9PTSk7XG5cbiAgICBjb25zdCBkZWZhdWx0TWluUmVzb2x1dGlvbiA9XG4gICAgICBkZWZhdWx0TWF4UmVzb2x1dGlvbiAvXG4gICAgICBNYXRoLnBvdyhkZWZhdWx0Wm9vbUZhY3RvciwgZGVmYXVsdE1heFpvb20gLSBERUZBVUxUX01JTl9aT09NKTtcblxuICAgIC8vIHVzZXIgcHJvdmlkZWQgbWF4UmVzb2x1dGlvbiB0YWtlcyBwcmVjZWRlbmNlXG4gICAgbWF4UmVzb2x1dGlvbiA9IG9wdGlvbnMubWF4UmVzb2x1dGlvbjtcbiAgICBpZiAobWF4UmVzb2x1dGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBtaW5ab29tID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgbWF4UmVzb2x1dGlvbiA9IGRlZmF1bHRNYXhSZXNvbHV0aW9uIC8gTWF0aC5wb3coem9vbUZhY3RvciwgbWluWm9vbSk7XG4gICAgfVxuXG4gICAgLy8gdXNlciBwcm92aWRlZCBtaW5SZXNvbHV0aW9uIHRha2VzIHByZWNlZGVuY2VcbiAgICBtaW5SZXNvbHV0aW9uID0gb3B0aW9ucy5taW5SZXNvbHV0aW9uO1xuICAgIGlmIChtaW5SZXNvbHV0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChvcHRpb25zLm1heFpvb20gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAob3B0aW9ucy5tYXhSZXNvbHV0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBtaW5SZXNvbHV0aW9uID0gbWF4UmVzb2x1dGlvbiAvIE1hdGgucG93KHpvb21GYWN0b3IsIG1heFpvb20pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1pblJlc29sdXRpb24gPSBkZWZhdWx0TWF4UmVzb2x1dGlvbiAvIE1hdGgucG93KHpvb21GYWN0b3IsIG1heFpvb20pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtaW5SZXNvbHV0aW9uID0gZGVmYXVsdE1pblJlc29sdXRpb247XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gZ2l2ZW4gZGlzY3JldGUgem9vbSBsZXZlbHMsIG1pblJlc29sdXRpb24gbWF5IGJlIGRpZmZlcmVudCB0aGFuIHByb3ZpZGVkXG4gICAgbWF4Wm9vbSA9XG4gICAgICBtaW5ab29tICtcbiAgICAgIE1hdGguZmxvb3IoXG4gICAgICAgIE1hdGgubG9nKG1heFJlc29sdXRpb24gLyBtaW5SZXNvbHV0aW9uKSAvIE1hdGgubG9nKHpvb21GYWN0b3IpXG4gICAgICApO1xuICAgIG1pblJlc29sdXRpb24gPSBtYXhSZXNvbHV0aW9uIC8gTWF0aC5wb3coem9vbUZhY3RvciwgbWF4Wm9vbSAtIG1pblpvb20pO1xuXG4gICAgaWYgKG9wdGlvbnMuY29uc3RyYWluUmVzb2x1dGlvbikge1xuICAgICAgcmVzb2x1dGlvbkNvbnN0cmFpbnQgPSBjcmVhdGVTbmFwVG9Qb3dlcihcbiAgICAgICAgem9vbUZhY3RvcixcbiAgICAgICAgbWF4UmVzb2x1dGlvbixcbiAgICAgICAgbWluUmVzb2x1dGlvbixcbiAgICAgICAgc21vb3RoLFxuICAgICAgICAhY29uc3RyYWluT25seUNlbnRlciAmJiBleHRlbnQsXG4gICAgICAgIHNob3dGdWxsRXh0ZW50XG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXNvbHV0aW9uQ29uc3RyYWludCA9IGNyZWF0ZU1pbk1heFJlc29sdXRpb24oXG4gICAgICAgIG1heFJlc29sdXRpb24sXG4gICAgICAgIG1pblJlc29sdXRpb24sXG4gICAgICAgIHNtb290aCxcbiAgICAgICAgIWNvbnN0cmFpbk9ubHlDZW50ZXIgJiYgZXh0ZW50LFxuICAgICAgICBzaG93RnVsbEV4dGVudFxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBjb25zdHJhaW50OiByZXNvbHV0aW9uQ29uc3RyYWludCxcbiAgICBtYXhSZXNvbHV0aW9uOiBtYXhSZXNvbHV0aW9uLFxuICAgIG1pblJlc29sdXRpb246IG1pblJlc29sdXRpb24sXG4gICAgbWluWm9vbTogbWluWm9vbSxcbiAgICB6b29tRmFjdG9yOiB6b29tRmFjdG9yLFxuICB9O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7Vmlld09wdGlvbnN9IG9wdGlvbnMgVmlldyBvcHRpb25zLlxuICogQHJldHVybiB7aW1wb3J0KFwiLi9yb3RhdGlvbmNvbnN0cmFpbnQuanNcIikuVHlwZX0gUm90YXRpb24gY29uc3RyYWludC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVJvdGF0aW9uQ29uc3RyYWludChvcHRpb25zKSB7XG4gIGNvbnN0IGVuYWJsZVJvdGF0aW9uID1cbiAgICBvcHRpb25zLmVuYWJsZVJvdGF0aW9uICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmVuYWJsZVJvdGF0aW9uIDogdHJ1ZTtcbiAgaWYgKGVuYWJsZVJvdGF0aW9uKSB7XG4gICAgY29uc3QgY29uc3RyYWluUm90YXRpb24gPSBvcHRpb25zLmNvbnN0cmFpblJvdGF0aW9uO1xuICAgIGlmIChjb25zdHJhaW5Sb3RhdGlvbiA9PT0gdW5kZWZpbmVkIHx8IGNvbnN0cmFpblJvdGF0aW9uID09PSB0cnVlKSB7XG4gICAgICByZXR1cm4gY3JlYXRlU25hcFRvWmVybygpO1xuICAgIH1cbiAgICBpZiAoY29uc3RyYWluUm90YXRpb24gPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm4gcm90YXRpb25Ob25lO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGNvbnN0cmFpblJvdGF0aW9uID09PSAnbnVtYmVyJykge1xuICAgICAgcmV0dXJuIGNyZWF0ZVNuYXBUb04oY29uc3RyYWluUm90YXRpb24pO1xuICAgIH1cbiAgICByZXR1cm4gcm90YXRpb25Ob25lO1xuICB9XG4gIHJldHVybiBkaXNhYmxlO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhbiBhbmltYXRpb24gaW52b2x2ZXMgbm8gdmlldyBjaGFuZ2UuXG4gKiBAcGFyYW0ge0FuaW1hdGlvbn0gYW5pbWF0aW9uIFRoZSBhbmltYXRpb24uXG4gKiBAcmV0dXJuIHtib29sZWFufSBUaGUgYW5pbWF0aW9uIGludm9sdmVzIG5vIHZpZXcgY2hhbmdlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNOb29wQW5pbWF0aW9uKGFuaW1hdGlvbikge1xuICBpZiAoYW5pbWF0aW9uLnNvdXJjZUNlbnRlciAmJiBhbmltYXRpb24udGFyZ2V0Q2VudGVyKSB7XG4gICAgaWYgKCFjb29yZGluYXRlc0VxdWFsKGFuaW1hdGlvbi5zb3VyY2VDZW50ZXIsIGFuaW1hdGlvbi50YXJnZXRDZW50ZXIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIGlmIChhbmltYXRpb24uc291cmNlUmVzb2x1dGlvbiAhPT0gYW5pbWF0aW9uLnRhcmdldFJlc29sdXRpb24pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGFuaW1hdGlvbi5zb3VyY2VSb3RhdGlvbiAhPT0gYW5pbWF0aW9uLnRhcmdldFJvdGF0aW9uKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGNvb3JkaW5hdGUgQ29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9zaXplLmpzXCIpLlNpemV9IHNpemUgQm94IHBpeGVsIHNpemUuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vcGl4ZWwuanNcIikuUGl4ZWx9IHBvc2l0aW9uIFBvc2l0aW9uIG9uIHRoZSB2aWV3IHRvIGNlbnRlciBvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSByZXNvbHV0aW9uIFJlc29sdXRpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gcm90YXRpb24gUm90YXRpb24uXG4gKiBAcmV0dXJuIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gU2hpZnRlZCBjZW50ZXIuXG4gKi9cbmZ1bmN0aW9uIGNhbGN1bGF0ZUNlbnRlck9uKGNvb3JkaW5hdGUsIHNpemUsIHBvc2l0aW9uLCByZXNvbHV0aW9uLCByb3RhdGlvbikge1xuICAvLyBjYWxjdWxhdGUgcm90YXRlZCBwb3NpdGlvblxuICBjb25zdCBjb3NBbmdsZSA9IE1hdGguY29zKC1yb3RhdGlvbik7XG4gIGxldCBzaW5BbmdsZSA9IE1hdGguc2luKC1yb3RhdGlvbik7XG4gIGxldCByb3RYID0gY29vcmRpbmF0ZVswXSAqIGNvc0FuZ2xlIC0gY29vcmRpbmF0ZVsxXSAqIHNpbkFuZ2xlO1xuICBsZXQgcm90WSA9IGNvb3JkaW5hdGVbMV0gKiBjb3NBbmdsZSArIGNvb3JkaW5hdGVbMF0gKiBzaW5BbmdsZTtcbiAgcm90WCArPSAoc2l6ZVswXSAvIDIgLSBwb3NpdGlvblswXSkgKiByZXNvbHV0aW9uO1xuICByb3RZICs9IChwb3NpdGlvblsxXSAtIHNpemVbMV0gLyAyKSAqIHJlc29sdXRpb247XG5cbiAgLy8gZ28gYmFjayB0byBvcmlnaW5hbCBhbmdsZVxuICBzaW5BbmdsZSA9IC1zaW5BbmdsZTsgLy8gZ28gYmFjayB0byBvcmlnaW5hbCByb3RhdGlvblxuICBjb25zdCBjZW50ZXJYID0gcm90WCAqIGNvc0FuZ2xlIC0gcm90WSAqIHNpbkFuZ2xlO1xuICBjb25zdCBjZW50ZXJZID0gcm90WSAqIGNvc0FuZ2xlICsgcm90WCAqIHNpbkFuZ2xlO1xuXG4gIHJldHVybiBbY2VudGVyWCwgY2VudGVyWV07XG59XG5cbmV4cG9ydCBkZWZhdWx0IFZpZXc7XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvVmlld0hpbnRcbiAqL1xuXG4vKipcbiAqIEBlbnVtIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IHtcbiAgQU5JTUFUSU5HOiAwLFxuICBJTlRFUkFDVElORzogMSxcbn07XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvVmlld1Byb3BlcnR5XG4gKi9cblxuLyoqXG4gKiBAZW51bSB7c3RyaW5nfVxuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gIENFTlRFUjogJ2NlbnRlcicsXG4gIFJFU09MVVRJT046ICdyZXNvbHV0aW9uJyxcbiAgUk9UQVRJT046ICdyb3RhdGlvbicsXG59O1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2FycmF5XG4gKi9cblxuLyoqXG4gKiBQZXJmb3JtcyBhIGJpbmFyeSBzZWFyY2ggb24gdGhlIHByb3ZpZGVkIHNvcnRlZCBsaXN0IGFuZCByZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgaXRlbSBpZiBmb3VuZC4gSWYgaXQgY2FuJ3QgYmUgZm91bmQgaXQnbGwgcmV0dXJuIC0xLlxuICogaHR0cHM6Ly9naXRodWIuY29tL2Rhcmtza3lhcHAvYmluYXJ5LXNlYXJjaFxuICpcbiAqIEBwYXJhbSB7QXJyYXk8Kj59IGhheXN0YWNrIEl0ZW1zIHRvIHNlYXJjaCB0aHJvdWdoLlxuICogQHBhcmFtIHsqfSBuZWVkbGUgVGhlIGl0ZW0gdG8gbG9vayBmb3IuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyYXRvcl0gQ29tcGFyYXRvciBmdW5jdGlvbi5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIGluZGV4IG9mIHRoZSBpdGVtIGlmIGZvdW5kLCAtMSBpZiBub3QuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiaW5hcnlTZWFyY2goaGF5c3RhY2ssIG5lZWRsZSwgY29tcGFyYXRvcikge1xuICBsZXQgbWlkLCBjbXA7XG4gIGNvbXBhcmF0b3IgPSBjb21wYXJhdG9yIHx8IGFzY2VuZGluZztcbiAgbGV0IGxvdyA9IDA7XG4gIGxldCBoaWdoID0gaGF5c3RhY2subGVuZ3RoO1xuICBsZXQgZm91bmQgPSBmYWxzZTtcblxuICB3aGlsZSAobG93IDwgaGlnaCkge1xuICAgIC8qIE5vdGUgdGhhdCBcIihsb3cgKyBoaWdoKSA+Pj4gMVwiIG1heSBvdmVyZmxvdywgYW5kIHJlc3VsdHMgaW4gYSB0eXBlY2FzdFxuICAgICAqIHRvIGRvdWJsZSAod2hpY2ggZ2l2ZXMgdGhlIHdyb25nIHJlc3VsdHMpLiAqL1xuICAgIG1pZCA9IGxvdyArICgoaGlnaCAtIGxvdykgPj4gMSk7XG4gICAgY21wID0gK2NvbXBhcmF0b3IoaGF5c3RhY2tbbWlkXSwgbmVlZGxlKTtcblxuICAgIGlmIChjbXAgPCAwLjApIHtcbiAgICAgIC8qIFRvbyBsb3cuICovXG4gICAgICBsb3cgPSBtaWQgKyAxO1xuICAgIH0gZWxzZSB7XG4gICAgICAvKiBLZXkgZm91bmQgb3IgdG9vIGhpZ2ggKi9cbiAgICAgIGhpZ2ggPSBtaWQ7XG4gICAgICBmb3VuZCA9ICFjbXA7XG4gICAgfVxuICB9XG5cbiAgLyogS2V5IG5vdCBmb3VuZC4gKi9cbiAgcmV0dXJuIGZvdW5kID8gbG93IDogfmxvdztcbn1cblxuLyoqXG4gKiBDb21wYXJlIGZ1bmN0aW9uIHNvcnRpbmcgYXJyYXlzIGluIGFzY2VuZGluZyBvcmRlci4gIFNhZmUgdG8gdXNlIGZvciBudW1lcmljIHZhbHVlcy5cbiAqIEBwYXJhbSB7Kn0gYSBUaGUgZmlyc3Qgb2JqZWN0IHRvIGJlIGNvbXBhcmVkLlxuICogQHBhcmFtIHsqfSBiIFRoZSBzZWNvbmQgb2JqZWN0IHRvIGJlIGNvbXBhcmVkLlxuICogQHJldHVybiB7bnVtYmVyfSBBIG5lZ2F0aXZlIG51bWJlciwgemVybywgb3IgYSBwb3NpdGl2ZSBudW1iZXIgYXMgdGhlIGZpcnN0XG4gKiAgICAgYXJndW1lbnQgaXMgbGVzcyB0aGFuLCBlcXVhbCB0bywgb3IgZ3JlYXRlciB0aGFuIHRoZSBzZWNvbmQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc2NlbmRpbmcoYSwgYikge1xuICByZXR1cm4gYSA+IGIgPyAxIDogYSA8IGIgPyAtMSA6IDA7XG59XG5cbi8qKlxuICogQ29tcGFyZSBmdW5jdGlvbiBzb3J0aW5nIGFycmF5cyBpbiBkZXNjZW5kaW5nIG9yZGVyLiAgU2FmZSB0byB1c2UgZm9yIG51bWVyaWMgdmFsdWVzLlxuICogQHBhcmFtIHsqfSBhIFRoZSBmaXJzdCBvYmplY3QgdG8gYmUgY29tcGFyZWQuXG4gKiBAcGFyYW0geyp9IGIgVGhlIHNlY29uZCBvYmplY3QgdG8gYmUgY29tcGFyZWQuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEEgbmVnYXRpdmUgbnVtYmVyLCB6ZXJvLCBvciBhIHBvc2l0aXZlIG51bWJlciBhcyB0aGUgZmlyc3RcbiAqICAgICBhcmd1bWVudCBpcyBncmVhdGVyIHRoYW4sIGVxdWFsIHRvLCBvciBsZXNzIHRoYW4gdGhlIHNlY29uZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlc2NlbmRpbmcoYSwgYikge1xuICByZXR1cm4gYSA8IGIgPyAxIDogYSA+IGIgPyAtMSA6IDA7XG59XG5cbi8qKlxuICoge0BsaW5rIG1vZHVsZTpvbC90aWxlZ3JpZC9UaWxlR3JpZH5UaWxlR3JpZCNnZXRaRm9yUmVzb2x1dGlvbn0gY2FuIHVzZSBhIGZ1bmN0aW9uXG4gKiBvZiB0aGlzIHR5cGUgdG8gZGV0ZXJtaW5lIHdoaWNoIG5lYXJlc3QgcmVzb2x1dGlvbiB0byB1c2UuXG4gKlxuICogVGhpcyBmdW5jdGlvbiB0YWtlcyBhIGB7bnVtYmVyfWAgcmVwcmVzZW50aW5nIGEgdmFsdWUgYmV0d2VlbiB0d28gYXJyYXkgZW50cmllcyxcbiAqIGEgYHtudW1iZXJ9YCByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIHRoZSBuZWFyZXN0IGhpZ2hlciBlbnRyeSBhbmRcbiAqIGEgYHtudW1iZXJ9YCByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIHRoZSBuZWFyZXN0IGxvd2VyIGVudHJ5XG4gKiBhcyBhcmd1bWVudHMgYW5kIHJldHVybnMgYSBge251bWJlcn1gLiBJZiBhIG5lZ2F0aXZlIG51bWJlciBvciB6ZXJvIGlzIHJldHVybmVkXG4gKiB0aGUgbG93ZXIgdmFsdWUgd2lsbCBiZSB1c2VkLCBpZiBhIHBvc2l0aXZlIG51bWJlciBpcyByZXR1cm5lZCB0aGUgaGlnaGVyIHZhbHVlXG4gKiB3aWxsIGJlIHVzZWQuXG4gKiBAdHlwZWRlZiB7ZnVuY3Rpb24obnVtYmVyLCBudW1iZXIsIG51bWJlcik6IG51bWJlcn0gTmVhcmVzdERpcmVjdGlvbkZ1bmN0aW9uXG4gKiBAYXBpXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGFyciBBcnJheSBpbiBkZXNjZW5kaW5nIG9yZGVyLlxuICogQHBhcmFtIHtudW1iZXJ9IHRhcmdldCBUYXJnZXQuXG4gKiBAcGFyYW0ge251bWJlcnxOZWFyZXN0RGlyZWN0aW9uRnVuY3Rpb259IGRpcmVjdGlvblxuICogICAgMCBtZWFucyByZXR1cm4gdGhlIG5lYXJlc3QsXG4gKiAgICA+IDAgbWVhbnMgcmV0dXJuIHRoZSBsYXJnZXN0IG5lYXJlc3QsXG4gKiAgICA8IDAgbWVhbnMgcmV0dXJuIHRoZSBzbWFsbGVzdCBuZWFyZXN0LlxuICogQHJldHVybiB7bnVtYmVyfSBJbmRleC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxpbmVhckZpbmROZWFyZXN0KGFyciwgdGFyZ2V0LCBkaXJlY3Rpb24pIHtcbiAgaWYgKGFyclswXSA8PSB0YXJnZXQpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIGNvbnN0IG4gPSBhcnIubGVuZ3RoO1xuICBpZiAodGFyZ2V0IDw9IGFycltuIC0gMV0pIHtcbiAgICByZXR1cm4gbiAtIDE7XG4gIH1cblxuICBpZiAodHlwZW9mIGRpcmVjdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgbjsgKytpKSB7XG4gICAgICBjb25zdCBjYW5kaWRhdGUgPSBhcnJbaV07XG4gICAgICBpZiAoY2FuZGlkYXRlID09PSB0YXJnZXQpIHtcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9XG4gICAgICBpZiAoY2FuZGlkYXRlIDwgdGFyZ2V0KSB7XG4gICAgICAgIGlmIChkaXJlY3Rpb24odGFyZ2V0LCBhcnJbaSAtIDFdLCBjYW5kaWRhdGUpID4gMCkge1xuICAgICAgICAgIHJldHVybiBpIC0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG4gLSAxO1xuICB9XG5cbiAgaWYgKGRpcmVjdGlvbiA+IDApIHtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKGFycltpXSA8IHRhcmdldCkge1xuICAgICAgICByZXR1cm4gaSAtIDE7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuIC0gMTtcbiAgfVxuXG4gIGlmIChkaXJlY3Rpb24gPCAwKSB7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmIChhcnJbaV0gPD0gdGFyZ2V0KSB7XG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbiAtIDE7XG4gIH1cblxuICBmb3IgKGxldCBpID0gMTsgaSA8IG47ICsraSkge1xuICAgIGlmIChhcnJbaV0gPT0gdGFyZ2V0KSB7XG4gICAgICByZXR1cm4gaTtcbiAgICB9XG4gICAgaWYgKGFycltpXSA8IHRhcmdldCkge1xuICAgICAgaWYgKGFycltpIC0gMV0gLSB0YXJnZXQgPCB0YXJnZXQgLSBhcnJbaV0pIHtcbiAgICAgICAgcmV0dXJuIGkgLSAxO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICB9XG4gIHJldHVybiBuIC0gMTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PCo+fSBhcnIgQXJyYXkuXG4gKiBAcGFyYW0ge251bWJlcn0gYmVnaW4gQmVnaW4gaW5kZXguXG4gKiBAcGFyYW0ge251bWJlcn0gZW5kIEVuZCBpbmRleC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJldmVyc2VTdWJBcnJheShhcnIsIGJlZ2luLCBlbmQpIHtcbiAgd2hpbGUgKGJlZ2luIDwgZW5kKSB7XG4gICAgY29uc3QgdG1wID0gYXJyW2JlZ2luXTtcbiAgICBhcnJbYmVnaW5dID0gYXJyW2VuZF07XG4gICAgYXJyW2VuZF0gPSB0bXA7XG4gICAgKytiZWdpbjtcbiAgICAtLWVuZDtcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8VkFMVUU+fSBhcnIgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7IUFycmF5PFZBTFVFPnxWQUxVRX0gZGF0YSBUaGUgZWxlbWVudHMgb3IgYXJyYXlzIG9mIGVsZW1lbnRzIHRvIGFkZCB0byBhcnIuXG4gKiBAdGVtcGxhdGUgVkFMVUVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4dGVuZChhcnIsIGRhdGEpIHtcbiAgY29uc3QgZXh0ZW5zaW9uID0gQXJyYXkuaXNBcnJheShkYXRhKSA/IGRhdGEgOiBbZGF0YV07XG4gIGNvbnN0IGxlbmd0aCA9IGV4dGVuc2lvbi5sZW5ndGg7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBhcnJbYXJyLmxlbmd0aF0gPSBleHRlbnNpb25baV07XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PFZBTFVFPn0gYXJyIFRoZSBhcnJheSB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge1ZBTFVFfSBvYmogVGhlIGVsZW1lbnQgdG8gcmVtb3ZlLlxuICogQHRlbXBsYXRlIFZBTFVFXG4gKiBAcmV0dXJuIHtib29sZWFufSBJZiB0aGUgZWxlbWVudCB3YXMgcmVtb3ZlZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZShhcnIsIG9iaikge1xuICBjb25zdCBpID0gYXJyLmluZGV4T2Yob2JqKTtcbiAgY29uc3QgZm91bmQgPSBpID4gLTE7XG4gIGlmIChmb3VuZCkge1xuICAgIGFyci5zcGxpY2UoaSwgMSk7XG4gIH1cbiAgcmV0dXJuIGZvdW5kO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXl8VWludDhDbGFtcGVkQXJyYXl9IGFycjEgVGhlIGZpcnN0IGFycmF5IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge0FycmF5fFVpbnQ4Q2xhbXBlZEFycmF5fSBhcnIyIFRoZSBzZWNvbmQgYXJyYXkgdG8gY29tcGFyZS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIHR3byBhcnJheXMgYXJlIGVxdWFsLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZXF1YWxzKGFycjEsIGFycjIpIHtcbiAgY29uc3QgbGVuMSA9IGFycjEubGVuZ3RoO1xuICBpZiAobGVuMSAhPT0gYXJyMi5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW4xOyBpKyspIHtcbiAgICBpZiAoYXJyMVtpXSAhPT0gYXJyMltpXSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBTb3J0IHRoZSBwYXNzZWQgYXJyYXkgc3VjaCB0aGF0IHRoZSByZWxhdGl2ZSBvcmRlciBvZiBlcXVhbCBlbGVtZW50cyBpcyBwcmVzZXJ2ZWQuXG4gKiBTZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU29ydGluZ19hbGdvcml0aG0jU3RhYmlsaXR5IGZvciBkZXRhaWxzLlxuICogQHBhcmFtIHtBcnJheTwqPn0gYXJyIFRoZSBhcnJheSB0byBzb3J0IChtb2RpZmllcyBvcmlnaW5hbCkuXG4gKiBAcGFyYW0geyFmdW5jdGlvbigqLCAqKTogbnVtYmVyfSBjb21wYXJlRm5jIENvbXBhcmlzb24gZnVuY3Rpb24uXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdGFibGVTb3J0KGFyciwgY29tcGFyZUZuYykge1xuICBjb25zdCBsZW5ndGggPSBhcnIubGVuZ3RoO1xuICBjb25zdCB0bXAgPSBBcnJheShhcnIubGVuZ3RoKTtcbiAgbGV0IGk7XG4gIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIHRtcFtpXSA9IHtpbmRleDogaSwgdmFsdWU6IGFycltpXX07XG4gIH1cbiAgdG1wLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gY29tcGFyZUZuYyhhLnZhbHVlLCBiLnZhbHVlKSB8fCBhLmluZGV4IC0gYi5pbmRleDtcbiAgfSk7XG4gIGZvciAoaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICBhcnJbaV0gPSB0bXBbaV0udmFsdWU7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PCo+fSBhcnIgVGhlIGFycmF5IHRvIHRlc3QuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZnVuY10gQ29tcGFyaXNvbiBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3N0cmljdF0gU3RyaWN0bHkgc29ydGVkIChkZWZhdWx0IGZhbHNlKS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFJldHVybiBpbmRleC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzU29ydGVkKGFyciwgZnVuYywgc3RyaWN0KSB7XG4gIGNvbnN0IGNvbXBhcmUgPSBmdW5jIHx8IGFzY2VuZGluZztcbiAgcmV0dXJuIGFyci5ldmVyeShmdW5jdGlvbiAoY3VycmVudFZhbCwgaW5kZXgpIHtcbiAgICBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjb25zdCByZXMgPSBjb21wYXJlKGFycltpbmRleCAtIDFdLCBjdXJyZW50VmFsKTtcbiAgICByZXR1cm4gIShyZXMgPiAwIHx8IChzdHJpY3QgJiYgcmVzID09PSAwKSk7XG4gIH0pO1xufVxuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2Fzc2VydHNcbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7Kn0gYXNzZXJ0aW9uIEFzc2VydGlvbiB3ZSBleHBlY3RlZCB0byBiZSB0cnV0aHkuXG4gKiBAcGFyYW0ge3N0cmluZ30gZXJyb3JNZXNzYWdlIEVycm9yIG1lc3NhZ2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnQoYXNzZXJ0aW9uLCBlcnJvck1lc3NhZ2UpIHtcbiAgaWYgKCFhc3NlcnRpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JNZXNzYWdlKTtcbiAgfVxufVxuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2NlbnRlcmNvbnN0cmFpbnRcbiAqL1xuaW1wb3J0IHtjbGFtcH0gZnJvbSAnLi9tYXRoLmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7ZnVuY3Rpb24oKGltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfHVuZGVmaW5lZCksIG51bWJlciwgaW1wb3J0KFwiLi9zaXplLmpzXCIpLlNpemUsIGJvb2xlYW49LCBBcnJheTxudW1iZXI+PSk6IChpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZXx1bmRlZmluZWQpfSBUeXBlXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gb25seUNlbnRlciBJZiB0cnVlLCB0aGUgY29uc3RyYWludCB3aWxsIG9ubHkgYXBwbHkgdG8gdGhlIHZpZXcgY2VudGVyLlxuICogQHBhcmFtIHtib29sZWFufSBzbW9vdGggSWYgdHJ1ZSwgdGhlIHZpZXcgd2lsbCBiZSBhYmxlIHRvIGdvIHNsaWdodGx5IG91dCBvZiB0aGUgZ2l2ZW4gZXh0ZW50XG4gKiAob25seSBkdXJpbmcgaW50ZXJhY3Rpb24gYW5kIGFuaW1hdGlvbikuXG4gKiBAcmV0dXJuIHtUeXBlfSBUaGUgY29uc3RyYWludC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUV4dGVudChleHRlbnQsIG9ubHlDZW50ZXIsIHNtb290aCkge1xuICByZXR1cm4gKFxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV8dW5kZWZpbmVkfSBjZW50ZXIgQ2VudGVyLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfHVuZGVmaW5lZH0gcmVzb2x1dGlvbiBSZXNvbHV0aW9uLlxuICAgICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9zaXplLmpzXCIpLlNpemV9IHNpemUgVmlld3BvcnQgc2l6ZTsgdW51c2VkIGlmIGBvbmx5Q2VudGVyYCB3YXMgc3BlY2lmaWVkLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzTW92aW5nXSBUcnVlIGlmIGFuIGludGVyYWN0aW9uIG9yIGFuaW1hdGlvbiBpcyBpbiBwcm9ncmVzcy5cbiAgICAgKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IFtjZW50ZXJTaGlmdF0gU2hpZnQgYmV0d2VlbiBtYXAgY2VudGVyIGFuZCB2aWV3cG9ydCBjZW50ZXIuXG4gICAgICogQHJldHVybiB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV8dW5kZWZpbmVkfSBDZW50ZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gKGNlbnRlciwgcmVzb2x1dGlvbiwgc2l6ZSwgaXNNb3ZpbmcsIGNlbnRlclNoaWZ0KSB7XG4gICAgICBpZiAoIWNlbnRlcikge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgaWYgKCFyZXNvbHV0aW9uICYmICFvbmx5Q2VudGVyKSB7XG4gICAgICAgIHJldHVybiBjZW50ZXI7XG4gICAgICB9XG4gICAgICBjb25zdCB2aWV3V2lkdGggPSBvbmx5Q2VudGVyID8gMCA6IHNpemVbMF0gKiByZXNvbHV0aW9uO1xuICAgICAgY29uc3Qgdmlld0hlaWdodCA9IG9ubHlDZW50ZXIgPyAwIDogc2l6ZVsxXSAqIHJlc29sdXRpb247XG4gICAgICBjb25zdCBzaGlmdFggPSBjZW50ZXJTaGlmdCA/IGNlbnRlclNoaWZ0WzBdIDogMDtcbiAgICAgIGNvbnN0IHNoaWZ0WSA9IGNlbnRlclNoaWZ0ID8gY2VudGVyU2hpZnRbMV0gOiAwO1xuICAgICAgbGV0IG1pblggPSBleHRlbnRbMF0gKyB2aWV3V2lkdGggLyAyICsgc2hpZnRYO1xuICAgICAgbGV0IG1heFggPSBleHRlbnRbMl0gLSB2aWV3V2lkdGggLyAyICsgc2hpZnRYO1xuICAgICAgbGV0IG1pblkgPSBleHRlbnRbMV0gKyB2aWV3SGVpZ2h0IC8gMiArIHNoaWZ0WTtcbiAgICAgIGxldCBtYXhZID0gZXh0ZW50WzNdIC0gdmlld0hlaWdodCAvIDIgKyBzaGlmdFk7XG5cbiAgICAgIC8vIG5vdGU6IHdoZW4gem9vbWluZyBvdXQgb2YgYm91bmRzLCBtaW4gYW5kIG1heCB2YWx1ZXMgZm9yIHggYW5kIHkgbWF5XG4gICAgICAvLyBlbmQgdXAgaW52ZXJ0ZWQgKG1pbiA+IG1heCk7IHRoaXMgaGFzIHRvIGJlIGFjY291bnRlZCBmb3JcbiAgICAgIGlmIChtaW5YID4gbWF4WCkge1xuICAgICAgICBtaW5YID0gKG1heFggKyBtaW5YKSAvIDI7XG4gICAgICAgIG1heFggPSBtaW5YO1xuICAgICAgfVxuICAgICAgaWYgKG1pblkgPiBtYXhZKSB7XG4gICAgICAgIG1pblkgPSAobWF4WSArIG1pblkpIC8gMjtcbiAgICAgICAgbWF4WSA9IG1pblk7XG4gICAgICB9XG5cbiAgICAgIGxldCB4ID0gY2xhbXAoY2VudGVyWzBdLCBtaW5YLCBtYXhYKTtcbiAgICAgIGxldCB5ID0gY2xhbXAoY2VudGVyWzFdLCBtaW5ZLCBtYXhZKTtcblxuICAgICAgLy8gZHVyaW5nIGFuIGludGVyYWN0aW9uLCBhbGxvdyBzb21lIG92ZXJzY3JvbGxcbiAgICAgIGlmIChpc01vdmluZyAmJiBzbW9vdGggJiYgcmVzb2x1dGlvbikge1xuICAgICAgICBjb25zdCByYXRpbyA9IDMwICogcmVzb2x1dGlvbjtcbiAgICAgICAgeCArPVxuICAgICAgICAgIC1yYXRpbyAqIE1hdGgubG9nKDEgKyBNYXRoLm1heCgwLCBtaW5YIC0gY2VudGVyWzBdKSAvIHJhdGlvKSArXG4gICAgICAgICAgcmF0aW8gKiBNYXRoLmxvZygxICsgTWF0aC5tYXgoMCwgY2VudGVyWzBdIC0gbWF4WCkgLyByYXRpbyk7XG4gICAgICAgIHkgKz1cbiAgICAgICAgICAtcmF0aW8gKiBNYXRoLmxvZygxICsgTWF0aC5tYXgoMCwgbWluWSAtIGNlbnRlclsxXSkgLyByYXRpbykgK1xuICAgICAgICAgIHJhdGlvICogTWF0aC5sb2coMSArIE1hdGgubWF4KDAsIGNlbnRlclsxXSAtIG1heFkpIC8gcmF0aW8pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gW3gsIHldO1xuICAgIH1cbiAgKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBbY2VudGVyXSBDZW50ZXIuXG4gKiBAcmV0dXJuIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZXx1bmRlZmluZWR9IENlbnRlci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG5vbmUoY2VudGVyKSB7XG4gIHJldHVybiBjZW50ZXI7XG59XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvY29sb3JcbiAqL1xuaW1wb3J0IHtjbGFtcH0gZnJvbSAnLi9tYXRoLmpzJztcblxuLyoqXG4gKiBBIGNvbG9yIHJlcHJlc2VudGVkIGFzIGEgc2hvcnQgYXJyYXkgW3JlZCwgZ3JlZW4sIGJsdWUsIGFscGhhXS5cbiAqIHJlZCwgZ3JlZW4sIGFuZCBibHVlIHNob3VsZCBiZSBpbnRlZ2VycyBpbiB0aGUgcmFuZ2UgMC4uMjU1IGluY2x1c2l2ZS5cbiAqIGFscGhhIHNob3VsZCBiZSBhIGZsb2F0IGluIHRoZSByYW5nZSAwLi4xIGluY2x1c2l2ZS4gSWYgbm8gYWxwaGEgdmFsdWUgaXNcbiAqIGdpdmVuIHRoZW4gYDFgIHdpbGwgYmUgdXNlZC5cbiAqIEB0eXBlZGVmIHtBcnJheTxudW1iZXI+fSBDb2xvclxuICogQGFwaVxuICovXG5cbi8qKlxuICogVGhpcyBSZWdFeHAgbWF0Y2hlcyAjIGZvbGxvd2VkIGJ5IDMsIDQsIDYsIG9yIDggaGV4IGRpZ2l0cy5cbiAqIEBjb25zdFxuICogQHR5cGUge1JlZ0V4cH1cbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IEhFWF9DT0xPUl9SRV8gPSAvXiMoW2EtZjAtOV17M318W2EtZjAtOV17NH0oPzpbYS1mMC05XXsyfSl7MCwyfSkkL2k7XG5cbi8qKlxuICogUmVndWxhciBleHByZXNzaW9uIGZvciBtYXRjaGluZyBwb3RlbnRpYWwgbmFtZWQgY29sb3Igc3R5bGUgc3RyaW5ncy5cbiAqIEBjb25zdFxuICogQHR5cGUge1JlZ0V4cH1cbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IE5BTUVEX0NPTE9SX1JFXyA9IC9eKFthLXpdKikkfF5oc2xhP1xcKC4qXFwpJC9pO1xuXG4vKipcbiAqIFJldHVybiB0aGUgY29sb3IgYXMgYW4gcmdiYSBzdHJpbmcuXG4gKiBAcGFyYW0ge0NvbG9yfHN0cmluZ30gY29sb3IgQ29sb3IuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFJnYmEgc3RyaW5nLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNTdHJpbmcoY29sb3IpIHtcbiAgaWYgKHR5cGVvZiBjb2xvciA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gY29sb3I7XG4gIH1cbiAgcmV0dXJuIHRvU3RyaW5nKGNvbG9yKTtcbn1cblxuLyoqXG4gKiBSZXR1cm4gbmFtZWQgY29sb3IgYXMgYW4gcmdiYSBzdHJpbmcuXG4gKiBAcGFyYW0ge3N0cmluZ30gY29sb3IgTmFtZWQgY29sb3IuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFJnYiBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGZyb21OYW1lZChjb2xvcikge1xuICBjb25zdCBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBlbC5zdHlsZS5jb2xvciA9IGNvbG9yO1xuICBpZiAoZWwuc3R5bGUuY29sb3IgIT09ICcnKSB7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChlbCk7XG4gICAgY29uc3QgcmdiID0gZ2V0Q29tcHV0ZWRTdHlsZShlbCkuY29sb3I7XG4gICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChlbCk7XG4gICAgcmV0dXJuIHJnYjtcbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHMgU3RyaW5nLlxuICogQHJldHVybiB7Q29sb3J9IENvbG9yLlxuICovXG5leHBvcnQgY29uc3QgZnJvbVN0cmluZyA9IChmdW5jdGlvbiAoKSB7XG4gIC8vIFdlIG1haW50YWluIGEgc21hbGwgY2FjaGUgb2YgcGFyc2VkIHN0cmluZ3MuICBUbyBwcm92aWRlIGNoZWFwIExSVS1saWtlXG4gIC8vIHNlbWFudGljcywgd2hlbmV2ZXIgdGhlIGNhY2hlIGdyb3dzIHRvbyBsYXJnZSB3ZSBzaW1wbHkgZGVsZXRlIGFuXG4gIC8vIGFyYml0cmFyeSAyNSUgb2YgdGhlIGVudHJpZXMuXG5cbiAgLyoqXG4gICAqIEBjb25zdFxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgY29uc3QgTUFYX0NBQ0hFX1NJWkUgPSAxMDI0O1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgQ29sb3I+fVxuICAgKi9cbiAgY29uc3QgY2FjaGUgPSB7fTtcblxuICAvKipcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGxldCBjYWNoZVNpemUgPSAwO1xuXG4gIHJldHVybiAoXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHMgU3RyaW5nLlxuICAgICAqIEByZXR1cm4ge0NvbG9yfSBDb2xvci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAocykge1xuICAgICAgbGV0IGNvbG9yO1xuICAgICAgaWYgKGNhY2hlLmhhc093blByb3BlcnR5KHMpKSB7XG4gICAgICAgIGNvbG9yID0gY2FjaGVbc107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoY2FjaGVTaXplID49IE1BWF9DQUNIRV9TSVpFKSB7XG4gICAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIGNhY2hlKSB7XG4gICAgICAgICAgICBpZiAoKGkrKyAmIDMpID09PSAwKSB7XG4gICAgICAgICAgICAgIGRlbGV0ZSBjYWNoZVtrZXldO1xuICAgICAgICAgICAgICAtLWNhY2hlU2l6ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29sb3IgPSBmcm9tU3RyaW5nSW50ZXJuYWxfKHMpO1xuICAgICAgICBjYWNoZVtzXSA9IGNvbG9yO1xuICAgICAgICArK2NhY2hlU2l6ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb2xvcjtcbiAgICB9XG4gICk7XG59KSgpO1xuXG4vKipcbiAqIFJldHVybiB0aGUgY29sb3IgYXMgYW4gYXJyYXkuIFRoaXMgZnVuY3Rpb24gbWFpbnRhaW5zIGEgY2FjaGUgb2YgY2FsY3VsYXRlZFxuICogYXJyYXlzIHdoaWNoIG1lYW5zIHRoZSByZXN1bHQgc2hvdWxkIG5vdCBiZSBtb2RpZmllZC5cbiAqIEBwYXJhbSB7Q29sb3J8c3RyaW5nfSBjb2xvciBDb2xvci5cbiAqIEByZXR1cm4ge0NvbG9yfSBDb2xvci5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzQXJyYXkoY29sb3IpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoY29sb3IpKSB7XG4gICAgcmV0dXJuIGNvbG9yO1xuICB9XG4gIHJldHVybiBmcm9tU3RyaW5nKGNvbG9yKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gcyBTdHJpbmcuXG4gKiBAcHJpdmF0ZVxuICogQHJldHVybiB7Q29sb3J9IENvbG9yLlxuICovXG5mdW5jdGlvbiBmcm9tU3RyaW5nSW50ZXJuYWxfKHMpIHtcbiAgbGV0IHIsIGcsIGIsIGEsIGNvbG9yO1xuXG4gIGlmIChOQU1FRF9DT0xPUl9SRV8uZXhlYyhzKSkge1xuICAgIHMgPSBmcm9tTmFtZWQocyk7XG4gIH1cblxuICBpZiAoSEVYX0NPTE9SX1JFXy5leGVjKHMpKSB7XG4gICAgLy8gaGV4XG4gICAgY29uc3QgbiA9IHMubGVuZ3RoIC0gMTsgLy8gbnVtYmVyIG9mIGhleCBkaWdpdHNcbiAgICBsZXQgZDsgLy8gbnVtYmVyIG9mIGRpZ2l0cyBwZXIgY2hhbm5lbFxuICAgIGlmIChuIDw9IDQpIHtcbiAgICAgIGQgPSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICBkID0gMjtcbiAgICB9XG4gICAgY29uc3QgaGFzQWxwaGEgPSBuID09PSA0IHx8IG4gPT09IDg7XG4gICAgciA9IHBhcnNlSW50KHMuc3Vic3RyKDEgKyAwICogZCwgZCksIDE2KTtcbiAgICBnID0gcGFyc2VJbnQocy5zdWJzdHIoMSArIDEgKiBkLCBkKSwgMTYpO1xuICAgIGIgPSBwYXJzZUludChzLnN1YnN0cigxICsgMiAqIGQsIGQpLCAxNik7XG4gICAgaWYgKGhhc0FscGhhKSB7XG4gICAgICBhID0gcGFyc2VJbnQocy5zdWJzdHIoMSArIDMgKiBkLCBkKSwgMTYpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhID0gMjU1O1xuICAgIH1cbiAgICBpZiAoZCA9PSAxKSB7XG4gICAgICByID0gKHIgPDwgNCkgKyByO1xuICAgICAgZyA9IChnIDw8IDQpICsgZztcbiAgICAgIGIgPSAoYiA8PCA0KSArIGI7XG4gICAgICBpZiAoaGFzQWxwaGEpIHtcbiAgICAgICAgYSA9IChhIDw8IDQpICsgYTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29sb3IgPSBbciwgZywgYiwgYSAvIDI1NV07XG4gIH0gZWxzZSBpZiAocy5zdGFydHNXaXRoKCdyZ2JhKCcpKSB7XG4gICAgLy8gcmdiYSgpXG4gICAgY29sb3IgPSBzLnNsaWNlKDUsIC0xKS5zcGxpdCgnLCcpLm1hcChOdW1iZXIpO1xuICAgIG5vcm1hbGl6ZShjb2xvcik7XG4gIH0gZWxzZSBpZiAocy5zdGFydHNXaXRoKCdyZ2IoJykpIHtcbiAgICAvLyByZ2IoKVxuICAgIGNvbG9yID0gcy5zbGljZSg0LCAtMSkuc3BsaXQoJywnKS5tYXAoTnVtYmVyKTtcbiAgICBjb2xvci5wdXNoKDEpO1xuICAgIG5vcm1hbGl6ZShjb2xvcik7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvbG9yJyk7XG4gIH1cbiAgcmV0dXJuIGNvbG9yO1xufVxuXG4vKipcbiAqIFRPRE8gdGhpcyBmdW5jdGlvbiBpcyBvbmx5IHVzZWQgaW4gdGhlIHRlc3QsIHdlIHByb2JhYmx5IHNob3VsZG4ndCBleHBvcnQgaXRcbiAqIEBwYXJhbSB7Q29sb3J9IGNvbG9yIENvbG9yLlxuICogQHJldHVybiB7Q29sb3J9IENsYW1wZWQgY29sb3IuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemUoY29sb3IpIHtcbiAgY29sb3JbMF0gPSBjbGFtcCgoY29sb3JbMF0gKyAwLjUpIHwgMCwgMCwgMjU1KTtcbiAgY29sb3JbMV0gPSBjbGFtcCgoY29sb3JbMV0gKyAwLjUpIHwgMCwgMCwgMjU1KTtcbiAgY29sb3JbMl0gPSBjbGFtcCgoY29sb3JbMl0gKyAwLjUpIHwgMCwgMCwgMjU1KTtcbiAgY29sb3JbM10gPSBjbGFtcChjb2xvclszXSwgMCwgMSk7XG4gIHJldHVybiBjb2xvcjtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0NvbG9yfSBjb2xvciBDb2xvci5cbiAqIEByZXR1cm4ge3N0cmluZ30gU3RyaW5nLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9TdHJpbmcoY29sb3IpIHtcbiAgbGV0IHIgPSBjb2xvclswXTtcbiAgaWYgKHIgIT0gKHIgfCAwKSkge1xuICAgIHIgPSAociArIDAuNSkgfCAwO1xuICB9XG4gIGxldCBnID0gY29sb3JbMV07XG4gIGlmIChnICE9IChnIHwgMCkpIHtcbiAgICBnID0gKGcgKyAwLjUpIHwgMDtcbiAgfVxuICBsZXQgYiA9IGNvbG9yWzJdO1xuICBpZiAoYiAhPSAoYiB8IDApKSB7XG4gICAgYiA9IChiICsgMC41KSB8IDA7XG4gIH1cbiAgY29uc3QgYSA9IGNvbG9yWzNdID09PSB1bmRlZmluZWQgPyAxIDogTWF0aC5yb3VuZChjb2xvclszXSAqIDEwMCkgLyAxMDA7XG4gIHJldHVybiAncmdiYSgnICsgciArICcsJyArIGcgKyAnLCcgKyBiICsgJywnICsgYSArICcpJztcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gcyBTdHJpbmcuXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSBzdHJpbmcgaXMgYWN0dWFsbHkgYSB2YWxpZCBjb2xvclxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNTdHJpbmdDb2xvcihzKSB7XG4gIGlmIChOQU1FRF9DT0xPUl9SRV8udGVzdChzKSkge1xuICAgIHMgPSBmcm9tTmFtZWQocyk7XG4gIH1cbiAgcmV0dXJuIEhFWF9DT0xPUl9SRV8udGVzdChzKSB8fCBzLnN0YXJ0c1dpdGgoJ3JnYmEoJykgfHwgcy5zdGFydHNXaXRoKCdyZ2IoJyk7XG59XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvY29sb3JsaWtlXG4gKi9cbmltcG9ydCB7dG9TdHJpbmd9IGZyb20gJy4vY29sb3IuanMnO1xuXG4vKipcbiAqIEEgdHlwZSBhY2NlcHRlZCBieSBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQuZmlsbFN0eWxlXG4gKiBvciBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQuc3Ryb2tlU3R5bGUuXG4gKiBSZXByZXNlbnRzIGEgY29sb3IsIHBhdHRlcm4sIG9yIGdyYWRpZW50LiBUaGUgb3JpZ2luIGZvciBwYXR0ZXJucyBhbmRcbiAqIGdyYWRpZW50cyBhcyBmaWxsIHN0eWxlIGlzIGFuIGluY3JlbWVudCBvZiA1MTIgY3NzIHBpeGVscyBmcm9tIG1hcCBjb29yZGluYXRlXG4gKiBgWzAsIDBdYC4gRm9yIHNlYW1sZXNzIHJlcGVhdCBwYXR0ZXJucywgd2lkdGggYW5kIGhlaWdodCBvZiB0aGUgcGF0dGVybiBpbWFnZVxuICogbXVzdCBiZSBhIGZhY3RvciBvZiB0d28gKDIsIDQsIDgsIC4uLiwgNTEyKS5cbiAqXG4gKiBAdHlwZWRlZiB7c3RyaW5nfENhbnZhc1BhdHRlcm58Q2FudmFzR3JhZGllbnR9IENvbG9yTGlrZVxuICogQGFwaVxuICovXG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL2NvbG9yLmpzXCIpLkNvbG9yfENvbG9yTGlrZX0gY29sb3IgQ29sb3IuXG4gKiBAcmV0dXJuIHtDb2xvckxpa2V9IFRoZSBjb2xvciBhcyBhbiB7QGxpbmsgb2wvY29sb3JsaWtlfkNvbG9yTGlrZX0uXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc0NvbG9yTGlrZShjb2xvcikge1xuICBpZiAoQXJyYXkuaXNBcnJheShjb2xvcikpIHtcbiAgICByZXR1cm4gdG9TdHJpbmcoY29sb3IpO1xuICB9XG4gIHJldHVybiBjb2xvcjtcbn1cbiIsIi8qKlxuICogQG1vZHVsZSBvbC9jb25zb2xlXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7J2luZm8nfCd3YXJuJ3wnZXJyb3InfCdub25lJ30gTGV2ZWxcbiAqL1xuXG4vKipcbiAqIEB0eXBlIHtPYmplY3Q8TGV2ZWwsIG51bWJlcj59XG4gKi9cbmNvbnN0IGxldmVscyA9IHtcbiAgaW5mbzogMSxcbiAgd2FybjogMixcbiAgZXJyb3I6IDMsXG4gIG5vbmU6IDQsXG59O1xuXG4vKipcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmxldCBsZXZlbCA9IGxldmVscy5pbmZvO1xuXG4vKipcbiAqIFNldCB0aGUgbG9nZ2luZyBsZXZlbC4gIEJ5IGRlZmF1bHQsIHRoZSBsZXZlbCBpcyBzZXQgdG8gJ2luZm8nIGFuZCBhbGxcbiAqIG1lc3NhZ2VzIHdpbGwgYmUgbG9nZ2VkLiAgU2V0IHRvICd3YXJuJyB0byBvbmx5IGRpc3BsYXkgd2FybmluZ3MgYW5kIGVycm9ycy5cbiAqIFNldCB0byAnZXJyb3InIHRvIG9ubHkgZGlzcGxheSBlcnJvcnMuICBTZXQgdG8gJ25vbmUnIHRvIHNpbGVuY2UgYWxsIG1lc3NhZ2VzLlxuICpcbiAqIEBwYXJhbSB7TGV2ZWx9IGwgVGhlIG5ldyBsZXZlbC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldExldmVsKGwpIHtcbiAgbGV2ZWwgPSBsZXZlbHNbbF07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsb2coLi4uYXJncykge1xuICBpZiAobGV2ZWwgPiBsZXZlbHMuaW5mbykge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zb2xlLmxvZyguLi5hcmdzKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zb2xlXG59XG5cbmV4cG9ydCBmdW5jdGlvbiB3YXJuKC4uLmFyZ3MpIHtcbiAgaWYgKGxldmVsID4gbGV2ZWxzLndhcm4pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc29sZS53YXJuKC4uLmFyZ3MpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnNvbGVcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGVycm9yKC4uLmFyZ3MpIHtcbiAgaWYgKGxldmVsID4gbGV2ZWxzLmVycm9yKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnNvbGUuZXJyb3IoLi4uYXJncyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc29sZVxufVxuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2NvbnRyb2wvQXR0cmlidXRpb25cbiAqL1xuaW1wb3J0IENvbnRyb2wgZnJvbSAnLi9Db250cm9sLmpzJztcbmltcG9ydCBFdmVudFR5cGUgZnJvbSAnLi4vZXZlbnRzL0V2ZW50VHlwZS5qcyc7XG5pbXBvcnQge0NMQVNTX0NPTExBUFNFRCwgQ0xBU1NfQ09OVFJPTCwgQ0xBU1NfVU5TRUxFQ1RBQkxFfSBmcm9tICcuLi9jc3MuanMnO1xuaW1wb3J0IHtlcXVhbHN9IGZyb20gJy4uL2FycmF5LmpzJztcbmltcG9ydCB7cmVtb3ZlQ2hpbGRyZW4sIHJlcGxhY2VOb2RlfSBmcm9tICcuLi9kb20uanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbY2xhc3NOYW1lPSdvbC1hdHRyaWJ1dGlvbiddIENTUyBjbGFzcyBuYW1lLlxuICogQHByb3BlcnR5IHtIVE1MRWxlbWVudHxzdHJpbmd9IFt0YXJnZXRdIFNwZWNpZnkgYSB0YXJnZXQgaWYgeW91XG4gKiB3YW50IHRoZSBjb250cm9sIHRvIGJlIHJlbmRlcmVkIG91dHNpZGUgb2YgdGhlIG1hcCdzXG4gKiB2aWV3cG9ydC5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2NvbGxhcHNpYmxlXSBTcGVjaWZ5IGlmIGF0dHJpYnV0aW9ucyBjYW5cbiAqIGJlIGNvbGxhcHNlZC4gSWYgbm90IHNwZWNpZmllZCwgc291cmNlcyBjb250cm9sIHRoaXMgYmVoYXZpb3Igd2l0aCB0aGVpclxuICogYGF0dHJpYnV0aW9uc0NvbGxhcHNpYmxlYCBzZXR0aW5nLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbY29sbGFwc2VkPXRydWVdIFNwZWNpZnkgaWYgYXR0cmlidXRpb25zIHNob3VsZFxuICogYmUgY29sbGFwc2VkIGF0IHN0YXJ0dXAuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW3RpcExhYmVsPSdBdHRyaWJ1dGlvbnMnXSBUZXh0IGxhYmVsIHRvIHVzZSBmb3IgdGhlIGJ1dHRvbiB0aXAuXG4gKiBAcHJvcGVydHkge3N0cmluZ3xIVE1MRWxlbWVudH0gW2xhYmVsPSdpJ10gVGV4dCBsYWJlbCB0byB1c2UgZm9yIHRoZVxuICogY29sbGFwc2VkIGF0dHJpYnV0aW9ucyBidXR0b24uXG4gKiBJbnN0ZWFkIG9mIHRleHQsIGFsc28gYW4gZWxlbWVudCAoZS5nLiBhIGBzcGFuYCBlbGVtZW50KSBjYW4gYmUgdXNlZC5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbZXhwYW5kQ2xhc3NOYW1lPWNsYXNzTmFtZSArICctZXhwYW5kJ10gQ1NTIGNsYXNzIG5hbWUgZm9yIHRoZVxuICogY29sbGFwc2VkIGF0dHJpYnV0aW9ucyBidXR0b24uXG4gKiBAcHJvcGVydHkge3N0cmluZ3xIVE1MRWxlbWVudH0gW2NvbGxhcHNlTGFiZWw9J+KAuiddIFRleHQgbGFiZWwgdG8gdXNlXG4gKiBmb3IgdGhlIGV4cGFuZGVkIGF0dHJpYnV0aW9ucyBidXR0b24uXG4gKiBJbnN0ZWFkIG9mIHRleHQsIGFsc28gYW4gZWxlbWVudCAoZS5nLiBhIGBzcGFuYCBlbGVtZW50KSBjYW4gYmUgdXNlZC5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbY29sbGFwc2VDbGFzc05hbWU9Y2xhc3NOYW1lICsgJy1jb2xsYXBzZSddIENTUyBjbGFzcyBuYW1lIGZvciB0aGVcbiAqIGV4cGFuZGVkIGF0dHJpYnV0aW9ucyBidXR0b24uXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9uKGltcG9ydChcIi4uL01hcEV2ZW50LmpzXCIpLmRlZmF1bHQpOnZvaWR9IFtyZW5kZXJdIEZ1bmN0aW9uIGNhbGxlZCB3aGVuXG4gKiB0aGUgY29udHJvbCBzaG91bGQgYmUgcmUtcmVuZGVyZWQuIFRoaXMgaXMgY2FsbGVkIGluIGEgYHJlcXVlc3RBbmltYXRpb25GcmFtZWBcbiAqIGNhbGxiYWNrLlxuICovXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQ29udHJvbCB0byBzaG93IGFsbCB0aGUgYXR0cmlidXRpb25zIGFzc29jaWF0ZWQgd2l0aCB0aGUgbGF5ZXIgc291cmNlc1xuICogaW4gdGhlIG1hcC4gVGhpcyBjb250cm9sIGlzIG9uZSBvZiB0aGUgZGVmYXVsdCBjb250cm9scyBpbmNsdWRlZCBpbiBtYXBzLlxuICogQnkgZGVmYXVsdCBpdCB3aWxsIHNob3cgaW4gdGhlIGJvdHRvbSByaWdodCBwb3J0aW9uIG9mIHRoZSBtYXAsIGJ1dCB0aGlzIGNhblxuICogYmUgY2hhbmdlZCBieSB1c2luZyBhIGNzcyBzZWxlY3RvciBmb3IgYC5vbC1hdHRyaWJ1dGlvbmAuXG4gKlxuICogQGFwaVxuICovXG5jbGFzcyBBdHRyaWJ1dGlvbiBleHRlbmRzIENvbnRyb2wge1xuICAvKipcbiAgICogQHBhcmFtIHtPcHRpb25zfSBbb3B0aW9uc10gQXR0cmlidXRpb24gb3B0aW9ucy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyA/IG9wdGlvbnMgOiB7fTtcblxuICAgIHN1cGVyKHtcbiAgICAgIGVsZW1lbnQ6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLFxuICAgICAgcmVuZGVyOiBvcHRpb25zLnJlbmRlcixcbiAgICAgIHRhcmdldDogb3B0aW9ucy50YXJnZXQsXG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cbiAgICAgKi9cbiAgICB0aGlzLnVsRWxlbWVudF8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd1bCcpO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmNvbGxhcHNlZF8gPVxuICAgICAgb3B0aW9ucy5jb2xsYXBzZWQgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuY29sbGFwc2VkIDogdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy51c2VyQ29sbGFwc2VkXyA9IHRoaXMuY29sbGFwc2VkXztcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5vdmVycmlkZUNvbGxhcHNpYmxlXyA9IG9wdGlvbnMuY29sbGFwc2libGUgIT09IHVuZGVmaW5lZDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5jb2xsYXBzaWJsZV8gPVxuICAgICAgb3B0aW9ucy5jb2xsYXBzaWJsZSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5jb2xsYXBzaWJsZSA6IHRydWU7XG5cbiAgICBpZiAoIXRoaXMuY29sbGFwc2libGVfKSB7XG4gICAgICB0aGlzLmNvbGxhcHNlZF8gPSBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCBjbGFzc05hbWUgPVxuICAgICAgb3B0aW9ucy5jbGFzc05hbWUgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuY2xhc3NOYW1lIDogJ29sLWF0dHJpYnV0aW9uJztcblxuICAgIGNvbnN0IHRpcExhYmVsID1cbiAgICAgIG9wdGlvbnMudGlwTGFiZWwgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMudGlwTGFiZWwgOiAnQXR0cmlidXRpb25zJztcblxuICAgIGNvbnN0IGV4cGFuZENsYXNzTmFtZSA9XG4gICAgICBvcHRpb25zLmV4cGFuZENsYXNzTmFtZSAhPT0gdW5kZWZpbmVkXG4gICAgICAgID8gb3B0aW9ucy5leHBhbmRDbGFzc05hbWVcbiAgICAgICAgOiBjbGFzc05hbWUgKyAnLWV4cGFuZCc7XG5cbiAgICBjb25zdCBjb2xsYXBzZUxhYmVsID1cbiAgICAgIG9wdGlvbnMuY29sbGFwc2VMYWJlbCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5jb2xsYXBzZUxhYmVsIDogJ1xcdTIwM0EnO1xuXG4gICAgY29uc3QgY29sbGFwc2VDbGFzc05hbWUgPVxuICAgICAgb3B0aW9ucy5jb2xsYXBzZUNsYXNzTmFtZSAhPT0gdW5kZWZpbmVkXG4gICAgICAgID8gb3B0aW9ucy5jb2xsYXBzZUNsYXNzTmFtZVxuICAgICAgICA6IGNsYXNzTmFtZSArICctY29sbGFwc2UnO1xuXG4gICAgaWYgKHR5cGVvZiBjb2xsYXBzZUxhYmVsID09PSAnc3RyaW5nJykge1xuICAgICAgLyoqXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICogQHR5cGUge0hUTUxFbGVtZW50fVxuICAgICAgICovXG4gICAgICB0aGlzLmNvbGxhcHNlTGFiZWxfID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgICAgdGhpcy5jb2xsYXBzZUxhYmVsXy50ZXh0Q29udGVudCA9IGNvbGxhcHNlTGFiZWw7XG4gICAgICB0aGlzLmNvbGxhcHNlTGFiZWxfLmNsYXNzTmFtZSA9IGNvbGxhcHNlQ2xhc3NOYW1lO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNvbGxhcHNlTGFiZWxfID0gY29sbGFwc2VMYWJlbDtcbiAgICB9XG5cbiAgICBjb25zdCBsYWJlbCA9IG9wdGlvbnMubGFiZWwgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMubGFiZWwgOiAnaSc7XG5cbiAgICBpZiAodHlwZW9mIGxhYmVsID09PSAnc3RyaW5nJykge1xuICAgICAgLyoqXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICogQHR5cGUge0hUTUxFbGVtZW50fVxuICAgICAgICovXG4gICAgICB0aGlzLmxhYmVsXyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgIHRoaXMubGFiZWxfLnRleHRDb250ZW50ID0gbGFiZWw7XG4gICAgICB0aGlzLmxhYmVsXy5jbGFzc05hbWUgPSBleHBhbmRDbGFzc05hbWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubGFiZWxfID0gbGFiZWw7XG4gICAgfVxuXG4gICAgY29uc3QgYWN0aXZlTGFiZWwgPVxuICAgICAgdGhpcy5jb2xsYXBzaWJsZV8gJiYgIXRoaXMuY29sbGFwc2VkXyA/IHRoaXMuY29sbGFwc2VMYWJlbF8gOiB0aGlzLmxhYmVsXztcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0hUTUxFbGVtZW50fVxuICAgICAqL1xuICAgIHRoaXMudG9nZ2xlQnV0dG9uXyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpO1xuICAgIHRoaXMudG9nZ2xlQnV0dG9uXy5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAnYnV0dG9uJyk7XG4gICAgdGhpcy50b2dnbGVCdXR0b25fLnNldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcsIFN0cmluZyghdGhpcy5jb2xsYXBzZWRfKSk7XG4gICAgdGhpcy50b2dnbGVCdXR0b25fLnRpdGxlID0gdGlwTGFiZWw7XG4gICAgdGhpcy50b2dnbGVCdXR0b25fLmFwcGVuZENoaWxkKGFjdGl2ZUxhYmVsKTtcblxuICAgIHRoaXMudG9nZ2xlQnV0dG9uXy5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgRXZlbnRUeXBlLkNMSUNLLFxuICAgICAgdGhpcy5oYW5kbGVDbGlja18uYmluZCh0aGlzKSxcbiAgICAgIGZhbHNlXG4gICAgKTtcblxuICAgIGNvbnN0IGNzc0NsYXNzZXMgPVxuICAgICAgY2xhc3NOYW1lICtcbiAgICAgICcgJyArXG4gICAgICBDTEFTU19VTlNFTEVDVEFCTEUgK1xuICAgICAgJyAnICtcbiAgICAgIENMQVNTX0NPTlRST0wgK1xuICAgICAgKHRoaXMuY29sbGFwc2VkXyAmJiB0aGlzLmNvbGxhcHNpYmxlXyA/ICcgJyArIENMQVNTX0NPTExBUFNFRCA6ICcnKSArXG4gICAgICAodGhpcy5jb2xsYXBzaWJsZV8gPyAnJyA6ICcgb2wtdW5jb2xsYXBzaWJsZScpO1xuICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQ7XG4gICAgZWxlbWVudC5jbGFzc05hbWUgPSBjc3NDbGFzc2VzO1xuICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy50b2dnbGVCdXR0b25fKTtcbiAgICBlbGVtZW50LmFwcGVuZENoaWxkKHRoaXMudWxFbGVtZW50Xyk7XG5cbiAgICAvKipcbiAgICAgKiBBIGxpc3Qgb2YgY3VycmVudGx5IHJlbmRlcmVkIHJlc29sdXRpb25zLlxuICAgICAqIEB0eXBlIHtBcnJheTxzdHJpbmc+fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5yZW5kZXJlZEF0dHJpYnV0aW9uc18gPSBbXTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5yZW5kZXJlZFZpc2libGVfID0gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb2xsZWN0IGEgbGlzdCBvZiB2aXNpYmxlIGF0dHJpYnV0aW9ucyBhbmQgc2V0IHRoZSBjb2xsYXBzaWJsZSBzdGF0ZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXAuanNcIikuRnJhbWVTdGF0ZX0gZnJhbWVTdGF0ZSBGcmFtZSBzdGF0ZS5cbiAgICogQHJldHVybiB7QXJyYXk8c3RyaW5nPn0gQXR0cmlidXRpb25zLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY29sbGVjdFNvdXJjZUF0dHJpYnV0aW9uc18oZnJhbWVTdGF0ZSkge1xuICAgIGNvbnN0IHZpc2libGVBdHRyaWJ1dGlvbnMgPSBBcnJheS5mcm9tKFxuICAgICAgbmV3IFNldChcbiAgICAgICAgdGhpcy5nZXRNYXAoKVxuICAgICAgICAgIC5nZXRBbGxMYXllcnMoKVxuICAgICAgICAgIC5mbGF0TWFwKChsYXllcikgPT4gbGF5ZXIuZ2V0QXR0cmlidXRpb25zKGZyYW1lU3RhdGUpKVxuICAgICAgKVxuICAgICk7XG5cbiAgICBjb25zdCBjb2xsYXBzaWJsZSA9ICF0aGlzLmdldE1hcCgpXG4gICAgICAuZ2V0QWxsTGF5ZXJzKClcbiAgICAgIC5zb21lKFxuICAgICAgICAobGF5ZXIpID0+XG4gICAgICAgICAgbGF5ZXIuZ2V0U291cmNlKCkgJiZcbiAgICAgICAgICBsYXllci5nZXRTb3VyY2UoKS5nZXRBdHRyaWJ1dGlvbnNDb2xsYXBzaWJsZSgpID09PSBmYWxzZVxuICAgICAgKTtcbiAgICBpZiAoIXRoaXMub3ZlcnJpZGVDb2xsYXBzaWJsZV8pIHtcbiAgICAgIHRoaXMuc2V0Q29sbGFwc2libGUoY29sbGFwc2libGUpO1xuICAgIH1cbiAgICByZXR1cm4gdmlzaWJsZUF0dHJpYnV0aW9ucztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0gez9pbXBvcnQoXCIuLi9NYXAuanNcIikuRnJhbWVTdGF0ZX0gZnJhbWVTdGF0ZSBGcmFtZSBzdGF0ZS5cbiAgICovXG4gIHVwZGF0ZUVsZW1lbnRfKGZyYW1lU3RhdGUpIHtcbiAgICBpZiAoIWZyYW1lU3RhdGUpIHtcbiAgICAgIGlmICh0aGlzLnJlbmRlcmVkVmlzaWJsZV8pIHtcbiAgICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIHRoaXMucmVuZGVyZWRWaXNpYmxlXyA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGF0dHJpYnV0aW9ucyA9IHRoaXMuY29sbGVjdFNvdXJjZUF0dHJpYnV0aW9uc18oZnJhbWVTdGF0ZSk7XG5cbiAgICBjb25zdCB2aXNpYmxlID0gYXR0cmlidXRpb25zLmxlbmd0aCA+IDA7XG4gICAgaWYgKHRoaXMucmVuZGVyZWRWaXNpYmxlXyAhPSB2aXNpYmxlKSB7XG4gICAgICB0aGlzLmVsZW1lbnQuc3R5bGUuZGlzcGxheSA9IHZpc2libGUgPyAnJyA6ICdub25lJztcbiAgICAgIHRoaXMucmVuZGVyZWRWaXNpYmxlXyA9IHZpc2libGU7XG4gICAgfVxuXG4gICAgaWYgKGVxdWFscyhhdHRyaWJ1dGlvbnMsIHRoaXMucmVuZGVyZWRBdHRyaWJ1dGlvbnNfKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHJlbW92ZUNoaWxkcmVuKHRoaXMudWxFbGVtZW50Xyk7XG5cbiAgICAvLyBhcHBlbmQgdGhlIGF0dHJpYnV0aW9uc1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IGF0dHJpYnV0aW9ucy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICBjb25zdCBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGknKTtcbiAgICAgIGVsZW1lbnQuaW5uZXJIVE1MID0gYXR0cmlidXRpb25zW2ldO1xuICAgICAgdGhpcy51bEVsZW1lbnRfLmFwcGVuZENoaWxkKGVsZW1lbnQpO1xuICAgIH1cblxuICAgIHRoaXMucmVuZGVyZWRBdHRyaWJ1dGlvbnNfID0gYXR0cmlidXRpb25zO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7TW91c2VFdmVudH0gZXZlbnQgVGhlIGV2ZW50IHRvIGhhbmRsZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaGFuZGxlQ2xpY2tfKGV2ZW50KSB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB0aGlzLmhhbmRsZVRvZ2dsZV8oKTtcbiAgICB0aGlzLnVzZXJDb2xsYXBzZWRfID0gdGhpcy5jb2xsYXBzZWRfO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBoYW5kbGVUb2dnbGVfKCkge1xuICAgIHRoaXMuZWxlbWVudC5jbGFzc0xpc3QudG9nZ2xlKENMQVNTX0NPTExBUFNFRCk7XG4gICAgaWYgKHRoaXMuY29sbGFwc2VkXykge1xuICAgICAgcmVwbGFjZU5vZGUodGhpcy5jb2xsYXBzZUxhYmVsXywgdGhpcy5sYWJlbF8pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXBsYWNlTm9kZSh0aGlzLmxhYmVsXywgdGhpcy5jb2xsYXBzZUxhYmVsXyk7XG4gICAgfVxuICAgIHRoaXMuY29sbGFwc2VkXyA9ICF0aGlzLmNvbGxhcHNlZF87XG4gICAgdGhpcy50b2dnbGVCdXR0b25fLnNldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcsIFN0cmluZyghdGhpcy5jb2xsYXBzZWRfKSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGB0cnVlYCBpZiB0aGUgYXR0cmlidXRpb24gaXMgY29sbGFwc2libGUsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSB3aWRnZXQgaXMgY29sbGFwc2libGUuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldENvbGxhcHNpYmxlKCkge1xuICAgIHJldHVybiB0aGlzLmNvbGxhcHNpYmxlXztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgd2hldGhlciB0aGUgYXR0cmlidXRpb24gc2hvdWxkIGJlIGNvbGxhcHNpYmxlLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGNvbGxhcHNpYmxlIFRydWUgaWYgdGhlIHdpZGdldCBpcyBjb2xsYXBzaWJsZS5cbiAgICogQGFwaVxuICAgKi9cbiAgc2V0Q29sbGFwc2libGUoY29sbGFwc2libGUpIHtcbiAgICBpZiAodGhpcy5jb2xsYXBzaWJsZV8gPT09IGNvbGxhcHNpYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuY29sbGFwc2libGVfID0gY29sbGFwc2libGU7XG4gICAgdGhpcy5lbGVtZW50LmNsYXNzTGlzdC50b2dnbGUoJ29sLXVuY29sbGFwc2libGUnKTtcbiAgICBpZiAodGhpcy51c2VyQ29sbGFwc2VkXykge1xuICAgICAgdGhpcy5oYW5kbGVUb2dnbGVfKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENvbGxhcHNlIG9yIGV4cGFuZCB0aGUgYXR0cmlidXRpb24gYWNjb3JkaW5nIHRvIHRoZSBwYXNzZWQgcGFyYW1ldGVyLiBXaWxsXG4gICAqIG5vdCBkbyBhbnl0aGluZyBpZiB0aGUgYXR0cmlidXRpb24gaXNuJ3QgY29sbGFwc2libGUgb3IgaWYgdGhlIGN1cnJlbnRcbiAgICogY29sbGFwc2VkIHN0YXRlIGlzIGFscmVhZHkgdGhlIG9uZSByZXF1ZXN0ZWQuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gY29sbGFwc2VkIFRydWUgaWYgdGhlIHdpZGdldCBpcyBjb2xsYXBzZWQuXG4gICAqIEBhcGlcbiAgICovXG4gIHNldENvbGxhcHNlZChjb2xsYXBzZWQpIHtcbiAgICB0aGlzLnVzZXJDb2xsYXBzZWRfID0gY29sbGFwc2VkO1xuICAgIGlmICghdGhpcy5jb2xsYXBzaWJsZV8gfHwgdGhpcy5jb2xsYXBzZWRfID09PSBjb2xsYXBzZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5oYW5kbGVUb2dnbGVfKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGB0cnVlYCB3aGVuIHRoZSBhdHRyaWJ1dGlvbiBpcyBjdXJyZW50bHkgY29sbGFwc2VkIG9yIGBmYWxzZWBcbiAgICogb3RoZXJ3aXNlLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSB3aWRnZXQgaXMgY29sbGFwc2VkLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRDb2xsYXBzZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29sbGFwc2VkXztcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIGF0dHJpYnV0aW9uIGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwRXZlbnQuanNcIikuZGVmYXVsdH0gbWFwRXZlbnQgTWFwIGV2ZW50LlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIHJlbmRlcihtYXBFdmVudCkge1xuICAgIHRoaXMudXBkYXRlRWxlbWVudF8obWFwRXZlbnQuZnJhbWVTdGF0ZSk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQXR0cmlidXRpb247XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvY29udHJvbC9Db250cm9sXG4gKi9cbmltcG9ydCBCYXNlT2JqZWN0IGZyb20gJy4uL09iamVjdC5qcyc7XG5pbXBvcnQgTWFwRXZlbnRUeXBlIGZyb20gJy4uL01hcEV2ZW50VHlwZS5qcyc7XG5pbXBvcnQge1ZPSUR9IGZyb20gJy4uL2Z1bmN0aW9ucy5qcyc7XG5pbXBvcnQge2xpc3RlbiwgdW5saXN0ZW5CeUtleX0gZnJvbSAnLi4vZXZlbnRzLmpzJztcbmltcG9ydCB7cmVtb3ZlTm9kZX0gZnJvbSAnLi4vZG9tLmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge0hUTUxFbGVtZW50fSBbZWxlbWVudF0gVGhlIGVsZW1lbnQgaXMgdGhlIGNvbnRyb2wnc1xuICogY29udGFpbmVyIGVsZW1lbnQuIFRoaXMgb25seSBuZWVkcyB0byBiZSBzcGVjaWZpZWQgaWYgeW91J3JlIGRldmVsb3BpbmdcbiAqIGEgY3VzdG9tIGNvbnRyb2wuXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9uKGltcG9ydChcIi4uL01hcEV2ZW50LmpzXCIpLmRlZmF1bHQpOnZvaWR9IFtyZW5kZXJdIEZ1bmN0aW9uIGNhbGxlZCB3aGVuXG4gKiB0aGUgY29udHJvbCBzaG91bGQgYmUgcmUtcmVuZGVyZWQuIFRoaXMgaXMgY2FsbGVkIGluIGEgYHJlcXVlc3RBbmltYXRpb25GcmFtZWBcbiAqIGNhbGxiYWNrLlxuICogQHByb3BlcnR5IHtIVE1MRWxlbWVudHxzdHJpbmd9IFt0YXJnZXRdIFNwZWNpZnkgYSB0YXJnZXQgaWYgeW91IHdhbnRcbiAqIHRoZSBjb250cm9sIHRvIGJlIHJlbmRlcmVkIG91dHNpZGUgb2YgdGhlIG1hcCdzIHZpZXdwb3J0LlxuICovXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQSBjb250cm9sIGlzIGEgdmlzaWJsZSB3aWRnZXQgd2l0aCBhIERPTSBlbGVtZW50IGluIGEgZml4ZWQgcG9zaXRpb24gb24gdGhlXG4gKiBzY3JlZW4uIFRoZXkgY2FuIGludm9sdmUgdXNlciBpbnB1dCAoYnV0dG9ucyksIG9yIGJlIGluZm9ybWF0aW9uYWwgb25seTtcbiAqIHRoZSBwb3NpdGlvbiBpcyBkZXRlcm1pbmVkIHVzaW5nIENTUy4gQnkgZGVmYXVsdCB0aGVzZSBhcmUgcGxhY2VkIGluIHRoZVxuICogY29udGFpbmVyIHdpdGggQ1NTIGNsYXNzIG5hbWUgYG9sLW92ZXJsYXljb250YWluZXItc3RvcGV2ZW50YCwgYnV0IGNhbiB1c2VcbiAqIGFueSBvdXRzaWRlIERPTSBlbGVtZW50LlxuICpcbiAqIFRoaXMgaXMgdGhlIGJhc2UgY2xhc3MgZm9yIGNvbnRyb2xzLiBZb3UgY2FuIHVzZSBpdCBmb3Igc2ltcGxlIGN1c3RvbVxuICogY29udHJvbHMgYnkgY3JlYXRpbmcgdGhlIGVsZW1lbnQgd2l0aCBsaXN0ZW5lcnMsIGNyZWF0aW5nIGFuIGluc3RhbmNlOlxuICogYGBganNcbiAqIGNvbnN0IG15Q29udHJvbCA9IG5ldyBDb250cm9sKHtlbGVtZW50OiBteUVsZW1lbnR9KTtcbiAqIGBgYFxuICogYW5kIHRoZW4gYWRkaW5nIHRoaXMgdG8gdGhlIG1hcC5cbiAqXG4gKiBUaGUgbWFpbiBhZHZhbnRhZ2Ugb2YgaGF2aW5nIHRoaXMgYXMgYSBjb250cm9sIHJhdGhlciB0aGFuIGEgc2ltcGxlIHNlcGFyYXRlXG4gKiBET00gZWxlbWVudCBpcyB0aGF0IHByZXZlbnRpbmcgcHJvcGFnYXRpb24gaXMgaGFuZGxlZCBmb3IgeW91LiBDb250cm9sc1xuICogd2lsbCBhbHNvIGJlIG9iamVjdHMgaW4gYSB7QGxpbmsgbW9kdWxlOm9sL0NvbGxlY3Rpb25+Q29sbGVjdGlvbn0sIHNvIHlvdSBjYW4gdXNlIHRoZWlyIG1ldGhvZHMuXG4gKlxuICogWW91IGNhbiBhbHNvIGV4dGVuZCB0aGlzIGJhc2UgZm9yIHlvdXIgb3duIGNvbnRyb2wgY2xhc3MuIFNlZVxuICogZXhhbXBsZXMvY3VzdG9tLWNvbnRyb2xzIGZvciBhbiBleGFtcGxlIG9mIGhvdyB0byBkbyB0aGlzLlxuICpcbiAqIEBhcGlcbiAqL1xuY2xhc3MgQ29udHJvbCBleHRlbmRzIEJhc2VPYmplY3Qge1xuICAvKipcbiAgICogQHBhcmFtIHtPcHRpb25zfSBvcHRpb25zIENvbnRyb2wgb3B0aW9ucy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgY29uc3QgZWxlbWVudCA9IG9wdGlvbnMuZWxlbWVudDtcbiAgICBpZiAoZWxlbWVudCAmJiAhb3B0aW9ucy50YXJnZXQgJiYgIWVsZW1lbnQuc3R5bGUucG9pbnRlckV2ZW50cykge1xuICAgICAgZWxlbWVudC5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ2F1dG8nO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XG4gICAgICovXG4gICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudCA/IGVsZW1lbnQgOiBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XG4gICAgICovXG4gICAgdGhpcy50YXJnZXRfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL01hcC5qc1wiKS5kZWZhdWx0fG51bGx9XG4gICAgICovXG4gICAgdGhpcy5tYXBfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAdHlwZSB7IUFycmF5PGltcG9ydChcIi4uL2V2ZW50cy5qc1wiKS5FdmVudHNLZXk+fVxuICAgICAqL1xuICAgIHRoaXMubGlzdGVuZXJLZXlzID0gW107XG5cbiAgICBpZiAob3B0aW9ucy5yZW5kZXIpIHtcbiAgICAgIHRoaXMucmVuZGVyID0gb3B0aW9ucy5yZW5kZXI7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMudGFyZ2V0KSB7XG4gICAgICB0aGlzLnNldFRhcmdldChvcHRpb25zLnRhcmdldCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENsZWFuIHVwLlxuICAgKi9cbiAgZGlzcG9zZUludGVybmFsKCkge1xuICAgIHJlbW92ZU5vZGUodGhpcy5lbGVtZW50KTtcbiAgICBzdXBlci5kaXNwb3NlSW50ZXJuYWwoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG1hcCBhc3NvY2lhdGVkIHdpdGggdGhpcyBjb250cm9sLlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9NYXAuanNcIikuZGVmYXVsdHxudWxsfSBNYXAuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldE1hcCgpIHtcbiAgICByZXR1cm4gdGhpcy5tYXBfO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSB0aGUgY29udHJvbCBmcm9tIGl0cyBjdXJyZW50IG1hcCBhbmQgYXR0YWNoIGl0IHRvIHRoZSBuZXcgbWFwLlxuICAgKiBQYXNzIGBudWxsYCB0byBqdXN0IHJlbW92ZSB0aGUgY29udHJvbCBmcm9tIHRoZSBjdXJyZW50IG1hcC5cbiAgICogU3ViY2xhc3NlcyBtYXkgc2V0IHVwIGV2ZW50IGhhbmRsZXJzIHRvIGdldCBub3RpZmllZCBhYm91dCBjaGFuZ2VzIHRvXG4gICAqIHRoZSBtYXAgaGVyZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXAuanNcIikuZGVmYXVsdHxudWxsfSBtYXAgTWFwLlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRNYXAobWFwKSB7XG4gICAgaWYgKHRoaXMubWFwXykge1xuICAgICAgcmVtb3ZlTm9kZSh0aGlzLmVsZW1lbnQpO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSB0aGlzLmxpc3RlbmVyS2V5cy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICB1bmxpc3RlbkJ5S2V5KHRoaXMubGlzdGVuZXJLZXlzW2ldKTtcbiAgICB9XG4gICAgdGhpcy5saXN0ZW5lcktleXMubGVuZ3RoID0gMDtcbiAgICB0aGlzLm1hcF8gPSBtYXA7XG4gICAgaWYgKG1hcCkge1xuICAgICAgY29uc3QgdGFyZ2V0ID0gdGhpcy50YXJnZXRfXG4gICAgICAgID8gdGhpcy50YXJnZXRfXG4gICAgICAgIDogbWFwLmdldE92ZXJsYXlDb250YWluZXJTdG9wRXZlbnQoKTtcbiAgICAgIHRhcmdldC5hcHBlbmRDaGlsZCh0aGlzLmVsZW1lbnQpO1xuICAgICAgaWYgKHRoaXMucmVuZGVyICE9PSBWT0lEKSB7XG4gICAgICAgIHRoaXMubGlzdGVuZXJLZXlzLnB1c2goXG4gICAgICAgICAgbGlzdGVuKG1hcCwgTWFwRXZlbnRUeXBlLlBPU1RSRU5ERVIsIHRoaXMucmVuZGVyLCB0aGlzKVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgbWFwLnJlbmRlcigpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBjb250cm9sLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcEV2ZW50LmpzXCIpLmRlZmF1bHR9IG1hcEV2ZW50IE1hcCBldmVudC5cbiAgICogQGFwaVxuICAgKi9cbiAgcmVuZGVyKG1hcEV2ZW50KSB7fVxuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgdG8gc2V0IGEgdGFyZ2V0IGVsZW1lbnQgZm9yIHRoZSBjb250cm9sLiBJdCBoYXMgbm9cbiAgICogZWZmZWN0IGlmIGl0IGlzIGNhbGxlZCBhZnRlciB0aGUgY29udHJvbCBoYXMgYmVlbiBhZGRlZCB0byB0aGUgbWFwIChpLmUuXG4gICAqIGFmdGVyIGBzZXRNYXBgIGlzIGNhbGxlZCBvbiB0aGUgY29udHJvbCkuIElmIG5vIGB0YXJnZXRgIGlzIHNldCBpbiB0aGVcbiAgICogb3B0aW9ucyBwYXNzZWQgdG8gdGhlIGNvbnRyb2wgY29uc3RydWN0b3IgYW5kIGlmIGBzZXRUYXJnZXRgIGlzIG5vdCBjYWxsZWRcbiAgICogdGhlbiB0aGUgY29udHJvbCBpcyBhZGRlZCB0byB0aGUgbWFwJ3Mgb3ZlcmxheSBjb250YWluZXIuXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR8c3RyaW5nfSB0YXJnZXQgVGFyZ2V0LlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRUYXJnZXQodGFyZ2V0KSB7XG4gICAgdGhpcy50YXJnZXRfID1cbiAgICAgIHR5cGVvZiB0YXJnZXQgPT09ICdzdHJpbmcnID8gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGFyZ2V0KSA6IHRhcmdldDtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBDb250cm9sO1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2NvbnRyb2wvUm90YXRlXG4gKi9cbmltcG9ydCBDb250cm9sIGZyb20gJy4vQ29udHJvbC5qcyc7XG5pbXBvcnQgRXZlbnRUeXBlIGZyb20gJy4uL2V2ZW50cy9FdmVudFR5cGUuanMnO1xuaW1wb3J0IHtDTEFTU19DT05UUk9MLCBDTEFTU19ISURERU4sIENMQVNTX1VOU0VMRUNUQUJMRX0gZnJvbSAnLi4vY3NzLmpzJztcbmltcG9ydCB7ZWFzZU91dH0gZnJvbSAnLi4vZWFzaW5nLmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2NsYXNzTmFtZT0nb2wtcm90YXRlJ10gQ1NTIGNsYXNzIG5hbWUuXG4gKiBAcHJvcGVydHkge3N0cmluZ3xIVE1MRWxlbWVudH0gW2xhYmVsPSfih6cnXSBUZXh0IGxhYmVsIHRvIHVzZSBmb3IgdGhlIHJvdGF0ZSBidXR0b24uXG4gKiBJbnN0ZWFkIG9mIHRleHQsIGFsc28gYW4gZWxlbWVudCAoZS5nLiBhIGBzcGFuYCBlbGVtZW50KSBjYW4gYmUgdXNlZC5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbdGlwTGFiZWw9J1Jlc2V0IHJvdGF0aW9uJ10gVGV4dCBsYWJlbCB0byB1c2UgZm9yIHRoZSByb3RhdGUgdGlwLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtjb21wYXNzQ2xhc3NOYW1lPSdvbC1jb21wYXNzJ10gQ1NTIGNsYXNzIG5hbWUgZm9yIHRoZSBjb21wYXNzLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtkdXJhdGlvbj0yNTBdIEFuaW1hdGlvbiBkdXJhdGlvbiBpbiBtaWxsaXNlY29uZHMuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFthdXRvSGlkZT10cnVlXSBIaWRlIHRoZSBjb250cm9sIHdoZW4gcm90YXRpb24gaXMgMC5cbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb24oaW1wb3J0KFwiLi4vTWFwRXZlbnQuanNcIikuZGVmYXVsdCk6dm9pZH0gW3JlbmRlcl0gRnVuY3Rpb24gY2FsbGVkIHdoZW4gdGhlIGNvbnRyb2wgc2hvdWxkXG4gKiBiZSByZS1yZW5kZXJlZC4gVGhpcyBpcyBjYWxsZWQgaW4gYSBgcmVxdWVzdEFuaW1hdGlvbkZyYW1lYCBjYWxsYmFjay5cbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb24oKTp2b2lkfSBbcmVzZXROb3J0aF0gRnVuY3Rpb24gY2FsbGVkIHdoZW4gdGhlIGNvbnRyb2wgaXMgY2xpY2tlZC5cbiAqIFRoaXMgd2lsbCBvdmVycmlkZSB0aGUgZGVmYXVsdCBgcmVzZXROb3J0aGAuXG4gKiBAcHJvcGVydHkge0hUTUxFbGVtZW50fHN0cmluZ30gW3RhcmdldF0gU3BlY2lmeSBhIHRhcmdldCBpZiB5b3Ugd2FudCB0aGUgY29udHJvbCB0byBiZVxuICogcmVuZGVyZWQgb3V0c2lkZSBvZiB0aGUgbWFwJ3Mgdmlld3BvcnQuXG4gKi9cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBBIGJ1dHRvbiBjb250cm9sIHRvIHJlc2V0IHJvdGF0aW9uIHRvIDAuXG4gKiBUbyBzdHlsZSB0aGlzIGNvbnRyb2wgdXNlIGNzcyBzZWxlY3RvciBgLm9sLXJvdGF0ZWAuIEEgYC5vbC1oaWRkZW5gIGNzc1xuICogc2VsZWN0b3IgaXMgYWRkZWQgdG8gdGhlIGJ1dHRvbiB3aGVuIHRoZSByb3RhdGlvbiBpcyAwLlxuICpcbiAqIEBhcGlcbiAqL1xuY2xhc3MgUm90YXRlIGV4dGVuZHMgQ29udHJvbCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge09wdGlvbnN9IFtvcHRpb25zXSBSb3RhdGUgb3B0aW9ucy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyA/IG9wdGlvbnMgOiB7fTtcblxuICAgIHN1cGVyKHtcbiAgICAgIGVsZW1lbnQ6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLFxuICAgICAgcmVuZGVyOiBvcHRpb25zLnJlbmRlcixcbiAgICAgIHRhcmdldDogb3B0aW9ucy50YXJnZXQsXG4gICAgfSk7XG5cbiAgICBjb25zdCBjbGFzc05hbWUgPVxuICAgICAgb3B0aW9ucy5jbGFzc05hbWUgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuY2xhc3NOYW1lIDogJ29sLXJvdGF0ZSc7XG5cbiAgICBjb25zdCBsYWJlbCA9IG9wdGlvbnMubGFiZWwgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMubGFiZWwgOiAnXFx1MjFFNyc7XG5cbiAgICBjb25zdCBjb21wYXNzQ2xhc3NOYW1lID1cbiAgICAgIG9wdGlvbnMuY29tcGFzc0NsYXNzTmFtZSAhPT0gdW5kZWZpbmVkXG4gICAgICAgID8gb3B0aW9ucy5jb21wYXNzQ2xhc3NOYW1lXG4gICAgICAgIDogJ29sLWNvbXBhc3MnO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge0hUTUxFbGVtZW50fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5sYWJlbF8gPSBudWxsO1xuXG4gICAgaWYgKHR5cGVvZiBsYWJlbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRoaXMubGFiZWxfID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgICAgdGhpcy5sYWJlbF8uY2xhc3NOYW1lID0gY29tcGFzc0NsYXNzTmFtZTtcbiAgICAgIHRoaXMubGFiZWxfLnRleHRDb250ZW50ID0gbGFiZWw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubGFiZWxfID0gbGFiZWw7XG4gICAgICB0aGlzLmxhYmVsXy5jbGFzc0xpc3QuYWRkKGNvbXBhc3NDbGFzc05hbWUpO1xuICAgIH1cblxuICAgIGNvbnN0IHRpcExhYmVsID0gb3B0aW9ucy50aXBMYWJlbCA/IG9wdGlvbnMudGlwTGFiZWwgOiAnUmVzZXQgcm90YXRpb24nO1xuXG4gICAgY29uc3QgYnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnV0dG9uJyk7XG4gICAgYnV0dG9uLmNsYXNzTmFtZSA9IGNsYXNzTmFtZSArICctcmVzZXQnO1xuICAgIGJ1dHRvbi5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAnYnV0dG9uJyk7XG4gICAgYnV0dG9uLnRpdGxlID0gdGlwTGFiZWw7XG4gICAgYnV0dG9uLmFwcGVuZENoaWxkKHRoaXMubGFiZWxfKTtcblxuICAgIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgRXZlbnRUeXBlLkNMSUNLLFxuICAgICAgdGhpcy5oYW5kbGVDbGlja18uYmluZCh0aGlzKSxcbiAgICAgIGZhbHNlXG4gICAgKTtcblxuICAgIGNvbnN0IGNzc0NsYXNzZXMgPVxuICAgICAgY2xhc3NOYW1lICsgJyAnICsgQ0xBU1NfVU5TRUxFQ1RBQkxFICsgJyAnICsgQ0xBU1NfQ09OVFJPTDtcbiAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5lbGVtZW50O1xuICAgIGVsZW1lbnQuY2xhc3NOYW1lID0gY3NzQ2xhc3NlcztcbiAgICBlbGVtZW50LmFwcGVuZENoaWxkKGJ1dHRvbik7XG5cbiAgICB0aGlzLmNhbGxSZXNldE5vcnRoXyA9IG9wdGlvbnMucmVzZXROb3J0aCA/IG9wdGlvbnMucmVzZXROb3J0aCA6IHVuZGVmaW5lZDtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmR1cmF0aW9uXyA9IG9wdGlvbnMuZHVyYXRpb24gIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZHVyYXRpb24gOiAyNTA7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuYXV0b0hpZGVfID0gb3B0aW9ucy5hdXRvSGlkZSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5hdXRvSGlkZSA6IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ8dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMucm90YXRpb25fID0gdW5kZWZpbmVkO1xuXG4gICAgaWYgKHRoaXMuYXV0b0hpZGVfKSB7XG4gICAgICB0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LmFkZChDTEFTU19ISURERU4pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGV2ZW50IFRoZSBldmVudCB0byBoYW5kbGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGhhbmRsZUNsaWNrXyhldmVudCkge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgaWYgKHRoaXMuY2FsbFJlc2V0Tm9ydGhfICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuY2FsbFJlc2V0Tm9ydGhfKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVzZXROb3J0aF8oKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHJlc2V0Tm9ydGhfKCkge1xuICAgIGNvbnN0IG1hcCA9IHRoaXMuZ2V0TWFwKCk7XG4gICAgY29uc3QgdmlldyA9IG1hcC5nZXRWaWV3KCk7XG4gICAgaWYgKCF2aWV3KSB7XG4gICAgICAvLyB0aGUgbWFwIGRvZXMgbm90IGhhdmUgYSB2aWV3LCBzbyB3ZSBjYW4ndCBhY3RcbiAgICAgIC8vIHVwb24gaXRcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgcm90YXRpb24gPSB2aWV3LmdldFJvdGF0aW9uKCk7XG4gICAgaWYgKHJvdGF0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICh0aGlzLmR1cmF0aW9uXyA+IDAgJiYgcm90YXRpb24gJSAoMiAqIE1hdGguUEkpICE9PSAwKSB7XG4gICAgICAgIHZpZXcuYW5pbWF0ZSh7XG4gICAgICAgICAgcm90YXRpb246IDAsXG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb25fLFxuICAgICAgICAgIGVhc2luZzogZWFzZU91dCxcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2aWV3LnNldFJvdGF0aW9uKDApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIHJvdGF0ZSBjb250cm9sIGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwRXZlbnQuanNcIikuZGVmYXVsdH0gbWFwRXZlbnQgTWFwIGV2ZW50LlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIHJlbmRlcihtYXBFdmVudCkge1xuICAgIGNvbnN0IGZyYW1lU3RhdGUgPSBtYXBFdmVudC5mcmFtZVN0YXRlO1xuICAgIGlmICghZnJhbWVTdGF0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCByb3RhdGlvbiA9IGZyYW1lU3RhdGUudmlld1N0YXRlLnJvdGF0aW9uO1xuICAgIGlmIChyb3RhdGlvbiAhPSB0aGlzLnJvdGF0aW9uXykge1xuICAgICAgY29uc3QgdHJhbnNmb3JtID0gJ3JvdGF0ZSgnICsgcm90YXRpb24gKyAncmFkKSc7XG4gICAgICBpZiAodGhpcy5hdXRvSGlkZV8pIHtcbiAgICAgICAgY29uc3QgY29udGFpbnMgPSB0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX0hJRERFTik7XG4gICAgICAgIGlmICghY29udGFpbnMgJiYgcm90YXRpb24gPT09IDApIHtcbiAgICAgICAgICB0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LmFkZChDTEFTU19ISURERU4pO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbnRhaW5zICYmIHJvdGF0aW9uICE9PSAwKSB7XG4gICAgICAgICAgdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfSElEREVOKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5sYWJlbF8uc3R5bGUudHJhbnNmb3JtID0gdHJhbnNmb3JtO1xuICAgIH1cbiAgICB0aGlzLnJvdGF0aW9uXyA9IHJvdGF0aW9uO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFJvdGF0ZTtcbiIsIi8qKlxuICogQG1vZHVsZSBvbC9jb250cm9sL1pvb21cbiAqL1xuaW1wb3J0IENvbnRyb2wgZnJvbSAnLi9Db250cm9sLmpzJztcbmltcG9ydCBFdmVudFR5cGUgZnJvbSAnLi4vZXZlbnRzL0V2ZW50VHlwZS5qcyc7XG5pbXBvcnQge0NMQVNTX0NPTlRST0wsIENMQVNTX1VOU0VMRUNUQUJMRX0gZnJvbSAnLi4vY3NzLmpzJztcbmltcG9ydCB7ZWFzZU91dH0gZnJvbSAnLi4vZWFzaW5nLmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2R1cmF0aW9uPTI1MF0gQW5pbWF0aW9uIGR1cmF0aW9uIGluIG1pbGxpc2Vjb25kcy5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbY2xhc3NOYW1lPSdvbC16b29tJ10gQ1NTIGNsYXNzIG5hbWUuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW3pvb21JbkNsYXNzTmFtZT1jbGFzc05hbWUgKyAnLWluJ10gQ1NTIGNsYXNzIG5hbWUgZm9yIHRoZSB6b29tLWluIGJ1dHRvbi5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbem9vbU91dENsYXNzTmFtZT1jbGFzc05hbWUgKyAnLW91dCddIENTUyBjbGFzcyBuYW1lIGZvciB0aGUgem9vbS1vdXQgYnV0dG9uLlxuICogQHByb3BlcnR5IHtzdHJpbmd8SFRNTEVsZW1lbnR9IFt6b29tSW5MYWJlbD0nKyddIFRleHQgbGFiZWwgdG8gdXNlIGZvciB0aGUgem9vbS1pblxuICogYnV0dG9uLiBJbnN0ZWFkIG9mIHRleHQsIGFsc28gYW4gZWxlbWVudCAoZS5nLiBhIGBzcGFuYCBlbGVtZW50KSBjYW4gYmUgdXNlZC5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfEhUTUxFbGVtZW50fSBbem9vbU91dExhYmVsPSfigJMnXSBUZXh0IGxhYmVsIHRvIHVzZSBmb3IgdGhlIHpvb20tb3V0IGJ1dHRvbi5cbiAqIEluc3RlYWQgb2YgdGV4dCwgYWxzbyBhbiBlbGVtZW50IChlLmcuIGEgYHNwYW5gIGVsZW1lbnQpIGNhbiBiZSB1c2VkLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFt6b29tSW5UaXBMYWJlbD0nWm9vbSBpbiddIFRleHQgbGFiZWwgdG8gdXNlIGZvciB0aGUgYnV0dG9uIHRpcC5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbem9vbU91dFRpcExhYmVsPSdab29tIG91dCddIFRleHQgbGFiZWwgdG8gdXNlIGZvciB0aGUgYnV0dG9uIHRpcC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbZGVsdGE9MV0gVGhlIHpvb20gZGVsdGEgYXBwbGllZCBvbiBlYWNoIGNsaWNrLlxuICogQHByb3BlcnR5IHtIVE1MRWxlbWVudHxzdHJpbmd9IFt0YXJnZXRdIFNwZWNpZnkgYSB0YXJnZXQgaWYgeW91IHdhbnQgdGhlIGNvbnRyb2wgdG8gYmVcbiAqIHJlbmRlcmVkIG91dHNpZGUgb2YgdGhlIG1hcCdzIHZpZXdwb3J0LlxuICovXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQSBjb250cm9sIHdpdGggMiBidXR0b25zLCBvbmUgZm9yIHpvb20gaW4gYW5kIG9uZSBmb3Igem9vbSBvdXQuXG4gKiBUaGlzIGNvbnRyb2wgaXMgb25lIG9mIHRoZSBkZWZhdWx0IGNvbnRyb2xzIG9mIGEgbWFwLiBUbyBzdHlsZSB0aGlzIGNvbnRyb2xcbiAqIHVzZSBjc3Mgc2VsZWN0b3JzIGAub2wtem9vbS1pbmAgYW5kIGAub2wtem9vbS1vdXRgLlxuICpcbiAqIEBhcGlcbiAqL1xuY2xhc3MgWm9vbSBleHRlbmRzIENvbnRyb2wge1xuICAvKipcbiAgICogQHBhcmFtIHtPcHRpb25zfSBbb3B0aW9uc10gWm9vbSBvcHRpb25zLlxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zID8gb3B0aW9ucyA6IHt9O1xuXG4gICAgc3VwZXIoe1xuICAgICAgZWxlbWVudDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JyksXG4gICAgICB0YXJnZXQ6IG9wdGlvbnMudGFyZ2V0LFxuICAgIH0pO1xuXG4gICAgY29uc3QgY2xhc3NOYW1lID1cbiAgICAgIG9wdGlvbnMuY2xhc3NOYW1lICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmNsYXNzTmFtZSA6ICdvbC16b29tJztcblxuICAgIGNvbnN0IGRlbHRhID0gb3B0aW9ucy5kZWx0YSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5kZWx0YSA6IDE7XG5cbiAgICBjb25zdCB6b29tSW5DbGFzc05hbWUgPVxuICAgICAgb3B0aW9ucy56b29tSW5DbGFzc05hbWUgIT09IHVuZGVmaW5lZFxuICAgICAgICA/IG9wdGlvbnMuem9vbUluQ2xhc3NOYW1lXG4gICAgICAgIDogY2xhc3NOYW1lICsgJy1pbic7XG5cbiAgICBjb25zdCB6b29tT3V0Q2xhc3NOYW1lID1cbiAgICAgIG9wdGlvbnMuem9vbU91dENsYXNzTmFtZSAhPT0gdW5kZWZpbmVkXG4gICAgICAgID8gb3B0aW9ucy56b29tT3V0Q2xhc3NOYW1lXG4gICAgICAgIDogY2xhc3NOYW1lICsgJy1vdXQnO1xuXG4gICAgY29uc3Qgem9vbUluTGFiZWwgPVxuICAgICAgb3B0aW9ucy56b29tSW5MYWJlbCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy56b29tSW5MYWJlbCA6ICcrJztcbiAgICBjb25zdCB6b29tT3V0TGFiZWwgPVxuICAgICAgb3B0aW9ucy56b29tT3V0TGFiZWwgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuem9vbU91dExhYmVsIDogJ1xcdTIwMTMnO1xuXG4gICAgY29uc3Qgem9vbUluVGlwTGFiZWwgPVxuICAgICAgb3B0aW9ucy56b29tSW5UaXBMYWJlbCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy56b29tSW5UaXBMYWJlbCA6ICdab29tIGluJztcbiAgICBjb25zdCB6b29tT3V0VGlwTGFiZWwgPVxuICAgICAgb3B0aW9ucy56b29tT3V0VGlwTGFiZWwgIT09IHVuZGVmaW5lZFxuICAgICAgICA/IG9wdGlvbnMuem9vbU91dFRpcExhYmVsXG4gICAgICAgIDogJ1pvb20gb3V0JztcblxuICAgIGNvbnN0IGluRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpO1xuICAgIGluRWxlbWVudC5jbGFzc05hbWUgPSB6b29tSW5DbGFzc05hbWU7XG4gICAgaW5FbGVtZW50LnNldEF0dHJpYnV0ZSgndHlwZScsICdidXR0b24nKTtcbiAgICBpbkVsZW1lbnQudGl0bGUgPSB6b29tSW5UaXBMYWJlbDtcbiAgICBpbkVsZW1lbnQuYXBwZW5kQ2hpbGQoXG4gICAgICB0eXBlb2Ygem9vbUluTGFiZWwgPT09ICdzdHJpbmcnXG4gICAgICAgID8gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoem9vbUluTGFiZWwpXG4gICAgICAgIDogem9vbUluTGFiZWxcbiAgICApO1xuXG4gICAgaW5FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICBFdmVudFR5cGUuQ0xJQ0ssXG4gICAgICB0aGlzLmhhbmRsZUNsaWNrXy5iaW5kKHRoaXMsIGRlbHRhKSxcbiAgICAgIGZhbHNlXG4gICAgKTtcblxuICAgIGNvbnN0IG91dEVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcbiAgICBvdXRFbGVtZW50LmNsYXNzTmFtZSA9IHpvb21PdXRDbGFzc05hbWU7XG4gICAgb3V0RWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAnYnV0dG9uJyk7XG4gICAgb3V0RWxlbWVudC50aXRsZSA9IHpvb21PdXRUaXBMYWJlbDtcbiAgICBvdXRFbGVtZW50LmFwcGVuZENoaWxkKFxuICAgICAgdHlwZW9mIHpvb21PdXRMYWJlbCA9PT0gJ3N0cmluZydcbiAgICAgICAgPyBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh6b29tT3V0TGFiZWwpXG4gICAgICAgIDogem9vbU91dExhYmVsXG4gICAgKTtcblxuICAgIG91dEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgIEV2ZW50VHlwZS5DTElDSyxcbiAgICAgIHRoaXMuaGFuZGxlQ2xpY2tfLmJpbmQodGhpcywgLWRlbHRhKSxcbiAgICAgIGZhbHNlXG4gICAgKTtcblxuICAgIGNvbnN0IGNzc0NsYXNzZXMgPVxuICAgICAgY2xhc3NOYW1lICsgJyAnICsgQ0xBU1NfVU5TRUxFQ1RBQkxFICsgJyAnICsgQ0xBU1NfQ09OVFJPTDtcbiAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5lbGVtZW50O1xuICAgIGVsZW1lbnQuY2xhc3NOYW1lID0gY3NzQ2xhc3NlcztcbiAgICBlbGVtZW50LmFwcGVuZENoaWxkKGluRWxlbWVudCk7XG4gICAgZWxlbWVudC5hcHBlbmRDaGlsZChvdXRFbGVtZW50KTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmR1cmF0aW9uXyA9IG9wdGlvbnMuZHVyYXRpb24gIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZHVyYXRpb24gOiAyNTA7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IGRlbHRhIFpvb20gZGVsdGEuXG4gICAqIEBwYXJhbSB7TW91c2VFdmVudH0gZXZlbnQgVGhlIGV2ZW50IHRvIGhhbmRsZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaGFuZGxlQ2xpY2tfKGRlbHRhLCBldmVudCkge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgdGhpcy56b29tQnlEZWx0YV8oZGVsdGEpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkZWx0YSBab29tIGRlbHRhLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgem9vbUJ5RGVsdGFfKGRlbHRhKSB7XG4gICAgY29uc3QgbWFwID0gdGhpcy5nZXRNYXAoKTtcbiAgICBjb25zdCB2aWV3ID0gbWFwLmdldFZpZXcoKTtcbiAgICBpZiAoIXZpZXcpIHtcbiAgICAgIC8vIHRoZSBtYXAgZG9lcyBub3QgaGF2ZSBhIHZpZXcsIHNvIHdlIGNhbid0IGFjdFxuICAgICAgLy8gdXBvbiBpdFxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjdXJyZW50Wm9vbSA9IHZpZXcuZ2V0Wm9vbSgpO1xuICAgIGlmIChjdXJyZW50Wm9vbSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zdCBuZXdab29tID0gdmlldy5nZXRDb25zdHJhaW5lZFpvb20oY3VycmVudFpvb20gKyBkZWx0YSk7XG4gICAgICBpZiAodGhpcy5kdXJhdGlvbl8gPiAwKSB7XG4gICAgICAgIGlmICh2aWV3LmdldEFuaW1hdGluZygpKSB7XG4gICAgICAgICAgdmlldy5jYW5jZWxBbmltYXRpb25zKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmlldy5hbmltYXRlKHtcbiAgICAgICAgICB6b29tOiBuZXdab29tLFxuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uXyxcbiAgICAgICAgICBlYXNpbmc6IGVhc2VPdXQsXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmlldy5zZXRab29tKG5ld1pvb20pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBab29tO1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2NvbnRyb2wvZGVmYXVsdHNcbiAqL1xuaW1wb3J0IEF0dHJpYnV0aW9uIGZyb20gJy4vQXR0cmlidXRpb24uanMnO1xuaW1wb3J0IENvbGxlY3Rpb24gZnJvbSAnLi4vQ29sbGVjdGlvbi5qcyc7XG5pbXBvcnQgUm90YXRlIGZyb20gJy4vUm90YXRlLmpzJztcbmltcG9ydCBab29tIGZyb20gJy4vWm9vbS5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gRGVmYXVsdHNPcHRpb25zXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFthdHRyaWJ1dGlvbj10cnVlXSBJbmNsdWRlXG4gKiB7QGxpbmsgbW9kdWxlOm9sL2NvbnRyb2wvQXR0cmlidXRpb25+QXR0cmlidXRpb259LlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL0F0dHJpYnV0aW9uLmpzXCIpLk9wdGlvbnN9IFthdHRyaWJ1dGlvbk9wdGlvbnNdXG4gKiBPcHRpb25zIGZvciB7QGxpbmsgbW9kdWxlOm9sL2NvbnRyb2wvQXR0cmlidXRpb25+QXR0cmlidXRpb259LlxuICogQHByb3BlcnR5IHtib29sZWFufSBbcm90YXRlPXRydWVdIEluY2x1ZGVcbiAqIHtAbGluayBtb2R1bGU6b2wvY29udHJvbC9Sb3RhdGV+Um90YXRlfS5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi9Sb3RhdGUuanNcIikuT3B0aW9uc30gW3JvdGF0ZU9wdGlvbnNdIE9wdGlvbnNcbiAqIGZvciB7QGxpbmsgbW9kdWxlOm9sL2NvbnRyb2wvUm90YXRlflJvdGF0ZX0uXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFt6b29tXSBJbmNsdWRlIHtAbGluayBtb2R1bGU6b2wvY29udHJvbC9ab29tflpvb219LlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL1pvb20uanNcIikuT3B0aW9uc30gW3pvb21PcHRpb25zXSBPcHRpb25zIGZvclxuICoge0BsaW5rIG1vZHVsZTpvbC9jb250cm9sL1pvb21+Wm9vbX0uXG4gKi9cblxuLyoqXG4gKiBTZXQgb2YgY29udHJvbHMgaW5jbHVkZWQgaW4gbWFwcyBieSBkZWZhdWx0LiBVbmxlc3MgY29uZmlndXJlZCBvdGhlcndpc2UsXG4gKiB0aGlzIHJldHVybnMgYSBjb2xsZWN0aW9uIGNvbnRhaW5pbmcgYW4gaW5zdGFuY2Ugb2YgZWFjaCBvZiB0aGUgZm9sbG93aW5nXG4gKiBjb250cm9sczpcbiAqICoge0BsaW5rIG1vZHVsZTpvbC9jb250cm9sL1pvb21+Wm9vbX1cbiAqICoge0BsaW5rIG1vZHVsZTpvbC9jb250cm9sL1JvdGF0ZX5Sb3RhdGV9XG4gKiAqIHtAbGluayBtb2R1bGU6b2wvY29udHJvbC9BdHRyaWJ1dGlvbn5BdHRyaWJ1dGlvbn1cbiAqXG4gKiBAcGFyYW0ge0RlZmF1bHRzT3B0aW9uc30gW29wdGlvbnNdIE9wdGlvbnMgZm9yIHRoZSBkZWZhdWx0IGNvbnRyb2xzLlxuICogQHJldHVybiB7Q29sbGVjdGlvbjxpbXBvcnQoXCIuL0NvbnRyb2wuanNcIikuZGVmYXVsdD59IEEgY29sbGVjdGlvbiBvZiBjb250cm9sc1xuICogdG8gYmUgdXNlZCB3aXRoIHRoZSB7QGxpbmsgbW9kdWxlOm9sL01hcH5NYXB9IGNvbnN0cnVjdG9yJ3MgYGNvbnRyb2xzYCBvcHRpb24uXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0cyhvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zID8gb3B0aW9ucyA6IHt9O1xuXG4gIC8qKiBAdHlwZSB7Q29sbGVjdGlvbjxpbXBvcnQoXCIuL0NvbnRyb2wuanNcIikuZGVmYXVsdD59ICovXG4gIGNvbnN0IGNvbnRyb2xzID0gbmV3IENvbGxlY3Rpb24oKTtcblxuICBjb25zdCB6b29tQ29udHJvbCA9IG9wdGlvbnMuem9vbSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy56b29tIDogdHJ1ZTtcbiAgaWYgKHpvb21Db250cm9sKSB7XG4gICAgY29udHJvbHMucHVzaChuZXcgWm9vbShvcHRpb25zLnpvb21PcHRpb25zKSk7XG4gIH1cblxuICBjb25zdCByb3RhdGVDb250cm9sID0gb3B0aW9ucy5yb3RhdGUgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMucm90YXRlIDogdHJ1ZTtcbiAgaWYgKHJvdGF0ZUNvbnRyb2wpIHtcbiAgICBjb250cm9scy5wdXNoKG5ldyBSb3RhdGUob3B0aW9ucy5yb3RhdGVPcHRpb25zKSk7XG4gIH1cblxuICBjb25zdCBhdHRyaWJ1dGlvbkNvbnRyb2wgPVxuICAgIG9wdGlvbnMuYXR0cmlidXRpb24gIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuYXR0cmlidXRpb24gOiB0cnVlO1xuICBpZiAoYXR0cmlidXRpb25Db250cm9sKSB7XG4gICAgY29udHJvbHMucHVzaChuZXcgQXR0cmlidXRpb24ob3B0aW9ucy5hdHRyaWJ1dGlvbk9wdGlvbnMpKTtcbiAgfVxuXG4gIHJldHVybiBjb250cm9scztcbn1cbiIsIi8qKlxuICogQG1vZHVsZSBvbC9jb29yZGluYXRlXG4gKi9cbmltcG9ydCB7Z2V0V2lkdGh9IGZyb20gJy4vZXh0ZW50LmpzJztcbmltcG9ydCB7bW9kdWxvLCB0b0ZpeGVkfSBmcm9tICcuL21hdGguanMnO1xuaW1wb3J0IHtwYWROdW1iZXJ9IGZyb20gJy4vc3RyaW5nLmpzJztcblxuLyoqXG4gKiBBbiBhcnJheSBvZiBudW1iZXJzIHJlcHJlc2VudGluZyBhbiBgeHlgLCBgeHl6YCBvciBgeHl6bWAgY29vcmRpbmF0ZS5cbiAqIEV4YW1wbGU6IGBbMTYsIDQ4XWAuXG4gKiBAdHlwZWRlZiB7QXJyYXk8bnVtYmVyPn0gQ29vcmRpbmF0ZVxuICogQGFwaVxuICovXG5cbi8qKlxuICogQSBmdW5jdGlvbiB0aGF0IHRha2VzIGEge0BsaW5rIG1vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGV9IGFuZFxuICogdHJhbnNmb3JtcyBpdCBpbnRvIGEgYHtzdHJpbmd9YC5cbiAqXG4gKiBAdHlwZWRlZiB7ZnVuY3Rpb24oKENvb3JkaW5hdGV8dW5kZWZpbmVkKSk6IHN0cmluZ30gQ29vcmRpbmF0ZUZvcm1hdFxuICogQGFwaVxuICovXG5cbi8qKlxuICogQWRkIGBkZWx0YWAgdG8gYGNvb3JkaW5hdGVgLiBgY29vcmRpbmF0ZWAgaXMgbW9kaWZpZWQgaW4gcGxhY2UgYW5kIHJldHVybmVkXG4gKiBieSB0aGUgZnVuY3Rpb24uXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiAgICAgaW1wb3J0IHthZGR9IGZyb20gJ29sL2Nvb3JkaW5hdGUuanMnO1xuICpcbiAqICAgICBjb25zdCBjb29yZCA9IFs3Ljg1LCA0Ny45ODMzMzNdO1xuICogICAgIGFkZChjb29yZCwgWy0yLCA0XSk7XG4gKiAgICAgLy8gY29vcmQgaXMgbm93IFs1Ljg1LCA1MS45ODMzMzNdXG4gKlxuICogQHBhcmFtIHtDb29yZGluYXRlfSBjb29yZGluYXRlIENvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge0Nvb3JkaW5hdGV9IGRlbHRhIERlbHRhLlxuICogQHJldHVybiB7Q29vcmRpbmF0ZX0gVGhlIGlucHV0IGNvb3JkaW5hdGUgYWRqdXN0ZWQgYnlcbiAqIHRoZSBnaXZlbiBkZWx0YS5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZChjb29yZGluYXRlLCBkZWx0YSkge1xuICBjb29yZGluYXRlWzBdICs9ICtkZWx0YVswXTtcbiAgY29vcmRpbmF0ZVsxXSArPSArZGVsdGFbMV07XG4gIHJldHVybiBjb29yZGluYXRlO1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIHBvaW50IGNsb3Nlc3QgdG8gdGhlIHBhc3NlZCBjb29yZGluYXRlIG9uIHRoZSBwYXNzZWQgY2lyY2xlLlxuICpcbiAqIEBwYXJhbSB7Q29vcmRpbmF0ZX0gY29vcmRpbmF0ZSBUaGUgY29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9nZW9tL0NpcmNsZS5qc1wiKS5kZWZhdWx0fSBjaXJjbGUgVGhlIGNpcmNsZS5cbiAqIEByZXR1cm4ge0Nvb3JkaW5hdGV9IENsb3Nlc3QgcG9pbnQgb24gdGhlIGNpcmN1bWZlcmVuY2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbG9zZXN0T25DaXJjbGUoY29vcmRpbmF0ZSwgY2lyY2xlKSB7XG4gIGNvbnN0IHIgPSBjaXJjbGUuZ2V0UmFkaXVzKCk7XG4gIGNvbnN0IGNlbnRlciA9IGNpcmNsZS5nZXRDZW50ZXIoKTtcbiAgY29uc3QgeDAgPSBjZW50ZXJbMF07XG4gIGNvbnN0IHkwID0gY2VudGVyWzFdO1xuICBjb25zdCB4MSA9IGNvb3JkaW5hdGVbMF07XG4gIGNvbnN0IHkxID0gY29vcmRpbmF0ZVsxXTtcblxuICBsZXQgZHggPSB4MSAtIHgwO1xuICBjb25zdCBkeSA9IHkxIC0geTA7XG4gIGlmIChkeCA9PT0gMCAmJiBkeSA9PT0gMCkge1xuICAgIGR4ID0gMTtcbiAgfVxuICBjb25zdCBkID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcblxuICBjb25zdCB4ID0geDAgKyAociAqIGR4KSAvIGQ7XG4gIGNvbnN0IHkgPSB5MCArIChyICogZHkpIC8gZDtcblxuICByZXR1cm4gW3gsIHldO1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIHBvaW50IGNsb3Nlc3QgdG8gdGhlIHBhc3NlZCBjb29yZGluYXRlIG9uIHRoZSBwYXNzZWQgc2VnbWVudC5cbiAqIFRoaXMgaXMgdGhlIGZvb3Qgb2YgdGhlIHBlcnBlbmRpY3VsYXIgb2YgdGhlIGNvb3JkaW5hdGUgdG8gdGhlIHNlZ21lbnQgd2hlblxuICogdGhlIGZvb3QgaXMgb24gdGhlIHNlZ21lbnQsIG9yIHRoZSBjbG9zZXN0IHNlZ21lbnQgY29vcmRpbmF0ZSB3aGVuIHRoZSBmb290XG4gKiBpcyBvdXRzaWRlIHRoZSBzZWdtZW50LlxuICpcbiAqIEBwYXJhbSB7Q29vcmRpbmF0ZX0gY29vcmRpbmF0ZSBUaGUgY29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7QXJyYXk8Q29vcmRpbmF0ZT59IHNlZ21lbnQgVGhlIHR3byBjb29yZGluYXRlc1xuICogb2YgdGhlIHNlZ21lbnQuXG4gKiBAcmV0dXJuIHtDb29yZGluYXRlfSBUaGUgZm9vdCBvZiB0aGUgcGVycGVuZGljdWxhciBvZlxuICogdGhlIGNvb3JkaW5hdGUgdG8gdGhlIHNlZ21lbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbG9zZXN0T25TZWdtZW50KGNvb3JkaW5hdGUsIHNlZ21lbnQpIHtcbiAgY29uc3QgeDAgPSBjb29yZGluYXRlWzBdO1xuICBjb25zdCB5MCA9IGNvb3JkaW5hdGVbMV07XG4gIGNvbnN0IHN0YXJ0ID0gc2VnbWVudFswXTtcbiAgY29uc3QgZW5kID0gc2VnbWVudFsxXTtcbiAgY29uc3QgeDEgPSBzdGFydFswXTtcbiAgY29uc3QgeTEgPSBzdGFydFsxXTtcbiAgY29uc3QgeDIgPSBlbmRbMF07XG4gIGNvbnN0IHkyID0gZW5kWzFdO1xuICBjb25zdCBkeCA9IHgyIC0geDE7XG4gIGNvbnN0IGR5ID0geTIgLSB5MTtcbiAgY29uc3QgYWxvbmcgPVxuICAgIGR4ID09PSAwICYmIGR5ID09PSAwXG4gICAgICA/IDBcbiAgICAgIDogKGR4ICogKHgwIC0geDEpICsgZHkgKiAoeTAgLSB5MSkpIC8gKGR4ICogZHggKyBkeSAqIGR5IHx8IDApO1xuICBsZXQgeCwgeTtcbiAgaWYgKGFsb25nIDw9IDApIHtcbiAgICB4ID0geDE7XG4gICAgeSA9IHkxO1xuICB9IGVsc2UgaWYgKGFsb25nID49IDEpIHtcbiAgICB4ID0geDI7XG4gICAgeSA9IHkyO1xuICB9IGVsc2Uge1xuICAgIHggPSB4MSArIGFsb25nICogZHg7XG4gICAgeSA9IHkxICsgYWxvbmcgKiBkeTtcbiAgfVxuICByZXR1cm4gW3gsIHldO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSB7QGxpbmsgbW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZUZvcm1hdH0gZnVuY3Rpb24gdGhhdCBjYW4gYmVcbiAqIHVzZWQgdG8gZm9ybWF0XG4gKiBhIHtDb29yZGluYXRlfSB0byBhIHN0cmluZy5cbiAqXG4gKiBFeGFtcGxlIHdpdGhvdXQgc3BlY2lmeWluZyB0aGUgZnJhY3Rpb25hbCBkaWdpdHM6XG4gKlxuICogICAgIGltcG9ydCB7Y3JlYXRlU3RyaW5nWFl9IGZyb20gJ29sL2Nvb3JkaW5hdGUuanMnO1xuICpcbiAqICAgICBjb25zdCBjb29yZCA9IFs3Ljg1LCA0Ny45ODMzMzNdO1xuICogICAgIGNvbnN0IHN0cmluZ2lmeUZ1bmMgPSBjcmVhdGVTdHJpbmdYWSgpO1xuICogICAgIGNvbnN0IG91dCA9IHN0cmluZ2lmeUZ1bmMoY29vcmQpO1xuICogICAgIC8vIG91dCBpcyBub3cgJzgsIDQ4J1xuICpcbiAqIEV4YW1wbGUgd2l0aCBleHBsaWNpdGx5IHNwZWNpZnlpbmcgMiBmcmFjdGlvbmFsIGRpZ2l0czpcbiAqXG4gKiAgICAgaW1wb3J0IHtjcmVhdGVTdHJpbmdYWX0gZnJvbSAnb2wvY29vcmRpbmF0ZS5qcyc7XG4gKlxuICogICAgIGNvbnN0IGNvb3JkID0gWzcuODUsIDQ3Ljk4MzMzM107XG4gKiAgICAgY29uc3Qgc3RyaW5naWZ5RnVuYyA9IGNyZWF0ZVN0cmluZ1hZKDIpO1xuICogICAgIGNvbnN0IG91dCA9IHN0cmluZ2lmeUZ1bmMoY29vcmQpO1xuICogICAgIC8vIG91dCBpcyBub3cgJzcuODUsIDQ3Ljk4J1xuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBbZnJhY3Rpb25EaWdpdHNdIFRoZSBudW1iZXIgb2YgZGlnaXRzIHRvIGluY2x1ZGVcbiAqICAgIGFmdGVyIHRoZSBkZWNpbWFsIHBvaW50LiBEZWZhdWx0IGlzIGAwYC5cbiAqIEByZXR1cm4ge0Nvb3JkaW5hdGVGb3JtYXR9IENvb3JkaW5hdGUgZm9ybWF0LlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU3RyaW5nWFkoZnJhY3Rpb25EaWdpdHMpIHtcbiAgcmV0dXJuIChcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0Nvb3JkaW5hdGV9IGNvb3JkaW5hdGUgQ29vcmRpbmF0ZS5cbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFN0cmluZyBYWS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoY29vcmRpbmF0ZSkge1xuICAgICAgcmV0dXJuIHRvU3RyaW5nWFkoY29vcmRpbmF0ZSwgZnJhY3Rpb25EaWdpdHMpO1xuICAgIH1cbiAgKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gaGVtaXNwaGVyZXMgSGVtaXNwaGVyZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gZGVncmVlcyBEZWdyZWVzLlxuICogQHBhcmFtIHtudW1iZXJ9IFtmcmFjdGlvbkRpZ2l0c10gVGhlIG51bWJlciBvZiBkaWdpdHMgdG8gaW5jbHVkZVxuICogICAgYWZ0ZXIgdGhlIGRlY2ltYWwgcG9pbnQuIERlZmF1bHQgaXMgYDBgLlxuICogQHJldHVybiB7c3RyaW5nfSBTdHJpbmcuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWdyZWVzVG9TdHJpbmdIRE1TKGhlbWlzcGhlcmVzLCBkZWdyZWVzLCBmcmFjdGlvbkRpZ2l0cykge1xuICBjb25zdCBub3JtYWxpemVkRGVncmVlcyA9IG1vZHVsbyhkZWdyZWVzICsgMTgwLCAzNjApIC0gMTgwO1xuICBjb25zdCB4ID0gTWF0aC5hYnMoMzYwMCAqIG5vcm1hbGl6ZWREZWdyZWVzKTtcbiAgY29uc3QgZGVjaW1hbHMgPSBmcmFjdGlvbkRpZ2l0cyB8fCAwO1xuXG4gIGxldCBkZWcgPSBNYXRoLmZsb29yKHggLyAzNjAwKTtcbiAgbGV0IG1pbiA9IE1hdGguZmxvb3IoKHggLSBkZWcgKiAzNjAwKSAvIDYwKTtcbiAgbGV0IHNlYyA9IHRvRml4ZWQoeCAtIGRlZyAqIDM2MDAgLSBtaW4gKiA2MCwgZGVjaW1hbHMpO1xuXG4gIGlmIChzZWMgPj0gNjApIHtcbiAgICBzZWMgPSAwO1xuICAgIG1pbiArPSAxO1xuICB9XG5cbiAgaWYgKG1pbiA+PSA2MCkge1xuICAgIG1pbiA9IDA7XG4gICAgZGVnICs9IDE7XG4gIH1cblxuICBsZXQgaGRtcyA9IGRlZyArICdcXHUwMGIwJztcbiAgaWYgKG1pbiAhPT0gMCB8fCBzZWMgIT09IDApIHtcbiAgICBoZG1zICs9ICcgJyArIHBhZE51bWJlcihtaW4sIDIpICsgJ1xcdTIwMzInO1xuICB9XG4gIGlmIChzZWMgIT09IDApIHtcbiAgICBoZG1zICs9ICcgJyArIHBhZE51bWJlcihzZWMsIDIsIGRlY2ltYWxzKSArICdcXHUyMDMzJztcbiAgfVxuICBpZiAobm9ybWFsaXplZERlZ3JlZXMgIT09IDApIHtcbiAgICBoZG1zICs9ICcgJyArIGhlbWlzcGhlcmVzLmNoYXJBdChub3JtYWxpemVkRGVncmVlcyA8IDAgPyAxIDogMCk7XG4gIH1cblxuICByZXR1cm4gaGRtcztcbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSBnaXZlbiB7QGxpbmsgbW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZX0gdG8gYSBzdHJpbmdcbiAqIHVzaW5nIHRoZSBnaXZlbiBzdHJpbmcgdGVtcGxhdGUuIFRoZSBzdHJpbmdzIGB7eH1gIGFuZCBge3l9YCBpbiB0aGUgdGVtcGxhdGVcbiAqIHdpbGwgYmUgcmVwbGFjZWQgd2l0aCB0aGUgZmlyc3QgYW5kIHNlY29uZCBjb29yZGluYXRlIHZhbHVlcyByZXNwZWN0aXZlbHkuXG4gKlxuICogRXhhbXBsZSB3aXRob3V0IHNwZWNpZnlpbmcgdGhlIGZyYWN0aW9uYWwgZGlnaXRzOlxuICpcbiAqICAgICBpbXBvcnQge2Zvcm1hdH0gZnJvbSAnb2wvY29vcmRpbmF0ZS5qcyc7XG4gKlxuICogICAgIGNvbnN0IGNvb3JkID0gWzcuODUsIDQ3Ljk4MzMzM107XG4gKiAgICAgY29uc3QgdGVtcGxhdGUgPSAnQ29vcmRpbmF0ZSBpcyAoe3h9fHt5fSkuJztcbiAqICAgICBjb25zdCBvdXQgPSBmb3JtYXQoY29vcmQsIHRlbXBsYXRlKTtcbiAqICAgICAvLyBvdXQgaXMgbm93ICdDb29yZGluYXRlIGlzICg4fDQ4KS4nXG4gKlxuICogRXhhbXBsZSBleHBsaWNpdGx5IHNwZWNpZnlpbmcgdGhlIGZyYWN0aW9uYWwgZGlnaXRzOlxuICpcbiAqICAgICBpbXBvcnQge2Zvcm1hdH0gZnJvbSAnb2wvY29vcmRpbmF0ZS5qcyc7XG4gKlxuICogICAgIGNvbnN0IGNvb3JkID0gWzcuODUsIDQ3Ljk4MzMzM107XG4gKiAgICAgY29uc3QgdGVtcGxhdGUgPSAnQ29vcmRpbmF0ZSBpcyAoe3h9fHt5fSkuJztcbiAqICAgICBjb25zdCBvdXQgPSBmb3JtYXQoY29vcmQsIHRlbXBsYXRlLCAyKTtcbiAqICAgICAvLyBvdXQgaXMgbm93ICdDb29yZGluYXRlIGlzICg3Ljg1fDQ3Ljk4KS4nXG4gKlxuICogQHBhcmFtIHtDb29yZGluYXRlfSBjb29yZGluYXRlIENvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGVtcGxhdGUgQSB0ZW1wbGF0ZSBzdHJpbmcgd2l0aCBge3h9YCBhbmQgYHt5fWAgcGxhY2Vob2xkZXJzXG4gKiAgICAgdGhhdCB3aWxsIGJlIHJlcGxhY2VkIGJ5IGZpcnN0IGFuZCBzZWNvbmQgY29vcmRpbmF0ZSB2YWx1ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gW2ZyYWN0aW9uRGlnaXRzXSBUaGUgbnVtYmVyIG9mIGRpZ2l0cyB0byBpbmNsdWRlXG4gKiAgICBhZnRlciB0aGUgZGVjaW1hbCBwb2ludC4gRGVmYXVsdCBpcyBgMGAuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEZvcm1hdHRlZCBjb29yZGluYXRlLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0KGNvb3JkaW5hdGUsIHRlbXBsYXRlLCBmcmFjdGlvbkRpZ2l0cykge1xuICBpZiAoY29vcmRpbmF0ZSkge1xuICAgIHJldHVybiB0ZW1wbGF0ZVxuICAgICAgLnJlcGxhY2UoJ3t4fScsIGNvb3JkaW5hdGVbMF0udG9GaXhlZChmcmFjdGlvbkRpZ2l0cykpXG4gICAgICAucmVwbGFjZSgne3l9JywgY29vcmRpbmF0ZVsxXS50b0ZpeGVkKGZyYWN0aW9uRGlnaXRzKSk7XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7Q29vcmRpbmF0ZX0gY29vcmRpbmF0ZTEgRmlyc3QgY29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7Q29vcmRpbmF0ZX0gY29vcmRpbmF0ZTIgU2Vjb25kIGNvb3JkaW5hdGUuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUaGUgdHdvIGNvb3JkaW5hdGVzIGFyZSBlcXVhbC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVxdWFscyhjb29yZGluYXRlMSwgY29vcmRpbmF0ZTIpIHtcbiAgbGV0IGVxdWFscyA9IHRydWU7XG4gIGZvciAobGV0IGkgPSBjb29yZGluYXRlMS5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgIGlmIChjb29yZGluYXRlMVtpXSAhPSBjb29yZGluYXRlMltpXSkge1xuICAgICAgZXF1YWxzID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGVxdWFscztcbn1cblxuLyoqXG4gKiBSb3RhdGUgYGNvb3JkaW5hdGVgIGJ5IGBhbmdsZWAuIGBjb29yZGluYXRlYCBpcyBtb2RpZmllZCBpbiBwbGFjZSBhbmRcbiAqIHJldHVybmVkIGJ5IHRoZSBmdW5jdGlvbi5cbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqICAgICBpbXBvcnQge3JvdGF0ZX0gZnJvbSAnb2wvY29vcmRpbmF0ZS5qcyc7XG4gKlxuICogICAgIGNvbnN0IGNvb3JkID0gWzcuODUsIDQ3Ljk4MzMzM107XG4gKiAgICAgY29uc3Qgcm90YXRlUmFkaWFucyA9IE1hdGguUEkgLyAyOyAvLyA5MCBkZWdyZWVzXG4gKiAgICAgcm90YXRlKGNvb3JkLCByb3RhdGVSYWRpYW5zKTtcbiAqICAgICAvLyBjb29yZCBpcyBub3cgWy00Ny45ODMzMzMsIDcuODVdXG4gKlxuICogQHBhcmFtIHtDb29yZGluYXRlfSBjb29yZGluYXRlIENvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge251bWJlcn0gYW5nbGUgQW5nbGUgaW4gcmFkaWFuLlxuICogQHJldHVybiB7Q29vcmRpbmF0ZX0gQ29vcmRpbmF0ZS5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJvdGF0ZShjb29yZGluYXRlLCBhbmdsZSkge1xuICBjb25zdCBjb3NBbmdsZSA9IE1hdGguY29zKGFuZ2xlKTtcbiAgY29uc3Qgc2luQW5nbGUgPSBNYXRoLnNpbihhbmdsZSk7XG4gIGNvbnN0IHggPSBjb29yZGluYXRlWzBdICogY29zQW5nbGUgLSBjb29yZGluYXRlWzFdICogc2luQW5nbGU7XG4gIGNvbnN0IHkgPSBjb29yZGluYXRlWzFdICogY29zQW5nbGUgKyBjb29yZGluYXRlWzBdICogc2luQW5nbGU7XG4gIGNvb3JkaW5hdGVbMF0gPSB4O1xuICBjb29yZGluYXRlWzFdID0geTtcbiAgcmV0dXJuIGNvb3JkaW5hdGU7XG59XG5cbi8qKlxuICogU2NhbGUgYGNvb3JkaW5hdGVgIGJ5IGBzY2FsZWAuIGBjb29yZGluYXRlYCBpcyBtb2RpZmllZCBpbiBwbGFjZSBhbmQgcmV0dXJuZWRcbiAqIGJ5IHRoZSBmdW5jdGlvbi5cbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqICAgICBpbXBvcnQge3NjYWxlIGFzIHNjYWxlQ29vcmRpbmF0ZX0gZnJvbSAnb2wvY29vcmRpbmF0ZS5qcyc7XG4gKlxuICogICAgIGNvbnN0IGNvb3JkID0gWzcuODUsIDQ3Ljk4MzMzM107XG4gKiAgICAgY29uc3Qgc2NhbGUgPSAxLjI7XG4gKiAgICAgc2NhbGVDb29yZGluYXRlKGNvb3JkLCBzY2FsZSk7XG4gKiAgICAgLy8gY29vcmQgaXMgbm93IFs5LjQyLCA1Ny41Nzk5OTk2XVxuICpcbiAqIEBwYXJhbSB7Q29vcmRpbmF0ZX0gY29vcmRpbmF0ZSBDb29yZGluYXRlLlxuICogQHBhcmFtIHtudW1iZXJ9IHNjYWxlIFNjYWxlIGZhY3Rvci5cbiAqIEByZXR1cm4ge0Nvb3JkaW5hdGV9IENvb3JkaW5hdGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzY2FsZShjb29yZGluYXRlLCBzY2FsZSkge1xuICBjb29yZGluYXRlWzBdICo9IHNjYWxlO1xuICBjb29yZGluYXRlWzFdICo9IHNjYWxlO1xuICByZXR1cm4gY29vcmRpbmF0ZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0Nvb3JkaW5hdGV9IGNvb3JkMSBGaXJzdCBjb29yZGluYXRlLlxuICogQHBhcmFtIHtDb29yZGluYXRlfSBjb29yZDIgU2Vjb25kIGNvb3JkaW5hdGUuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFNxdWFyZWQgZGlzdGFuY2UgYmV0d2VlbiBjb29yZDEgYW5kIGNvb3JkMi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNxdWFyZWREaXN0YW5jZShjb29yZDEsIGNvb3JkMikge1xuICBjb25zdCBkeCA9IGNvb3JkMVswXSAtIGNvb3JkMlswXTtcbiAgY29uc3QgZHkgPSBjb29yZDFbMV0gLSBjb29yZDJbMV07XG4gIHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0Nvb3JkaW5hdGV9IGNvb3JkMSBGaXJzdCBjb29yZGluYXRlLlxuICogQHBhcmFtIHtDb29yZGluYXRlfSBjb29yZDIgU2Vjb25kIGNvb3JkaW5hdGUuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IERpc3RhbmNlIGJldHdlZW4gY29vcmQxIGFuZCBjb29yZDIuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkaXN0YW5jZShjb29yZDEsIGNvb3JkMikge1xuICByZXR1cm4gTWF0aC5zcXJ0KHNxdWFyZWREaXN0YW5jZShjb29yZDEsIGNvb3JkMikpO1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZSB0aGUgc3F1YXJlZCBkaXN0YW5jZSBmcm9tIGEgY29vcmRpbmF0ZSB0byBhIGxpbmUgc2VnbWVudC5cbiAqXG4gKiBAcGFyYW0ge0Nvb3JkaW5hdGV9IGNvb3JkaW5hdGUgQ29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQuXG4gKiBAcGFyYW0ge0FycmF5PENvb3JkaW5hdGU+fSBzZWdtZW50IExpbmUgc2VnbWVudCAoMlxuICogY29vcmRpbmF0ZXMpLlxuICogQHJldHVybiB7bnVtYmVyfSBTcXVhcmVkIGRpc3RhbmNlIGZyb20gdGhlIHBvaW50IHRvIHRoZSBsaW5lIHNlZ21lbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzcXVhcmVkRGlzdGFuY2VUb1NlZ21lbnQoY29vcmRpbmF0ZSwgc2VnbWVudCkge1xuICByZXR1cm4gc3F1YXJlZERpc3RhbmNlKGNvb3JkaW5hdGUsIGNsb3Nlc3RPblNlZ21lbnQoY29vcmRpbmF0ZSwgc2VnbWVudCkpO1xufVxuXG4vKipcbiAqIEZvcm1hdCBhIGdlb2dyYXBoaWMgY29vcmRpbmF0ZSB3aXRoIHRoZSBoZW1pc3BoZXJlLCBkZWdyZWVzLCBtaW51dGVzLCBhbmRcbiAqIHNlY29uZHMuXG4gKlxuICogRXhhbXBsZSB3aXRob3V0IHNwZWNpZnlpbmcgZnJhY3Rpb25hbCBkaWdpdHM6XG4gKlxuICogICAgIGltcG9ydCB7dG9TdHJpbmdIRE1TfSBmcm9tICdvbC9jb29yZGluYXRlLmpzJztcbiAqXG4gKiAgICAgY29uc3QgY29vcmQgPSBbNy44NSwgNDcuOTgzMzMzXTtcbiAqICAgICBjb25zdCBvdXQgPSB0b1N0cmluZ0hETVMoY29vcmQpO1xuICogICAgIC8vIG91dCBpcyBub3cgJzQ3wrAgNTjigLIgNjDigLMgTiA3wrAgNTDigLIgNjDigLMgRSdcbiAqXG4gKiBFeGFtcGxlIGV4cGxpY2l0bHkgc3BlY2lmeWluZyAxIGZyYWN0aW9uYWwgZGlnaXQ6XG4gKlxuICogICAgIGltcG9ydCB7dG9TdHJpbmdIRE1TfSBmcm9tICdvbC9jb29yZGluYXRlLmpzJztcbiAqXG4gKiAgICAgY29uc3QgY29vcmQgPSBbNy44NSwgNDcuOTgzMzMzXTtcbiAqICAgICBjb25zdCBvdXQgPSB0b1N0cmluZ0hETVMoY29vcmQsIDEpO1xuICogICAgIC8vIG91dCBpcyBub3cgJzQ3wrAgNTjigLIgNjAuMOKAsyBOIDfCsCA1MOKAsiA2MC4w4oCzIEUnXG4gKlxuICogQHBhcmFtIHtDb29yZGluYXRlfSBjb29yZGluYXRlIENvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge251bWJlcn0gW2ZyYWN0aW9uRGlnaXRzXSBUaGUgbnVtYmVyIG9mIGRpZ2l0cyB0byBpbmNsdWRlXG4gKiAgICBhZnRlciB0aGUgZGVjaW1hbCBwb2ludC4gRGVmYXVsdCBpcyBgMGAuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEhlbWlzcGhlcmUsIGRlZ3JlZXMsIG1pbnV0ZXMgYW5kIHNlY29uZHMuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b1N0cmluZ0hETVMoY29vcmRpbmF0ZSwgZnJhY3Rpb25EaWdpdHMpIHtcbiAgaWYgKGNvb3JkaW5hdGUpIHtcbiAgICByZXR1cm4gKFxuICAgICAgZGVncmVlc1RvU3RyaW5nSERNUygnTlMnLCBjb29yZGluYXRlWzFdLCBmcmFjdGlvbkRpZ2l0cykgK1xuICAgICAgJyAnICtcbiAgICAgIGRlZ3JlZXNUb1N0cmluZ0hETVMoJ0VXJywgY29vcmRpbmF0ZVswXSwgZnJhY3Rpb25EaWdpdHMpXG4gICAgKTtcbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbi8qKlxuICogRm9ybWF0IGEgY29vcmRpbmF0ZSBhcyBhIGNvbW1hIGRlbGltaXRlZCBzdHJpbmcuXG4gKlxuICogRXhhbXBsZSB3aXRob3V0IHNwZWNpZnlpbmcgZnJhY3Rpb25hbCBkaWdpdHM6XG4gKlxuICogICAgIGltcG9ydCB7dG9TdHJpbmdYWX0gZnJvbSAnb2wvY29vcmRpbmF0ZS5qcyc7XG4gKlxuICogICAgIGNvbnN0IGNvb3JkID0gWzcuODUsIDQ3Ljk4MzMzM107XG4gKiAgICAgY29uc3Qgb3V0ID0gdG9TdHJpbmdYWShjb29yZCk7XG4gKiAgICAgLy8gb3V0IGlzIG5vdyAnOCwgNDgnXG4gKlxuICogRXhhbXBsZSBleHBsaWNpdGx5IHNwZWNpZnlpbmcgMSBmcmFjdGlvbmFsIGRpZ2l0OlxuICpcbiAqICAgICBpbXBvcnQge3RvU3RyaW5nWFl9IGZyb20gJ29sL2Nvb3JkaW5hdGUuanMnO1xuICpcbiAqICAgICBjb25zdCBjb29yZCA9IFs3Ljg1LCA0Ny45ODMzMzNdO1xuICogICAgIGNvbnN0IG91dCA9IHRvU3RyaW5nWFkoY29vcmQsIDEpO1xuICogICAgIC8vIG91dCBpcyBub3cgJzcuOCwgNDguMCdcbiAqXG4gKiBAcGFyYW0ge0Nvb3JkaW5hdGV9IGNvb3JkaW5hdGUgQ29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbZnJhY3Rpb25EaWdpdHNdIFRoZSBudW1iZXIgb2YgZGlnaXRzIHRvIGluY2x1ZGVcbiAqICAgIGFmdGVyIHRoZSBkZWNpbWFsIHBvaW50LiBEZWZhdWx0IGlzIGAwYC5cbiAqIEByZXR1cm4ge3N0cmluZ30gWFkuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b1N0cmluZ1hZKGNvb3JkaW5hdGUsIGZyYWN0aW9uRGlnaXRzKSB7XG4gIHJldHVybiBmb3JtYXQoY29vcmRpbmF0ZSwgJ3t4fSwge3l9JywgZnJhY3Rpb25EaWdpdHMpO1xufVxuXG4vKipcbiAqIE1vZGlmaWVzIHRoZSBwcm92aWRlZCBjb29yZGluYXRlIGluLXBsYWNlIHRvIGJlIHdpdGhpbiB0aGUgcmVhbCB3b3JsZFxuICogZXh0ZW50LiBUaGUgbG93ZXIgcHJvamVjdGlvbiBleHRlbnQgYm91bmRhcnkgaXMgaW5jbHVzaXZlLCB0aGUgdXBwZXIgb25lXG4gKiBleGNsdXNpdmUuXG4gKlxuICogQHBhcmFtIHtDb29yZGluYXRlfSBjb29yZGluYXRlIENvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vcHJvai9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR9IHByb2plY3Rpb24gUHJvamVjdGlvbi5cbiAqIEByZXR1cm4ge0Nvb3JkaW5hdGV9IFRoZSBjb29yZGluYXRlIHdpdGhpbiB0aGUgcmVhbCB3b3JsZCBleHRlbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB3cmFwWChjb29yZGluYXRlLCBwcm9qZWN0aW9uKSB7XG4gIGlmIChwcm9qZWN0aW9uLmNhbldyYXBYKCkpIHtcbiAgICBjb25zdCB3b3JsZFdpZHRoID0gZ2V0V2lkdGgocHJvamVjdGlvbi5nZXRFeHRlbnQoKSk7XG4gICAgY29uc3Qgd29ybGRzQXdheSA9IGdldFdvcmxkc0F3YXkoY29vcmRpbmF0ZSwgcHJvamVjdGlvbiwgd29ybGRXaWR0aCk7XG4gICAgaWYgKHdvcmxkc0F3YXkpIHtcbiAgICAgIGNvb3JkaW5hdGVbMF0gLT0gd29ybGRzQXdheSAqIHdvcmxkV2lkdGg7XG4gICAgfVxuICB9XG4gIHJldHVybiBjb29yZGluYXRlO1xufVxuLyoqXG4gKiBAcGFyYW0ge0Nvb3JkaW5hdGV9IGNvb3JkaW5hdGUgQ29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9wcm9qL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdH0gcHJvamVjdGlvbiBQcm9qZWN0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IFtzb3VyY2VFeHRlbnRXaWR0aF0gV2lkdGggb2YgdGhlIHNvdXJjZSBleHRlbnQuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IE9mZnNldCBpbiB3b3JsZCB3aWR0aHMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRXb3JsZHNBd2F5KGNvb3JkaW5hdGUsIHByb2plY3Rpb24sIHNvdXJjZUV4dGVudFdpZHRoKSB7XG4gIGNvbnN0IHByb2plY3Rpb25FeHRlbnQgPSBwcm9qZWN0aW9uLmdldEV4dGVudCgpO1xuICBsZXQgd29ybGRzQXdheSA9IDA7XG4gIGlmIChcbiAgICBwcm9qZWN0aW9uLmNhbldyYXBYKCkgJiZcbiAgICAoY29vcmRpbmF0ZVswXSA8IHByb2plY3Rpb25FeHRlbnRbMF0gfHwgY29vcmRpbmF0ZVswXSA+IHByb2plY3Rpb25FeHRlbnRbMl0pXG4gICkge1xuICAgIHNvdXJjZUV4dGVudFdpZHRoID0gc291cmNlRXh0ZW50V2lkdGggfHwgZ2V0V2lkdGgocHJvamVjdGlvbkV4dGVudCk7XG4gICAgd29ybGRzQXdheSA9IE1hdGguZmxvb3IoXG4gICAgICAoY29vcmRpbmF0ZVswXSAtIHByb2plY3Rpb25FeHRlbnRbMF0pIC8gc291cmNlRXh0ZW50V2lkdGhcbiAgICApO1xuICB9XG4gIHJldHVybiB3b3JsZHNBd2F5O1xufVxuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2Nzc1xuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gRm9udFBhcmFtZXRlcnNcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzdHlsZSBTdHlsZS5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB2YXJpYW50IFZhcmlhbnQuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gd2VpZ2h0IFdlaWdodC5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzaXplIFNpemUuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbGluZUhlaWdodCBMaW5lSGVpZ2h0LlxuICogQHByb3BlcnR5IHtzdHJpbmd9IGZhbWlseSBGYW1pbHkuXG4gKiBAcHJvcGVydHkge0FycmF5PHN0cmluZz59IGZhbWlsaWVzIEZhbWlsaWVzLlxuICovXG5cbi8qKlxuICogVGhlIENTUyBjbGFzcyBmb3IgaGlkZGVuIGZlYXR1cmUuXG4gKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG5leHBvcnQgY29uc3QgQ0xBU1NfSElEREVOID0gJ29sLWhpZGRlbic7XG5cbi8qKlxuICogVGhlIENTUyBjbGFzcyB0aGF0IHdlJ2xsIGdpdmUgdGhlIERPTSBlbGVtZW50cyB0byBoYXZlIHRoZW0gc2VsZWN0YWJsZS5cbiAqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBjb25zdCBDTEFTU19TRUxFQ1RBQkxFID0gJ29sLXNlbGVjdGFibGUnO1xuXG4vKipcbiAqIFRoZSBDU1MgY2xhc3MgdGhhdCB3ZSdsbCBnaXZlIHRoZSBET00gZWxlbWVudHMgdG8gaGF2ZSB0aGVtIHVuc2VsZWN0YWJsZS5cbiAqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBjb25zdCBDTEFTU19VTlNFTEVDVEFCTEUgPSAnb2wtdW5zZWxlY3RhYmxlJztcblxuLyoqXG4gKiBUaGUgQ1NTIGNsYXNzIGZvciB1bnN1cHBvcnRlZCBmZWF0dXJlLlxuICpcbiAqIEBjb25zdFxuICogQHR5cGUge3N0cmluZ31cbiAqL1xuZXhwb3J0IGNvbnN0IENMQVNTX1VOU1VQUE9SVEVEID0gJ29sLXVuc3VwcG9ydGVkJztcblxuLyoqXG4gKiBUaGUgQ1NTIGNsYXNzIGZvciBjb250cm9scy5cbiAqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBjb25zdCBDTEFTU19DT05UUk9MID0gJ29sLWNvbnRyb2wnO1xuXG4vKipcbiAqIFRoZSBDU1MgY2xhc3MgdGhhdCB3ZSdsbCBnaXZlIHRoZSBET00gZWxlbWVudHMgdGhhdCBhcmUgY29sbGFwc2VkLCBpLmUuXG4gKiB0byB0aG9zZSBlbGVtZW50cyB3aGljaCB1c3VhbGx5IGNhbiBiZSBleHBhbmRlZC5cbiAqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBjb25zdCBDTEFTU19DT0xMQVBTRUQgPSAnb2wtY29sbGFwc2VkJztcblxuLyoqXG4gKiBGcm9tIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzEwMTM1Njk3L3JlZ2V4LXRvLXBhcnNlLWFueS1jc3MtZm9udFxuICogQHR5cGUge1JlZ0V4cH1cbiAqL1xuY29uc3QgZm9udFJlZ0V4ID0gbmV3IFJlZ0V4cChcbiAgW1xuICAgICdeXFxcXHMqKD89KD86KD86Wy1hLXpdK1xcXFxzKil7MCwyfShpdGFsaWN8b2JsaXF1ZSkpPyknLFxuICAgICcoPz0oPzooPzpbLWEtel0rXFxcXHMqKXswLDJ9KHNtYWxsLWNhcHMpKT8pJyxcbiAgICAnKD89KD86KD86Wy1hLXpdK1xcXFxzKil7MCwyfShib2xkKD86ZXIpP3xsaWdodGVyfFsxLTldMDAgKSk/KScsXG4gICAgJyg/Oig/Om5vcm1hbHxcXFxcMXxcXFxcMnxcXFxcMylcXFxccyopezAsM30oKD86eHg/LSk/JyxcbiAgICAnKD86c21hbGx8bGFyZ2UpfG1lZGl1bXxzbWFsbGVyfGxhcmdlcnxbXFxcXC5cXFxcZF0rKD86XFxcXCV8aW58W2NlbV1tfGV4fHBbY3R4XSkpJyxcbiAgICAnKD86XFxcXHMqXFxcXC9cXFxccyoobm9ybWFsfFtcXFxcLlxcXFxkXSsoPzpcXFxcJXxpbnxbY2VtXW18ZXh8cFtjdHhdKT8pKScsXG4gICAgJz9cXFxccyooWy0sXFxcXFwiXFxcXFxcJ1xcXFxzYS16XSs/KVxcXFxzKiQnLFxuICBdLmpvaW4oJycpLFxuICAnaSdcbik7XG5jb25zdCBmb250UmVnRXhNYXRjaEluZGV4ID0gW1xuICAnc3R5bGUnLFxuICAndmFyaWFudCcsXG4gICd3ZWlnaHQnLFxuICAnc2l6ZScsXG4gICdsaW5lSGVpZ2h0JyxcbiAgJ2ZhbWlseScsXG5dO1xuXG4vKipcbiAqIEdldCB0aGUgbGlzdCBvZiBmb250IGZhbWlsaWVzIGZyb20gYSBmb250IHNwZWMuICBOb3RlIHRoYXQgdGhpcyBkb2Vzbid0IHdvcmtcbiAqIGZvciBmb250IGZhbWlsaWVzIHRoYXQgaGF2ZSBjb21tYXMgaW4gdGhlbS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBmb250U3BlYyBUaGUgQ1NTIGZvbnQgcHJvcGVydHkuXG4gKiBAcmV0dXJuIHtGb250UGFyYW1ldGVyc3xudWxsfSBUaGUgZm9udCBwYXJhbWV0ZXJzIChvciBudWxsIGlmIHRoZSBpbnB1dCBzcGVjIGlzIGludmFsaWQpLlxuICovXG5leHBvcnQgY29uc3QgZ2V0Rm9udFBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoZm9udFNwZWMpIHtcbiAgY29uc3QgbWF0Y2ggPSBmb250U3BlYy5tYXRjaChmb250UmVnRXgpO1xuICBpZiAoIW1hdGNoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3Qgc3R5bGUgPSAvKiogQHR5cGUge0ZvbnRQYXJhbWV0ZXJzfSAqLyAoe1xuICAgIGxpbmVIZWlnaHQ6ICdub3JtYWwnLFxuICAgIHNpemU6ICcxLjJlbScsXG4gICAgc3R5bGU6ICdub3JtYWwnLFxuICAgIHdlaWdodDogJ25vcm1hbCcsXG4gICAgdmFyaWFudDogJ25vcm1hbCcsXG4gIH0pO1xuICBmb3IgKGxldCBpID0gMCwgaWkgPSBmb250UmVnRXhNYXRjaEluZGV4Lmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICBjb25zdCB2YWx1ZSA9IG1hdGNoW2kgKyAxXTtcbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgc3R5bGVbZm9udFJlZ0V4TWF0Y2hJbmRleFtpXV0gPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgc3R5bGUuZmFtaWxpZXMgPSBzdHlsZS5mYW1pbHkuc3BsaXQoLyxcXHM/Lyk7XG4gIHJldHVybiBzdHlsZTtcbn07XG4iLCJpbXBvcnQge1dPUktFUl9PRkZTQ1JFRU5fQ0FOVkFTfSBmcm9tICcuL2hhcy5qcyc7XG5cbi8qKlxuICogQG1vZHVsZSBvbC9kb21cbiAqL1xuXG4vL0ZJWE1FIE1vdmUgdGhpcyBmdW5jdGlvbiB0byB0aGUgY2FudmFzIG1vZHVsZVxuLyoqXG4gKiBDcmVhdGUgYW4gaHRtbCBjYW52YXMgZWxlbWVudCBhbmQgcmV0dXJucyBpdHMgMmQgY29udGV4dC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbd2lkdGhdIENhbnZhcyB3aWR0aC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbaGVpZ2h0XSBDYW52YXMgaGVpZ2h0LlxuICogQHBhcmFtIHtBcnJheTxIVE1MQ2FudmFzRWxlbWVudD59IFtjYW52YXNQb29sXSBDYW52YXMgcG9vbCB0byB0YWtlIGV4aXN0aW5nIGNhbnZhcyBmcm9tLlxuICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkRTZXR0aW5nc30gW3NldHRpbmdzXSBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkRTZXR0aW5nc1xuICogQHJldHVybiB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBUaGUgY29udGV4dC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUNhbnZhc0NvbnRleHQyRCh3aWR0aCwgaGVpZ2h0LCBjYW52YXNQb29sLCBzZXR0aW5ncykge1xuICAvKiogQHR5cGUge0hUTUxDYW52YXNFbGVtZW50fE9mZnNjcmVlbkNhbnZhc30gKi9cbiAgbGV0IGNhbnZhcztcbiAgaWYgKGNhbnZhc1Bvb2wgJiYgY2FudmFzUG9vbC5sZW5ndGgpIHtcbiAgICBjYW52YXMgPSBjYW52YXNQb29sLnNoaWZ0KCk7XG4gIH0gZWxzZSBpZiAoV09SS0VSX09GRlNDUkVFTl9DQU5WQVMpIHtcbiAgICBjYW52YXMgPSBuZXcgT2Zmc2NyZWVuQ2FudmFzKHdpZHRoIHx8IDMwMCwgaGVpZ2h0IHx8IDMwMCk7XG4gIH0gZWxzZSB7XG4gICAgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gIH1cbiAgaWYgKHdpZHRoKSB7XG4gICAgY2FudmFzLndpZHRoID0gd2lkdGg7XG4gIH1cbiAgaWYgKGhlaWdodCkge1xuICAgIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG4gIH1cbiAgLy9GSVhNRSBBbGxvdyBPZmZzY3JlZW5DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQgYXMgcmV0dXJuIHR5cGVcbiAgcmV0dXJuIC8qKiBAdHlwZSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSAqLyAoXG4gICAgY2FudmFzLmdldENvbnRleHQoJzJkJywgc2V0dGluZ3MpXG4gICk7XG59XG5cbi8qKlxuICogUmVsZWFzZXMgY2FudmFzIG1lbW9yeSB0byBhdm9pZCBleGNlZWRpbmcgbWVtb3J5IGxpbWl0cyBpbiBTYWZhcmkuXG4gKiBTZWUgaHR0cHM6Ly9wcWluYS5ubC9ibG9nL3RvdGFsLWNhbnZhcy1tZW1vcnktdXNlLWV4Y2VlZHMtdGhlLW1heGltdW0tbGltaXQvXG4gKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY29udGV4dCBDb250ZXh0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVsZWFzZUNhbnZhcyhjb250ZXh0KSB7XG4gIGNvbnN0IGNhbnZhcyA9IGNvbnRleHQuY2FudmFzO1xuICBjYW52YXMud2lkdGggPSAxO1xuICBjYW52YXMuaGVpZ2h0ID0gMTtcbiAgY29udGV4dC5jbGVhclJlY3QoMCwgMCwgMSwgMSk7XG59XG5cbi8qKlxuICogR2V0IHRoZSBjdXJyZW50IGNvbXB1dGVkIHdpZHRoIGZvciB0aGUgZ2l2ZW4gZWxlbWVudCBpbmNsdWRpbmcgbWFyZ2luLFxuICogcGFkZGluZyBhbmQgYm9yZGVyLlxuICogRXF1aXZhbGVudCB0byBqUXVlcnkncyBgJChlbCkub3V0ZXJXaWR0aCh0cnVlKWAuXG4gKiBAcGFyYW0geyFIVE1MRWxlbWVudH0gZWxlbWVudCBFbGVtZW50LlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgd2lkdGguXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBvdXRlcldpZHRoKGVsZW1lbnQpIHtcbiAgbGV0IHdpZHRoID0gZWxlbWVudC5vZmZzZXRXaWR0aDtcbiAgY29uc3Qgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xuICB3aWR0aCArPSBwYXJzZUludChzdHlsZS5tYXJnaW5MZWZ0LCAxMCkgKyBwYXJzZUludChzdHlsZS5tYXJnaW5SaWdodCwgMTApO1xuXG4gIHJldHVybiB3aWR0aDtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGN1cnJlbnQgY29tcHV0ZWQgaGVpZ2h0IGZvciB0aGUgZ2l2ZW4gZWxlbWVudCBpbmNsdWRpbmcgbWFyZ2luLFxuICogcGFkZGluZyBhbmQgYm9yZGVyLlxuICogRXF1aXZhbGVudCB0byBqUXVlcnkncyBgJChlbCkub3V0ZXJIZWlnaHQodHJ1ZSlgLlxuICogQHBhcmFtIHshSFRNTEVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudC5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIGhlaWdodC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG91dGVySGVpZ2h0KGVsZW1lbnQpIHtcbiAgbGV0IGhlaWdodCA9IGVsZW1lbnQub2Zmc2V0SGVpZ2h0O1xuICBjb25zdCBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG4gIGhlaWdodCArPSBwYXJzZUludChzdHlsZS5tYXJnaW5Ub3AsIDEwKSArIHBhcnNlSW50KHN0eWxlLm1hcmdpbkJvdHRvbSwgMTApO1xuXG4gIHJldHVybiBoZWlnaHQ7XG59XG5cbi8qKlxuICogQHBhcmFtIHtOb2RlfSBuZXdOb2RlIE5vZGUgdG8gcmVwbGFjZSBvbGQgbm9kZVxuICogQHBhcmFtIHtOb2RlfSBvbGROb2RlIFRoZSBub2RlIHRvIGJlIHJlcGxhY2VkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXBsYWNlTm9kZShuZXdOb2RlLCBvbGROb2RlKSB7XG4gIGNvbnN0IHBhcmVudCA9IG9sZE5vZGUucGFyZW50Tm9kZTtcbiAgaWYgKHBhcmVudCkge1xuICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQobmV3Tm9kZSwgb2xkTm9kZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge05vZGV9IG5vZGUgVGhlIG5vZGUgdG8gcmVtb3ZlLlxuICogQHJldHVybiB7Tm9kZXxudWxsfSBUaGUgbm9kZSB0aGF0IHdhcyByZW1vdmVkIG9yIG51bGwuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVOb2RlKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUgJiYgbm9kZS5wYXJlbnROb2RlID8gbm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5vZGUpIDogbnVsbDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge05vZGV9IG5vZGUgVGhlIG5vZGUgdG8gcmVtb3ZlIHRoZSBjaGlsZHJlbiBmcm9tLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlQ2hpbGRyZW4obm9kZSkge1xuICB3aGlsZSAobm9kZS5sYXN0Q2hpbGQpIHtcbiAgICBub2RlLnJlbW92ZUNoaWxkKG5vZGUubGFzdENoaWxkKTtcbiAgfVxufVxuXG4vKipcbiAqIFRyYW5zZm9ybSB0aGUgY2hpbGRyZW4gb2YgYSBwYXJlbnQgbm9kZSBzbyB0aGV5IG1hdGNoIHRoZVxuICogcHJvdmlkZWQgbGlzdCBvZiBjaGlsZHJlbi4gIFRoaXMgZnVuY3Rpb24gYWltcyB0byBlZmZpY2llbnRseVxuICogcmVtb3ZlLCBhZGQsIGFuZCByZW9yZGVyIGNoaWxkIG5vZGVzIHdoaWxlIG1haW50YWluaW5nIGEgc2ltcGxlXG4gKiBpbXBsZW1lbnRhdGlvbiAoaXQgaXMgbm90IGd1YXJhbnRlZWQgdG8gbWluaW1pemUgRE9NIG9wZXJhdGlvbnMpLlxuICogQHBhcmFtIHtOb2RlfSBub2RlIFRoZSBwYXJlbnQgbm9kZSB3aG9zZSBjaGlsZHJlbiBuZWVkIHJld29ya2luZy5cbiAqIEBwYXJhbSB7QXJyYXk8Tm9kZT59IGNoaWxkcmVuIFRoZSBkZXNpcmVkIGNoaWxkcmVuLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVwbGFjZUNoaWxkcmVuKG5vZGUsIGNoaWxkcmVuKSB7XG4gIGNvbnN0IG9sZENoaWxkcmVuID0gbm9kZS5jaGlsZE5vZGVzO1xuXG4gIGZvciAobGV0IGkgPSAwOyB0cnVlOyArK2kpIHtcbiAgICBjb25zdCBvbGRDaGlsZCA9IG9sZENoaWxkcmVuW2ldO1xuICAgIGNvbnN0IG5ld0NoaWxkID0gY2hpbGRyZW5baV07XG5cbiAgICAvLyBjaGVjayBpZiBvdXIgd29yayBpcyBkb25lXG4gICAgaWYgKCFvbGRDaGlsZCAmJiAhbmV3Q2hpbGQpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIGNoZWNrIGlmIGNoaWxkcmVuIG1hdGNoXG4gICAgaWYgKG9sZENoaWxkID09PSBuZXdDaGlsZCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gY2hlY2sgaWYgYSBuZXcgY2hpbGQgbmVlZHMgdG8gYmUgYWRkZWRcbiAgICBpZiAoIW9sZENoaWxkKSB7XG4gICAgICBub2RlLmFwcGVuZENoaWxkKG5ld0NoaWxkKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIGNoZWNrIGlmIGFuIG9sZCBjaGlsZCBuZWVkcyB0byBiZSByZW1vdmVkXG4gICAgaWYgKCFuZXdDaGlsZCkge1xuICAgICAgbm9kZS5yZW1vdmVDaGlsZChvbGRDaGlsZCk7XG4gICAgICAtLWk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyByZW9yZGVyXG4gICAgbm9kZS5pbnNlcnRCZWZvcmUobmV3Q2hpbGQsIG9sZENoaWxkKTtcbiAgfVxufVxuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2Vhc2luZ1xuICovXG5cbi8qKlxuICogU3RhcnQgc2xvdyBhbmQgc3BlZWQgdXAuXG4gKiBAcGFyYW0ge251bWJlcn0gdCBJbnB1dCBiZXR3ZWVuIDAgYW5kIDEuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IE91dHB1dCBiZXR3ZWVuIDAgYW5kIDEuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlYXNlSW4odCkge1xuICByZXR1cm4gTWF0aC5wb3codCwgMyk7XG59XG5cbi8qKlxuICogU3RhcnQgZmFzdCBhbmQgc2xvdyBkb3duLlxuICogQHBhcmFtIHtudW1iZXJ9IHQgSW5wdXQgYmV0d2VlbiAwIGFuZCAxLlxuICogQHJldHVybiB7bnVtYmVyfSBPdXRwdXQgYmV0d2VlbiAwIGFuZCAxLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gZWFzZU91dCh0KSB7XG4gIHJldHVybiAxIC0gZWFzZUluKDEgLSB0KTtcbn1cblxuLyoqXG4gKiBTdGFydCBzbG93LCBzcGVlZCB1cCwgYW5kIHRoZW4gc2xvdyBkb3duIGFnYWluLlxuICogQHBhcmFtIHtudW1iZXJ9IHQgSW5wdXQgYmV0d2VlbiAwIGFuZCAxLlxuICogQHJldHVybiB7bnVtYmVyfSBPdXRwdXQgYmV0d2VlbiAwIGFuZCAxLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gaW5BbmRPdXQodCkge1xuICByZXR1cm4gMyAqIHQgKiB0IC0gMiAqIHQgKiB0ICogdDtcbn1cblxuLyoqXG4gKiBNYWludGFpbiBhIGNvbnN0YW50IHNwZWVkIG92ZXIgdGltZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB0IElucHV0IGJldHdlZW4gMCBhbmQgMS5cbiAqIEByZXR1cm4ge251bWJlcn0gT3V0cHV0IGJldHdlZW4gMCBhbmQgMS5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxpbmVhcih0KSB7XG4gIHJldHVybiB0O1xufVxuXG4vKipcbiAqIFN0YXJ0IHNsb3csIHNwZWVkIHVwLCBhbmQgYXQgdGhlIHZlcnkgZW5kIHNsb3cgZG93biBhZ2Fpbi4gIFRoaXMgaGFzIHRoZVxuICogc2FtZSBnZW5lcmFsIGJlaGF2aW9yIGFzIHtAbGluayBtb2R1bGU6b2wvZWFzaW5nLmluQW5kT3V0fSwgYnV0IHRoZSBmaW5hbFxuICogc2xvd2Rvd24gaXMgZGVsYXllZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB0IElucHV0IGJldHdlZW4gMCBhbmQgMS5cbiAqIEByZXR1cm4ge251bWJlcn0gT3V0cHV0IGJldHdlZW4gMCBhbmQgMS5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVwQW5kRG93bih0KSB7XG4gIGlmICh0IDwgMC41KSB7XG4gICAgcmV0dXJuIGluQW5kT3V0KDIgKiB0KTtcbiAgfVxuICByZXR1cm4gMSAtIGluQW5kT3V0KDIgKiAodCAtIDAuNSkpO1xufVxuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2V2ZW50c1xuICovXG5pbXBvcnQge2NsZWFyfSBmcm9tICcuL29iai5qcyc7XG5cbi8qKlxuICogS2V5IHRvIHVzZSB3aXRoIHtAbGluayBtb2R1bGU6b2wvT2JzZXJ2YWJsZS51bkJ5S2V5fS5cbiAqIEB0eXBlZGVmIHtPYmplY3R9IEV2ZW50c0tleVxuICogQHByb3BlcnR5IHtMaXN0ZW5lckZ1bmN0aW9ufSBsaXN0ZW5lciBMaXN0ZW5lci5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi9ldmVudHMvVGFyZ2V0LmpzXCIpLkV2ZW50VGFyZ2V0TGlrZX0gdGFyZ2V0IFRhcmdldC5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB0eXBlIFR5cGUuXG4gKiBAYXBpXG4gKi9cblxuLyoqXG4gKiBMaXN0ZW5lciBmdW5jdGlvbi4gVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgd2l0aCBhbiBldmVudCBvYmplY3QgYXMgYXJndW1lbnQuXG4gKiBXaGVuIHRoZSBmdW5jdGlvbiByZXR1cm5zIGBmYWxzZWAsIGV2ZW50IHByb3BhZ2F0aW9uIHdpbGwgc3RvcC5cbiAqXG4gKiBAdHlwZWRlZiB7ZnVuY3Rpb24oKEV2ZW50fGltcG9ydChcIi4vZXZlbnRzL0V2ZW50LmpzXCIpLmRlZmF1bHQpKTogKHZvaWR8Ym9vbGVhbil9IExpc3RlbmVyRnVuY3Rpb25cbiAqIEBhcGlcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IExpc3RlbmVyT2JqZWN0XG4gKiBAcHJvcGVydHkge0xpc3RlbmVyRnVuY3Rpb259IGhhbmRsZUV2ZW50IEhhbmRsZUV2ZW50IGxpc3RlbmVyIGZ1bmN0aW9uLlxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge0xpc3RlbmVyRnVuY3Rpb258TGlzdGVuZXJPYmplY3R9IExpc3RlbmVyXG4gKi9cblxuLyoqXG4gKiBSZWdpc3RlcnMgYW4gZXZlbnQgbGlzdGVuZXIgb24gYW4gZXZlbnQgdGFyZ2V0LiBJbnNwaXJlZCBieVxuICogaHR0cHM6Ly9nb29nbGUuZ2l0aHViLmlvL2Nsb3N1cmUtbGlicmFyeS9hcGkvc291cmNlL2Nsb3N1cmUvZ29vZy9ldmVudHMvZXZlbnRzLmpzLnNyYy5odG1sXG4gKlxuICogVGhpcyBmdW5jdGlvbiBlZmZpY2llbnRseSBiaW5kcyBhIGBsaXN0ZW5lcmAgdG8gYSBgdGhpc2Agb2JqZWN0LCBhbmQgcmV0dXJuc1xuICogYSBrZXkgZm9yIHVzZSB3aXRoIHtAbGluayBtb2R1bGU6b2wvZXZlbnRzLnVubGlzdGVuQnlLZXl9LlxuICpcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9ldmVudHMvVGFyZ2V0LmpzXCIpLkV2ZW50VGFyZ2V0TGlrZX0gdGFyZ2V0IEV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIEV2ZW50IHR5cGUuXG4gKiBAcGFyYW0ge0xpc3RlbmVyRnVuY3Rpb259IGxpc3RlbmVyIExpc3RlbmVyLlxuICogQHBhcmFtIHtPYmplY3R9IFt0aGlzQXJnXSBPYmplY3QgcmVmZXJlbmNlZCBieSB0aGUgYHRoaXNgIGtleXdvcmQgaW4gdGhlXG4gKiAgICAgbGlzdGVuZXIuIERlZmF1bHQgaXMgdGhlIGB0YXJnZXRgLlxuICogQHBhcmFtIHtib29sZWFufSBbb25jZV0gSWYgdHJ1ZSwgYWRkIHRoZSBsaXN0ZW5lciBhcyBvbmUtb2ZmIGxpc3RlbmVyLlxuICogQHJldHVybiB7RXZlbnRzS2V5fSBVbmlxdWUga2V5IGZvciB0aGUgbGlzdGVuZXIuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsaXN0ZW4odGFyZ2V0LCB0eXBlLCBsaXN0ZW5lciwgdGhpc0FyZywgb25jZSkge1xuICBpZiAodGhpc0FyZyAmJiB0aGlzQXJnICE9PSB0YXJnZXQpIHtcbiAgICBsaXN0ZW5lciA9IGxpc3RlbmVyLmJpbmQodGhpc0FyZyk7XG4gIH1cbiAgaWYgKG9uY2UpIHtcbiAgICBjb25zdCBvcmlnaW5hbExpc3RlbmVyID0gbGlzdGVuZXI7XG4gICAgbGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcik7XG4gICAgICBvcmlnaW5hbExpc3RlbmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfVxuICBjb25zdCBldmVudHNLZXkgPSB7XG4gICAgdGFyZ2V0OiB0YXJnZXQsXG4gICAgdHlwZTogdHlwZSxcbiAgICBsaXN0ZW5lcjogbGlzdGVuZXIsXG4gIH07XG4gIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKTtcbiAgcmV0dXJuIGV2ZW50c0tleTtcbn1cblxuLyoqXG4gKiBSZWdpc3RlcnMgYSBvbmUtb2ZmIGV2ZW50IGxpc3RlbmVyIG9uIGFuIGV2ZW50IHRhcmdldC4gSW5zcGlyZWQgYnlcbiAqIGh0dHBzOi8vZ29vZ2xlLmdpdGh1Yi5pby9jbG9zdXJlLWxpYnJhcnkvYXBpL3NvdXJjZS9jbG9zdXJlL2dvb2cvZXZlbnRzL2V2ZW50cy5qcy5zcmMuaHRtbFxuICpcbiAqIFRoaXMgZnVuY3Rpb24gZWZmaWNpZW50bHkgYmluZHMgYSBgbGlzdGVuZXJgIGFzIHNlbGYtdW5yZWdpc3RlcmluZyBsaXN0ZW5lclxuICogdG8gYSBgdGhpc2Agb2JqZWN0LCBhbmQgcmV0dXJucyBhIGtleSBmb3IgdXNlIHdpdGhcbiAqIHtAbGluayBtb2R1bGU6b2wvZXZlbnRzLnVubGlzdGVuQnlLZXl9IGluIGNhc2UgdGhlIGxpc3RlbmVyIG5lZWRzIHRvIGJlXG4gKiB1bnJlZ2lzdGVyZWQgYmVmb3JlIGl0IGlzIGNhbGxlZC5cbiAqXG4gKiBXaGVuIHtAbGluayBtb2R1bGU6b2wvZXZlbnRzLmxpc3Rlbn0gaXMgY2FsbGVkIHdpdGggdGhlIHNhbWUgYXJndW1lbnRzIGFmdGVyIHRoaXNcbiAqIGZ1bmN0aW9uLCB0aGUgc2VsZi11bnJlZ2lzdGVyaW5nIGxpc3RlbmVyIHdpbGwgYmUgdHVybmVkIGludG8gYSBwZXJtYW5lbnRcbiAqIGxpc3RlbmVyLlxuICpcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9ldmVudHMvVGFyZ2V0LmpzXCIpLkV2ZW50VGFyZ2V0TGlrZX0gdGFyZ2V0IEV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIEV2ZW50IHR5cGUuXG4gKiBAcGFyYW0ge0xpc3RlbmVyRnVuY3Rpb259IGxpc3RlbmVyIExpc3RlbmVyLlxuICogQHBhcmFtIHtPYmplY3R9IFt0aGlzQXJnXSBPYmplY3QgcmVmZXJlbmNlZCBieSB0aGUgYHRoaXNgIGtleXdvcmQgaW4gdGhlXG4gKiAgICAgbGlzdGVuZXIuIERlZmF1bHQgaXMgdGhlIGB0YXJnZXRgLlxuICogQHJldHVybiB7RXZlbnRzS2V5fSBLZXkgZm9yIHVubGlzdGVuQnlLZXkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsaXN0ZW5PbmNlKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIsIHRoaXNBcmcpIHtcbiAgcmV0dXJuIGxpc3Rlbih0YXJnZXQsIHR5cGUsIGxpc3RlbmVyLCB0aGlzQXJnLCB0cnVlKTtcbn1cblxuLyoqXG4gKiBVbnJlZ2lzdGVycyBldmVudCBsaXN0ZW5lcnMgb24gYW4gZXZlbnQgdGFyZ2V0LiBJbnNwaXJlZCBieVxuICogaHR0cHM6Ly9nb29nbGUuZ2l0aHViLmlvL2Nsb3N1cmUtbGlicmFyeS9hcGkvc291cmNlL2Nsb3N1cmUvZ29vZy9ldmVudHMvZXZlbnRzLmpzLnNyYy5odG1sXG4gKlxuICogVGhlIGFyZ3VtZW50IHBhc3NlZCB0byB0aGlzIGZ1bmN0aW9uIGlzIHRoZSBrZXkgcmV0dXJuZWQgZnJvbVxuICoge0BsaW5rIG1vZHVsZTpvbC9ldmVudHMubGlzdGVufSBvciB7QGxpbmsgbW9kdWxlOm9sL2V2ZW50cy5saXN0ZW5PbmNlfS5cbiAqXG4gKiBAcGFyYW0ge0V2ZW50c0tleX0ga2V5IFRoZSBrZXkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1bmxpc3RlbkJ5S2V5KGtleSkge1xuICBpZiAoa2V5ICYmIGtleS50YXJnZXQpIHtcbiAgICBrZXkudGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoa2V5LnR5cGUsIGtleS5saXN0ZW5lcik7XG4gICAgY2xlYXIoa2V5KTtcbiAgfVxufVxuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2V2ZW50cy9FdmVudFxuICovXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogU3RyaXBwZWQgZG93biBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgVzNDIERPTSBMZXZlbCAyIEV2ZW50IGludGVyZmFjZS5cbiAqIFNlZSBodHRwczovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTItRXZlbnRzL2V2ZW50cy5odG1sI0V2ZW50cy1pbnRlcmZhY2UuXG4gKlxuICogVGhpcyBpbXBsZW1lbnRhdGlvbiBvbmx5IHByb3ZpZGVzIGB0eXBlYCBhbmQgYHRhcmdldGAgcHJvcGVydGllcywgYW5kXG4gKiBgc3RvcFByb3BhZ2F0aW9uYCBhbmQgYHByZXZlbnREZWZhdWx0YCBtZXRob2RzLiBJdCBpcyBtZWFudCBhcyBiYXNlIGNsYXNzXG4gKiBmb3IgaGlnaGVyIGxldmVsIGV2ZW50cyBkZWZpbmVkIGluIHRoZSBsaWJyYXJ5LCBhbmQgd29ya3Mgd2l0aFxuICoge0BsaW5rIG1vZHVsZTpvbC9ldmVudHMvVGFyZ2V0flRhcmdldH0uXG4gKi9cbmNsYXNzIEJhc2VFdmVudCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBUeXBlLlxuICAgKi9cbiAgY29uc3RydWN0b3IodHlwZSkge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMucHJvcGFnYXRpb25TdG9wcGVkO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5kZWZhdWx0UHJldmVudGVkO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGV2ZW50IHR5cGUuXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAYXBpXG4gICAgICovXG4gICAgdGhpcy50eXBlID0gdHlwZTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBldmVudCB0YXJnZXQuXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKiBAYXBpXG4gICAgICovXG4gICAgdGhpcy50YXJnZXQgPSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFByZXZlbnQgZGVmYXVsdC4gVGhpcyBtZWFucyB0aGF0IG5vIGVtdWxhdGVkIGBjbGlja2AsIGBzaW5nbGVjbGlja2Agb3IgYGRvdWJsZWNsaWNrYCBldmVudHNcbiAgICogd2lsbCBiZSBmaXJlZC5cbiAgICogQGFwaVxuICAgKi9cbiAgcHJldmVudERlZmF1bHQoKSB7XG4gICAgdGhpcy5kZWZhdWx0UHJldmVudGVkID0gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdG9wIGV2ZW50IHByb3BhZ2F0aW9uLlxuICAgKiBAYXBpXG4gICAqL1xuICBzdG9wUHJvcGFnYXRpb24oKSB7XG4gICAgdGhpcy5wcm9wYWdhdGlvblN0b3BwZWQgPSB0cnVlO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtFdmVudHxpbXBvcnQoXCIuL0V2ZW50LmpzXCIpLmRlZmF1bHR9IGV2dCBFdmVudFxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RvcFByb3BhZ2F0aW9uKGV2dCkge1xuICBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtFdmVudHxpbXBvcnQoXCIuL0V2ZW50LmpzXCIpLmRlZmF1bHR9IGV2dCBFdmVudFxuICovXG5leHBvcnQgZnVuY3Rpb24gcHJldmVudERlZmF1bHQoZXZ0KSB7XG4gIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBCYXNlRXZlbnQ7XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvZXZlbnRzL0V2ZW50VHlwZVxuICovXG5cbi8qKlxuICogQGVudW0ge3N0cmluZ31cbiAqIEBjb25zdFxuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gIC8qKlxuICAgKiBHZW5lcmljIGNoYW5nZSBldmVudC4gVHJpZ2dlcmVkIHdoZW4gdGhlIHJldmlzaW9uIGNvdW50ZXIgaXMgaW5jcmVhc2VkLlxuICAgKiBAZXZlbnQgbW9kdWxlOm9sL2V2ZW50cy9FdmVudH5CYXNlRXZlbnQjY2hhbmdlXG4gICAqIEBhcGlcbiAgICovXG4gIENIQU5HRTogJ2NoYW5nZScsXG5cbiAgLyoqXG4gICAqIEdlbmVyaWMgZXJyb3IgZXZlbnQuIFRyaWdnZXJlZCB3aGVuIGFuIGVycm9yIG9jY3Vycy5cbiAgICogQGV2ZW50IG1vZHVsZTpvbC9ldmVudHMvRXZlbnR+QmFzZUV2ZW50I2Vycm9yXG4gICAqIEBhcGlcbiAgICovXG4gIEVSUk9SOiAnZXJyb3InLFxuXG4gIEJMVVI6ICdibHVyJyxcbiAgQ0xFQVI6ICdjbGVhcicsXG4gIENPTlRFWFRNRU5VOiAnY29udGV4dG1lbnUnLFxuICBDTElDSzogJ2NsaWNrJyxcbiAgREJMQ0xJQ0s6ICdkYmxjbGljaycsXG4gIERSQUdFTlRFUjogJ2RyYWdlbnRlcicsXG4gIERSQUdPVkVSOiAnZHJhZ292ZXInLFxuICBEUk9QOiAnZHJvcCcsXG4gIEZPQ1VTOiAnZm9jdXMnLFxuICBLRVlET1dOOiAna2V5ZG93bicsXG4gIEtFWVBSRVNTOiAna2V5cHJlc3MnLFxuICBMT0FEOiAnbG9hZCcsXG4gIFJFU0laRTogJ3Jlc2l6ZScsXG4gIFRPVUNITU9WRTogJ3RvdWNobW92ZScsXG4gIFdIRUVMOiAnd2hlZWwnLFxufTtcbiIsIi8qKlxuICogQG1vZHVsZSBvbC9ldmVudHMvS2V5XG4gKi9cblxuLyoqXG4gKiBAZW51bSB7c3RyaW5nfVxuICogQGNvbnN0XG4gKi9cbmV4cG9ydCBkZWZhdWx0IHtcbiAgTEVGVDogJ0Fycm93TGVmdCcsXG4gIFVQOiAnQXJyb3dVcCcsXG4gIFJJR0hUOiAnQXJyb3dSaWdodCcsXG4gIERPV046ICdBcnJvd0Rvd24nLFxufTtcbiIsIi8qKlxuICogQG1vZHVsZSBvbC9ldmVudHMvVGFyZ2V0XG4gKi9cbmltcG9ydCBEaXNwb3NhYmxlIGZyb20gJy4uL0Rpc3Bvc2FibGUuanMnO1xuaW1wb3J0IEV2ZW50IGZyb20gJy4vRXZlbnQuanMnO1xuaW1wb3J0IHtWT0lEfSBmcm9tICcuLi9mdW5jdGlvbnMuanMnO1xuaW1wb3J0IHtjbGVhcn0gZnJvbSAnLi4vb2JqLmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7RXZlbnRUYXJnZXR8VGFyZ2V0fSBFdmVudFRhcmdldExpa2VcbiAqL1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEEgc2ltcGxpZmllZCBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgVzNDIERPTSBMZXZlbCAyIEV2ZW50VGFyZ2V0IGludGVyZmFjZS5cbiAqIFNlZSBodHRwczovL3d3dy53My5vcmcvVFIvMjAwMC9SRUMtRE9NLUxldmVsLTItRXZlbnRzLTIwMDAxMTEzL2V2ZW50cy5odG1sI0V2ZW50cy1FdmVudFRhcmdldC5cbiAqXG4gKiBUaGVyZSBhcmUgdHdvIGltcG9ydGFudCBzaW1wbGlmaWNhdGlvbnMgY29tcGFyZWQgdG8gdGhlIHNwZWNpZmljYXRpb246XG4gKlxuICogMS4gVGhlIGhhbmRsaW5nIG9mIGB1c2VDYXB0dXJlYCBpbiBgYWRkRXZlbnRMaXN0ZW5lcmAgYW5kXG4gKiAgICBgcmVtb3ZlRXZlbnRMaXN0ZW5lcmAuIFRoZXJlIGlzIG5vIHJlYWwgY2FwdHVyZSBtb2RlbC5cbiAqIDIuIFRoZSBoYW5kbGluZyBvZiBgc3RvcFByb3BhZ2F0aW9uYCBhbmQgYHByZXZlbnREZWZhdWx0YCBvbiBgZGlzcGF0Y2hFdmVudGAuXG4gKiAgICBUaGVyZSBpcyBubyBldmVudCB0YXJnZXQgaGllcmFyY2h5LiBXaGVuIGEgbGlzdGVuZXIgY2FsbHNcbiAqICAgIGBzdG9wUHJvcGFnYXRpb25gIG9yIGBwcmV2ZW50RGVmYXVsdGAgb24gYW4gZXZlbnQgb2JqZWN0LCBpdCBtZWFucyB0aGF0IG5vXG4gKiAgICBtb3JlIGxpc3RlbmVycyBhZnRlciB0aGlzIG9uZSB3aWxsIGJlIGNhbGxlZC4gU2FtZSBhcyB3aGVuIHRoZSBsaXN0ZW5lclxuICogICAgcmV0dXJucyBmYWxzZS5cbiAqL1xuY2xhc3MgVGFyZ2V0IGV4dGVuZHMgRGlzcG9zYWJsZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0geyp9IFt0YXJnZXRdIERlZmF1bHQgZXZlbnQgdGFyZ2V0IGZvciBkaXNwYXRjaGVkIGV2ZW50cy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHRhcmdldCkge1xuICAgIHN1cGVyKCk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHsqfVxuICAgICAqL1xuICAgIHRoaXMuZXZlbnRUYXJnZXRfID0gdGFyZ2V0O1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgbnVtYmVyPn1cbiAgICAgKi9cbiAgICB0aGlzLnBlbmRpbmdSZW1vdmFsc18gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgbnVtYmVyPn1cbiAgICAgKi9cbiAgICB0aGlzLmRpc3BhdGNoaW5nXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBBcnJheTxpbXBvcnQoXCIuLi9ldmVudHMuanNcIikuTGlzdGVuZXI+Pn1cbiAgICAgKi9cbiAgICB0aGlzLmxpc3RlbmVyc18gPSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIFR5cGUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZXZlbnRzLmpzXCIpLkxpc3RlbmVyfSBsaXN0ZW5lciBMaXN0ZW5lci5cbiAgICovXG4gIGFkZEV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICBpZiAoIXR5cGUgfHwgIWxpc3RlbmVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGxpc3RlbmVycyA9IHRoaXMubGlzdGVuZXJzXyB8fCAodGhpcy5saXN0ZW5lcnNfID0ge30pO1xuICAgIGNvbnN0IGxpc3RlbmVyc0ZvclR5cGUgPSBsaXN0ZW5lcnNbdHlwZV0gfHwgKGxpc3RlbmVyc1t0eXBlXSA9IFtdKTtcbiAgICBpZiAoIWxpc3RlbmVyc0ZvclR5cGUuaW5jbHVkZXMobGlzdGVuZXIpKSB7XG4gICAgICBsaXN0ZW5lcnNGb3JUeXBlLnB1c2gobGlzdGVuZXIpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEaXNwYXRjaGVzIGFuIGV2ZW50IGFuZCBjYWxscyBhbGwgbGlzdGVuZXJzIGxpc3RlbmluZyBmb3IgZXZlbnRzXG4gICAqIG9mIHRoaXMgdHlwZS4gVGhlIGV2ZW50IHBhcmFtZXRlciBjYW4gZWl0aGVyIGJlIGEgc3RyaW5nIG9yIGFuXG4gICAqIE9iamVjdCB3aXRoIGEgYHR5cGVgIHByb3BlcnR5LlxuICAgKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vRXZlbnQuanNcIikuZGVmYXVsdHxzdHJpbmd9IGV2ZW50IEV2ZW50IG9iamVjdC5cbiAgICogQHJldHVybiB7Ym9vbGVhbnx1bmRlZmluZWR9IGBmYWxzZWAgaWYgYW55b25lIGNhbGxlZCBwcmV2ZW50RGVmYXVsdCBvbiB0aGVcbiAgICogICAgIGV2ZW50IG9iamVjdCBvciBpZiBhbnkgb2YgdGhlIGxpc3RlbmVycyByZXR1cm5lZCBmYWxzZS5cbiAgICogQGFwaVxuICAgKi9cbiAgZGlzcGF0Y2hFdmVudChldmVudCkge1xuICAgIGNvbnN0IGlzU3RyaW5nID0gdHlwZW9mIGV2ZW50ID09PSAnc3RyaW5nJztcbiAgICBjb25zdCB0eXBlID0gaXNTdHJpbmcgPyBldmVudCA6IGV2ZW50LnR5cGU7XG4gICAgY29uc3QgbGlzdGVuZXJzID0gdGhpcy5saXN0ZW5lcnNfICYmIHRoaXMubGlzdGVuZXJzX1t0eXBlXTtcbiAgICBpZiAoIWxpc3RlbmVycykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGV2dCA9IGlzU3RyaW5nID8gbmV3IEV2ZW50KGV2ZW50KSA6IC8qKiBAdHlwZSB7RXZlbnR9ICovIChldmVudCk7XG4gICAgaWYgKCFldnQudGFyZ2V0KSB7XG4gICAgICBldnQudGFyZ2V0ID0gdGhpcy5ldmVudFRhcmdldF8gfHwgdGhpcztcbiAgICB9XG4gICAgY29uc3QgZGlzcGF0Y2hpbmcgPSB0aGlzLmRpc3BhdGNoaW5nXyB8fCAodGhpcy5kaXNwYXRjaGluZ18gPSB7fSk7XG4gICAgY29uc3QgcGVuZGluZ1JlbW92YWxzID1cbiAgICAgIHRoaXMucGVuZGluZ1JlbW92YWxzXyB8fCAodGhpcy5wZW5kaW5nUmVtb3ZhbHNfID0ge30pO1xuICAgIGlmICghKHR5cGUgaW4gZGlzcGF0Y2hpbmcpKSB7XG4gICAgICBkaXNwYXRjaGluZ1t0eXBlXSA9IDA7XG4gICAgICBwZW5kaW5nUmVtb3ZhbHNbdHlwZV0gPSAwO1xuICAgIH1cbiAgICArK2Rpc3BhdGNoaW5nW3R5cGVdO1xuICAgIGxldCBwcm9wYWdhdGU7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gbGlzdGVuZXJzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgIGlmICgnaGFuZGxlRXZlbnQnIGluIGxpc3RlbmVyc1tpXSkge1xuICAgICAgICBwcm9wYWdhdGUgPSAvKiogQHR5cGUge2ltcG9ydChcIi4uL2V2ZW50cy5qc1wiKS5MaXN0ZW5lck9iamVjdH0gKi8gKFxuICAgICAgICAgIGxpc3RlbmVyc1tpXVxuICAgICAgICApLmhhbmRsZUV2ZW50KGV2dCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9wYWdhdGUgPSAvKiogQHR5cGUge2ltcG9ydChcIi4uL2V2ZW50cy5qc1wiKS5MaXN0ZW5lckZ1bmN0aW9ufSAqLyAoXG4gICAgICAgICAgbGlzdGVuZXJzW2ldXG4gICAgICAgICkuY2FsbCh0aGlzLCBldnQpO1xuICAgICAgfVxuICAgICAgaWYgKHByb3BhZ2F0ZSA9PT0gZmFsc2UgfHwgZXZ0LnByb3BhZ2F0aW9uU3RvcHBlZCkge1xuICAgICAgICBwcm9wYWdhdGUgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICgtLWRpc3BhdGNoaW5nW3R5cGVdID09PSAwKSB7XG4gICAgICBsZXQgcHIgPSBwZW5kaW5nUmVtb3ZhbHNbdHlwZV07XG4gICAgICBkZWxldGUgcGVuZGluZ1JlbW92YWxzW3R5cGVdO1xuICAgICAgd2hpbGUgKHByLS0pIHtcbiAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIFZPSUQpO1xuICAgICAgfVxuICAgICAgZGVsZXRlIGRpc3BhdGNoaW5nW3R5cGVdO1xuICAgIH1cbiAgICByZXR1cm4gcHJvcGFnYXRlO1xuICB9XG5cbiAgLyoqXG4gICAqIENsZWFuIHVwLlxuICAgKi9cbiAgZGlzcG9zZUludGVybmFsKCkge1xuICAgIHRoaXMubGlzdGVuZXJzXyAmJiBjbGVhcih0aGlzLmxpc3RlbmVyc18pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbGlzdGVuZXJzIGZvciBhIHNwZWNpZmllZCBldmVudCB0eXBlLiBMaXN0ZW5lcnMgYXJlIHJldHVybmVkIGluIHRoZVxuICAgKiBvcmRlciB0aGF0IHRoZXkgd2lsbCBiZSBjYWxsZWQgaW4uXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIFR5cGUuXG4gICAqIEByZXR1cm4ge0FycmF5PGltcG9ydChcIi4uL2V2ZW50cy5qc1wiKS5MaXN0ZW5lcj58dW5kZWZpbmVkfSBMaXN0ZW5lcnMuXG4gICAqL1xuICBnZXRMaXN0ZW5lcnModHlwZSkge1xuICAgIHJldHVybiAodGhpcy5saXN0ZW5lcnNfICYmIHRoaXMubGlzdGVuZXJzX1t0eXBlXSkgfHwgdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbdHlwZV0gVHlwZS4gSWYgbm90IHByb3ZpZGVkLFxuICAgKiAgICAgYHRydWVgIHdpbGwgYmUgcmV0dXJuZWQgaWYgdGhpcyBldmVudCB0YXJnZXQgaGFzIGFueSBsaXN0ZW5lcnMuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IEhhcyBsaXN0ZW5lcnMuXG4gICAqL1xuICBoYXNMaXN0ZW5lcih0eXBlKSB7XG4gICAgaWYgKCF0aGlzLmxpc3RlbmVyc18pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHR5cGVcbiAgICAgID8gdHlwZSBpbiB0aGlzLmxpc3RlbmVyc19cbiAgICAgIDogT2JqZWN0LmtleXModGhpcy5saXN0ZW5lcnNfKS5sZW5ndGggPiAwO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIFR5cGUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZXZlbnRzLmpzXCIpLkxpc3RlbmVyfSBsaXN0ZW5lciBMaXN0ZW5lci5cbiAgICovXG4gIHJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICBjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLmxpc3RlbmVyc18gJiYgdGhpcy5saXN0ZW5lcnNfW3R5cGVdO1xuICAgIGlmIChsaXN0ZW5lcnMpIHtcbiAgICAgIGNvbnN0IGluZGV4ID0gbGlzdGVuZXJzLmluZGV4T2YobGlzdGVuZXIpO1xuICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICBpZiAodGhpcy5wZW5kaW5nUmVtb3ZhbHNfICYmIHR5cGUgaW4gdGhpcy5wZW5kaW5nUmVtb3ZhbHNfKSB7XG4gICAgICAgICAgLy8gbWFrZSBsaXN0ZW5lciBhIG5vLW9wLCBhbmQgcmVtb3ZlIGxhdGVyIGluICNkaXNwYXRjaEV2ZW50KClcbiAgICAgICAgICBsaXN0ZW5lcnNbaW5kZXhdID0gVk9JRDtcbiAgICAgICAgICArK3RoaXMucGVuZGluZ1JlbW92YWxzX1t0eXBlXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsaXN0ZW5lcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICBpZiAobGlzdGVuZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMubGlzdGVuZXJzX1t0eXBlXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgVGFyZ2V0O1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2V2ZW50cy9jb25kaXRpb25cbiAqL1xuaW1wb3J0IE1hcEJyb3dzZXJFdmVudFR5cGUgZnJvbSAnLi4vTWFwQnJvd3NlckV2ZW50VHlwZS5qcyc7XG5pbXBvcnQge0ZBTFNFLCBUUlVFfSBmcm9tICcuLi9mdW5jdGlvbnMuanMnO1xuaW1wb3J0IHtNQUMsIFdFQktJVH0gZnJvbSAnLi4vaGFzLmpzJztcbmltcG9ydCB7YXNzZXJ0fSBmcm9tICcuLi9hc3NlcnRzLmpzJztcblxuLyoqXG4gKiBBIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYW4ge0BsaW5rIG1vZHVsZTpvbC9NYXBCcm93c2VyRXZlbnR+TWFwQnJvd3NlckV2ZW50fSBhbmQgcmV0dXJucyBhXG4gKiBge2Jvb2xlYW59YC4gSWYgdGhlIGNvbmRpdGlvbiBpcyBtZXQsIHRydWUgc2hvdWxkIGJlIHJldHVybmVkLlxuICpcbiAqIEB0eXBlZGVmIHtmdW5jdGlvbih0aGlzOiA/LCBpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdCk6IGJvb2xlYW59IENvbmRpdGlvblxuICovXG5cbi8qKlxuICogQ3JlYXRlcyBhIGNvbmRpdGlvbiBmdW5jdGlvbiB0aGF0IHBhc3NlcyB3aGVuIGFsbCBwcm92aWRlZCBjb25kaXRpb25zIHBhc3MuXG4gKiBAcGFyYW0gey4uLkNvbmRpdGlvbn0gdmFyX2FyZ3MgQ29uZGl0aW9ucyB0byBjaGVjay5cbiAqIEByZXR1cm4ge0NvbmRpdGlvbn0gQ29uZGl0aW9uIGZ1bmN0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYWxsKHZhcl9hcmdzKSB7XG4gIGNvbnN0IGNvbmRpdGlvbnMgPSBhcmd1bWVudHM7XG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcEJyb3dzZXJFdmVudC5qc1wiKS5kZWZhdWx0fSBldmVudCBFdmVudC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gQWxsIGNvbmRpdGlvbnMgcGFzc2VkLlxuICAgKi9cbiAgcmV0dXJuIGZ1bmN0aW9uIChldmVudCkge1xuICAgIGxldCBwYXNzID0gdHJ1ZTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBjb25kaXRpb25zLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgIHBhc3MgPSBwYXNzICYmIGNvbmRpdGlvbnNbaV0oZXZlbnQpO1xuICAgICAgaWYgKCFwYXNzKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcGFzcztcbiAgfTtcbn1cblxuLyoqXG4gKiBSZXR1cm4gYHRydWVgIGlmIG9ubHkgdGhlIGFsdC1rZXkgaXMgcHJlc3NlZCwgYGZhbHNlYCBvdGhlcndpc2UgKGUuZy4gd2hlblxuICogYWRkaXRpb25hbGx5IHRoZSBzaGlmdC1rZXkgaXMgcHJlc3NlZCkuXG4gKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdH0gbWFwQnJvd3NlckV2ZW50IE1hcCBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBvbmx5IHRoZSBhbHQga2V5IGlzIHByZXNzZWQuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBjb25zdCBhbHRLZXlPbmx5ID0gZnVuY3Rpb24gKG1hcEJyb3dzZXJFdmVudCkge1xuICBjb25zdCBvcmlnaW5hbEV2ZW50ID0gLyoqIEB0eXBlIHtLZXlib2FyZEV2ZW50fE1vdXNlRXZlbnR8VG91Y2hFdmVudH0gKi8gKFxuICAgIG1hcEJyb3dzZXJFdmVudC5vcmlnaW5hbEV2ZW50XG4gICk7XG4gIHJldHVybiAoXG4gICAgb3JpZ2luYWxFdmVudC5hbHRLZXkgJiZcbiAgICAhKG9yaWdpbmFsRXZlbnQubWV0YUtleSB8fCBvcmlnaW5hbEV2ZW50LmN0cmxLZXkpICYmXG4gICAgIW9yaWdpbmFsRXZlbnQuc2hpZnRLZXlcbiAgKTtcbn07XG5cbi8qKlxuICogUmV0dXJuIGB0cnVlYCBpZiBvbmx5IHRoZSBhbHQta2V5IGFuZCBzaGlmdC1rZXkgaXMgcHJlc3NlZCwgYGZhbHNlYCBvdGhlcndpc2VcbiAqIChlLmcuIHdoZW4gYWRkaXRpb25hbGx5IHRoZSBwbGF0Zm9ybS1tb2RpZmllci1rZXkgaXMgcHJlc3NlZCkuXG4gKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdH0gbWFwQnJvd3NlckV2ZW50IE1hcCBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBvbmx5IHRoZSBhbHQgYW5kIHNoaWZ0IGtleXMgYXJlIHByZXNzZWQuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBjb25zdCBhbHRTaGlmdEtleXNPbmx5ID0gZnVuY3Rpb24gKG1hcEJyb3dzZXJFdmVudCkge1xuICBjb25zdCBvcmlnaW5hbEV2ZW50ID0gLyoqIEB0eXBlIHtLZXlib2FyZEV2ZW50fE1vdXNlRXZlbnR8VG91Y2hFdmVudH0gKi8gKFxuICAgIG1hcEJyb3dzZXJFdmVudC5vcmlnaW5hbEV2ZW50XG4gICk7XG4gIHJldHVybiAoXG4gICAgb3JpZ2luYWxFdmVudC5hbHRLZXkgJiZcbiAgICAhKG9yaWdpbmFsRXZlbnQubWV0YUtleSB8fCBvcmlnaW5hbEV2ZW50LmN0cmxLZXkpICYmXG4gICAgb3JpZ2luYWxFdmVudC5zaGlmdEtleVxuICApO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gYHRydWVgIGlmIHRoZSBtYXAgaGFzIHRoZSBmb2N1cy4gVGhpcyBjb25kaXRpb24gcmVxdWlyZXMgYSBtYXAgdGFyZ2V0XG4gKiBlbGVtZW50IHdpdGggYSBgdGFiaW5kZXhgIGF0dHJpYnV0ZSwgZS5nLiBgPGRpdiBpZD1cIm1hcFwiIHRhYmluZGV4PVwiMVwiPmAuXG4gKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdH0gZXZlbnQgTWFwIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUaGUgbWFwIGhhcyB0aGUgZm9jdXMuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBjb25zdCBmb2N1cyA9IGZ1bmN0aW9uIChldmVudCkge1xuICBjb25zdCB0YXJnZXRFbGVtZW50ID0gZXZlbnQubWFwLmdldFRhcmdldEVsZW1lbnQoKTtcbiAgY29uc3QgYWN0aXZlRWxlbWVudCA9IGV2ZW50Lm1hcC5nZXRPd25lckRvY3VtZW50KCkuYWN0aXZlRWxlbWVudDtcbiAgcmV0dXJuIHRhcmdldEVsZW1lbnQuY29udGFpbnMoYWN0aXZlRWxlbWVudCk7XG59O1xuXG4vKipcbiAqIFJldHVybiBgdHJ1ZWAgaWYgdGhlIG1hcCBoYXMgdGhlIGZvY3VzIG9yIG5vICd0YWJpbmRleCcgYXR0cmlidXRlIHNldC5cbiAqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcEJyb3dzZXJFdmVudC5qc1wiKS5kZWZhdWx0fSBldmVudCBNYXAgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSBtYXAgY29udGFpbmVyIGhhcyB0aGUgZm9jdXMgb3Igbm8gJ3RhYmluZGV4JyBhdHRyaWJ1dGUuXG4gKi9cbmV4cG9ydCBjb25zdCBmb2N1c1dpdGhUYWJpbmRleCA9IGZ1bmN0aW9uIChldmVudCkge1xuICByZXR1cm4gZXZlbnQubWFwLmdldFRhcmdldEVsZW1lbnQoKS5oYXNBdHRyaWJ1dGUoJ3RhYmluZGV4JylcbiAgICA/IGZvY3VzKGV2ZW50KVxuICAgIDogdHJ1ZTtcbn07XG5cbi8qKlxuICogUmV0dXJuIGFsd2F5cyB0cnVlLlxuICpcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLmRlZmF1bHR9IG1hcEJyb3dzZXJFdmVudCBNYXAgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBjb25zdCBhbHdheXMgPSBUUlVFO1xuXG4vKipcbiAqIFJldHVybiBgdHJ1ZWAgaWYgdGhlIGV2ZW50IGlzIGEgYGNsaWNrYCBldmVudCwgYGZhbHNlYCBvdGhlcndpc2UuXG4gKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdH0gbWFwQnJvd3NlckV2ZW50IE1hcCBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgZXZlbnQgaXMgYSBtYXAgYGNsaWNrYCBldmVudC5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGNvbnN0IGNsaWNrID0gZnVuY3Rpb24gKG1hcEJyb3dzZXJFdmVudCkge1xuICByZXR1cm4gbWFwQnJvd3NlckV2ZW50LnR5cGUgPT0gTWFwQnJvd3NlckV2ZW50VHlwZS5DTElDSztcbn07XG5cbi8qKlxuICogUmV0dXJuIGB0cnVlYCBpZiB0aGUgZXZlbnQgaGFzIGFuIFwiYWN0aW9uXCItcHJvZHVjaW5nIG1vdXNlIGJ1dHRvbi5cbiAqXG4gKiBCeSBkZWZpbml0aW9uLCB0aGlzIGluY2x1ZGVzIGxlZnQtY2xpY2sgb24gd2luZG93cy9saW51eCwgYW5kIGxlZnQtY2xpY2tcbiAqIHdpdGhvdXQgdGhlIGN0cmwga2V5IG9uIE1hY3MuXG4gKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdH0gbWFwQnJvd3NlckV2ZW50IE1hcCBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7Ym9vbGVhbn0gVGhlIHJlc3VsdC5cbiAqL1xuZXhwb3J0IGNvbnN0IG1vdXNlQWN0aW9uQnV0dG9uID0gZnVuY3Rpb24gKG1hcEJyb3dzZXJFdmVudCkge1xuICBjb25zdCBvcmlnaW5hbEV2ZW50ID0gLyoqIEB0eXBlIHtNb3VzZUV2ZW50fSAqLyAoXG4gICAgbWFwQnJvd3NlckV2ZW50Lm9yaWdpbmFsRXZlbnRcbiAgKTtcbiAgcmV0dXJuIG9yaWdpbmFsRXZlbnQuYnV0dG9uID09IDAgJiYgIShXRUJLSVQgJiYgTUFDICYmIG9yaWdpbmFsRXZlbnQuY3RybEtleSk7XG59O1xuXG4vKipcbiAqIFJldHVybiBhbHdheXMgZmFsc2UuXG4gKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdH0gbWFwQnJvd3NlckV2ZW50IE1hcCBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7Ym9vbGVhbn0gRmFsc2UuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBjb25zdCBuZXZlciA9IEZBTFNFO1xuXG4vKipcbiAqIFJldHVybiBgdHJ1ZWAgaWYgdGhlIGJyb3dzZXIgZXZlbnQgaXMgYSBgcG9pbnRlcm1vdmVgIGV2ZW50LCBgZmFsc2VgXG4gKiBvdGhlcndpc2UuXG4gKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdH0gbWFwQnJvd3NlckV2ZW50IE1hcCBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgYnJvd3NlciBldmVudCBpcyBhIGBwb2ludGVybW92ZWAgZXZlbnQuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBjb25zdCBwb2ludGVyTW92ZSA9IGZ1bmN0aW9uIChtYXBCcm93c2VyRXZlbnQpIHtcbiAgcmV0dXJuIG1hcEJyb3dzZXJFdmVudC50eXBlID09ICdwb2ludGVybW92ZSc7XG59O1xuXG4vKipcbiAqIFJldHVybiBgdHJ1ZWAgaWYgdGhlIGV2ZW50IGlzIGEgbWFwIGBzaW5nbGVjbGlja2AgZXZlbnQsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICpcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLmRlZmF1bHR9IG1hcEJyb3dzZXJFdmVudCBNYXAgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGV2ZW50IGlzIGEgbWFwIGBzaW5nbGVjbGlja2AgZXZlbnQuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBjb25zdCBzaW5nbGVDbGljayA9IGZ1bmN0aW9uIChtYXBCcm93c2VyRXZlbnQpIHtcbiAgcmV0dXJuIG1hcEJyb3dzZXJFdmVudC50eXBlID09IE1hcEJyb3dzZXJFdmVudFR5cGUuU0lOR0xFQ0xJQ0s7XG59O1xuXG4vKipcbiAqIFJldHVybiBgdHJ1ZWAgaWYgdGhlIGV2ZW50IGlzIGEgbWFwIGBkYmxjbGlja2AgZXZlbnQsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICpcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLmRlZmF1bHR9IG1hcEJyb3dzZXJFdmVudCBNYXAgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGV2ZW50IGlzIGEgbWFwIGBkYmxjbGlja2AgZXZlbnQuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBjb25zdCBkb3VibGVDbGljayA9IGZ1bmN0aW9uIChtYXBCcm93c2VyRXZlbnQpIHtcbiAgcmV0dXJuIG1hcEJyb3dzZXJFdmVudC50eXBlID09IE1hcEJyb3dzZXJFdmVudFR5cGUuREJMQ0xJQ0s7XG59O1xuXG4vKipcbiAqIFJldHVybiBgdHJ1ZWAgaWYgbm8gbW9kaWZpZXIga2V5IChhbHQtLCBzaGlmdC0gb3IgcGxhdGZvcm0tbW9kaWZpZXIta2V5KSBpc1xuICogcHJlc3NlZC5cbiAqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcEJyb3dzZXJFdmVudC5qc1wiKS5kZWZhdWx0fSBtYXBCcm93c2VyRXZlbnQgTWFwIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIG9ubHkgaWYgdGhlcmUgbm8gbW9kaWZpZXIga2V5cyBhcmUgcHJlc3NlZC5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGNvbnN0IG5vTW9kaWZpZXJLZXlzID0gZnVuY3Rpb24gKG1hcEJyb3dzZXJFdmVudCkge1xuICBjb25zdCBvcmlnaW5hbEV2ZW50ID0gLyoqIEB0eXBlIHtLZXlib2FyZEV2ZW50fE1vdXNlRXZlbnR8VG91Y2hFdmVudH0gKi8gKFxuICAgIG1hcEJyb3dzZXJFdmVudC5vcmlnaW5hbEV2ZW50XG4gICk7XG4gIHJldHVybiAoXG4gICAgIW9yaWdpbmFsRXZlbnQuYWx0S2V5ICYmXG4gICAgIShvcmlnaW5hbEV2ZW50Lm1ldGFLZXkgfHwgb3JpZ2luYWxFdmVudC5jdHJsS2V5KSAmJlxuICAgICFvcmlnaW5hbEV2ZW50LnNoaWZ0S2V5XG4gICk7XG59O1xuXG4vKipcbiAqIFJldHVybiBgdHJ1ZWAgaWYgb25seSB0aGUgcGxhdGZvcm0tbW9kaWZpZXIta2V5ICh0aGUgbWV0YS1rZXkgb24gTWFjLFxuICogY3RybC1rZXkgb3RoZXJ3aXNlKSBpcyBwcmVzc2VkLCBgZmFsc2VgIG90aGVyd2lzZSAoZS5nLiB3aGVuIGFkZGl0aW9uYWxseVxuICogdGhlIHNoaWZ0LWtleSBpcyBwcmVzc2VkKS5cbiAqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcEJyb3dzZXJFdmVudC5qc1wiKS5kZWZhdWx0fSBtYXBCcm93c2VyRXZlbnQgTWFwIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIG9ubHkgdGhlIHBsYXRmb3JtIG1vZGlmaWVyIGtleSBpcyBwcmVzc2VkLlxuICogQGFwaVxuICovXG5leHBvcnQgY29uc3QgcGxhdGZvcm1Nb2RpZmllcktleU9ubHkgPSBmdW5jdGlvbiAobWFwQnJvd3NlckV2ZW50KSB7XG4gIGNvbnN0IG9yaWdpbmFsRXZlbnQgPSAvKiogQHR5cGUge0tleWJvYXJkRXZlbnR8TW91c2VFdmVudHxUb3VjaEV2ZW50fSAqLyAoXG4gICAgbWFwQnJvd3NlckV2ZW50Lm9yaWdpbmFsRXZlbnRcbiAgKTtcbiAgcmV0dXJuIChcbiAgICAhb3JpZ2luYWxFdmVudC5hbHRLZXkgJiZcbiAgICAoTUFDID8gb3JpZ2luYWxFdmVudC5tZXRhS2V5IDogb3JpZ2luYWxFdmVudC5jdHJsS2V5KSAmJlxuICAgICFvcmlnaW5hbEV2ZW50LnNoaWZ0S2V5XG4gICk7XG59O1xuXG4vKipcbiAqIFJldHVybiBgdHJ1ZWAgaWYgdGhlIHBsYXRmb3JtLW1vZGlmaWVyLWtleSAodGhlIG1ldGEta2V5IG9uIE1hYyxcbiAqIGN0cmwta2V5IG90aGVyd2lzZSkgaXMgcHJlc3NlZC5cbiAqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcEJyb3dzZXJFdmVudC5qc1wiKS5kZWZhdWx0fSBtYXBCcm93c2VyRXZlbnQgTWFwIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBwbGF0Zm9ybSBtb2RpZmllciBrZXkgaXMgcHJlc3NlZC5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGNvbnN0IHBsYXRmb3JtTW9kaWZpZXJLZXkgPSBmdW5jdGlvbiAobWFwQnJvd3NlckV2ZW50KSB7XG4gIGNvbnN0IG9yaWdpbmFsRXZlbnQgPSAvKiogQHR5cGUge0tleWJvYXJkRXZlbnR8TW91c2VFdmVudHxUb3VjaEV2ZW50fSAqLyAoXG4gICAgbWFwQnJvd3NlckV2ZW50Lm9yaWdpbmFsRXZlbnRcbiAgKTtcbiAgcmV0dXJuIE1BQyA/IG9yaWdpbmFsRXZlbnQubWV0YUtleSA6IG9yaWdpbmFsRXZlbnQuY3RybEtleTtcbn07XG5cbi8qKlxuICogUmV0dXJuIGB0cnVlYCBpZiBvbmx5IHRoZSBzaGlmdC1rZXkgaXMgcHJlc3NlZCwgYGZhbHNlYCBvdGhlcndpc2UgKGUuZy4gd2hlblxuICogYWRkaXRpb25hbGx5IHRoZSBhbHQta2V5IGlzIHByZXNzZWQpLlxuICpcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLmRlZmF1bHR9IG1hcEJyb3dzZXJFdmVudCBNYXAgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgb25seSB0aGUgc2hpZnQga2V5IGlzIHByZXNzZWQuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBjb25zdCBzaGlmdEtleU9ubHkgPSBmdW5jdGlvbiAobWFwQnJvd3NlckV2ZW50KSB7XG4gIGNvbnN0IG9yaWdpbmFsRXZlbnQgPSAvKiogQHR5cGUge0tleWJvYXJkRXZlbnR8TW91c2VFdmVudHxUb3VjaEV2ZW50fSAqLyAoXG4gICAgbWFwQnJvd3NlckV2ZW50Lm9yaWdpbmFsRXZlbnRcbiAgKTtcbiAgcmV0dXJuIChcbiAgICAhb3JpZ2luYWxFdmVudC5hbHRLZXkgJiZcbiAgICAhKG9yaWdpbmFsRXZlbnQubWV0YUtleSB8fCBvcmlnaW5hbEV2ZW50LmN0cmxLZXkpICYmXG4gICAgb3JpZ2luYWxFdmVudC5zaGlmdEtleVxuICApO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gYHRydWVgIGlmIHRoZSB0YXJnZXQgZWxlbWVudCBpcyBub3QgZWRpdGFibGUsIGkuZS4gbm90IGFuIGBpbnB1dGAsXG4gKiBgc2VsZWN0YCwgb3IgYHRleHRhcmVhYCBlbGVtZW50IGFuZCBubyBgY29udGVudGVkaXRhYmxlYCBhdHRyaWJ1dGUgaXNcbiAqIHNldCBvciBpbmhlcml0ZWQsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICpcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLmRlZmF1bHR9IG1hcEJyb3dzZXJFdmVudCBNYXAgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgb25seSBpZiB0aGUgdGFyZ2V0IGVsZW1lbnQgaXMgbm90IGVkaXRhYmxlLlxuICogQGFwaVxuICovXG5leHBvcnQgY29uc3QgdGFyZ2V0Tm90RWRpdGFibGUgPSBmdW5jdGlvbiAobWFwQnJvd3NlckV2ZW50KSB7XG4gIGNvbnN0IG9yaWdpbmFsRXZlbnQgPSAvKiogQHR5cGUge0tleWJvYXJkRXZlbnR8TW91c2VFdmVudHxUb3VjaEV2ZW50fSAqLyAoXG4gICAgbWFwQnJvd3NlckV2ZW50Lm9yaWdpbmFsRXZlbnRcbiAgKTtcbiAgY29uc3QgdGFnTmFtZSA9IC8qKiBAdHlwZSB7RWxlbWVudH0gKi8gKG9yaWdpbmFsRXZlbnQudGFyZ2V0KS50YWdOYW1lO1xuICByZXR1cm4gKFxuICAgIHRhZ05hbWUgIT09ICdJTlBVVCcgJiZcbiAgICB0YWdOYW1lICE9PSAnU0VMRUNUJyAmJlxuICAgIHRhZ05hbWUgIT09ICdURVhUQVJFQScgJiZcbiAgICAvLyBgaXNDb250ZW50RWRpdGFibGVgIGlzIG9ubHkgYXZhaWxhYmxlIG9uIGBIVE1MRWxlbWVudGAsIGJ1dCBpdCBtYXkgYWxzbyBiZSBhXG4gICAgLy8gZGlmZmVyZW50IHR5cGUgbGlrZSBgU1ZHRWxlbWVudGAuXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgICFvcmlnaW5hbEV2ZW50LnRhcmdldC5pc0NvbnRlbnRFZGl0YWJsZVxuICApO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gYHRydWVgIGlmIHRoZSBldmVudCBvcmlnaW5hdGVzIGZyb20gYSBtb3VzZSBkZXZpY2UuXG4gKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdH0gbWFwQnJvd3NlckV2ZW50IE1hcCBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgZXZlbnQgb3JpZ2luYXRlcyBmcm9tIGEgbW91c2UgZGV2aWNlLlxuICogQGFwaVxuICovXG5leHBvcnQgY29uc3QgbW91c2VPbmx5ID0gZnVuY3Rpb24gKG1hcEJyb3dzZXJFdmVudCkge1xuICBjb25zdCBwb2ludGVyRXZlbnQgPSAvKiogQHR5cGUge2ltcG9ydChcIi4uL01hcEJyb3dzZXJFdmVudFwiKS5kZWZhdWx0fSAqLyAoXG4gICAgbWFwQnJvd3NlckV2ZW50XG4gICkub3JpZ2luYWxFdmVudDtcbiAgYXNzZXJ0KFxuICAgIHBvaW50ZXJFdmVudCAhPT0gdW5kZWZpbmVkLFxuICAgICdtYXBCcm93c2VyRXZlbnQgbXVzdCBvcmlnaW5hdGUgZnJvbSBhIHBvaW50ZXIgZXZlbnQnXG4gICk7XG4gIC8vIHNlZSBodHRwczovL3d3dy53My5vcmcvVFIvcG9pbnRlcmV2ZW50cy8jd2lkbC1Qb2ludGVyRXZlbnQtcG9pbnRlclR5cGVcbiAgcmV0dXJuIHBvaW50ZXJFdmVudC5wb2ludGVyVHlwZSA9PSAnbW91c2UnO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gYHRydWVgIGlmIHRoZSBldmVudCBvcmlnaW5hdGVzIGZyb20gYSB0b3VjaGFibGUgZGV2aWNlLlxuICpcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLmRlZmF1bHR9IG1hcEJyb3dzZXJFdmVudCBNYXAgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGV2ZW50IG9yaWdpbmF0ZXMgZnJvbSBhIHRvdWNoYWJsZSBkZXZpY2UuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBjb25zdCB0b3VjaE9ubHkgPSBmdW5jdGlvbiAobWFwQnJvd3NlckV2ZW50KSB7XG4gIGNvbnN0IHBvaW50ZXJFdnQgPSAvKiogQHR5cGUge2ltcG9ydChcIi4uL01hcEJyb3dzZXJFdmVudFwiKS5kZWZhdWx0fSAqLyAoXG4gICAgbWFwQnJvd3NlckV2ZW50XG4gICkub3JpZ2luYWxFdmVudDtcbiAgYXNzZXJ0KFxuICAgIHBvaW50ZXJFdnQgIT09IHVuZGVmaW5lZCxcbiAgICAnbWFwQnJvd3NlckV2ZW50IG11c3Qgb3JpZ2luYXRlIGZyb20gYSBwb2ludGVyIGV2ZW50J1xuICApO1xuICAvLyBzZWUgaHR0cHM6Ly93d3cudzMub3JnL1RSL3BvaW50ZXJldmVudHMvI3dpZGwtUG9pbnRlckV2ZW50LXBvaW50ZXJUeXBlXG4gIHJldHVybiBwb2ludGVyRXZ0LnBvaW50ZXJUeXBlID09PSAndG91Y2gnO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gYHRydWVgIGlmIHRoZSBldmVudCBvcmlnaW5hdGVzIGZyb20gYSBkaWdpdGFsIHBlbi5cbiAqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcEJyb3dzZXJFdmVudC5qc1wiKS5kZWZhdWx0fSBtYXBCcm93c2VyRXZlbnQgTWFwIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBldmVudCBvcmlnaW5hdGVzIGZyb20gYSBkaWdpdGFsIHBlbi5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGNvbnN0IHBlbk9ubHkgPSBmdW5jdGlvbiAobWFwQnJvd3NlckV2ZW50KSB7XG4gIGNvbnN0IHBvaW50ZXJFdnQgPSAvKiogQHR5cGUge2ltcG9ydChcIi4uL01hcEJyb3dzZXJFdmVudFwiKS5kZWZhdWx0fSAqLyAoXG4gICAgbWFwQnJvd3NlckV2ZW50XG4gICkub3JpZ2luYWxFdmVudDtcbiAgYXNzZXJ0KFxuICAgIHBvaW50ZXJFdnQgIT09IHVuZGVmaW5lZCxcbiAgICAnbWFwQnJvd3NlckV2ZW50IG11c3Qgb3JpZ2luYXRlIGZyb20gYSBwb2ludGVyIGV2ZW50J1xuICApO1xuICAvLyBzZWUgaHR0cHM6Ly93d3cudzMub3JnL1RSL3BvaW50ZXJldmVudHMvI3dpZGwtUG9pbnRlckV2ZW50LXBvaW50ZXJUeXBlXG4gIHJldHVybiBwb2ludGVyRXZ0LnBvaW50ZXJUeXBlID09PSAncGVuJztcbn07XG5cbi8qKlxuICogUmV0dXJuIGB0cnVlYCBpZiB0aGUgZXZlbnQgb3JpZ2luYXRlcyBmcm9tIGEgcHJpbWFyeSBwb2ludGVyIGluXG4gKiBjb250YWN0IHdpdGggdGhlIHN1cmZhY2Ugb3IgaWYgdGhlIGxlZnQgbW91c2UgYnV0dG9uIGlzIHByZXNzZWQuXG4gKiBTZWUgaHR0cHM6Ly93d3cudzMub3JnL1RSL3BvaW50ZXJldmVudHMvI2J1dHRvbi1zdGF0ZXMuXG4gKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdH0gbWFwQnJvd3NlckV2ZW50IE1hcCBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgZXZlbnQgb3JpZ2luYXRlcyBmcm9tIGEgcHJpbWFyeSBwb2ludGVyLlxuICogQGFwaVxuICovXG5leHBvcnQgY29uc3QgcHJpbWFyeUFjdGlvbiA9IGZ1bmN0aW9uIChtYXBCcm93c2VyRXZlbnQpIHtcbiAgY29uc3QgcG9pbnRlckV2ZW50ID0gLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnRcIikuZGVmYXVsdH0gKi8gKFxuICAgIG1hcEJyb3dzZXJFdmVudFxuICApLm9yaWdpbmFsRXZlbnQ7XG4gIGFzc2VydChcbiAgICBwb2ludGVyRXZlbnQgIT09IHVuZGVmaW5lZCxcbiAgICAnbWFwQnJvd3NlckV2ZW50IG11c3Qgb3JpZ2luYXRlIGZyb20gYSBwb2ludGVyIGV2ZW50J1xuICApO1xuICByZXR1cm4gcG9pbnRlckV2ZW50LmlzUHJpbWFyeSAmJiBwb2ludGVyRXZlbnQuYnV0dG9uID09PSAwO1xufTtcbiIsIi8qKlxuICogQG1vZHVsZSBvbC9leHByL2NwdVxuICovXG5cbmltcG9ydCB7XG4gIExpdGVyYWxFeHByZXNzaW9uLFxuICBPcHMsXG4gIG92ZXJsYXBzVHlwZSxcbiAgcGFyc2UsXG4gIHR5cGVOYW1lLFxufSBmcm9tICcuL2V4cHJlc3Npb24uanMnO1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgVGhpcyBtb2R1bGUgaW5jbHVkZXMgZnVuY3Rpb25zIHRvIGJ1aWxkIGV4cHJlc3Npb25zIGZvciBldmFsdWF0aW9uIG9uIHRoZSBDUFUuXG4gKiBCdWlsZGluZyBpcyBjb21wb3NlZCBvZiB0d28gc3RlcHM6IHBhcnNpbmcgYW5kIGNvbXBpbGluZy4gIFRoZSBwYXJzaW5nIHN0ZXAgdGFrZXMgYW4gZW5jb2RlZFxuICogZXhwcmVzc2lvbiBhbmQgcmV0dXJucyBhbiBpbnN0YW5jZSBvZiBvbmUgb2YgdGhlIGV4cHJlc3Npb24gY2xhc3Nlcy4gIFRoZSBjb21waWxpbmcgc3RlcCB0YWtlc1xuICogdGhlIGV4cHJlc3Npb24gaW5zdGFuY2UgYW5kIHJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGNhbiBiZSBldmFsdWF0ZWQgaW4gdG8gcmV0dXJuIGEgbGl0ZXJhbFxuICogdmFsdWUuICBUaGUgZXZhbHVhdG9yIGZ1bmN0aW9uIHNob3VsZCBkbyBhcyBsaXR0bGUgYWxsb2NhdGlvbiBhbmQgd29yayBhcyBwb3NzaWJsZS5cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEV2YWx1YXRpb25Db250ZXh0XG4gKiBAcHJvcGVydHkge09iamVjdH0gcHJvcGVydGllcyBUaGUgdmFsdWVzIGZvciBwcm9wZXJ0aWVzIHVzZWQgaW4gJ2dldCcgZXhwcmVzc2lvbnMuXG4gKiBAcHJvcGVydHkge09iamVjdH0gdmFyaWFibGVzIFRoZSB2YWx1ZXMgZm9yIHZhcmlhYmxlcyB1c2VkIGluICd2YXInIGV4cHJlc3Npb25zLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IHJlc29sdXRpb24gVGhlIG1hcCByZXNvbHV0aW9uLlxuICovXG5cbi8qKlxuICogQHJldHVybiB7RXZhbHVhdGlvbkNvbnRleHR9IEEgbmV3IGV2YWx1YXRpb24gY29udGV4dC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG5ld0V2YWx1YXRpb25Db250ZXh0KCkge1xuICByZXR1cm4ge1xuICAgIHZhcmlhYmxlczoge30sXG4gICAgcHJvcGVydGllczoge30sXG4gICAgcmVzb2x1dGlvbjogTmFOLFxuICB9O1xufVxuXG4vKipcbiAqIEB0eXBlZGVmIHtmdW5jdGlvbihFdmFsdWF0aW9uQ29udGV4dCk6aW1wb3J0KFwiLi9leHByZXNzaW9uLmpzXCIpLkxpdGVyYWxWYWx1ZX0gRXhwcmVzc2lvbkV2YWx1YXRvclxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge2Z1bmN0aW9uKEV2YWx1YXRpb25Db250ZXh0KTpib29sZWFufSBCb29sZWFuRXZhbHVhdG9yXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7ZnVuY3Rpb24oRXZhbHVhdGlvbkNvbnRleHQpOm51bWJlcn0gTnVtYmVyRXZhbHVhdG9yXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7ZnVuY3Rpb24oRXZhbHVhdGlvbkNvbnRleHQpOnN0cmluZ30gU3RyaW5nRXZhbHVhdG9yXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7ZnVuY3Rpb24oRXZhbHVhdGlvbkNvbnRleHQpOihBcnJheTxudW1iZXI+fHN0cmluZyl9IENvbG9yTGlrZUV2YWx1YXRvclxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge2Z1bmN0aW9uKEV2YWx1YXRpb25Db250ZXh0KTpBcnJheTxudW1iZXI+fSBOdW1iZXJBcnJheUV2YWx1YXRvclxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge2Z1bmN0aW9uKEV2YWx1YXRpb25Db250ZXh0KTpBcnJheTxudW1iZXI+fSBDb29yZGluYXRlRXZhbHVhdG9yXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7ZnVuY3Rpb24oRXZhbHVhdGlvbkNvbnRleHQpOihBcnJheTxudW1iZXI+fG51bWJlcil9IFNpemVMaWtlRXZhbHVhdG9yXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9leHByZXNzaW9uLmpzJykuRW5jb2RlZEV4cHJlc3Npb259IGVuY29kZWQgVGhlIGVuY29kZWQgZXhwcmVzc2lvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSB0eXBlIFRoZSBleHBlY3RlZCB0eXBlLlxuICogQHBhcmFtIHtpbXBvcnQoJy4vZXhwcmVzc2lvbi5qcycpLlBhcnNpbmdDb250ZXh0fSBjb250ZXh0IFRoZSBwYXJzaW5nIGNvbnRleHQuXG4gKiBAcmV0dXJuIHtFeHByZXNzaW9uRXZhbHVhdG9yfSBUaGUgZXhwcmVzc2lvbiBldmFsdWF0b3IuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBidWlsZEV4cHJlc3Npb24oZW5jb2RlZCwgdHlwZSwgY29udGV4dCkge1xuICBjb25zdCBleHByZXNzaW9uID0gcGFyc2UoZW5jb2RlZCwgY29udGV4dCk7XG4gIGlmICghb3ZlcmxhcHNUeXBlKHR5cGUsIGV4cHJlc3Npb24udHlwZSkpIHtcbiAgICBjb25zdCBleHBlY3RlZCA9IHR5cGVOYW1lKHR5cGUpO1xuICAgIGNvbnN0IGFjdHVhbCA9IHR5cGVOYW1lKGV4cHJlc3Npb24udHlwZSk7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYEV4cGVjdGVkIGV4cHJlc3Npb24gdG8gYmUgb2YgdHlwZSAke2V4cGVjdGVkfSwgZ290ICR7YWN0dWFsfWBcbiAgICApO1xuICB9XG4gIHJldHVybiBjb21waWxlRXhwcmVzc2lvbihleHByZXNzaW9uLCBjb250ZXh0KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vZXhwcmVzc2lvbi5qc1wiKS5FeHByZXNzaW9ufSBleHByZXNzaW9uIFRoZSBleHByZXNzaW9uLlxuICogQHBhcmFtIHtpbXBvcnQoJy4vZXhwcmVzc2lvbi5qcycpLlBhcnNpbmdDb250ZXh0fSBjb250ZXh0IFRoZSBwYXJzaW5nIGNvbnRleHQuXG4gKiBAcmV0dXJuIHtFeHByZXNzaW9uRXZhbHVhdG9yfSBUaGUgZXZhbHVhdG9yIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjb21waWxlRXhwcmVzc2lvbihleHByZXNzaW9uLCBjb250ZXh0KSB7XG4gIGlmIChleHByZXNzaW9uIGluc3RhbmNlb2YgTGl0ZXJhbEV4cHJlc3Npb24pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGV4cHJlc3Npb24udmFsdWU7XG4gICAgfTtcbiAgfVxuICBjb25zdCBvcGVyYXRvciA9IGV4cHJlc3Npb24ub3BlcmF0b3I7XG4gIHN3aXRjaCAob3BlcmF0b3IpIHtcbiAgICBjYXNlIE9wcy5OdW1iZXI6XG4gICAgY2FzZSBPcHMuU3RyaW5nOiB7XG4gICAgICByZXR1cm4gY29tcGlsZUFzc2VydGlvbkV4cHJlc3Npb24oZXhwcmVzc2lvbiwgY29udGV4dCk7XG4gICAgfVxuICAgIGNhc2UgT3BzLkdldDpcbiAgICBjYXNlIE9wcy5WYXI6IHtcbiAgICAgIHJldHVybiBjb21waWxlQWNjZXNzb3JFeHByZXNzaW9uKGV4cHJlc3Npb24sIGNvbnRleHQpO1xuICAgIH1cbiAgICBjYXNlIE9wcy5SZXNvbHV0aW9uOiB7XG4gICAgICByZXR1cm4gKGNvbnRleHQpID0+IGNvbnRleHQucmVzb2x1dGlvbjtcbiAgICB9XG4gICAgY2FzZSBPcHMuQW55OlxuICAgIGNhc2UgT3BzLkFsbDpcbiAgICBjYXNlIE9wcy5Ob3Q6IHtcbiAgICAgIHJldHVybiBjb21waWxlTG9naWNhbEV4cHJlc3Npb24oZXhwcmVzc2lvbiwgY29udGV4dCk7XG4gICAgfVxuICAgIGNhc2UgT3BzLkVxdWFsOlxuICAgIGNhc2UgT3BzLk5vdEVxdWFsOlxuICAgIGNhc2UgT3BzLkxlc3NUaGFuOlxuICAgIGNhc2UgT3BzLkxlc3NUaGFuT3JFcXVhbFRvOlxuICAgIGNhc2UgT3BzLkdyZWF0ZXJUaGFuOlxuICAgIGNhc2UgT3BzLkdyZWF0ZXJUaGFuT3JFcXVhbFRvOiB7XG4gICAgICByZXR1cm4gY29tcGlsZUNvbXBhcmlzb25FeHByZXNzaW9uKGV4cHJlc3Npb24sIGNvbnRleHQpO1xuICAgIH1cbiAgICBjYXNlIE9wcy5NdWx0aXBseTpcbiAgICBjYXNlIE9wcy5EaXZpZGU6XG4gICAgY2FzZSBPcHMuQWRkOlxuICAgIGNhc2UgT3BzLlN1YnRyYWN0OlxuICAgIGNhc2UgT3BzLkNsYW1wOlxuICAgIGNhc2UgT3BzLk1vZDpcbiAgICBjYXNlIE9wcy5Qb3c6XG4gICAgY2FzZSBPcHMuQWJzOlxuICAgIGNhc2UgT3BzLkZsb29yOlxuICAgIGNhc2UgT3BzLkNlaWw6XG4gICAgY2FzZSBPcHMuUm91bmQ6XG4gICAgY2FzZSBPcHMuU2luOlxuICAgIGNhc2UgT3BzLkNvczpcbiAgICBjYXNlIE9wcy5BdGFuOlxuICAgIGNhc2UgT3BzLlNxcnQ6IHtcbiAgICAgIHJldHVybiBjb21waWxlTnVtZXJpY0V4cHJlc3Npb24oZXhwcmVzc2lvbiwgY29udGV4dCk7XG4gICAgfVxuICAgIGNhc2UgT3BzLk1hdGNoOiB7XG4gICAgICByZXR1cm4gY29tcGlsZU1hdGNoRXhwcmVzc2lvbihleHByZXNzaW9uLCBjb250ZXh0KTtcbiAgICB9XG4gICAgZGVmYXVsdDoge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBvcGVyYXRvciAke29wZXJhdG9yfWApO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2V4cHJlc3Npb24uanMnKS5DYWxsRXhwcmVzc2lvbn0gZXhwcmVzc2lvbiBUaGUgY2FsbCBleHByZXNzaW9uLlxuICogQHBhcmFtIHtpbXBvcnQoJy4vZXhwcmVzc2lvbi5qcycpLlBhcnNpbmdDb250ZXh0fSBjb250ZXh0IFRoZSBwYXJzaW5nIGNvbnRleHQuXG4gKiBAcmV0dXJuIHtFeHByZXNzaW9uRXZhbHVhdG9yfSBUaGUgZXZhbHVhdG9yIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjb21waWxlQXNzZXJ0aW9uRXhwcmVzc2lvbihleHByZXNzaW9uLCBjb250ZXh0KSB7XG4gIGNvbnN0IHR5cGUgPSBleHByZXNzaW9uLm9wZXJhdG9yO1xuICBjb25zdCBsZW5ndGggPSBleHByZXNzaW9uLmFyZ3MubGVuZ3RoO1xuXG4gIGNvbnN0IGFyZ3MgPSBuZXcgQXJyYXkobGVuZ3RoKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGFyZ3NbaV0gPSBjb21waWxlRXhwcmVzc2lvbihleHByZXNzaW9uLmFyZ3NbaV0sIGNvbnRleHQpO1xuICB9XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgT3BzLk51bWJlcjpcbiAgICBjYXNlIE9wcy5TdHJpbmc6IHtcbiAgICAgIHJldHVybiAoY29udGV4dCkgPT4ge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgY29uc3QgdmFsdWUgPSBhcmdzW2ldKGNvbnRleHQpO1xuICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IHR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBvbmUgb2YgdGhlIHZhbHVlcyB0byBiZSBhICR7dHlwZX1gKTtcbiAgICAgIH07XG4gICAgfVxuICAgIGRlZmF1bHQ6IHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgYXNzZXJ0aW9uIG9wZXJhdG9yICR7dHlwZX1gKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9leHByZXNzaW9uLmpzJykuQ2FsbEV4cHJlc3Npb259IGV4cHJlc3Npb24gVGhlIGNhbGwgZXhwcmVzc2lvbi5cbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2V4cHJlc3Npb24uanMnKS5QYXJzaW5nQ29udGV4dH0gY29udGV4dCBUaGUgcGFyc2luZyBjb250ZXh0LlxuICogQHJldHVybiB7RXhwcmVzc2lvbkV2YWx1YXRvcn0gVGhlIGV2YWx1YXRvciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY29tcGlsZUFjY2Vzc29yRXhwcmVzc2lvbihleHByZXNzaW9uLCBjb250ZXh0KSB7XG4gIGNvbnN0IG5hbWVFeHByZXNzaW9uID0gZXhwcmVzc2lvbi5hcmdzWzBdO1xuICBpZiAoIShuYW1lRXhwcmVzc2lvbiBpbnN0YW5jZW9mIExpdGVyYWxFeHByZXNzaW9uKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgbGl0ZXJhbCBuYW1lJyk7XG4gIH1cbiAgY29uc3QgbmFtZSA9IG5hbWVFeHByZXNzaW9uLnZhbHVlO1xuICBpZiAodHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBzdHJpbmcgbmFtZScpO1xuICB9XG4gIHN3aXRjaCAoZXhwcmVzc2lvbi5vcGVyYXRvcikge1xuICAgIGNhc2UgT3BzLkdldDoge1xuICAgICAgcmV0dXJuIChjb250ZXh0KSA9PiBjb250ZXh0LnByb3BlcnRpZXNbbmFtZV07XG4gICAgfVxuICAgIGNhc2UgT3BzLlZhcjoge1xuICAgICAgcmV0dXJuIChjb250ZXh0KSA9PiBjb250ZXh0LnZhcmlhYmxlc1tuYW1lXTtcbiAgICB9XG4gICAgZGVmYXVsdDoge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBhY2Nlc3NvciBvcGVyYXRvciAke2V4cHJlc3Npb24ub3BlcmF0b3J9YCk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoJy4vZXhwcmVzc2lvbi5qcycpLkNhbGxFeHByZXNzaW9ufSBleHByZXNzaW9uIFRoZSBjYWxsIGV4cHJlc3Npb24uXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9leHByZXNzaW9uLmpzJykuUGFyc2luZ0NvbnRleHR9IGNvbnRleHQgVGhlIHBhcnNpbmcgY29udGV4dC5cbiAqIEByZXR1cm4ge0Jvb2xlYW5FdmFsdWF0b3J9IFRoZSBldmFsdWF0b3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNvbXBpbGVDb21wYXJpc29uRXhwcmVzc2lvbihleHByZXNzaW9uLCBjb250ZXh0KSB7XG4gIGNvbnN0IG9wID0gZXhwcmVzc2lvbi5vcGVyYXRvcjtcbiAgY29uc3QgbGVmdCA9IGNvbXBpbGVFeHByZXNzaW9uKGV4cHJlc3Npb24uYXJnc1swXSwgY29udGV4dCk7XG4gIGNvbnN0IHJpZ2h0ID0gY29tcGlsZUV4cHJlc3Npb24oZXhwcmVzc2lvbi5hcmdzWzFdLCBjb250ZXh0KTtcbiAgc3dpdGNoIChvcCkge1xuICAgIGNhc2UgT3BzLkVxdWFsOiB7XG4gICAgICByZXR1cm4gKGNvbnRleHQpID0+IGxlZnQoY29udGV4dCkgPT09IHJpZ2h0KGNvbnRleHQpO1xuICAgIH1cbiAgICBjYXNlIE9wcy5Ob3RFcXVhbDoge1xuICAgICAgcmV0dXJuIChjb250ZXh0KSA9PiBsZWZ0KGNvbnRleHQpICE9PSByaWdodChjb250ZXh0KTtcbiAgICB9XG4gICAgY2FzZSBPcHMuTGVzc1RoYW46IHtcbiAgICAgIHJldHVybiAoY29udGV4dCkgPT4gbGVmdChjb250ZXh0KSA8IHJpZ2h0KGNvbnRleHQpO1xuICAgIH1cbiAgICBjYXNlIE9wcy5MZXNzVGhhbk9yRXF1YWxUbzoge1xuICAgICAgcmV0dXJuIChjb250ZXh0KSA9PiBsZWZ0KGNvbnRleHQpIDw9IHJpZ2h0KGNvbnRleHQpO1xuICAgIH1cbiAgICBjYXNlIE9wcy5HcmVhdGVyVGhhbjoge1xuICAgICAgcmV0dXJuIChjb250ZXh0KSA9PiBsZWZ0KGNvbnRleHQpID4gcmlnaHQoY29udGV4dCk7XG4gICAgfVxuICAgIGNhc2UgT3BzLkdyZWF0ZXJUaGFuT3JFcXVhbFRvOiB7XG4gICAgICByZXR1cm4gKGNvbnRleHQpID0+IGxlZnQoY29udGV4dCkgPj0gcmlnaHQoY29udGV4dCk7XG4gICAgfVxuICAgIGRlZmF1bHQ6IHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgY29tcGFyaXNvbiBvcGVyYXRvciAke29wfWApO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2V4cHJlc3Npb24uanMnKS5DYWxsRXhwcmVzc2lvbn0gZXhwcmVzc2lvbiBUaGUgY2FsbCBleHByZXNzaW9uLlxuICogQHBhcmFtIHtpbXBvcnQoJy4vZXhwcmVzc2lvbi5qcycpLlBhcnNpbmdDb250ZXh0fSBjb250ZXh0IFRoZSBwYXJzaW5nIGNvbnRleHQuXG4gKiBAcmV0dXJuIHtCb29sZWFuRXZhbHVhdG9yfSBUaGUgZXZhbHVhdG9yIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjb21waWxlTG9naWNhbEV4cHJlc3Npb24oZXhwcmVzc2lvbiwgY29udGV4dCkge1xuICBjb25zdCBvcCA9IGV4cHJlc3Npb24ub3BlcmF0b3I7XG4gIGNvbnN0IGxlbmd0aCA9IGV4cHJlc3Npb24uYXJncy5sZW5ndGg7XG5cbiAgY29uc3QgYXJncyA9IG5ldyBBcnJheShsZW5ndGgpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgYXJnc1tpXSA9IGNvbXBpbGVFeHByZXNzaW9uKGV4cHJlc3Npb24uYXJnc1tpXSwgY29udGV4dCk7XG4gIH1cbiAgc3dpdGNoIChvcCkge1xuICAgIGNhc2UgT3BzLkFueToge1xuICAgICAgcmV0dXJuIChjb250ZXh0KSA9PiB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBpZiAoYXJnc1tpXShjb250ZXh0KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH07XG4gICAgfVxuICAgIGNhc2UgT3BzLkFsbDoge1xuICAgICAgcmV0dXJuIChjb250ZXh0KSA9PiB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBpZiAoIWFyZ3NbaV0oY29udGV4dCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9O1xuICAgIH1cbiAgICBjYXNlIE9wcy5Ob3Q6IHtcbiAgICAgIHJldHVybiAoY29udGV4dCkgPT4gIWFyZ3NbMF0oY29udGV4dCk7XG4gICAgfVxuICAgIGRlZmF1bHQ6IHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgbG9naWNhbCBvcGVyYXRvciAke29wfWApO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2V4cHJlc3Npb24uanMnKS5DYWxsRXhwcmVzc2lvbn0gZXhwcmVzc2lvbiBUaGUgY2FsbCBleHByZXNzaW9uLlxuICogQHBhcmFtIHtpbXBvcnQoJy4vZXhwcmVzc2lvbi5qcycpLlBhcnNpbmdDb250ZXh0fSBjb250ZXh0IFRoZSBwYXJzaW5nIGNvbnRleHQuXG4gKiBAcmV0dXJuIHtOdW1iZXJFdmFsdWF0b3J9IFRoZSBldmFsdWF0b3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNvbXBpbGVOdW1lcmljRXhwcmVzc2lvbihleHByZXNzaW9uLCBjb250ZXh0KSB7XG4gIGNvbnN0IG9wID0gZXhwcmVzc2lvbi5vcGVyYXRvcjtcbiAgY29uc3QgbGVuZ3RoID0gZXhwcmVzc2lvbi5hcmdzLmxlbmd0aDtcblxuICBjb25zdCBhcmdzID0gbmV3IEFycmF5KGxlbmd0aCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBhcmdzW2ldID0gY29tcGlsZUV4cHJlc3Npb24oZXhwcmVzc2lvbi5hcmdzW2ldLCBjb250ZXh0KTtcbiAgfVxuICBzd2l0Y2ggKG9wKSB7XG4gICAgY2FzZSBPcHMuTXVsdGlwbHk6IHtcbiAgICAgIHJldHVybiAoY29udGV4dCkgPT4ge1xuICAgICAgICBsZXQgdmFsdWUgPSAxO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgdmFsdWUgKj0gYXJnc1tpXShjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9O1xuICAgIH1cbiAgICBjYXNlIE9wcy5EaXZpZGU6IHtcbiAgICAgIHJldHVybiAoY29udGV4dCkgPT4gYXJnc1swXShjb250ZXh0KSAvIGFyZ3NbMV0oY29udGV4dCk7XG4gICAgfVxuICAgIGNhc2UgT3BzLkFkZDoge1xuICAgICAgcmV0dXJuIChjb250ZXh0KSA9PiB7XG4gICAgICAgIGxldCB2YWx1ZSA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICB2YWx1ZSArPSBhcmdzW2ldKGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH07XG4gICAgfVxuICAgIGNhc2UgT3BzLlN1YnRyYWN0OiB7XG4gICAgICByZXR1cm4gKGNvbnRleHQpID0+IGFyZ3NbMF0oY29udGV4dCkgLSBhcmdzWzFdKGNvbnRleHQpO1xuICAgIH1cbiAgICBjYXNlIE9wcy5DbGFtcDoge1xuICAgICAgcmV0dXJuIChjb250ZXh0KSA9PiB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gYXJnc1swXShjb250ZXh0KTtcbiAgICAgICAgY29uc3QgbWluID0gYXJnc1sxXShjb250ZXh0KTtcbiAgICAgICAgaWYgKHZhbHVlIDwgbWluKSB7XG4gICAgICAgICAgcmV0dXJuIG1pbjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtYXggPSBhcmdzWzJdKGNvbnRleHQpO1xuICAgICAgICBpZiAodmFsdWUgPiBtYXgpIHtcbiAgICAgICAgICByZXR1cm4gbWF4O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH07XG4gICAgfVxuICAgIGNhc2UgT3BzLk1vZDoge1xuICAgICAgcmV0dXJuIChjb250ZXh0KSA9PiBhcmdzWzBdKGNvbnRleHQpICUgYXJnc1sxXShjb250ZXh0KTtcbiAgICB9XG4gICAgY2FzZSBPcHMuUG93OiB7XG4gICAgICByZXR1cm4gKGNvbnRleHQpID0+IE1hdGgucG93KGFyZ3NbMF0oY29udGV4dCksIGFyZ3NbMV0oY29udGV4dCkpO1xuICAgIH1cbiAgICBjYXNlIE9wcy5BYnM6IHtcbiAgICAgIHJldHVybiAoY29udGV4dCkgPT4gTWF0aC5hYnMoYXJnc1swXShjb250ZXh0KSk7XG4gICAgfVxuICAgIGNhc2UgT3BzLkZsb29yOiB7XG4gICAgICByZXR1cm4gKGNvbnRleHQpID0+IE1hdGguZmxvb3IoYXJnc1swXShjb250ZXh0KSk7XG4gICAgfVxuICAgIGNhc2UgT3BzLkNlaWw6IHtcbiAgICAgIHJldHVybiAoY29udGV4dCkgPT4gTWF0aC5jZWlsKGFyZ3NbMF0oY29udGV4dCkpO1xuICAgIH1cbiAgICBjYXNlIE9wcy5Sb3VuZDoge1xuICAgICAgcmV0dXJuIChjb250ZXh0KSA9PiBNYXRoLnJvdW5kKGFyZ3NbMF0oY29udGV4dCkpO1xuICAgIH1cbiAgICBjYXNlIE9wcy5TaW46IHtcbiAgICAgIHJldHVybiAoY29udGV4dCkgPT4gTWF0aC5zaW4oYXJnc1swXShjb250ZXh0KSk7XG4gICAgfVxuICAgIGNhc2UgT3BzLkNvczoge1xuICAgICAgcmV0dXJuIChjb250ZXh0KSA9PiBNYXRoLmNvcyhhcmdzWzBdKGNvbnRleHQpKTtcbiAgICB9XG4gICAgY2FzZSBPcHMuQXRhbjoge1xuICAgICAgaWYgKGxlbmd0aCA9PT0gMikge1xuICAgICAgICByZXR1cm4gKGNvbnRleHQpID0+IE1hdGguYXRhbjIoYXJnc1swXShjb250ZXh0KSwgYXJnc1sxXShjb250ZXh0KSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gKGNvbnRleHQpID0+IE1hdGguYXRhbihhcmdzWzBdKGNvbnRleHQpKTtcbiAgICB9XG4gICAgY2FzZSBPcHMuU3FydDoge1xuICAgICAgcmV0dXJuIChjb250ZXh0KSA9PiBNYXRoLnNxcnQoYXJnc1swXShjb250ZXh0KSk7XG4gICAgfVxuICAgIGRlZmF1bHQ6IHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgbnVtZXJpYyBvcGVyYXRvciAke29wfWApO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2V4cHJlc3Npb24uanMnKS5DYWxsRXhwcmVzc2lvbn0gZXhwcmVzc2lvbiBUaGUgY2FsbCBleHByZXNzaW9uLlxuICogQHBhcmFtIHtpbXBvcnQoJy4vZXhwcmVzc2lvbi5qcycpLlBhcnNpbmdDb250ZXh0fSBjb250ZXh0IFRoZSBwYXJzaW5nIGNvbnRleHQuXG4gKiBAcmV0dXJuIHtFeHByZXNzaW9uRXZhbHVhdG9yfSBUaGUgZXZhbHVhdG9yIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjb21waWxlTWF0Y2hFeHByZXNzaW9uKGV4cHJlc3Npb24sIGNvbnRleHQpIHtcbiAgY29uc3QgbGVuZ3RoID0gZXhwcmVzc2lvbi5hcmdzLmxlbmd0aDtcbiAgY29uc3QgYXJncyA9IG5ldyBBcnJheShsZW5ndGgpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgYXJnc1tpXSA9IGNvbXBpbGVFeHByZXNzaW9uKGV4cHJlc3Npb24uYXJnc1tpXSwgY29udGV4dCk7XG4gIH1cbiAgcmV0dXJuIChjb250ZXh0KSA9PiB7XG4gICAgY29uc3QgdmFsdWUgPSBhcmdzWzBdKGNvbnRleHQpO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgbGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgIGlmICh2YWx1ZSA9PT0gYXJnc1tpXShjb250ZXh0KSkge1xuICAgICAgICByZXR1cm4gYXJnc1tpICsgMV0oY29udGV4dCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcmdzW2xlbmd0aCAtIDFdKGNvbnRleHQpO1xuICB9O1xufVxuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2V4cHIvZXhwcmVzc2lvblxuICovXG5cbmltcG9ydCB7YXNjZW5kaW5nfSBmcm9tICcuLi9hcnJheS5qcyc7XG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBUaGlzIG1vZHVsZSBpbmNsdWRlcyB0eXBlcyBhbmQgZnVuY3Rpb25zIGZvciBwYXJzaW5nIGFycmF5IGVuY29kZWQgZXhwcmVzc2lvbnMuXG4gKiBUaGUgcmVzdWx0IG9mIHBhcnNpbmcgYW4gZW5jb2RlZCBleHByZXNzaW9uIGlzIG9uZSBvZiB0aGUgc3BlY2lmaWMgZXhwcmVzc2lvbiBjbGFzc2VzLlxuICogRHVyaW5nIHBhcnNpbmcsIGluZm9ybWF0aW9uIGlzIGFkZGVkIHRvIHRoZSBwYXJzaW5nIGNvbnRleHQgYWJvdXQgdGhlIGRhdGEgYWNjZXNzZWQgYnkgdGhlXG4gKiBleHByZXNzaW9uLlxuICovXG5cbmxldCBudW1UeXBlcyA9IDA7XG5leHBvcnQgY29uc3QgTm9uZVR5cGUgPSAwO1xuZXhwb3J0IGNvbnN0IEJvb2xlYW5UeXBlID0gMSA8PCBudW1UeXBlcysrO1xuZXhwb3J0IGNvbnN0IE51bWJlclR5cGUgPSAxIDw8IG51bVR5cGVzKys7XG5leHBvcnQgY29uc3QgU3RyaW5nVHlwZSA9IDEgPDwgbnVtVHlwZXMrKztcbmV4cG9ydCBjb25zdCBDb2xvclR5cGUgPSAxIDw8IG51bVR5cGVzKys7XG5leHBvcnQgY29uc3QgTnVtYmVyQXJyYXlUeXBlID0gMSA8PCBudW1UeXBlcysrO1xuZXhwb3J0IGNvbnN0IEFueVR5cGUgPSBNYXRoLnBvdygyLCBudW1UeXBlcykgLSAxO1xuXG5jb25zdCB0eXBlTmFtZXMgPSB7XG4gIFtCb29sZWFuVHlwZV06ICdib29sZWFuJyxcbiAgW051bWJlclR5cGVdOiAnbnVtYmVyJyxcbiAgW1N0cmluZ1R5cGVdOiAnc3RyaW5nJyxcbiAgW0NvbG9yVHlwZV06ICdjb2xvcicsXG4gIFtOdW1iZXJBcnJheVR5cGVdOiAnbnVtYmVyW10nLFxufTtcblxuY29uc3QgbmFtZWRUeXBlcyA9IE9iamVjdC5rZXlzKHR5cGVOYW1lcykubWFwKE51bWJlcikuc29ydChhc2NlbmRpbmcpO1xuXG4vKipcbiAqIEdldCBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBmb3IgYSB0eXBlLlxuICogQHBhcmFtIHtudW1iZXJ9IHR5cGUgVGhlIHR5cGUuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSB0eXBlIG5hbWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0eXBlTmFtZSh0eXBlKSB7XG4gIGNvbnN0IG5hbWVzID0gW107XG4gIGZvciAoY29uc3QgbmFtZWRUeXBlIG9mIG5hbWVkVHlwZXMpIHtcbiAgICBpZiAoaW5jbHVkZXNUeXBlKHR5cGUsIG5hbWVkVHlwZSkpIHtcbiAgICAgIG5hbWVzLnB1c2godHlwZU5hbWVzW25hbWVkVHlwZV0pO1xuICAgIH1cbiAgfVxuICBpZiAobmFtZXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuICd1bnR5cGVkJztcbiAgfVxuICBpZiAobmFtZXMubGVuZ3RoIDwgMykge1xuICAgIHJldHVybiBuYW1lcy5qb2luKCcgb3IgJyk7XG4gIH1cbiAgcmV0dXJuIG5hbWVzLnNsaWNlKDAsIC0xKS5qb2luKCcsICcpICsgJywgb3IgJyArIG5hbWVzW25hbWVzLmxlbmd0aCAtIDFdO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBicm9hZCBUaGUgYnJvYWQgdHlwZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzcGVjaWZpYyBUaGUgc3BlY2lmaWMgdHlwZS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSBicm9hZCB0eXBlIGluY2x1ZGVzIHRoZSBzcGVjaWZpYyB0eXBlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaW5jbHVkZXNUeXBlKGJyb2FkLCBzcGVjaWZpYykge1xuICByZXR1cm4gKGJyb2FkICYgc3BlY2lmaWMpID09PSBzcGVjaWZpYztcbn1cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gb25lVHlwZSBPbmUgdHlwZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvdGhlclR5cGUgQW5vdGhlciB0eXBlLlxuICogQHJldHVybiB7Ym9vbGVhbn0gVGhlIHNldCBvZiB0eXBlcyBvdmVybGFwIChzaGFyZSBhIGNvbW1vbiBzcGVjaWZpYyB0eXBlKVxuICovXG5leHBvcnQgZnVuY3Rpb24gb3ZlcmxhcHNUeXBlKG9uZVR5cGUsIG90aGVyVHlwZSkge1xuICByZXR1cm4gISEob25lVHlwZSAmIG90aGVyVHlwZSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IHR5cGUgVGhlIHR5cGUuXG4gKiBAcGFyYW0ge251bWJlcn0gZXhwZWN0ZWQgVGhlIGV4cGVjdGVkIHR5cGUuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUaGUgZ2l2ZW4gdHlwZSBpcyBleGFjdGx5IHRoZSBleHBlY3RlZCB0eXBlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNUeXBlKHR5cGUsIGV4cGVjdGVkKSB7XG4gIHJldHVybiB0eXBlID09PSBleHBlY3RlZDtcbn1cblxuLyoqXG4gKiBAdHlwZWRlZiB7Ym9vbGVhbnxudW1iZXJ8c3RyaW5nfEFycmF5PG51bWJlcj59IExpdGVyYWxWYWx1ZVxuICovXG5cbmV4cG9ydCBjbGFzcyBMaXRlcmFsRXhwcmVzc2lvbiB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gdHlwZSBUaGUgdmFsdWUgdHlwZS5cbiAgICogQHBhcmFtIHtMaXRlcmFsVmFsdWV9IHZhbHVlIFRoZSBsaXRlcmFsIHZhbHVlLlxuICAgKi9cbiAgY29uc3RydWN0b3IodHlwZSwgdmFsdWUpIHtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgQ2FsbEV4cHJlc3Npb24ge1xuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHR5cGUgVGhlIHJldHVybiB0eXBlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3BlcmF0b3IgVGhlIG9wZXJhdG9yLlxuICAgKiBAcGFyYW0gey4uLkV4cHJlc3Npb259IGFyZ3MgVGhlIGFyZ3VtZW50cy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHR5cGUsIG9wZXJhdG9yLCAuLi5hcmdzKSB7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLm9wZXJhdG9yID0gb3BlcmF0b3I7XG4gICAgdGhpcy5hcmdzID0gYXJncztcbiAgfVxufVxuXG4vKipcbiAqIEB0eXBlZGVmIHtMaXRlcmFsRXhwcmVzc2lvbnxDYWxsRXhwcmVzc2lvbn0gRXhwcmVzc2lvblxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gUGFyc2luZ0NvbnRleHRcbiAqIEBwcm9wZXJ0eSB7U2V0PHN0cmluZz59IHZhcmlhYmxlcyBWYXJpYWJsZXMgcmVmZXJlbmNlZCB3aXRoIHRoZSAndmFyJyBvcGVyYXRvci5cbiAqIEBwcm9wZXJ0eSB7U2V0PHN0cmluZz59IHByb3BlcnRpZXMgUHJvcGVydGllcyByZWZlcmVuY2VkIHdpdGggdGhlICdnZXQnIG9wZXJhdG9yLlxuICovXG5cbi8qKlxuICogQHJldHVybiB7UGFyc2luZ0NvbnRleHR9IEEgbmV3IHBhcnNpbmcgY29udGV4dC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG5ld1BhcnNpbmdDb250ZXh0KCkge1xuICByZXR1cm4ge1xuICAgIHZhcmlhYmxlczogbmV3IFNldCgpLFxuICAgIHByb3BlcnRpZXM6IG5ldyBTZXQoKSxcbiAgfTtcbn1cblxuLyoqXG4gKiBAdHlwZWRlZiB7TGl0ZXJhbFZhbHVlfEFycmF5fSBFbmNvZGVkRXhwcmVzc2lvblxuICovXG5cbi8qKlxuICogQHBhcmFtIHtFbmNvZGVkRXhwcmVzc2lvbn0gZW5jb2RlZCBUaGUgZW5jb2RlZCBleHByZXNzaW9uLlxuICogQHBhcmFtIHtQYXJzaW5nQ29udGV4dH0gY29udGV4dCBUaGUgcGFyc2luZyBjb250ZXh0LlxuICogQHJldHVybiB7RXhwcmVzc2lvbn0gVGhlIHBhcnNlZCBleHByZXNzaW9uIHJlc3VsdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlKGVuY29kZWQsIGNvbnRleHQpIHtcbiAgc3dpdGNoICh0eXBlb2YgZW5jb2RlZCkge1xuICAgIGNhc2UgJ2Jvb2xlYW4nOiB7XG4gICAgICByZXR1cm4gbmV3IExpdGVyYWxFeHByZXNzaW9uKEJvb2xlYW5UeXBlLCBlbmNvZGVkKTtcbiAgICB9XG4gICAgY2FzZSAnbnVtYmVyJzoge1xuICAgICAgcmV0dXJuIG5ldyBMaXRlcmFsRXhwcmVzc2lvbihOdW1iZXJUeXBlLCBlbmNvZGVkKTtcbiAgICB9XG4gICAgY2FzZSAnc3RyaW5nJzoge1xuICAgICAgcmV0dXJuIG5ldyBMaXRlcmFsRXhwcmVzc2lvbihTdHJpbmdUeXBlLCBlbmNvZGVkKTtcbiAgICB9XG4gICAgZGVmYXVsdDoge1xuICAgICAgLy8gcGFzc1xuICAgIH1cbiAgfVxuXG4gIGlmICghQXJyYXkuaXNBcnJheShlbmNvZGVkKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignRXhwcmVzc2lvbiBtdXN0IGJlIGFuIGFycmF5IG9yIGEgcHJpbWl0aXZlIHZhbHVlJyk7XG4gIH1cblxuICBpZiAoZW5jb2RlZC5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0VtcHR5IGV4cHJlc3Npb24nKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZW5jb2RlZFswXSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gcGFyc2VDYWxsRXhwcmVzc2lvbihlbmNvZGVkLCBjb250ZXh0KTtcbiAgfVxuXG4gIGZvciAoY29uc3QgaXRlbSBvZiBlbmNvZGVkKSB7XG4gICAgaWYgKHR5cGVvZiBpdGVtICE9PSAnbnVtYmVyJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBhbiBhcnJheSBvZiBudW1iZXJzJyk7XG4gICAgfVxuICB9XG5cbiAgbGV0IHR5cGUgPSBOdW1iZXJBcnJheVR5cGU7XG4gIGlmIChlbmNvZGVkLmxlbmd0aCA9PT0gMyB8fCBlbmNvZGVkLmxlbmd0aCA9PT0gNCkge1xuICAgIHR5cGUgfD0gQ29sb3JUeXBlO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBMaXRlcmFsRXhwcmVzc2lvbih0eXBlLCBlbmNvZGVkKTtcbn1cblxuLyoqXG4gKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgc3RyaW5nPn1cbiAqL1xuZXhwb3J0IGNvbnN0IE9wcyA9IHtcbiAgTnVtYmVyOiAnbnVtYmVyJyxcbiAgU3RyaW5nOiAnc3RyaW5nJyxcbiAgR2V0OiAnZ2V0JyxcbiAgVmFyOiAndmFyJyxcbiAgQW55OiAnYW55JyxcbiAgQWxsOiAnYWxsJyxcbiAgTm90OiAnIScsXG4gIFJlc29sdXRpb246ICdyZXNvbHV0aW9uJyxcbiAgRXF1YWw6ICc9PScsXG4gIE5vdEVxdWFsOiAnIT0nLFxuICBHcmVhdGVyVGhhbjogJz4nLFxuICBHcmVhdGVyVGhhbk9yRXF1YWxUbzogJz49JyxcbiAgTGVzc1RoYW46ICc8JyxcbiAgTGVzc1RoYW5PckVxdWFsVG86ICc8PScsXG4gIE11bHRpcGx5OiAnKicsXG4gIERpdmlkZTogJy8nLFxuICBBZGQ6ICcrJyxcbiAgU3VidHJhY3Q6ICctJyxcbiAgQ2xhbXA6ICdjbGFtcCcsXG4gIE1vZDogJyUnLFxuICBQb3c6ICdeJyxcbiAgQWJzOiAnYWJzJyxcbiAgRmxvb3I6ICdmbG9vcicsXG4gIENlaWw6ICdjZWlsJyxcbiAgUm91bmQ6ICdyb3VuZCcsXG4gIFNpbjogJ3NpbicsXG4gIENvczogJ2NvcycsXG4gIEF0YW46ICdhdGFuJyxcbiAgU3FydDogJ3NxcnQnLFxuICBNYXRjaDogJ21hdGNoJyxcbn07XG5cbi8qKlxuICogQHR5cGVkZWYge2Z1bmN0aW9uKEFycmF5LCBQYXJzaW5nQ29udGV4dCk6RXhwcmVzc2lvbn0gUGFyc2VyXG4gKi9cblxuLyoqXG4gKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgUGFyc2VyPn1cbiAqL1xuY29uc3QgcGFyc2VycyA9IHtcbiAgW09wcy5OdW1iZXJdOiBjcmVhdGVQYXJzZXIod2l0aEFyZ3MoMSwgSW5maW5pdHksIEFueVR5cGUpLCBOdW1iZXJUeXBlKSxcbiAgW09wcy5TdHJpbmddOiBjcmVhdGVQYXJzZXIod2l0aEFyZ3MoMSwgSW5maW5pdHksIEFueVR5cGUpLCBTdHJpbmdUeXBlKSxcbiAgW09wcy5HZXRdOiBjcmVhdGVQYXJzZXIod2l0aEdldEFyZ3MsIEFueVR5cGUpLFxuICBbT3BzLlZhcl06IGNyZWF0ZVBhcnNlcih3aXRoVmFyQXJncywgQW55VHlwZSksXG4gIFtPcHMuUmVzb2x1dGlvbl06IGNyZWF0ZVBhcnNlcih3aXRoTm9BcmdzLCBOdW1iZXJUeXBlKSxcbiAgW09wcy5BbnldOiBjcmVhdGVQYXJzZXIod2l0aEFyZ3MoMiwgSW5maW5pdHksIEJvb2xlYW5UeXBlKSwgQm9vbGVhblR5cGUpLFxuICBbT3BzLkFsbF06IGNyZWF0ZVBhcnNlcih3aXRoQXJncygyLCBJbmZpbml0eSwgQm9vbGVhblR5cGUpLCBCb29sZWFuVHlwZSksXG4gIFtPcHMuTm90XTogY3JlYXRlUGFyc2VyKHdpdGhBcmdzKDEsIDEsIEJvb2xlYW5UeXBlKSwgQm9vbGVhblR5cGUpLFxuICBbT3BzLkVxdWFsXTogY3JlYXRlUGFyc2VyKHdpdGhBcmdzKDIsIDIsIEFueVR5cGUpLCBCb29sZWFuVHlwZSksXG4gIFtPcHMuTm90RXF1YWxdOiBjcmVhdGVQYXJzZXIod2l0aEFyZ3MoMiwgMiwgQW55VHlwZSksIEJvb2xlYW5UeXBlKSxcbiAgW09wcy5HcmVhdGVyVGhhbl06IGNyZWF0ZVBhcnNlcih3aXRoQXJncygyLCAyLCBBbnlUeXBlKSwgQm9vbGVhblR5cGUpLFxuICBbT3BzLkdyZWF0ZXJUaGFuT3JFcXVhbFRvXTogY3JlYXRlUGFyc2VyKFxuICAgIHdpdGhBcmdzKDIsIDIsIEFueVR5cGUpLFxuICAgIEJvb2xlYW5UeXBlXG4gICksXG4gIFtPcHMuTGVzc1RoYW5dOiBjcmVhdGVQYXJzZXIod2l0aEFyZ3MoMiwgMiwgQW55VHlwZSksIEJvb2xlYW5UeXBlKSxcbiAgW09wcy5MZXNzVGhhbk9yRXF1YWxUb106IGNyZWF0ZVBhcnNlcih3aXRoQXJncygyLCAyLCBBbnlUeXBlKSwgQm9vbGVhblR5cGUpLFxuICBbT3BzLk11bHRpcGx5XTogY3JlYXRlUGFyc2VyKHdpdGhBcmdzKDIsIEluZmluaXR5LCBOdW1iZXJUeXBlKSwgTnVtYmVyVHlwZSksXG4gIFtPcHMuRGl2aWRlXTogY3JlYXRlUGFyc2VyKHdpdGhBcmdzKDIsIDIsIE51bWJlclR5cGUpLCBOdW1iZXJUeXBlKSxcbiAgW09wcy5BZGRdOiBjcmVhdGVQYXJzZXIod2l0aEFyZ3MoMiwgSW5maW5pdHksIE51bWJlclR5cGUpLCBOdW1iZXJUeXBlKSxcbiAgW09wcy5TdWJ0cmFjdF06IGNyZWF0ZVBhcnNlcih3aXRoQXJncygyLCAyLCBOdW1iZXJUeXBlKSwgTnVtYmVyVHlwZSksXG4gIFtPcHMuQ2xhbXBdOiBjcmVhdGVQYXJzZXIod2l0aEFyZ3MoMywgMywgTnVtYmVyVHlwZSksIE51bWJlclR5cGUpLFxuICBbT3BzLk1vZF06IGNyZWF0ZVBhcnNlcih3aXRoQXJncygyLCAyLCBOdW1iZXJUeXBlKSwgTnVtYmVyVHlwZSksXG4gIFtPcHMuUG93XTogY3JlYXRlUGFyc2VyKHdpdGhBcmdzKDIsIDIsIE51bWJlclR5cGUpLCBOdW1iZXJUeXBlKSxcbiAgW09wcy5BYnNdOiBjcmVhdGVQYXJzZXIod2l0aEFyZ3MoMSwgMSwgTnVtYmVyVHlwZSksIE51bWJlclR5cGUpLFxuICBbT3BzLkZsb29yXTogY3JlYXRlUGFyc2VyKHdpdGhBcmdzKDEsIDEsIE51bWJlclR5cGUpLCBOdW1iZXJUeXBlKSxcbiAgW09wcy5DZWlsXTogY3JlYXRlUGFyc2VyKHdpdGhBcmdzKDEsIDEsIE51bWJlclR5cGUpLCBOdW1iZXJUeXBlKSxcbiAgW09wcy5Sb3VuZF06IGNyZWF0ZVBhcnNlcih3aXRoQXJncygxLCAxLCBOdW1iZXJUeXBlKSwgTnVtYmVyVHlwZSksXG4gIFtPcHMuU2luXTogY3JlYXRlUGFyc2VyKHdpdGhBcmdzKDEsIDEsIE51bWJlclR5cGUpLCBOdW1iZXJUeXBlKSxcbiAgW09wcy5Db3NdOiBjcmVhdGVQYXJzZXIod2l0aEFyZ3MoMSwgMSwgTnVtYmVyVHlwZSksIE51bWJlclR5cGUpLFxuICBbT3BzLkF0YW5dOiBjcmVhdGVQYXJzZXIod2l0aEFyZ3MoMSwgMiwgTnVtYmVyVHlwZSksIE51bWJlclR5cGUpLFxuICBbT3BzLlNxcnRdOiBjcmVhdGVQYXJzZXIod2l0aEFyZ3MoMSwgMSwgTnVtYmVyVHlwZSksIE51bWJlclR5cGUpLFxuICBbT3BzLk1hdGNoXTogY3JlYXRlUGFyc2VyKFxuICAgIHdpdGhBcmdzKDQsIEluZmluaXR5LCBTdHJpbmdUeXBlIHwgTnVtYmVyVHlwZSksXG4gICAgQW55VHlwZVxuICApLFxufTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7ZnVuY3Rpb24oQXJyYXksIFBhcnNpbmdDb250ZXh0KTpBcnJheTxFeHByZXNzaW9uPn0gQXJnVmFsaWRhdG9yXG4gKi9cblxuLyoqXG4gKiBAdHlwZSBBcmdWYWxpZGF0b3JcbiAqL1xuZnVuY3Rpb24gd2l0aEdldEFyZ3MoZW5jb2RlZCwgY29udGV4dCkge1xuICBpZiAoZW5jb2RlZC5sZW5ndGggIT09IDIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIDEgYXJndW1lbnQgZm9yIGdldCBvcGVyYXRpb24nKTtcbiAgfVxuICBjb25zdCBhcmcgPSBwYXJzZShlbmNvZGVkWzFdLCBjb250ZXh0KTtcbiAgaWYgKCEoYXJnIGluc3RhbmNlb2YgTGl0ZXJhbEV4cHJlc3Npb24pKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBhIGxpdGVyYWwgYXJndW1lbnQgZm9yIGdldCBvcGVyYXRpb24nKTtcbiAgfVxuICBpZiAodHlwZW9mIGFyZy52YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGEgc3RyaW5nIGFyZ3VtZW50IGZvciBnZXQgb3BlcmF0aW9uJyk7XG4gIH1cbiAgY29udGV4dC5wcm9wZXJ0aWVzLmFkZChhcmcudmFsdWUpO1xuICByZXR1cm4gW2FyZ107XG59XG5cbi8qKlxuICogQHR5cGUgQXJnVmFsaWRhdG9yXG4gKi9cbmZ1bmN0aW9uIHdpdGhWYXJBcmdzKGVuY29kZWQsIGNvbnRleHQpIHtcbiAgaWYgKGVuY29kZWQubGVuZ3RoICE9PSAyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCAxIGFyZ3VtZW50IGZvciB2YXIgb3BlcmF0aW9uJyk7XG4gIH1cbiAgY29uc3QgYXJnID0gcGFyc2UoZW5jb2RlZFsxXSwgY29udGV4dCk7XG4gIGlmICghKGFyZyBpbnN0YW5jZW9mIExpdGVyYWxFeHByZXNzaW9uKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgYSBsaXRlcmFsIGFyZ3VtZW50IGZvciB2YXIgb3BlcmF0aW9uJyk7XG4gIH1cbiAgaWYgKHR5cGVvZiBhcmcudmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBhIHN0cmluZyBhcmd1bWVudCBmb3IgZ2V0IG9wZXJhdGlvbicpO1xuICB9XG4gIGNvbnRleHQudmFyaWFibGVzLmFkZChhcmcudmFsdWUpO1xuICByZXR1cm4gW2FyZ107XG59XG5cbi8qKlxuICogQHR5cGUgQXJnVmFsaWRhdG9yXG4gKi9cbmZ1bmN0aW9uIHdpdGhOb0FyZ3MoZW5jb2RlZCwgY29udGV4dCkge1xuICBjb25zdCBvcGVyYXRpb24gPSBlbmNvZGVkWzBdO1xuICBpZiAoZW5jb2RlZC5sZW5ndGggIT09IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIG5vIGFyZ3VtZW50cyBmb3IgJHtvcGVyYXRpb259IG9wZXJhdGlvbmApO1xuICB9XG4gIHJldHVybiBbXTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gbWluQXJncyBUaGUgbWluaW11bSBudW1iZXIgb2YgYXJndW1lbnRzLlxuICogQHBhcmFtIHtudW1iZXJ9IG1heEFyZ3MgVGhlIG1heGltdW0gbnVtYmVyIG9mIGFyZ3VtZW50cy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBhcmdUeXBlIFRoZSBhcmd1bWVudCB0eXBlLlxuICogQHJldHVybiB7QXJnVmFsaWRhdG9yfSBUaGUgYXJndW1lbnQgdmFsaWRhdG9yXG4gKi9cbmZ1bmN0aW9uIHdpdGhBcmdzKG1pbkFyZ3MsIG1heEFyZ3MsIGFyZ1R5cGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChlbmNvZGVkLCBjb250ZXh0KSB7XG4gICAgY29uc3Qgb3BlcmF0aW9uID0gZW5jb2RlZFswXTtcbiAgICBjb25zdCBhcmdDb3VudCA9IGVuY29kZWQubGVuZ3RoIC0gMTtcbiAgICBpZiAobWluQXJncyA9PT0gbWF4QXJncykge1xuICAgICAgaWYgKGFyZ0NvdW50ICE9PSBtaW5BcmdzKSB7XG4gICAgICAgIGNvbnN0IHBsdXJhbCA9IG1pbkFyZ3MgPT09IDEgPyAnJyA6ICdzJztcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBFeHBlY3RlZCAke21pbkFyZ3N9IGFyZ3VtZW50JHtwbHVyYWx9IGZvciBvcGVyYXRpb24gJHtvcGVyYXRpb259LCBnb3QgJHthcmdDb3VudH1gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChhcmdDb3VudCA8IG1pbkFyZ3MgfHwgYXJnQ291bnQgPiBtYXhBcmdzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBFeHBlY3RlZCAke21pbkFyZ3N9IHRvICR7bWF4QXJnc30gYXJndW1lbnRzIGZvciBvcGVyYXRpb24gJHtvcGVyYXRpb259LCBnb3QgJHthcmdDb3VudH1gXG4gICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtBcnJheTxFeHByZXNzaW9uPn1cbiAgICAgKi9cbiAgICBjb25zdCBhcmdzID0gbmV3IEFycmF5KGFyZ0NvdW50KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyZ0NvdW50OyArK2kpIHtcbiAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSBwYXJzZShlbmNvZGVkW2kgKyAxXSwgY29udGV4dCk7XG4gICAgICBpZiAoIW92ZXJsYXBzVHlwZShhcmdUeXBlLCBleHByZXNzaW9uLnR5cGUpKSB7XG4gICAgICAgIGNvbnN0IGdvdFR5cGUgPSB0eXBlTmFtZShhcmdUeXBlKTtcbiAgICAgICAgY29uc3QgZXhwZWN0ZWRUeXBlID0gdHlwZU5hbWUoZXhwcmVzc2lvbi50eXBlKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBVbmV4cGVjdGVkIHR5cGUgZm9yIGFyZ3VtZW50ICR7aX0gb2YgJHtvcGVyYXRpb259IG9wZXJhdGlvbmAgK1xuICAgICAgICAgICAgYCA6IGdvdCAke2dvdFR5cGV9IGJ1dCBleHBlY3RlZCAke2V4cGVjdGVkVHlwZX1gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBhcmdzW2ldID0gZXhwcmVzc2lvbjtcbiAgICB9XG5cbiAgICByZXR1cm4gYXJncztcbiAgfTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0FyZ1ZhbGlkYXRvcn0gYXJnVmFsaWRhdG9yIFRoZSBhcmd1bWVudCB2YWxpZGF0b3IuXG4gKiBAcGFyYW0ge251bWJlcn0gcmV0dXJuVHlwZSBUaGUgcmV0dXJuIHR5cGUuXG4gKiBAcmV0dXJuIHtQYXJzZXJ9IFRoZSBwYXJzZXIuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVBhcnNlcihhcmdWYWxpZGF0b3IsIHJldHVyblR5cGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChlbmNvZGVkLCBjb250ZXh0KSB7XG4gICAgY29uc3Qgb3BlcmF0b3IgPSBlbmNvZGVkWzBdO1xuICAgIGNvbnN0IGFyZ3MgPSBhcmdWYWxpZGF0b3IoZW5jb2RlZCwgY29udGV4dCk7XG4gICAgcmV0dXJuIG5ldyBDYWxsRXhwcmVzc2lvbihyZXR1cm5UeXBlLCBvcGVyYXRvciwgLi4uYXJncyk7XG4gIH07XG59XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheX0gZW5jb2RlZCBUaGUgZW5jb2RlZCBleHByZXNzaW9uLlxuICogQHBhcmFtIHtQYXJzaW5nQ29udGV4dH0gY29udGV4dCBUaGUgcGFyc2luZyBjb250ZXh0LlxuICogQHJldHVybiB7RXhwcmVzc2lvbn0gVGhlIHBhcnNlZCBleHByZXNzaW9uLlxuICovXG5mdW5jdGlvbiBwYXJzZUNhbGxFeHByZXNzaW9uKGVuY29kZWQsIGNvbnRleHQpIHtcbiAgY29uc3Qgb3BlcmF0b3IgPSBlbmNvZGVkWzBdO1xuXG4gIGNvbnN0IHBhcnNlciA9IHBhcnNlcnNbb3BlcmF0b3JdO1xuICBpZiAoIXBhcnNlcikge1xuICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBvcGVyYXRvcjogJHtvcGVyYXRvcn1gKTtcbiAgfVxuICByZXR1cm4gcGFyc2VyKGVuY29kZWQsIGNvbnRleHQpO1xufVxuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2V4dGVudFxuICovXG5pbXBvcnQgUmVsYXRpb25zaGlwIGZyb20gJy4vZXh0ZW50L1JlbGF0aW9uc2hpcC5qcyc7XG5cbi8qKlxuICogQW4gYXJyYXkgb2YgbnVtYmVycyByZXByZXNlbnRpbmcgYW4gZXh0ZW50OiBgW21pbngsIG1pbnksIG1heHgsIG1heHldYC5cbiAqIEB0eXBlZGVmIHtBcnJheTxudW1iZXI+fSBFeHRlbnRcbiAqIEBhcGlcbiAqL1xuXG4vKipcbiAqIEV4dGVudCBjb3JuZXIuXG4gKiBAdHlwZWRlZiB7J2JvdHRvbS1sZWZ0JyB8ICdib3R0b20tcmlnaHQnIHwgJ3RvcC1sZWZ0JyB8ICd0b3AtcmlnaHQnfSBDb3JuZXJcbiAqL1xuXG4vKipcbiAqIEJ1aWxkIGFuIGV4dGVudCB0aGF0IGluY2x1ZGVzIGFsbCBnaXZlbiBjb29yZGluYXRlcy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PGltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlPn0gY29vcmRpbmF0ZXMgQ29vcmRpbmF0ZXMuXG4gKiBAcmV0dXJuIHtFeHRlbnR9IEJvdW5kaW5nIGV4dGVudC5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJvdW5kaW5nRXh0ZW50KGNvb3JkaW5hdGVzKSB7XG4gIGNvbnN0IGV4dGVudCA9IGNyZWF0ZUVtcHR5KCk7XG4gIGZvciAobGV0IGkgPSAwLCBpaSA9IGNvb3JkaW5hdGVzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICBleHRlbmRDb29yZGluYXRlKGV4dGVudCwgY29vcmRpbmF0ZXNbaV0pO1xuICB9XG4gIHJldHVybiBleHRlbnQ7XG59XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSB4cyBYcy5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0geXMgWXMuXG4gKiBAcGFyYW0ge0V4dGVudH0gW2Rlc3RdIERlc3RpbmF0aW9uIGV4dGVudC5cbiAqIEBwcml2YXRlXG4gKiBAcmV0dXJuIHtFeHRlbnR9IEV4dGVudC5cbiAqL1xuZnVuY3Rpb24gX2JvdW5kaW5nRXh0ZW50WFlzKHhzLCB5cywgZGVzdCkge1xuICBjb25zdCBtaW5YID0gTWF0aC5taW4uYXBwbHkobnVsbCwgeHMpO1xuICBjb25zdCBtaW5ZID0gTWF0aC5taW4uYXBwbHkobnVsbCwgeXMpO1xuICBjb25zdCBtYXhYID0gTWF0aC5tYXguYXBwbHkobnVsbCwgeHMpO1xuICBjb25zdCBtYXhZID0gTWF0aC5tYXguYXBwbHkobnVsbCwgeXMpO1xuICByZXR1cm4gY3JlYXRlT3JVcGRhdGUobWluWCwgbWluWSwgbWF4WCwgbWF4WSwgZGVzdCk7XG59XG5cbi8qKlxuICogUmV0dXJuIGV4dGVudCBpbmNyZWFzZWQgYnkgdGhlIHByb3ZpZGVkIHZhbHVlLlxuICogQHBhcmFtIHtFeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVGhlIGFtb3VudCBieSB3aGljaCB0aGUgZXh0ZW50IHNob3VsZCBiZSBidWZmZXJlZC5cbiAqIEBwYXJhbSB7RXh0ZW50fSBbZGVzdF0gRXh0ZW50LlxuICogQHJldHVybiB7RXh0ZW50fSBFeHRlbnQuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBidWZmZXIoZXh0ZW50LCB2YWx1ZSwgZGVzdCkge1xuICBpZiAoZGVzdCkge1xuICAgIGRlc3RbMF0gPSBleHRlbnRbMF0gLSB2YWx1ZTtcbiAgICBkZXN0WzFdID0gZXh0ZW50WzFdIC0gdmFsdWU7XG4gICAgZGVzdFsyXSA9IGV4dGVudFsyXSArIHZhbHVlO1xuICAgIGRlc3RbM10gPSBleHRlbnRbM10gKyB2YWx1ZTtcbiAgICByZXR1cm4gZGVzdDtcbiAgfVxuICByZXR1cm4gW1xuICAgIGV4dGVudFswXSAtIHZhbHVlLFxuICAgIGV4dGVudFsxXSAtIHZhbHVlLFxuICAgIGV4dGVudFsyXSArIHZhbHVlLFxuICAgIGV4dGVudFszXSArIHZhbHVlLFxuICBdO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiBhbiBleHRlbnQuXG4gKlxuICogQHBhcmFtIHtFeHRlbnR9IGV4dGVudCBFeHRlbnQgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge0V4dGVudH0gW2Rlc3RdIEV4dGVudC5cbiAqIEByZXR1cm4ge0V4dGVudH0gVGhlIGNsb25lLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xvbmUoZXh0ZW50LCBkZXN0KSB7XG4gIGlmIChkZXN0KSB7XG4gICAgZGVzdFswXSA9IGV4dGVudFswXTtcbiAgICBkZXN0WzFdID0gZXh0ZW50WzFdO1xuICAgIGRlc3RbMl0gPSBleHRlbnRbMl07XG4gICAgZGVzdFszXSA9IGV4dGVudFszXTtcbiAgICByZXR1cm4gZGVzdDtcbiAgfVxuICByZXR1cm4gZXh0ZW50LnNsaWNlKCk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtFeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcGFyYW0ge251bWJlcn0geCBYLlxuICogQHBhcmFtIHtudW1iZXJ9IHkgWS5cbiAqIEByZXR1cm4ge251bWJlcn0gQ2xvc2VzdCBzcXVhcmVkIGRpc3RhbmNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xvc2VzdFNxdWFyZWREaXN0YW5jZVhZKGV4dGVudCwgeCwgeSkge1xuICBsZXQgZHgsIGR5O1xuICBpZiAoeCA8IGV4dGVudFswXSkge1xuICAgIGR4ID0gZXh0ZW50WzBdIC0geDtcbiAgfSBlbHNlIGlmIChleHRlbnRbMl0gPCB4KSB7XG4gICAgZHggPSB4IC0gZXh0ZW50WzJdO1xuICB9IGVsc2Uge1xuICAgIGR4ID0gMDtcbiAgfVxuICBpZiAoeSA8IGV4dGVudFsxXSkge1xuICAgIGR5ID0gZXh0ZW50WzFdIC0geTtcbiAgfSBlbHNlIGlmIChleHRlbnRbM10gPCB5KSB7XG4gICAgZHkgPSB5IC0gZXh0ZW50WzNdO1xuICB9IGVsc2Uge1xuICAgIGR5ID0gMDtcbiAgfVxuICByZXR1cm4gZHggKiBkeCArIGR5ICogZHk7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIHBhc3NlZCBjb29yZGluYXRlIGlzIGNvbnRhaW5lZCBvciBvbiB0aGUgZWRnZSBvZiB0aGUgZXh0ZW50LlxuICpcbiAqIEBwYXJhbSB7RXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gY29vcmRpbmF0ZSBDb29yZGluYXRlLlxuICogQHJldHVybiB7Ym9vbGVhbn0gVGhlIGNvb3JkaW5hdGUgaXMgY29udGFpbmVkIGluIHRoZSBleHRlbnQuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb250YWluc0Nvb3JkaW5hdGUoZXh0ZW50LCBjb29yZGluYXRlKSB7XG4gIHJldHVybiBjb250YWluc1hZKGV4dGVudCwgY29vcmRpbmF0ZVswXSwgY29vcmRpbmF0ZVsxXSk7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgb25lIGV4dGVudCBjb250YWlucyBhbm90aGVyLlxuICpcbiAqIEFuIGV4dGVudCBpcyBkZWVtZWQgY29udGFpbmVkIGlmIGl0IGxpZXMgY29tcGxldGVseSB3aXRoaW4gdGhlIG90aGVyIGV4dGVudCxcbiAqIGluY2x1ZGluZyBpZiB0aGV5IHNoYXJlIG9uZSBvciBtb3JlIGVkZ2VzLlxuICpcbiAqIEBwYXJhbSB7RXh0ZW50fSBleHRlbnQxIEV4dGVudCAxLlxuICogQHBhcmFtIHtFeHRlbnR9IGV4dGVudDIgRXh0ZW50IDIuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUaGUgc2Vjb25kIGV4dGVudCBpcyBjb250YWluZWQgYnkgb3Igb24gdGhlIGVkZ2Ugb2YgdGhlXG4gKiAgICAgZmlyc3QuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb250YWluc0V4dGVudChleHRlbnQxLCBleHRlbnQyKSB7XG4gIHJldHVybiAoXG4gICAgZXh0ZW50MVswXSA8PSBleHRlbnQyWzBdICYmXG4gICAgZXh0ZW50MlsyXSA8PSBleHRlbnQxWzJdICYmXG4gICAgZXh0ZW50MVsxXSA8PSBleHRlbnQyWzFdICYmXG4gICAgZXh0ZW50MlszXSA8PSBleHRlbnQxWzNdXG4gICk7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIHBhc3NlZCBjb29yZGluYXRlIGlzIGNvbnRhaW5lZCBvciBvbiB0aGUgZWRnZSBvZiB0aGUgZXh0ZW50LlxuICpcbiAqIEBwYXJhbSB7RXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICogQHBhcmFtIHtudW1iZXJ9IHggWCBjb29yZGluYXRlLlxuICogQHBhcmFtIHtudW1iZXJ9IHkgWSBjb29yZGluYXRlLlxuICogQHJldHVybiB7Ym9vbGVhbn0gVGhlIHgsIHkgdmFsdWVzIGFyZSBjb250YWluZWQgaW4gdGhlIGV4dGVudC5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbnRhaW5zWFkoZXh0ZW50LCB4LCB5KSB7XG4gIHJldHVybiBleHRlbnRbMF0gPD0geCAmJiB4IDw9IGV4dGVudFsyXSAmJiBleHRlbnRbMV0gPD0geSAmJiB5IDw9IGV4dGVudFszXTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHJlbGF0aW9uc2hpcCBiZXR3ZWVuIGEgY29vcmRpbmF0ZSBhbmQgZXh0ZW50LlxuICogQHBhcmFtIHtFeHRlbnR9IGV4dGVudCBUaGUgZXh0ZW50LlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gY29vcmRpbmF0ZSBUaGUgY29vcmRpbmF0ZS5cbiAqIEByZXR1cm4ge2ltcG9ydChcIi4vZXh0ZW50L1JlbGF0aW9uc2hpcC5qc1wiKS5kZWZhdWx0fSBUaGUgcmVsYXRpb25zaGlwIChiaXR3aXNlIGNvbXBhcmUgd2l0aFxuICogICAgIGltcG9ydChcIi4vZXh0ZW50L1JlbGF0aW9uc2hpcC5qc1wiKS5SZWxhdGlvbnNoaXApLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29vcmRpbmF0ZVJlbGF0aW9uc2hpcChleHRlbnQsIGNvb3JkaW5hdGUpIHtcbiAgY29uc3QgbWluWCA9IGV4dGVudFswXTtcbiAgY29uc3QgbWluWSA9IGV4dGVudFsxXTtcbiAgY29uc3QgbWF4WCA9IGV4dGVudFsyXTtcbiAgY29uc3QgbWF4WSA9IGV4dGVudFszXTtcbiAgY29uc3QgeCA9IGNvb3JkaW5hdGVbMF07XG4gIGNvbnN0IHkgPSBjb29yZGluYXRlWzFdO1xuICBsZXQgcmVsYXRpb25zaGlwID0gUmVsYXRpb25zaGlwLlVOS05PV047XG4gIGlmICh4IDwgbWluWCkge1xuICAgIHJlbGF0aW9uc2hpcCA9IHJlbGF0aW9uc2hpcCB8IFJlbGF0aW9uc2hpcC5MRUZUO1xuICB9IGVsc2UgaWYgKHggPiBtYXhYKSB7XG4gICAgcmVsYXRpb25zaGlwID0gcmVsYXRpb25zaGlwIHwgUmVsYXRpb25zaGlwLlJJR0hUO1xuICB9XG4gIGlmICh5IDwgbWluWSkge1xuICAgIHJlbGF0aW9uc2hpcCA9IHJlbGF0aW9uc2hpcCB8IFJlbGF0aW9uc2hpcC5CRUxPVztcbiAgfSBlbHNlIGlmICh5ID4gbWF4WSkge1xuICAgIHJlbGF0aW9uc2hpcCA9IHJlbGF0aW9uc2hpcCB8IFJlbGF0aW9uc2hpcC5BQk9WRTtcbiAgfVxuICBpZiAocmVsYXRpb25zaGlwID09PSBSZWxhdGlvbnNoaXAuVU5LTk9XTikge1xuICAgIHJlbGF0aW9uc2hpcCA9IFJlbGF0aW9uc2hpcC5JTlRFUlNFQ1RJTkc7XG4gIH1cbiAgcmV0dXJuIHJlbGF0aW9uc2hpcDtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYW4gZW1wdHkgZXh0ZW50LlxuICogQHJldHVybiB7RXh0ZW50fSBFbXB0eSBleHRlbnQuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVFbXB0eSgpIHtcbiAgcmV0dXJuIFtJbmZpbml0eSwgSW5maW5pdHksIC1JbmZpbml0eSwgLUluZmluaXR5XTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgZXh0ZW50IG9yIHVwZGF0ZSB0aGUgcHJvdmlkZWQgZXh0ZW50LlxuICogQHBhcmFtIHtudW1iZXJ9IG1pblggTWluaW11bSBYLlxuICogQHBhcmFtIHtudW1iZXJ9IG1pblkgTWluaW11bSBZLlxuICogQHBhcmFtIHtudW1iZXJ9IG1heFggTWF4aW11bSBYLlxuICogQHBhcmFtIHtudW1iZXJ9IG1heFkgTWF4aW11bSBZLlxuICogQHBhcmFtIHtFeHRlbnR9IFtkZXN0XSBEZXN0aW5hdGlvbiBleHRlbnQuXG4gKiBAcmV0dXJuIHtFeHRlbnR9IEV4dGVudC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZU9yVXBkYXRlKG1pblgsIG1pblksIG1heFgsIG1heFksIGRlc3QpIHtcbiAgaWYgKGRlc3QpIHtcbiAgICBkZXN0WzBdID0gbWluWDtcbiAgICBkZXN0WzFdID0gbWluWTtcbiAgICBkZXN0WzJdID0gbWF4WDtcbiAgICBkZXN0WzNdID0gbWF4WTtcbiAgICByZXR1cm4gZGVzdDtcbiAgfVxuICByZXR1cm4gW21pblgsIG1pblksIG1heFgsIG1heFldO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBlbXB0eSBleHRlbnQgb3IgbWFrZSB0aGUgcHJvdmlkZWQgb25lIGVtcHR5LlxuICogQHBhcmFtIHtFeHRlbnR9IFtkZXN0XSBFeHRlbnQuXG4gKiBAcmV0dXJuIHtFeHRlbnR9IEV4dGVudC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZU9yVXBkYXRlRW1wdHkoZGVzdCkge1xuICByZXR1cm4gY3JlYXRlT3JVcGRhdGUoSW5maW5pdHksIEluZmluaXR5LCAtSW5maW5pdHksIC1JbmZpbml0eSwgZGVzdCk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gY29vcmRpbmF0ZSBDb29yZGluYXRlLlxuICogQHBhcmFtIHtFeHRlbnR9IFtkZXN0XSBFeHRlbnQuXG4gKiBAcmV0dXJuIHtFeHRlbnR9IEV4dGVudC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZU9yVXBkYXRlRnJvbUNvb3JkaW5hdGUoY29vcmRpbmF0ZSwgZGVzdCkge1xuICBjb25zdCB4ID0gY29vcmRpbmF0ZVswXTtcbiAgY29uc3QgeSA9IGNvb3JkaW5hdGVbMV07XG4gIHJldHVybiBjcmVhdGVPclVwZGF0ZSh4LCB5LCB4LCB5LCBkZXN0KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PGltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlPn0gY29vcmRpbmF0ZXMgQ29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge0V4dGVudH0gW2Rlc3RdIEV4dGVudC5cbiAqIEByZXR1cm4ge0V4dGVudH0gRXh0ZW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlT3JVcGRhdGVGcm9tQ29vcmRpbmF0ZXMoY29vcmRpbmF0ZXMsIGRlc3QpIHtcbiAgY29uc3QgZXh0ZW50ID0gY3JlYXRlT3JVcGRhdGVFbXB0eShkZXN0KTtcbiAgcmV0dXJuIGV4dGVuZENvb3JkaW5hdGVzKGV4dGVudCwgY29vcmRpbmF0ZXMpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgRW5kLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcGFyYW0ge0V4dGVudH0gW2Rlc3RdIEV4dGVudC5cbiAqIEByZXR1cm4ge0V4dGVudH0gRXh0ZW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlT3JVcGRhdGVGcm9tRmxhdENvb3JkaW5hdGVzKFxuICBmbGF0Q29vcmRpbmF0ZXMsXG4gIG9mZnNldCxcbiAgZW5kLFxuICBzdHJpZGUsXG4gIGRlc3Rcbikge1xuICBjb25zdCBleHRlbnQgPSBjcmVhdGVPclVwZGF0ZUVtcHR5KGRlc3QpO1xuICByZXR1cm4gZXh0ZW5kRmxhdENvb3JkaW5hdGVzKGV4dGVudCwgZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZCwgc3RyaWRlKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PEFycmF5PGltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlPj59IHJpbmdzIFJpbmdzLlxuICogQHBhcmFtIHtFeHRlbnR9IFtkZXN0XSBFeHRlbnQuXG4gKiBAcmV0dXJuIHtFeHRlbnR9IEV4dGVudC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZU9yVXBkYXRlRnJvbVJpbmdzKHJpbmdzLCBkZXN0KSB7XG4gIGNvbnN0IGV4dGVudCA9IGNyZWF0ZU9yVXBkYXRlRW1wdHkoZGVzdCk7XG4gIHJldHVybiBleHRlbmRSaW5ncyhleHRlbnQsIHJpbmdzKTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgdHdvIGV4dGVudHMgYXJlIGVxdWl2YWxlbnQuXG4gKiBAcGFyYW0ge0V4dGVudH0gZXh0ZW50MSBFeHRlbnQgMS5cbiAqIEBwYXJhbSB7RXh0ZW50fSBleHRlbnQyIEV4dGVudCAyLlxuICogQHJldHVybiB7Ym9vbGVhbn0gVGhlIHR3byBleHRlbnRzIGFyZSBlcXVpdmFsZW50LlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gZXF1YWxzKGV4dGVudDEsIGV4dGVudDIpIHtcbiAgcmV0dXJuIChcbiAgICBleHRlbnQxWzBdID09IGV4dGVudDJbMF0gJiZcbiAgICBleHRlbnQxWzJdID09IGV4dGVudDJbMl0gJiZcbiAgICBleHRlbnQxWzFdID09IGV4dGVudDJbMV0gJiZcbiAgICBleHRlbnQxWzNdID09IGV4dGVudDJbM11cbiAgKTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgdHdvIGV4dGVudHMgYXJlIGFwcHJveGltYXRlbHkgZXF1aXZhbGVudC5cbiAqIEBwYXJhbSB7RXh0ZW50fSBleHRlbnQxIEV4dGVudCAxLlxuICogQHBhcmFtIHtFeHRlbnR9IGV4dGVudDIgRXh0ZW50IDIuXG4gKiBAcGFyYW0ge251bWJlcn0gdG9sZXJhbmNlIFRvbGVyYW5jZSBpbiBleHRlbnQgY29vcmRpbmF0ZSB1bml0cy5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSB0d28gZXh0ZW50cyBkaWZmZXIgYnkgbGVzcyB0aGFuIHRoZSB0b2xlcmFuY2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhcHByb3hpbWF0ZWx5RXF1YWxzKGV4dGVudDEsIGV4dGVudDIsIHRvbGVyYW5jZSkge1xuICByZXR1cm4gKFxuICAgIE1hdGguYWJzKGV4dGVudDFbMF0gLSBleHRlbnQyWzBdKSA8IHRvbGVyYW5jZSAmJlxuICAgIE1hdGguYWJzKGV4dGVudDFbMl0gLSBleHRlbnQyWzJdKSA8IHRvbGVyYW5jZSAmJlxuICAgIE1hdGguYWJzKGV4dGVudDFbMV0gLSBleHRlbnQyWzFdKSA8IHRvbGVyYW5jZSAmJlxuICAgIE1hdGguYWJzKGV4dGVudDFbM10gLSBleHRlbnQyWzNdKSA8IHRvbGVyYW5jZVxuICApO1xufVxuXG4vKipcbiAqIE1vZGlmeSBhbiBleHRlbnQgdG8gaW5jbHVkZSBhbm90aGVyIGV4dGVudC5cbiAqIEBwYXJhbSB7RXh0ZW50fSBleHRlbnQxIFRoZSBleHRlbnQgdG8gYmUgbW9kaWZpZWQuXG4gKiBAcGFyYW0ge0V4dGVudH0gZXh0ZW50MiBUaGUgZXh0ZW50IHRoYXQgd2lsbCBiZSBpbmNsdWRlZCBpbiB0aGUgZmlyc3QuXG4gKiBAcmV0dXJuIHtFeHRlbnR9IEEgcmVmZXJlbmNlIHRvIHRoZSBmaXJzdCAoZXh0ZW5kZWQpIGV4dGVudC5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4dGVuZChleHRlbnQxLCBleHRlbnQyKSB7XG4gIGlmIChleHRlbnQyWzBdIDwgZXh0ZW50MVswXSkge1xuICAgIGV4dGVudDFbMF0gPSBleHRlbnQyWzBdO1xuICB9XG4gIGlmIChleHRlbnQyWzJdID4gZXh0ZW50MVsyXSkge1xuICAgIGV4dGVudDFbMl0gPSBleHRlbnQyWzJdO1xuICB9XG4gIGlmIChleHRlbnQyWzFdIDwgZXh0ZW50MVsxXSkge1xuICAgIGV4dGVudDFbMV0gPSBleHRlbnQyWzFdO1xuICB9XG4gIGlmIChleHRlbnQyWzNdID4gZXh0ZW50MVszXSkge1xuICAgIGV4dGVudDFbM10gPSBleHRlbnQyWzNdO1xuICB9XG4gIHJldHVybiBleHRlbnQxO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gY29vcmRpbmF0ZSBDb29yZGluYXRlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZXh0ZW5kQ29vcmRpbmF0ZShleHRlbnQsIGNvb3JkaW5hdGUpIHtcbiAgaWYgKGNvb3JkaW5hdGVbMF0gPCBleHRlbnRbMF0pIHtcbiAgICBleHRlbnRbMF0gPSBjb29yZGluYXRlWzBdO1xuICB9XG4gIGlmIChjb29yZGluYXRlWzBdID4gZXh0ZW50WzJdKSB7XG4gICAgZXh0ZW50WzJdID0gY29vcmRpbmF0ZVswXTtcbiAgfVxuICBpZiAoY29vcmRpbmF0ZVsxXSA8IGV4dGVudFsxXSkge1xuICAgIGV4dGVudFsxXSA9IGNvb3JkaW5hdGVbMV07XG4gIH1cbiAgaWYgKGNvb3JkaW5hdGVbMV0gPiBleHRlbnRbM10pIHtcbiAgICBleHRlbnRbM10gPSBjb29yZGluYXRlWzFdO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtFeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcGFyYW0ge0FycmF5PGltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlPn0gY29vcmRpbmF0ZXMgQ29vcmRpbmF0ZXMuXG4gKiBAcmV0dXJuIHtFeHRlbnR9IEV4dGVudC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4dGVuZENvb3JkaW5hdGVzKGV4dGVudCwgY29vcmRpbmF0ZXMpIHtcbiAgZm9yIChsZXQgaSA9IDAsIGlpID0gY29vcmRpbmF0ZXMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgIGV4dGVuZENvb3JkaW5hdGUoZXh0ZW50LCBjb29yZGluYXRlc1tpXSk7XG4gIH1cbiAgcmV0dXJuIGV4dGVudDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0V4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgRW5kLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcmV0dXJuIHtFeHRlbnR9IEV4dGVudC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4dGVuZEZsYXRDb29yZGluYXRlcyhcbiAgZXh0ZW50LFxuICBmbGF0Q29vcmRpbmF0ZXMsXG4gIG9mZnNldCxcbiAgZW5kLFxuICBzdHJpZGVcbikge1xuICBmb3IgKDsgb2Zmc2V0IDwgZW5kOyBvZmZzZXQgKz0gc3RyaWRlKSB7XG4gICAgZXh0ZW5kWFkoZXh0ZW50LCBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0XSwgZmxhdENvb3JkaW5hdGVzW29mZnNldCArIDFdKTtcbiAgfVxuICByZXR1cm4gZXh0ZW50O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICogQHBhcmFtIHtBcnJheTxBcnJheTxpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZT4+fSByaW5ncyBSaW5ncy5cbiAqIEByZXR1cm4ge0V4dGVudH0gRXh0ZW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZXh0ZW5kUmluZ3MoZXh0ZW50LCByaW5ncykge1xuICBmb3IgKGxldCBpID0gMCwgaWkgPSByaW5ncy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgZXh0ZW5kQ29vcmRpbmF0ZXMoZXh0ZW50LCByaW5nc1tpXSk7XG4gIH1cbiAgcmV0dXJuIGV4dGVudDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0V4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB4IFguXG4gKiBAcGFyYW0ge251bWJlcn0geSBZLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZXh0ZW5kWFkoZXh0ZW50LCB4LCB5KSB7XG4gIGV4dGVudFswXSA9IE1hdGgubWluKGV4dGVudFswXSwgeCk7XG4gIGV4dGVudFsxXSA9IE1hdGgubWluKGV4dGVudFsxXSwgeSk7XG4gIGV4dGVudFsyXSA9IE1hdGgubWF4KGV4dGVudFsyXSwgeCk7XG4gIGV4dGVudFszXSA9IE1hdGgubWF4KGV4dGVudFszXSwgeSk7XG59XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBjYWxscyBgY2FsbGJhY2tgIGZvciBlYWNoIGNvcm5lciBvZiB0aGUgZXh0ZW50LiBJZiB0aGVcbiAqIGNhbGxiYWNrIHJldHVybnMgYSB0cnV0aHkgdmFsdWUgdGhlIGZ1bmN0aW9uIHJldHVybnMgdGhhdCB2YWx1ZVxuICogaW1tZWRpYXRlbHkuIE90aGVyd2lzZSB0aGUgZnVuY3Rpb24gcmV0dXJucyBgZmFsc2VgLlxuICogQHBhcmFtIHtFeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKGltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlKTogU30gY2FsbGJhY2sgQ2FsbGJhY2suXG4gKiBAcmV0dXJuIHtTfGJvb2xlYW59IFZhbHVlLlxuICogQHRlbXBsYXRlIFNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZvckVhY2hDb3JuZXIoZXh0ZW50LCBjYWxsYmFjaykge1xuICBsZXQgdmFsO1xuICB2YWwgPSBjYWxsYmFjayhnZXRCb3R0b21MZWZ0KGV4dGVudCkpO1xuICBpZiAodmFsKSB7XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuICB2YWwgPSBjYWxsYmFjayhnZXRCb3R0b21SaWdodChleHRlbnQpKTtcbiAgaWYgKHZhbCkge1xuICAgIHJldHVybiB2YWw7XG4gIH1cbiAgdmFsID0gY2FsbGJhY2soZ2V0VG9wUmlnaHQoZXh0ZW50KSk7XG4gIGlmICh2YWwpIHtcbiAgICByZXR1cm4gdmFsO1xuICB9XG4gIHZhbCA9IGNhbGxiYWNrKGdldFRvcExlZnQoZXh0ZW50KSk7XG4gIGlmICh2YWwpIHtcbiAgICByZXR1cm4gdmFsO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHNpemUgb2YgYW4gZXh0ZW50LlxuICogQHBhcmFtIHtFeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEFyZWEuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRBcmVhKGV4dGVudCkge1xuICBsZXQgYXJlYSA9IDA7XG4gIGlmICghaXNFbXB0eShleHRlbnQpKSB7XG4gICAgYXJlYSA9IGdldFdpZHRoKGV4dGVudCkgKiBnZXRIZWlnaHQoZXh0ZW50KTtcbiAgfVxuICByZXR1cm4gYXJlYTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGJvdHRvbSBsZWZ0IGNvb3JkaW5hdGUgb2YgYW4gZXh0ZW50LlxuICogQHBhcmFtIHtFeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcmV0dXJuIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gQm90dG9tIGxlZnQgY29vcmRpbmF0ZS5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEJvdHRvbUxlZnQoZXh0ZW50KSB7XG4gIHJldHVybiBbZXh0ZW50WzBdLCBleHRlbnRbMV1dO1xufVxuXG4vKipcbiAqIEdldCB0aGUgYm90dG9tIHJpZ2h0IGNvb3JkaW5hdGUgb2YgYW4gZXh0ZW50LlxuICogQHBhcmFtIHtFeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcmV0dXJuIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gQm90dG9tIHJpZ2h0IGNvb3JkaW5hdGUuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRCb3R0b21SaWdodChleHRlbnQpIHtcbiAgcmV0dXJuIFtleHRlbnRbMl0sIGV4dGVudFsxXV07XG59XG5cbi8qKlxuICogR2V0IHRoZSBjZW50ZXIgY29vcmRpbmF0ZSBvZiBhbiBleHRlbnQuXG4gKiBAcGFyYW0ge0V4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEByZXR1cm4ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBDZW50ZXIuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRDZW50ZXIoZXh0ZW50KSB7XG4gIHJldHVybiBbKGV4dGVudFswXSArIGV4dGVudFsyXSkgLyAyLCAoZXh0ZW50WzFdICsgZXh0ZW50WzNdKSAvIDJdO1xufVxuXG4vKipcbiAqIEdldCBhIGNvcm5lciBjb29yZGluYXRlIG9mIGFuIGV4dGVudC5cbiAqIEBwYXJhbSB7RXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICogQHBhcmFtIHtDb3JuZXJ9IGNvcm5lciBDb3JuZXIuXG4gKiBAcmV0dXJuIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gQ29ybmVyIGNvb3JkaW5hdGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRDb3JuZXIoZXh0ZW50LCBjb3JuZXIpIHtcbiAgbGV0IGNvb3JkaW5hdGU7XG4gIGlmIChjb3JuZXIgPT09ICdib3R0b20tbGVmdCcpIHtcbiAgICBjb29yZGluYXRlID0gZ2V0Qm90dG9tTGVmdChleHRlbnQpO1xuICB9IGVsc2UgaWYgKGNvcm5lciA9PT0gJ2JvdHRvbS1yaWdodCcpIHtcbiAgICBjb29yZGluYXRlID0gZ2V0Qm90dG9tUmlnaHQoZXh0ZW50KTtcbiAgfSBlbHNlIGlmIChjb3JuZXIgPT09ICd0b3AtbGVmdCcpIHtcbiAgICBjb29yZGluYXRlID0gZ2V0VG9wTGVmdChleHRlbnQpO1xuICB9IGVsc2UgaWYgKGNvcm5lciA9PT0gJ3RvcC1yaWdodCcpIHtcbiAgICBjb29yZGluYXRlID0gZ2V0VG9wUmlnaHQoZXh0ZW50KTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29ybmVyJyk7XG4gIH1cbiAgcmV0dXJuIGNvb3JkaW5hdGU7XG59XG5cbi8qKlxuICogQHBhcmFtIHtFeHRlbnR9IGV4dGVudDEgRXh0ZW50IDEuXG4gKiBAcGFyYW0ge0V4dGVudH0gZXh0ZW50MiBFeHRlbnQgMi5cbiAqIEByZXR1cm4ge251bWJlcn0gRW5sYXJnZWQgYXJlYS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEVubGFyZ2VkQXJlYShleHRlbnQxLCBleHRlbnQyKSB7XG4gIGNvbnN0IG1pblggPSBNYXRoLm1pbihleHRlbnQxWzBdLCBleHRlbnQyWzBdKTtcbiAgY29uc3QgbWluWSA9IE1hdGgubWluKGV4dGVudDFbMV0sIGV4dGVudDJbMV0pO1xuICBjb25zdCBtYXhYID0gTWF0aC5tYXgoZXh0ZW50MVsyXSwgZXh0ZW50MlsyXSk7XG4gIGNvbnN0IG1heFkgPSBNYXRoLm1heChleHRlbnQxWzNdLCBleHRlbnQyWzNdKTtcbiAgcmV0dXJuIChtYXhYIC0gbWluWCkgKiAobWF4WSAtIG1pblkpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGNlbnRlciBDZW50ZXIuXG4gKiBAcGFyYW0ge251bWJlcn0gcmVzb2x1dGlvbiBSZXNvbHV0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IHJvdGF0aW9uIFJvdGF0aW9uLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL3NpemUuanNcIikuU2l6ZX0gc2l6ZSBTaXplLlxuICogQHBhcmFtIHtFeHRlbnR9IFtkZXN0XSBEZXN0aW5hdGlvbiBleHRlbnQuXG4gKiBAcmV0dXJuIHtFeHRlbnR9IEV4dGVudC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEZvclZpZXdBbmRTaXplKGNlbnRlciwgcmVzb2x1dGlvbiwgcm90YXRpb24sIHNpemUsIGRlc3QpIHtcbiAgY29uc3QgW3gwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIHgzLCB5M10gPSBnZXRSb3RhdGVkVmlld3BvcnQoXG4gICAgY2VudGVyLFxuICAgIHJlc29sdXRpb24sXG4gICAgcm90YXRpb24sXG4gICAgc2l6ZVxuICApO1xuICByZXR1cm4gY3JlYXRlT3JVcGRhdGUoXG4gICAgTWF0aC5taW4oeDAsIHgxLCB4MiwgeDMpLFxuICAgIE1hdGgubWluKHkwLCB5MSwgeTIsIHkzKSxcbiAgICBNYXRoLm1heCh4MCwgeDEsIHgyLCB4MyksXG4gICAgTWF0aC5tYXgoeTAsIHkxLCB5MiwgeTMpLFxuICAgIGRlc3RcbiAgKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBjZW50ZXIgQ2VudGVyLlxuICogQHBhcmFtIHtudW1iZXJ9IHJlc29sdXRpb24gUmVzb2x1dGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSByb3RhdGlvbiBSb3RhdGlvbi5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9zaXplLmpzXCIpLlNpemV9IHNpemUgU2l6ZS5cbiAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IExpbmVhciByaW5nIHJlcHJlc2VudGluZyB0aGUgdmlld3BvcnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRSb3RhdGVkVmlld3BvcnQoY2VudGVyLCByZXNvbHV0aW9uLCByb3RhdGlvbiwgc2l6ZSkge1xuICBjb25zdCBkeCA9IChyZXNvbHV0aW9uICogc2l6ZVswXSkgLyAyO1xuICBjb25zdCBkeSA9IChyZXNvbHV0aW9uICogc2l6ZVsxXSkgLyAyO1xuICBjb25zdCBjb3NSb3RhdGlvbiA9IE1hdGguY29zKHJvdGF0aW9uKTtcbiAgY29uc3Qgc2luUm90YXRpb24gPSBNYXRoLnNpbihyb3RhdGlvbik7XG4gIGNvbnN0IHhDb3MgPSBkeCAqIGNvc1JvdGF0aW9uO1xuICBjb25zdCB4U2luID0gZHggKiBzaW5Sb3RhdGlvbjtcbiAgY29uc3QgeUNvcyA9IGR5ICogY29zUm90YXRpb247XG4gIGNvbnN0IHlTaW4gPSBkeSAqIHNpblJvdGF0aW9uO1xuICBjb25zdCB4ID0gY2VudGVyWzBdO1xuICBjb25zdCB5ID0gY2VudGVyWzFdO1xuICByZXR1cm4gW1xuICAgIHggLSB4Q29zICsgeVNpbixcbiAgICB5IC0geFNpbiAtIHlDb3MsXG4gICAgeCAtIHhDb3MgLSB5U2luLFxuICAgIHkgLSB4U2luICsgeUNvcyxcbiAgICB4ICsgeENvcyAtIHlTaW4sXG4gICAgeSArIHhTaW4gKyB5Q29zLFxuICAgIHggKyB4Q29zICsgeVNpbixcbiAgICB5ICsgeFNpbiAtIHlDb3MsXG4gICAgeCAtIHhDb3MgKyB5U2luLFxuICAgIHkgLSB4U2luIC0geUNvcyxcbiAgXTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGhlaWdodCBvZiBhbiBleHRlbnQuXG4gKiBAcGFyYW0ge0V4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEByZXR1cm4ge251bWJlcn0gSGVpZ2h0LlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0SGVpZ2h0KGV4dGVudCkge1xuICByZXR1cm4gZXh0ZW50WzNdIC0gZXh0ZW50WzFdO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RXh0ZW50fSBleHRlbnQxIEV4dGVudCAxLlxuICogQHBhcmFtIHtFeHRlbnR9IGV4dGVudDIgRXh0ZW50IDIuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEludGVyc2VjdGlvbiBhcmVhLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0SW50ZXJzZWN0aW9uQXJlYShleHRlbnQxLCBleHRlbnQyKSB7XG4gIGNvbnN0IGludGVyc2VjdGlvbiA9IGdldEludGVyc2VjdGlvbihleHRlbnQxLCBleHRlbnQyKTtcbiAgcmV0dXJuIGdldEFyZWEoaW50ZXJzZWN0aW9uKTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGludGVyc2VjdGlvbiBvZiB0d28gZXh0ZW50cy5cbiAqIEBwYXJhbSB7RXh0ZW50fSBleHRlbnQxIEV4dGVudCAxLlxuICogQHBhcmFtIHtFeHRlbnR9IGV4dGVudDIgRXh0ZW50IDIuXG4gKiBAcGFyYW0ge0V4dGVudH0gW2Rlc3RdIE9wdGlvbmFsIGV4dGVudCB0byBwb3B1bGF0ZSB3aXRoIGludGVyc2VjdGlvbi5cbiAqIEByZXR1cm4ge0V4dGVudH0gSW50ZXJzZWN0aW5nIGV4dGVudC5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEludGVyc2VjdGlvbihleHRlbnQxLCBleHRlbnQyLCBkZXN0KSB7XG4gIGNvbnN0IGludGVyc2VjdGlvbiA9IGRlc3QgPyBkZXN0IDogY3JlYXRlRW1wdHkoKTtcbiAgaWYgKGludGVyc2VjdHMoZXh0ZW50MSwgZXh0ZW50MikpIHtcbiAgICBpZiAoZXh0ZW50MVswXSA+IGV4dGVudDJbMF0pIHtcbiAgICAgIGludGVyc2VjdGlvblswXSA9IGV4dGVudDFbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIGludGVyc2VjdGlvblswXSA9IGV4dGVudDJbMF07XG4gICAgfVxuICAgIGlmIChleHRlbnQxWzFdID4gZXh0ZW50MlsxXSkge1xuICAgICAgaW50ZXJzZWN0aW9uWzFdID0gZXh0ZW50MVsxXTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW50ZXJzZWN0aW9uWzFdID0gZXh0ZW50MlsxXTtcbiAgICB9XG4gICAgaWYgKGV4dGVudDFbMl0gPCBleHRlbnQyWzJdKSB7XG4gICAgICBpbnRlcnNlY3Rpb25bMl0gPSBleHRlbnQxWzJdO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbnRlcnNlY3Rpb25bMl0gPSBleHRlbnQyWzJdO1xuICAgIH1cbiAgICBpZiAoZXh0ZW50MVszXSA8IGV4dGVudDJbM10pIHtcbiAgICAgIGludGVyc2VjdGlvblszXSA9IGV4dGVudDFbM107XG4gICAgfSBlbHNlIHtcbiAgICAgIGludGVyc2VjdGlvblszXSA9IGV4dGVudDJbM107XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNyZWF0ZU9yVXBkYXRlRW1wdHkoaW50ZXJzZWN0aW9uKTtcbiAgfVxuICByZXR1cm4gaW50ZXJzZWN0aW9uO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICogQHJldHVybiB7bnVtYmVyfSBNYXJnaW4uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRNYXJnaW4oZXh0ZW50KSB7XG4gIHJldHVybiBnZXRXaWR0aChleHRlbnQpICsgZ2V0SGVpZ2h0KGV4dGVudCk7XG59XG5cbi8qKlxuICogR2V0IHRoZSBzaXplICh3aWR0aCwgaGVpZ2h0KSBvZiBhbiBleHRlbnQuXG4gKiBAcGFyYW0ge0V4dGVudH0gZXh0ZW50IFRoZSBleHRlbnQuXG4gKiBAcmV0dXJuIHtpbXBvcnQoXCIuL3NpemUuanNcIikuU2l6ZX0gVGhlIGV4dGVudCBzaXplLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2l6ZShleHRlbnQpIHtcbiAgcmV0dXJuIFtleHRlbnRbMl0gLSBleHRlbnRbMF0sIGV4dGVudFszXSAtIGV4dGVudFsxXV07XG59XG5cbi8qKlxuICogR2V0IHRoZSB0b3AgbGVmdCBjb29yZGluYXRlIG9mIGFuIGV4dGVudC5cbiAqIEBwYXJhbSB7RXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICogQHJldHVybiB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IFRvcCBsZWZ0IGNvb3JkaW5hdGUuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRUb3BMZWZ0KGV4dGVudCkge1xuICByZXR1cm4gW2V4dGVudFswXSwgZXh0ZW50WzNdXTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHRvcCByaWdodCBjb29yZGluYXRlIG9mIGFuIGV4dGVudC5cbiAqIEBwYXJhbSB7RXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICogQHJldHVybiB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IFRvcCByaWdodCBjb29yZGluYXRlLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0VG9wUmlnaHQoZXh0ZW50KSB7XG4gIHJldHVybiBbZXh0ZW50WzJdLCBleHRlbnRbM11dO1xufVxuXG4vKipcbiAqIEdldCB0aGUgd2lkdGggb2YgYW4gZXh0ZW50LlxuICogQHBhcmFtIHtFeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFdpZHRoLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0V2lkdGgoZXh0ZW50KSB7XG4gIHJldHVybiBleHRlbnRbMl0gLSBleHRlbnRbMF07XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIG9uZSBleHRlbnQgaW50ZXJzZWN0cyBhbm90aGVyLlxuICogQHBhcmFtIHtFeHRlbnR9IGV4dGVudDEgRXh0ZW50IDEuXG4gKiBAcGFyYW0ge0V4dGVudH0gZXh0ZW50MiBFeHRlbnQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUaGUgdHdvIGV4dGVudHMgaW50ZXJzZWN0LlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gaW50ZXJzZWN0cyhleHRlbnQxLCBleHRlbnQyKSB7XG4gIHJldHVybiAoXG4gICAgZXh0ZW50MVswXSA8PSBleHRlbnQyWzJdICYmXG4gICAgZXh0ZW50MVsyXSA+PSBleHRlbnQyWzBdICYmXG4gICAgZXh0ZW50MVsxXSA8PSBleHRlbnQyWzNdICYmXG4gICAgZXh0ZW50MVszXSA+PSBleHRlbnQyWzFdXG4gICk7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGFuIGV4dGVudCBpcyBlbXB0eS5cbiAqIEBwYXJhbSB7RXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICogQHJldHVybiB7Ym9vbGVhbn0gSXMgZW1wdHkuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0VtcHR5KGV4dGVudCkge1xuICByZXR1cm4gZXh0ZW50WzJdIDwgZXh0ZW50WzBdIHx8IGV4dGVudFszXSA8IGV4dGVudFsxXTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0V4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEBwYXJhbSB7RXh0ZW50fSBbZGVzdF0gRXh0ZW50LlxuICogQHJldHVybiB7RXh0ZW50fSBFeHRlbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXR1cm5PclVwZGF0ZShleHRlbnQsIGRlc3QpIHtcbiAgaWYgKGRlc3QpIHtcbiAgICBkZXN0WzBdID0gZXh0ZW50WzBdO1xuICAgIGRlc3RbMV0gPSBleHRlbnRbMV07XG4gICAgZGVzdFsyXSA9IGV4dGVudFsyXTtcbiAgICBkZXN0WzNdID0gZXh0ZW50WzNdO1xuICAgIHJldHVybiBkZXN0O1xuICB9XG4gIHJldHVybiBleHRlbnQ7XG59XG5cbi8qKlxuICogQHBhcmFtIHtFeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzY2FsZUZyb21DZW50ZXIoZXh0ZW50LCB2YWx1ZSkge1xuICBjb25zdCBkZWx0YVggPSAoKGV4dGVudFsyXSAtIGV4dGVudFswXSkgLyAyKSAqICh2YWx1ZSAtIDEpO1xuICBjb25zdCBkZWx0YVkgPSAoKGV4dGVudFszXSAtIGV4dGVudFsxXSkgLyAyKSAqICh2YWx1ZSAtIDEpO1xuICBleHRlbnRbMF0gLT0gZGVsdGFYO1xuICBleHRlbnRbMl0gKz0gZGVsdGFYO1xuICBleHRlbnRbMV0gLT0gZGVsdGFZO1xuICBleHRlbnRbM10gKz0gZGVsdGFZO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiB0aGUgc2VnbWVudCBiZXR3ZWVuIHR3byBjb29yZGluYXRlcyBpbnRlcnNlY3RzIChjcm9zc2VzLFxuICogdG91Y2hlcywgb3IgaXMgY29udGFpbmVkIGJ5KSB0aGUgcHJvdmlkZWQgZXh0ZW50LlxuICogQHBhcmFtIHtFeHRlbnR9IGV4dGVudCBUaGUgZXh0ZW50LlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gc3RhcnQgU2VnbWVudCBzdGFydCBjb29yZGluYXRlLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gZW5kIFNlZ21lbnQgZW5kIGNvb3JkaW5hdGUuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUaGUgc2VnbWVudCBpbnRlcnNlY3RzIHRoZSBleHRlbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnRlcnNlY3RzU2VnbWVudChleHRlbnQsIHN0YXJ0LCBlbmQpIHtcbiAgbGV0IGludGVyc2VjdHMgPSBmYWxzZTtcbiAgY29uc3Qgc3RhcnRSZWwgPSBjb29yZGluYXRlUmVsYXRpb25zaGlwKGV4dGVudCwgc3RhcnQpO1xuICBjb25zdCBlbmRSZWwgPSBjb29yZGluYXRlUmVsYXRpb25zaGlwKGV4dGVudCwgZW5kKTtcbiAgaWYgKFxuICAgIHN0YXJ0UmVsID09PSBSZWxhdGlvbnNoaXAuSU5URVJTRUNUSU5HIHx8XG4gICAgZW5kUmVsID09PSBSZWxhdGlvbnNoaXAuSU5URVJTRUNUSU5HXG4gICkge1xuICAgIGludGVyc2VjdHMgPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IG1pblggPSBleHRlbnRbMF07XG4gICAgY29uc3QgbWluWSA9IGV4dGVudFsxXTtcbiAgICBjb25zdCBtYXhYID0gZXh0ZW50WzJdO1xuICAgIGNvbnN0IG1heFkgPSBleHRlbnRbM107XG4gICAgY29uc3Qgc3RhcnRYID0gc3RhcnRbMF07XG4gICAgY29uc3Qgc3RhcnRZID0gc3RhcnRbMV07XG4gICAgY29uc3QgZW5kWCA9IGVuZFswXTtcbiAgICBjb25zdCBlbmRZID0gZW5kWzFdO1xuICAgIGNvbnN0IHNsb3BlID0gKGVuZFkgLSBzdGFydFkpIC8gKGVuZFggLSBzdGFydFgpO1xuICAgIGxldCB4LCB5O1xuICAgIGlmICghIShlbmRSZWwgJiBSZWxhdGlvbnNoaXAuQUJPVkUpICYmICEoc3RhcnRSZWwgJiBSZWxhdGlvbnNoaXAuQUJPVkUpKSB7XG4gICAgICAvLyBwb3RlbnRpYWxseSBpbnRlcnNlY3RzIHRvcFxuICAgICAgeCA9IGVuZFggLSAoZW5kWSAtIG1heFkpIC8gc2xvcGU7XG4gICAgICBpbnRlcnNlY3RzID0geCA+PSBtaW5YICYmIHggPD0gbWF4WDtcbiAgICB9XG4gICAgaWYgKFxuICAgICAgIWludGVyc2VjdHMgJiZcbiAgICAgICEhKGVuZFJlbCAmIFJlbGF0aW9uc2hpcC5SSUdIVCkgJiZcbiAgICAgICEoc3RhcnRSZWwgJiBSZWxhdGlvbnNoaXAuUklHSFQpXG4gICAgKSB7XG4gICAgICAvLyBwb3RlbnRpYWxseSBpbnRlcnNlY3RzIHJpZ2h0XG4gICAgICB5ID0gZW5kWSAtIChlbmRYIC0gbWF4WCkgKiBzbG9wZTtcbiAgICAgIGludGVyc2VjdHMgPSB5ID49IG1pblkgJiYgeSA8PSBtYXhZO1xuICAgIH1cbiAgICBpZiAoXG4gICAgICAhaW50ZXJzZWN0cyAmJlxuICAgICAgISEoZW5kUmVsICYgUmVsYXRpb25zaGlwLkJFTE9XKSAmJlxuICAgICAgIShzdGFydFJlbCAmIFJlbGF0aW9uc2hpcC5CRUxPVylcbiAgICApIHtcbiAgICAgIC8vIHBvdGVudGlhbGx5IGludGVyc2VjdHMgYm90dG9tXG4gICAgICB4ID0gZW5kWCAtIChlbmRZIC0gbWluWSkgLyBzbG9wZTtcbiAgICAgIGludGVyc2VjdHMgPSB4ID49IG1pblggJiYgeCA8PSBtYXhYO1xuICAgIH1cbiAgICBpZiAoXG4gICAgICAhaW50ZXJzZWN0cyAmJlxuICAgICAgISEoZW5kUmVsICYgUmVsYXRpb25zaGlwLkxFRlQpICYmXG4gICAgICAhKHN0YXJ0UmVsICYgUmVsYXRpb25zaGlwLkxFRlQpXG4gICAgKSB7XG4gICAgICAvLyBwb3RlbnRpYWxseSBpbnRlcnNlY3RzIGxlZnRcbiAgICAgIHkgPSBlbmRZIC0gKGVuZFggLSBtaW5YKSAqIHNsb3BlO1xuICAgICAgaW50ZXJzZWN0cyA9IHkgPj0gbWluWSAmJiB5IDw9IG1heFk7XG4gICAgfVxuICB9XG4gIHJldHVybiBpbnRlcnNlY3RzO1xufVxuXG4vKipcbiAqIEFwcGx5IGEgdHJhbnNmb3JtIGZ1bmN0aW9uIHRvIHRoZSBleHRlbnQuXG4gKiBAcGFyYW0ge0V4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9wcm9qLmpzXCIpLlRyYW5zZm9ybUZ1bmN0aW9ufSB0cmFuc2Zvcm1GbiBUcmFuc2Zvcm0gZnVuY3Rpb24uXG4gKiBDYWxsZWQgd2l0aCBgW21pblgsIG1pblksIG1heFgsIG1heFldYCBleHRlbnQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge0V4dGVudH0gW2Rlc3RdIERlc3RpbmF0aW9uIGV4dGVudC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RvcHNdIE51bWJlciBvZiBzdG9wcyBwZXIgc2lkZSB1c2VkIGZvciB0aGUgdHJhbnNmb3JtLlxuICogQnkgZGVmYXVsdCBvbmx5IHRoZSBjb3JuZXJzIGFyZSB1c2VkLlxuICogQHJldHVybiB7RXh0ZW50fSBFeHRlbnQuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhcHBseVRyYW5zZm9ybShleHRlbnQsIHRyYW5zZm9ybUZuLCBkZXN0LCBzdG9wcykge1xuICBpZiAoaXNFbXB0eShleHRlbnQpKSB7XG4gICAgcmV0dXJuIGNyZWF0ZU9yVXBkYXRlRW1wdHkoZGVzdCk7XG4gIH1cbiAgbGV0IGNvb3JkaW5hdGVzID0gW107XG4gIGlmIChzdG9wcyA+IDEpIHtcbiAgICBjb25zdCB3aWR0aCA9IGV4dGVudFsyXSAtIGV4dGVudFswXTtcbiAgICBjb25zdCBoZWlnaHQgPSBleHRlbnRbM10gLSBleHRlbnRbMV07XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdG9wczsgKytpKSB7XG4gICAgICBjb29yZGluYXRlcy5wdXNoKFxuICAgICAgICBleHRlbnRbMF0gKyAod2lkdGggKiBpKSAvIHN0b3BzLFxuICAgICAgICBleHRlbnRbMV0sXG4gICAgICAgIGV4dGVudFsyXSxcbiAgICAgICAgZXh0ZW50WzFdICsgKGhlaWdodCAqIGkpIC8gc3RvcHMsXG4gICAgICAgIGV4dGVudFsyXSAtICh3aWR0aCAqIGkpIC8gc3RvcHMsXG4gICAgICAgIGV4dGVudFszXSxcbiAgICAgICAgZXh0ZW50WzBdLFxuICAgICAgICBleHRlbnRbM10gLSAoaGVpZ2h0ICogaSkgLyBzdG9wc1xuICAgICAgKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgY29vcmRpbmF0ZXMgPSBbXG4gICAgICBleHRlbnRbMF0sXG4gICAgICBleHRlbnRbMV0sXG4gICAgICBleHRlbnRbMl0sXG4gICAgICBleHRlbnRbMV0sXG4gICAgICBleHRlbnRbMl0sXG4gICAgICBleHRlbnRbM10sXG4gICAgICBleHRlbnRbMF0sXG4gICAgICBleHRlbnRbM10sXG4gICAgXTtcbiAgfVxuICB0cmFuc2Zvcm1Gbihjb29yZGluYXRlcywgY29vcmRpbmF0ZXMsIDIpO1xuICBjb25zdCB4cyA9IFtdO1xuICBjb25zdCB5cyA9IFtdO1xuICBmb3IgKGxldCBpID0gMCwgbCA9IGNvb3JkaW5hdGVzLmxlbmd0aDsgaSA8IGw7IGkgKz0gMikge1xuICAgIHhzLnB1c2goY29vcmRpbmF0ZXNbaV0pO1xuICAgIHlzLnB1c2goY29vcmRpbmF0ZXNbaSArIDFdKTtcbiAgfVxuICByZXR1cm4gX2JvdW5kaW5nRXh0ZW50WFlzKHhzLCB5cywgZGVzdCk7XG59XG5cbi8qKlxuICogTW9kaWZpZXMgdGhlIHByb3ZpZGVkIGV4dGVudCBpbi1wbGFjZSB0byBiZSB3aXRoaW4gdGhlIHJlYWwgd29ybGRcbiAqIGV4dGVudC5cbiAqXG4gKiBAcGFyYW0ge0V4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9wcm9qL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdH0gcHJvamVjdGlvbiBQcm9qZWN0aW9uXG4gKiBAcmV0dXJuIHtFeHRlbnR9IFRoZSBleHRlbnQgd2l0aGluIHRoZSByZWFsIHdvcmxkIGV4dGVudC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHdyYXBYKGV4dGVudCwgcHJvamVjdGlvbikge1xuICBjb25zdCBwcm9qZWN0aW9uRXh0ZW50ID0gcHJvamVjdGlvbi5nZXRFeHRlbnQoKTtcbiAgY29uc3QgY2VudGVyID0gZ2V0Q2VudGVyKGV4dGVudCk7XG4gIGlmIChcbiAgICBwcm9qZWN0aW9uLmNhbldyYXBYKCkgJiZcbiAgICAoY2VudGVyWzBdIDwgcHJvamVjdGlvbkV4dGVudFswXSB8fCBjZW50ZXJbMF0gPj0gcHJvamVjdGlvbkV4dGVudFsyXSlcbiAgKSB7XG4gICAgY29uc3Qgd29ybGRXaWR0aCA9IGdldFdpZHRoKHByb2plY3Rpb25FeHRlbnQpO1xuICAgIGNvbnN0IHdvcmxkc0F3YXkgPSBNYXRoLmZsb29yKFxuICAgICAgKGNlbnRlclswXSAtIHByb2plY3Rpb25FeHRlbnRbMF0pIC8gd29ybGRXaWR0aFxuICAgICk7XG4gICAgY29uc3Qgb2Zmc2V0ID0gd29ybGRzQXdheSAqIHdvcmxkV2lkdGg7XG4gICAgZXh0ZW50WzBdIC09IG9mZnNldDtcbiAgICBleHRlbnRbMl0gLT0gb2Zmc2V0O1xuICB9XG4gIHJldHVybiBleHRlbnQ7XG59XG5cbi8qKlxuICogRml0cyB0aGUgZXh0ZW50IHRvIHRoZSByZWFsIHdvcmxkXG4gKlxuICogSWYgdGhlIGV4dGVudCBkb2VzIG5vdCBjcm9zcyB0aGUgYW50aSBtZXJpZGlhbiwgdGhpcyB3aWxsIHJldHVybiB0aGUgZXh0ZW50IGluIGFuIGFycmF5XG4gKiBJZiB0aGUgZXh0ZW50IGNyb3NzZXMgdGhlIGFudGkgbWVyaWRpYW4sIHRoZSBleHRlbnQgd2lsbCBiZSBzbGljZWQsIHNvIGVhY2ggcGFydCBmaXRzIHdpdGhpbiB0aGVcbiAqIHJlYWwgd29ybGRcbiAqXG4gKlxuICogQHBhcmFtIHtFeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vcHJvai9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR9IHByb2plY3Rpb24gUHJvamVjdGlvblxuICogQHJldHVybiB7QXJyYXk8RXh0ZW50Pn0gVGhlIGV4dGVudCB3aXRoaW4gdGhlIHJlYWwgd29ybGQgZXh0ZW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gd3JhcEFuZFNsaWNlWChleHRlbnQsIHByb2plY3Rpb24pIHtcbiAgaWYgKHByb2plY3Rpb24uY2FuV3JhcFgoKSkge1xuICAgIGNvbnN0IHByb2plY3Rpb25FeHRlbnQgPSBwcm9qZWN0aW9uLmdldEV4dGVudCgpO1xuXG4gICAgaWYgKCFpc0Zpbml0ZShleHRlbnRbMF0pIHx8ICFpc0Zpbml0ZShleHRlbnRbMl0pKSB7XG4gICAgICByZXR1cm4gW1twcm9qZWN0aW9uRXh0ZW50WzBdLCBleHRlbnRbMV0sIHByb2plY3Rpb25FeHRlbnRbMl0sIGV4dGVudFszXV1dO1xuICAgIH1cblxuICAgIHdyYXBYKGV4dGVudCwgcHJvamVjdGlvbik7XG4gICAgY29uc3Qgd29ybGRXaWR0aCA9IGdldFdpZHRoKHByb2plY3Rpb25FeHRlbnQpO1xuXG4gICAgaWYgKGdldFdpZHRoKGV4dGVudCkgPiB3b3JsZFdpZHRoKSB7XG4gICAgICAvLyB0aGUgZXh0ZW50IHdyYXBzIGFyb3VuZCBvbiBpdHNlbGZcbiAgICAgIHJldHVybiBbW3Byb2plY3Rpb25FeHRlbnRbMF0sIGV4dGVudFsxXSwgcHJvamVjdGlvbkV4dGVudFsyXSwgZXh0ZW50WzNdXV07XG4gICAgfVxuICAgIGlmIChleHRlbnRbMF0gPCBwcm9qZWN0aW9uRXh0ZW50WzBdKSB7XG4gICAgICAvLyB0aGUgZXh0ZW50IGNyb3NzZXMgdGhlIGFudGkgbWVyaWRpYW4sIHNvIGl0IG5lZWRzIHRvIGJlIHNsaWNlZFxuICAgICAgcmV0dXJuIFtcbiAgICAgICAgW2V4dGVudFswXSArIHdvcmxkV2lkdGgsIGV4dGVudFsxXSwgcHJvamVjdGlvbkV4dGVudFsyXSwgZXh0ZW50WzNdXSxcbiAgICAgICAgW3Byb2plY3Rpb25FeHRlbnRbMF0sIGV4dGVudFsxXSwgZXh0ZW50WzJdLCBleHRlbnRbM11dLFxuICAgICAgXTtcbiAgICB9XG4gICAgaWYgKGV4dGVudFsyXSA+IHByb2plY3Rpb25FeHRlbnRbMl0pIHtcbiAgICAgIC8vIHRoZSBleHRlbnQgY3Jvc3NlcyB0aGUgYW50aSBtZXJpZGlhbiwgc28gaXQgbmVlZHMgdG8gYmUgc2xpY2VkXG4gICAgICByZXR1cm4gW1xuICAgICAgICBbZXh0ZW50WzBdLCBleHRlbnRbMV0sIHByb2plY3Rpb25FeHRlbnRbMl0sIGV4dGVudFszXV0sXG4gICAgICAgIFtwcm9qZWN0aW9uRXh0ZW50WzBdLCBleHRlbnRbMV0sIGV4dGVudFsyXSAtIHdvcmxkV2lkdGgsIGV4dGVudFszXV0sXG4gICAgICBdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBbZXh0ZW50XTtcbn1cbiIsIi8qKlxuICogQG1vZHVsZSBvbC9leHRlbnQvUmVsYXRpb25zaGlwXG4gKi9cblxuLyoqXG4gKiBSZWxhdGlvbnNoaXAgdG8gYW4gZXh0ZW50LlxuICogQGVudW0ge251bWJlcn1cbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICBVTktOT1dOOiAwLFxuICBJTlRFUlNFQ1RJTkc6IDEsXG4gIEFCT1ZFOiAyLFxuICBSSUdIVDogNCxcbiAgQkVMT1c6IDgsXG4gIExFRlQ6IDE2LFxufTtcbiIsIi8qKlxuICogQG1vZHVsZSBvbC9mZWF0dXJlbG9hZGVyXG4gKi9cbmltcG9ydCB7Vk9JRH0gZnJvbSAnLi9mdW5jdGlvbnMuanMnO1xuXG4vKipcbiAqXG4gKiBAdHlwZSB7Ym9vbGVhbn1cbiAqIEBwcml2YXRlXG4gKi9cbmxldCB3aXRoQ3JlZGVudGlhbHMgPSBmYWxzZTtcblxuLyoqXG4gKiB7QGxpbmsgbW9kdWxlOm9sL3NvdXJjZS9WZWN0b3J+VmVjdG9yU291cmNlfSBzb3VyY2VzIHVzZSBhIGZ1bmN0aW9uIG9mIHRoaXMgdHlwZSB0b1xuICogbG9hZCBmZWF0dXJlcy5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHRha2VzIHVwIHRvIDUgYXJndW1lbnRzLiBUaGVzZSBhcmUgYW4ge0BsaW5rIG1vZHVsZTpvbC9leHRlbnR+RXh0ZW50fSByZXByZXNlbnRpbmdcbiAqIHRoZSBhcmVhIHRvIGJlIGxvYWRlZCwgYSBge251bWJlcn1gIHJlcHJlc2VudGluZyB0aGUgcmVzb2x1dGlvbiAobWFwIHVuaXRzIHBlciBwaXhlbCksIGFuXG4gKiB7QGxpbmsgbW9kdWxlOm9sL3Byb2ovUHJvamVjdGlvbn5Qcm9qZWN0aW9ufSBmb3IgdGhlIHByb2plY3Rpb24sIGFuIG9wdGlvbmFsIHN1Y2Nlc3MgY2FsbGJhY2sgdGhhdCBzaG91bGQgZ2V0XG4gKiB0aGUgbG9hZGVkIGZlYXR1cmVzIHBhc3NlZCBhcyBhbiBhcmd1bWVudCBhbmQgYW4gb3B0aW9uYWwgZmFpbHVyZSBjYWxsYmFjayB3aXRoIG5vIGFyZ3VtZW50cy4gSWZcbiAqIHRoZSBjYWxsYmFja3MgYXJlIG5vdCB1c2VkLCB0aGUgY29ycmVzcG9uZGluZyB2ZWN0b3Igc291cmNlIHdpbGwgbm90IGZpcmUgYCdmZWF0dXJlc2xvYWRlbmQnYCBhbmRcbiAqIGAnZmVhdHVyZXNsb2FkZXJyb3InYCBldmVudHMuIGB0aGlzYCB3aXRoaW4gdGhlIGZ1bmN0aW9uIGlzIGJvdW5kIHRvIHRoZVxuICoge0BsaW5rIG1vZHVsZTpvbC9zb3VyY2UvVmVjdG9yflZlY3RvclNvdXJjZX0gaXQncyBjYWxsZWQgZnJvbS5cbiAqXG4gKiBUaGUgZnVuY3Rpb24gaXMgcmVzcG9uc2libGUgZm9yIGxvYWRpbmcgdGhlIGZlYXR1cmVzIGFuZCBhZGRpbmcgdGhlbSB0byB0aGVcbiAqIHNvdXJjZS5cbiAqIEB0eXBlZGVmIHtmdW5jdGlvbih0aGlzOihpbXBvcnQoXCIuL3NvdXJjZS9WZWN0b3JcIikuZGVmYXVsdHxpbXBvcnQoXCIuL1ZlY3RvclRpbGUuanNcIikuZGVmYXVsdCksXG4gKiAgICAgICAgICAgaW1wb3J0KFwiLi9leHRlbnQuanNcIikuRXh0ZW50LFxuICogICAgICAgICAgIG51bWJlcixcbiAqICAgICAgICAgICBpbXBvcnQoXCIuL3Byb2ovUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0LFxuICogICAgICAgICAgIGZ1bmN0aW9uKEFycmF5PGltcG9ydChcIi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0Pik6IHZvaWQ9LFxuICogICAgICAgICAgIGZ1bmN0aW9uKCk6IHZvaWQ9KTogdm9pZH0gRmVhdHVyZUxvYWRlclxuICogQGFwaVxuICovXG5cbi8qKlxuICoge0BsaW5rIG1vZHVsZTpvbC9zb3VyY2UvVmVjdG9yflZlY3RvclNvdXJjZX0gc291cmNlcyB1c2UgYSBmdW5jdGlvbiBvZiB0aGlzIHR5cGUgdG9cbiAqIGdldCB0aGUgdXJsIHRvIGxvYWQgZmVhdHVyZXMgZnJvbS5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHRha2VzIGFuIHtAbGluayBtb2R1bGU6b2wvZXh0ZW50fkV4dGVudH0gcmVwcmVzZW50aW5nIHRoZSBhcmVhXG4gKiB0byBiZSBsb2FkZWQsIGEgYHtudW1iZXJ9YCByZXByZXNlbnRpbmcgdGhlIHJlc29sdXRpb24gKG1hcCB1bml0cyBwZXIgcGl4ZWwpXG4gKiBhbmQgYW4ge0BsaW5rIG1vZHVsZTpvbC9wcm9qL1Byb2plY3Rpb25+UHJvamVjdGlvbn0gZm9yIHRoZSBwcm9qZWN0aW9uICBhc1xuICogYXJndW1lbnRzIGFuZCByZXR1cm5zIGEgYHtzdHJpbmd9YCByZXByZXNlbnRpbmcgdGhlIFVSTC5cbiAqIEB0eXBlZGVmIHtmdW5jdGlvbihpbXBvcnQoXCIuL2V4dGVudC5qc1wiKS5FeHRlbnQsIG51bWJlciwgaW1wb3J0KFwiLi9wcm9qL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdCk6IHN0cmluZ30gRmVhdHVyZVVybEZ1bmN0aW9uXG4gKiBAYXBpXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ3xGZWF0dXJlVXJsRnVuY3Rpb259IHVybCBGZWF0dXJlIFVSTCBzZXJ2aWNlLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL2Zvcm1hdC9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9IGZvcm1hdCBGZWF0dXJlIGZvcm1hdC5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9leHRlbnQuanNcIikuRXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICogQHBhcmFtIHtudW1iZXJ9IHJlc29sdXRpb24gUmVzb2x1dGlvbi5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9wcm9qL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdH0gcHJvamVjdGlvbiBQcm9qZWN0aW9uLlxuICogQHBhcmFtIHtmdW5jdGlvbihBcnJheTxpbXBvcnQoXCIuL0ZlYXR1cmUuanNcIikuZGVmYXVsdD4sIGltcG9ydChcIi4vcHJvai9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHQpOiB2b2lkfSBzdWNjZXNzIFN1Y2Nlc3NcbiAqICAgICAgRnVuY3Rpb24gY2FsbGVkIHdpdGggdGhlIGxvYWRlZCBmZWF0dXJlcyBhbmQgb3B0aW9uYWxseSB3aXRoIHRoZSBkYXRhIHByb2plY3Rpb24uXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCk6IHZvaWR9IGZhaWx1cmUgRmFpbHVyZVxuICogICAgICBGdW5jdGlvbiBjYWxsZWQgd2hlbiBsb2FkaW5nIGZhaWxlZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxvYWRGZWF0dXJlc1hocihcbiAgdXJsLFxuICBmb3JtYXQsXG4gIGV4dGVudCxcbiAgcmVzb2x1dGlvbixcbiAgcHJvamVjdGlvbixcbiAgc3VjY2VzcyxcbiAgZmFpbHVyZVxuKSB7XG4gIGNvbnN0IHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICB4aHIub3BlbihcbiAgICAnR0VUJyxcbiAgICB0eXBlb2YgdXJsID09PSAnZnVuY3Rpb24nID8gdXJsKGV4dGVudCwgcmVzb2x1dGlvbiwgcHJvamVjdGlvbikgOiB1cmwsXG4gICAgdHJ1ZVxuICApO1xuICBpZiAoZm9ybWF0LmdldFR5cGUoKSA9PSAnYXJyYXlidWZmZXInKSB7XG4gICAgeGhyLnJlc3BvbnNlVHlwZSA9ICdhcnJheWJ1ZmZlcic7XG4gIH1cbiAgeGhyLndpdGhDcmVkZW50aWFscyA9IHdpdGhDcmVkZW50aWFscztcbiAgLyoqXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IEV2ZW50LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgeGhyLm9ubG9hZCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIC8vIHN0YXR1cyB3aWxsIGJlIDAgZm9yIGZpbGU6Ly8gdXJsc1xuICAgIGlmICgheGhyLnN0YXR1cyB8fCAoeGhyLnN0YXR1cyA+PSAyMDAgJiYgeGhyLnN0YXR1cyA8IDMwMCkpIHtcbiAgICAgIGNvbnN0IHR5cGUgPSBmb3JtYXQuZ2V0VHlwZSgpO1xuICAgICAgLyoqIEB0eXBlIHtEb2N1bWVudHxOb2RlfE9iamVjdHxzdHJpbmd8dW5kZWZpbmVkfSAqL1xuICAgICAgbGV0IHNvdXJjZTtcbiAgICAgIGlmICh0eXBlID09ICdqc29uJyB8fCB0eXBlID09ICd0ZXh0Jykge1xuICAgICAgICBzb3VyY2UgPSB4aHIucmVzcG9uc2VUZXh0O1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09ICd4bWwnKSB7XG4gICAgICAgIHNvdXJjZSA9IHhoci5yZXNwb25zZVhNTDtcbiAgICAgICAgaWYgKCFzb3VyY2UpIHtcbiAgICAgICAgICBzb3VyY2UgPSBuZXcgRE9NUGFyc2VyKCkucGFyc2VGcm9tU3RyaW5nKFxuICAgICAgICAgICAgeGhyLnJlc3BvbnNlVGV4dCxcbiAgICAgICAgICAgICdhcHBsaWNhdGlvbi94bWwnXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlID09ICdhcnJheWJ1ZmZlcicpIHtcbiAgICAgICAgc291cmNlID0gLyoqIEB0eXBlIHtBcnJheUJ1ZmZlcn0gKi8gKHhoci5yZXNwb25zZSk7XG4gICAgICB9XG4gICAgICBpZiAoc291cmNlKSB7XG4gICAgICAgIHN1Y2Nlc3MoXG4gICAgICAgICAgLyoqIEB0eXBlIHtBcnJheTxpbXBvcnQoXCIuL0ZlYXR1cmUuanNcIikuZGVmYXVsdD59ICovXG4gICAgICAgICAgKFxuICAgICAgICAgICAgZm9ybWF0LnJlYWRGZWF0dXJlcyhzb3VyY2UsIHtcbiAgICAgICAgICAgICAgZXh0ZW50OiBleHRlbnQsXG4gICAgICAgICAgICAgIGZlYXR1cmVQcm9qZWN0aW9uOiBwcm9qZWN0aW9uLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICApLFxuICAgICAgICAgIGZvcm1hdC5yZWFkUHJvamVjdGlvbihzb3VyY2UpXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmYWlsdXJlKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZhaWx1cmUoKTtcbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgeGhyLm9uZXJyb3IgPSBmYWlsdXJlO1xuICB4aHIuc2VuZCgpO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhbiBYSFIgZmVhdHVyZSBsb2FkZXIgZm9yIGEgYHVybGAgYW5kIGBmb3JtYXRgLiBUaGUgZmVhdHVyZSBsb2FkZXJcbiAqIGxvYWRzIGZlYXR1cmVzICh3aXRoIFhIUiksIHBhcnNlcyB0aGUgZmVhdHVyZXMsIGFuZCBhZGRzIHRoZW0gdG8gdGhlXG4gKiB2ZWN0b3Igc291cmNlLlxuICogQHBhcmFtIHtzdHJpbmd8RmVhdHVyZVVybEZ1bmN0aW9ufSB1cmwgRmVhdHVyZSBVUkwgc2VydmljZS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9mb3JtYXQvRmVhdHVyZS5qc1wiKS5kZWZhdWx0fSBmb3JtYXQgRmVhdHVyZSBmb3JtYXQuXG4gKiBAcmV0dXJuIHtGZWF0dXJlTG9hZGVyfSBUaGUgZmVhdHVyZSBsb2FkZXIuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB4aHIodXJsLCBmb3JtYXQpIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9leHRlbnQuanNcIikuRXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICAgKiBAcGFyYW0ge251bWJlcn0gcmVzb2x1dGlvbiBSZXNvbHV0aW9uLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vcHJvai9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR9IHByb2plY3Rpb24gUHJvamVjdGlvbi5cbiAgICogQHBhcmFtIHtmdW5jdGlvbihBcnJheTxpbXBvcnQoXCIuL0ZlYXR1cmUuanNcIikuZGVmYXVsdD4pOiB2b2lkfSBbc3VjY2Vzc10gU3VjY2Vzc1xuICAgKiAgICAgIEZ1bmN0aW9uIGNhbGxlZCB3aGVuIGxvYWRpbmcgc3VjY2VlZGVkLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCk6IHZvaWR9IFtmYWlsdXJlXSBGYWlsdXJlXG4gICAqICAgICAgRnVuY3Rpb24gY2FsbGVkIHdoZW4gbG9hZGluZyBmYWlsZWQuXG4gICAqL1xuICByZXR1cm4gZnVuY3Rpb24gKGV4dGVudCwgcmVzb2x1dGlvbiwgcHJvamVjdGlvbiwgc3VjY2VzcywgZmFpbHVyZSkge1xuICAgIGNvbnN0IHNvdXJjZSA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi9zb3VyY2UvVmVjdG9yXCIpLmRlZmF1bHR9ICovICh0aGlzKTtcbiAgICBsb2FkRmVhdHVyZXNYaHIoXG4gICAgICB1cmwsXG4gICAgICBmb3JtYXQsXG4gICAgICBleHRlbnQsXG4gICAgICByZXNvbHV0aW9uLFxuICAgICAgcHJvamVjdGlvbixcbiAgICAgIC8qKlxuICAgICAgICogQHBhcmFtIHtBcnJheTxpbXBvcnQoXCIuL0ZlYXR1cmUuanNcIikuZGVmYXVsdD59IGZlYXR1cmVzIFRoZSBsb2FkZWQgZmVhdHVyZXMuXG4gICAgICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vcHJvai9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR9IGRhdGFQcm9qZWN0aW9uIERhdGFcbiAgICAgICAqIHByb2plY3Rpb24uXG4gICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uIChmZWF0dXJlcywgZGF0YVByb2plY3Rpb24pIHtcbiAgICAgICAgc291cmNlLmFkZEZlYXR1cmVzKGZlYXR1cmVzKTtcbiAgICAgICAgaWYgKHN1Y2Nlc3MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHN1Y2Nlc3MoZmVhdHVyZXMpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLyogRklYTUUgaGFuZGxlIGVycm9yICovIGZhaWx1cmUgPyBmYWlsdXJlIDogVk9JRFxuICAgICk7XG4gIH07XG59XG5cbi8qKlxuICogU2V0dGVyIGZvciB0aGUgd2l0aENyZWRlbnRpYWxzIGNvbmZpZ3VyYXRpb24gZm9yIHRoZSBYSFIuXG4gKlxuICogQHBhcmFtIHtib29sZWFufSB4aHJXaXRoQ3JlZGVudGlhbHMgVGhlIHZhbHVlIG9mIHdpdGhDcmVkZW50aWFscyB0byBzZXQuXG4gKiBDb21wYXJlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9YTUxIdHRwUmVxdWVzdC9cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldFdpdGhDcmVkZW50aWFscyh4aHJXaXRoQ3JlZGVudGlhbHMpIHtcbiAgd2l0aENyZWRlbnRpYWxzID0geGhyV2l0aENyZWRlbnRpYWxzO1xufVxuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2Zvcm1hdC9GZWF0dXJlXG4gKi9cbmltcG9ydCB7YWJzdHJhY3R9IGZyb20gJy4uL3V0aWwuanMnO1xuaW1wb3J0IHtcbiAgZXF1aXZhbGVudCBhcyBlcXVpdmFsZW50UHJvamVjdGlvbixcbiAgZ2V0IGFzIGdldFByb2plY3Rpb24sXG4gIHRyYW5zZm9ybUV4dGVudCxcbn0gZnJvbSAnLi4vcHJvai5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gUmVhZE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vcHJvai5qc1wiKS5Qcm9qZWN0aW9uTGlrZX0gW2RhdGFQcm9qZWN0aW9uXSBQcm9qZWN0aW9uIG9mIHRoZSBkYXRhIHdlIGFyZSByZWFkaW5nLlxuICogSWYgbm90IHByb3ZpZGVkLCB0aGUgcHJvamVjdGlvbiB3aWxsIGJlIGRlcml2ZWQgZnJvbSB0aGUgZGF0YSAod2hlcmUgcG9zc2libGUpIG9yXG4gKiB0aGUgYGRhdGFQcm9qZWN0aW9uYCBvZiB0aGUgZm9ybWF0IGlzIGFzc2lnbmVkICh3aGVyZSBzZXQpLiBJZiB0aGUgcHJvamVjdGlvblxuICogY2FuIG5vdCBiZSBkZXJpdmVkIGZyb20gdGhlIGRhdGEgYW5kIGlmIG5vIGBkYXRhUHJvamVjdGlvbmAgaXMgc2V0IGZvciBhIGZvcm1hdCxcbiAqIHRoZSBmZWF0dXJlcyB3aWxsIG5vdCBiZSByZXByb2plY3RlZC5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gW2V4dGVudF0gVGlsZSBleHRlbnQgaW4gbWFwIHVuaXRzIG9mIHRoZSB0aWxlIGJlaW5nIHJlYWQuXG4gKiBUaGlzIGlzIG9ubHkgcmVxdWlyZWQgd2hlbiByZWFkaW5nIGRhdGEgd2l0aCB0aWxlIHBpeGVscyBhcyBnZW9tZXRyeSB1bml0cy4gV2hlbiBjb25maWd1cmVkLFxuICogYSBgZGF0YVByb2plY3Rpb25gIHdpdGggYFRJTEVfUElYRUxTYCBhcyBgdW5pdHNgIGFuZCB0aGUgdGlsZSdzIHBpeGVsIGV4dGVudCBhcyBgZXh0ZW50YCBuZWVkcyB0byBiZVxuICogcHJvdmlkZWQuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL3Byb2ouanNcIikuUHJvamVjdGlvbkxpa2V9IFtmZWF0dXJlUHJvamVjdGlvbl0gUHJvamVjdGlvbiBvZiB0aGUgZmVhdHVyZSBnZW9tZXRyaWVzXG4gKiBjcmVhdGVkIGJ5IHRoZSBmb3JtYXQgcmVhZGVyLiBJZiBub3QgcHJvdmlkZWQsIGZlYXR1cmVzIHdpbGwgYmUgcmV0dXJuZWQgaW4gdGhlXG4gKiBgZGF0YVByb2plY3Rpb25gLlxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gV3JpdGVPcHRpb25zXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL3Byb2ouanNcIikuUHJvamVjdGlvbkxpa2V9IFtkYXRhUHJvamVjdGlvbl0gUHJvamVjdGlvbiBvZiB0aGUgZGF0YSB3ZSBhcmUgd3JpdGluZy5cbiAqIElmIG5vdCBwcm92aWRlZCwgdGhlIGBkYXRhUHJvamVjdGlvbmAgb2YgdGhlIGZvcm1hdCBpcyBhc3NpZ25lZCAod2hlcmUgc2V0KS5cbiAqIElmIG5vIGBkYXRhUHJvamVjdGlvbmAgaXMgc2V0IGZvciBhIGZvcm1hdCwgdGhlIGZlYXR1cmVzIHdpbGwgYmUgcmV0dXJuZWRcbiAqIGluIHRoZSBgZmVhdHVyZVByb2plY3Rpb25gLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9wcm9qLmpzXCIpLlByb2plY3Rpb25MaWtlfSBbZmVhdHVyZVByb2plY3Rpb25dIFByb2plY3Rpb24gb2YgdGhlIGZlYXR1cmUgZ2VvbWV0cmllc1xuICogdGhhdCB3aWxsIGJlIHNlcmlhbGl6ZWQgYnkgdGhlIGZvcm1hdCB3cml0ZXIuIElmIG5vdCBwcm92aWRlZCwgZ2VvbWV0cmllcyBhcmUgYXNzdW1lZFxuICogdG8gYmUgaW4gdGhlIGBkYXRhUHJvamVjdGlvbmAgaWYgdGhhdCBpcyBzZXQ7IGluIG90aGVyIHdvcmRzLCB0aGV5IGFyZSBub3QgdHJhbnNmb3JtZWQuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtyaWdodEhhbmRlZF0gV2hlbiB3cml0aW5nIGdlb21ldHJpZXMsIGZvbGxvdyB0aGUgcmlnaHQtaGFuZFxuICogcnVsZSBmb3IgbGluZWFyIHJpbmcgb3JpZW50YXRpb24uICBUaGlzIG1lYW5zIHRoYXQgcG9seWdvbnMgd2lsbCBoYXZlIGNvdW50ZXItY2xvY2t3aXNlXG4gKiBleHRlcmlvciByaW5ncyBhbmQgY2xvY2t3aXNlIGludGVyaW9yIHJpbmdzLiAgQnkgZGVmYXVsdCwgY29vcmRpbmF0ZXMgYXJlIHNlcmlhbGl6ZWRcbiAqIGFzIHRoZXkgYXJlIHByb3ZpZGVkIGF0IGNvbnN0cnVjdGlvbi4gIElmIGB0cnVlYCwgdGhlIHJpZ2h0LWhhbmQgcnVsZSB3aWxsXG4gKiBiZSBhcHBsaWVkLiAgSWYgYGZhbHNlYCwgdGhlIGxlZnQtaGFuZCBydWxlIHdpbGwgYmUgYXBwbGllZCAoY2xvY2t3aXNlIGZvclxuICogZXh0ZXJpb3IgYW5kIGNvdW50ZXItY2xvY2t3aXNlIGZvciBpbnRlcmlvciByaW5ncykuICBOb3RlIHRoYXQgbm90IGFsbFxuICogZm9ybWF0cyBzdXBwb3J0IHRoaXMuICBUaGUgR2VvSlNPTiBmb3JtYXQgZG9lcyB1c2UgdGhpcyBwcm9wZXJ0eSB3aGVuIHdyaXRpbmdcbiAqIGdlb21ldHJpZXMuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2RlY2ltYWxzXSBNYXhpbXVtIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyBmb3IgY29vcmRpbmF0ZXMuXG4gKiBDb29yZGluYXRlcyBhcmUgc3RvcmVkIGludGVybmFsbHkgYXMgZmxvYXRzLCBidXQgZmxvYXRpbmctcG9pbnQgYXJpdGhtZXRpYyBjYW4gY3JlYXRlXG4gKiBjb29yZGluYXRlcyB3aXRoIGEgbGFyZ2UgbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzLCBub3QgZ2VuZXJhbGx5IHdhbnRlZCBvbiBvdXRwdXQuXG4gKiBTZXQgYSBudW1iZXIgaGVyZSB0byByb3VuZCBjb29yZGluYXRlcy4gQ2FuIGFsc28gYmUgdXNlZCB0byBlbnN1cmUgdGhhdFxuICogY29vcmRpbmF0ZXMgcmVhZCBpbiBjYW4gYmUgd3JpdHRlbiBiYWNrIG91dCB3aXRoIHRoZSBzYW1lIG51bWJlciBvZiBkZWNpbWFscy5cbiAqIERlZmF1bHQgaXMgbm8gcm91bmRpbmcuXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7J2FycmF5YnVmZmVyJyB8ICdqc29uJyB8ICd0ZXh0JyB8ICd4bWwnfSBUeXBlXG4gKi9cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBBYnN0cmFjdCBiYXNlIGNsYXNzOyBub3JtYWxseSBvbmx5IHVzZWQgZm9yIGNyZWF0aW5nIHN1YmNsYXNzZXMgYW5kIG5vdFxuICogaW5zdGFudGlhdGVkIGluIGFwcHMuXG4gKiBCYXNlIGNsYXNzIGZvciBmZWF0dXJlIGZvcm1hdHMuXG4gKiB7QGxpbmsgbW9kdWxlOm9sL2Zvcm1hdC9GZWF0dXJlfkZlYXR1cmVGb3JtYXR9IHN1YmNsYXNzZXMgcHJvdmlkZSB0aGUgYWJpbGl0eSB0byBkZWNvZGUgYW5kIGVuY29kZVxuICoge0BsaW5rIG1vZHVsZTpvbC9GZWF0dXJlfkZlYXR1cmV9IG9iamVjdHMgZnJvbSBhIHZhcmlldHkgb2YgY29tbW9ubHkgdXNlZCBnZW9zcGF0aWFsXG4gKiBmaWxlIGZvcm1hdHMuICBTZWUgdGhlIGRvY3VtZW50YXRpb24gZm9yIGVhY2ggZm9ybWF0IGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogQGFic3RyYWN0XG4gKiBAYXBpXG4gKi9cbmNsYXNzIEZlYXR1cmVGb3JtYXQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL3Byb2ovUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0fHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLmRhdGFQcm9qZWN0aW9uID0gdW5kZWZpbmVkO1xuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9wcm9qL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdHx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5kZWZhdWx0RmVhdHVyZVByb2plY3Rpb24gPSB1bmRlZmluZWQ7XG5cbiAgICAvKipcbiAgICAgKiBBIGxpc3QgbWVkaWEgdHlwZXMgc3VwcG9ydGVkIGJ5IHRoZSBmb3JtYXQgaW4gZGVzY2VuZGluZyBvcmRlciBvZiBwcmVmZXJlbmNlLlxuICAgICAqIEB0eXBlIHtBcnJheTxzdHJpbmc+fVxuICAgICAqL1xuICAgIHRoaXMuc3VwcG9ydGVkTWVkaWFUeXBlcyA9IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyB0aGUgZGF0YSBwcm9qZWN0aW9uIHRvIHRoZSByZWFkIG9wdGlvbnMuXG4gICAqIEBwYXJhbSB7RG9jdW1lbnR8RWxlbWVudHxPYmplY3R8c3RyaW5nfSBzb3VyY2UgU291cmNlLlxuICAgKiBAcGFyYW0ge1JlYWRPcHRpb25zfSBbb3B0aW9uc10gT3B0aW9ucy5cbiAgICogQHJldHVybiB7UmVhZE9wdGlvbnN8dW5kZWZpbmVkfSBPcHRpb25zLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBnZXRSZWFkT3B0aW9ucyhzb3VyY2UsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucykge1xuICAgICAgbGV0IGRhdGFQcm9qZWN0aW9uID0gb3B0aW9ucy5kYXRhUHJvamVjdGlvblxuICAgICAgICA/IGdldFByb2plY3Rpb24ob3B0aW9ucy5kYXRhUHJvamVjdGlvbilcbiAgICAgICAgOiB0aGlzLnJlYWRQcm9qZWN0aW9uKHNvdXJjZSk7XG4gICAgICBpZiAoXG4gICAgICAgIG9wdGlvbnMuZXh0ZW50ICYmXG4gICAgICAgIGRhdGFQcm9qZWN0aW9uICYmXG4gICAgICAgIGRhdGFQcm9qZWN0aW9uLmdldFVuaXRzKCkgPT09ICd0aWxlLXBpeGVscydcbiAgICAgICkge1xuICAgICAgICBkYXRhUHJvamVjdGlvbiA9IGdldFByb2plY3Rpb24oZGF0YVByb2plY3Rpb24pO1xuICAgICAgICBkYXRhUHJvamVjdGlvbi5zZXRXb3JsZEV4dGVudChvcHRpb25zLmV4dGVudCk7XG4gICAgICB9XG4gICAgICBvcHRpb25zID0ge1xuICAgICAgICBkYXRhUHJvamVjdGlvbjogZGF0YVByb2plY3Rpb24sXG4gICAgICAgIGZlYXR1cmVQcm9qZWN0aW9uOiBvcHRpb25zLmZlYXR1cmVQcm9qZWN0aW9uLFxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuYWRhcHRPcHRpb25zKG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGBkYXRhUHJvamVjdGlvbmAgb24gdGhlIG9wdGlvbnMsIGlmIG5vIGBkYXRhUHJvamVjdGlvbmBcbiAgICogaXMgc2V0LlxuICAgKiBAcGFyYW0ge1dyaXRlT3B0aW9uc3xSZWFkT3B0aW9uc3x1bmRlZmluZWR9IG9wdGlvbnNcbiAgICogICAgIE9wdGlvbnMuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQHJldHVybiB7V3JpdGVPcHRpb25zfFJlYWRPcHRpb25zfHVuZGVmaW5lZH1cbiAgICogICAgIFVwZGF0ZWQgb3B0aW9ucy5cbiAgICovXG4gIGFkYXB0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oXG4gICAgICB7XG4gICAgICAgIGRhdGFQcm9qZWN0aW9uOiB0aGlzLmRhdGFQcm9qZWN0aW9uLFxuICAgICAgICBmZWF0dXJlUHJvamVjdGlvbjogdGhpcy5kZWZhdWx0RmVhdHVyZVByb2plY3Rpb24sXG4gICAgICB9LFxuICAgICAgb3B0aW9uc1xuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQGFic3RyYWN0XG4gICAqIEByZXR1cm4ge1R5cGV9IFRoZSBmb3JtYXQgdHlwZS5cbiAgICovXG4gIGdldFR5cGUoKSB7XG4gICAgcmV0dXJuIGFic3RyYWN0KCk7XG4gIH1cblxuICAvKipcbiAgICogUmVhZCBhIHNpbmdsZSBmZWF0dXJlIGZyb20gYSBzb3VyY2UuXG4gICAqXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcGFyYW0ge0RvY3VtZW50fEVsZW1lbnR8T2JqZWN0fHN0cmluZ30gc291cmNlIFNvdXJjZS5cbiAgICogQHBhcmFtIHtSZWFkT3B0aW9uc30gW29wdGlvbnNdIFJlYWQgb3B0aW9ucy5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5GZWF0dXJlTGlrZX0gRmVhdHVyZS5cbiAgICovXG4gIHJlYWRGZWF0dXJlKHNvdXJjZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBhYnN0cmFjdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlYWQgYWxsIGZlYXR1cmVzIGZyb20gYSBzb3VyY2UuXG4gICAqXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcGFyYW0ge0RvY3VtZW50fEVsZW1lbnR8QXJyYXlCdWZmZXJ8T2JqZWN0fHN0cmluZ30gc291cmNlIFNvdXJjZS5cbiAgICogQHBhcmFtIHtSZWFkT3B0aW9uc30gW29wdGlvbnNdIFJlYWQgb3B0aW9ucy5cbiAgICogQHJldHVybiB7QXJyYXk8aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5GZWF0dXJlTGlrZT59IEZlYXR1cmVzLlxuICAgKi9cbiAgcmVhZEZlYXR1cmVzKHNvdXJjZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBhYnN0cmFjdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlYWQgYSBzaW5nbGUgZ2VvbWV0cnkgZnJvbSBhIHNvdXJjZS5cbiAgICpcbiAgICogQGFic3RyYWN0XG4gICAqIEBwYXJhbSB7RG9jdW1lbnR8RWxlbWVudHxPYmplY3R8c3RyaW5nfSBzb3VyY2UgU291cmNlLlxuICAgKiBAcGFyYW0ge1JlYWRPcHRpb25zfSBbb3B0aW9uc10gUmVhZCBvcHRpb25zLlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9nZW9tL0dlb21ldHJ5LmpzXCIpLmRlZmF1bHR9IEdlb21ldHJ5LlxuICAgKi9cbiAgcmVhZEdlb21ldHJ5KHNvdXJjZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBhYnN0cmFjdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlYWQgdGhlIHByb2plY3Rpb24gZnJvbSBhIHNvdXJjZS5cbiAgICpcbiAgICogQGFic3RyYWN0XG4gICAqIEBwYXJhbSB7RG9jdW1lbnR8RWxlbWVudHxPYmplY3R8c3RyaW5nfSBzb3VyY2UgU291cmNlLlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9wcm9qL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdHx1bmRlZmluZWR9IFByb2plY3Rpb24uXG4gICAqL1xuICByZWFkUHJvamVjdGlvbihzb3VyY2UpIHtcbiAgICByZXR1cm4gYWJzdHJhY3QoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbmNvZGUgYSBmZWF0dXJlIGluIHRoaXMgZm9ybWF0LlxuICAgKlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9IGZlYXR1cmUgRmVhdHVyZS5cbiAgICogQHBhcmFtIHtXcml0ZU9wdGlvbnN9IFtvcHRpb25zXSBXcml0ZSBvcHRpb25zLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd8QXJyYXlCdWZmZXJ9IFJlc3VsdC5cbiAgICovXG4gIHdyaXRlRmVhdHVyZShmZWF0dXJlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGFic3RyYWN0KCk7XG4gIH1cblxuICAvKipcbiAgICogRW5jb2RlIGFuIGFycmF5IG9mIGZlYXR1cmVzIGluIHRoaXMgZm9ybWF0LlxuICAgKlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHBhcmFtIHtBcnJheTxpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHQ+fSBmZWF0dXJlcyBGZWF0dXJlcy5cbiAgICogQHBhcmFtIHtXcml0ZU9wdGlvbnN9IFtvcHRpb25zXSBXcml0ZSBvcHRpb25zLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd8QXJyYXlCdWZmZXJ9IFJlc3VsdC5cbiAgICovXG4gIHdyaXRlRmVhdHVyZXMoZmVhdHVyZXMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gYWJzdHJhY3QoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXcml0ZSBhIHNpbmdsZSBnZW9tZXRyeSBpbiB0aGlzIGZvcm1hdC5cbiAgICpcbiAgICogQGFic3RyYWN0XG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZ2VvbS9HZW9tZXRyeS5qc1wiKS5kZWZhdWx0fSBnZW9tZXRyeSBHZW9tZXRyeS5cbiAgICogQHBhcmFtIHtXcml0ZU9wdGlvbnN9IFtvcHRpb25zXSBXcml0ZSBvcHRpb25zLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd8QXJyYXlCdWZmZXJ9IFJlc3VsdC5cbiAgICovXG4gIHdyaXRlR2VvbWV0cnkoZ2VvbWV0cnksIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gYWJzdHJhY3QoKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBGZWF0dXJlRm9ybWF0O1xuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZ2VvbS9HZW9tZXRyeS5qc1wiKS5kZWZhdWx0fSBnZW9tZXRyeSBHZW9tZXRyeS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gd3JpdGUgU2V0IHRvIHRydWUgZm9yIHdyaXRpbmcsIGZhbHNlIGZvciByZWFkaW5nLlxuICogQHBhcmFtIHtXcml0ZU9wdGlvbnN8UmVhZE9wdGlvbnN9IFtvcHRpb25zXSBPcHRpb25zLlxuICogQHJldHVybiB7aW1wb3J0KFwiLi4vZ2VvbS9HZW9tZXRyeS5qc1wiKS5kZWZhdWx0fSBUcmFuc2Zvcm1lZCBnZW9tZXRyeS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZm9ybUdlb21ldHJ5V2l0aE9wdGlvbnMoZ2VvbWV0cnksIHdyaXRlLCBvcHRpb25zKSB7XG4gIGNvbnN0IGZlYXR1cmVQcm9qZWN0aW9uID0gb3B0aW9uc1xuICAgID8gZ2V0UHJvamVjdGlvbihvcHRpb25zLmZlYXR1cmVQcm9qZWN0aW9uKVxuICAgIDogbnVsbDtcbiAgY29uc3QgZGF0YVByb2plY3Rpb24gPSBvcHRpb25zID8gZ2V0UHJvamVjdGlvbihvcHRpb25zLmRhdGFQcm9qZWN0aW9uKSA6IG51bGw7XG5cbiAgbGV0IHRyYW5zZm9ybWVkO1xuICBpZiAoXG4gICAgZmVhdHVyZVByb2plY3Rpb24gJiZcbiAgICBkYXRhUHJvamVjdGlvbiAmJlxuICAgICFlcXVpdmFsZW50UHJvamVjdGlvbihmZWF0dXJlUHJvamVjdGlvbiwgZGF0YVByb2plY3Rpb24pXG4gICkge1xuICAgIHRyYW5zZm9ybWVkID0gKHdyaXRlID8gZ2VvbWV0cnkuY2xvbmUoKSA6IGdlb21ldHJ5KS50cmFuc2Zvcm0oXG4gICAgICB3cml0ZSA/IGZlYXR1cmVQcm9qZWN0aW9uIDogZGF0YVByb2plY3Rpb24sXG4gICAgICB3cml0ZSA/IGRhdGFQcm9qZWN0aW9uIDogZmVhdHVyZVByb2plY3Rpb25cbiAgICApO1xuICB9IGVsc2Uge1xuICAgIHRyYW5zZm9ybWVkID0gZ2VvbWV0cnk7XG4gIH1cbiAgaWYgKFxuICAgIHdyaXRlICYmXG4gICAgb3B0aW9ucyAmJlxuICAgIC8qKiBAdHlwZSB7V3JpdGVPcHRpb25zfSAqLyAob3B0aW9ucykuZGVjaW1hbHMgIT09IHVuZGVmaW5lZFxuICApIHtcbiAgICBjb25zdCBwb3dlciA9IE1hdGgucG93KDEwLCAvKiogQHR5cGUge1dyaXRlT3B0aW9uc30gKi8gKG9wdGlvbnMpLmRlY2ltYWxzKTtcbiAgICAvLyBpZiBkZWNpbWFscyBvcHRpb24gb24gd3JpdGUsIHJvdW5kIGVhY2ggY29vcmRpbmF0ZSBhcHByb3ByaWF0ZWx5XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBjb29yZGluYXRlcyBDb29yZGluYXRlcy5cbiAgICAgKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBUcmFuc2Zvcm1lZCBjb29yZGluYXRlcy5cbiAgICAgKi9cbiAgICBjb25zdCB0cmFuc2Zvcm0gPSBmdW5jdGlvbiAoY29vcmRpbmF0ZXMpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IGNvb3JkaW5hdGVzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgY29vcmRpbmF0ZXNbaV0gPSBNYXRoLnJvdW5kKGNvb3JkaW5hdGVzW2ldICogcG93ZXIpIC8gcG93ZXI7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29vcmRpbmF0ZXM7XG4gICAgfTtcbiAgICBpZiAodHJhbnNmb3JtZWQgPT09IGdlb21ldHJ5KSB7XG4gICAgICB0cmFuc2Zvcm1lZCA9IGdlb21ldHJ5LmNsb25lKCk7XG4gICAgfVxuICAgIHRyYW5zZm9ybWVkLmFwcGx5VHJhbnNmb3JtKHRyYW5zZm9ybSk7XG4gIH1cbiAgcmV0dXJuIHRyYW5zZm9ybWVkO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEBwYXJhbSB7UmVhZE9wdGlvbnN9IFtvcHRpb25zXSBSZWFkIG9wdGlvbnMuXG4gKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fSBUcmFuc2Zvcm1lZCBleHRlbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1FeHRlbnRXaXRoT3B0aW9ucyhleHRlbnQsIG9wdGlvbnMpIHtcbiAgY29uc3QgZmVhdHVyZVByb2plY3Rpb24gPSBvcHRpb25zXG4gICAgPyBnZXRQcm9qZWN0aW9uKG9wdGlvbnMuZmVhdHVyZVByb2plY3Rpb24pXG4gICAgOiBudWxsO1xuICBjb25zdCBkYXRhUHJvamVjdGlvbiA9IG9wdGlvbnMgPyBnZXRQcm9qZWN0aW9uKG9wdGlvbnMuZGF0YVByb2plY3Rpb24pIDogbnVsbDtcblxuICBpZiAoXG4gICAgZmVhdHVyZVByb2plY3Rpb24gJiZcbiAgICBkYXRhUHJvamVjdGlvbiAmJlxuICAgICFlcXVpdmFsZW50UHJvamVjdGlvbihmZWF0dXJlUHJvamVjdGlvbiwgZGF0YVByb2plY3Rpb24pXG4gICkge1xuICAgIHJldHVybiB0cmFuc2Zvcm1FeHRlbnQoZXh0ZW50LCBkYXRhUHJvamVjdGlvbiwgZmVhdHVyZVByb2plY3Rpb24pO1xuICB9XG4gIHJldHVybiBleHRlbnQ7XG59XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvZm9ybWF0L0dlb0pTT05cbiAqL1xuXG5pbXBvcnQgRmVhdHVyZSBmcm9tICcuLi9GZWF0dXJlLmpzJztcbmltcG9ydCBHZW9tZXRyeUNvbGxlY3Rpb24gZnJvbSAnLi4vZ2VvbS9HZW9tZXRyeUNvbGxlY3Rpb24uanMnO1xuaW1wb3J0IEpTT05GZWF0dXJlIGZyb20gJy4vSlNPTkZlYXR1cmUuanMnO1xuaW1wb3J0IExpbmVTdHJpbmcgZnJvbSAnLi4vZ2VvbS9MaW5lU3RyaW5nLmpzJztcbmltcG9ydCBNdWx0aUxpbmVTdHJpbmcgZnJvbSAnLi4vZ2VvbS9NdWx0aUxpbmVTdHJpbmcuanMnO1xuaW1wb3J0IE11bHRpUG9pbnQgZnJvbSAnLi4vZ2VvbS9NdWx0aVBvaW50LmpzJztcbmltcG9ydCBNdWx0aVBvbHlnb24gZnJvbSAnLi4vZ2VvbS9NdWx0aVBvbHlnb24uanMnO1xuaW1wb3J0IFBvaW50IGZyb20gJy4uL2dlb20vUG9pbnQuanMnO1xuaW1wb3J0IFBvbHlnb24gZnJvbSAnLi4vZ2VvbS9Qb2x5Z29uLmpzJztcbmltcG9ydCB7Z2V0IGFzIGdldFByb2plY3Rpb259IGZyb20gJy4uL3Byb2ouanMnO1xuaW1wb3J0IHtpc0VtcHR5fSBmcm9tICcuLi9vYmouanMnO1xuaW1wb3J0IHt0cmFuc2Zvcm1HZW9tZXRyeVdpdGhPcHRpb25zfSBmcm9tICcuL0ZlYXR1cmUuanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoXCJnZW9qc29uXCIpLkdlb0pTT059IEdlb0pTT05PYmplY3RcbiAqIEB0eXBlZGVmIHtpbXBvcnQoXCJnZW9qc29uXCIpLkZlYXR1cmV9IEdlb0pTT05GZWF0dXJlXG4gKiBAdHlwZWRlZiB7aW1wb3J0KFwiZ2VvanNvblwiKS5GZWF0dXJlQ29sbGVjdGlvbn0gR2VvSlNPTkZlYXR1cmVDb2xsZWN0aW9uXG4gKiBAdHlwZWRlZiB7aW1wb3J0KFwiZ2VvanNvblwiKS5HZW9tZXRyeX0gR2VvSlNPTkdlb21ldHJ5XG4gKiBAdHlwZWRlZiB7aW1wb3J0KFwiZ2VvanNvblwiKS5Qb2ludH0gR2VvSlNPTlBvaW50XG4gKiBAdHlwZWRlZiB7aW1wb3J0KFwiZ2VvanNvblwiKS5MaW5lU3RyaW5nfSBHZW9KU09OTGluZVN0cmluZ1xuICogQHR5cGVkZWYge2ltcG9ydChcImdlb2pzb25cIikuUG9seWdvbn0gR2VvSlNPTlBvbHlnb25cbiAqIEB0eXBlZGVmIHtpbXBvcnQoXCJnZW9qc29uXCIpLk11bHRpUG9pbnR9IEdlb0pTT05NdWx0aVBvaW50XG4gKiBAdHlwZWRlZiB7aW1wb3J0KFwiZ2VvanNvblwiKS5NdWx0aUxpbmVTdHJpbmd9IEdlb0pTT05NdWx0aUxpbmVTdHJpbmdcbiAqIEB0eXBlZGVmIHtpbXBvcnQoXCJnZW9qc29uXCIpLk11bHRpUG9seWdvbn0gR2VvSlNPTk11bHRpUG9seWdvblxuICogQHR5cGVkZWYge2ltcG9ydChcImdlb2pzb25cIikuR2VvbWV0cnlDb2xsZWN0aW9ufSBHZW9KU09OR2VvbWV0cnlDb2xsZWN0aW9uXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL3Byb2ouanNcIikuUHJvamVjdGlvbkxpa2V9IFtkYXRhUHJvamVjdGlvbj0nRVBTRzo0MzI2J10gRGVmYXVsdCBkYXRhIHByb2plY3Rpb24uXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL3Byb2ouanNcIikuUHJvamVjdGlvbkxpa2V9IFtmZWF0dXJlUHJvamVjdGlvbl0gUHJvamVjdGlvbiBmb3IgZmVhdHVyZXMgcmVhZCBvclxuICogd3JpdHRlbiBieSB0aGUgZm9ybWF0LiAgT3B0aW9ucyBwYXNzZWQgdG8gcmVhZCBvciB3cml0ZSBtZXRob2RzIHdpbGwgdGFrZSBwcmVjZWRlbmNlLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtnZW9tZXRyeU5hbWVdIEdlb21ldHJ5IG5hbWUgdG8gdXNlIHdoZW4gY3JlYXRpbmcgZmVhdHVyZXMuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtleHRyYWN0R2VvbWV0cnlOYW1lPWZhbHNlXSBDZXJ0YWluIEdlb0pTT04gcHJvdmlkZXJzIGluY2x1ZGVcbiAqIHRoZSBnZW9tZXRyeV9uYW1lIGZpZWxkIGluIHRoZSBmZWF0dXJlIEdlb0pTT04uIElmIHNldCB0byBgdHJ1ZWAgdGhlIEdlb0pTT04gcmVhZGVyXG4gKiB3aWxsIGxvb2sgZm9yIHRoYXQgZmllbGQgdG8gc2V0IHRoZSBnZW9tZXRyeSBuYW1lLiBJZiBib3RoIHRoaXMgZmllbGQgaXMgc2V0IHRvIGB0cnVlYFxuICogYW5kIGEgYGdlb21ldHJ5TmFtZWAgaXMgcHJvdmlkZWQsIHRoZSBgZ2VvbWV0cnlOYW1lYCB3aWxsIHRha2UgcHJlY2VkZW5jZS5cbiAqL1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEZlYXR1cmUgZm9ybWF0IGZvciByZWFkaW5nIGFuZCB3cml0aW5nIGRhdGEgaW4gdGhlIEdlb0pTT04gZm9ybWF0LlxuICpcbiAqIEBhcGlcbiAqL1xuY2xhc3MgR2VvSlNPTiBleHRlbmRzIEpTT05GZWF0dXJlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7T3B0aW9uc30gW29wdGlvbnNdIE9wdGlvbnMuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgPyBvcHRpb25zIDoge307XG5cbiAgICBzdXBlcigpO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL3Byb2ovUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0fVxuICAgICAqL1xuICAgIHRoaXMuZGF0YVByb2plY3Rpb24gPSBnZXRQcm9qZWN0aW9uKFxuICAgICAgb3B0aW9ucy5kYXRhUHJvamVjdGlvbiA/IG9wdGlvbnMuZGF0YVByb2plY3Rpb24gOiAnRVBTRzo0MzI2J1xuICAgICk7XG5cbiAgICBpZiAob3B0aW9ucy5mZWF0dXJlUHJvamVjdGlvbikge1xuICAgICAgLyoqXG4gICAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vcHJvai9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR9XG4gICAgICAgKi9cbiAgICAgIHRoaXMuZGVmYXVsdEZlYXR1cmVQcm9qZWN0aW9uID0gZ2V0UHJvamVjdGlvbihvcHRpb25zLmZlYXR1cmVQcm9qZWN0aW9uKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBOYW1lIG9mIHRoZSBnZW9tZXRyeSBhdHRyaWJ1dGUgZm9yIGZlYXR1cmVzLlxuICAgICAqIEB0eXBlIHtzdHJpbmd8dW5kZWZpbmVkfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5nZW9tZXRyeU5hbWVfID0gb3B0aW9ucy5nZW9tZXRyeU5hbWU7XG5cbiAgICAvKipcbiAgICAgKiBMb29rIGZvciB0aGUgZ2VvbWV0cnkgbmFtZSBpbiB0aGUgZmVhdHVyZSBHZW9KU09OXG4gICAgICogQHR5cGUge2Jvb2xlYW58dW5kZWZpbmVkfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5leHRyYWN0R2VvbWV0cnlOYW1lXyA9IG9wdGlvbnMuZXh0cmFjdEdlb21ldHJ5TmFtZTtcblxuICAgIHRoaXMuc3VwcG9ydGVkTWVkaWFUeXBlcyA9IFtcbiAgICAgICdhcHBsaWNhdGlvbi9nZW8ranNvbicsXG4gICAgICAnYXBwbGljYXRpb24vdm5kLmdlbytqc29uJyxcbiAgICBdO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0LlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vRmVhdHVyZS5qc1wiKS5SZWFkT3B0aW9uc30gW29wdGlvbnNdIFJlYWQgb3B0aW9ucy5cbiAgICogQHByb3RlY3RlZFxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9IEZlYXR1cmUuXG4gICAqL1xuICByZWFkRmVhdHVyZUZyb21PYmplY3Qob2JqZWN0LCBvcHRpb25zKSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge0dlb0pTT05GZWF0dXJlfVxuICAgICAqL1xuICAgIGxldCBnZW9KU09ORmVhdHVyZSA9IG51bGw7XG4gICAgaWYgKG9iamVjdFsndHlwZSddID09PSAnRmVhdHVyZScpIHtcbiAgICAgIGdlb0pTT05GZWF0dXJlID0gLyoqIEB0eXBlIHtHZW9KU09ORmVhdHVyZX0gKi8gKG9iamVjdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdlb0pTT05GZWF0dXJlID0ge1xuICAgICAgICAndHlwZSc6ICdGZWF0dXJlJyxcbiAgICAgICAgJ2dlb21ldHJ5JzogLyoqIEB0eXBlIHtHZW9KU09OR2VvbWV0cnl9ICovIChvYmplY3QpLFxuICAgICAgICAncHJvcGVydGllcyc6IG51bGwsXG4gICAgICB9O1xuICAgIH1cblxuICAgIGNvbnN0IGdlb21ldHJ5ID0gcmVhZEdlb21ldHJ5KGdlb0pTT05GZWF0dXJlWydnZW9tZXRyeSddLCBvcHRpb25zKTtcbiAgICBjb25zdCBmZWF0dXJlID0gbmV3IEZlYXR1cmUoKTtcbiAgICBpZiAodGhpcy5nZW9tZXRyeU5hbWVfKSB7XG4gICAgICBmZWF0dXJlLnNldEdlb21ldHJ5TmFtZSh0aGlzLmdlb21ldHJ5TmFtZV8pO1xuICAgIH0gZWxzZSBpZiAoXG4gICAgICB0aGlzLmV4dHJhY3RHZW9tZXRyeU5hbWVfICYmXG4gICAgICAnZ2VvbWV0cnlfbmFtZScgaW4gZ2VvSlNPTkZlYXR1cmUgIT09IHVuZGVmaW5lZFxuICAgICkge1xuICAgICAgZmVhdHVyZS5zZXRHZW9tZXRyeU5hbWUoZ2VvSlNPTkZlYXR1cmVbJ2dlb21ldHJ5X25hbWUnXSk7XG4gICAgfVxuICAgIGZlYXR1cmUuc2V0R2VvbWV0cnkoZ2VvbWV0cnkpO1xuXG4gICAgaWYgKCdpZCcgaW4gZ2VvSlNPTkZlYXR1cmUpIHtcbiAgICAgIGZlYXR1cmUuc2V0SWQoZ2VvSlNPTkZlYXR1cmVbJ2lkJ10pO1xuICAgIH1cblxuICAgIGlmIChnZW9KU09ORmVhdHVyZVsncHJvcGVydGllcyddKSB7XG4gICAgICBmZWF0dXJlLnNldFByb3BlcnRpZXMoZ2VvSlNPTkZlYXR1cmVbJ3Byb3BlcnRpZXMnXSwgdHJ1ZSk7XG4gICAgfVxuICAgIHJldHVybiBmZWF0dXJlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0LlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vRmVhdHVyZS5qc1wiKS5SZWFkT3B0aW9uc30gW29wdGlvbnNdIFJlYWQgb3B0aW9ucy5cbiAgICogQHByb3RlY3RlZFxuICAgKiBAcmV0dXJuIHtBcnJheTxGZWF0dXJlPn0gRmVhdHVyZXMuXG4gICAqL1xuICByZWFkRmVhdHVyZXNGcm9tT2JqZWN0KG9iamVjdCwgb3B0aW9ucykge1xuICAgIGNvbnN0IGdlb0pTT05PYmplY3QgPSAvKiogQHR5cGUge0dlb0pTT05PYmplY3R9ICovIChvYmplY3QpO1xuICAgIC8qKiBAdHlwZSB7QXJyYXk8aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0Pn0gKi9cbiAgICBsZXQgZmVhdHVyZXMgPSBudWxsO1xuICAgIGlmIChnZW9KU09OT2JqZWN0Wyd0eXBlJ10gPT09ICdGZWF0dXJlQ29sbGVjdGlvbicpIHtcbiAgICAgIGNvbnN0IGdlb0pTT05GZWF0dXJlQ29sbGVjdGlvbiA9IC8qKiBAdHlwZSB7R2VvSlNPTkZlYXR1cmVDb2xsZWN0aW9ufSAqLyAoXG4gICAgICAgIG9iamVjdFxuICAgICAgKTtcbiAgICAgIGZlYXR1cmVzID0gW107XG4gICAgICBjb25zdCBnZW9KU09ORmVhdHVyZXMgPSBnZW9KU09ORmVhdHVyZUNvbGxlY3Rpb25bJ2ZlYXR1cmVzJ107XG4gICAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBnZW9KU09ORmVhdHVyZXMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICBmZWF0dXJlcy5wdXNoKHRoaXMucmVhZEZlYXR1cmVGcm9tT2JqZWN0KGdlb0pTT05GZWF0dXJlc1tpXSwgb3B0aW9ucykpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmZWF0dXJlcyA9IFt0aGlzLnJlYWRGZWF0dXJlRnJvbU9iamVjdChvYmplY3QsIG9wdGlvbnMpXTtcbiAgICB9XG4gICAgcmV0dXJuIGZlYXR1cmVzO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7R2VvSlNPTkdlb21ldHJ5fSBvYmplY3QgT2JqZWN0LlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vRmVhdHVyZS5qc1wiKS5SZWFkT3B0aW9uc30gW29wdGlvbnNdIFJlYWQgb3B0aW9ucy5cbiAgICogQHByb3RlY3RlZFxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9nZW9tL0dlb21ldHJ5LmpzXCIpLmRlZmF1bHR9IEdlb21ldHJ5LlxuICAgKi9cbiAgcmVhZEdlb21ldHJ5RnJvbU9iamVjdChvYmplY3QsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gcmVhZEdlb21ldHJ5KG9iamVjdCwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBPYmplY3QuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vcHJvai9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR9IFByb2plY3Rpb24uXG4gICAqL1xuICByZWFkUHJvamVjdGlvbkZyb21PYmplY3Qob2JqZWN0KSB7XG4gICAgY29uc3QgY3JzID0gb2JqZWN0WydjcnMnXTtcbiAgICBsZXQgcHJvamVjdGlvbjtcbiAgICBpZiAoY3JzKSB7XG4gICAgICBpZiAoY3JzWyd0eXBlJ10gPT0gJ25hbWUnKSB7XG4gICAgICAgIHByb2plY3Rpb24gPSBnZXRQcm9qZWN0aW9uKGNyc1sncHJvcGVydGllcyddWyduYW1lJ10pO1xuICAgICAgfSBlbHNlIGlmIChjcnNbJ3R5cGUnXSA9PT0gJ0VQU0cnKSB7XG4gICAgICAgIHByb2plY3Rpb24gPSBnZXRQcm9qZWN0aW9uKCdFUFNHOicgKyBjcnNbJ3Byb3BlcnRpZXMnXVsnY29kZSddKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBTUlMgdHlwZScpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwcm9qZWN0aW9uID0gdGhpcy5kYXRhUHJvamVjdGlvbjtcbiAgICB9XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vcHJvai9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR9ICovIChwcm9qZWN0aW9uKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbmNvZGUgYSBmZWF0dXJlIGFzIGEgR2VvSlNPTiBGZWF0dXJlIG9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9IGZlYXR1cmUgRmVhdHVyZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL0ZlYXR1cmUuanNcIikuV3JpdGVPcHRpb25zfSBbb3B0aW9uc10gV3JpdGUgb3B0aW9ucy5cbiAgICogQHJldHVybiB7R2VvSlNPTkZlYXR1cmV9IE9iamVjdC5cbiAgICogQGFwaVxuICAgKi9cbiAgd3JpdGVGZWF0dXJlT2JqZWN0KGZlYXR1cmUsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gdGhpcy5hZGFwdE9wdGlvbnMob3B0aW9ucyk7XG5cbiAgICAvKiogQHR5cGUge0dlb0pTT05GZWF0dXJlfSAqL1xuICAgIGNvbnN0IG9iamVjdCA9IHtcbiAgICAgICd0eXBlJzogJ0ZlYXR1cmUnLFxuICAgICAgZ2VvbWV0cnk6IG51bGwsXG4gICAgICBwcm9wZXJ0aWVzOiBudWxsLFxuICAgIH07XG5cbiAgICBjb25zdCBpZCA9IGZlYXR1cmUuZ2V0SWQoKTtcbiAgICBpZiAoaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgb2JqZWN0LmlkID0gaWQ7XG4gICAgfVxuXG4gICAgaWYgKCFmZWF0dXJlLmhhc1Byb3BlcnRpZXMoKSkge1xuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9XG5cbiAgICBjb25zdCBwcm9wZXJ0aWVzID0gZmVhdHVyZS5nZXRQcm9wZXJ0aWVzKCk7XG4gICAgY29uc3QgZ2VvbWV0cnkgPSBmZWF0dXJlLmdldEdlb21ldHJ5KCk7XG4gICAgaWYgKGdlb21ldHJ5KSB7XG4gICAgICBvYmplY3QuZ2VvbWV0cnkgPSB3cml0ZUdlb21ldHJ5KGdlb21ldHJ5LCBvcHRpb25zKTtcblxuICAgICAgZGVsZXRlIHByb3BlcnRpZXNbZmVhdHVyZS5nZXRHZW9tZXRyeU5hbWUoKV07XG4gICAgfVxuXG4gICAgaWYgKCFpc0VtcHR5KHByb3BlcnRpZXMpKSB7XG4gICAgICBvYmplY3QucHJvcGVydGllcyA9IHByb3BlcnRpZXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbmNvZGUgYW4gYXJyYXkgb2YgZmVhdHVyZXMgYXMgYSBHZW9KU09OIG9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheTxpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHQ+fSBmZWF0dXJlcyBGZWF0dXJlcy5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL0ZlYXR1cmUuanNcIikuV3JpdGVPcHRpb25zfSBbb3B0aW9uc10gV3JpdGUgb3B0aW9ucy5cbiAgICogQHJldHVybiB7R2VvSlNPTkZlYXR1cmVDb2xsZWN0aW9ufSBHZW9KU09OIE9iamVjdC5cbiAgICogQGFwaVxuICAgKi9cbiAgd3JpdGVGZWF0dXJlc09iamVjdChmZWF0dXJlcywgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSB0aGlzLmFkYXB0T3B0aW9ucyhvcHRpb25zKTtcbiAgICBjb25zdCBvYmplY3RzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gZmVhdHVyZXMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgb2JqZWN0cy5wdXNoKHRoaXMud3JpdGVGZWF0dXJlT2JqZWN0KGZlYXR1cmVzW2ldLCBvcHRpb25zKSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiAnRmVhdHVyZUNvbGxlY3Rpb24nLFxuICAgICAgZmVhdHVyZXM6IG9iamVjdHMsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbmNvZGUgYSBnZW9tZXRyeSBhcyBhIEdlb0pTT04gb2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2dlb20vR2VvbWV0cnkuanNcIikuZGVmYXVsdH0gZ2VvbWV0cnkgR2VvbWV0cnkuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9GZWF0dXJlLmpzXCIpLldyaXRlT3B0aW9uc30gW29wdGlvbnNdIFdyaXRlIG9wdGlvbnMuXG4gICAqIEByZXR1cm4ge0dlb0pTT05HZW9tZXRyeXxHZW9KU09OR2VvbWV0cnlDb2xsZWN0aW9ufSBPYmplY3QuXG4gICAqIEBhcGlcbiAgICovXG4gIHdyaXRlR2VvbWV0cnlPYmplY3QoZ2VvbWV0cnksIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gd3JpdGVHZW9tZXRyeShnZW9tZXRyeSwgdGhpcy5hZGFwdE9wdGlvbnMob3B0aW9ucykpO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtHZW9KU09OR2VvbWV0cnl8R2VvSlNPTkdlb21ldHJ5Q29sbGVjdGlvbn0gb2JqZWN0IE9iamVjdC5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9GZWF0dXJlLmpzXCIpLlJlYWRPcHRpb25zfSBbb3B0aW9uc10gUmVhZCBvcHRpb25zLlxuICogQHJldHVybiB7aW1wb3J0KFwiLi4vZ2VvbS9HZW9tZXRyeS5qc1wiKS5kZWZhdWx0fSBHZW9tZXRyeS5cbiAqL1xuZnVuY3Rpb24gcmVhZEdlb21ldHJ5KG9iamVjdCwgb3B0aW9ucykge1xuICBpZiAoIW9iamVjdCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9nZW9tL0dlb21ldHJ5LmpzXCIpLmRlZmF1bHR9XG4gICAqL1xuICBsZXQgZ2VvbWV0cnk7XG4gIHN3aXRjaCAob2JqZWN0Wyd0eXBlJ10pIHtcbiAgICBjYXNlICdQb2ludCc6IHtcbiAgICAgIGdlb21ldHJ5ID0gcmVhZFBvaW50R2VvbWV0cnkoLyoqIEB0eXBlIHtHZW9KU09OUG9pbnR9ICovIChvYmplY3QpKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlICdMaW5lU3RyaW5nJzoge1xuICAgICAgZ2VvbWV0cnkgPSByZWFkTGluZVN0cmluZ0dlb21ldHJ5KFxuICAgICAgICAvKiogQHR5cGUge0dlb0pTT05MaW5lU3RyaW5nfSAqLyAob2JqZWN0KVxuICAgICAgKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlICdQb2x5Z29uJzoge1xuICAgICAgZ2VvbWV0cnkgPSByZWFkUG9seWdvbkdlb21ldHJ5KC8qKiBAdHlwZSB7R2VvSlNPTlBvbHlnb259ICovIChvYmplY3QpKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlICdNdWx0aVBvaW50Jzoge1xuICAgICAgZ2VvbWV0cnkgPSByZWFkTXVsdGlQb2ludEdlb21ldHJ5KFxuICAgICAgICAvKiogQHR5cGUge0dlb0pTT05NdWx0aVBvaW50fSAqLyAob2JqZWN0KVxuICAgICAgKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlICdNdWx0aUxpbmVTdHJpbmcnOiB7XG4gICAgICBnZW9tZXRyeSA9IHJlYWRNdWx0aUxpbmVTdHJpbmdHZW9tZXRyeShcbiAgICAgICAgLyoqIEB0eXBlIHtHZW9KU09OTXVsdGlMaW5lU3RyaW5nfSAqLyAob2JqZWN0KVxuICAgICAgKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlICdNdWx0aVBvbHlnb24nOiB7XG4gICAgICBnZW9tZXRyeSA9IHJlYWRNdWx0aVBvbHlnb25HZW9tZXRyeShcbiAgICAgICAgLyoqIEB0eXBlIHtHZW9KU09OTXVsdGlQb2x5Z29ufSAqLyAob2JqZWN0KVxuICAgICAgKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlICdHZW9tZXRyeUNvbGxlY3Rpb24nOiB7XG4gICAgICBnZW9tZXRyeSA9IHJlYWRHZW9tZXRyeUNvbGxlY3Rpb25HZW9tZXRyeShcbiAgICAgICAgLyoqIEB0eXBlIHtHZW9KU09OR2VvbWV0cnlDb2xsZWN0aW9ufSAqLyAob2JqZWN0KVxuICAgICAgKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBkZWZhdWx0OiB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIEdlb0pTT04gdHlwZTogJyArIG9iamVjdFsndHlwZSddKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRyYW5zZm9ybUdlb21ldHJ5V2l0aE9wdGlvbnMoZ2VvbWV0cnksIGZhbHNlLCBvcHRpb25zKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0dlb0pTT05HZW9tZXRyeUNvbGxlY3Rpb259IG9iamVjdCBPYmplY3QuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vRmVhdHVyZS5qc1wiKS5SZWFkT3B0aW9uc30gW29wdGlvbnNdIFJlYWQgb3B0aW9ucy5cbiAqIEByZXR1cm4ge0dlb21ldHJ5Q29sbGVjdGlvbn0gR2VvbWV0cnkgY29sbGVjdGlvbi5cbiAqL1xuZnVuY3Rpb24gcmVhZEdlb21ldHJ5Q29sbGVjdGlvbkdlb21ldHJ5KG9iamVjdCwgb3B0aW9ucykge1xuICBjb25zdCBnZW9tZXRyaWVzID0gb2JqZWN0WydnZW9tZXRyaWVzJ10ubWFwKFxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7R2VvSlNPTkdlb21ldHJ5fSBnZW9tZXRyeSBHZW9tZXRyeS5cbiAgICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9nZW9tL0dlb21ldHJ5LmpzXCIpLmRlZmF1bHR9IGdlb21ldHJ5IEdlb21ldHJ5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChnZW9tZXRyeSkge1xuICAgICAgcmV0dXJuIHJlYWRHZW9tZXRyeShnZW9tZXRyeSwgb3B0aW9ucyk7XG4gICAgfVxuICApO1xuICByZXR1cm4gbmV3IEdlb21ldHJ5Q29sbGVjdGlvbihnZW9tZXRyaWVzKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0dlb0pTT05Qb2ludH0gb2JqZWN0IE9iamVjdC5cbiAqIEByZXR1cm4ge1BvaW50fSBQb2ludC5cbiAqL1xuZnVuY3Rpb24gcmVhZFBvaW50R2VvbWV0cnkob2JqZWN0KSB7XG4gIHJldHVybiBuZXcgUG9pbnQob2JqZWN0Wydjb29yZGluYXRlcyddKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0dlb0pTT05MaW5lU3RyaW5nfSBvYmplY3QgT2JqZWN0LlxuICogQHJldHVybiB7TGluZVN0cmluZ30gTGluZVN0cmluZy5cbiAqL1xuZnVuY3Rpb24gcmVhZExpbmVTdHJpbmdHZW9tZXRyeShvYmplY3QpIHtcbiAgcmV0dXJuIG5ldyBMaW5lU3RyaW5nKG9iamVjdFsnY29vcmRpbmF0ZXMnXSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtHZW9KU09OTXVsdGlMaW5lU3RyaW5nfSBvYmplY3QgT2JqZWN0LlxuICogQHJldHVybiB7TXVsdGlMaW5lU3RyaW5nfSBNdWx0aUxpbmVTdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIHJlYWRNdWx0aUxpbmVTdHJpbmdHZW9tZXRyeShvYmplY3QpIHtcbiAgcmV0dXJuIG5ldyBNdWx0aUxpbmVTdHJpbmcob2JqZWN0Wydjb29yZGluYXRlcyddKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0dlb0pTT05NdWx0aVBvaW50fSBvYmplY3QgT2JqZWN0LlxuICogQHJldHVybiB7TXVsdGlQb2ludH0gTXVsdGlQb2ludC5cbiAqL1xuZnVuY3Rpb24gcmVhZE11bHRpUG9pbnRHZW9tZXRyeShvYmplY3QpIHtcbiAgcmV0dXJuIG5ldyBNdWx0aVBvaW50KG9iamVjdFsnY29vcmRpbmF0ZXMnXSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtHZW9KU09OTXVsdGlQb2x5Z29ufSBvYmplY3QgT2JqZWN0LlxuICogQHJldHVybiB7TXVsdGlQb2x5Z29ufSBNdWx0aVBvbHlnb24uXG4gKi9cbmZ1bmN0aW9uIHJlYWRNdWx0aVBvbHlnb25HZW9tZXRyeShvYmplY3QpIHtcbiAgcmV0dXJuIG5ldyBNdWx0aVBvbHlnb24ob2JqZWN0Wydjb29yZGluYXRlcyddKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0dlb0pTT05Qb2x5Z29ufSBvYmplY3QgT2JqZWN0LlxuICogQHJldHVybiB7UG9seWdvbn0gUG9seWdvbi5cbiAqL1xuZnVuY3Rpb24gcmVhZFBvbHlnb25HZW9tZXRyeShvYmplY3QpIHtcbiAgcmV0dXJuIG5ldyBQb2x5Z29uKG9iamVjdFsnY29vcmRpbmF0ZXMnXSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9nZW9tL0dlb21ldHJ5LmpzXCIpLmRlZmF1bHR9IGdlb21ldHJ5IEdlb21ldHJ5LlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL0ZlYXR1cmUuanNcIikuV3JpdGVPcHRpb25zfSBbb3B0aW9uc10gV3JpdGUgb3B0aW9ucy5cbiAqIEByZXR1cm4ge0dlb0pTT05HZW9tZXRyeX0gR2VvSlNPTiBnZW9tZXRyeS5cbiAqL1xuZnVuY3Rpb24gd3JpdGVHZW9tZXRyeShnZW9tZXRyeSwgb3B0aW9ucykge1xuICBnZW9tZXRyeSA9IHRyYW5zZm9ybUdlb21ldHJ5V2l0aE9wdGlvbnMoZ2VvbWV0cnksIHRydWUsIG9wdGlvbnMpO1xuICBjb25zdCB0eXBlID0gZ2VvbWV0cnkuZ2V0VHlwZSgpO1xuXG4gIC8qKiBAdHlwZSB7R2VvSlNPTkdlb21ldHJ5fSAqL1xuICBsZXQgZ2VvSlNPTjtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAnUG9pbnQnOiB7XG4gICAgICBnZW9KU09OID0gd3JpdGVQb2ludEdlb21ldHJ5KC8qKiBAdHlwZSB7UG9pbnR9ICovIChnZW9tZXRyeSksIG9wdGlvbnMpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgJ0xpbmVTdHJpbmcnOiB7XG4gICAgICBnZW9KU09OID0gd3JpdGVMaW5lU3RyaW5nR2VvbWV0cnkoXG4gICAgICAgIC8qKiBAdHlwZSB7TGluZVN0cmluZ30gKi8gKGdlb21ldHJ5KSxcbiAgICAgICAgb3B0aW9uc1xuICAgICAgKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlICdQb2x5Z29uJzoge1xuICAgICAgZ2VvSlNPTiA9IHdyaXRlUG9seWdvbkdlb21ldHJ5KFxuICAgICAgICAvKiogQHR5cGUge1BvbHlnb259ICovIChnZW9tZXRyeSksXG4gICAgICAgIG9wdGlvbnNcbiAgICAgICk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSAnTXVsdGlQb2ludCc6IHtcbiAgICAgIGdlb0pTT04gPSB3cml0ZU11bHRpUG9pbnRHZW9tZXRyeShcbiAgICAgICAgLyoqIEB0eXBlIHtNdWx0aVBvaW50fSAqLyAoZ2VvbWV0cnkpLFxuICAgICAgICBvcHRpb25zXG4gICAgICApO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgJ011bHRpTGluZVN0cmluZyc6IHtcbiAgICAgIGdlb0pTT04gPSB3cml0ZU11bHRpTGluZVN0cmluZ0dlb21ldHJ5KFxuICAgICAgICAvKiogQHR5cGUge011bHRpTGluZVN0cmluZ30gKi8gKGdlb21ldHJ5KSxcbiAgICAgICAgb3B0aW9uc1xuICAgICAgKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlICdNdWx0aVBvbHlnb24nOiB7XG4gICAgICBnZW9KU09OID0gd3JpdGVNdWx0aVBvbHlnb25HZW9tZXRyeShcbiAgICAgICAgLyoqIEB0eXBlIHtNdWx0aVBvbHlnb259ICovIChnZW9tZXRyeSksXG4gICAgICAgIG9wdGlvbnNcbiAgICAgICk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSAnR2VvbWV0cnlDb2xsZWN0aW9uJzoge1xuICAgICAgZ2VvSlNPTiA9IHdyaXRlR2VvbWV0cnlDb2xsZWN0aW9uR2VvbWV0cnkoXG4gICAgICAgIC8qKiBAdHlwZSB7R2VvbWV0cnlDb2xsZWN0aW9ufSAqLyAoZ2VvbWV0cnkpLFxuICAgICAgICBvcHRpb25zXG4gICAgICApO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgJ0NpcmNsZSc6IHtcbiAgICAgIGdlb0pTT04gPSB7XG4gICAgICAgIHR5cGU6ICdHZW9tZXRyeUNvbGxlY3Rpb24nLFxuICAgICAgICBnZW9tZXRyaWVzOiBbXSxcbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgZGVmYXVsdDoge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBnZW9tZXRyeSB0eXBlOiAnICsgdHlwZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBnZW9KU09OO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7R2VvbWV0cnlDb2xsZWN0aW9ufSBnZW9tZXRyeSBHZW9tZXRyeS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9GZWF0dXJlLmpzXCIpLldyaXRlT3B0aW9uc30gW29wdGlvbnNdIFdyaXRlIG9wdGlvbnMuXG4gKiBAcmV0dXJuIHtHZW9KU09OR2VvbWV0cnlDb2xsZWN0aW9ufSBHZW9KU09OIGdlb21ldHJ5IGNvbGxlY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIHdyaXRlR2VvbWV0cnlDb2xsZWN0aW9uR2VvbWV0cnkoZ2VvbWV0cnksIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpO1xuICBkZWxldGUgb3B0aW9ucy5mZWF0dXJlUHJvamVjdGlvbjtcbiAgY29uc3QgZ2VvbWV0cmllcyA9IGdlb21ldHJ5LmdldEdlb21ldHJpZXNBcnJheSgpLm1hcChmdW5jdGlvbiAoZ2VvbWV0cnkpIHtcbiAgICByZXR1cm4gd3JpdGVHZW9tZXRyeShnZW9tZXRyeSwgb3B0aW9ucyk7XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdHZW9tZXRyeUNvbGxlY3Rpb24nLFxuICAgIGdlb21ldHJpZXM6IGdlb21ldHJpZXMsXG4gIH07XG59XG5cbi8qKlxuICogQHBhcmFtIHtMaW5lU3RyaW5nfSBnZW9tZXRyeSBHZW9tZXRyeS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9GZWF0dXJlLmpzXCIpLldyaXRlT3B0aW9uc30gW29wdGlvbnNdIFdyaXRlIG9wdGlvbnMuXG4gKiBAcmV0dXJuIHtHZW9KU09OR2VvbWV0cnl9IEdlb0pTT04gZ2VvbWV0cnkuXG4gKi9cbmZ1bmN0aW9uIHdyaXRlTGluZVN0cmluZ0dlb21ldHJ5KGdlb21ldHJ5LCBvcHRpb25zKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0xpbmVTdHJpbmcnLFxuICAgIGNvb3JkaW5hdGVzOiBnZW9tZXRyeS5nZXRDb29yZGluYXRlcygpLFxuICB9O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7TXVsdGlMaW5lU3RyaW5nfSBnZW9tZXRyeSBHZW9tZXRyeS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9GZWF0dXJlLmpzXCIpLldyaXRlT3B0aW9uc30gW29wdGlvbnNdIFdyaXRlIG9wdGlvbnMuXG4gKiBAcmV0dXJuIHtHZW9KU09OR2VvbWV0cnl9IEdlb0pTT04gZ2VvbWV0cnkuXG4gKi9cbmZ1bmN0aW9uIHdyaXRlTXVsdGlMaW5lU3RyaW5nR2VvbWV0cnkoZ2VvbWV0cnksIG9wdGlvbnMpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnTXVsdGlMaW5lU3RyaW5nJyxcbiAgICBjb29yZGluYXRlczogZ2VvbWV0cnkuZ2V0Q29vcmRpbmF0ZXMoKSxcbiAgfTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge011bHRpUG9pbnR9IGdlb21ldHJ5IEdlb21ldHJ5LlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL0ZlYXR1cmUuanNcIikuV3JpdGVPcHRpb25zfSBbb3B0aW9uc10gV3JpdGUgb3B0aW9ucy5cbiAqIEByZXR1cm4ge0dlb0pTT05HZW9tZXRyeX0gR2VvSlNPTiBnZW9tZXRyeS5cbiAqL1xuZnVuY3Rpb24gd3JpdGVNdWx0aVBvaW50R2VvbWV0cnkoZ2VvbWV0cnksIG9wdGlvbnMpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnTXVsdGlQb2ludCcsXG4gICAgY29vcmRpbmF0ZXM6IGdlb21ldHJ5LmdldENvb3JkaW5hdGVzKCksXG4gIH07XG59XG5cbi8qKlxuICogQHBhcmFtIHtNdWx0aVBvbHlnb259IGdlb21ldHJ5IEdlb21ldHJ5LlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL0ZlYXR1cmUuanNcIikuV3JpdGVPcHRpb25zfSBbb3B0aW9uc10gV3JpdGUgb3B0aW9ucy5cbiAqIEByZXR1cm4ge0dlb0pTT05HZW9tZXRyeX0gR2VvSlNPTiBnZW9tZXRyeS5cbiAqL1xuZnVuY3Rpb24gd3JpdGVNdWx0aVBvbHlnb25HZW9tZXRyeShnZW9tZXRyeSwgb3B0aW9ucykge1xuICBsZXQgcmlnaHQ7XG4gIGlmIChvcHRpb25zKSB7XG4gICAgcmlnaHQgPSBvcHRpb25zLnJpZ2h0SGFuZGVkO1xuICB9XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ011bHRpUG9seWdvbicsXG4gICAgY29vcmRpbmF0ZXM6IGdlb21ldHJ5LmdldENvb3JkaW5hdGVzKHJpZ2h0KSxcbiAgfTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1BvaW50fSBnZW9tZXRyeSBHZW9tZXRyeS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9GZWF0dXJlLmpzXCIpLldyaXRlT3B0aW9uc30gW29wdGlvbnNdIFdyaXRlIG9wdGlvbnMuXG4gKiBAcmV0dXJuIHtHZW9KU09OR2VvbWV0cnl9IEdlb0pTT04gZ2VvbWV0cnkuXG4gKi9cbmZ1bmN0aW9uIHdyaXRlUG9pbnRHZW9tZXRyeShnZW9tZXRyeSwgb3B0aW9ucykge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdQb2ludCcsXG4gICAgY29vcmRpbmF0ZXM6IGdlb21ldHJ5LmdldENvb3JkaW5hdGVzKCksXG4gIH07XG59XG5cbi8qKlxuICogQHBhcmFtIHtQb2x5Z29ufSBnZW9tZXRyeSBHZW9tZXRyeS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9GZWF0dXJlLmpzXCIpLldyaXRlT3B0aW9uc30gW29wdGlvbnNdIFdyaXRlIG9wdGlvbnMuXG4gKiBAcmV0dXJuIHtHZW9KU09OR2VvbWV0cnl9IEdlb0pTT04gZ2VvbWV0cnkuXG4gKi9cbmZ1bmN0aW9uIHdyaXRlUG9seWdvbkdlb21ldHJ5KGdlb21ldHJ5LCBvcHRpb25zKSB7XG4gIGxldCByaWdodDtcbiAgaWYgKG9wdGlvbnMpIHtcbiAgICByaWdodCA9IG9wdGlvbnMucmlnaHRIYW5kZWQ7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnUG9seWdvbicsXG4gICAgY29vcmRpbmF0ZXM6IGdlb21ldHJ5LmdldENvb3JkaW5hdGVzKHJpZ2h0KSxcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgR2VvSlNPTjtcbiIsIi8qKlxuICogQG1vZHVsZSBvbC9mb3JtYXQvSlNPTkZlYXR1cmVcbiAqL1xuaW1wb3J0IEZlYXR1cmVGb3JtYXQgZnJvbSAnLi9GZWF0dXJlLmpzJztcbmltcG9ydCB7YWJzdHJhY3R9IGZyb20gJy4uL3V0aWwuanMnO1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEFic3RyYWN0IGJhc2UgY2xhc3M7IG5vcm1hbGx5IG9ubHkgdXNlZCBmb3IgY3JlYXRpbmcgc3ViY2xhc3NlcyBhbmQgbm90XG4gKiBpbnN0YW50aWF0ZWQgaW4gYXBwcy5cbiAqIEJhc2UgY2xhc3MgZm9yIEpTT04gZmVhdHVyZSBmb3JtYXRzLlxuICpcbiAqIEBhYnN0cmFjdFxuICovXG5jbGFzcyBKU09ORmVhdHVyZSBleHRlbmRzIEZlYXR1cmVGb3JtYXQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4vRmVhdHVyZS5qc1wiKS5UeXBlfSBGb3JtYXQuXG4gICAqL1xuICBnZXRUeXBlKCkge1xuICAgIHJldHVybiAnanNvbic7XG4gIH1cblxuICAvKipcbiAgICogUmVhZCBhIGZlYXR1cmUuICBPbmx5IHdvcmtzIGZvciBhIHNpbmdsZSBmZWF0dXJlLiBVc2UgYHJlYWRGZWF0dXJlc2AgdG9cbiAgICogcmVhZCBhIGZlYXR1cmUgY29sbGVjdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheUJ1ZmZlcnxEb2N1bWVudHxFbGVtZW50fE9iamVjdHxzdHJpbmd9IHNvdXJjZSBTb3VyY2UuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9GZWF0dXJlLmpzXCIpLlJlYWRPcHRpb25zfSBbb3B0aW9uc10gUmVhZCBvcHRpb25zLlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9IEZlYXR1cmUuXG4gICAqIEBhcGlcbiAgICovXG4gIHJlYWRGZWF0dXJlKHNvdXJjZSwgb3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLnJlYWRGZWF0dXJlRnJvbU9iamVjdChcbiAgICAgIGdldE9iamVjdChzb3VyY2UpLFxuICAgICAgdGhpcy5nZXRSZWFkT3B0aW9ucyhzb3VyY2UsIG9wdGlvbnMpXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWFkIGFsbCBmZWF0dXJlcy4gIFdvcmtzIHdpdGggYm90aCBhIHNpbmdsZSBmZWF0dXJlIGFuZCBhIGZlYXR1cmVcbiAgICogY29sbGVjdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheUJ1ZmZlcnxEb2N1bWVudHxFbGVtZW50fE9iamVjdHxzdHJpbmd9IHNvdXJjZSBTb3VyY2UuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9GZWF0dXJlLmpzXCIpLlJlYWRPcHRpb25zfSBbb3B0aW9uc10gUmVhZCBvcHRpb25zLlxuICAgKiBAcmV0dXJuIHtBcnJheTxpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHQ+fSBGZWF0dXJlcy5cbiAgICogQGFwaVxuICAgKi9cbiAgcmVhZEZlYXR1cmVzKHNvdXJjZSwgb3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLnJlYWRGZWF0dXJlc0Zyb21PYmplY3QoXG4gICAgICBnZXRPYmplY3Qoc291cmNlKSxcbiAgICAgIHRoaXMuZ2V0UmVhZE9wdGlvbnMoc291cmNlLCBvcHRpb25zKVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQGFic3RyYWN0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0LlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vRmVhdHVyZS5qc1wiKS5SZWFkT3B0aW9uc30gW29wdGlvbnNdIFJlYWQgb3B0aW9ucy5cbiAgICogQHByb3RlY3RlZFxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9IEZlYXR1cmUuXG4gICAqL1xuICByZWFkRmVhdHVyZUZyb21PYmplY3Qob2JqZWN0LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGFic3RyYWN0KCk7XG4gIH1cblxuICAvKipcbiAgICogQGFic3RyYWN0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0LlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vRmVhdHVyZS5qc1wiKS5SZWFkT3B0aW9uc30gW29wdGlvbnNdIFJlYWQgb3B0aW9ucy5cbiAgICogQHByb3RlY3RlZFxuICAgKiBAcmV0dXJuIHtBcnJheTxpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHQ+fSBGZWF0dXJlcy5cbiAgICovXG4gIHJlYWRGZWF0dXJlc0Zyb21PYmplY3Qob2JqZWN0LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGFic3RyYWN0KCk7XG4gIH1cblxuICAvKipcbiAgICogUmVhZCBhIGdlb21ldHJ5LlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5QnVmZmVyfERvY3VtZW50fEVsZW1lbnR8T2JqZWN0fHN0cmluZ30gc291cmNlIFNvdXJjZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL0ZlYXR1cmUuanNcIikuUmVhZE9wdGlvbnN9IFtvcHRpb25zXSBSZWFkIG9wdGlvbnMuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL2dlb20vR2VvbWV0cnkuanNcIikuZGVmYXVsdH0gR2VvbWV0cnkuXG4gICAqIEBhcGlcbiAgICovXG4gIHJlYWRHZW9tZXRyeShzb3VyY2UsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5yZWFkR2VvbWV0cnlGcm9tT2JqZWN0KFxuICAgICAgZ2V0T2JqZWN0KHNvdXJjZSksXG4gICAgICB0aGlzLmdldFJlYWRPcHRpb25zKHNvdXJjZSwgb3B0aW9ucylcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IE9iamVjdC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL0ZlYXR1cmUuanNcIikuUmVhZE9wdGlvbnN9IFtvcHRpb25zXSBSZWFkIG9wdGlvbnMuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vZ2VvbS9HZW9tZXRyeS5qc1wiKS5kZWZhdWx0fSBHZW9tZXRyeS5cbiAgICovXG4gIHJlYWRHZW9tZXRyeUZyb21PYmplY3Qob2JqZWN0LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGFic3RyYWN0KCk7XG4gIH1cblxuICAvKipcbiAgICogUmVhZCB0aGUgcHJvamVjdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheUJ1ZmZlcnxEb2N1bWVudHxFbGVtZW50fE9iamVjdHxzdHJpbmd9IHNvdXJjZSBTb3VyY2UuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL3Byb2ovUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0fSBQcm9qZWN0aW9uLlxuICAgKiBAYXBpXG4gICAqL1xuICByZWFkUHJvamVjdGlvbihzb3VyY2UpIHtcbiAgICByZXR1cm4gdGhpcy5yZWFkUHJvamVjdGlvbkZyb21PYmplY3QoZ2V0T2JqZWN0KHNvdXJjZSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IE9iamVjdC5cbiAgICogQHByb3RlY3RlZFxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9wcm9qL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdH0gUHJvamVjdGlvbi5cbiAgICovXG4gIHJlYWRQcm9qZWN0aW9uRnJvbU9iamVjdChvYmplY3QpIHtcbiAgICByZXR1cm4gYWJzdHJhY3QoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbmNvZGUgYSBmZWF0dXJlIGFzIHN0cmluZy5cbiAgICpcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9IGZlYXR1cmUgRmVhdHVyZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL0ZlYXR1cmUuanNcIikuV3JpdGVPcHRpb25zfSBbb3B0aW9uc10gV3JpdGUgb3B0aW9ucy5cbiAgICogQHJldHVybiB7c3RyaW5nfSBFbmNvZGVkIGZlYXR1cmUuXG4gICAqIEBhcGlcbiAgICovXG4gIHdyaXRlRmVhdHVyZShmZWF0dXJlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMud3JpdGVGZWF0dXJlT2JqZWN0KGZlYXR1cmUsIG9wdGlvbnMpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9IGZlYXR1cmUgRmVhdHVyZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL0ZlYXR1cmUuanNcIikuV3JpdGVPcHRpb25zfSBbb3B0aW9uc10gV3JpdGUgb3B0aW9ucy5cbiAgICogQHJldHVybiB7T2JqZWN0fSBPYmplY3QuXG4gICAqL1xuICB3cml0ZUZlYXR1cmVPYmplY3QoZmVhdHVyZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBhYnN0cmFjdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEVuY29kZSBhbiBhcnJheSBvZiBmZWF0dXJlcyBhcyBzdHJpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXk8aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0Pn0gZmVhdHVyZXMgRmVhdHVyZXMuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9GZWF0dXJlLmpzXCIpLldyaXRlT3B0aW9uc30gW29wdGlvbnNdIFdyaXRlIG9wdGlvbnMuXG4gICAqIEByZXR1cm4ge3N0cmluZ30gRW5jb2RlZCBmZWF0dXJlcy5cbiAgICogQGFwaVxuICAgKi9cbiAgd3JpdGVGZWF0dXJlcyhmZWF0dXJlcywgb3B0aW9ucykge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzLndyaXRlRmVhdHVyZXNPYmplY3QoZmVhdHVyZXMsIG9wdGlvbnMpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHBhcmFtIHtBcnJheTxpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHQ+fSBmZWF0dXJlcyBGZWF0dXJlcy5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL0ZlYXR1cmUuanNcIikuV3JpdGVPcHRpb25zfSBbb3B0aW9uc10gV3JpdGUgb3B0aW9ucy5cbiAgICogQHJldHVybiB7T2JqZWN0fSBPYmplY3QuXG4gICAqL1xuICB3cml0ZUZlYXR1cmVzT2JqZWN0KGZlYXR1cmVzLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGFic3RyYWN0KCk7XG4gIH1cblxuICAvKipcbiAgICogRW5jb2RlIGEgZ2VvbWV0cnkgYXMgc3RyaW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2dlb20vR2VvbWV0cnkuanNcIikuZGVmYXVsdH0gZ2VvbWV0cnkgR2VvbWV0cnkuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9GZWF0dXJlLmpzXCIpLldyaXRlT3B0aW9uc30gW29wdGlvbnNdIFdyaXRlIG9wdGlvbnMuXG4gICAqIEByZXR1cm4ge3N0cmluZ30gRW5jb2RlZCBnZW9tZXRyeS5cbiAgICogQGFwaVxuICAgKi9cbiAgd3JpdGVHZW9tZXRyeShnZW9tZXRyeSwgb3B0aW9ucykge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzLndyaXRlR2VvbWV0cnlPYmplY3QoZ2VvbWV0cnksIG9wdGlvbnMpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9nZW9tL0dlb21ldHJ5LmpzXCIpLmRlZmF1bHR9IGdlb21ldHJ5IEdlb21ldHJ5LlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vRmVhdHVyZS5qc1wiKS5Xcml0ZU9wdGlvbnN9IFtvcHRpb25zXSBXcml0ZSBvcHRpb25zLlxuICAgKiBAcmV0dXJuIHtPYmplY3R9IE9iamVjdC5cbiAgICovXG4gIHdyaXRlR2VvbWV0cnlPYmplY3QoZ2VvbWV0cnksIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gYWJzdHJhY3QoKTtcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7RG9jdW1lbnR8RWxlbWVudHxPYmplY3R8c3RyaW5nfSBzb3VyY2UgU291cmNlLlxuICogQHJldHVybiB7T2JqZWN0fSBPYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGdldE9iamVjdChzb3VyY2UpIHtcbiAgaWYgKHR5cGVvZiBzb3VyY2UgPT09ICdzdHJpbmcnKSB7XG4gICAgY29uc3Qgb2JqZWN0ID0gSlNPTi5wYXJzZShzb3VyY2UpO1xuICAgIHJldHVybiBvYmplY3QgPyAvKiogQHR5cGUge09iamVjdH0gKi8gKG9iamVjdCkgOiBudWxsO1xuICB9XG4gIGlmIChzb3VyY2UgIT09IG51bGwpIHtcbiAgICByZXR1cm4gc291cmNlO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG5leHBvcnQgZGVmYXVsdCBKU09ORmVhdHVyZTtcbiIsIi8qKlxuICogQG1vZHVsZSBvbC9mdW5jdGlvbnNcbiAqL1xuXG5pbXBvcnQge2VxdWFscyBhcyBhcnJheUVxdWFsc30gZnJvbSAnLi9hcnJheS5qcyc7XG5cbi8qKlxuICogQWx3YXlzIHJldHVybnMgdHJ1ZS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBUUlVFKCkge1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBBbHdheXMgcmV0dXJucyBmYWxzZS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IGZhbHNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gRkFMU0UoKSB7XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBBIHJldXNhYmxlIGZ1bmN0aW9uLCB1c2VkIGUuZy4gYXMgYSBkZWZhdWx0IGZvciBjYWxsYmFja3MuXG4gKlxuICogQHJldHVybiB7dm9pZH0gTm90aGluZy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIFZPSUQoKSB7fVxuXG4vKipcbiAqIFdyYXAgYSBmdW5jdGlvbiBpbiBhbm90aGVyIGZ1bmN0aW9uIHRoYXQgcmVtZW1iZXJzIHRoZSBsYXN0IHJldHVybi4gIElmIHRoZVxuICogcmV0dXJuZWQgZnVuY3Rpb24gaXMgY2FsbGVkIHR3aWNlIGluIGEgcm93IHdpdGggdGhlIHNhbWUgYXJndW1lbnRzIGFuZCB0aGUgc2FtZVxuICogdGhpcyBvYmplY3QsIGl0IHdpbGwgcmV0dXJuIHRoZSB2YWx1ZSBmcm9tIHRoZSBmaXJzdCBjYWxsIGluIHRoZSBzZWNvbmQgY2FsbC5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKC4uLmFueSk6IFJldHVyblR5cGV9IGZuIFRoZSBmdW5jdGlvbiB0byBtZW1vaXplLlxuICogQHJldHVybiB7ZnVuY3Rpb24oLi4uYW55KTogUmV0dXJuVHlwZX0gVGhlIG1lbW9pemVkIGZ1bmN0aW9uLlxuICogQHRlbXBsYXRlIFJldHVyblR5cGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1lbW9pemVPbmUoZm4pIHtcbiAgbGV0IGNhbGxlZCA9IGZhbHNlO1xuXG4gIC8qKiBAdHlwZSB7UmV0dXJuVHlwZX0gKi9cbiAgbGV0IGxhc3RSZXN1bHQ7XG5cbiAgLyoqIEB0eXBlIHtBcnJheTxhbnk+fSAqL1xuICBsZXQgbGFzdEFyZ3M7XG5cbiAgbGV0IGxhc3RUaGlzO1xuXG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgY29uc3QgbmV4dEFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgIGlmICghY2FsbGVkIHx8IHRoaXMgIT09IGxhc3RUaGlzIHx8ICFhcnJheUVxdWFscyhuZXh0QXJncywgbGFzdEFyZ3MpKSB7XG4gICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgbGFzdFRoaXMgPSB0aGlzO1xuICAgICAgbGFzdEFyZ3MgPSBuZXh0QXJncztcbiAgICAgIGxhc3RSZXN1bHQgPSBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICByZXR1cm4gbGFzdFJlc3VsdDtcbiAgfTtcbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtmdW5jdGlvbigpOiAoVCB8IFByb21pc2U8VD4pfSBnZXR0ZXIgQSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSB2YWx1ZSBvciBhIHByb21pc2UgZm9yIGEgdmFsdWUuXG4gKiBAcmV0dXJuIHtQcm9taXNlPFQ+fSBBIHByb21pc2UgZm9yIHRoZSB2YWx1ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvUHJvbWlzZShnZXR0ZXIpIHtcbiAgZnVuY3Rpb24gcHJvbWlzZUdldHRlcigpIHtcbiAgICBsZXQgdmFsdWU7XG4gICAgdHJ5IHtcbiAgICAgIHZhbHVlID0gZ2V0dGVyKCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyKTtcbiAgICB9XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZhbHVlKTtcbiAgfVxuICByZXR1cm4gcHJvbWlzZUdldHRlcigpO1xufVxuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2dlb20vQ2lyY2xlXG4gKi9cbmltcG9ydCBTaW1wbGVHZW9tZXRyeSBmcm9tICcuL1NpbXBsZUdlb21ldHJ5LmpzJztcbmltcG9ydCB7Y3JlYXRlT3JVcGRhdGUsIGZvckVhY2hDb3JuZXIsIGludGVyc2VjdHN9IGZyb20gJy4uL2V4dGVudC5qcyc7XG5pbXBvcnQge2RlZmxhdGVDb29yZGluYXRlfSBmcm9tICcuL2ZsYXQvZGVmbGF0ZS5qcyc7XG5pbXBvcnQge3JvdGF0ZX0gZnJvbSAnLi9mbGF0L3RyYW5zZm9ybS5qcyc7XG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQ2lyY2xlIGdlb21ldHJ5LlxuICpcbiAqIEBhcGlcbiAqL1xuY2xhc3MgQ2lyY2xlIGV4dGVuZHMgU2ltcGxlR2VvbWV0cnkge1xuICAvKipcbiAgICogQHBhcmFtIHshaW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBjZW50ZXIgQ2VudGVyLlxuICAgKiAgICAgRm9yIGludGVybmFsIHVzZSwgZmxhdCBjb29yZGluYXRlcyBpbiBjb21iaW5hdGlvbiB3aXRoIGBsYXlvdXRgIGFuZCBub1xuICAgKiAgICAgYHJhZGl1c2AgYXJlIGFsc28gYWNjZXB0ZWQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbcmFkaXVzXSBSYWRpdXMgaW4gdW5pdHMgb2YgdGhlIHByb2plY3Rpb24uXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9HZW9tZXRyeS5qc1wiKS5HZW9tZXRyeUxheW91dH0gW2xheW91dF0gTGF5b3V0LlxuICAgKi9cbiAgY29uc3RydWN0b3IoY2VudGVyLCByYWRpdXMsIGxheW91dCkge1xuICAgIHN1cGVyKCk7XG4gICAgaWYgKGxheW91dCAhPT0gdW5kZWZpbmVkICYmIHJhZGl1cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLnNldEZsYXRDb29yZGluYXRlcyhsYXlvdXQsIGNlbnRlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJhZGl1cyA9IHJhZGl1cyA/IHJhZGl1cyA6IDA7XG4gICAgICB0aGlzLnNldENlbnRlckFuZFJhZGl1cyhjZW50ZXIsIHJhZGl1cywgbGF5b3V0KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTWFrZSBhIGNvbXBsZXRlIGNvcHkgb2YgdGhlIGdlb21ldHJ5LlxuICAgKiBAcmV0dXJuIHshQ2lyY2xlfSBDbG9uZS5cbiAgICogQGFwaVxuICAgKi9cbiAgY2xvbmUoKSB7XG4gICAgY29uc3QgY2lyY2xlID0gbmV3IENpcmNsZShcbiAgICAgIHRoaXMuZmxhdENvb3JkaW5hdGVzLnNsaWNlKCksXG4gICAgICB1bmRlZmluZWQsXG4gICAgICB0aGlzLmxheW91dFxuICAgICk7XG4gICAgY2lyY2xlLmFwcGx5UHJvcGVydGllcyh0aGlzKTtcbiAgICByZXR1cm4gY2lyY2xlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4IFguXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5IFkuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBjbG9zZXN0UG9pbnQgQ2xvc2VzdCBwb2ludC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG1pblNxdWFyZWREaXN0YW5jZSBNaW5pbXVtIHNxdWFyZWQgZGlzdGFuY2UuXG4gICAqIEByZXR1cm4ge251bWJlcn0gTWluaW11bSBzcXVhcmVkIGRpc3RhbmNlLlxuICAgKi9cbiAgY2xvc2VzdFBvaW50WFkoeCwgeSwgY2xvc2VzdFBvaW50LCBtaW5TcXVhcmVkRGlzdGFuY2UpIHtcbiAgICBjb25zdCBmbGF0Q29vcmRpbmF0ZXMgPSB0aGlzLmZsYXRDb29yZGluYXRlcztcbiAgICBjb25zdCBkeCA9IHggLSBmbGF0Q29vcmRpbmF0ZXNbMF07XG4gICAgY29uc3QgZHkgPSB5IC0gZmxhdENvb3JkaW5hdGVzWzFdO1xuICAgIGNvbnN0IHNxdWFyZWREaXN0YW5jZSA9IGR4ICogZHggKyBkeSAqIGR5O1xuICAgIGlmIChzcXVhcmVkRGlzdGFuY2UgPCBtaW5TcXVhcmVkRGlzdGFuY2UpIHtcbiAgICAgIGlmIChzcXVhcmVkRGlzdGFuY2UgPT09IDApIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnN0cmlkZTsgKytpKSB7XG4gICAgICAgICAgY2xvc2VzdFBvaW50W2ldID0gZmxhdENvb3JkaW5hdGVzW2ldO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBkZWx0YSA9IHRoaXMuZ2V0UmFkaXVzKCkgLyBNYXRoLnNxcnQoc3F1YXJlZERpc3RhbmNlKTtcbiAgICAgICAgY2xvc2VzdFBvaW50WzBdID0gZmxhdENvb3JkaW5hdGVzWzBdICsgZGVsdGEgKiBkeDtcbiAgICAgICAgY2xvc2VzdFBvaW50WzFdID0gZmxhdENvb3JkaW5hdGVzWzFdICsgZGVsdGEgKiBkeTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDI7IGkgPCB0aGlzLnN0cmlkZTsgKytpKSB7XG4gICAgICAgICAgY2xvc2VzdFBvaW50W2ldID0gZmxhdENvb3JkaW5hdGVzW2ldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjbG9zZXN0UG9pbnQubGVuZ3RoID0gdGhpcy5zdHJpZGU7XG4gICAgICByZXR1cm4gc3F1YXJlZERpc3RhbmNlO1xuICAgIH1cbiAgICByZXR1cm4gbWluU3F1YXJlZERpc3RhbmNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4IFguXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5IFkuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IENvbnRhaW5zICh4LCB5KS5cbiAgICovXG4gIGNvbnRhaW5zWFkoeCwgeSkge1xuICAgIGNvbnN0IGZsYXRDb29yZGluYXRlcyA9IHRoaXMuZmxhdENvb3JkaW5hdGVzO1xuICAgIGNvbnN0IGR4ID0geCAtIGZsYXRDb29yZGluYXRlc1swXTtcbiAgICBjb25zdCBkeSA9IHkgLSBmbGF0Q29vcmRpbmF0ZXNbMV07XG4gICAgcmV0dXJuIGR4ICogZHggKyBkeSAqIGR5IDw9IHRoaXMuZ2V0UmFkaXVzU3F1YXJlZF8oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGNlbnRlciBvZiB0aGUgY2lyY2xlIGFzIHtAbGluayBtb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlIGNvb3JkaW5hdGV9LlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IENlbnRlci5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0Q2VudGVyKCkge1xuICAgIHJldHVybiB0aGlzLmZsYXRDb29yZGluYXRlcy5zbGljZSgwLCB0aGlzLnN0cmlkZSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gICAqL1xuICBjb21wdXRlRXh0ZW50KGV4dGVudCkge1xuICAgIGNvbnN0IGZsYXRDb29yZGluYXRlcyA9IHRoaXMuZmxhdENvb3JkaW5hdGVzO1xuICAgIGNvbnN0IHJhZGl1cyA9IGZsYXRDb29yZGluYXRlc1t0aGlzLnN0cmlkZV0gLSBmbGF0Q29vcmRpbmF0ZXNbMF07XG4gICAgcmV0dXJuIGNyZWF0ZU9yVXBkYXRlKFxuICAgICAgZmxhdENvb3JkaW5hdGVzWzBdIC0gcmFkaXVzLFxuICAgICAgZmxhdENvb3JkaW5hdGVzWzFdIC0gcmFkaXVzLFxuICAgICAgZmxhdENvb3JkaW5hdGVzWzBdICsgcmFkaXVzLFxuICAgICAgZmxhdENvb3JkaW5hdGVzWzFdICsgcmFkaXVzLFxuICAgICAgZXh0ZW50XG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIHJhZGl1cyBvZiB0aGUgY2lyY2xlLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IFJhZGl1cy5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0UmFkaXVzKCkge1xuICAgIHJldHVybiBNYXRoLnNxcnQodGhpcy5nZXRSYWRpdXNTcXVhcmVkXygpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IFJhZGl1cyBzcXVhcmVkLlxuICAgKi9cbiAgZ2V0UmFkaXVzU3F1YXJlZF8oKSB7XG4gICAgY29uc3QgZHggPSB0aGlzLmZsYXRDb29yZGluYXRlc1t0aGlzLnN0cmlkZV0gLSB0aGlzLmZsYXRDb29yZGluYXRlc1swXTtcbiAgICBjb25zdCBkeSA9IHRoaXMuZmxhdENvb3JkaW5hdGVzW3RoaXMuc3RyaWRlICsgMV0gLSB0aGlzLmZsYXRDb29yZGluYXRlc1sxXTtcbiAgICByZXR1cm4gZHggKiBkeCArIGR5ICogZHk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB0eXBlIG9mIHRoaXMgZ2VvbWV0cnkuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4vR2VvbWV0cnkuanNcIikuVHlwZX0gR2VvbWV0cnkgdHlwZS5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0VHlwZSgpIHtcbiAgICByZXR1cm4gJ0NpcmNsZSc7XG4gIH1cblxuICAvKipcbiAgICogVGVzdCBpZiB0aGUgZ2VvbWV0cnkgYW5kIHRoZSBwYXNzZWQgZXh0ZW50IGludGVyc2VjdC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBgdHJ1ZWAgaWYgdGhlIGdlb21ldHJ5IGFuZCB0aGUgZXh0ZW50IGludGVyc2VjdC5cbiAgICogQGFwaVxuICAgKi9cbiAgaW50ZXJzZWN0c0V4dGVudChleHRlbnQpIHtcbiAgICBjb25zdCBjaXJjbGVFeHRlbnQgPSB0aGlzLmdldEV4dGVudCgpO1xuICAgIGlmIChpbnRlcnNlY3RzKGV4dGVudCwgY2lyY2xlRXh0ZW50KSkge1xuICAgICAgY29uc3QgY2VudGVyID0gdGhpcy5nZXRDZW50ZXIoKTtcblxuICAgICAgaWYgKGV4dGVudFswXSA8PSBjZW50ZXJbMF0gJiYgZXh0ZW50WzJdID49IGNlbnRlclswXSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChleHRlbnRbMV0gPD0gY2VudGVyWzFdICYmIGV4dGVudFszXSA+PSBjZW50ZXJbMV0pIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmb3JFYWNoQ29ybmVyKGV4dGVudCwgdGhpcy5pbnRlcnNlY3RzQ29vcmRpbmF0ZS5iaW5kKHRoaXMpKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgY2VudGVyIG9mIHRoZSBjaXJjbGUgYXMge0BsaW5rIG1vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGUgY29vcmRpbmF0ZX0uXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBjZW50ZXIgQ2VudGVyLlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRDZW50ZXIoY2VudGVyKSB7XG4gICAgY29uc3Qgc3RyaWRlID0gdGhpcy5zdHJpZGU7XG4gICAgY29uc3QgcmFkaXVzID0gdGhpcy5mbGF0Q29vcmRpbmF0ZXNbc3RyaWRlXSAtIHRoaXMuZmxhdENvb3JkaW5hdGVzWzBdO1xuICAgIGNvbnN0IGZsYXRDb29yZGluYXRlcyA9IGNlbnRlci5zbGljZSgpO1xuICAgIGZsYXRDb29yZGluYXRlc1tzdHJpZGVdID0gZmxhdENvb3JkaW5hdGVzWzBdICsgcmFkaXVzO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgc3RyaWRlOyArK2kpIHtcbiAgICAgIGZsYXRDb29yZGluYXRlc1tzdHJpZGUgKyBpXSA9IGNlbnRlcltpXTtcbiAgICB9XG4gICAgdGhpcy5zZXRGbGF0Q29vcmRpbmF0ZXModGhpcy5sYXlvdXQsIGZsYXRDb29yZGluYXRlcyk7XG4gICAgdGhpcy5jaGFuZ2VkKCk7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBjZW50ZXIgKGFzIHtAbGluayBtb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlIGNvb3JkaW5hdGV9KSBhbmQgdGhlIHJhZGl1cyAoYXNcbiAgICogbnVtYmVyKSBvZiB0aGUgY2lyY2xlLlxuICAgKiBAcGFyYW0geyFpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGNlbnRlciBDZW50ZXIuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSByYWRpdXMgUmFkaXVzLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vR2VvbWV0cnkuanNcIikuR2VvbWV0cnlMYXlvdXR9IFtsYXlvdXRdIExheW91dC5cbiAgICogQGFwaVxuICAgKi9cbiAgc2V0Q2VudGVyQW5kUmFkaXVzKGNlbnRlciwgcmFkaXVzLCBsYXlvdXQpIHtcbiAgICB0aGlzLnNldExheW91dChsYXlvdXQsIGNlbnRlciwgMCk7XG4gICAgaWYgKCF0aGlzLmZsYXRDb29yZGluYXRlcykge1xuICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMgPSBbXTtcbiAgICB9XG4gICAgLyoqIEB0eXBlIHtBcnJheTxudW1iZXI+fSAqL1xuICAgIGNvbnN0IGZsYXRDb29yZGluYXRlcyA9IHRoaXMuZmxhdENvb3JkaW5hdGVzO1xuICAgIGxldCBvZmZzZXQgPSBkZWZsYXRlQ29vcmRpbmF0ZShmbGF0Q29vcmRpbmF0ZXMsIDAsIGNlbnRlciwgdGhpcy5zdHJpZGUpO1xuICAgIGZsYXRDb29yZGluYXRlc1tvZmZzZXQrK10gPSBmbGF0Q29vcmRpbmF0ZXNbMF0gKyByYWRpdXM7XG4gICAgZm9yIChsZXQgaSA9IDEsIGlpID0gdGhpcy5zdHJpZGU7IGkgPCBpaTsgKytpKSB7XG4gICAgICBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0KytdID0gZmxhdENvb3JkaW5hdGVzW2ldO1xuICAgIH1cbiAgICBmbGF0Q29vcmRpbmF0ZXMubGVuZ3RoID0gb2Zmc2V0O1xuICAgIHRoaXMuY2hhbmdlZCgpO1xuICB9XG5cbiAgZ2V0Q29vcmRpbmF0ZXMoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBzZXRDb29yZGluYXRlcyhjb29yZGluYXRlcywgbGF5b3V0KSB7fVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHJhZGl1cyBvZiB0aGUgY2lyY2xlLiBUaGUgcmFkaXVzIGlzIGluIHRoZSB1bml0cyBvZiB0aGUgcHJvamVjdGlvbi5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHJhZGl1cyBSYWRpdXMuXG4gICAqIEBhcGlcbiAgICovXG4gIHNldFJhZGl1cyhyYWRpdXMpIHtcbiAgICB0aGlzLmZsYXRDb29yZGluYXRlc1t0aGlzLnN0cmlkZV0gPSB0aGlzLmZsYXRDb29yZGluYXRlc1swXSArIHJhZGl1cztcbiAgICB0aGlzLmNoYW5nZWQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSb3RhdGUgdGhlIGdlb21ldHJ5IGFyb3VuZCBhIGdpdmVuIGNvb3JkaW5hdGUuIFRoaXMgbW9kaWZpZXMgdGhlIGdlb21ldHJ5XG4gICAqIGNvb3JkaW5hdGVzIGluIHBsYWNlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gYW5nbGUgUm90YXRpb24gYW5nbGUgaW4gY291bnRlci1jbG9ja3dpc2UgcmFkaWFucy5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGFuY2hvciBUaGUgcm90YXRpb24gY2VudGVyLlxuICAgKiBAYXBpXG4gICAqL1xuICByb3RhdGUoYW5nbGUsIGFuY2hvcikge1xuICAgIGNvbnN0IGNlbnRlciA9IHRoaXMuZ2V0Q2VudGVyKCk7XG4gICAgY29uc3Qgc3RyaWRlID0gdGhpcy5nZXRTdHJpZGUoKTtcbiAgICB0aGlzLnNldENlbnRlcihcbiAgICAgIHJvdGF0ZShjZW50ZXIsIDAsIGNlbnRlci5sZW5ndGgsIHN0cmlkZSwgYW5nbGUsIGFuY2hvciwgY2VudGVyKVxuICAgICk7XG4gICAgdGhpcy5jaGFuZ2VkKCk7XG4gIH1cbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm0gZWFjaCBjb29yZGluYXRlIG9mIHRoZSBjaXJjbGUgZnJvbSBvbmUgY29vcmRpbmF0ZSByZWZlcmVuY2Ugc3lzdGVtXG4gKiB0byBhbm90aGVyLiBUaGUgZ2VvbWV0cnkgaXMgbW9kaWZpZWQgaW4gcGxhY2UuXG4gKiBJZiB5b3UgZG8gbm90IHdhbnQgdGhlIGdlb21ldHJ5IG1vZGlmaWVkIGluIHBsYWNlLCBmaXJzdCBjbG9uZSgpIGl0IGFuZFxuICogdGhlbiB1c2UgdGhpcyBmdW5jdGlvbiBvbiB0aGUgY2xvbmUuXG4gKlxuICogSW50ZXJuYWxseSBhIGNpcmNsZSBpcyBjdXJyZW50bHkgcmVwcmVzZW50ZWQgYnkgdHdvIHBvaW50czogdGhlIGNlbnRlciBvZlxuICogdGhlIGNpcmNsZSBgW2N4LCBjeV1gLCBhbmQgdGhlIHBvaW50IHRvIHRoZSByaWdodCBvZiB0aGUgY2lyY2xlXG4gKiBgW2N4ICsgciwgY3ldYC4gVGhpcyBgdHJhbnNmb3JtYCBmdW5jdGlvbiBqdXN0IHRyYW5zZm9ybXMgdGhlc2UgdHdvIHBvaW50cy5cbiAqIFNvIHRoZSByZXN1bHRpbmcgZ2VvbWV0cnkgaXMgYWxzbyBhIGNpcmNsZSwgYW5kIHRoYXQgY2lyY2xlIGRvZXMgbm90XG4gKiBjb3JyZXNwb25kIHRvIHRoZSBzaGFwZSB0aGF0IHdvdWxkIGJlIG9idGFpbmVkIGJ5IHRyYW5zZm9ybWluZyBldmVyeSBwb2ludFxuICogb2YgdGhlIG9yaWdpbmFsIGNpcmNsZS5cbiAqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL3Byb2ouanNcIikuUHJvamVjdGlvbkxpa2V9IHNvdXJjZSBUaGUgY3VycmVudCBwcm9qZWN0aW9uLiAgQ2FuIGJlIGFcbiAqICAgICBzdHJpbmcgaWRlbnRpZmllciBvciBhIHtAbGluayBtb2R1bGU6b2wvcHJvai9Qcm9qZWN0aW9uflByb2plY3Rpb259IG9iamVjdC5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcHJvai5qc1wiKS5Qcm9qZWN0aW9uTGlrZX0gZGVzdGluYXRpb24gVGhlIGRlc2lyZWQgcHJvamVjdGlvbi4gIENhbiBiZSBhXG4gKiAgICAgc3RyaW5nIGlkZW50aWZpZXIgb3IgYSB7QGxpbmsgbW9kdWxlOm9sL3Byb2ovUHJvamVjdGlvbn5Qcm9qZWN0aW9ufSBvYmplY3QuXG4gKiBAcmV0dXJuIHtDaXJjbGV9IFRoaXMgZ2VvbWV0cnkuICBOb3RlIHRoYXQgb3JpZ2luYWwgZ2VvbWV0cnkgaXNcbiAqICAgICBtb2RpZmllZCBpbiBwbGFjZS5cbiAqIEBmdW5jdGlvblxuICogQGFwaVxuICovXG5DaXJjbGUucHJvdG90eXBlLnRyYW5zZm9ybTtcbmV4cG9ydCBkZWZhdWx0IENpcmNsZTtcbiIsIi8qKlxuICogQG1vZHVsZSBvbC9nZW9tL0dlb21ldHJ5XG4gKi9cbmltcG9ydCBCYXNlT2JqZWN0IGZyb20gJy4uL09iamVjdC5qcyc7XG5pbXBvcnQge2Fic3RyYWN0fSBmcm9tICcuLi91dGlsLmpzJztcbmltcG9ydCB7XG4gIGNvbXBvc2UgYXMgY29tcG9zZVRyYW5zZm9ybSxcbiAgY3JlYXRlIGFzIGNyZWF0ZVRyYW5zZm9ybSxcbn0gZnJvbSAnLi4vdHJhbnNmb3JtLmpzJztcbmltcG9ydCB7XG4gIGNyZWF0ZUVtcHR5LFxuICBjcmVhdGVPclVwZGF0ZUVtcHR5LFxuICBnZXRIZWlnaHQsXG4gIHJldHVybk9yVXBkYXRlLFxufSBmcm9tICcuLi9leHRlbnQuanMnO1xuaW1wb3J0IHtnZXQgYXMgZ2V0UHJvamVjdGlvbiwgZ2V0VHJhbnNmb3JtfSBmcm9tICcuLi9wcm9qLmpzJztcbmltcG9ydCB7bWVtb2l6ZU9uZX0gZnJvbSAnLi4vZnVuY3Rpb25zLmpzJztcbmltcG9ydCB7dHJhbnNmb3JtMkR9IGZyb20gJy4vZmxhdC90cmFuc2Zvcm0uanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHsnWFknIHwgJ1hZWicgfCAnWFlNJyB8ICdYWVpNJ30gR2VvbWV0cnlMYXlvdXRcbiAqIFRoZSBjb29yZGluYXRlIGxheW91dCBmb3IgZ2VvbWV0cmllcywgaW5kaWNhdGluZyB3aGV0aGVyIGEgM3JkIG9yIDR0aCB6ICgnWicpXG4gKiBvciBtZWFzdXJlICgnTScpIGNvb3JkaW5hdGUgaXMgYXZhaWxhYmxlLlxuICovXG5cbi8qKlxuICogQHR5cGVkZWYgeydQb2ludCcgfCAnTGluZVN0cmluZycgfCAnTGluZWFyUmluZycgfCAnUG9seWdvbicgfCAnTXVsdGlQb2ludCcgfCAnTXVsdGlMaW5lU3RyaW5nJyB8ICdNdWx0aVBvbHlnb24nIHwgJ0dlb21ldHJ5Q29sbGVjdGlvbicgfCAnQ2lyY2xlJ30gVHlwZVxuICogVGhlIGdlb21ldHJ5IHR5cGUuICBPbmUgb2YgYCdQb2ludCdgLCBgJ0xpbmVTdHJpbmcnYCwgYCdMaW5lYXJSaW5nJ2AsXG4gKiBgJ1BvbHlnb24nYCwgYCdNdWx0aVBvaW50J2AsIGAnTXVsdGlMaW5lU3RyaW5nJ2AsIGAnTXVsdGlQb2x5Z29uJ2AsXG4gKiBgJ0dlb21ldHJ5Q29sbGVjdGlvbidgLCBvciBgJ0NpcmNsZSdgLlxuICovXG5cbi8qKlxuICogQHR5cGUge2ltcG9ydChcIi4uL3RyYW5zZm9ybS5qc1wiKS5UcmFuc2Zvcm19XG4gKi9cbmNvbnN0IHRtcFRyYW5zZm9ybSA9IGNyZWF0ZVRyYW5zZm9ybSgpO1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEFic3RyYWN0IGJhc2UgY2xhc3M7IG5vcm1hbGx5IG9ubHkgdXNlZCBmb3IgY3JlYXRpbmcgc3ViY2xhc3NlcyBhbmQgbm90XG4gKiBpbnN0YW50aWF0ZWQgaW4gYXBwcy5cbiAqIEJhc2UgY2xhc3MgZm9yIHZlY3RvciBnZW9tZXRyaWVzLlxuICpcbiAqIFRvIGdldCBub3RpZmllZCBvZiBjaGFuZ2VzIHRvIHRoZSBnZW9tZXRyeSwgcmVnaXN0ZXIgYSBsaXN0ZW5lciBmb3IgdGhlXG4gKiBnZW5lcmljIGBjaGFuZ2VgIGV2ZW50IG9uIHlvdXIgZ2VvbWV0cnkgaW5zdGFuY2UuXG4gKlxuICogQGFic3RyYWN0XG4gKiBAYXBpXG4gKi9cbmNsYXNzIEdlb21ldHJ5IGV4dGVuZHMgQmFzZU9iamVjdCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fVxuICAgICAqL1xuICAgIHRoaXMuZXh0ZW50XyA9IGNyZWF0ZUVtcHR5KCk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5leHRlbnRSZXZpc2lvbl8gPSAtMTtcblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuc2ltcGxpZmllZEdlb21ldHJ5TWF4TWluU3F1YXJlZFRvbGVyYW5jZSA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnNpbXBsaWZpZWRHZW9tZXRyeVJldmlzaW9uID0gMDtcblxuICAgIC8qKlxuICAgICAqIEdldCBhIHRyYW5zZm9ybWVkIGFuZCBzaW1wbGlmaWVkIHZlcnNpb24gb2YgdGhlIGdlb21ldHJ5LlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByZXZpc2lvbiBUaGUgZ2VvbWV0cnkgcmV2aXNpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNxdWFyZWRUb2xlcmFuY2UgU3F1YXJlZCB0b2xlcmFuY2UuXG4gICAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9wcm9qLmpzXCIpLlRyYW5zZm9ybUZ1bmN0aW9ufSBbdHJhbnNmb3JtXSBPcHRpb25hbCB0cmFuc2Zvcm0gZnVuY3Rpb24uXG4gICAgICogQHJldHVybiB7R2VvbWV0cnl9IFNpbXBsaWZpZWQgZ2VvbWV0cnkuXG4gICAgICovXG4gICAgdGhpcy5zaW1wbGlmeVRyYW5zZm9ybWVkSW50ZXJuYWwgPSBtZW1vaXplT25lKGZ1bmN0aW9uIChcbiAgICAgIHJldmlzaW9uLFxuICAgICAgc3F1YXJlZFRvbGVyYW5jZSxcbiAgICAgIHRyYW5zZm9ybVxuICAgICkge1xuICAgICAgaWYgKCF0cmFuc2Zvcm0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U2ltcGxpZmllZEdlb21ldHJ5KHNxdWFyZWRUb2xlcmFuY2UpO1xuICAgICAgfVxuICAgICAgY29uc3QgY2xvbmUgPSB0aGlzLmNsb25lKCk7XG4gICAgICBjbG9uZS5hcHBseVRyYW5zZm9ybSh0cmFuc2Zvcm0pO1xuICAgICAgcmV0dXJuIGNsb25lLmdldFNpbXBsaWZpZWRHZW9tZXRyeShzcXVhcmVkVG9sZXJhbmNlKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYSB0cmFuc2Zvcm1lZCBhbmQgc2ltcGxpZmllZCB2ZXJzaW9uIG9mIHRoZSBnZW9tZXRyeS5cbiAgICogQGFic3RyYWN0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzcXVhcmVkVG9sZXJhbmNlIFNxdWFyZWQgdG9sZXJhbmNlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3Byb2ouanNcIikuVHJhbnNmb3JtRnVuY3Rpb259IFt0cmFuc2Zvcm1dIE9wdGlvbmFsIHRyYW5zZm9ybSBmdW5jdGlvbi5cbiAgICogQHJldHVybiB7R2VvbWV0cnl9IFNpbXBsaWZpZWQgZ2VvbWV0cnkuXG4gICAqL1xuICBzaW1wbGlmeVRyYW5zZm9ybWVkKHNxdWFyZWRUb2xlcmFuY2UsIHRyYW5zZm9ybSkge1xuICAgIHJldHVybiB0aGlzLnNpbXBsaWZ5VHJhbnNmb3JtZWRJbnRlcm5hbChcbiAgICAgIHRoaXMuZ2V0UmV2aXNpb24oKSxcbiAgICAgIHNxdWFyZWRUb2xlcmFuY2UsXG4gICAgICB0cmFuc2Zvcm1cbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ha2UgYSBjb21wbGV0ZSBjb3B5IG9mIHRoZSBnZW9tZXRyeS5cbiAgICogQGFic3RyYWN0XG4gICAqIEByZXR1cm4geyFHZW9tZXRyeX0gQ2xvbmUuXG4gICAqL1xuICBjbG9uZSgpIHtcbiAgICByZXR1cm4gYWJzdHJhY3QoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHBhcmFtIHtudW1iZXJ9IHggWC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHkgWS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGNsb3Nlc3RQb2ludCBDbG9zZXN0IHBvaW50LlxuICAgKiBAcGFyYW0ge251bWJlcn0gbWluU3F1YXJlZERpc3RhbmNlIE1pbmltdW0gc3F1YXJlZCBkaXN0YW5jZS5cbiAgICogQHJldHVybiB7bnVtYmVyfSBNaW5pbXVtIHNxdWFyZWQgZGlzdGFuY2UuXG4gICAqL1xuICBjbG9zZXN0UG9pbnRYWSh4LCB5LCBjbG9zZXN0UG9pbnQsIG1pblNxdWFyZWREaXN0YW5jZSkge1xuICAgIHJldHVybiBhYnN0cmFjdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4IFguXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5IFkuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IENvbnRhaW5zICh4LCB5KS5cbiAgICovXG4gIGNvbnRhaW5zWFkoeCwgeSkge1xuICAgIGNvbnN0IGNvb3JkID0gdGhpcy5nZXRDbG9zZXN0UG9pbnQoW3gsIHldKTtcbiAgICByZXR1cm4gY29vcmRbMF0gPT09IHggJiYgY29vcmRbMV0gPT09IHk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBjbG9zZXN0IHBvaW50IG9mIHRoZSBnZW9tZXRyeSB0byB0aGUgcGFzc2VkIHBvaW50IGFzXG4gICAqIHtAbGluayBtb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlIGNvb3JkaW5hdGV9LlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gcG9pbnQgUG9pbnQuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBbY2xvc2VzdFBvaW50XSBDbG9zZXN0IHBvaW50LlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IENsb3Nlc3QgcG9pbnQuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldENsb3Nlc3RQb2ludChwb2ludCwgY2xvc2VzdFBvaW50KSB7XG4gICAgY2xvc2VzdFBvaW50ID0gY2xvc2VzdFBvaW50ID8gY2xvc2VzdFBvaW50IDogW05hTiwgTmFOXTtcbiAgICB0aGlzLmNsb3Nlc3RQb2ludFhZKHBvaW50WzBdLCBwb2ludFsxXSwgY2xvc2VzdFBvaW50LCBJbmZpbml0eSk7XG4gICAgcmV0dXJuIGNsb3Nlc3RQb2ludDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBnZW9tZXRyeSBpbmNsdWRlcyB0aGUgc3BlY2lmaWVkIGNvb3JkaW5hdGUuIElmIHRoZVxuICAgKiBjb29yZGluYXRlIGlzIG9uIHRoZSBib3VuZGFyeSBvZiB0aGUgZ2VvbWV0cnksIHJldHVybnMgZmFsc2UuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBjb29yZGluYXRlIENvb3JkaW5hdGUuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IENvbnRhaW5zIGNvb3JkaW5hdGUuXG4gICAqIEBhcGlcbiAgICovXG4gIGludGVyc2VjdHNDb29yZGluYXRlKGNvb3JkaW5hdGUpIHtcbiAgICByZXR1cm4gdGhpcy5jb250YWluc1hZKGNvb3JkaW5hdGVbMF0sIGNvb3JkaW5hdGVbMV0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAgICovXG4gIGNvbXB1dGVFeHRlbnQoZXh0ZW50KSB7XG4gICAgcmV0dXJuIGFic3RyYWN0KCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBleHRlbnQgb2YgdGhlIGdlb21ldHJ5LlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IFtleHRlbnRdIEV4dGVudC5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0RXh0ZW50KGV4dGVudCkge1xuICAgIGlmICh0aGlzLmV4dGVudFJldmlzaW9uXyAhPSB0aGlzLmdldFJldmlzaW9uKCkpIHtcbiAgICAgIGNvbnN0IGV4dGVudCA9IHRoaXMuY29tcHV0ZUV4dGVudCh0aGlzLmV4dGVudF8pO1xuICAgICAgaWYgKGlzTmFOKGV4dGVudFswXSkgfHwgaXNOYU4oZXh0ZW50WzFdKSkge1xuICAgICAgICBjcmVhdGVPclVwZGF0ZUVtcHR5KGV4dGVudCk7XG4gICAgICB9XG4gICAgICB0aGlzLmV4dGVudFJldmlzaW9uXyA9IHRoaXMuZ2V0UmV2aXNpb24oKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldHVybk9yVXBkYXRlKHRoaXMuZXh0ZW50XywgZXh0ZW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSb3RhdGUgdGhlIGdlb21ldHJ5IGFyb3VuZCBhIGdpdmVuIGNvb3JkaW5hdGUuIFRoaXMgbW9kaWZpZXMgdGhlIGdlb21ldHJ5XG4gICAqIGNvb3JkaW5hdGVzIGluIHBsYWNlLlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHBhcmFtIHtudW1iZXJ9IGFuZ2xlIFJvdGF0aW9uIGFuZ2xlIGluIHJhZGlhbnMuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBhbmNob3IgVGhlIHJvdGF0aW9uIGNlbnRlci5cbiAgICogQGFwaVxuICAgKi9cbiAgcm90YXRlKGFuZ2xlLCBhbmNob3IpIHtcbiAgICBhYnN0cmFjdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNjYWxlIHRoZSBnZW9tZXRyeSAod2l0aCBhbiBvcHRpb25hbCBvcmlnaW4pLiAgVGhpcyBtb2RpZmllcyB0aGUgZ2VvbWV0cnlcbiAgICogY29vcmRpbmF0ZXMgaW4gcGxhY2UuXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcGFyYW0ge251bWJlcn0gc3ggVGhlIHNjYWxpbmcgZmFjdG9yIGluIHRoZSB4LWRpcmVjdGlvbi5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtzeV0gVGhlIHNjYWxpbmcgZmFjdG9yIGluIHRoZSB5LWRpcmVjdGlvbiAoZGVmYXVsdHMgdG8gc3gpLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gW2FuY2hvcl0gVGhlIHNjYWxlIG9yaWdpbiAoZGVmYXVsdHMgdG8gdGhlIGNlbnRlclxuICAgKiAgICAgb2YgdGhlIGdlb21ldHJ5IGV4dGVudCkuXG4gICAqIEBhcGlcbiAgICovXG4gIHNjYWxlKHN4LCBzeSwgYW5jaG9yKSB7XG4gICAgYWJzdHJhY3QoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBzaW1wbGlmaWVkIHZlcnNpb24gb2YgdGhpcyBnZW9tZXRyeS4gIEZvciBsaW5lc3RyaW5ncywgdGhpcyB1c2VzXG4gICAqIHRoZSBbRG91Z2xhcyBQZXVja2VyXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9SYW1lci1Eb3VnbGFzLVBldWNrZXJfYWxnb3JpdGhtKVxuICAgKiBhbGdvcml0aG0uICBGb3IgcG9seWdvbnMsIGEgcXVhbnRpemF0aW9uLWJhc2VkXG4gICAqIHNpbXBsaWZpY2F0aW9uIGlzIHVzZWQgdG8gcHJlc2VydmUgdG9wb2xvZ3kuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0b2xlcmFuY2UgVGhlIHRvbGVyYW5jZSBkaXN0YW5jZSBmb3Igc2ltcGxpZmljYXRpb24uXG4gICAqIEByZXR1cm4ge0dlb21ldHJ5fSBBIG5ldywgc2ltcGxpZmllZCB2ZXJzaW9uIG9mIHRoZSBvcmlnaW5hbCBnZW9tZXRyeS5cbiAgICogQGFwaVxuICAgKi9cbiAgc2ltcGxpZnkodG9sZXJhbmNlKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0U2ltcGxpZmllZEdlb21ldHJ5KHRvbGVyYW5jZSAqIHRvbGVyYW5jZSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgc2ltcGxpZmllZCB2ZXJzaW9uIG9mIHRoaXMgZ2VvbWV0cnkgdXNpbmcgdGhlIERvdWdsYXMgUGV1Y2tlclxuICAgKiBhbGdvcml0aG0uXG4gICAqIFNlZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9SYW1lci1Eb3VnbGFzLVBldWNrZXJfYWxnb3JpdGhtLlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNxdWFyZWRUb2xlcmFuY2UgU3F1YXJlZCB0b2xlcmFuY2UuXG4gICAqIEByZXR1cm4ge0dlb21ldHJ5fSBTaW1wbGlmaWVkIGdlb21ldHJ5LlxuICAgKi9cbiAgZ2V0U2ltcGxpZmllZEdlb21ldHJ5KHNxdWFyZWRUb2xlcmFuY2UpIHtcbiAgICByZXR1cm4gYWJzdHJhY3QoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHR5cGUgb2YgdGhpcyBnZW9tZXRyeS5cbiAgICogQGFic3RyYWN0XG4gICAqIEByZXR1cm4ge1R5cGV9IEdlb21ldHJ5IHR5cGUuXG4gICAqL1xuICBnZXRUeXBlKCkge1xuICAgIHJldHVybiBhYnN0cmFjdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFwcGx5IGEgdHJhbnNmb3JtIGZ1bmN0aW9uIHRvIHRoZSBjb29yZGluYXRlcyBvZiB0aGUgZ2VvbWV0cnkuXG4gICAqIFRoZSBnZW9tZXRyeSBpcyBtb2RpZmllZCBpbiBwbGFjZS5cbiAgICogSWYgeW91IGRvIG5vdCB3YW50IHRoZSBnZW9tZXRyeSBtb2RpZmllZCBpbiBwbGFjZSwgZmlyc3QgYGNsb25lKClgIGl0IGFuZFxuICAgKiB0aGVuIHVzZSB0aGlzIGZ1bmN0aW9uIG9uIHRoZSBjbG9uZS5cbiAgICogQGFic3RyYWN0XG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcHJvai5qc1wiKS5UcmFuc2Zvcm1GdW5jdGlvbn0gdHJhbnNmb3JtRm4gVHJhbnNmb3JtIGZ1bmN0aW9uLlxuICAgKiBDYWxsZWQgd2l0aCBhIGZsYXQgYXJyYXkgb2YgZ2VvbWV0cnkgY29vcmRpbmF0ZXMuXG4gICAqL1xuICBhcHBseVRyYW5zZm9ybSh0cmFuc2Zvcm1Gbikge1xuICAgIGFic3RyYWN0KCk7XG4gIH1cblxuICAvKipcbiAgICogVGVzdCBpZiB0aGUgZ2VvbWV0cnkgYW5kIHRoZSBwYXNzZWQgZXh0ZW50IGludGVyc2VjdC5cbiAgICogQGFic3RyYWN0XG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSBnZW9tZXRyeSBhbmQgdGhlIGV4dGVudCBpbnRlcnNlY3QuXG4gICAqL1xuICBpbnRlcnNlY3RzRXh0ZW50KGV4dGVudCkge1xuICAgIHJldHVybiBhYnN0cmFjdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRyYW5zbGF0ZSB0aGUgZ2VvbWV0cnkuICBUaGlzIG1vZGlmaWVzIHRoZSBnZW9tZXRyeSBjb29yZGluYXRlcyBpbiBwbGFjZS4gIElmXG4gICAqIGluc3RlYWQgeW91IHdhbnQgYSBuZXcgZ2VvbWV0cnksIGZpcnN0IGBjbG9uZSgpYCB0aGlzIGdlb21ldHJ5LlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHBhcmFtIHtudW1iZXJ9IGRlbHRhWCBEZWx0YSBYLlxuICAgKiBAcGFyYW0ge251bWJlcn0gZGVsdGFZIERlbHRhIFkuXG4gICAqIEBhcGlcbiAgICovXG4gIHRyYW5zbGF0ZShkZWx0YVgsIGRlbHRhWSkge1xuICAgIGFic3RyYWN0KCk7XG4gIH1cblxuICAvKipcbiAgICogVHJhbnNmb3JtIGVhY2ggY29vcmRpbmF0ZSBvZiB0aGUgZ2VvbWV0cnkgZnJvbSBvbmUgY29vcmRpbmF0ZSByZWZlcmVuY2VcbiAgICogc3lzdGVtIHRvIGFub3RoZXIuIFRoZSBnZW9tZXRyeSBpcyBtb2RpZmllZCBpbiBwbGFjZS5cbiAgICogRm9yIGV4YW1wbGUsIGEgbGluZSB3aWxsIGJlIHRyYW5zZm9ybWVkIHRvIGEgbGluZSBhbmQgYSBjaXJjbGUgdG8gYSBjaXJjbGUuXG4gICAqIElmIHlvdSBkbyBub3Qgd2FudCB0aGUgZ2VvbWV0cnkgbW9kaWZpZWQgaW4gcGxhY2UsIGZpcnN0IGBjbG9uZSgpYCBpdCBhbmRcbiAgICogdGhlbiB1c2UgdGhpcyBmdW5jdGlvbiBvbiB0aGUgY2xvbmUuXG4gICAqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcHJvai5qc1wiKS5Qcm9qZWN0aW9uTGlrZX0gc291cmNlIFRoZSBjdXJyZW50IHByb2plY3Rpb24uICBDYW4gYmUgYVxuICAgKiAgICAgc3RyaW5nIGlkZW50aWZpZXIgb3IgYSB7QGxpbmsgbW9kdWxlOm9sL3Byb2ovUHJvamVjdGlvbn5Qcm9qZWN0aW9ufSBvYmplY3QuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcHJvai5qc1wiKS5Qcm9qZWN0aW9uTGlrZX0gZGVzdGluYXRpb24gVGhlIGRlc2lyZWQgcHJvamVjdGlvbi4gIENhbiBiZSBhXG4gICAqICAgICBzdHJpbmcgaWRlbnRpZmllciBvciBhIHtAbGluayBtb2R1bGU6b2wvcHJvai9Qcm9qZWN0aW9uflByb2plY3Rpb259IG9iamVjdC5cbiAgICogQHJldHVybiB7R2VvbWV0cnl9IFRoaXMgZ2VvbWV0cnkuICBOb3RlIHRoYXQgb3JpZ2luYWwgZ2VvbWV0cnkgaXNcbiAgICogICAgIG1vZGlmaWVkIGluIHBsYWNlLlxuICAgKiBAYXBpXG4gICAqL1xuICB0cmFuc2Zvcm0oc291cmNlLCBkZXN0aW5hdGlvbikge1xuICAgIC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vcHJvai9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR9ICovXG4gICAgY29uc3Qgc291cmNlUHJvaiA9IGdldFByb2plY3Rpb24oc291cmNlKTtcbiAgICBjb25zdCB0cmFuc2Zvcm1GbiA9XG4gICAgICBzb3VyY2VQcm9qLmdldFVuaXRzKCkgPT0gJ3RpbGUtcGl4ZWxzJ1xuICAgICAgICA/IGZ1bmN0aW9uIChpbkNvb3JkaW5hdGVzLCBvdXRDb29yZGluYXRlcywgc3RyaWRlKSB7XG4gICAgICAgICAgICBjb25zdCBwaXhlbEV4dGVudCA9IHNvdXJjZVByb2ouZ2V0RXh0ZW50KCk7XG4gICAgICAgICAgICBjb25zdCBwcm9qZWN0ZWRFeHRlbnQgPSBzb3VyY2VQcm9qLmdldFdvcmxkRXh0ZW50KCk7XG4gICAgICAgICAgICBjb25zdCBzY2FsZSA9IGdldEhlaWdodChwcm9qZWN0ZWRFeHRlbnQpIC8gZ2V0SGVpZ2h0KHBpeGVsRXh0ZW50KTtcbiAgICAgICAgICAgIGNvbXBvc2VUcmFuc2Zvcm0oXG4gICAgICAgICAgICAgIHRtcFRyYW5zZm9ybSxcbiAgICAgICAgICAgICAgcHJvamVjdGVkRXh0ZW50WzBdLFxuICAgICAgICAgICAgICBwcm9qZWN0ZWRFeHRlbnRbM10sXG4gICAgICAgICAgICAgIHNjYWxlLFxuICAgICAgICAgICAgICAtc2NhbGUsXG4gICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgIDBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB0cmFuc2Zvcm0yRChcbiAgICAgICAgICAgICAgaW5Db29yZGluYXRlcyxcbiAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgaW5Db29yZGluYXRlcy5sZW5ndGgsXG4gICAgICAgICAgICAgIHN0cmlkZSxcbiAgICAgICAgICAgICAgdG1wVHJhbnNmb3JtLFxuICAgICAgICAgICAgICBvdXRDb29yZGluYXRlc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybiBnZXRUcmFuc2Zvcm0oc291cmNlUHJvaiwgZGVzdGluYXRpb24pKFxuICAgICAgICAgICAgICBpbkNvb3JkaW5hdGVzLFxuICAgICAgICAgICAgICBvdXRDb29yZGluYXRlcyxcbiAgICAgICAgICAgICAgc3RyaWRlXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgOiBnZXRUcmFuc2Zvcm0oc291cmNlUHJvaiwgZGVzdGluYXRpb24pO1xuICAgIHRoaXMuYXBwbHlUcmFuc2Zvcm0odHJhbnNmb3JtRm4pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEdlb21ldHJ5O1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2dlb20vR2VvbWV0cnlDb2xsZWN0aW9uXG4gKi9cbmltcG9ydCBFdmVudFR5cGUgZnJvbSAnLi4vZXZlbnRzL0V2ZW50VHlwZS5qcyc7XG5pbXBvcnQgR2VvbWV0cnkgZnJvbSAnLi9HZW9tZXRyeS5qcyc7XG5pbXBvcnQge1xuICBjbG9zZXN0U3F1YXJlZERpc3RhbmNlWFksXG4gIGNyZWF0ZU9yVXBkYXRlRW1wdHksXG4gIGV4dGVuZCxcbiAgZ2V0Q2VudGVyLFxufSBmcm9tICcuLi9leHRlbnQuanMnO1xuaW1wb3J0IHtsaXN0ZW4sIHVubGlzdGVuQnlLZXl9IGZyb20gJy4uL2V2ZW50cy5qcyc7XG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQW4gYXJyYXkgb2Yge0BsaW5rIG1vZHVsZTpvbC9nZW9tL0dlb21ldHJ5fkdlb21ldHJ5fSBvYmplY3RzLlxuICpcbiAqIEBhcGlcbiAqL1xuY2xhc3MgR2VvbWV0cnlDb2xsZWN0aW9uIGV4dGVuZHMgR2VvbWV0cnkge1xuICAvKipcbiAgICogQHBhcmFtIHtBcnJheTxHZW9tZXRyeT59IFtnZW9tZXRyaWVzXSBHZW9tZXRyaWVzLlxuICAgKi9cbiAgY29uc3RydWN0b3IoZ2VvbWV0cmllcykge1xuICAgIHN1cGVyKCk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtBcnJheTxHZW9tZXRyeT59XG4gICAgICovXG4gICAgdGhpcy5nZW9tZXRyaWVzXyA9IGdlb21ldHJpZXMgPyBnZW9tZXRyaWVzIDogbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtBcnJheTxpbXBvcnQoXCIuLi9ldmVudHMuanNcIikuRXZlbnRzS2V5Pn1cbiAgICAgKi9cbiAgICB0aGlzLmNoYW5nZUV2ZW50c0tleXNfID0gW107XG5cbiAgICB0aGlzLmxpc3Rlbkdlb21ldHJpZXNDaGFuZ2VfKCk7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHVubGlzdGVuR2VvbWV0cmllc0NoYW5nZV8oKSB7XG4gICAgdGhpcy5jaGFuZ2VFdmVudHNLZXlzXy5mb3JFYWNoKHVubGlzdGVuQnlLZXkpO1xuICAgIHRoaXMuY2hhbmdlRXZlbnRzS2V5c18ubGVuZ3RoID0gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgbGlzdGVuR2VvbWV0cmllc0NoYW5nZV8oKSB7XG4gICAgaWYgKCF0aGlzLmdlb21ldHJpZXNfKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IHRoaXMuZ2VvbWV0cmllc18ubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgdGhpcy5jaGFuZ2VFdmVudHNLZXlzXy5wdXNoKFxuICAgICAgICBsaXN0ZW4odGhpcy5nZW9tZXRyaWVzX1tpXSwgRXZlbnRUeXBlLkNIQU5HRSwgdGhpcy5jaGFuZ2VkLCB0aGlzKVxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTWFrZSBhIGNvbXBsZXRlIGNvcHkgb2YgdGhlIGdlb21ldHJ5LlxuICAgKiBAcmV0dXJuIHshR2VvbWV0cnlDb2xsZWN0aW9ufSBDbG9uZS5cbiAgICogQGFwaVxuICAgKi9cbiAgY2xvbmUoKSB7XG4gICAgY29uc3QgZ2VvbWV0cnlDb2xsZWN0aW9uID0gbmV3IEdlb21ldHJ5Q29sbGVjdGlvbihudWxsKTtcbiAgICBnZW9tZXRyeUNvbGxlY3Rpb24uc2V0R2VvbWV0cmllcyh0aGlzLmdlb21ldHJpZXNfKTtcbiAgICBnZW9tZXRyeUNvbGxlY3Rpb24uYXBwbHlQcm9wZXJ0aWVzKHRoaXMpO1xuICAgIHJldHVybiBnZW9tZXRyeUNvbGxlY3Rpb247XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHggWC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHkgWS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGNsb3Nlc3RQb2ludCBDbG9zZXN0IHBvaW50LlxuICAgKiBAcGFyYW0ge251bWJlcn0gbWluU3F1YXJlZERpc3RhbmNlIE1pbmltdW0gc3F1YXJlZCBkaXN0YW5jZS5cbiAgICogQHJldHVybiB7bnVtYmVyfSBNaW5pbXVtIHNxdWFyZWQgZGlzdGFuY2UuXG4gICAqL1xuICBjbG9zZXN0UG9pbnRYWSh4LCB5LCBjbG9zZXN0UG9pbnQsIG1pblNxdWFyZWREaXN0YW5jZSkge1xuICAgIGlmIChtaW5TcXVhcmVkRGlzdGFuY2UgPCBjbG9zZXN0U3F1YXJlZERpc3RhbmNlWFkodGhpcy5nZXRFeHRlbnQoKSwgeCwgeSkpIHtcbiAgICAgIHJldHVybiBtaW5TcXVhcmVkRGlzdGFuY2U7XG4gICAgfVxuICAgIGNvbnN0IGdlb21ldHJpZXMgPSB0aGlzLmdlb21ldHJpZXNfO1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IGdlb21ldHJpZXMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgbWluU3F1YXJlZERpc3RhbmNlID0gZ2VvbWV0cmllc1tpXS5jbG9zZXN0UG9pbnRYWShcbiAgICAgICAgeCxcbiAgICAgICAgeSxcbiAgICAgICAgY2xvc2VzdFBvaW50LFxuICAgICAgICBtaW5TcXVhcmVkRGlzdGFuY2VcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBtaW5TcXVhcmVkRGlzdGFuY2U7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHggWC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHkgWS5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gQ29udGFpbnMgKHgsIHkpLlxuICAgKi9cbiAgY29udGFpbnNYWSh4LCB5KSB7XG4gICAgY29uc3QgZ2VvbWV0cmllcyA9IHRoaXMuZ2VvbWV0cmllc187XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gZ2VvbWV0cmllcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICBpZiAoZ2VvbWV0cmllc1tpXS5jb250YWluc1hZKHgsIHkpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gICAqL1xuICBjb21wdXRlRXh0ZW50KGV4dGVudCkge1xuICAgIGNyZWF0ZU9yVXBkYXRlRW1wdHkoZXh0ZW50KTtcbiAgICBjb25zdCBnZW9tZXRyaWVzID0gdGhpcy5nZW9tZXRyaWVzXztcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBnZW9tZXRyaWVzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgIGV4dGVuZChleHRlbnQsIGdlb21ldHJpZXNbaV0uZ2V0RXh0ZW50KCkpO1xuICAgIH1cbiAgICByZXR1cm4gZXh0ZW50O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgZ2VvbWV0cmllcyB0aGF0IG1ha2UgdXAgdGhpcyBnZW9tZXRyeSBjb2xsZWN0aW9uLlxuICAgKiBAcmV0dXJuIHtBcnJheTxHZW9tZXRyeT59IEdlb21ldHJpZXMuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldEdlb21ldHJpZXMoKSB7XG4gICAgcmV0dXJuIGNsb25lR2VvbWV0cmllcyh0aGlzLmdlb21ldHJpZXNfKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtBcnJheTxHZW9tZXRyeT59IEdlb21ldHJpZXMuXG4gICAqL1xuICBnZXRHZW9tZXRyaWVzQXJyYXkoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2VvbWV0cmllc187XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7QXJyYXk8R2VvbWV0cnk+fSBHZW9tZXRyaWVzLlxuICAgKi9cbiAgZ2V0R2VvbWV0cmllc0FycmF5UmVjdXJzaXZlKCkge1xuICAgIC8qKiBAdHlwZSB7QXJyYXk8R2VvbWV0cnk+fSAqL1xuICAgIGxldCBnZW9tZXRyaWVzQXJyYXkgPSBbXTtcbiAgICBjb25zdCBnZW9tZXRyaWVzID0gdGhpcy5nZW9tZXRyaWVzXztcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBnZW9tZXRyaWVzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgIGlmIChnZW9tZXRyaWVzW2ldLmdldFR5cGUoKSA9PT0gdGhpcy5nZXRUeXBlKCkpIHtcbiAgICAgICAgZ2VvbWV0cmllc0FycmF5ID0gZ2VvbWV0cmllc0FycmF5LmNvbmNhdChcbiAgICAgICAgICAvKiogQHR5cGUge0dlb21ldHJ5Q29sbGVjdGlvbn0gKi8gKFxuICAgICAgICAgICAgZ2VvbWV0cmllc1tpXVxuICAgICAgICAgICkuZ2V0R2VvbWV0cmllc0FycmF5UmVjdXJzaXZlKClcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGdlb21ldHJpZXNBcnJheS5wdXNoKGdlb21ldHJpZXNbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZ2VvbWV0cmllc0FycmF5O1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIHNpbXBsaWZpZWQgdmVyc2lvbiBvZiB0aGlzIGdlb21ldHJ5IHVzaW5nIHRoZSBEb3VnbGFzIFBldWNrZXIgYWxnb3JpdGhtLlxuICAgKiBAcGFyYW0ge251bWJlcn0gc3F1YXJlZFRvbGVyYW5jZSBTcXVhcmVkIHRvbGVyYW5jZS5cbiAgICogQHJldHVybiB7R2VvbWV0cnlDb2xsZWN0aW9ufSBTaW1wbGlmaWVkIEdlb21ldHJ5Q29sbGVjdGlvbi5cbiAgICovXG4gIGdldFNpbXBsaWZpZWRHZW9tZXRyeShzcXVhcmVkVG9sZXJhbmNlKSB7XG4gICAgaWYgKHRoaXMuc2ltcGxpZmllZEdlb21ldHJ5UmV2aXNpb24gIT09IHRoaXMuZ2V0UmV2aXNpb24oKSkge1xuICAgICAgdGhpcy5zaW1wbGlmaWVkR2VvbWV0cnlNYXhNaW5TcXVhcmVkVG9sZXJhbmNlID0gMDtcbiAgICAgIHRoaXMuc2ltcGxpZmllZEdlb21ldHJ5UmV2aXNpb24gPSB0aGlzLmdldFJldmlzaW9uKCk7XG4gICAgfVxuICAgIGlmIChcbiAgICAgIHNxdWFyZWRUb2xlcmFuY2UgPCAwIHx8XG4gICAgICAodGhpcy5zaW1wbGlmaWVkR2VvbWV0cnlNYXhNaW5TcXVhcmVkVG9sZXJhbmNlICE9PSAwICYmXG4gICAgICAgIHNxdWFyZWRUb2xlcmFuY2UgPCB0aGlzLnNpbXBsaWZpZWRHZW9tZXRyeU1heE1pblNxdWFyZWRUb2xlcmFuY2UpXG4gICAgKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBjb25zdCBzaW1wbGlmaWVkR2VvbWV0cmllcyA9IFtdO1xuICAgIGNvbnN0IGdlb21ldHJpZXMgPSB0aGlzLmdlb21ldHJpZXNfO1xuICAgIGxldCBzaW1wbGlmaWVkID0gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gZ2VvbWV0cmllcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICBjb25zdCBnZW9tZXRyeSA9IGdlb21ldHJpZXNbaV07XG4gICAgICBjb25zdCBzaW1wbGlmaWVkR2VvbWV0cnkgPVxuICAgICAgICBnZW9tZXRyeS5nZXRTaW1wbGlmaWVkR2VvbWV0cnkoc3F1YXJlZFRvbGVyYW5jZSk7XG4gICAgICBzaW1wbGlmaWVkR2VvbWV0cmllcy5wdXNoKHNpbXBsaWZpZWRHZW9tZXRyeSk7XG4gICAgICBpZiAoc2ltcGxpZmllZEdlb21ldHJ5ICE9PSBnZW9tZXRyeSkge1xuICAgICAgICBzaW1wbGlmaWVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNpbXBsaWZpZWQpIHtcbiAgICAgIGNvbnN0IHNpbXBsaWZpZWRHZW9tZXRyeUNvbGxlY3Rpb24gPSBuZXcgR2VvbWV0cnlDb2xsZWN0aW9uKG51bGwpO1xuICAgICAgc2ltcGxpZmllZEdlb21ldHJ5Q29sbGVjdGlvbi5zZXRHZW9tZXRyaWVzQXJyYXkoc2ltcGxpZmllZEdlb21ldHJpZXMpO1xuICAgICAgcmV0dXJuIHNpbXBsaWZpZWRHZW9tZXRyeUNvbGxlY3Rpb247XG4gICAgfVxuICAgIHRoaXMuc2ltcGxpZmllZEdlb21ldHJ5TWF4TWluU3F1YXJlZFRvbGVyYW5jZSA9IHNxdWFyZWRUb2xlcmFuY2U7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB0eXBlIG9mIHRoaXMgZ2VvbWV0cnkuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4vR2VvbWV0cnkuanNcIikuVHlwZX0gR2VvbWV0cnkgdHlwZS5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0VHlwZSgpIHtcbiAgICByZXR1cm4gJ0dlb21ldHJ5Q29sbGVjdGlvbic7XG4gIH1cblxuICAvKipcbiAgICogVGVzdCBpZiB0aGUgZ2VvbWV0cnkgYW5kIHRoZSBwYXNzZWQgZXh0ZW50IGludGVyc2VjdC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBgdHJ1ZWAgaWYgdGhlIGdlb21ldHJ5IGFuZCB0aGUgZXh0ZW50IGludGVyc2VjdC5cbiAgICogQGFwaVxuICAgKi9cbiAgaW50ZXJzZWN0c0V4dGVudChleHRlbnQpIHtcbiAgICBjb25zdCBnZW9tZXRyaWVzID0gdGhpcy5nZW9tZXRyaWVzXztcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBnZW9tZXRyaWVzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgIGlmIChnZW9tZXRyaWVzW2ldLmludGVyc2VjdHNFeHRlbnQoZXh0ZW50KSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IElzIGVtcHR5LlxuICAgKi9cbiAgaXNFbXB0eSgpIHtcbiAgICByZXR1cm4gdGhpcy5nZW9tZXRyaWVzXy5sZW5ndGggPT09IDA7XG4gIH1cblxuICAvKipcbiAgICogUm90YXRlIHRoZSBnZW9tZXRyeSBhcm91bmQgYSBnaXZlbiBjb29yZGluYXRlLiBUaGlzIG1vZGlmaWVzIHRoZSBnZW9tZXRyeVxuICAgKiBjb29yZGluYXRlcyBpbiBwbGFjZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGFuZ2xlIFJvdGF0aW9uIGFuZ2xlIGluIHJhZGlhbnMuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBhbmNob3IgVGhlIHJvdGF0aW9uIGNlbnRlci5cbiAgICogQGFwaVxuICAgKi9cbiAgcm90YXRlKGFuZ2xlLCBhbmNob3IpIHtcbiAgICBjb25zdCBnZW9tZXRyaWVzID0gdGhpcy5nZW9tZXRyaWVzXztcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBnZW9tZXRyaWVzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgIGdlb21ldHJpZXNbaV0ucm90YXRlKGFuZ2xlLCBhbmNob3IpO1xuICAgIH1cbiAgICB0aGlzLmNoYW5nZWQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTY2FsZSB0aGUgZ2VvbWV0cnkgKHdpdGggYW4gb3B0aW9uYWwgb3JpZ2luKS4gIFRoaXMgbW9kaWZpZXMgdGhlIGdlb21ldHJ5XG4gICAqIGNvb3JkaW5hdGVzIGluIHBsYWNlLlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHBhcmFtIHtudW1iZXJ9IHN4IFRoZSBzY2FsaW5nIGZhY3RvciBpbiB0aGUgeC1kaXJlY3Rpb24uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbc3ldIFRoZSBzY2FsaW5nIGZhY3RvciBpbiB0aGUgeS1kaXJlY3Rpb24gKGRlZmF1bHRzIHRvIHN4KS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IFthbmNob3JdIFRoZSBzY2FsZSBvcmlnaW4gKGRlZmF1bHRzIHRvIHRoZSBjZW50ZXJcbiAgICogICAgIG9mIHRoZSBnZW9tZXRyeSBleHRlbnQpLlxuICAgKiBAYXBpXG4gICAqL1xuICBzY2FsZShzeCwgc3ksIGFuY2hvcikge1xuICAgIGlmICghYW5jaG9yKSB7XG4gICAgICBhbmNob3IgPSBnZXRDZW50ZXIodGhpcy5nZXRFeHRlbnQoKSk7XG4gICAgfVxuICAgIGNvbnN0IGdlb21ldHJpZXMgPSB0aGlzLmdlb21ldHJpZXNfO1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IGdlb21ldHJpZXMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgZ2VvbWV0cmllc1tpXS5zY2FsZShzeCwgc3ksIGFuY2hvcik7XG4gICAgfVxuICAgIHRoaXMuY2hhbmdlZCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgZ2VvbWV0cmllcyB0aGF0IG1ha2UgdXAgdGhpcyBnZW9tZXRyeSBjb2xsZWN0aW9uLlxuICAgKiBAcGFyYW0ge0FycmF5PEdlb21ldHJ5Pn0gZ2VvbWV0cmllcyBHZW9tZXRyaWVzLlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRHZW9tZXRyaWVzKGdlb21ldHJpZXMpIHtcbiAgICB0aGlzLnNldEdlb21ldHJpZXNBcnJheShjbG9uZUdlb21ldHJpZXMoZ2VvbWV0cmllcykpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7QXJyYXk8R2VvbWV0cnk+fSBnZW9tZXRyaWVzIEdlb21ldHJpZXMuXG4gICAqL1xuICBzZXRHZW9tZXRyaWVzQXJyYXkoZ2VvbWV0cmllcykge1xuICAgIHRoaXMudW5saXN0ZW5HZW9tZXRyaWVzQ2hhbmdlXygpO1xuICAgIHRoaXMuZ2VvbWV0cmllc18gPSBnZW9tZXRyaWVzO1xuICAgIHRoaXMubGlzdGVuR2VvbWV0cmllc0NoYW5nZV8oKTtcbiAgICB0aGlzLmNoYW5nZWQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBcHBseSBhIHRyYW5zZm9ybSBmdW5jdGlvbiB0byB0aGUgY29vcmRpbmF0ZXMgb2YgdGhlIGdlb21ldHJ5LlxuICAgKiBUaGUgZ2VvbWV0cnkgaXMgbW9kaWZpZWQgaW4gcGxhY2UuXG4gICAqIElmIHlvdSBkbyBub3Qgd2FudCB0aGUgZ2VvbWV0cnkgbW9kaWZpZWQgaW4gcGxhY2UsIGZpcnN0IGBjbG9uZSgpYCBpdCBhbmRcbiAgICogdGhlbiB1c2UgdGhpcyBmdW5jdGlvbiBvbiB0aGUgY2xvbmUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcHJvai5qc1wiKS5UcmFuc2Zvcm1GdW5jdGlvbn0gdHJhbnNmb3JtRm4gVHJhbnNmb3JtIGZ1bmN0aW9uLlxuICAgKiBDYWxsZWQgd2l0aCBhIGZsYXQgYXJyYXkgb2YgZ2VvbWV0cnkgY29vcmRpbmF0ZXMuXG4gICAqIEBhcGlcbiAgICovXG4gIGFwcGx5VHJhbnNmb3JtKHRyYW5zZm9ybUZuKSB7XG4gICAgY29uc3QgZ2VvbWV0cmllcyA9IHRoaXMuZ2VvbWV0cmllc187XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gZ2VvbWV0cmllcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICBnZW9tZXRyaWVzW2ldLmFwcGx5VHJhbnNmb3JtKHRyYW5zZm9ybUZuKTtcbiAgICB9XG4gICAgdGhpcy5jaGFuZ2VkKCk7XG4gIH1cblxuICAvKipcbiAgICogVHJhbnNsYXRlIHRoZSBnZW9tZXRyeS4gIFRoaXMgbW9kaWZpZXMgdGhlIGdlb21ldHJ5IGNvb3JkaW5hdGVzIGluIHBsYWNlLiAgSWZcbiAgICogaW5zdGVhZCB5b3Ugd2FudCBhIG5ldyBnZW9tZXRyeSwgZmlyc3QgYGNsb25lKClgIHRoaXMgZ2VvbWV0cnkuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkZWx0YVggRGVsdGEgWC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGRlbHRhWSBEZWx0YSBZLlxuICAgKiBAYXBpXG4gICAqL1xuICB0cmFuc2xhdGUoZGVsdGFYLCBkZWx0YVkpIHtcbiAgICBjb25zdCBnZW9tZXRyaWVzID0gdGhpcy5nZW9tZXRyaWVzXztcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBnZW9tZXRyaWVzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgIGdlb21ldHJpZXNbaV0udHJhbnNsYXRlKGRlbHRhWCwgZGVsdGFZKTtcbiAgICB9XG4gICAgdGhpcy5jaGFuZ2VkKCk7XG4gIH1cblxuICAvKipcbiAgICogQ2xlYW4gdXAuXG4gICAqL1xuICBkaXNwb3NlSW50ZXJuYWwoKSB7XG4gICAgdGhpcy51bmxpc3Rlbkdlb21ldHJpZXNDaGFuZ2VfKCk7XG4gICAgc3VwZXIuZGlzcG9zZUludGVybmFsKCk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PEdlb21ldHJ5Pn0gZ2VvbWV0cmllcyBHZW9tZXRyaWVzLlxuICogQHJldHVybiB7QXJyYXk8R2VvbWV0cnk+fSBDbG9uZWQgZ2VvbWV0cmllcy5cbiAqL1xuZnVuY3Rpb24gY2xvbmVHZW9tZXRyaWVzKGdlb21ldHJpZXMpIHtcbiAgY29uc3QgY2xvbmVkR2VvbWV0cmllcyA9IFtdO1xuICBmb3IgKGxldCBpID0gMCwgaWkgPSBnZW9tZXRyaWVzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICBjbG9uZWRHZW9tZXRyaWVzLnB1c2goZ2VvbWV0cmllc1tpXS5jbG9uZSgpKTtcbiAgfVxuICByZXR1cm4gY2xvbmVkR2VvbWV0cmllcztcbn1cblxuZXhwb3J0IGRlZmF1bHQgR2VvbWV0cnlDb2xsZWN0aW9uO1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2dlb20vTGluZVN0cmluZ1xuICovXG5pbXBvcnQgU2ltcGxlR2VvbWV0cnkgZnJvbSAnLi9TaW1wbGVHZW9tZXRyeS5qcyc7XG5pbXBvcnQge2Fzc2lnbkNsb3Nlc3RQb2ludCwgbWF4U3F1YXJlZERlbHRhfSBmcm9tICcuL2ZsYXQvY2xvc2VzdC5qcyc7XG5pbXBvcnQge2Nsb3Nlc3RTcXVhcmVkRGlzdGFuY2VYWX0gZnJvbSAnLi4vZXh0ZW50LmpzJztcbmltcG9ydCB7ZGVmbGF0ZUNvb3JkaW5hdGVzfSBmcm9tICcuL2ZsYXQvZGVmbGF0ZS5qcyc7XG5pbXBvcnQge2RvdWdsYXNQZXVja2VyfSBmcm9tICcuL2ZsYXQvc2ltcGxpZnkuanMnO1xuaW1wb3J0IHtleHRlbmR9IGZyb20gJy4uL2FycmF5LmpzJztcbmltcG9ydCB7Zm9yRWFjaCBhcyBmb3JFYWNoU2VnbWVudH0gZnJvbSAnLi9mbGF0L3NlZ21lbnRzLmpzJztcbmltcG9ydCB7aW5mbGF0ZUNvb3JkaW5hdGVzfSBmcm9tICcuL2ZsYXQvaW5mbGF0ZS5qcyc7XG5pbXBvcnQge2ludGVycG9sYXRlUG9pbnQsIGxpbmVTdHJpbmdDb29yZGluYXRlQXRNfSBmcm9tICcuL2ZsYXQvaW50ZXJwb2xhdGUuanMnO1xuaW1wb3J0IHtpbnRlcnNlY3RzTGluZVN0cmluZ30gZnJvbSAnLi9mbGF0L2ludGVyc2VjdHNleHRlbnQuanMnO1xuaW1wb3J0IHtsaW5lU3RyaW5nTGVuZ3RofSBmcm9tICcuL2ZsYXQvbGVuZ3RoLmpzJztcblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBMaW5lc3RyaW5nIGdlb21ldHJ5LlxuICpcbiAqIEBhcGlcbiAqL1xuY2xhc3MgTGluZVN0cmluZyBleHRlbmRzIFNpbXBsZUdlb21ldHJ5IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7QXJyYXk8aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlPnxBcnJheTxudW1iZXI+fSBjb29yZGluYXRlcyBDb29yZGluYXRlcy5cbiAgICogICAgIEZvciBpbnRlcm5hbCB1c2UsIGZsYXQgY29vcmRpbmF0ZXMgaW4gY29tYmluYXRpb24gd2l0aCBgbGF5b3V0YCBhcmUgYWxzbyBhY2NlcHRlZC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL0dlb21ldHJ5LmpzXCIpLkdlb21ldHJ5TGF5b3V0fSBbbGF5b3V0XSBMYXlvdXQuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihjb29yZGluYXRlcywgbGF5b3V0KSB7XG4gICAgc3VwZXIoKTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX1cbiAgICAgKi9cbiAgICB0aGlzLmZsYXRNaWRwb2ludF8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuZmxhdE1pZHBvaW50UmV2aXNpb25fID0gLTE7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5tYXhEZWx0YV8gPSAtMTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLm1heERlbHRhUmV2aXNpb25fID0gLTE7XG5cbiAgICBpZiAobGF5b3V0ICE9PSB1bmRlZmluZWQgJiYgIUFycmF5LmlzQXJyYXkoY29vcmRpbmF0ZXNbMF0pKSB7XG4gICAgICB0aGlzLnNldEZsYXRDb29yZGluYXRlcyhcbiAgICAgICAgbGF5b3V0LFxuICAgICAgICAvKiogQHR5cGUge0FycmF5PG51bWJlcj59ICovIChjb29yZGluYXRlcylcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2V0Q29vcmRpbmF0ZXMoXG4gICAgICAgIC8qKiBAdHlwZSB7QXJyYXk8aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlPn0gKi8gKFxuICAgICAgICAgIGNvb3JkaW5hdGVzXG4gICAgICAgICksXG4gICAgICAgIGxheW91dFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQXBwZW5kIHRoZSBwYXNzZWQgY29vcmRpbmF0ZSB0byB0aGUgY29vcmRpbmF0ZXMgb2YgdGhlIGxpbmVzdHJpbmcuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBjb29yZGluYXRlIENvb3JkaW5hdGUuXG4gICAqIEBhcGlcbiAgICovXG4gIGFwcGVuZENvb3JkaW5hdGUoY29vcmRpbmF0ZSkge1xuICAgIGlmICghdGhpcy5mbGF0Q29vcmRpbmF0ZXMpIHtcbiAgICAgIHRoaXMuZmxhdENvb3JkaW5hdGVzID0gY29vcmRpbmF0ZS5zbGljZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBleHRlbmQodGhpcy5mbGF0Q29vcmRpbmF0ZXMsIGNvb3JkaW5hdGUpO1xuICAgIH1cbiAgICB0aGlzLmNoYW5nZWQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNYWtlIGEgY29tcGxldGUgY29weSBvZiB0aGUgZ2VvbWV0cnkuXG4gICAqIEByZXR1cm4geyFMaW5lU3RyaW5nfSBDbG9uZS5cbiAgICogQGFwaVxuICAgKi9cbiAgY2xvbmUoKSB7XG4gICAgY29uc3QgbGluZVN0cmluZyA9IG5ldyBMaW5lU3RyaW5nKFxuICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMuc2xpY2UoKSxcbiAgICAgIHRoaXMubGF5b3V0XG4gICAgKTtcbiAgICBsaW5lU3RyaW5nLmFwcGx5UHJvcGVydGllcyh0aGlzKTtcbiAgICByZXR1cm4gbGluZVN0cmluZztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0geCBYLlxuICAgKiBAcGFyYW0ge251bWJlcn0geSBZLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gY2xvc2VzdFBvaW50IENsb3Nlc3QgcG9pbnQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtaW5TcXVhcmVkRGlzdGFuY2UgTWluaW11bSBzcXVhcmVkIGRpc3RhbmNlLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IE1pbmltdW0gc3F1YXJlZCBkaXN0YW5jZS5cbiAgICovXG4gIGNsb3Nlc3RQb2ludFhZKHgsIHksIGNsb3Nlc3RQb2ludCwgbWluU3F1YXJlZERpc3RhbmNlKSB7XG4gICAgaWYgKG1pblNxdWFyZWREaXN0YW5jZSA8IGNsb3Nlc3RTcXVhcmVkRGlzdGFuY2VYWSh0aGlzLmdldEV4dGVudCgpLCB4LCB5KSkge1xuICAgICAgcmV0dXJuIG1pblNxdWFyZWREaXN0YW5jZTtcbiAgICB9XG4gICAgaWYgKHRoaXMubWF4RGVsdGFSZXZpc2lvbl8gIT0gdGhpcy5nZXRSZXZpc2lvbigpKSB7XG4gICAgICB0aGlzLm1heERlbHRhXyA9IE1hdGguc3FydChcbiAgICAgICAgbWF4U3F1YXJlZERlbHRhKFxuICAgICAgICAgIHRoaXMuZmxhdENvb3JkaW5hdGVzLFxuICAgICAgICAgIDAsXG4gICAgICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMubGVuZ3RoLFxuICAgICAgICAgIHRoaXMuc3RyaWRlLFxuICAgICAgICAgIDBcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICAgIHRoaXMubWF4RGVsdGFSZXZpc2lvbl8gPSB0aGlzLmdldFJldmlzaW9uKCk7XG4gICAgfVxuICAgIHJldHVybiBhc3NpZ25DbG9zZXN0UG9pbnQoXG4gICAgICB0aGlzLmZsYXRDb29yZGluYXRlcyxcbiAgICAgIDAsXG4gICAgICB0aGlzLmZsYXRDb29yZGluYXRlcy5sZW5ndGgsXG4gICAgICB0aGlzLnN0cmlkZSxcbiAgICAgIHRoaXMubWF4RGVsdGFfLFxuICAgICAgZmFsc2UsXG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIGNsb3Nlc3RQb2ludCxcbiAgICAgIG1pblNxdWFyZWREaXN0YW5jZVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogSXRlcmF0ZSBvdmVyIGVhY2ggc2VnbWVudCwgY2FsbGluZyB0aGUgcHJvdmlkZWQgY2FsbGJhY2suXG4gICAqIElmIHRoZSBjYWxsYmFjayByZXR1cm5zIGEgdHJ1dGh5IHZhbHVlIHRoZSBmdW5jdGlvbiByZXR1cm5zIHRoYXRcbiAgICogdmFsdWUgaW1tZWRpYXRlbHkuIE90aGVyd2lzZSB0aGUgZnVuY3Rpb24gcmV0dXJucyBgZmFsc2VgLlxuICAgKlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKHRoaXM6IFMsIGltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZSwgaW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlKTogVH0gY2FsbGJhY2sgRnVuY3Rpb25cbiAgICogICAgIGNhbGxlZCBmb3IgZWFjaCBzZWdtZW50LiBUaGUgZnVuY3Rpb24gd2lsbCByZWNlaXZlIHR3byBhcmd1bWVudHMsIHRoZSBzdGFydCBhbmQgZW5kIGNvb3JkaW5hdGVzIG9mIHRoZSBzZWdtZW50LlxuICAgKiBAcmV0dXJuIHtUfGJvb2xlYW59IFZhbHVlLlxuICAgKiBAdGVtcGxhdGUgVCxTXG4gICAqIEBhcGlcbiAgICovXG4gIGZvckVhY2hTZWdtZW50KGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIGZvckVhY2hTZWdtZW50KFxuICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMsXG4gICAgICAwLFxuICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMubGVuZ3RoLFxuICAgICAgdGhpcy5zdHJpZGUsXG4gICAgICBjYWxsYmFja1xuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY29vcmRpbmF0ZSBhdCBgbWAgdXNpbmcgbGluZWFyIGludGVycG9sYXRpb24sIG9yIGBudWxsYCBpZiBub1xuICAgKiBzdWNoIGNvb3JkaW5hdGUgZXhpc3RzLlxuICAgKlxuICAgKiBgZXh0cmFwb2xhdGVgIGNvbnRyb2xzIGV4dHJhcG9sYXRpb24gYmV5b25kIHRoZSByYW5nZSBvZiBNcyBpbiB0aGVcbiAgICogTXVsdGlMaW5lU3RyaW5nLiBJZiBgZXh0cmFwb2xhdGVgIGlzIGB0cnVlYCB0aGVuIE1zIGxlc3MgdGhhbiB0aGUgZmlyc3RcbiAgICogTSB3aWxsIHJldHVybiB0aGUgZmlyc3QgY29vcmRpbmF0ZSBhbmQgTXMgZ3JlYXRlciB0aGFuIHRoZSBsYXN0IE0gd2lsbFxuICAgKiByZXR1cm4gdGhlIGxhc3QgY29vcmRpbmF0ZS5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IG0gTS5cbiAgICogQHBhcmFtIHtib29sZWFufSBbZXh0cmFwb2xhdGVdIEV4dHJhcG9sYXRlLiBEZWZhdWx0IGlzIGBmYWxzZWAuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZXxudWxsfSBDb29yZGluYXRlLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRDb29yZGluYXRlQXRNKG0sIGV4dHJhcG9sYXRlKSB7XG4gICAgaWYgKHRoaXMubGF5b3V0ICE9ICdYWU0nICYmIHRoaXMubGF5b3V0ICE9ICdYWVpNJykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGV4dHJhcG9sYXRlID0gZXh0cmFwb2xhdGUgIT09IHVuZGVmaW5lZCA/IGV4dHJhcG9sYXRlIDogZmFsc2U7XG4gICAgcmV0dXJuIGxpbmVTdHJpbmdDb29yZGluYXRlQXRNKFxuICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMsXG4gICAgICAwLFxuICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMubGVuZ3RoLFxuICAgICAgdGhpcy5zdHJpZGUsXG4gICAgICBtLFxuICAgICAgZXh0cmFwb2xhdGVcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgY29vcmRpbmF0ZXMgb2YgdGhlIGxpbmVzdHJpbmcuXG4gICAqIEByZXR1cm4ge0FycmF5PGltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZT59IENvb3JkaW5hdGVzLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRDb29yZGluYXRlcygpIHtcbiAgICByZXR1cm4gaW5mbGF0ZUNvb3JkaW5hdGVzKFxuICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMsXG4gICAgICAwLFxuICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMubGVuZ3RoLFxuICAgICAgdGhpcy5zdHJpZGVcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgY29vcmRpbmF0ZSBhdCB0aGUgcHJvdmlkZWQgZnJhY3Rpb24gYWxvbmcgdGhlIGxpbmVzdHJpbmcuXG4gICAqIFRoZSBgZnJhY3Rpb25gIGlzIGEgbnVtYmVyIGJldHdlZW4gMCBhbmQgMSwgd2hlcmUgMCBpcyB0aGUgc3RhcnQgb2YgdGhlXG4gICAqIGxpbmVzdHJpbmcgYW5kIDEgaXMgdGhlIGVuZC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGZyYWN0aW9uIEZyYWN0aW9uLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gW2Rlc3RdIE9wdGlvbmFsIGNvb3JkaW5hdGUgd2hvc2UgdmFsdWVzIHdpbGxcbiAgICogICAgIGJlIG1vZGlmaWVkLiBJZiBub3QgcHJvdmlkZWQsIGEgbmV3IGNvb3JkaW5hdGUgd2lsbCBiZSByZXR1cm5lZC5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBDb29yZGluYXRlIG9mIHRoZSBpbnRlcnBvbGF0ZWQgcG9pbnQuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldENvb3JkaW5hdGVBdChmcmFjdGlvbiwgZGVzdCkge1xuICAgIHJldHVybiBpbnRlcnBvbGF0ZVBvaW50KFxuICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMsXG4gICAgICAwLFxuICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMubGVuZ3RoLFxuICAgICAgdGhpcy5zdHJpZGUsXG4gICAgICBmcmFjdGlvbixcbiAgICAgIGRlc3QsXG4gICAgICB0aGlzLnN0cmlkZVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBsZW5ndGggb2YgdGhlIGxpbmVzdHJpbmcgb24gcHJvamVjdGVkIHBsYW5lLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IExlbmd0aCAob24gcHJvamVjdGVkIHBsYW5lKS5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0TGVuZ3RoKCkge1xuICAgIHJldHVybiBsaW5lU3RyaW5nTGVuZ3RoKFxuICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMsXG4gICAgICAwLFxuICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMubGVuZ3RoLFxuICAgICAgdGhpcy5zdHJpZGVcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IEZsYXQgbWlkcG9pbnQuXG4gICAqL1xuICBnZXRGbGF0TWlkcG9pbnQoKSB7XG4gICAgaWYgKHRoaXMuZmxhdE1pZHBvaW50UmV2aXNpb25fICE9IHRoaXMuZ2V0UmV2aXNpb24oKSkge1xuICAgICAgdGhpcy5mbGF0TWlkcG9pbnRfID0gdGhpcy5nZXRDb29yZGluYXRlQXQoMC41LCB0aGlzLmZsYXRNaWRwb2ludF8pO1xuICAgICAgdGhpcy5mbGF0TWlkcG9pbnRSZXZpc2lvbl8gPSB0aGlzLmdldFJldmlzaW9uKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZsYXRNaWRwb2ludF87XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNxdWFyZWRUb2xlcmFuY2UgU3F1YXJlZCB0b2xlcmFuY2UuXG4gICAqIEByZXR1cm4ge0xpbmVTdHJpbmd9IFNpbXBsaWZpZWQgTGluZVN0cmluZy5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgZ2V0U2ltcGxpZmllZEdlb21ldHJ5SW50ZXJuYWwoc3F1YXJlZFRvbGVyYW5jZSkge1xuICAgIGNvbnN0IHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXMgPSBbXTtcbiAgICBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzLmxlbmd0aCA9IGRvdWdsYXNQZXVja2VyKFxuICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMsXG4gICAgICAwLFxuICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMubGVuZ3RoLFxuICAgICAgdGhpcy5zdHJpZGUsXG4gICAgICBzcXVhcmVkVG9sZXJhbmNlLFxuICAgICAgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcyxcbiAgICAgIDBcbiAgICApO1xuICAgIHJldHVybiBuZXcgTGluZVN0cmluZyhzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzLCAnWFknKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHR5cGUgb2YgdGhpcyBnZW9tZXRyeS5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi9HZW9tZXRyeS5qc1wiKS5UeXBlfSBHZW9tZXRyeSB0eXBlLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRUeXBlKCkge1xuICAgIHJldHVybiAnTGluZVN0cmluZyc7XG4gIH1cblxuICAvKipcbiAgICogVGVzdCBpZiB0aGUgZ2VvbWV0cnkgYW5kIHRoZSBwYXNzZWQgZXh0ZW50IGludGVyc2VjdC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBgdHJ1ZWAgaWYgdGhlIGdlb21ldHJ5IGFuZCB0aGUgZXh0ZW50IGludGVyc2VjdC5cbiAgICogQGFwaVxuICAgKi9cbiAgaW50ZXJzZWN0c0V4dGVudChleHRlbnQpIHtcbiAgICByZXR1cm4gaW50ZXJzZWN0c0xpbmVTdHJpbmcoXG4gICAgICB0aGlzLmZsYXRDb29yZGluYXRlcyxcbiAgICAgIDAsXG4gICAgICB0aGlzLmZsYXRDb29yZGluYXRlcy5sZW5ndGgsXG4gICAgICB0aGlzLnN0cmlkZSxcbiAgICAgIGV4dGVudFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBjb29yZGluYXRlcyBvZiB0aGUgbGluZXN0cmluZy5cbiAgICogQHBhcmFtIHshQXJyYXk8aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlPn0gY29vcmRpbmF0ZXMgQ29vcmRpbmF0ZXMuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9HZW9tZXRyeS5qc1wiKS5HZW9tZXRyeUxheW91dH0gW2xheW91dF0gTGF5b3V0LlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRDb29yZGluYXRlcyhjb29yZGluYXRlcywgbGF5b3V0KSB7XG4gICAgdGhpcy5zZXRMYXlvdXQobGF5b3V0LCBjb29yZGluYXRlcywgMSk7XG4gICAgaWYgKCF0aGlzLmZsYXRDb29yZGluYXRlcykge1xuICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMgPSBbXTtcbiAgICB9XG4gICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMubGVuZ3RoID0gZGVmbGF0ZUNvb3JkaW5hdGVzKFxuICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMsXG4gICAgICAwLFxuICAgICAgY29vcmRpbmF0ZXMsXG4gICAgICB0aGlzLnN0cmlkZVxuICAgICk7XG4gICAgdGhpcy5jaGFuZ2VkKCk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTGluZVN0cmluZztcbiIsIi8qKlxuICogQG1vZHVsZSBvbC9nZW9tL0xpbmVhclJpbmdcbiAqL1xuaW1wb3J0IFNpbXBsZUdlb21ldHJ5IGZyb20gJy4vU2ltcGxlR2VvbWV0cnkuanMnO1xuaW1wb3J0IHthc3NpZ25DbG9zZXN0UG9pbnQsIG1heFNxdWFyZWREZWx0YX0gZnJvbSAnLi9mbGF0L2Nsb3Nlc3QuanMnO1xuaW1wb3J0IHtjbG9zZXN0U3F1YXJlZERpc3RhbmNlWFl9IGZyb20gJy4uL2V4dGVudC5qcyc7XG5pbXBvcnQge2RlZmxhdGVDb29yZGluYXRlc30gZnJvbSAnLi9mbGF0L2RlZmxhdGUuanMnO1xuaW1wb3J0IHtkb3VnbGFzUGV1Y2tlcn0gZnJvbSAnLi9mbGF0L3NpbXBsaWZ5LmpzJztcbmltcG9ydCB7aW5mbGF0ZUNvb3JkaW5hdGVzfSBmcm9tICcuL2ZsYXQvaW5mbGF0ZS5qcyc7XG5pbXBvcnQge2xpbmVhclJpbmcgYXMgbGluZWFyUmluZ0FyZWF9IGZyb20gJy4vZmxhdC9hcmVhLmpzJztcblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBMaW5lYXIgcmluZyBnZW9tZXRyeS4gT25seSB1c2VkIGFzIHBhcnQgb2YgcG9seWdvbjsgY2Fubm90IGJlIHJlbmRlcmVkXG4gKiBvbiBpdHMgb3duLlxuICpcbiAqIEBhcGlcbiAqL1xuY2xhc3MgTGluZWFyUmluZyBleHRlbmRzIFNpbXBsZUdlb21ldHJ5IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7QXJyYXk8aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlPnxBcnJheTxudW1iZXI+fSBjb29yZGluYXRlcyBDb29yZGluYXRlcy5cbiAgICogICAgIEZvciBpbnRlcm5hbCB1c2UsIGZsYXQgY29vcmRpbmF0ZXMgaW4gY29tYmluYXRpb24gd2l0aCBgbGF5b3V0YCBhcmUgYWxzbyBhY2NlcHRlZC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL0dlb21ldHJ5LmpzXCIpLkdlb21ldHJ5TGF5b3V0fSBbbGF5b3V0XSBMYXlvdXQuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihjb29yZGluYXRlcywgbGF5b3V0KSB7XG4gICAgc3VwZXIoKTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLm1heERlbHRhXyA9IC0xO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubWF4RGVsdGFSZXZpc2lvbl8gPSAtMTtcblxuICAgIGlmIChsYXlvdXQgIT09IHVuZGVmaW5lZCAmJiAhQXJyYXkuaXNBcnJheShjb29yZGluYXRlc1swXSkpIHtcbiAgICAgIHRoaXMuc2V0RmxhdENvb3JkaW5hdGVzKFxuICAgICAgICBsYXlvdXQsXG4gICAgICAgIC8qKiBAdHlwZSB7QXJyYXk8bnVtYmVyPn0gKi8gKGNvb3JkaW5hdGVzKVxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZXRDb29yZGluYXRlcyhcbiAgICAgICAgLyoqIEB0eXBlIHtBcnJheTxpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGU+fSAqLyAoXG4gICAgICAgICAgY29vcmRpbmF0ZXNcbiAgICAgICAgKSxcbiAgICAgICAgbGF5b3V0XG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBNYWtlIGEgY29tcGxldGUgY29weSBvZiB0aGUgZ2VvbWV0cnkuXG4gICAqIEByZXR1cm4geyFMaW5lYXJSaW5nfSBDbG9uZS5cbiAgICogQGFwaVxuICAgKi9cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIG5ldyBMaW5lYXJSaW5nKHRoaXMuZmxhdENvb3JkaW5hdGVzLnNsaWNlKCksIHRoaXMubGF5b3V0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0geCBYLlxuICAgKiBAcGFyYW0ge251bWJlcn0geSBZLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gY2xvc2VzdFBvaW50IENsb3Nlc3QgcG9pbnQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtaW5TcXVhcmVkRGlzdGFuY2UgTWluaW11bSBzcXVhcmVkIGRpc3RhbmNlLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IE1pbmltdW0gc3F1YXJlZCBkaXN0YW5jZS5cbiAgICovXG4gIGNsb3Nlc3RQb2ludFhZKHgsIHksIGNsb3Nlc3RQb2ludCwgbWluU3F1YXJlZERpc3RhbmNlKSB7XG4gICAgaWYgKG1pblNxdWFyZWREaXN0YW5jZSA8IGNsb3Nlc3RTcXVhcmVkRGlzdGFuY2VYWSh0aGlzLmdldEV4dGVudCgpLCB4LCB5KSkge1xuICAgICAgcmV0dXJuIG1pblNxdWFyZWREaXN0YW5jZTtcbiAgICB9XG4gICAgaWYgKHRoaXMubWF4RGVsdGFSZXZpc2lvbl8gIT0gdGhpcy5nZXRSZXZpc2lvbigpKSB7XG4gICAgICB0aGlzLm1heERlbHRhXyA9IE1hdGguc3FydChcbiAgICAgICAgbWF4U3F1YXJlZERlbHRhKFxuICAgICAgICAgIHRoaXMuZmxhdENvb3JkaW5hdGVzLFxuICAgICAgICAgIDAsXG4gICAgICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMubGVuZ3RoLFxuICAgICAgICAgIHRoaXMuc3RyaWRlLFxuICAgICAgICAgIDBcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICAgIHRoaXMubWF4RGVsdGFSZXZpc2lvbl8gPSB0aGlzLmdldFJldmlzaW9uKCk7XG4gICAgfVxuICAgIHJldHVybiBhc3NpZ25DbG9zZXN0UG9pbnQoXG4gICAgICB0aGlzLmZsYXRDb29yZGluYXRlcyxcbiAgICAgIDAsXG4gICAgICB0aGlzLmZsYXRDb29yZGluYXRlcy5sZW5ndGgsXG4gICAgICB0aGlzLnN0cmlkZSxcbiAgICAgIHRoaXMubWF4RGVsdGFfLFxuICAgICAgdHJ1ZSxcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgY2xvc2VzdFBvaW50LFxuICAgICAgbWluU3F1YXJlZERpc3RhbmNlXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGFyZWEgb2YgdGhlIGxpbmVhciByaW5nIG9uIHByb2plY3RlZCBwbGFuZS5cbiAgICogQHJldHVybiB7bnVtYmVyfSBBcmVhIChvbiBwcm9qZWN0ZWQgcGxhbmUpLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRBcmVhKCkge1xuICAgIHJldHVybiBsaW5lYXJSaW5nQXJlYShcbiAgICAgIHRoaXMuZmxhdENvb3JkaW5hdGVzLFxuICAgICAgMCxcbiAgICAgIHRoaXMuZmxhdENvb3JkaW5hdGVzLmxlbmd0aCxcbiAgICAgIHRoaXMuc3RyaWRlXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBsaW5lYXIgcmluZy5cbiAgICogQHJldHVybiB7QXJyYXk8aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlPn0gQ29vcmRpbmF0ZXMuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldENvb3JkaW5hdGVzKCkge1xuICAgIHJldHVybiBpbmZsYXRlQ29vcmRpbmF0ZXMoXG4gICAgICB0aGlzLmZsYXRDb29yZGluYXRlcyxcbiAgICAgIDAsXG4gICAgICB0aGlzLmZsYXRDb29yZGluYXRlcy5sZW5ndGgsXG4gICAgICB0aGlzLnN0cmlkZVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNxdWFyZWRUb2xlcmFuY2UgU3F1YXJlZCB0b2xlcmFuY2UuXG4gICAqIEByZXR1cm4ge0xpbmVhclJpbmd9IFNpbXBsaWZpZWQgTGluZWFyUmluZy5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgZ2V0U2ltcGxpZmllZEdlb21ldHJ5SW50ZXJuYWwoc3F1YXJlZFRvbGVyYW5jZSkge1xuICAgIGNvbnN0IHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXMgPSBbXTtcbiAgICBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzLmxlbmd0aCA9IGRvdWdsYXNQZXVja2VyKFxuICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMsXG4gICAgICAwLFxuICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMubGVuZ3RoLFxuICAgICAgdGhpcy5zdHJpZGUsXG4gICAgICBzcXVhcmVkVG9sZXJhbmNlLFxuICAgICAgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcyxcbiAgICAgIDBcbiAgICApO1xuICAgIHJldHVybiBuZXcgTGluZWFyUmluZyhzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzLCAnWFknKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHR5cGUgb2YgdGhpcyBnZW9tZXRyeS5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi9HZW9tZXRyeS5qc1wiKS5UeXBlfSBHZW9tZXRyeSB0eXBlLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRUeXBlKCkge1xuICAgIHJldHVybiAnTGluZWFyUmluZyc7XG4gIH1cblxuICAvKipcbiAgICogVGVzdCBpZiB0aGUgZ2VvbWV0cnkgYW5kIHRoZSBwYXNzZWQgZXh0ZW50IGludGVyc2VjdC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBgdHJ1ZWAgaWYgdGhlIGdlb21ldHJ5IGFuZCB0aGUgZXh0ZW50IGludGVyc2VjdC5cbiAgICogQGFwaVxuICAgKi9cbiAgaW50ZXJzZWN0c0V4dGVudChleHRlbnQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBjb29yZGluYXRlcyBvZiB0aGUgbGluZWFyIHJpbmcuXG4gICAqIEBwYXJhbSB7IUFycmF5PGltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZT59IGNvb3JkaW5hdGVzIENvb3JkaW5hdGVzLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vR2VvbWV0cnkuanNcIikuR2VvbWV0cnlMYXlvdXR9IFtsYXlvdXRdIExheW91dC5cbiAgICogQGFwaVxuICAgKi9cbiAgc2V0Q29vcmRpbmF0ZXMoY29vcmRpbmF0ZXMsIGxheW91dCkge1xuICAgIHRoaXMuc2V0TGF5b3V0KGxheW91dCwgY29vcmRpbmF0ZXMsIDEpO1xuICAgIGlmICghdGhpcy5mbGF0Q29vcmRpbmF0ZXMpIHtcbiAgICAgIHRoaXMuZmxhdENvb3JkaW5hdGVzID0gW107XG4gICAgfVxuICAgIHRoaXMuZmxhdENvb3JkaW5hdGVzLmxlbmd0aCA9IGRlZmxhdGVDb29yZGluYXRlcyhcbiAgICAgIHRoaXMuZmxhdENvb3JkaW5hdGVzLFxuICAgICAgMCxcbiAgICAgIGNvb3JkaW5hdGVzLFxuICAgICAgdGhpcy5zdHJpZGVcbiAgICApO1xuICAgIHRoaXMuY2hhbmdlZCgpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IExpbmVhclJpbmc7XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvZ2VvbS9NdWx0aUxpbmVTdHJpbmdcbiAqL1xuaW1wb3J0IExpbmVTdHJpbmcgZnJvbSAnLi9MaW5lU3RyaW5nLmpzJztcbmltcG9ydCBTaW1wbGVHZW9tZXRyeSBmcm9tICcuL1NpbXBsZUdlb21ldHJ5LmpzJztcbmltcG9ydCB7YXJyYXlNYXhTcXVhcmVkRGVsdGEsIGFzc2lnbkNsb3Nlc3RBcnJheVBvaW50fSBmcm9tICcuL2ZsYXQvY2xvc2VzdC5qcyc7XG5pbXBvcnQge2Nsb3Nlc3RTcXVhcmVkRGlzdGFuY2VYWX0gZnJvbSAnLi4vZXh0ZW50LmpzJztcbmltcG9ydCB7ZGVmbGF0ZUNvb3JkaW5hdGVzQXJyYXl9IGZyb20gJy4vZmxhdC9kZWZsYXRlLmpzJztcbmltcG9ydCB7ZG91Z2xhc1BldWNrZXJBcnJheX0gZnJvbSAnLi9mbGF0L3NpbXBsaWZ5LmpzJztcbmltcG9ydCB7ZXh0ZW5kfSBmcm9tICcuLi9hcnJheS5qcyc7XG5pbXBvcnQge2luZmxhdGVDb29yZGluYXRlc0FycmF5fSBmcm9tICcuL2ZsYXQvaW5mbGF0ZS5qcyc7XG5pbXBvcnQge1xuICBpbnRlcnBvbGF0ZVBvaW50LFxuICBsaW5lU3RyaW5nc0Nvb3JkaW5hdGVBdE0sXG59IGZyb20gJy4vZmxhdC9pbnRlcnBvbGF0ZS5qcyc7XG5pbXBvcnQge2ludGVyc2VjdHNMaW5lU3RyaW5nQXJyYXl9IGZyb20gJy4vZmxhdC9pbnRlcnNlY3RzZXh0ZW50LmpzJztcblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBNdWx0aS1saW5lc3RyaW5nIGdlb21ldHJ5LlxuICpcbiAqIEBhcGlcbiAqL1xuY2xhc3MgTXVsdGlMaW5lU3RyaW5nIGV4dGVuZHMgU2ltcGxlR2VvbWV0cnkge1xuICAvKipcbiAgICogQHBhcmFtIHtBcnJheTxBcnJheTxpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGU+fExpbmVTdHJpbmc+fEFycmF5PG51bWJlcj59IGNvb3JkaW5hdGVzXG4gICAqICAgICBDb29yZGluYXRlcyBvciBMaW5lU3RyaW5nIGdlb21ldHJpZXMuIChGb3IgaW50ZXJuYWwgdXNlLCBmbGF0IGNvb3JkaW5hdGVzIGluXG4gICAqICAgICBjb21iaW5hdGlvbiB3aXRoIGBsYXlvdXRgIGFuZCBgZW5kc2AgYXJlIGFsc28gYWNjZXB0ZWQuKVxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vR2VvbWV0cnkuanNcIikuR2VvbWV0cnlMYXlvdXR9IFtsYXlvdXRdIExheW91dC5cbiAgICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBbZW5kc10gRmxhdCBjb29yZGluYXRlIGVuZHMgZm9yIGludGVybmFsIHVzZS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGNvb3JkaW5hdGVzLCBsYXlvdXQsIGVuZHMpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge0FycmF5PG51bWJlcj59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmVuZHNfID0gW107XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5tYXhEZWx0YV8gPSAtMTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLm1heERlbHRhUmV2aXNpb25fID0gLTE7XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShjb29yZGluYXRlc1swXSkpIHtcbiAgICAgIHRoaXMuc2V0Q29vcmRpbmF0ZXMoXG4gICAgICAgIC8qKiBAdHlwZSB7QXJyYXk8QXJyYXk8aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlPj59ICovIChcbiAgICAgICAgICBjb29yZGluYXRlc1xuICAgICAgICApLFxuICAgICAgICBsYXlvdXRcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmIChsYXlvdXQgIT09IHVuZGVmaW5lZCAmJiBlbmRzKSB7XG4gICAgICB0aGlzLnNldEZsYXRDb29yZGluYXRlcyhcbiAgICAgICAgbGF5b3V0LFxuICAgICAgICAvKiogQHR5cGUge0FycmF5PG51bWJlcj59ICovIChjb29yZGluYXRlcylcbiAgICAgICk7XG4gICAgICB0aGlzLmVuZHNfID0gZW5kcztcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGxheW91dCA9IHRoaXMuZ2V0TGF5b3V0KCk7XG4gICAgICBjb25zdCBsaW5lU3RyaW5ncyA9IC8qKiBAdHlwZSB7QXJyYXk8TGluZVN0cmluZz59ICovIChjb29yZGluYXRlcyk7XG4gICAgICBjb25zdCBmbGF0Q29vcmRpbmF0ZXMgPSBbXTtcbiAgICAgIGNvbnN0IGVuZHMgPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IGxpbmVTdHJpbmdzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgY29uc3QgbGluZVN0cmluZyA9IGxpbmVTdHJpbmdzW2ldO1xuICAgICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgIGxheW91dCA9IGxpbmVTdHJpbmcuZ2V0TGF5b3V0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZXh0ZW5kKGZsYXRDb29yZGluYXRlcywgbGluZVN0cmluZy5nZXRGbGF0Q29vcmRpbmF0ZXMoKSk7XG4gICAgICAgIGVuZHMucHVzaChmbGF0Q29vcmRpbmF0ZXMubGVuZ3RoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2V0RmxhdENvb3JkaW5hdGVzKGxheW91dCwgZmxhdENvb3JkaW5hdGVzKTtcbiAgICAgIHRoaXMuZW5kc18gPSBlbmRzO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBcHBlbmQgdGhlIHBhc3NlZCBsaW5lc3RyaW5nIHRvIHRoZSBtdWx0aWxpbmVzdHJpbmcuXG4gICAqIEBwYXJhbSB7TGluZVN0cmluZ30gbGluZVN0cmluZyBMaW5lU3RyaW5nLlxuICAgKiBAYXBpXG4gICAqL1xuICBhcHBlbmRMaW5lU3RyaW5nKGxpbmVTdHJpbmcpIHtcbiAgICBpZiAoIXRoaXMuZmxhdENvb3JkaW5hdGVzKSB7XG4gICAgICB0aGlzLmZsYXRDb29yZGluYXRlcyA9IGxpbmVTdHJpbmcuZ2V0RmxhdENvb3JkaW5hdGVzKCkuc2xpY2UoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXh0ZW5kKHRoaXMuZmxhdENvb3JkaW5hdGVzLCBsaW5lU3RyaW5nLmdldEZsYXRDb29yZGluYXRlcygpLnNsaWNlKCkpO1xuICAgIH1cbiAgICB0aGlzLmVuZHNfLnB1c2godGhpcy5mbGF0Q29vcmRpbmF0ZXMubGVuZ3RoKTtcbiAgICB0aGlzLmNoYW5nZWQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNYWtlIGEgY29tcGxldGUgY29weSBvZiB0aGUgZ2VvbWV0cnkuXG4gICAqIEByZXR1cm4geyFNdWx0aUxpbmVTdHJpbmd9IENsb25lLlxuICAgKiBAYXBpXG4gICAqL1xuICBjbG9uZSgpIHtcbiAgICBjb25zdCBtdWx0aUxpbmVTdHJpbmcgPSBuZXcgTXVsdGlMaW5lU3RyaW5nKFxuICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMuc2xpY2UoKSxcbiAgICAgIHRoaXMubGF5b3V0LFxuICAgICAgdGhpcy5lbmRzXy5zbGljZSgpXG4gICAgKTtcbiAgICBtdWx0aUxpbmVTdHJpbmcuYXBwbHlQcm9wZXJ0aWVzKHRoaXMpO1xuICAgIHJldHVybiBtdWx0aUxpbmVTdHJpbmc7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHggWC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHkgWS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGNsb3Nlc3RQb2ludCBDbG9zZXN0IHBvaW50LlxuICAgKiBAcGFyYW0ge251bWJlcn0gbWluU3F1YXJlZERpc3RhbmNlIE1pbmltdW0gc3F1YXJlZCBkaXN0YW5jZS5cbiAgICogQHJldHVybiB7bnVtYmVyfSBNaW5pbXVtIHNxdWFyZWQgZGlzdGFuY2UuXG4gICAqL1xuICBjbG9zZXN0UG9pbnRYWSh4LCB5LCBjbG9zZXN0UG9pbnQsIG1pblNxdWFyZWREaXN0YW5jZSkge1xuICAgIGlmIChtaW5TcXVhcmVkRGlzdGFuY2UgPCBjbG9zZXN0U3F1YXJlZERpc3RhbmNlWFkodGhpcy5nZXRFeHRlbnQoKSwgeCwgeSkpIHtcbiAgICAgIHJldHVybiBtaW5TcXVhcmVkRGlzdGFuY2U7XG4gICAgfVxuICAgIGlmICh0aGlzLm1heERlbHRhUmV2aXNpb25fICE9IHRoaXMuZ2V0UmV2aXNpb24oKSkge1xuICAgICAgdGhpcy5tYXhEZWx0YV8gPSBNYXRoLnNxcnQoXG4gICAgICAgIGFycmF5TWF4U3F1YXJlZERlbHRhKFxuICAgICAgICAgIHRoaXMuZmxhdENvb3JkaW5hdGVzLFxuICAgICAgICAgIDAsXG4gICAgICAgICAgdGhpcy5lbmRzXyxcbiAgICAgICAgICB0aGlzLnN0cmlkZSxcbiAgICAgICAgICAwXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgICB0aGlzLm1heERlbHRhUmV2aXNpb25fID0gdGhpcy5nZXRSZXZpc2lvbigpO1xuICAgIH1cbiAgICByZXR1cm4gYXNzaWduQ2xvc2VzdEFycmF5UG9pbnQoXG4gICAgICB0aGlzLmZsYXRDb29yZGluYXRlcyxcbiAgICAgIDAsXG4gICAgICB0aGlzLmVuZHNfLFxuICAgICAgdGhpcy5zdHJpZGUsXG4gICAgICB0aGlzLm1heERlbHRhXyxcbiAgICAgIGZhbHNlLFxuICAgICAgeCxcbiAgICAgIHksXG4gICAgICBjbG9zZXN0UG9pbnQsXG4gICAgICBtaW5TcXVhcmVkRGlzdGFuY2VcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGNvb3JkaW5hdGUgYXQgYG1gIHVzaW5nIGxpbmVhciBpbnRlcnBvbGF0aW9uLCBvciBgbnVsbGAgaWYgbm9cbiAgICogc3VjaCBjb29yZGluYXRlIGV4aXN0cy5cbiAgICpcbiAgICogYGV4dHJhcG9sYXRlYCBjb250cm9scyBleHRyYXBvbGF0aW9uIGJleW9uZCB0aGUgcmFuZ2Ugb2YgTXMgaW4gdGhlXG4gICAqIE11bHRpTGluZVN0cmluZy4gSWYgYGV4dHJhcG9sYXRlYCBpcyBgdHJ1ZWAgdGhlbiBNcyBsZXNzIHRoYW4gdGhlIGZpcnN0XG4gICAqIE0gd2lsbCByZXR1cm4gdGhlIGZpcnN0IGNvb3JkaW5hdGUgYW5kIE1zIGdyZWF0ZXIgdGhhbiB0aGUgbGFzdCBNIHdpbGxcbiAgICogcmV0dXJuIHRoZSBsYXN0IGNvb3JkaW5hdGUuXG4gICAqXG4gICAqIGBpbnRlcnBvbGF0ZWAgY29udHJvbHMgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIGNvbnNlY3V0aXZlIExpbmVTdHJpbmdzXG4gICAqIHdpdGhpbiB0aGUgTXVsdGlMaW5lU3RyaW5nLiBJZiBgaW50ZXJwb2xhdGVgIGlzIGB0cnVlYCB0aGUgY29vcmRpbmF0ZXNcbiAgICogd2lsbCBiZSBsaW5lYXJseSBpbnRlcnBvbGF0ZWQgYmV0d2VlbiB0aGUgbGFzdCBjb29yZGluYXRlIG9mIG9uZSBMaW5lU3RyaW5nXG4gICAqIGFuZCB0aGUgZmlyc3QgY29vcmRpbmF0ZSBvZiB0aGUgbmV4dCBMaW5lU3RyaW5nLiAgSWYgYGludGVycG9sYXRlYCBpc1xuICAgKiBgZmFsc2VgIHRoZW4gdGhlIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIGBudWxsYCBmb3IgTXMgZmFsbGluZyBiZXR3ZWVuXG4gICAqIExpbmVTdHJpbmdzLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gbSBNLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtleHRyYXBvbGF0ZV0gRXh0cmFwb2xhdGUuIERlZmF1bHQgaXMgYGZhbHNlYC5cbiAgICogQHBhcmFtIHtib29sZWFufSBbaW50ZXJwb2xhdGVdIEludGVycG9sYXRlLiBEZWZhdWx0IGlzIGBmYWxzZWAuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZXxudWxsfSBDb29yZGluYXRlLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRDb29yZGluYXRlQXRNKG0sIGV4dHJhcG9sYXRlLCBpbnRlcnBvbGF0ZSkge1xuICAgIGlmIChcbiAgICAgICh0aGlzLmxheW91dCAhPSAnWFlNJyAmJiB0aGlzLmxheW91dCAhPSAnWFlaTScpIHx8XG4gICAgICB0aGlzLmZsYXRDb29yZGluYXRlcy5sZW5ndGggPT09IDBcbiAgICApIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBleHRyYXBvbGF0ZSA9IGV4dHJhcG9sYXRlICE9PSB1bmRlZmluZWQgPyBleHRyYXBvbGF0ZSA6IGZhbHNlO1xuICAgIGludGVycG9sYXRlID0gaW50ZXJwb2xhdGUgIT09IHVuZGVmaW5lZCA/IGludGVycG9sYXRlIDogZmFsc2U7XG4gICAgcmV0dXJuIGxpbmVTdHJpbmdzQ29vcmRpbmF0ZUF0TShcbiAgICAgIHRoaXMuZmxhdENvb3JkaW5hdGVzLFxuICAgICAgMCxcbiAgICAgIHRoaXMuZW5kc18sXG4gICAgICB0aGlzLnN0cmlkZSxcbiAgICAgIG0sXG4gICAgICBleHRyYXBvbGF0ZSxcbiAgICAgIGludGVycG9sYXRlXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBtdWx0aWxpbmVzdHJpbmcuXG4gICAqIEByZXR1cm4ge0FycmF5PEFycmF5PGltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZT4+fSBDb29yZGluYXRlcy5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0Q29vcmRpbmF0ZXMoKSB7XG4gICAgcmV0dXJuIGluZmxhdGVDb29yZGluYXRlc0FycmF5KFxuICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMsXG4gICAgICAwLFxuICAgICAgdGhpcy5lbmRzXyxcbiAgICAgIHRoaXMuc3RyaWRlXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBFbmRzLlxuICAgKi9cbiAgZ2V0RW5kcygpIHtcbiAgICByZXR1cm4gdGhpcy5lbmRzXztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGxpbmVzdHJpbmcgYXQgdGhlIHNwZWNpZmllZCBpbmRleC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IEluZGV4LlxuICAgKiBAcmV0dXJuIHtMaW5lU3RyaW5nfSBMaW5lU3RyaW5nLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRMaW5lU3RyaW5nKGluZGV4KSB7XG4gICAgaWYgKGluZGV4IDwgMCB8fCB0aGlzLmVuZHNfLmxlbmd0aCA8PSBpbmRleCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBuZXcgTGluZVN0cmluZyhcbiAgICAgIHRoaXMuZmxhdENvb3JkaW5hdGVzLnNsaWNlKFxuICAgICAgICBpbmRleCA9PT0gMCA/IDAgOiB0aGlzLmVuZHNfW2luZGV4IC0gMV0sXG4gICAgICAgIHRoaXMuZW5kc19baW5kZXhdXG4gICAgICApLFxuICAgICAgdGhpcy5sYXlvdXRcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgbGluZXN0cmluZ3Mgb2YgdGhpcyBtdWx0aWxpbmVzdHJpbmcuXG4gICAqIEByZXR1cm4ge0FycmF5PExpbmVTdHJpbmc+fSBMaW5lU3RyaW5ncy5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0TGluZVN0cmluZ3MoKSB7XG4gICAgY29uc3QgZmxhdENvb3JkaW5hdGVzID0gdGhpcy5mbGF0Q29vcmRpbmF0ZXM7XG4gICAgY29uc3QgZW5kcyA9IHRoaXMuZW5kc187XG4gICAgY29uc3QgbGF5b3V0ID0gdGhpcy5sYXlvdXQ7XG4gICAgLyoqIEB0eXBlIHtBcnJheTxMaW5lU3RyaW5nPn0gKi9cbiAgICBjb25zdCBsaW5lU3RyaW5ncyA9IFtdO1xuICAgIGxldCBvZmZzZXQgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IGVuZHMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgY29uc3QgZW5kID0gZW5kc1tpXTtcbiAgICAgIGNvbnN0IGxpbmVTdHJpbmcgPSBuZXcgTGluZVN0cmluZyhcbiAgICAgICAgZmxhdENvb3JkaW5hdGVzLnNsaWNlKG9mZnNldCwgZW5kKSxcbiAgICAgICAgbGF5b3V0XG4gICAgICApO1xuICAgICAgbGluZVN0cmluZ3MucHVzaChsaW5lU3RyaW5nKTtcbiAgICAgIG9mZnNldCA9IGVuZDtcbiAgICB9XG4gICAgcmV0dXJuIGxpbmVTdHJpbmdzO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IEZsYXQgbWlkcG9pbnRzLlxuICAgKi9cbiAgZ2V0RmxhdE1pZHBvaW50cygpIHtcbiAgICBjb25zdCBtaWRwb2ludHMgPSBbXTtcbiAgICBjb25zdCBmbGF0Q29vcmRpbmF0ZXMgPSB0aGlzLmZsYXRDb29yZGluYXRlcztcbiAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICBjb25zdCBlbmRzID0gdGhpcy5lbmRzXztcbiAgICBjb25zdCBzdHJpZGUgPSB0aGlzLnN0cmlkZTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBlbmRzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgIGNvbnN0IGVuZCA9IGVuZHNbaV07XG4gICAgICBjb25zdCBtaWRwb2ludCA9IGludGVycG9sYXRlUG9pbnQoXG4gICAgICAgIGZsYXRDb29yZGluYXRlcyxcbiAgICAgICAgb2Zmc2V0LFxuICAgICAgICBlbmQsXG4gICAgICAgIHN0cmlkZSxcbiAgICAgICAgMC41XG4gICAgICApO1xuICAgICAgZXh0ZW5kKG1pZHBvaW50cywgbWlkcG9pbnQpO1xuICAgICAgb2Zmc2V0ID0gZW5kO1xuICAgIH1cbiAgICByZXR1cm4gbWlkcG9pbnRzO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzcXVhcmVkVG9sZXJhbmNlIFNxdWFyZWQgdG9sZXJhbmNlLlxuICAgKiBAcmV0dXJuIHtNdWx0aUxpbmVTdHJpbmd9IFNpbXBsaWZpZWQgTXVsdGlMaW5lU3RyaW5nLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBnZXRTaW1wbGlmaWVkR2VvbWV0cnlJbnRlcm5hbChzcXVhcmVkVG9sZXJhbmNlKSB7XG4gICAgY29uc3Qgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcyA9IFtdO1xuICAgIGNvbnN0IHNpbXBsaWZpZWRFbmRzID0gW107XG4gICAgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcy5sZW5ndGggPSBkb3VnbGFzUGV1Y2tlckFycmF5KFxuICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMsXG4gICAgICAwLFxuICAgICAgdGhpcy5lbmRzXyxcbiAgICAgIHRoaXMuc3RyaWRlLFxuICAgICAgc3F1YXJlZFRvbGVyYW5jZSxcbiAgICAgIHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXMsXG4gICAgICAwLFxuICAgICAgc2ltcGxpZmllZEVuZHNcbiAgICApO1xuICAgIHJldHVybiBuZXcgTXVsdGlMaW5lU3RyaW5nKHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXMsICdYWScsIHNpbXBsaWZpZWRFbmRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHR5cGUgb2YgdGhpcyBnZW9tZXRyeS5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi9HZW9tZXRyeS5qc1wiKS5UeXBlfSBHZW9tZXRyeSB0eXBlLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRUeXBlKCkge1xuICAgIHJldHVybiAnTXVsdGlMaW5lU3RyaW5nJztcbiAgfVxuXG4gIC8qKlxuICAgKiBUZXN0IGlmIHRoZSBnZW9tZXRyeSBhbmQgdGhlIHBhc3NlZCBleHRlbnQgaW50ZXJzZWN0LlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgZ2VvbWV0cnkgYW5kIHRoZSBleHRlbnQgaW50ZXJzZWN0LlxuICAgKiBAYXBpXG4gICAqL1xuICBpbnRlcnNlY3RzRXh0ZW50KGV4dGVudCkge1xuICAgIHJldHVybiBpbnRlcnNlY3RzTGluZVN0cmluZ0FycmF5KFxuICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMsXG4gICAgICAwLFxuICAgICAgdGhpcy5lbmRzXyxcbiAgICAgIHRoaXMuc3RyaWRlLFxuICAgICAgZXh0ZW50XG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBtdWx0aWxpbmVzdHJpbmcuXG4gICAqIEBwYXJhbSB7IUFycmF5PEFycmF5PGltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZT4+fSBjb29yZGluYXRlcyBDb29yZGluYXRlcy5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL0dlb21ldHJ5LmpzXCIpLkdlb21ldHJ5TGF5b3V0fSBbbGF5b3V0XSBMYXlvdXQuXG4gICAqIEBhcGlcbiAgICovXG4gIHNldENvb3JkaW5hdGVzKGNvb3JkaW5hdGVzLCBsYXlvdXQpIHtcbiAgICB0aGlzLnNldExheW91dChsYXlvdXQsIGNvb3JkaW5hdGVzLCAyKTtcbiAgICBpZiAoIXRoaXMuZmxhdENvb3JkaW5hdGVzKSB7XG4gICAgICB0aGlzLmZsYXRDb29yZGluYXRlcyA9IFtdO1xuICAgIH1cbiAgICBjb25zdCBlbmRzID0gZGVmbGF0ZUNvb3JkaW5hdGVzQXJyYXkoXG4gICAgICB0aGlzLmZsYXRDb29yZGluYXRlcyxcbiAgICAgIDAsXG4gICAgICBjb29yZGluYXRlcyxcbiAgICAgIHRoaXMuc3RyaWRlLFxuICAgICAgdGhpcy5lbmRzX1xuICAgICk7XG4gICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMubGVuZ3RoID0gZW5kcy5sZW5ndGggPT09IDAgPyAwIDogZW5kc1tlbmRzLmxlbmd0aCAtIDFdO1xuICAgIHRoaXMuY2hhbmdlZCgpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE11bHRpTGluZVN0cmluZztcbiIsIi8qKlxuICogQG1vZHVsZSBvbC9nZW9tL011bHRpUG9pbnRcbiAqL1xuaW1wb3J0IFBvaW50IGZyb20gJy4vUG9pbnQuanMnO1xuaW1wb3J0IFNpbXBsZUdlb21ldHJ5IGZyb20gJy4vU2ltcGxlR2VvbWV0cnkuanMnO1xuaW1wb3J0IHtjbG9zZXN0U3F1YXJlZERpc3RhbmNlWFksIGNvbnRhaW5zWFl9IGZyb20gJy4uL2V4dGVudC5qcyc7XG5pbXBvcnQge2RlZmxhdGVDb29yZGluYXRlc30gZnJvbSAnLi9mbGF0L2RlZmxhdGUuanMnO1xuaW1wb3J0IHtleHRlbmR9IGZyb20gJy4uL2FycmF5LmpzJztcbmltcG9ydCB7aW5mbGF0ZUNvb3JkaW5hdGVzfSBmcm9tICcuL2ZsYXQvaW5mbGF0ZS5qcyc7XG5pbXBvcnQge3NxdWFyZWREaXN0YW5jZSBhcyBzcXVhcmVkRHh9IGZyb20gJy4uL21hdGguanMnO1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIE11bHRpLXBvaW50IGdlb21ldHJ5LlxuICpcbiAqIEBhcGlcbiAqL1xuY2xhc3MgTXVsdGlQb2ludCBleHRlbmRzIFNpbXBsZUdlb21ldHJ5IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7QXJyYXk8aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlPnxBcnJheTxudW1iZXI+fSBjb29yZGluYXRlcyBDb29yZGluYXRlcy5cbiAgICogICAgIEZvciBpbnRlcm5hbCB1c2UsIGZsYXQgY29vcmRpbmF0ZXMgaW4gY29tYmluYXRpb24gd2l0aCBgbGF5b3V0YCBhcmUgYWxzbyBhY2NlcHRlZC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL0dlb21ldHJ5LmpzXCIpLkdlb21ldHJ5TGF5b3V0fSBbbGF5b3V0XSBMYXlvdXQuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihjb29yZGluYXRlcywgbGF5b3V0KSB7XG4gICAgc3VwZXIoKTtcbiAgICBpZiAobGF5b3V0ICYmICFBcnJheS5pc0FycmF5KGNvb3JkaW5hdGVzWzBdKSkge1xuICAgICAgdGhpcy5zZXRGbGF0Q29vcmRpbmF0ZXMoXG4gICAgICAgIGxheW91dCxcbiAgICAgICAgLyoqIEB0eXBlIHtBcnJheTxudW1iZXI+fSAqLyAoY29vcmRpbmF0ZXMpXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNldENvb3JkaW5hdGVzKFxuICAgICAgICAvKiogQHR5cGUge0FycmF5PGltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZT59ICovIChcbiAgICAgICAgICBjb29yZGluYXRlc1xuICAgICAgICApLFxuICAgICAgICBsYXlvdXRcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFwcGVuZCB0aGUgcGFzc2VkIHBvaW50IHRvIHRoaXMgbXVsdGlwb2ludC5cbiAgICogQHBhcmFtIHtQb2ludH0gcG9pbnQgUG9pbnQuXG4gICAqIEBhcGlcbiAgICovXG4gIGFwcGVuZFBvaW50KHBvaW50KSB7XG4gICAgaWYgKCF0aGlzLmZsYXRDb29yZGluYXRlcykge1xuICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMgPSBwb2ludC5nZXRGbGF0Q29vcmRpbmF0ZXMoKS5zbGljZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBleHRlbmQodGhpcy5mbGF0Q29vcmRpbmF0ZXMsIHBvaW50LmdldEZsYXRDb29yZGluYXRlcygpKTtcbiAgICB9XG4gICAgdGhpcy5jaGFuZ2VkKCk7XG4gIH1cblxuICAvKipcbiAgICogTWFrZSBhIGNvbXBsZXRlIGNvcHkgb2YgdGhlIGdlb21ldHJ5LlxuICAgKiBAcmV0dXJuIHshTXVsdGlQb2ludH0gQ2xvbmUuXG4gICAqIEBhcGlcbiAgICovXG4gIGNsb25lKCkge1xuICAgIGNvbnN0IG11bHRpUG9pbnQgPSBuZXcgTXVsdGlQb2ludChcbiAgICAgIHRoaXMuZmxhdENvb3JkaW5hdGVzLnNsaWNlKCksXG4gICAgICB0aGlzLmxheW91dFxuICAgICk7XG4gICAgbXVsdGlQb2ludC5hcHBseVByb3BlcnRpZXModGhpcyk7XG4gICAgcmV0dXJuIG11bHRpUG9pbnQ7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHggWC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHkgWS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGNsb3Nlc3RQb2ludCBDbG9zZXN0IHBvaW50LlxuICAgKiBAcGFyYW0ge251bWJlcn0gbWluU3F1YXJlZERpc3RhbmNlIE1pbmltdW0gc3F1YXJlZCBkaXN0YW5jZS5cbiAgICogQHJldHVybiB7bnVtYmVyfSBNaW5pbXVtIHNxdWFyZWQgZGlzdGFuY2UuXG4gICAqL1xuICBjbG9zZXN0UG9pbnRYWSh4LCB5LCBjbG9zZXN0UG9pbnQsIG1pblNxdWFyZWREaXN0YW5jZSkge1xuICAgIGlmIChtaW5TcXVhcmVkRGlzdGFuY2UgPCBjbG9zZXN0U3F1YXJlZERpc3RhbmNlWFkodGhpcy5nZXRFeHRlbnQoKSwgeCwgeSkpIHtcbiAgICAgIHJldHVybiBtaW5TcXVhcmVkRGlzdGFuY2U7XG4gICAgfVxuICAgIGNvbnN0IGZsYXRDb29yZGluYXRlcyA9IHRoaXMuZmxhdENvb3JkaW5hdGVzO1xuICAgIGNvbnN0IHN0cmlkZSA9IHRoaXMuc3RyaWRlO1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IGZsYXRDb29yZGluYXRlcy5sZW5ndGg7IGkgPCBpaTsgaSArPSBzdHJpZGUpIHtcbiAgICAgIGNvbnN0IHNxdWFyZWREaXN0YW5jZSA9IHNxdWFyZWREeChcbiAgICAgICAgeCxcbiAgICAgICAgeSxcbiAgICAgICAgZmxhdENvb3JkaW5hdGVzW2ldLFxuICAgICAgICBmbGF0Q29vcmRpbmF0ZXNbaSArIDFdXG4gICAgICApO1xuICAgICAgaWYgKHNxdWFyZWREaXN0YW5jZSA8IG1pblNxdWFyZWREaXN0YW5jZSkge1xuICAgICAgICBtaW5TcXVhcmVkRGlzdGFuY2UgPSBzcXVhcmVkRGlzdGFuY2U7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgc3RyaWRlOyArK2opIHtcbiAgICAgICAgICBjbG9zZXN0UG9pbnRbal0gPSBmbGF0Q29vcmRpbmF0ZXNbaSArIGpdO1xuICAgICAgICB9XG4gICAgICAgIGNsb3Nlc3RQb2ludC5sZW5ndGggPSBzdHJpZGU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtaW5TcXVhcmVkRGlzdGFuY2U7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBjb29yZGluYXRlcyBvZiB0aGUgbXVsdGlwb2ludC5cbiAgICogQHJldHVybiB7QXJyYXk8aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlPn0gQ29vcmRpbmF0ZXMuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldENvb3JkaW5hdGVzKCkge1xuICAgIHJldHVybiBpbmZsYXRlQ29vcmRpbmF0ZXMoXG4gICAgICB0aGlzLmZsYXRDb29yZGluYXRlcyxcbiAgICAgIDAsXG4gICAgICB0aGlzLmZsYXRDb29yZGluYXRlcy5sZW5ndGgsXG4gICAgICB0aGlzLnN0cmlkZVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBwb2ludCBhdCB0aGUgc3BlY2lmaWVkIGluZGV4LlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggSW5kZXguXG4gICAqIEByZXR1cm4ge1BvaW50fSBQb2ludC5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0UG9pbnQoaW5kZXgpIHtcbiAgICBjb25zdCBuID0gIXRoaXMuZmxhdENvb3JkaW5hdGVzXG4gICAgICA/IDBcbiAgICAgIDogdGhpcy5mbGF0Q29vcmRpbmF0ZXMubGVuZ3RoIC8gdGhpcy5zdHJpZGU7XG4gICAgaWYgKGluZGV4IDwgMCB8fCBuIDw9IGluZGV4KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBQb2ludChcbiAgICAgIHRoaXMuZmxhdENvb3JkaW5hdGVzLnNsaWNlKFxuICAgICAgICBpbmRleCAqIHRoaXMuc3RyaWRlLFxuICAgICAgICAoaW5kZXggKyAxKSAqIHRoaXMuc3RyaWRlXG4gICAgICApLFxuICAgICAgdGhpcy5sYXlvdXRcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgcG9pbnRzIG9mIHRoaXMgbXVsdGlwb2ludC5cbiAgICogQHJldHVybiB7QXJyYXk8UG9pbnQ+fSBQb2ludHMuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldFBvaW50cygpIHtcbiAgICBjb25zdCBmbGF0Q29vcmRpbmF0ZXMgPSB0aGlzLmZsYXRDb29yZGluYXRlcztcbiAgICBjb25zdCBsYXlvdXQgPSB0aGlzLmxheW91dDtcbiAgICBjb25zdCBzdHJpZGUgPSB0aGlzLnN0cmlkZTtcbiAgICAvKiogQHR5cGUge0FycmF5PFBvaW50Pn0gKi9cbiAgICBjb25zdCBwb2ludHMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBmbGF0Q29vcmRpbmF0ZXMubGVuZ3RoOyBpIDwgaWk7IGkgKz0gc3RyaWRlKSB7XG4gICAgICBjb25zdCBwb2ludCA9IG5ldyBQb2ludChmbGF0Q29vcmRpbmF0ZXMuc2xpY2UoaSwgaSArIHN0cmlkZSksIGxheW91dCk7XG4gICAgICBwb2ludHMucHVzaChwb2ludCk7XG4gICAgfVxuICAgIHJldHVybiBwb2ludHM7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB0eXBlIG9mIHRoaXMgZ2VvbWV0cnkuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4vR2VvbWV0cnkuanNcIikuVHlwZX0gR2VvbWV0cnkgdHlwZS5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0VHlwZSgpIHtcbiAgICByZXR1cm4gJ011bHRpUG9pbnQnO1xuICB9XG5cbiAgLyoqXG4gICAqIFRlc3QgaWYgdGhlIGdlb21ldHJ5IGFuZCB0aGUgcGFzc2VkIGV4dGVudCBpbnRlcnNlY3QuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSBnZW9tZXRyeSBhbmQgdGhlIGV4dGVudCBpbnRlcnNlY3QuXG4gICAqIEBhcGlcbiAgICovXG4gIGludGVyc2VjdHNFeHRlbnQoZXh0ZW50KSB7XG4gICAgY29uc3QgZmxhdENvb3JkaW5hdGVzID0gdGhpcy5mbGF0Q29vcmRpbmF0ZXM7XG4gICAgY29uc3Qgc3RyaWRlID0gdGhpcy5zdHJpZGU7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gZmxhdENvb3JkaW5hdGVzLmxlbmd0aDsgaSA8IGlpOyBpICs9IHN0cmlkZSkge1xuICAgICAgY29uc3QgeCA9IGZsYXRDb29yZGluYXRlc1tpXTtcbiAgICAgIGNvbnN0IHkgPSBmbGF0Q29vcmRpbmF0ZXNbaSArIDFdO1xuICAgICAgaWYgKGNvbnRhaW5zWFkoZXh0ZW50LCB4LCB5KSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgY29vcmRpbmF0ZXMgb2YgdGhlIG11bHRpcG9pbnQuXG4gICAqIEBwYXJhbSB7IUFycmF5PGltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZT59IGNvb3JkaW5hdGVzIENvb3JkaW5hdGVzLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vR2VvbWV0cnkuanNcIikuR2VvbWV0cnlMYXlvdXR9IFtsYXlvdXRdIExheW91dC5cbiAgICogQGFwaVxuICAgKi9cbiAgc2V0Q29vcmRpbmF0ZXMoY29vcmRpbmF0ZXMsIGxheW91dCkge1xuICAgIHRoaXMuc2V0TGF5b3V0KGxheW91dCwgY29vcmRpbmF0ZXMsIDEpO1xuICAgIGlmICghdGhpcy5mbGF0Q29vcmRpbmF0ZXMpIHtcbiAgICAgIHRoaXMuZmxhdENvb3JkaW5hdGVzID0gW107XG4gICAgfVxuICAgIHRoaXMuZmxhdENvb3JkaW5hdGVzLmxlbmd0aCA9IGRlZmxhdGVDb29yZGluYXRlcyhcbiAgICAgIHRoaXMuZmxhdENvb3JkaW5hdGVzLFxuICAgICAgMCxcbiAgICAgIGNvb3JkaW5hdGVzLFxuICAgICAgdGhpcy5zdHJpZGVcbiAgICApO1xuICAgIHRoaXMuY2hhbmdlZCgpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE11bHRpUG9pbnQ7XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvZ2VvbS9NdWx0aVBvbHlnb25cbiAqL1xuaW1wb3J0IE11bHRpUG9pbnQgZnJvbSAnLi9NdWx0aVBvaW50LmpzJztcbmltcG9ydCBQb2x5Z29uIGZyb20gJy4vUG9seWdvbi5qcyc7XG5pbXBvcnQgU2ltcGxlR2VvbWV0cnkgZnJvbSAnLi9TaW1wbGVHZW9tZXRyeS5qcyc7XG5pbXBvcnQge1xuICBhc3NpZ25DbG9zZXN0TXVsdGlBcnJheVBvaW50LFxuICBtdWx0aUFycmF5TWF4U3F1YXJlZERlbHRhLFxufSBmcm9tICcuL2ZsYXQvY2xvc2VzdC5qcyc7XG5pbXBvcnQge2Nsb3Nlc3RTcXVhcmVkRGlzdGFuY2VYWX0gZnJvbSAnLi4vZXh0ZW50LmpzJztcbmltcG9ydCB7ZGVmbGF0ZU11bHRpQ29vcmRpbmF0ZXNBcnJheX0gZnJvbSAnLi9mbGF0L2RlZmxhdGUuanMnO1xuaW1wb3J0IHtleHRlbmR9IGZyb20gJy4uL2FycmF5LmpzJztcbmltcG9ydCB7Z2V0SW50ZXJpb3JQb2ludHNPZk11bHRpQXJyYXl9IGZyb20gJy4vZmxhdC9pbnRlcmlvcnBvaW50LmpzJztcbmltcG9ydCB7aW5mbGF0ZU11bHRpQ29vcmRpbmF0ZXNBcnJheX0gZnJvbSAnLi9mbGF0L2luZmxhdGUuanMnO1xuaW1wb3J0IHtpbnRlcnNlY3RzTGluZWFyUmluZ011bHRpQXJyYXl9IGZyb20gJy4vZmxhdC9pbnRlcnNlY3RzZXh0ZW50LmpzJztcbmltcG9ydCB7XG4gIGxpbmVhclJpbmdzc0FyZU9yaWVudGVkLFxuICBvcmllbnRMaW5lYXJSaW5nc0FycmF5LFxufSBmcm9tICcuL2ZsYXQvb3JpZW50LmpzJztcbmltcG9ydCB7bGluZWFyUmluZ3NzIGFzIGxpbmVhclJpbmdzc0FyZWF9IGZyb20gJy4vZmxhdC9hcmVhLmpzJztcbmltcG9ydCB7bGluZWFyUmluZ3NzIGFzIGxpbmVhclJpbmdzc0NlbnRlcn0gZnJvbSAnLi9mbGF0L2NlbnRlci5qcyc7XG5pbXBvcnQge2xpbmVhclJpbmdzc0NvbnRhaW5zWFl9IGZyb20gJy4vZmxhdC9jb250YWlucy5qcyc7XG5pbXBvcnQge3F1YW50aXplTXVsdGlBcnJheX0gZnJvbSAnLi9mbGF0L3NpbXBsaWZ5LmpzJztcblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBNdWx0aS1wb2x5Z29uIGdlb21ldHJ5LlxuICpcbiAqIEBhcGlcbiAqL1xuY2xhc3MgTXVsdGlQb2x5Z29uIGV4dGVuZHMgU2ltcGxlR2VvbWV0cnkge1xuICAvKipcbiAgICogQHBhcmFtIHtBcnJheTxBcnJheTxBcnJheTxpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGU+PnxQb2x5Z29uPnxBcnJheTxudW1iZXI+fSBjb29yZGluYXRlcyBDb29yZGluYXRlcy5cbiAgICogICAgIEZvciBpbnRlcm5hbCB1c2UsIGZsYXQgY29vcmRpbmF0ZXMgaW4gY29tYmluYXRpb24gd2l0aCBgbGF5b3V0YCBhbmQgYGVuZHNzYCBhcmUgYWxzbyBhY2NlcHRlZC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL0dlb21ldHJ5LmpzXCIpLkdlb21ldHJ5TGF5b3V0fSBbbGF5b3V0XSBMYXlvdXQuXG4gICAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8bnVtYmVyPj59IFtlbmRzc10gQXJyYXkgb2YgZW5kcyBmb3IgaW50ZXJuYWwgdXNlIHdpdGggZmxhdCBjb29yZGluYXRlcy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGNvb3JkaW5hdGVzLCBsYXlvdXQsIGVuZHNzKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtBcnJheTxBcnJheTxudW1iZXI+Pn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuZW5kc3NfID0gW107XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5mbGF0SW50ZXJpb3JQb2ludHNSZXZpc2lvbl8gPSAtMTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0FycmF5PG51bWJlcj59XG4gICAgICovXG4gICAgdGhpcy5mbGF0SW50ZXJpb3JQb2ludHNfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLm1heERlbHRhXyA9IC0xO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubWF4RGVsdGFSZXZpc2lvbl8gPSAtMTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLm9yaWVudGVkUmV2aXNpb25fID0gLTE7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtBcnJheTxudW1iZXI+fVxuICAgICAqL1xuICAgIHRoaXMub3JpZW50ZWRGbGF0Q29vcmRpbmF0ZXNfID0gbnVsbDtcblxuICAgIGlmICghZW5kc3MgJiYgIUFycmF5LmlzQXJyYXkoY29vcmRpbmF0ZXNbMF0pKSB7XG4gICAgICBsZXQgdGhpc0xheW91dCA9IHRoaXMuZ2V0TGF5b3V0KCk7XG4gICAgICBjb25zdCBwb2x5Z29ucyA9IC8qKiBAdHlwZSB7QXJyYXk8UG9seWdvbj59ICovIChjb29yZGluYXRlcyk7XG4gICAgICBjb25zdCBmbGF0Q29vcmRpbmF0ZXMgPSBbXTtcbiAgICAgIGNvbnN0IHRoaXNFbmRzcyA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gcG9seWdvbnMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICBjb25zdCBwb2x5Z29uID0gcG9seWdvbnNbaV07XG4gICAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgdGhpc0xheW91dCA9IHBvbHlnb24uZ2V0TGF5b3V0KCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gZmxhdENvb3JkaW5hdGVzLmxlbmd0aDtcbiAgICAgICAgY29uc3QgZW5kcyA9IHBvbHlnb24uZ2V0RW5kcygpO1xuICAgICAgICBmb3IgKGxldCBqID0gMCwgamogPSBlbmRzLmxlbmd0aDsgaiA8IGpqOyArK2opIHtcbiAgICAgICAgICBlbmRzW2pdICs9IG9mZnNldDtcbiAgICAgICAgfVxuICAgICAgICBleHRlbmQoZmxhdENvb3JkaW5hdGVzLCBwb2x5Z29uLmdldEZsYXRDb29yZGluYXRlcygpKTtcbiAgICAgICAgdGhpc0VuZHNzLnB1c2goZW5kcyk7XG4gICAgICB9XG4gICAgICBsYXlvdXQgPSB0aGlzTGF5b3V0O1xuICAgICAgY29vcmRpbmF0ZXMgPSBmbGF0Q29vcmRpbmF0ZXM7XG4gICAgICBlbmRzcyA9IHRoaXNFbmRzcztcbiAgICB9XG4gICAgaWYgKGxheW91dCAhPT0gdW5kZWZpbmVkICYmIGVuZHNzKSB7XG4gICAgICB0aGlzLnNldEZsYXRDb29yZGluYXRlcyhcbiAgICAgICAgbGF5b3V0LFxuICAgICAgICAvKiogQHR5cGUge0FycmF5PG51bWJlcj59ICovIChjb29yZGluYXRlcylcbiAgICAgICk7XG4gICAgICB0aGlzLmVuZHNzXyA9IGVuZHNzO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNldENvb3JkaW5hdGVzKFxuICAgICAgICAvKiogQHR5cGUge0FycmF5PEFycmF5PEFycmF5PGltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZT4+Pn0gKi8gKFxuICAgICAgICAgIGNvb3JkaW5hdGVzXG4gICAgICAgICksXG4gICAgICAgIGxheW91dFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQXBwZW5kIHRoZSBwYXNzZWQgcG9seWdvbiB0byB0aGlzIG11bHRpcG9seWdvbi5cbiAgICogQHBhcmFtIHtQb2x5Z29ufSBwb2x5Z29uIFBvbHlnb24uXG4gICAqIEBhcGlcbiAgICovXG4gIGFwcGVuZFBvbHlnb24ocG9seWdvbikge1xuICAgIC8qKiBAdHlwZSB7QXJyYXk8bnVtYmVyPn0gKi9cbiAgICBsZXQgZW5kcztcbiAgICBpZiAoIXRoaXMuZmxhdENvb3JkaW5hdGVzKSB7XG4gICAgICB0aGlzLmZsYXRDb29yZGluYXRlcyA9IHBvbHlnb24uZ2V0RmxhdENvb3JkaW5hdGVzKCkuc2xpY2UoKTtcbiAgICAgIGVuZHMgPSBwb2x5Z29uLmdldEVuZHMoKS5zbGljZSgpO1xuICAgICAgdGhpcy5lbmRzc18ucHVzaCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBvZmZzZXQgPSB0aGlzLmZsYXRDb29yZGluYXRlcy5sZW5ndGg7XG4gICAgICBleHRlbmQodGhpcy5mbGF0Q29vcmRpbmF0ZXMsIHBvbHlnb24uZ2V0RmxhdENvb3JkaW5hdGVzKCkpO1xuICAgICAgZW5kcyA9IHBvbHlnb24uZ2V0RW5kcygpLnNsaWNlKCk7XG4gICAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBlbmRzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgZW5kc1tpXSArPSBvZmZzZXQ7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuZW5kc3NfLnB1c2goZW5kcyk7XG4gICAgdGhpcy5jaGFuZ2VkKCk7XG4gIH1cblxuICAvKipcbiAgICogTWFrZSBhIGNvbXBsZXRlIGNvcHkgb2YgdGhlIGdlb21ldHJ5LlxuICAgKiBAcmV0dXJuIHshTXVsdGlQb2x5Z29ufSBDbG9uZS5cbiAgICogQGFwaVxuICAgKi9cbiAgY2xvbmUoKSB7XG4gICAgY29uc3QgbGVuID0gdGhpcy5lbmRzc18ubGVuZ3RoO1xuICAgIGNvbnN0IG5ld0VuZHNzID0gbmV3IEFycmF5KGxlbik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgbmV3RW5kc3NbaV0gPSB0aGlzLmVuZHNzX1tpXS5zbGljZSgpO1xuICAgIH1cblxuICAgIGNvbnN0IG11bHRpUG9seWdvbiA9IG5ldyBNdWx0aVBvbHlnb24oXG4gICAgICB0aGlzLmZsYXRDb29yZGluYXRlcy5zbGljZSgpLFxuICAgICAgdGhpcy5sYXlvdXQsXG4gICAgICBuZXdFbmRzc1xuICAgICk7XG4gICAgbXVsdGlQb2x5Z29uLmFwcGx5UHJvcGVydGllcyh0aGlzKTtcblxuICAgIHJldHVybiBtdWx0aVBvbHlnb247XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHggWC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHkgWS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGNsb3Nlc3RQb2ludCBDbG9zZXN0IHBvaW50LlxuICAgKiBAcGFyYW0ge251bWJlcn0gbWluU3F1YXJlZERpc3RhbmNlIE1pbmltdW0gc3F1YXJlZCBkaXN0YW5jZS5cbiAgICogQHJldHVybiB7bnVtYmVyfSBNaW5pbXVtIHNxdWFyZWQgZGlzdGFuY2UuXG4gICAqL1xuICBjbG9zZXN0UG9pbnRYWSh4LCB5LCBjbG9zZXN0UG9pbnQsIG1pblNxdWFyZWREaXN0YW5jZSkge1xuICAgIGlmIChtaW5TcXVhcmVkRGlzdGFuY2UgPCBjbG9zZXN0U3F1YXJlZERpc3RhbmNlWFkodGhpcy5nZXRFeHRlbnQoKSwgeCwgeSkpIHtcbiAgICAgIHJldHVybiBtaW5TcXVhcmVkRGlzdGFuY2U7XG4gICAgfVxuICAgIGlmICh0aGlzLm1heERlbHRhUmV2aXNpb25fICE9IHRoaXMuZ2V0UmV2aXNpb24oKSkge1xuICAgICAgdGhpcy5tYXhEZWx0YV8gPSBNYXRoLnNxcnQoXG4gICAgICAgIG11bHRpQXJyYXlNYXhTcXVhcmVkRGVsdGEoXG4gICAgICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMsXG4gICAgICAgICAgMCxcbiAgICAgICAgICB0aGlzLmVuZHNzXyxcbiAgICAgICAgICB0aGlzLnN0cmlkZSxcbiAgICAgICAgICAwXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgICB0aGlzLm1heERlbHRhUmV2aXNpb25fID0gdGhpcy5nZXRSZXZpc2lvbigpO1xuICAgIH1cbiAgICByZXR1cm4gYXNzaWduQ2xvc2VzdE11bHRpQXJyYXlQb2ludChcbiAgICAgIHRoaXMuZ2V0T3JpZW50ZWRGbGF0Q29vcmRpbmF0ZXMoKSxcbiAgICAgIDAsXG4gICAgICB0aGlzLmVuZHNzXyxcbiAgICAgIHRoaXMuc3RyaWRlLFxuICAgICAgdGhpcy5tYXhEZWx0YV8sXG4gICAgICB0cnVlLFxuICAgICAgeCxcbiAgICAgIHksXG4gICAgICBjbG9zZXN0UG9pbnQsXG4gICAgICBtaW5TcXVhcmVkRGlzdGFuY2VcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4IFguXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5IFkuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IENvbnRhaW5zICh4LCB5KS5cbiAgICovXG4gIGNvbnRhaW5zWFkoeCwgeSkge1xuICAgIHJldHVybiBsaW5lYXJSaW5nc3NDb250YWluc1hZKFxuICAgICAgdGhpcy5nZXRPcmllbnRlZEZsYXRDb29yZGluYXRlcygpLFxuICAgICAgMCxcbiAgICAgIHRoaXMuZW5kc3NfLFxuICAgICAgdGhpcy5zdHJpZGUsXG4gICAgICB4LFxuICAgICAgeVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBhcmVhIG9mIHRoZSBtdWx0aXBvbHlnb24gb24gcHJvamVjdGVkIHBsYW5lLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IEFyZWEgKG9uIHByb2plY3RlZCBwbGFuZSkuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldEFyZWEoKSB7XG4gICAgcmV0dXJuIGxpbmVhclJpbmdzc0FyZWEoXG4gICAgICB0aGlzLmdldE9yaWVudGVkRmxhdENvb3JkaW5hdGVzKCksXG4gICAgICAwLFxuICAgICAgdGhpcy5lbmRzc18sXG4gICAgICB0aGlzLnN0cmlkZVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBjb29yZGluYXRlIGFycmF5IGZvciB0aGlzIGdlb21ldHJ5LiAgVGhpcyBhcnJheSBoYXMgdGhlIHN0cnVjdHVyZVxuICAgKiBvZiBhIEdlb0pTT04gY29vcmRpbmF0ZSBhcnJheSBmb3IgbXVsdGktcG9seWdvbnMuXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JpZ2h0XSBPcmllbnQgY29vcmRpbmF0ZXMgYWNjb3JkaW5nIHRvIHRoZSByaWdodC1oYW5kXG4gICAqICAgICBydWxlIChjb3VudGVyLWNsb2Nrd2lzZSBmb3IgZXh0ZXJpb3IgYW5kIGNsb2Nrd2lzZSBmb3IgaW50ZXJpb3IgcmluZ3MpLlxuICAgKiAgICAgSWYgYGZhbHNlYCwgY29vcmRpbmF0ZXMgd2lsbCBiZSBvcmllbnRlZCBhY2NvcmRpbmcgdG8gdGhlIGxlZnQtaGFuZCBydWxlXG4gICAqICAgICAoY2xvY2t3aXNlIGZvciBleHRlcmlvciBhbmQgY291bnRlci1jbG9ja3dpc2UgZm9yIGludGVyaW9yIHJpbmdzKS5cbiAgICogICAgIEJ5IGRlZmF1bHQsIGNvb3JkaW5hdGUgb3JpZW50YXRpb24gd2lsbCBkZXBlbmQgb24gaG93IHRoZSBnZW9tZXRyeSB3YXNcbiAgICogICAgIGNvbnN0cnVjdGVkLlxuICAgKiBAcmV0dXJuIHtBcnJheTxBcnJheTxBcnJheTxpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGU+Pj59IENvb3JkaW5hdGVzLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRDb29yZGluYXRlcyhyaWdodCkge1xuICAgIGxldCBmbGF0Q29vcmRpbmF0ZXM7XG4gICAgaWYgKHJpZ2h0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGZsYXRDb29yZGluYXRlcyA9IHRoaXMuZ2V0T3JpZW50ZWRGbGF0Q29vcmRpbmF0ZXMoKS5zbGljZSgpO1xuICAgICAgb3JpZW50TGluZWFyUmluZ3NBcnJheShcbiAgICAgICAgZmxhdENvb3JkaW5hdGVzLFxuICAgICAgICAwLFxuICAgICAgICB0aGlzLmVuZHNzXyxcbiAgICAgICAgdGhpcy5zdHJpZGUsXG4gICAgICAgIHJpZ2h0XG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBmbGF0Q29vcmRpbmF0ZXMgPSB0aGlzLmZsYXRDb29yZGluYXRlcztcbiAgICB9XG5cbiAgICByZXR1cm4gaW5mbGF0ZU11bHRpQ29vcmRpbmF0ZXNBcnJheShcbiAgICAgIGZsYXRDb29yZGluYXRlcyxcbiAgICAgIDAsXG4gICAgICB0aGlzLmVuZHNzXyxcbiAgICAgIHRoaXMuc3RyaWRlXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtBcnJheTxBcnJheTxudW1iZXI+Pn0gRW5kc3MuXG4gICAqL1xuICBnZXRFbmRzcygpIHtcbiAgICByZXR1cm4gdGhpcy5lbmRzc187XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gRmxhdCBpbnRlcmlvciBwb2ludHMuXG4gICAqL1xuICBnZXRGbGF0SW50ZXJpb3JQb2ludHMoKSB7XG4gICAgaWYgKHRoaXMuZmxhdEludGVyaW9yUG9pbnRzUmV2aXNpb25fICE9IHRoaXMuZ2V0UmV2aXNpb24oKSkge1xuICAgICAgY29uc3QgZmxhdENlbnRlcnMgPSBsaW5lYXJSaW5nc3NDZW50ZXIoXG4gICAgICAgIHRoaXMuZmxhdENvb3JkaW5hdGVzLFxuICAgICAgICAwLFxuICAgICAgICB0aGlzLmVuZHNzXyxcbiAgICAgICAgdGhpcy5zdHJpZGVcbiAgICAgICk7XG4gICAgICB0aGlzLmZsYXRJbnRlcmlvclBvaW50c18gPSBnZXRJbnRlcmlvclBvaW50c09mTXVsdGlBcnJheShcbiAgICAgICAgdGhpcy5nZXRPcmllbnRlZEZsYXRDb29yZGluYXRlcygpLFxuICAgICAgICAwLFxuICAgICAgICB0aGlzLmVuZHNzXyxcbiAgICAgICAgdGhpcy5zdHJpZGUsXG4gICAgICAgIGZsYXRDZW50ZXJzXG4gICAgICApO1xuICAgICAgdGhpcy5mbGF0SW50ZXJpb3JQb2ludHNSZXZpc2lvbl8gPSB0aGlzLmdldFJldmlzaW9uKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZsYXRJbnRlcmlvclBvaW50c187XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBpbnRlcmlvciBwb2ludHMgYXMge0BsaW5rIG1vZHVsZTpvbC9nZW9tL011bHRpUG9pbnR+TXVsdGlQb2ludCBtdWx0aXBvaW50fS5cbiAgICogQHJldHVybiB7TXVsdGlQb2ludH0gSW50ZXJpb3IgcG9pbnRzIGFzIFhZTSBjb29yZGluYXRlcywgd2hlcmUgTSBpc1xuICAgKiB0aGUgbGVuZ3RoIG9mIHRoZSBob3Jpem9udGFsIGludGVyc2VjdGlvbiB0aGF0IHRoZSBwb2ludCBiZWxvbmdzIHRvLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRJbnRlcmlvclBvaW50cygpIHtcbiAgICByZXR1cm4gbmV3IE11bHRpUG9pbnQodGhpcy5nZXRGbGF0SW50ZXJpb3JQb2ludHMoKS5zbGljZSgpLCAnWFlNJyk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gT3JpZW50ZWQgZmxhdCBjb29yZGluYXRlcy5cbiAgICovXG4gIGdldE9yaWVudGVkRmxhdENvb3JkaW5hdGVzKCkge1xuICAgIGlmICh0aGlzLm9yaWVudGVkUmV2aXNpb25fICE9IHRoaXMuZ2V0UmV2aXNpb24oKSkge1xuICAgICAgY29uc3QgZmxhdENvb3JkaW5hdGVzID0gdGhpcy5mbGF0Q29vcmRpbmF0ZXM7XG4gICAgICBpZiAoXG4gICAgICAgIGxpbmVhclJpbmdzc0FyZU9yaWVudGVkKGZsYXRDb29yZGluYXRlcywgMCwgdGhpcy5lbmRzc18sIHRoaXMuc3RyaWRlKVxuICAgICAgKSB7XG4gICAgICAgIHRoaXMub3JpZW50ZWRGbGF0Q29vcmRpbmF0ZXNfID0gZmxhdENvb3JkaW5hdGVzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5vcmllbnRlZEZsYXRDb29yZGluYXRlc18gPSBmbGF0Q29vcmRpbmF0ZXMuc2xpY2UoKTtcbiAgICAgICAgdGhpcy5vcmllbnRlZEZsYXRDb29yZGluYXRlc18ubGVuZ3RoID0gb3JpZW50TGluZWFyUmluZ3NBcnJheShcbiAgICAgICAgICB0aGlzLm9yaWVudGVkRmxhdENvb3JkaW5hdGVzXyxcbiAgICAgICAgICAwLFxuICAgICAgICAgIHRoaXMuZW5kc3NfLFxuICAgICAgICAgIHRoaXMuc3RyaWRlXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICB0aGlzLm9yaWVudGVkUmV2aXNpb25fID0gdGhpcy5nZXRSZXZpc2lvbigpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5vcmllbnRlZEZsYXRDb29yZGluYXRlc187XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNxdWFyZWRUb2xlcmFuY2UgU3F1YXJlZCB0b2xlcmFuY2UuXG4gICAqIEByZXR1cm4ge011bHRpUG9seWdvbn0gU2ltcGxpZmllZCBNdWx0aVBvbHlnb24uXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIGdldFNpbXBsaWZpZWRHZW9tZXRyeUludGVybmFsKHNxdWFyZWRUb2xlcmFuY2UpIHtcbiAgICBjb25zdCBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzID0gW107XG4gICAgY29uc3Qgc2ltcGxpZmllZEVuZHNzID0gW107XG4gICAgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcy5sZW5ndGggPSBxdWFudGl6ZU11bHRpQXJyYXkoXG4gICAgICB0aGlzLmZsYXRDb29yZGluYXRlcyxcbiAgICAgIDAsXG4gICAgICB0aGlzLmVuZHNzXyxcbiAgICAgIHRoaXMuc3RyaWRlLFxuICAgICAgTWF0aC5zcXJ0KHNxdWFyZWRUb2xlcmFuY2UpLFxuICAgICAgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcyxcbiAgICAgIDAsXG4gICAgICBzaW1wbGlmaWVkRW5kc3NcbiAgICApO1xuICAgIHJldHVybiBuZXcgTXVsdGlQb2x5Z29uKHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXMsICdYWScsIHNpbXBsaWZpZWRFbmRzcyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBwb2x5Z29uIGF0IHRoZSBzcGVjaWZpZWQgaW5kZXguXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBJbmRleC5cbiAgICogQHJldHVybiB7UG9seWdvbn0gUG9seWdvbi5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0UG9seWdvbihpbmRleCkge1xuICAgIGlmIChpbmRleCA8IDAgfHwgdGhpcy5lbmRzc18ubGVuZ3RoIDw9IGluZGV4KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgbGV0IG9mZnNldDtcbiAgICBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgIG9mZnNldCA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHByZXZFbmRzID0gdGhpcy5lbmRzc19baW5kZXggLSAxXTtcbiAgICAgIG9mZnNldCA9IHByZXZFbmRzW3ByZXZFbmRzLmxlbmd0aCAtIDFdO1xuICAgIH1cbiAgICBjb25zdCBlbmRzID0gdGhpcy5lbmRzc19baW5kZXhdLnNsaWNlKCk7XG4gICAgY29uc3QgZW5kID0gZW5kc1tlbmRzLmxlbmd0aCAtIDFdO1xuICAgIGlmIChvZmZzZXQgIT09IDApIHtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IGVuZHMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICBlbmRzW2ldIC09IG9mZnNldDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBQb2x5Z29uKFxuICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMuc2xpY2Uob2Zmc2V0LCBlbmQpLFxuICAgICAgdGhpcy5sYXlvdXQsXG4gICAgICBlbmRzXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIHBvbHlnb25zIG9mIHRoaXMgbXVsdGlwb2x5Z29uLlxuICAgKiBAcmV0dXJuIHtBcnJheTxQb2x5Z29uPn0gUG9seWdvbnMuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldFBvbHlnb25zKCkge1xuICAgIGNvbnN0IGxheW91dCA9IHRoaXMubGF5b3V0O1xuICAgIGNvbnN0IGZsYXRDb29yZGluYXRlcyA9IHRoaXMuZmxhdENvb3JkaW5hdGVzO1xuICAgIGNvbnN0IGVuZHNzID0gdGhpcy5lbmRzc187XG4gICAgY29uc3QgcG9seWdvbnMgPSBbXTtcbiAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBlbmRzcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICBjb25zdCBlbmRzID0gZW5kc3NbaV0uc2xpY2UoKTtcbiAgICAgIGNvbnN0IGVuZCA9IGVuZHNbZW5kcy5sZW5ndGggLSAxXTtcbiAgICAgIGlmIChvZmZzZXQgIT09IDApIHtcbiAgICAgICAgZm9yIChsZXQgaiA9IDAsIGpqID0gZW5kcy5sZW5ndGg7IGogPCBqajsgKytqKSB7XG4gICAgICAgICAgZW5kc1tqXSAtPSBvZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IHBvbHlnb24gPSBuZXcgUG9seWdvbihcbiAgICAgICAgZmxhdENvb3JkaW5hdGVzLnNsaWNlKG9mZnNldCwgZW5kKSxcbiAgICAgICAgbGF5b3V0LFxuICAgICAgICBlbmRzXG4gICAgICApO1xuICAgICAgcG9seWdvbnMucHVzaChwb2x5Z29uKTtcbiAgICAgIG9mZnNldCA9IGVuZDtcbiAgICB9XG4gICAgcmV0dXJuIHBvbHlnb25zO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdHlwZSBvZiB0aGlzIGdlb21ldHJ5LlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuL0dlb21ldHJ5LmpzXCIpLlR5cGV9IEdlb21ldHJ5IHR5cGUuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldFR5cGUoKSB7XG4gICAgcmV0dXJuICdNdWx0aVBvbHlnb24nO1xuICB9XG5cbiAgLyoqXG4gICAqIFRlc3QgaWYgdGhlIGdlb21ldHJ5IGFuZCB0aGUgcGFzc2VkIGV4dGVudCBpbnRlcnNlY3QuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSBnZW9tZXRyeSBhbmQgdGhlIGV4dGVudCBpbnRlcnNlY3QuXG4gICAqIEBhcGlcbiAgICovXG4gIGludGVyc2VjdHNFeHRlbnQoZXh0ZW50KSB7XG4gICAgcmV0dXJuIGludGVyc2VjdHNMaW5lYXJSaW5nTXVsdGlBcnJheShcbiAgICAgIHRoaXMuZ2V0T3JpZW50ZWRGbGF0Q29vcmRpbmF0ZXMoKSxcbiAgICAgIDAsXG4gICAgICB0aGlzLmVuZHNzXyxcbiAgICAgIHRoaXMuc3RyaWRlLFxuICAgICAgZXh0ZW50XG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBtdWx0aXBvbHlnb24uXG4gICAqIEBwYXJhbSB7IUFycmF5PEFycmF5PEFycmF5PGltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZT4+Pn0gY29vcmRpbmF0ZXMgQ29vcmRpbmF0ZXMuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9HZW9tZXRyeS5qc1wiKS5HZW9tZXRyeUxheW91dH0gW2xheW91dF0gTGF5b3V0LlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRDb29yZGluYXRlcyhjb29yZGluYXRlcywgbGF5b3V0KSB7XG4gICAgdGhpcy5zZXRMYXlvdXQobGF5b3V0LCBjb29yZGluYXRlcywgMyk7XG4gICAgaWYgKCF0aGlzLmZsYXRDb29yZGluYXRlcykge1xuICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMgPSBbXTtcbiAgICB9XG4gICAgY29uc3QgZW5kc3MgPSBkZWZsYXRlTXVsdGlDb29yZGluYXRlc0FycmF5KFxuICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMsXG4gICAgICAwLFxuICAgICAgY29vcmRpbmF0ZXMsXG4gICAgICB0aGlzLnN0cmlkZSxcbiAgICAgIHRoaXMuZW5kc3NfXG4gICAgKTtcbiAgICBpZiAoZW5kc3MubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aGlzLmZsYXRDb29yZGluYXRlcy5sZW5ndGggPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBsYXN0RW5kcyA9IGVuZHNzW2VuZHNzLmxlbmd0aCAtIDFdO1xuICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMubGVuZ3RoID1cbiAgICAgICAgbGFzdEVuZHMubGVuZ3RoID09PSAwID8gMCA6IGxhc3RFbmRzW2xhc3RFbmRzLmxlbmd0aCAtIDFdO1xuICAgIH1cbiAgICB0aGlzLmNoYW5nZWQoKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBNdWx0aVBvbHlnb247XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvZ2VvbS9Qb2ludFxuICovXG5pbXBvcnQgU2ltcGxlR2VvbWV0cnkgZnJvbSAnLi9TaW1wbGVHZW9tZXRyeS5qcyc7XG5pbXBvcnQge2NvbnRhaW5zWFksIGNyZWF0ZU9yVXBkYXRlRnJvbUNvb3JkaW5hdGV9IGZyb20gJy4uL2V4dGVudC5qcyc7XG5pbXBvcnQge2RlZmxhdGVDb29yZGluYXRlfSBmcm9tICcuL2ZsYXQvZGVmbGF0ZS5qcyc7XG5pbXBvcnQge3NxdWFyZWREaXN0YW5jZSBhcyBzcXVhcmVkRHh9IGZyb20gJy4uL21hdGguanMnO1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIFBvaW50IGdlb21ldHJ5LlxuICpcbiAqIEBhcGlcbiAqL1xuY2xhc3MgUG9pbnQgZXh0ZW5kcyBTaW1wbGVHZW9tZXRyeSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gY29vcmRpbmF0ZXMgQ29vcmRpbmF0ZXMuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9HZW9tZXRyeS5qc1wiKS5HZW9tZXRyeUxheW91dH0gW2xheW91dF0gTGF5b3V0LlxuICAgKi9cbiAgY29uc3RydWN0b3IoY29vcmRpbmF0ZXMsIGxheW91dCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5zZXRDb29yZGluYXRlcyhjb29yZGluYXRlcywgbGF5b3V0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNYWtlIGEgY29tcGxldGUgY29weSBvZiB0aGUgZ2VvbWV0cnkuXG4gICAqIEByZXR1cm4geyFQb2ludH0gQ2xvbmUuXG4gICAqIEBhcGlcbiAgICovXG4gIGNsb25lKCkge1xuICAgIGNvbnN0IHBvaW50ID0gbmV3IFBvaW50KHRoaXMuZmxhdENvb3JkaW5hdGVzLnNsaWNlKCksIHRoaXMubGF5b3V0KTtcbiAgICBwb2ludC5hcHBseVByb3BlcnRpZXModGhpcyk7XG4gICAgcmV0dXJuIHBvaW50O1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4IFguXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5IFkuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBjbG9zZXN0UG9pbnQgQ2xvc2VzdCBwb2ludC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG1pblNxdWFyZWREaXN0YW5jZSBNaW5pbXVtIHNxdWFyZWQgZGlzdGFuY2UuXG4gICAqIEByZXR1cm4ge251bWJlcn0gTWluaW11bSBzcXVhcmVkIGRpc3RhbmNlLlxuICAgKi9cbiAgY2xvc2VzdFBvaW50WFkoeCwgeSwgY2xvc2VzdFBvaW50LCBtaW5TcXVhcmVkRGlzdGFuY2UpIHtcbiAgICBjb25zdCBmbGF0Q29vcmRpbmF0ZXMgPSB0aGlzLmZsYXRDb29yZGluYXRlcztcbiAgICBjb25zdCBzcXVhcmVkRGlzdGFuY2UgPSBzcXVhcmVkRHgoXG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIGZsYXRDb29yZGluYXRlc1swXSxcbiAgICAgIGZsYXRDb29yZGluYXRlc1sxXVxuICAgICk7XG4gICAgaWYgKHNxdWFyZWREaXN0YW5jZSA8IG1pblNxdWFyZWREaXN0YW5jZSkge1xuICAgICAgY29uc3Qgc3RyaWRlID0gdGhpcy5zdHJpZGU7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0cmlkZTsgKytpKSB7XG4gICAgICAgIGNsb3Nlc3RQb2ludFtpXSA9IGZsYXRDb29yZGluYXRlc1tpXTtcbiAgICAgIH1cbiAgICAgIGNsb3Nlc3RQb2ludC5sZW5ndGggPSBzdHJpZGU7XG4gICAgICByZXR1cm4gc3F1YXJlZERpc3RhbmNlO1xuICAgIH1cbiAgICByZXR1cm4gbWluU3F1YXJlZERpc3RhbmNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gQ29vcmRpbmF0ZXMuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldENvb3JkaW5hdGVzKCkge1xuICAgIHJldHVybiAhdGhpcy5mbGF0Q29vcmRpbmF0ZXMgPyBbXSA6IHRoaXMuZmxhdENvb3JkaW5hdGVzLnNsaWNlKCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gICAqL1xuICBjb21wdXRlRXh0ZW50KGV4dGVudCkge1xuICAgIHJldHVybiBjcmVhdGVPclVwZGF0ZUZyb21Db29yZGluYXRlKHRoaXMuZmxhdENvb3JkaW5hdGVzLCBleHRlbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdHlwZSBvZiB0aGlzIGdlb21ldHJ5LlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuL0dlb21ldHJ5LmpzXCIpLlR5cGV9IEdlb21ldHJ5IHR5cGUuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldFR5cGUoKSB7XG4gICAgcmV0dXJuICdQb2ludCc7XG4gIH1cblxuICAvKipcbiAgICogVGVzdCBpZiB0aGUgZ2VvbWV0cnkgYW5kIHRoZSBwYXNzZWQgZXh0ZW50IGludGVyc2VjdC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBgdHJ1ZWAgaWYgdGhlIGdlb21ldHJ5IGFuZCB0aGUgZXh0ZW50IGludGVyc2VjdC5cbiAgICogQGFwaVxuICAgKi9cbiAgaW50ZXJzZWN0c0V4dGVudChleHRlbnQpIHtcbiAgICByZXR1cm4gY29udGFpbnNYWShleHRlbnQsIHRoaXMuZmxhdENvb3JkaW5hdGVzWzBdLCB0aGlzLmZsYXRDb29yZGluYXRlc1sxXSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHshQXJyYXk8Kj59IGNvb3JkaW5hdGVzIENvb3JkaW5hdGVzLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vR2VvbWV0cnkuanNcIikuR2VvbWV0cnlMYXlvdXR9IFtsYXlvdXRdIExheW91dC5cbiAgICogQGFwaVxuICAgKi9cbiAgc2V0Q29vcmRpbmF0ZXMoY29vcmRpbmF0ZXMsIGxheW91dCkge1xuICAgIHRoaXMuc2V0TGF5b3V0KGxheW91dCwgY29vcmRpbmF0ZXMsIDApO1xuICAgIGlmICghdGhpcy5mbGF0Q29vcmRpbmF0ZXMpIHtcbiAgICAgIHRoaXMuZmxhdENvb3JkaW5hdGVzID0gW107XG4gICAgfVxuICAgIHRoaXMuZmxhdENvb3JkaW5hdGVzLmxlbmd0aCA9IGRlZmxhdGVDb29yZGluYXRlKFxuICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMsXG4gICAgICAwLFxuICAgICAgY29vcmRpbmF0ZXMsXG4gICAgICB0aGlzLnN0cmlkZVxuICAgICk7XG4gICAgdGhpcy5jaGFuZ2VkKCk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgUG9pbnQ7XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvZ2VvbS9Qb2x5Z29uXG4gKi9cbmltcG9ydCBMaW5lYXJSaW5nIGZyb20gJy4vTGluZWFyUmluZy5qcyc7XG5pbXBvcnQgUG9pbnQgZnJvbSAnLi9Qb2ludC5qcyc7XG5pbXBvcnQgU2ltcGxlR2VvbWV0cnkgZnJvbSAnLi9TaW1wbGVHZW9tZXRyeS5qcyc7XG5pbXBvcnQge2FycmF5TWF4U3F1YXJlZERlbHRhLCBhc3NpZ25DbG9zZXN0QXJyYXlQb2ludH0gZnJvbSAnLi9mbGF0L2Nsb3Nlc3QuanMnO1xuaW1wb3J0IHtjbG9zZXN0U3F1YXJlZERpc3RhbmNlWFksIGdldENlbnRlciwgaXNFbXB0eX0gZnJvbSAnLi4vZXh0ZW50LmpzJztcbmltcG9ydCB7ZGVmbGF0ZUNvb3JkaW5hdGVzQXJyYXl9IGZyb20gJy4vZmxhdC9kZWZsYXRlLmpzJztcbmltcG9ydCB7ZXh0ZW5kfSBmcm9tICcuLi9hcnJheS5qcyc7XG5pbXBvcnQge2dldEludGVyaW9yUG9pbnRPZkFycmF5fSBmcm9tICcuL2ZsYXQvaW50ZXJpb3Jwb2ludC5qcyc7XG5pbXBvcnQge2luZmxhdGVDb29yZGluYXRlc0FycmF5fSBmcm9tICcuL2ZsYXQvaW5mbGF0ZS5qcyc7XG5pbXBvcnQge2ludGVyc2VjdHNMaW5lYXJSaW5nQXJyYXl9IGZyb20gJy4vZmxhdC9pbnRlcnNlY3RzZXh0ZW50LmpzJztcbmltcG9ydCB7bGluZWFyUmluZ3NBcmVPcmllbnRlZCwgb3JpZW50TGluZWFyUmluZ3N9IGZyb20gJy4vZmxhdC9vcmllbnQuanMnO1xuaW1wb3J0IHtsaW5lYXJSaW5ncyBhcyBsaW5lYXJSaW5nc0FyZWF9IGZyb20gJy4vZmxhdC9hcmVhLmpzJztcbmltcG9ydCB7bGluZWFyUmluZ3NDb250YWluc1hZfSBmcm9tICcuL2ZsYXQvY29udGFpbnMuanMnO1xuaW1wb3J0IHttb2R1bG99IGZyb20gJy4uL21hdGguanMnO1xuaW1wb3J0IHtxdWFudGl6ZUFycmF5fSBmcm9tICcuL2ZsYXQvc2ltcGxpZnkuanMnO1xuaW1wb3J0IHtvZmZzZXQgYXMgc3BoZXJlT2Zmc2V0fSBmcm9tICcuLi9zcGhlcmUuanMnO1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIFBvbHlnb24gZ2VvbWV0cnkuXG4gKlxuICogQGFwaVxuICovXG5jbGFzcyBQb2x5Z29uIGV4dGVuZHMgU2ltcGxlR2VvbWV0cnkge1xuICAvKipcbiAgICogQHBhcmFtIHshQXJyYXk8QXJyYXk8aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlPj58IUFycmF5PG51bWJlcj59IGNvb3JkaW5hdGVzXG4gICAqICAgICBBcnJheSBvZiBsaW5lYXIgcmluZ3MgdGhhdCBkZWZpbmUgdGhlIHBvbHlnb24uIFRoZSBmaXJzdCBsaW5lYXIgcmluZyBvZiB0aGVcbiAgICogICAgIGFycmF5IGRlZmluZXMgdGhlIG91dGVyLWJvdW5kYXJ5IG9yIHN1cmZhY2Ugb2YgdGhlIHBvbHlnb24uIEVhY2ggc3Vic2VxdWVudFxuICAgKiAgICAgbGluZWFyIHJpbmcgZGVmaW5lcyBhIGhvbGUgaW4gdGhlIHN1cmZhY2Ugb2YgdGhlIHBvbHlnb24uIEEgbGluZWFyIHJpbmcgaXNcbiAgICogICAgIGFuIGFycmF5IG9mIHZlcnRpY2VzJyBjb29yZGluYXRlcyB3aGVyZSB0aGUgZmlyc3QgY29vcmRpbmF0ZSBhbmQgdGhlIGxhc3QgYXJlXG4gICAqICAgICBlcXVpdmFsZW50LiAoRm9yIGludGVybmFsIHVzZSwgZmxhdCBjb29yZGluYXRlcyBpbiBjb21iaW5hdGlvbiB3aXRoXG4gICAqICAgICBgbGF5b3V0YCBhbmQgYGVuZHNgIGFyZSBhbHNvIGFjY2VwdGVkLilcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL0dlb21ldHJ5LmpzXCIpLkdlb21ldHJ5TGF5b3V0fSBbbGF5b3V0XSBMYXlvdXQuXG4gICAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gW2VuZHNdIEVuZHMgKGZvciBpbnRlcm5hbCB1c2Ugd2l0aCBmbGF0IGNvb3JkaW5hdGVzKS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGNvb3JkaW5hdGVzLCBsYXlvdXQsIGVuZHMpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge0FycmF5PG51bWJlcj59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmVuZHNfID0gW107XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5mbGF0SW50ZXJpb3JQb2ludFJldmlzaW9uXyA9IC0xO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfVxuICAgICAqL1xuICAgIHRoaXMuZmxhdEludGVyaW9yUG9pbnRfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLm1heERlbHRhXyA9IC0xO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubWF4RGVsdGFSZXZpc2lvbl8gPSAtMTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLm9yaWVudGVkUmV2aXNpb25fID0gLTE7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtBcnJheTxudW1iZXI+fVxuICAgICAqL1xuICAgIHRoaXMub3JpZW50ZWRGbGF0Q29vcmRpbmF0ZXNfID0gbnVsbDtcblxuICAgIGlmIChsYXlvdXQgIT09IHVuZGVmaW5lZCAmJiBlbmRzKSB7XG4gICAgICB0aGlzLnNldEZsYXRDb29yZGluYXRlcyhcbiAgICAgICAgbGF5b3V0LFxuICAgICAgICAvKiogQHR5cGUge0FycmF5PG51bWJlcj59ICovIChjb29yZGluYXRlcylcbiAgICAgICk7XG4gICAgICB0aGlzLmVuZHNfID0gZW5kcztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZXRDb29yZGluYXRlcyhcbiAgICAgICAgLyoqIEB0eXBlIHtBcnJheTxBcnJheTxpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGU+Pn0gKi8gKFxuICAgICAgICAgIGNvb3JkaW5hdGVzXG4gICAgICAgICksXG4gICAgICAgIGxheW91dFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQXBwZW5kIHRoZSBwYXNzZWQgbGluZWFyIHJpbmcgdG8gdGhpcyBwb2x5Z29uLlxuICAgKiBAcGFyYW0ge0xpbmVhclJpbmd9IGxpbmVhclJpbmcgTGluZWFyIHJpbmcuXG4gICAqIEBhcGlcbiAgICovXG4gIGFwcGVuZExpbmVhclJpbmcobGluZWFyUmluZykge1xuICAgIGlmICghdGhpcy5mbGF0Q29vcmRpbmF0ZXMpIHtcbiAgICAgIHRoaXMuZmxhdENvb3JkaW5hdGVzID0gbGluZWFyUmluZy5nZXRGbGF0Q29vcmRpbmF0ZXMoKS5zbGljZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBleHRlbmQodGhpcy5mbGF0Q29vcmRpbmF0ZXMsIGxpbmVhclJpbmcuZ2V0RmxhdENvb3JkaW5hdGVzKCkpO1xuICAgIH1cbiAgICB0aGlzLmVuZHNfLnB1c2godGhpcy5mbGF0Q29vcmRpbmF0ZXMubGVuZ3RoKTtcbiAgICB0aGlzLmNoYW5nZWQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNYWtlIGEgY29tcGxldGUgY29weSBvZiB0aGUgZ2VvbWV0cnkuXG4gICAqIEByZXR1cm4geyFQb2x5Z29ufSBDbG9uZS5cbiAgICogQGFwaVxuICAgKi9cbiAgY2xvbmUoKSB7XG4gICAgY29uc3QgcG9seWdvbiA9IG5ldyBQb2x5Z29uKFxuICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMuc2xpY2UoKSxcbiAgICAgIHRoaXMubGF5b3V0LFxuICAgICAgdGhpcy5lbmRzXy5zbGljZSgpXG4gICAgKTtcbiAgICBwb2x5Z29uLmFwcGx5UHJvcGVydGllcyh0aGlzKTtcbiAgICByZXR1cm4gcG9seWdvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0geCBYLlxuICAgKiBAcGFyYW0ge251bWJlcn0geSBZLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gY2xvc2VzdFBvaW50IENsb3Nlc3QgcG9pbnQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtaW5TcXVhcmVkRGlzdGFuY2UgTWluaW11bSBzcXVhcmVkIGRpc3RhbmNlLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IE1pbmltdW0gc3F1YXJlZCBkaXN0YW5jZS5cbiAgICovXG4gIGNsb3Nlc3RQb2ludFhZKHgsIHksIGNsb3Nlc3RQb2ludCwgbWluU3F1YXJlZERpc3RhbmNlKSB7XG4gICAgaWYgKG1pblNxdWFyZWREaXN0YW5jZSA8IGNsb3Nlc3RTcXVhcmVkRGlzdGFuY2VYWSh0aGlzLmdldEV4dGVudCgpLCB4LCB5KSkge1xuICAgICAgcmV0dXJuIG1pblNxdWFyZWREaXN0YW5jZTtcbiAgICB9XG4gICAgaWYgKHRoaXMubWF4RGVsdGFSZXZpc2lvbl8gIT0gdGhpcy5nZXRSZXZpc2lvbigpKSB7XG4gICAgICB0aGlzLm1heERlbHRhXyA9IE1hdGguc3FydChcbiAgICAgICAgYXJyYXlNYXhTcXVhcmVkRGVsdGEoXG4gICAgICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMsXG4gICAgICAgICAgMCxcbiAgICAgICAgICB0aGlzLmVuZHNfLFxuICAgICAgICAgIHRoaXMuc3RyaWRlLFxuICAgICAgICAgIDBcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICAgIHRoaXMubWF4RGVsdGFSZXZpc2lvbl8gPSB0aGlzLmdldFJldmlzaW9uKCk7XG4gICAgfVxuICAgIHJldHVybiBhc3NpZ25DbG9zZXN0QXJyYXlQb2ludChcbiAgICAgIHRoaXMuZmxhdENvb3JkaW5hdGVzLFxuICAgICAgMCxcbiAgICAgIHRoaXMuZW5kc18sXG4gICAgICB0aGlzLnN0cmlkZSxcbiAgICAgIHRoaXMubWF4RGVsdGFfLFxuICAgICAgdHJ1ZSxcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgY2xvc2VzdFBvaW50LFxuICAgICAgbWluU3F1YXJlZERpc3RhbmNlXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0geCBYLlxuICAgKiBAcGFyYW0ge251bWJlcn0geSBZLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBDb250YWlucyAoeCwgeSkuXG4gICAqL1xuICBjb250YWluc1hZKHgsIHkpIHtcbiAgICByZXR1cm4gbGluZWFyUmluZ3NDb250YWluc1hZKFxuICAgICAgdGhpcy5nZXRPcmllbnRlZEZsYXRDb29yZGluYXRlcygpLFxuICAgICAgMCxcbiAgICAgIHRoaXMuZW5kc18sXG4gICAgICB0aGlzLnN0cmlkZSxcbiAgICAgIHgsXG4gICAgICB5XG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGFyZWEgb2YgdGhlIHBvbHlnb24gb24gcHJvamVjdGVkIHBsYW5lLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IEFyZWEgKG9uIHByb2plY3RlZCBwbGFuZSkuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldEFyZWEoKSB7XG4gICAgcmV0dXJuIGxpbmVhclJpbmdzQXJlYShcbiAgICAgIHRoaXMuZ2V0T3JpZW50ZWRGbGF0Q29vcmRpbmF0ZXMoKSxcbiAgICAgIDAsXG4gICAgICB0aGlzLmVuZHNfLFxuICAgICAgdGhpcy5zdHJpZGVcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgY29vcmRpbmF0ZSBhcnJheSBmb3IgdGhpcyBnZW9tZXRyeS4gIFRoaXMgYXJyYXkgaGFzIHRoZSBzdHJ1Y3R1cmVcbiAgICogb2YgYSBHZW9KU09OIGNvb3JkaW5hdGUgYXJyYXkgZm9yIHBvbHlnb25zLlxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtyaWdodF0gT3JpZW50IGNvb3JkaW5hdGVzIGFjY29yZGluZyB0byB0aGUgcmlnaHQtaGFuZFxuICAgKiAgICAgcnVsZSAoY291bnRlci1jbG9ja3dpc2UgZm9yIGV4dGVyaW9yIGFuZCBjbG9ja3dpc2UgZm9yIGludGVyaW9yIHJpbmdzKS5cbiAgICogICAgIElmIGBmYWxzZWAsIGNvb3JkaW5hdGVzIHdpbGwgYmUgb3JpZW50ZWQgYWNjb3JkaW5nIHRvIHRoZSBsZWZ0LWhhbmQgcnVsZVxuICAgKiAgICAgKGNsb2Nrd2lzZSBmb3IgZXh0ZXJpb3IgYW5kIGNvdW50ZXItY2xvY2t3aXNlIGZvciBpbnRlcmlvciByaW5ncykuXG4gICAqICAgICBCeSBkZWZhdWx0LCBjb29yZGluYXRlIG9yaWVudGF0aW9uIHdpbGwgZGVwZW5kIG9uIGhvdyB0aGUgZ2VvbWV0cnkgd2FzXG4gICAqICAgICBjb25zdHJ1Y3RlZC5cbiAgICogQHJldHVybiB7QXJyYXk8QXJyYXk8aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlPj59IENvb3JkaW5hdGVzLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRDb29yZGluYXRlcyhyaWdodCkge1xuICAgIGxldCBmbGF0Q29vcmRpbmF0ZXM7XG4gICAgaWYgKHJpZ2h0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGZsYXRDb29yZGluYXRlcyA9IHRoaXMuZ2V0T3JpZW50ZWRGbGF0Q29vcmRpbmF0ZXMoKS5zbGljZSgpO1xuICAgICAgb3JpZW50TGluZWFyUmluZ3MoZmxhdENvb3JkaW5hdGVzLCAwLCB0aGlzLmVuZHNfLCB0aGlzLnN0cmlkZSwgcmlnaHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmbGF0Q29vcmRpbmF0ZXMgPSB0aGlzLmZsYXRDb29yZGluYXRlcztcbiAgICB9XG5cbiAgICByZXR1cm4gaW5mbGF0ZUNvb3JkaW5hdGVzQXJyYXkoZmxhdENvb3JkaW5hdGVzLCAwLCB0aGlzLmVuZHNfLCB0aGlzLnN0cmlkZSk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gRW5kcy5cbiAgICovXG4gIGdldEVuZHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZW5kc187XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gSW50ZXJpb3IgcG9pbnQuXG4gICAqL1xuICBnZXRGbGF0SW50ZXJpb3JQb2ludCgpIHtcbiAgICBpZiAodGhpcy5mbGF0SW50ZXJpb3JQb2ludFJldmlzaW9uXyAhPSB0aGlzLmdldFJldmlzaW9uKCkpIHtcbiAgICAgIGNvbnN0IGZsYXRDZW50ZXIgPSBnZXRDZW50ZXIodGhpcy5nZXRFeHRlbnQoKSk7XG4gICAgICB0aGlzLmZsYXRJbnRlcmlvclBvaW50XyA9IGdldEludGVyaW9yUG9pbnRPZkFycmF5KFxuICAgICAgICB0aGlzLmdldE9yaWVudGVkRmxhdENvb3JkaW5hdGVzKCksXG4gICAgICAgIDAsXG4gICAgICAgIHRoaXMuZW5kc18sXG4gICAgICAgIHRoaXMuc3RyaWRlLFxuICAgICAgICBmbGF0Q2VudGVyLFxuICAgICAgICAwXG4gICAgICApO1xuICAgICAgdGhpcy5mbGF0SW50ZXJpb3JQb2ludFJldmlzaW9uXyA9IHRoaXMuZ2V0UmV2aXNpb24oKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZmxhdEludGVyaW9yUG9pbnRfO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhbiBpbnRlcmlvciBwb2ludCBvZiB0aGUgcG9seWdvbi5cbiAgICogQHJldHVybiB7UG9pbnR9IEludGVyaW9yIHBvaW50IGFzIFhZTSBjb29yZGluYXRlLCB3aGVyZSBNIGlzIHRoZVxuICAgKiBsZW5ndGggb2YgdGhlIGhvcml6b250YWwgaW50ZXJzZWN0aW9uIHRoYXQgdGhlIHBvaW50IGJlbG9uZ3MgdG8uXG4gICAqIEBhcGlcbiAgICovXG4gIGdldEludGVyaW9yUG9pbnQoKSB7XG4gICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLmdldEZsYXRJbnRlcmlvclBvaW50KCksICdYWU0nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIG51bWJlciBvZiByaW5ncyBvZiB0aGUgcG9seWdvbiwgIHRoaXMgaW5jbHVkZXMgdGhlIGV4dGVyaW9yXG4gICAqIHJpbmcgYW5kIGFueSBpbnRlcmlvciByaW5ncy5cbiAgICpcbiAgICogQHJldHVybiB7bnVtYmVyfSBOdW1iZXIgb2YgcmluZ3MuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldExpbmVhclJpbmdDb3VudCgpIHtcbiAgICByZXR1cm4gdGhpcy5lbmRzXy5sZW5ndGg7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBOdGggbGluZWFyIHJpbmcgb2YgdGhlIHBvbHlnb24gZ2VvbWV0cnkuIFJldHVybiBgbnVsbGAgaWYgdGhlXG4gICAqIGdpdmVuIGluZGV4IGlzIG91dCBvZiByYW5nZS5cbiAgICogVGhlIGV4dGVyaW9yIGxpbmVhciByaW5nIGlzIGF2YWlsYWJsZSBhdCBpbmRleCBgMGAgYW5kIHRoZSBpbnRlcmlvciByaW5nc1xuICAgKiBhdCBpbmRleCBgMWAgYW5kIGJleW9uZC5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IEluZGV4LlxuICAgKiBAcmV0dXJuIHtMaW5lYXJSaW5nfG51bGx9IExpbmVhciByaW5nLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRMaW5lYXJSaW5nKGluZGV4KSB7XG4gICAgaWYgKGluZGV4IDwgMCB8fCB0aGlzLmVuZHNfLmxlbmd0aCA8PSBpbmRleCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBuZXcgTGluZWFyUmluZyhcbiAgICAgIHRoaXMuZmxhdENvb3JkaW5hdGVzLnNsaWNlKFxuICAgICAgICBpbmRleCA9PT0gMCA/IDAgOiB0aGlzLmVuZHNfW2luZGV4IC0gMV0sXG4gICAgICAgIHRoaXMuZW5kc19baW5kZXhdXG4gICAgICApLFxuICAgICAgdGhpcy5sYXlvdXRcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgbGluZWFyIHJpbmdzIG9mIHRoZSBwb2x5Z29uLlxuICAgKiBAcmV0dXJuIHtBcnJheTxMaW5lYXJSaW5nPn0gTGluZWFyIHJpbmdzLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRMaW5lYXJSaW5ncygpIHtcbiAgICBjb25zdCBsYXlvdXQgPSB0aGlzLmxheW91dDtcbiAgICBjb25zdCBmbGF0Q29vcmRpbmF0ZXMgPSB0aGlzLmZsYXRDb29yZGluYXRlcztcbiAgICBjb25zdCBlbmRzID0gdGhpcy5lbmRzXztcbiAgICBjb25zdCBsaW5lYXJSaW5ncyA9IFtdO1xuICAgIGxldCBvZmZzZXQgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IGVuZHMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgY29uc3QgZW5kID0gZW5kc1tpXTtcbiAgICAgIGNvbnN0IGxpbmVhclJpbmcgPSBuZXcgTGluZWFyUmluZyhcbiAgICAgICAgZmxhdENvb3JkaW5hdGVzLnNsaWNlKG9mZnNldCwgZW5kKSxcbiAgICAgICAgbGF5b3V0XG4gICAgICApO1xuICAgICAgbGluZWFyUmluZ3MucHVzaChsaW5lYXJSaW5nKTtcbiAgICAgIG9mZnNldCA9IGVuZDtcbiAgICB9XG4gICAgcmV0dXJuIGxpbmVhclJpbmdzO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IE9yaWVudGVkIGZsYXQgY29vcmRpbmF0ZXMuXG4gICAqL1xuICBnZXRPcmllbnRlZEZsYXRDb29yZGluYXRlcygpIHtcbiAgICBpZiAodGhpcy5vcmllbnRlZFJldmlzaW9uXyAhPSB0aGlzLmdldFJldmlzaW9uKCkpIHtcbiAgICAgIGNvbnN0IGZsYXRDb29yZGluYXRlcyA9IHRoaXMuZmxhdENvb3JkaW5hdGVzO1xuICAgICAgaWYgKGxpbmVhclJpbmdzQXJlT3JpZW50ZWQoZmxhdENvb3JkaW5hdGVzLCAwLCB0aGlzLmVuZHNfLCB0aGlzLnN0cmlkZSkpIHtcbiAgICAgICAgdGhpcy5vcmllbnRlZEZsYXRDb29yZGluYXRlc18gPSBmbGF0Q29vcmRpbmF0ZXM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm9yaWVudGVkRmxhdENvb3JkaW5hdGVzXyA9IGZsYXRDb29yZGluYXRlcy5zbGljZSgpO1xuICAgICAgICB0aGlzLm9yaWVudGVkRmxhdENvb3JkaW5hdGVzXy5sZW5ndGggPSBvcmllbnRMaW5lYXJSaW5ncyhcbiAgICAgICAgICB0aGlzLm9yaWVudGVkRmxhdENvb3JkaW5hdGVzXyxcbiAgICAgICAgICAwLFxuICAgICAgICAgIHRoaXMuZW5kc18sXG4gICAgICAgICAgdGhpcy5zdHJpZGVcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHRoaXMub3JpZW50ZWRSZXZpc2lvbl8gPSB0aGlzLmdldFJldmlzaW9uKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLm9yaWVudGVkRmxhdENvb3JkaW5hdGVzXztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gc3F1YXJlZFRvbGVyYW5jZSBTcXVhcmVkIHRvbGVyYW5jZS5cbiAgICogQHJldHVybiB7UG9seWdvbn0gU2ltcGxpZmllZCBQb2x5Z29uLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBnZXRTaW1wbGlmaWVkR2VvbWV0cnlJbnRlcm5hbChzcXVhcmVkVG9sZXJhbmNlKSB7XG4gICAgY29uc3Qgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcyA9IFtdO1xuICAgIGNvbnN0IHNpbXBsaWZpZWRFbmRzID0gW107XG4gICAgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcy5sZW5ndGggPSBxdWFudGl6ZUFycmF5KFxuICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMsXG4gICAgICAwLFxuICAgICAgdGhpcy5lbmRzXyxcbiAgICAgIHRoaXMuc3RyaWRlLFxuICAgICAgTWF0aC5zcXJ0KHNxdWFyZWRUb2xlcmFuY2UpLFxuICAgICAgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcyxcbiAgICAgIDAsXG4gICAgICBzaW1wbGlmaWVkRW5kc1xuICAgICk7XG4gICAgcmV0dXJuIG5ldyBQb2x5Z29uKHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXMsICdYWScsIHNpbXBsaWZpZWRFbmRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHR5cGUgb2YgdGhpcyBnZW9tZXRyeS5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi9HZW9tZXRyeS5qc1wiKS5UeXBlfSBHZW9tZXRyeSB0eXBlLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRUeXBlKCkge1xuICAgIHJldHVybiAnUG9seWdvbic7XG4gIH1cblxuICAvKipcbiAgICogVGVzdCBpZiB0aGUgZ2VvbWV0cnkgYW5kIHRoZSBwYXNzZWQgZXh0ZW50IGludGVyc2VjdC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBgdHJ1ZWAgaWYgdGhlIGdlb21ldHJ5IGFuZCB0aGUgZXh0ZW50IGludGVyc2VjdC5cbiAgICogQGFwaVxuICAgKi9cbiAgaW50ZXJzZWN0c0V4dGVudChleHRlbnQpIHtcbiAgICByZXR1cm4gaW50ZXJzZWN0c0xpbmVhclJpbmdBcnJheShcbiAgICAgIHRoaXMuZ2V0T3JpZW50ZWRGbGF0Q29vcmRpbmF0ZXMoKSxcbiAgICAgIDAsXG4gICAgICB0aGlzLmVuZHNfLFxuICAgICAgdGhpcy5zdHJpZGUsXG4gICAgICBleHRlbnRcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgY29vcmRpbmF0ZXMgb2YgdGhlIHBvbHlnb24uXG4gICAqIEBwYXJhbSB7IUFycmF5PEFycmF5PGltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZT4+fSBjb29yZGluYXRlcyBDb29yZGluYXRlcy5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL0dlb21ldHJ5LmpzXCIpLkdlb21ldHJ5TGF5b3V0fSBbbGF5b3V0XSBMYXlvdXQuXG4gICAqIEBhcGlcbiAgICovXG4gIHNldENvb3JkaW5hdGVzKGNvb3JkaW5hdGVzLCBsYXlvdXQpIHtcbiAgICB0aGlzLnNldExheW91dChsYXlvdXQsIGNvb3JkaW5hdGVzLCAyKTtcbiAgICBpZiAoIXRoaXMuZmxhdENvb3JkaW5hdGVzKSB7XG4gICAgICB0aGlzLmZsYXRDb29yZGluYXRlcyA9IFtdO1xuICAgIH1cbiAgICBjb25zdCBlbmRzID0gZGVmbGF0ZUNvb3JkaW5hdGVzQXJyYXkoXG4gICAgICB0aGlzLmZsYXRDb29yZGluYXRlcyxcbiAgICAgIDAsXG4gICAgICBjb29yZGluYXRlcyxcbiAgICAgIHRoaXMuc3RyaWRlLFxuICAgICAgdGhpcy5lbmRzX1xuICAgICk7XG4gICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMubGVuZ3RoID0gZW5kcy5sZW5ndGggPT09IDAgPyAwIDogZW5kc1tlbmRzLmxlbmd0aCAtIDFdO1xuICAgIHRoaXMuY2hhbmdlZCgpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFBvbHlnb247XG5cbi8qKlxuICogQ3JlYXRlIGFuIGFwcHJveGltYXRpb24gb2YgYSBjaXJjbGUgb24gdGhlIHN1cmZhY2Ugb2YgYSBzcGhlcmUuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gY2VudGVyIENlbnRlciAoYFtsb24sIGxhdF1gIGluIGRlZ3JlZXMpLlxuICogQHBhcmFtIHtudW1iZXJ9IHJhZGl1cyBUaGUgZ3JlYXQtY2lyY2xlIGRpc3RhbmNlIGZyb20gdGhlIGNlbnRlciB0b1xuICogICAgIHRoZSBwb2x5Z29uIHZlcnRpY2VzIGluIG1ldGVycy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbbl0gT3B0aW9uYWwgbnVtYmVyIG9mIHZlcnRpY2VzIGZvciB0aGUgcmVzdWx0aW5nXG4gKiAgICAgcG9seWdvbi4gRGVmYXVsdCBpcyBgMzJgLlxuICogQHBhcmFtIHtudW1iZXJ9IFtzcGhlcmVSYWRpdXNdIE9wdGlvbmFsIHJhZGl1cyBmb3IgdGhlIHNwaGVyZSAoZGVmYXVsdHMgdG9cbiAqICAgICB0aGUgRWFydGgncyBtZWFuIHJhZGl1cyB1c2luZyB0aGUgV0dTODQgZWxsaXBzb2lkKS5cbiAqIEByZXR1cm4ge1BvbHlnb259IFRoZSBcImNpcmN1bGFyXCIgcG9seWdvbi5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNpcmN1bGFyKGNlbnRlciwgcmFkaXVzLCBuLCBzcGhlcmVSYWRpdXMpIHtcbiAgbiA9IG4gPyBuIDogMzI7XG4gIC8qKiBAdHlwZSB7QXJyYXk8bnVtYmVyPn0gKi9cbiAgY29uc3QgZmxhdENvb3JkaW5hdGVzID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgZXh0ZW5kKFxuICAgICAgZmxhdENvb3JkaW5hdGVzLFxuICAgICAgc3BoZXJlT2Zmc2V0KGNlbnRlciwgcmFkaXVzLCAoMiAqIE1hdGguUEkgKiBpKSAvIG4sIHNwaGVyZVJhZGl1cylcbiAgICApO1xuICB9XG4gIGZsYXRDb29yZGluYXRlcy5wdXNoKGZsYXRDb29yZGluYXRlc1swXSwgZmxhdENvb3JkaW5hdGVzWzFdKTtcbiAgcmV0dXJuIG5ldyBQb2x5Z29uKGZsYXRDb29yZGluYXRlcywgJ1hZJywgW2ZsYXRDb29yZGluYXRlcy5sZW5ndGhdKTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBwb2x5Z29uIGZyb20gYW4gZXh0ZW50LiBUaGUgbGF5b3V0IHVzZWQgaXMgYFhZYC5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gZXh0ZW50IFRoZSBleHRlbnQuXG4gKiBAcmV0dXJuIHtQb2x5Z29ufSBUaGUgcG9seWdvbi5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21FeHRlbnQoZXh0ZW50KSB7XG4gIGlmIChpc0VtcHR5KGV4dGVudCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBjcmVhdGUgcG9seWdvbiBmcm9tIGVtcHR5IGV4dGVudCcpO1xuICB9XG4gIGNvbnN0IG1pblggPSBleHRlbnRbMF07XG4gIGNvbnN0IG1pblkgPSBleHRlbnRbMV07XG4gIGNvbnN0IG1heFggPSBleHRlbnRbMl07XG4gIGNvbnN0IG1heFkgPSBleHRlbnRbM107XG4gIGNvbnN0IGZsYXRDb29yZGluYXRlcyA9IFtcbiAgICBtaW5YLFxuICAgIG1pblksXG4gICAgbWluWCxcbiAgICBtYXhZLFxuICAgIG1heFgsXG4gICAgbWF4WSxcbiAgICBtYXhYLFxuICAgIG1pblksXG4gICAgbWluWCxcbiAgICBtaW5ZLFxuICBdO1xuICByZXR1cm4gbmV3IFBvbHlnb24oZmxhdENvb3JkaW5hdGVzLCAnWFknLCBbZmxhdENvb3JkaW5hdGVzLmxlbmd0aF0pO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIHJlZ3VsYXIgcG9seWdvbiBmcm9tIGEgY2lyY2xlLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL0NpcmNsZS5qc1wiKS5kZWZhdWx0fSBjaXJjbGUgQ2lyY2xlIGdlb21ldHJ5LlxuICogQHBhcmFtIHtudW1iZXJ9IFtzaWRlc10gTnVtYmVyIG9mIHNpZGVzIG9mIHRoZSBwb2x5Z29uLiBEZWZhdWx0IGlzIDMyLlxuICogQHBhcmFtIHtudW1iZXJ9IFthbmdsZV0gU3RhcnQgYW5nbGUgZm9yIHRoZSBmaXJzdCB2ZXJ0ZXggb2YgdGhlIHBvbHlnb24gaW5cbiAqICAgICBjb3VudGVyLWNsb2Nrd2lzZSByYWRpYW5zLiAwIG1lYW5zIEVhc3QuIERlZmF1bHQgaXMgMC5cbiAqIEByZXR1cm4ge1BvbHlnb259IFBvbHlnb24gZ2VvbWV0cnkuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tQ2lyY2xlKGNpcmNsZSwgc2lkZXMsIGFuZ2xlKSB7XG4gIHNpZGVzID0gc2lkZXMgPyBzaWRlcyA6IDMyO1xuICBjb25zdCBzdHJpZGUgPSBjaXJjbGUuZ2V0U3RyaWRlKCk7XG4gIGNvbnN0IGxheW91dCA9IGNpcmNsZS5nZXRMYXlvdXQoKTtcbiAgY29uc3QgY2VudGVyID0gY2lyY2xlLmdldENlbnRlcigpO1xuICBjb25zdCBhcnJheUxlbmd0aCA9IHN0cmlkZSAqIChzaWRlcyArIDEpO1xuICBjb25zdCBmbGF0Q29vcmRpbmF0ZXMgPSBuZXcgQXJyYXkoYXJyYXlMZW5ndGgpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5TGVuZ3RoOyBpICs9IHN0cmlkZSkge1xuICAgIGZsYXRDb29yZGluYXRlc1tpXSA9IDA7XG4gICAgZmxhdENvb3JkaW5hdGVzW2kgKyAxXSA9IDA7XG4gICAgZm9yIChsZXQgaiA9IDI7IGogPCBzdHJpZGU7IGorKykge1xuICAgICAgZmxhdENvb3JkaW5hdGVzW2kgKyBqXSA9IGNlbnRlcltqXTtcbiAgICB9XG4gIH1cbiAgY29uc3QgZW5kcyA9IFtmbGF0Q29vcmRpbmF0ZXMubGVuZ3RoXTtcbiAgY29uc3QgcG9seWdvbiA9IG5ldyBQb2x5Z29uKGZsYXRDb29yZGluYXRlcywgbGF5b3V0LCBlbmRzKTtcbiAgbWFrZVJlZ3VsYXIocG9seWdvbiwgY2VudGVyLCBjaXJjbGUuZ2V0UmFkaXVzKCksIGFuZ2xlKTtcbiAgcmV0dXJuIHBvbHlnb247XG59XG5cbi8qKlxuICogTW9kaWZ5IHRoZSBjb29yZGluYXRlcyBvZiBhIHBvbHlnb24gdG8gbWFrZSBpdCBhIHJlZ3VsYXIgcG9seWdvbi5cbiAqIEBwYXJhbSB7UG9seWdvbn0gcG9seWdvbiBQb2x5Z29uIGdlb21ldHJ5LlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGNlbnRlciBDZW50ZXIgb2YgdGhlIHJlZ3VsYXIgcG9seWdvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSByYWRpdXMgUmFkaXVzIG9mIHRoZSByZWd1bGFyIHBvbHlnb24uXG4gKiBAcGFyYW0ge251bWJlcn0gW2FuZ2xlXSBTdGFydCBhbmdsZSBmb3IgdGhlIGZpcnN0IHZlcnRleCBvZiB0aGUgcG9seWdvbiBpblxuICogICAgIGNvdW50ZXItY2xvY2t3aXNlIHJhZGlhbnMuIDAgbWVhbnMgRWFzdC4gRGVmYXVsdCBpcyAwLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbWFrZVJlZ3VsYXIocG9seWdvbiwgY2VudGVyLCByYWRpdXMsIGFuZ2xlKSB7XG4gIGNvbnN0IGZsYXRDb29yZGluYXRlcyA9IHBvbHlnb24uZ2V0RmxhdENvb3JkaW5hdGVzKCk7XG4gIGNvbnN0IHN0cmlkZSA9IHBvbHlnb24uZ2V0U3RyaWRlKCk7XG4gIGNvbnN0IHNpZGVzID0gZmxhdENvb3JkaW5hdGVzLmxlbmd0aCAvIHN0cmlkZSAtIDE7XG4gIGNvbnN0IHN0YXJ0QW5nbGUgPSBhbmdsZSA/IGFuZ2xlIDogMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPD0gc2lkZXM7ICsraSkge1xuICAgIGNvbnN0IG9mZnNldCA9IGkgKiBzdHJpZGU7XG4gICAgY29uc3QgYW5nbGUgPSBzdGFydEFuZ2xlICsgKG1vZHVsbyhpLCBzaWRlcykgKiAyICogTWF0aC5QSSkgLyBzaWRlcztcbiAgICBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0XSA9IGNlbnRlclswXSArIHJhZGl1cyAqIE1hdGguY29zKGFuZ2xlKTtcbiAgICBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0ICsgMV0gPSBjZW50ZXJbMV0gKyByYWRpdXMgKiBNYXRoLnNpbihhbmdsZSk7XG4gIH1cbiAgcG9seWdvbi5jaGFuZ2VkKCk7XG59XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvZ2VvbS9TaW1wbGVHZW9tZXRyeVxuICovXG5pbXBvcnQgR2VvbWV0cnkgZnJvbSAnLi9HZW9tZXRyeS5qcyc7XG5pbXBvcnQge2Fic3RyYWN0fSBmcm9tICcuLi91dGlsLmpzJztcbmltcG9ydCB7Y3JlYXRlT3JVcGRhdGVGcm9tRmxhdENvb3JkaW5hdGVzLCBnZXRDZW50ZXJ9IGZyb20gJy4uL2V4dGVudC5qcyc7XG5pbXBvcnQge3JvdGF0ZSwgc2NhbGUsIHRyYW5zZm9ybTJELCB0cmFuc2xhdGV9IGZyb20gJy4vZmxhdC90cmFuc2Zvcm0uanMnO1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEFic3RyYWN0IGJhc2UgY2xhc3M7IG9ubHkgdXNlZCBmb3IgY3JlYXRpbmcgc3ViY2xhc3NlczsgZG8gbm90IGluc3RhbnRpYXRlXG4gKiBpbiBhcHBzLCBhcyBjYW5ub3QgYmUgcmVuZGVyZWQuXG4gKlxuICogQGFic3RyYWN0XG4gKiBAYXBpXG4gKi9cbmNsYXNzIFNpbXBsZUdlb21ldHJ5IGV4dGVuZHMgR2VvbWV0cnkge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuL0dlb21ldHJ5LmpzXCIpLkdlb21ldHJ5TGF5b3V0fVxuICAgICAqL1xuICAgIHRoaXMubGF5b3V0ID0gJ1hZJztcblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuc3RyaWRlID0gMjtcblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAdHlwZSB7QXJyYXk8bnVtYmVyPn1cbiAgICAgKi9cbiAgICB0aGlzLmZsYXRDb29yZGluYXRlcyA9IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gICAqL1xuICBjb21wdXRlRXh0ZW50KGV4dGVudCkge1xuICAgIHJldHVybiBjcmVhdGVPclVwZGF0ZUZyb21GbGF0Q29vcmRpbmF0ZXMoXG4gICAgICB0aGlzLmZsYXRDb29yZGluYXRlcyxcbiAgICAgIDAsXG4gICAgICB0aGlzLmZsYXRDb29yZGluYXRlcy5sZW5ndGgsXG4gICAgICB0aGlzLnN0cmlkZSxcbiAgICAgIGV4dGVudFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQGFic3RyYWN0XG4gICAqIEByZXR1cm4ge0FycmF5PCo+IHwgbnVsbH0gQ29vcmRpbmF0ZXMuXG4gICAqL1xuICBnZXRDb29yZGluYXRlcygpIHtcbiAgICByZXR1cm4gYWJzdHJhY3QoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGZpcnN0IGNvb3JkaW5hdGUgb2YgdGhlIGdlb21ldHJ5LlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IEZpcnN0IGNvb3JkaW5hdGUuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldEZpcnN0Q29vcmRpbmF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5mbGF0Q29vcmRpbmF0ZXMuc2xpY2UoMCwgdGhpcy5zdHJpZGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IEZsYXQgY29vcmRpbmF0ZXMuXG4gICAqL1xuICBnZXRGbGF0Q29vcmRpbmF0ZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmxhdENvb3JkaW5hdGVzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgbGFzdCBjb29yZGluYXRlIG9mIHRoZSBnZW9tZXRyeS5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBMYXN0IHBvaW50LlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRMYXN0Q29vcmRpbmF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5mbGF0Q29vcmRpbmF0ZXMuc2xpY2UoXG4gICAgICB0aGlzLmZsYXRDb29yZGluYXRlcy5sZW5ndGggLSB0aGlzLnN0cmlkZVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSB7QGxpbmsgaW1wb3J0KFwiLi9HZW9tZXRyeS5qc1wiKS5HZW9tZXRyeUxheW91dCBsYXlvdXR9IG9mIHRoZSBnZW9tZXRyeS5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi9HZW9tZXRyeS5qc1wiKS5HZW9tZXRyeUxheW91dH0gTGF5b3V0LlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRMYXlvdXQoKSB7XG4gICAgcmV0dXJuIHRoaXMubGF5b3V0O1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIHNpbXBsaWZpZWQgdmVyc2lvbiBvZiB0aGlzIGdlb21ldHJ5IHVzaW5nIHRoZSBEb3VnbGFzIFBldWNrZXIgYWxnb3JpdGhtLlxuICAgKiBAcGFyYW0ge251bWJlcn0gc3F1YXJlZFRvbGVyYW5jZSBTcXVhcmVkIHRvbGVyYW5jZS5cbiAgICogQHJldHVybiB7U2ltcGxlR2VvbWV0cnl9IFNpbXBsaWZpZWQgZ2VvbWV0cnkuXG4gICAqL1xuICBnZXRTaW1wbGlmaWVkR2VvbWV0cnkoc3F1YXJlZFRvbGVyYW5jZSkge1xuICAgIGlmICh0aGlzLnNpbXBsaWZpZWRHZW9tZXRyeVJldmlzaW9uICE9PSB0aGlzLmdldFJldmlzaW9uKCkpIHtcbiAgICAgIHRoaXMuc2ltcGxpZmllZEdlb21ldHJ5TWF4TWluU3F1YXJlZFRvbGVyYW5jZSA9IDA7XG4gICAgICB0aGlzLnNpbXBsaWZpZWRHZW9tZXRyeVJldmlzaW9uID0gdGhpcy5nZXRSZXZpc2lvbigpO1xuICAgIH1cbiAgICAvLyBJZiBzcXVhcmVkVG9sZXJhbmNlIGlzIG5lZ2F0aXZlIG9yIGlmIHdlIGtub3cgdGhhdCBzaW1wbGlmaWNhdGlvbiB3aWxsIG5vdFxuICAgIC8vIGhhdmUgYW55IGVmZmVjdCB0aGVuIGp1c3QgcmV0dXJuIHRoaXMuXG4gICAgaWYgKFxuICAgICAgc3F1YXJlZFRvbGVyYW5jZSA8IDAgfHxcbiAgICAgICh0aGlzLnNpbXBsaWZpZWRHZW9tZXRyeU1heE1pblNxdWFyZWRUb2xlcmFuY2UgIT09IDAgJiZcbiAgICAgICAgc3F1YXJlZFRvbGVyYW5jZSA8PSB0aGlzLnNpbXBsaWZpZWRHZW9tZXRyeU1heE1pblNxdWFyZWRUb2xlcmFuY2UpXG4gICAgKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBjb25zdCBzaW1wbGlmaWVkR2VvbWV0cnkgPVxuICAgICAgdGhpcy5nZXRTaW1wbGlmaWVkR2VvbWV0cnlJbnRlcm5hbChzcXVhcmVkVG9sZXJhbmNlKTtcbiAgICBjb25zdCBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzID0gc2ltcGxpZmllZEdlb21ldHJ5LmdldEZsYXRDb29yZGluYXRlcygpO1xuICAgIGlmIChzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzLmxlbmd0aCA8IHRoaXMuZmxhdENvb3JkaW5hdGVzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHNpbXBsaWZpZWRHZW9tZXRyeTtcbiAgICB9XG4gICAgLy8gU2ltcGxpZmljYXRpb24gZGlkIG5vdCBhY3R1YWxseSByZW1vdmUgYW55IGNvb3JkaW5hdGVzLiAgV2Ugbm93IGtub3dcbiAgICAvLyB0aGF0IGFueSBjYWxscyB0byBnZXRTaW1wbGlmaWVkR2VvbWV0cnkgd2l0aCBhIHNxdWFyZWRUb2xlcmFuY2UgbGVzc1xuICAgIC8vIHRoYW4gb3IgZXF1YWwgdG8gdGhlIGN1cnJlbnQgc3F1YXJlZFRvbGVyYW5jZSB3aWxsIGFsc28gbm90IGhhdmUgYW55XG4gICAgLy8gZWZmZWN0LiAgVGhpcyBhbGxvd3MgdXMgdG8gc2hvcnQgY2lyY3VpdCBzaW1wbGlmaWNhdGlvbiAoc2F2aW5nIENQVVxuICAgIC8vIGN5Y2xlcykgYW5kIHByZXZlbnRzIHRoZSBjYWNoZSBvZiBzaW1wbGlmaWVkIGdlb21ldHJpZXMgZnJvbSBmaWxsaW5nXG4gICAgLy8gdXAgd2l0aCB1c2VsZXNzIGlkZW50aWNhbCBjb3BpZXMgb2YgdGhpcyBnZW9tZXRyeSAoc2F2aW5nIG1lbW9yeSkuXG4gICAgdGhpcy5zaW1wbGlmaWVkR2VvbWV0cnlNYXhNaW5TcXVhcmVkVG9sZXJhbmNlID0gc3F1YXJlZFRvbGVyYW5jZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gc3F1YXJlZFRvbGVyYW5jZSBTcXVhcmVkIHRvbGVyYW5jZS5cbiAgICogQHJldHVybiB7U2ltcGxlR2VvbWV0cnl9IFNpbXBsaWZpZWQgZ2VvbWV0cnkuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIGdldFNpbXBsaWZpZWRHZW9tZXRyeUludGVybmFsKHNxdWFyZWRUb2xlcmFuY2UpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IFN0cmlkZS5cbiAgICovXG4gIGdldFN0cmlkZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zdHJpZGU7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL0dlb21ldHJ5LmpzXCIpLkdlb21ldHJ5TGF5b3V0fSBsYXlvdXQgTGF5b3V0LlxuICAgKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICAgKi9cbiAgc2V0RmxhdENvb3JkaW5hdGVzKGxheW91dCwgZmxhdENvb3JkaW5hdGVzKSB7XG4gICAgdGhpcy5zdHJpZGUgPSBnZXRTdHJpZGVGb3JMYXlvdXQobGF5b3V0KTtcbiAgICB0aGlzLmxheW91dCA9IGxheW91dDtcbiAgICB0aGlzLmZsYXRDb29yZGluYXRlcyA9IGZsYXRDb29yZGluYXRlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHBhcmFtIHshQXJyYXk8Kj59IGNvb3JkaW5hdGVzIENvb3JkaW5hdGVzLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vR2VvbWV0cnkuanNcIikuR2VvbWV0cnlMYXlvdXR9IFtsYXlvdXRdIExheW91dC5cbiAgICovXG4gIHNldENvb3JkaW5hdGVzKGNvb3JkaW5hdGVzLCBsYXlvdXQpIHtcbiAgICBhYnN0cmFjdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9HZW9tZXRyeS5qc1wiKS5HZW9tZXRyeUxheW91dHx1bmRlZmluZWR9IGxheW91dCBMYXlvdXQuXG4gICAqIEBwYXJhbSB7QXJyYXk8Kj59IGNvb3JkaW5hdGVzIENvb3JkaW5hdGVzLlxuICAgKiBAcGFyYW0ge251bWJlcn0gbmVzdGluZyBOZXN0aW5nLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBzZXRMYXlvdXQobGF5b3V0LCBjb29yZGluYXRlcywgbmVzdGluZykge1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIGxldCBzdHJpZGU7XG4gICAgaWYgKGxheW91dCkge1xuICAgICAgc3RyaWRlID0gZ2V0U3RyaWRlRm9yTGF5b3V0KGxheW91dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmVzdGluZzsgKytpKSB7XG4gICAgICAgIGlmIChjb29yZGluYXRlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aGlzLmxheW91dCA9ICdYWSc7XG4gICAgICAgICAgdGhpcy5zdHJpZGUgPSAyO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb29yZGluYXRlcyA9IC8qKiBAdHlwZSB7QXJyYXl9ICovIChjb29yZGluYXRlc1swXSk7XG4gICAgICB9XG4gICAgICBzdHJpZGUgPSBjb29yZGluYXRlcy5sZW5ndGg7XG4gICAgICBsYXlvdXQgPSBnZXRMYXlvdXRGb3JTdHJpZGUoc3RyaWRlKTtcbiAgICB9XG4gICAgdGhpcy5sYXlvdXQgPSBsYXlvdXQ7XG4gICAgdGhpcy5zdHJpZGUgPSBzdHJpZGU7XG4gIH1cblxuICAvKipcbiAgICogQXBwbHkgYSB0cmFuc2Zvcm0gZnVuY3Rpb24gdG8gdGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBnZW9tZXRyeS5cbiAgICogVGhlIGdlb21ldHJ5IGlzIG1vZGlmaWVkIGluIHBsYWNlLlxuICAgKiBJZiB5b3UgZG8gbm90IHdhbnQgdGhlIGdlb21ldHJ5IG1vZGlmaWVkIGluIHBsYWNlLCBmaXJzdCBgY2xvbmUoKWAgaXQgYW5kXG4gICAqIHRoZW4gdXNlIHRoaXMgZnVuY3Rpb24gb24gdGhlIGNsb25lLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3Byb2ouanNcIikuVHJhbnNmb3JtRnVuY3Rpb259IHRyYW5zZm9ybUZuIFRyYW5zZm9ybSBmdW5jdGlvbi5cbiAgICogQ2FsbGVkIHdpdGggYSBmbGF0IGFycmF5IG9mIGdlb21ldHJ5IGNvb3JkaW5hdGVzLlxuICAgKiBAYXBpXG4gICAqL1xuICBhcHBseVRyYW5zZm9ybSh0cmFuc2Zvcm1Gbikge1xuICAgIGlmICh0aGlzLmZsYXRDb29yZGluYXRlcykge1xuICAgICAgdHJhbnNmb3JtRm4odGhpcy5mbGF0Q29vcmRpbmF0ZXMsIHRoaXMuZmxhdENvb3JkaW5hdGVzLCB0aGlzLnN0cmlkZSk7XG4gICAgICB0aGlzLmNoYW5nZWQoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUm90YXRlIHRoZSBnZW9tZXRyeSBhcm91bmQgYSBnaXZlbiBjb29yZGluYXRlLiBUaGlzIG1vZGlmaWVzIHRoZSBnZW9tZXRyeVxuICAgKiBjb29yZGluYXRlcyBpbiBwbGFjZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGFuZ2xlIFJvdGF0aW9uIGFuZ2xlIGluIGNvdW50ZXItY2xvY2t3aXNlIHJhZGlhbnMuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBhbmNob3IgVGhlIHJvdGF0aW9uIGNlbnRlci5cbiAgICogQGFwaVxuICAgKi9cbiAgcm90YXRlKGFuZ2xlLCBhbmNob3IpIHtcbiAgICBjb25zdCBmbGF0Q29vcmRpbmF0ZXMgPSB0aGlzLmdldEZsYXRDb29yZGluYXRlcygpO1xuICAgIGlmIChmbGF0Q29vcmRpbmF0ZXMpIHtcbiAgICAgIGNvbnN0IHN0cmlkZSA9IHRoaXMuZ2V0U3RyaWRlKCk7XG4gICAgICByb3RhdGUoXG4gICAgICAgIGZsYXRDb29yZGluYXRlcyxcbiAgICAgICAgMCxcbiAgICAgICAgZmxhdENvb3JkaW5hdGVzLmxlbmd0aCxcbiAgICAgICAgc3RyaWRlLFxuICAgICAgICBhbmdsZSxcbiAgICAgICAgYW5jaG9yLFxuICAgICAgICBmbGF0Q29vcmRpbmF0ZXNcbiAgICAgICk7XG4gICAgICB0aGlzLmNoYW5nZWQoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2NhbGUgdGhlIGdlb21ldHJ5ICh3aXRoIGFuIG9wdGlvbmFsIG9yaWdpbikuICBUaGlzIG1vZGlmaWVzIHRoZSBnZW9tZXRyeVxuICAgKiBjb29yZGluYXRlcyBpbiBwbGFjZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHN4IFRoZSBzY2FsaW5nIGZhY3RvciBpbiB0aGUgeC1kaXJlY3Rpb24uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbc3ldIFRoZSBzY2FsaW5nIGZhY3RvciBpbiB0aGUgeS1kaXJlY3Rpb24gKGRlZmF1bHRzIHRvIHN4KS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IFthbmNob3JdIFRoZSBzY2FsZSBvcmlnaW4gKGRlZmF1bHRzIHRvIHRoZSBjZW50ZXJcbiAgICogICAgIG9mIHRoZSBnZW9tZXRyeSBleHRlbnQpLlxuICAgKiBAYXBpXG4gICAqL1xuICBzY2FsZShzeCwgc3ksIGFuY2hvcikge1xuICAgIGlmIChzeSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBzeSA9IHN4O1xuICAgIH1cbiAgICBpZiAoIWFuY2hvcikge1xuICAgICAgYW5jaG9yID0gZ2V0Q2VudGVyKHRoaXMuZ2V0RXh0ZW50KCkpO1xuICAgIH1cbiAgICBjb25zdCBmbGF0Q29vcmRpbmF0ZXMgPSB0aGlzLmdldEZsYXRDb29yZGluYXRlcygpO1xuICAgIGlmIChmbGF0Q29vcmRpbmF0ZXMpIHtcbiAgICAgIGNvbnN0IHN0cmlkZSA9IHRoaXMuZ2V0U3RyaWRlKCk7XG4gICAgICBzY2FsZShcbiAgICAgICAgZmxhdENvb3JkaW5hdGVzLFxuICAgICAgICAwLFxuICAgICAgICBmbGF0Q29vcmRpbmF0ZXMubGVuZ3RoLFxuICAgICAgICBzdHJpZGUsXG4gICAgICAgIHN4LFxuICAgICAgICBzeSxcbiAgICAgICAgYW5jaG9yLFxuICAgICAgICBmbGF0Q29vcmRpbmF0ZXNcbiAgICAgICk7XG4gICAgICB0aGlzLmNoYW5nZWQoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVHJhbnNsYXRlIHRoZSBnZW9tZXRyeS4gIFRoaXMgbW9kaWZpZXMgdGhlIGdlb21ldHJ5IGNvb3JkaW5hdGVzIGluIHBsYWNlLiAgSWZcbiAgICogaW5zdGVhZCB5b3Ugd2FudCBhIG5ldyBnZW9tZXRyeSwgZmlyc3QgYGNsb25lKClgIHRoaXMgZ2VvbWV0cnkuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkZWx0YVggRGVsdGEgWC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGRlbHRhWSBEZWx0YSBZLlxuICAgKiBAYXBpXG4gICAqL1xuICB0cmFuc2xhdGUoZGVsdGFYLCBkZWx0YVkpIHtcbiAgICBjb25zdCBmbGF0Q29vcmRpbmF0ZXMgPSB0aGlzLmdldEZsYXRDb29yZGluYXRlcygpO1xuICAgIGlmIChmbGF0Q29vcmRpbmF0ZXMpIHtcbiAgICAgIGNvbnN0IHN0cmlkZSA9IHRoaXMuZ2V0U3RyaWRlKCk7XG4gICAgICB0cmFuc2xhdGUoXG4gICAgICAgIGZsYXRDb29yZGluYXRlcyxcbiAgICAgICAgMCxcbiAgICAgICAgZmxhdENvb3JkaW5hdGVzLmxlbmd0aCxcbiAgICAgICAgc3RyaWRlLFxuICAgICAgICBkZWx0YVgsXG4gICAgICAgIGRlbHRhWSxcbiAgICAgICAgZmxhdENvb3JkaW5hdGVzXG4gICAgICApO1xuICAgICAgdGhpcy5jaGFuZ2VkKCk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcmV0dXJuIHtpbXBvcnQoXCIuL0dlb21ldHJ5LmpzXCIpLkdlb21ldHJ5TGF5b3V0fSBsYXlvdXQgTGF5b3V0LlxuICovXG5mdW5jdGlvbiBnZXRMYXlvdXRGb3JTdHJpZGUoc3RyaWRlKSB7XG4gIGxldCBsYXlvdXQ7XG4gIGlmIChzdHJpZGUgPT0gMikge1xuICAgIGxheW91dCA9ICdYWSc7XG4gIH0gZWxzZSBpZiAoc3RyaWRlID09IDMpIHtcbiAgICBsYXlvdXQgPSAnWFlaJztcbiAgfSBlbHNlIGlmIChzdHJpZGUgPT0gNCkge1xuICAgIGxheW91dCA9ICdYWVpNJztcbiAgfVxuICByZXR1cm4gLyoqIEB0eXBlIHtpbXBvcnQoXCIuL0dlb21ldHJ5LmpzXCIpLkdlb21ldHJ5TGF5b3V0fSAqLyAobGF5b3V0KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vR2VvbWV0cnkuanNcIikuR2VvbWV0cnlMYXlvdXR9IGxheW91dCBMYXlvdXQuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFN0cmlkZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFN0cmlkZUZvckxheW91dChsYXlvdXQpIHtcbiAgbGV0IHN0cmlkZTtcbiAgaWYgKGxheW91dCA9PSAnWFknKSB7XG4gICAgc3RyaWRlID0gMjtcbiAgfSBlbHNlIGlmIChsYXlvdXQgPT0gJ1hZWicgfHwgbGF5b3V0ID09ICdYWU0nKSB7XG4gICAgc3RyaWRlID0gMztcbiAgfSBlbHNlIGlmIChsYXlvdXQgPT0gJ1hZWk0nKSB7XG4gICAgc3RyaWRlID0gNDtcbiAgfVxuICByZXR1cm4gLyoqIEB0eXBlIHtudW1iZXJ9ICovIChzdHJpZGUpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7U2ltcGxlR2VvbWV0cnl9IHNpbXBsZUdlb21ldHJ5IFNpbXBsZSBnZW9tZXRyeS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vdHJhbnNmb3JtLmpzXCIpLlRyYW5zZm9ybX0gdHJhbnNmb3JtIFRyYW5zZm9ybS5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gW2Rlc3RdIERlc3RpbmF0aW9uLlxuICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gVHJhbnNmb3JtZWQgZmxhdCBjb29yZGluYXRlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZm9ybUdlb20yRChzaW1wbGVHZW9tZXRyeSwgdHJhbnNmb3JtLCBkZXN0KSB7XG4gIGNvbnN0IGZsYXRDb29yZGluYXRlcyA9IHNpbXBsZUdlb21ldHJ5LmdldEZsYXRDb29yZGluYXRlcygpO1xuICBpZiAoIWZsYXRDb29yZGluYXRlcykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IHN0cmlkZSA9IHNpbXBsZUdlb21ldHJ5LmdldFN0cmlkZSgpO1xuICByZXR1cm4gdHJhbnNmb3JtMkQoXG4gICAgZmxhdENvb3JkaW5hdGVzLFxuICAgIDAsXG4gICAgZmxhdENvb3JkaW5hdGVzLmxlbmd0aCxcbiAgICBzdHJpZGUsXG4gICAgdHJhbnNmb3JtLFxuICAgIGRlc3RcbiAgKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgU2ltcGxlR2VvbWV0cnk7XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvZ2VvbS9mbGF0L2FyZWFcbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgRW5kLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEFyZWEuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsaW5lYXJSaW5nKGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmQsIHN0cmlkZSkge1xuICBsZXQgdHdpY2VBcmVhID0gMDtcbiAgbGV0IHgxID0gZmxhdENvb3JkaW5hdGVzW2VuZCAtIHN0cmlkZV07XG4gIGxldCB5MSA9IGZsYXRDb29yZGluYXRlc1tlbmQgLSBzdHJpZGUgKyAxXTtcbiAgZm9yICg7IG9mZnNldCA8IGVuZDsgb2Zmc2V0ICs9IHN0cmlkZSkge1xuICAgIGNvbnN0IHgyID0gZmxhdENvb3JkaW5hdGVzW29mZnNldF07XG4gICAgY29uc3QgeTIgPSBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0ICsgMV07XG4gICAgdHdpY2VBcmVhICs9IHkxICogeDIgLSB4MSAqIHkyO1xuICAgIHgxID0geDI7XG4gICAgeTEgPSB5MjtcbiAgfVxuICByZXR1cm4gdHdpY2VBcmVhIC8gMjtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGVuZHMgRW5kcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHJldHVybiB7bnVtYmVyfSBBcmVhLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbGluZWFyUmluZ3MoZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZHMsIHN0cmlkZSkge1xuICBsZXQgYXJlYSA9IDA7XG4gIGZvciAobGV0IGkgPSAwLCBpaSA9IGVuZHMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgIGNvbnN0IGVuZCA9IGVuZHNbaV07XG4gICAgYXJlYSArPSBsaW5lYXJSaW5nKGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmQsIHN0cmlkZSk7XG4gICAgb2Zmc2V0ID0gZW5kO1xuICB9XG4gIHJldHVybiBhcmVhO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8bnVtYmVyPj59IGVuZHNzIEVuZHNzLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEFyZWEuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsaW5lYXJSaW5nc3MoZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZHNzLCBzdHJpZGUpIHtcbiAgbGV0IGFyZWEgPSAwO1xuICBmb3IgKGxldCBpID0gMCwgaWkgPSBlbmRzcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgY29uc3QgZW5kcyA9IGVuZHNzW2ldO1xuICAgIGFyZWEgKz0gbGluZWFyUmluZ3MoZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZHMsIHN0cmlkZSk7XG4gICAgb2Zmc2V0ID0gZW5kc1tlbmRzLmxlbmd0aCAtIDFdO1xuICB9XG4gIHJldHVybiBhcmVhO1xufVxuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2dlb20vZmxhdC9jZW50ZXJcbiAqL1xuaW1wb3J0IHtjcmVhdGVFbXB0eSwgY3JlYXRlT3JVcGRhdGVGcm9tRmxhdENvb3JkaW5hdGVzfSBmcm9tICcuLi8uLi9leHRlbnQuanMnO1xuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8bnVtYmVyPj59IGVuZHNzIEVuZHNzLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBGbGF0IGNlbnRlcnMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsaW5lYXJSaW5nc3MoZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZHNzLCBzdHJpZGUpIHtcbiAgY29uc3QgZmxhdENlbnRlcnMgPSBbXTtcbiAgbGV0IGV4dGVudCA9IGNyZWF0ZUVtcHR5KCk7XG4gIGZvciAobGV0IGkgPSAwLCBpaSA9IGVuZHNzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICBjb25zdCBlbmRzID0gZW5kc3NbaV07XG4gICAgZXh0ZW50ID0gY3JlYXRlT3JVcGRhdGVGcm9tRmxhdENvb3JkaW5hdGVzKFxuICAgICAgZmxhdENvb3JkaW5hdGVzLFxuICAgICAgb2Zmc2V0LFxuICAgICAgZW5kc1swXSxcbiAgICAgIHN0cmlkZVxuICAgICk7XG4gICAgZmxhdENlbnRlcnMucHVzaCgoZXh0ZW50WzBdICsgZXh0ZW50WzJdKSAvIDIsIChleHRlbnRbMV0gKyBleHRlbnRbM10pIC8gMik7XG4gICAgb2Zmc2V0ID0gZW5kc1tlbmRzLmxlbmd0aCAtIDFdO1xuICB9XG4gIHJldHVybiBmbGF0Q2VudGVycztcbn1cbiIsIi8qKlxuICogQG1vZHVsZSBvbC9nZW9tL2ZsYXQvY2xvc2VzdFxuICovXG5pbXBvcnQge2xlcnAsIHNxdWFyZWREaXN0YW5jZSBhcyBzcXVhcmVkRHh9IGZyb20gJy4uLy4uL21hdGguanMnO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIHBvaW50IG9uIHRoZSAyRCBsaW5lIHNlZ21lbnQgZmxhdENvb3JkaW5hdGVzW29mZnNldDFdIHRvXG4gKiBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0Ml0gdGhhdCBpcyBjbG9zZXN0IHRvIHRoZSBwb2ludCAoeCwgeSkuICBFeHRyYVxuICogZGltZW5zaW9ucyBhcmUgbGluZWFybHkgaW50ZXJwb2xhdGVkLlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQxIE9mZnNldCAxLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldDIgT2Zmc2V0IDIuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB4IFguXG4gKiBAcGFyYW0ge251bWJlcn0geSBZLlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBjbG9zZXN0UG9pbnQgQ2xvc2VzdCBwb2ludC5cbiAqL1xuZnVuY3Rpb24gYXNzaWduQ2xvc2VzdChcbiAgZmxhdENvb3JkaW5hdGVzLFxuICBvZmZzZXQxLFxuICBvZmZzZXQyLFxuICBzdHJpZGUsXG4gIHgsXG4gIHksXG4gIGNsb3Nlc3RQb2ludFxuKSB7XG4gIGNvbnN0IHgxID0gZmxhdENvb3JkaW5hdGVzW29mZnNldDFdO1xuICBjb25zdCB5MSA9IGZsYXRDb29yZGluYXRlc1tvZmZzZXQxICsgMV07XG4gIGNvbnN0IGR4ID0gZmxhdENvb3JkaW5hdGVzW29mZnNldDJdIC0geDE7XG4gIGNvbnN0IGR5ID0gZmxhdENvb3JkaW5hdGVzW29mZnNldDIgKyAxXSAtIHkxO1xuICBsZXQgb2Zmc2V0O1xuICBpZiAoZHggPT09IDAgJiYgZHkgPT09IDApIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQxO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHQgPSAoKHggLSB4MSkgKiBkeCArICh5IC0geTEpICogZHkpIC8gKGR4ICogZHggKyBkeSAqIGR5KTtcbiAgICBpZiAodCA+IDEpIHtcbiAgICAgIG9mZnNldCA9IG9mZnNldDI7XG4gICAgfSBlbHNlIGlmICh0ID4gMCkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHJpZGU7ICsraSkge1xuICAgICAgICBjbG9zZXN0UG9pbnRbaV0gPSBsZXJwKFxuICAgICAgICAgIGZsYXRDb29yZGluYXRlc1tvZmZzZXQxICsgaV0sXG4gICAgICAgICAgZmxhdENvb3JkaW5hdGVzW29mZnNldDIgKyBpXSxcbiAgICAgICAgICB0XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjbG9zZXN0UG9pbnQubGVuZ3RoID0gc3RyaWRlO1xuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSB7XG4gICAgICBvZmZzZXQgPSBvZmZzZXQxO1xuICAgIH1cbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IHN0cmlkZTsgKytpKSB7XG4gICAgY2xvc2VzdFBvaW50W2ldID0gZmxhdENvb3JkaW5hdGVzW29mZnNldCArIGldO1xuICB9XG4gIGNsb3Nlc3RQb2ludC5sZW5ndGggPSBzdHJpZGU7XG59XG5cbi8qKlxuICogUmV0dXJuIHRoZSBzcXVhcmVkIG9mIHRoZSBsYXJnZXN0IGRpc3RhbmNlIGJldHdlZW4gYW55IHBhaXIgb2YgY29uc2VjdXRpdmVcbiAqIGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtudW1iZXJ9IGVuZCBFbmQuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXggTWF4IHNxdWFyZWQgZGVsdGEuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IE1heCBzcXVhcmVkIGRlbHRhLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbWF4U3F1YXJlZERlbHRhKGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmQsIHN0cmlkZSwgbWF4KSB7XG4gIGxldCB4MSA9IGZsYXRDb29yZGluYXRlc1tvZmZzZXRdO1xuICBsZXQgeTEgPSBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0ICsgMV07XG4gIGZvciAob2Zmc2V0ICs9IHN0cmlkZTsgb2Zmc2V0IDwgZW5kOyBvZmZzZXQgKz0gc3RyaWRlKSB7XG4gICAgY29uc3QgeDIgPSBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0XTtcbiAgICBjb25zdCB5MiA9IGZsYXRDb29yZGluYXRlc1tvZmZzZXQgKyAxXTtcbiAgICBjb25zdCBzcXVhcmVkRGVsdGEgPSBzcXVhcmVkRHgoeDEsIHkxLCB4MiwgeTIpO1xuICAgIGlmIChzcXVhcmVkRGVsdGEgPiBtYXgpIHtcbiAgICAgIG1heCA9IHNxdWFyZWREZWx0YTtcbiAgICB9XG4gICAgeDEgPSB4MjtcbiAgICB5MSA9IHkyO1xuICB9XG4gIHJldHVybiBtYXg7XG59XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBlbmRzIEVuZHMuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXggTWF4IHNxdWFyZWQgZGVsdGEuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IE1heCBzcXVhcmVkIGRlbHRhLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYXJyYXlNYXhTcXVhcmVkRGVsdGEoXG4gIGZsYXRDb29yZGluYXRlcyxcbiAgb2Zmc2V0LFxuICBlbmRzLFxuICBzdHJpZGUsXG4gIG1heFxuKSB7XG4gIGZvciAobGV0IGkgPSAwLCBpaSA9IGVuZHMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgIGNvbnN0IGVuZCA9IGVuZHNbaV07XG4gICAgbWF4ID0gbWF4U3F1YXJlZERlbHRhKGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmQsIHN0cmlkZSwgbWF4KTtcbiAgICBvZmZzZXQgPSBlbmQ7XG4gIH1cbiAgcmV0dXJuIG1heDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gKiBAcGFyYW0ge0FycmF5PEFycmF5PG51bWJlcj4+fSBlbmRzcyBFbmRzcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHBhcmFtIHtudW1iZXJ9IG1heCBNYXggc3F1YXJlZCBkZWx0YS5cbiAqIEByZXR1cm4ge251bWJlcn0gTWF4IHNxdWFyZWQgZGVsdGEuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtdWx0aUFycmF5TWF4U3F1YXJlZERlbHRhKFxuICBmbGF0Q29vcmRpbmF0ZXMsXG4gIG9mZnNldCxcbiAgZW5kc3MsXG4gIHN0cmlkZSxcbiAgbWF4XG4pIHtcbiAgZm9yIChsZXQgaSA9IDAsIGlpID0gZW5kc3MubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgIGNvbnN0IGVuZHMgPSBlbmRzc1tpXTtcbiAgICBtYXggPSBhcnJheU1heFNxdWFyZWREZWx0YShmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kcywgc3RyaWRlLCBtYXgpO1xuICAgIG9mZnNldCA9IGVuZHNbZW5kcy5sZW5ndGggLSAxXTtcbiAgfVxuICByZXR1cm4gbWF4O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgRW5kLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4RGVsdGEgTWF4IGRlbHRhLlxuICogQHBhcmFtIHtib29sZWFufSBpc1JpbmcgSXMgcmluZy5cbiAqIEBwYXJhbSB7bnVtYmVyfSB4IFguXG4gKiBAcGFyYW0ge251bWJlcn0geSBZLlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBjbG9zZXN0UG9pbnQgQ2xvc2VzdCBwb2ludC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtaW5TcXVhcmVkRGlzdGFuY2UgTWluaW11bSBzcXVhcmVkIGRpc3RhbmNlLlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBbdG1wUG9pbnRdIFRlbXBvcmFyeSBwb2ludCBvYmplY3QuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IE1pbmltdW0gc3F1YXJlZCBkaXN0YW5jZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2lnbkNsb3Nlc3RQb2ludChcbiAgZmxhdENvb3JkaW5hdGVzLFxuICBvZmZzZXQsXG4gIGVuZCxcbiAgc3RyaWRlLFxuICBtYXhEZWx0YSxcbiAgaXNSaW5nLFxuICB4LFxuICB5LFxuICBjbG9zZXN0UG9pbnQsXG4gIG1pblNxdWFyZWREaXN0YW5jZSxcbiAgdG1wUG9pbnRcbikge1xuICBpZiAob2Zmc2V0ID09IGVuZCkge1xuICAgIHJldHVybiBtaW5TcXVhcmVkRGlzdGFuY2U7XG4gIH1cbiAgbGV0IGksIHNxdWFyZWREaXN0YW5jZTtcbiAgaWYgKG1heERlbHRhID09PSAwKSB7XG4gICAgLy8gQWxsIHBvaW50cyBhcmUgaWRlbnRpY2FsLCBzbyBqdXN0IHRlc3QgdGhlIGZpcnN0IHBvaW50LlxuICAgIHNxdWFyZWREaXN0YW5jZSA9IHNxdWFyZWREeChcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgZmxhdENvb3JkaW5hdGVzW29mZnNldF0sXG4gICAgICBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0ICsgMV1cbiAgICApO1xuICAgIGlmIChzcXVhcmVkRGlzdGFuY2UgPCBtaW5TcXVhcmVkRGlzdGFuY2UpIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBzdHJpZGU7ICsraSkge1xuICAgICAgICBjbG9zZXN0UG9pbnRbaV0gPSBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0ICsgaV07XG4gICAgICB9XG4gICAgICBjbG9zZXN0UG9pbnQubGVuZ3RoID0gc3RyaWRlO1xuICAgICAgcmV0dXJuIHNxdWFyZWREaXN0YW5jZTtcbiAgICB9XG4gICAgcmV0dXJuIG1pblNxdWFyZWREaXN0YW5jZTtcbiAgfVxuICB0bXBQb2ludCA9IHRtcFBvaW50ID8gdG1wUG9pbnQgOiBbTmFOLCBOYU5dO1xuICBsZXQgaW5kZXggPSBvZmZzZXQgKyBzdHJpZGU7XG4gIHdoaWxlIChpbmRleCA8IGVuZCkge1xuICAgIGFzc2lnbkNsb3Nlc3QoXG4gICAgICBmbGF0Q29vcmRpbmF0ZXMsXG4gICAgICBpbmRleCAtIHN0cmlkZSxcbiAgICAgIGluZGV4LFxuICAgICAgc3RyaWRlLFxuICAgICAgeCxcbiAgICAgIHksXG4gICAgICB0bXBQb2ludFxuICAgICk7XG4gICAgc3F1YXJlZERpc3RhbmNlID0gc3F1YXJlZER4KHgsIHksIHRtcFBvaW50WzBdLCB0bXBQb2ludFsxXSk7XG4gICAgaWYgKHNxdWFyZWREaXN0YW5jZSA8IG1pblNxdWFyZWREaXN0YW5jZSkge1xuICAgICAgbWluU3F1YXJlZERpc3RhbmNlID0gc3F1YXJlZERpc3RhbmNlO1xuICAgICAgZm9yIChpID0gMDsgaSA8IHN0cmlkZTsgKytpKSB7XG4gICAgICAgIGNsb3Nlc3RQb2ludFtpXSA9IHRtcFBvaW50W2ldO1xuICAgICAgfVxuICAgICAgY2xvc2VzdFBvaW50Lmxlbmd0aCA9IHN0cmlkZTtcbiAgICAgIGluZGV4ICs9IHN0cmlkZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gU2tpcCBhaGVhZCBtdWx0aXBsZSBwb2ludHMsIGJlY2F1c2Ugd2Uga25vdyB0aGF0IGFsbCB0aGUgc2tpcHBlZFxuICAgICAgLy8gcG9pbnRzIGNhbm5vdCBiZSBhbnkgY2xvc2VyIHRoYW4gdGhlIGNsb3Nlc3QgcG9pbnQgd2UgaGF2ZSBmb3VuZCBzb1xuICAgICAgLy8gZmFyLiAgV2Uga25vdyB0aGlzIGJlY2F1c2Ugd2Uga25vdyBob3cgY2xvc2UgdGhlIGN1cnJlbnQgcG9pbnQgaXMsIGhvd1xuICAgICAgLy8gY2xvc2UgdGhlIGNsb3Nlc3QgcG9pbnQgd2UgaGF2ZSBmb3VuZCBzbyBmYXIgaXMsIGFuZCB0aGUgbWF4aW11bVxuICAgICAgLy8gZGlzdGFuY2UgYmV0d2VlbiBjb25zZWN1dGl2ZSBwb2ludHMuICBGb3IgZXhhbXBsZSwgaWYgd2UncmUgY3VycmVudGx5XG4gICAgICAvLyBhdCBkaXN0YW5jZSAxMCwgdGhlIGJlc3Qgd2UndmUgZm91bmQgc28gZmFyIGlzIDMsIGFuZCB0aGF0IHRoZSBtYXhpbXVtXG4gICAgICAvLyBkaXN0YW5jZSBiZXR3ZWVuIGNvbnNlY3V0aXZlIHBvaW50cyBpcyAyLCB0aGVuIHdlJ2xsIG5lZWQgdG8gc2tpcCBhdFxuICAgICAgLy8gbGVhc3QgKDEwIC0gMykgLyAyID09IDMgKHJvdW5kZWQgZG93bikgcG9pbnRzIHRvIGhhdmUgYW55IGNoYW5jZSBvZlxuICAgICAgLy8gZmluZGluZyBhIGNsb3NlciBwb2ludC4gIFdlIHVzZSBNYXRoLm1heCguLi4sIDEpIHRvIGVuc3VyZSB0aGF0IHdlXG4gICAgICAvLyBhbHdheXMgYWR2YW5jZSBhdCBsZWFzdCBvbmUgcG9pbnQsIHRvIGF2b2lkIGFuIGluZmluaXRlIGxvb3AuXG4gICAgICBpbmRleCArPVxuICAgICAgICBzdHJpZGUgKlxuICAgICAgICBNYXRoLm1heChcbiAgICAgICAgICAoKE1hdGguc3FydChzcXVhcmVkRGlzdGFuY2UpIC0gTWF0aC5zcXJ0KG1pblNxdWFyZWREaXN0YW5jZSkpIC9cbiAgICAgICAgICAgIG1heERlbHRhKSB8XG4gICAgICAgICAgICAwLFxuICAgICAgICAgIDFcbiAgICAgICAgKTtcbiAgICB9XG4gIH1cbiAgaWYgKGlzUmluZykge1xuICAgIC8vIENoZWNrIHRoZSBjbG9zaW5nIHNlZ21lbnQuXG4gICAgYXNzaWduQ2xvc2VzdChcbiAgICAgIGZsYXRDb29yZGluYXRlcyxcbiAgICAgIGVuZCAtIHN0cmlkZSxcbiAgICAgIG9mZnNldCxcbiAgICAgIHN0cmlkZSxcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgdG1wUG9pbnRcbiAgICApO1xuICAgIHNxdWFyZWREaXN0YW5jZSA9IHNxdWFyZWREeCh4LCB5LCB0bXBQb2ludFswXSwgdG1wUG9pbnRbMV0pO1xuICAgIGlmIChzcXVhcmVkRGlzdGFuY2UgPCBtaW5TcXVhcmVkRGlzdGFuY2UpIHtcbiAgICAgIG1pblNxdWFyZWREaXN0YW5jZSA9IHNxdWFyZWREaXN0YW5jZTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBzdHJpZGU7ICsraSkge1xuICAgICAgICBjbG9zZXN0UG9pbnRbaV0gPSB0bXBQb2ludFtpXTtcbiAgICAgIH1cbiAgICAgIGNsb3Nlc3RQb2ludC5sZW5ndGggPSBzdHJpZGU7XG4gICAgfVxuICB9XG4gIHJldHVybiBtaW5TcXVhcmVkRGlzdGFuY2U7XG59XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBlbmRzIEVuZHMuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXhEZWx0YSBNYXggZGVsdGEuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGlzUmluZyBJcyByaW5nLlxuICogQHBhcmFtIHtudW1iZXJ9IHggWC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB5IFkuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGNsb3Nlc3RQb2ludCBDbG9zZXN0IHBvaW50LlxuICogQHBhcmFtIHtudW1iZXJ9IG1pblNxdWFyZWREaXN0YW5jZSBNaW5pbXVtIHNxdWFyZWQgZGlzdGFuY2UuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IFt0bXBQb2ludF0gVGVtcG9yYXJ5IHBvaW50IG9iamVjdC5cbiAqIEByZXR1cm4ge251bWJlcn0gTWluaW11bSBzcXVhcmVkIGRpc3RhbmNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzaWduQ2xvc2VzdEFycmF5UG9pbnQoXG4gIGZsYXRDb29yZGluYXRlcyxcbiAgb2Zmc2V0LFxuICBlbmRzLFxuICBzdHJpZGUsXG4gIG1heERlbHRhLFxuICBpc1JpbmcsXG4gIHgsXG4gIHksXG4gIGNsb3Nlc3RQb2ludCxcbiAgbWluU3F1YXJlZERpc3RhbmNlLFxuICB0bXBQb2ludFxuKSB7XG4gIHRtcFBvaW50ID0gdG1wUG9pbnQgPyB0bXBQb2ludCA6IFtOYU4sIE5hTl07XG4gIGZvciAobGV0IGkgPSAwLCBpaSA9IGVuZHMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgIGNvbnN0IGVuZCA9IGVuZHNbaV07XG4gICAgbWluU3F1YXJlZERpc3RhbmNlID0gYXNzaWduQ2xvc2VzdFBvaW50KFxuICAgICAgZmxhdENvb3JkaW5hdGVzLFxuICAgICAgb2Zmc2V0LFxuICAgICAgZW5kLFxuICAgICAgc3RyaWRlLFxuICAgICAgbWF4RGVsdGEsXG4gICAgICBpc1JpbmcsXG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIGNsb3Nlc3RQb2ludCxcbiAgICAgIG1pblNxdWFyZWREaXN0YW5jZSxcbiAgICAgIHRtcFBvaW50XG4gICAgKTtcbiAgICBvZmZzZXQgPSBlbmQ7XG4gIH1cbiAgcmV0dXJuIG1pblNxdWFyZWREaXN0YW5jZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gKiBAcGFyYW0ge0FycmF5PEFycmF5PG51bWJlcj4+fSBlbmRzcyBFbmRzcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHBhcmFtIHtudW1iZXJ9IG1heERlbHRhIE1heCBkZWx0YS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNSaW5nIElzIHJpbmcuXG4gKiBAcGFyYW0ge251bWJlcn0geCBYLlxuICogQHBhcmFtIHtudW1iZXJ9IHkgWS5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gY2xvc2VzdFBvaW50IENsb3Nlc3QgcG9pbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gbWluU3F1YXJlZERpc3RhbmNlIE1pbmltdW0gc3F1YXJlZCBkaXN0YW5jZS5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gW3RtcFBvaW50XSBUZW1wb3JhcnkgcG9pbnQgb2JqZWN0LlxuICogQHJldHVybiB7bnVtYmVyfSBNaW5pbXVtIHNxdWFyZWQgZGlzdGFuY2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NpZ25DbG9zZXN0TXVsdGlBcnJheVBvaW50KFxuICBmbGF0Q29vcmRpbmF0ZXMsXG4gIG9mZnNldCxcbiAgZW5kc3MsXG4gIHN0cmlkZSxcbiAgbWF4RGVsdGEsXG4gIGlzUmluZyxcbiAgeCxcbiAgeSxcbiAgY2xvc2VzdFBvaW50LFxuICBtaW5TcXVhcmVkRGlzdGFuY2UsXG4gIHRtcFBvaW50XG4pIHtcbiAgdG1wUG9pbnQgPSB0bXBQb2ludCA/IHRtcFBvaW50IDogW05hTiwgTmFOXTtcbiAgZm9yIChsZXQgaSA9IDAsIGlpID0gZW5kc3MubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgIGNvbnN0IGVuZHMgPSBlbmRzc1tpXTtcbiAgICBtaW5TcXVhcmVkRGlzdGFuY2UgPSBhc3NpZ25DbG9zZXN0QXJyYXlQb2ludChcbiAgICAgIGZsYXRDb29yZGluYXRlcyxcbiAgICAgIG9mZnNldCxcbiAgICAgIGVuZHMsXG4gICAgICBzdHJpZGUsXG4gICAgICBtYXhEZWx0YSxcbiAgICAgIGlzUmluZyxcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgY2xvc2VzdFBvaW50LFxuICAgICAgbWluU3F1YXJlZERpc3RhbmNlLFxuICAgICAgdG1wUG9pbnRcbiAgICApO1xuICAgIG9mZnNldCA9IGVuZHNbZW5kcy5sZW5ndGggLSAxXTtcbiAgfVxuICByZXR1cm4gbWluU3F1YXJlZERpc3RhbmNlO1xufVxuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2dlb20vZmxhdC9jb250YWluc1xuICovXG5pbXBvcnQge2ZvckVhY2hDb3JuZXJ9IGZyb20gJy4uLy4uL2V4dGVudC5qcyc7XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtudW1iZXJ9IGVuZCBFbmQuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IENvbnRhaW5zIGV4dGVudC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxpbmVhclJpbmdDb250YWluc0V4dGVudChcbiAgZmxhdENvb3JkaW5hdGVzLFxuICBvZmZzZXQsXG4gIGVuZCxcbiAgc3RyaWRlLFxuICBleHRlbnRcbikge1xuICBjb25zdCBvdXRzaWRlID0gZm9yRWFjaENvcm5lcihcbiAgICBleHRlbnQsXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGNvb3JkaW5hdGUgQ29vcmRpbmF0ZS5cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBDb250YWlucyAoeCwgeSkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gKGNvb3JkaW5hdGUpIHtcbiAgICAgIHJldHVybiAhbGluZWFyUmluZ0NvbnRhaW5zWFkoXG4gICAgICAgIGZsYXRDb29yZGluYXRlcyxcbiAgICAgICAgb2Zmc2V0LFxuICAgICAgICBlbmQsXG4gICAgICAgIHN0cmlkZSxcbiAgICAgICAgY29vcmRpbmF0ZVswXSxcbiAgICAgICAgY29vcmRpbmF0ZVsxXVxuICAgICAgKTtcbiAgICB9XG4gICk7XG4gIHJldHVybiAhb3V0c2lkZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gKiBAcGFyYW0ge251bWJlcn0gZW5kIEVuZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHBhcmFtIHtudW1iZXJ9IHggWC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB5IFkuXG4gKiBAcmV0dXJuIHtib29sZWFufSBDb250YWlucyAoeCwgeSkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsaW5lYXJSaW5nQ29udGFpbnNYWShcbiAgZmxhdENvb3JkaW5hdGVzLFxuICBvZmZzZXQsXG4gIGVuZCxcbiAgc3RyaWRlLFxuICB4LFxuICB5XG4pIHtcbiAgLy8gaHR0cHM6Ly9nZW9tYWxnb3JpdGhtcy5jb20vYTAzLV9pbmNsdXNpb24uaHRtbFxuICAvLyBDb3B5cmlnaHQgMjAwMCBzb2Z0U3VyZmVyLCAyMDEyIERhbiBTdW5kYXlcbiAgLy8gVGhpcyBjb2RlIG1heSBiZSBmcmVlbHkgdXNlZCBhbmQgbW9kaWZpZWQgZm9yIGFueSBwdXJwb3NlXG4gIC8vIHByb3ZpZGluZyB0aGF0IHRoaXMgY29weXJpZ2h0IG5vdGljZSBpcyBpbmNsdWRlZCB3aXRoIGl0LlxuICAvLyBTb2Z0U3VyZmVyIG1ha2VzIG5vIHdhcnJhbnR5IGZvciB0aGlzIGNvZGUsIGFuZCBjYW5ub3QgYmUgaGVsZFxuICAvLyBsaWFibGUgZm9yIGFueSByZWFsIG9yIGltYWdpbmVkIGRhbWFnZSByZXN1bHRpbmcgZnJvbSBpdHMgdXNlLlxuICAvLyBVc2VycyBvZiB0aGlzIGNvZGUgbXVzdCB2ZXJpZnkgY29ycmVjdG5lc3MgZm9yIHRoZWlyIGFwcGxpY2F0aW9uLlxuICBsZXQgd24gPSAwO1xuICBsZXQgeDEgPSBmbGF0Q29vcmRpbmF0ZXNbZW5kIC0gc3RyaWRlXTtcbiAgbGV0IHkxID0gZmxhdENvb3JkaW5hdGVzW2VuZCAtIHN0cmlkZSArIDFdO1xuICBmb3IgKDsgb2Zmc2V0IDwgZW5kOyBvZmZzZXQgKz0gc3RyaWRlKSB7XG4gICAgY29uc3QgeDIgPSBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0XTtcbiAgICBjb25zdCB5MiA9IGZsYXRDb29yZGluYXRlc1tvZmZzZXQgKyAxXTtcbiAgICBpZiAoeTEgPD0geSkge1xuICAgICAgaWYgKHkyID4geSAmJiAoeDIgLSB4MSkgKiAoeSAtIHkxKSAtICh4IC0geDEpICogKHkyIC0geTEpID4gMCkge1xuICAgICAgICB3bisrO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoeTIgPD0geSAmJiAoeDIgLSB4MSkgKiAoeSAtIHkxKSAtICh4IC0geDEpICogKHkyIC0geTEpIDwgMCkge1xuICAgICAgd24tLTtcbiAgICB9XG4gICAgeDEgPSB4MjtcbiAgICB5MSA9IHkyO1xuICB9XG4gIHJldHVybiB3biAhPT0gMDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGVuZHMgRW5kcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHBhcmFtIHtudW1iZXJ9IHggWC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB5IFkuXG4gKiBAcmV0dXJuIHtib29sZWFufSBDb250YWlucyAoeCwgeSkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsaW5lYXJSaW5nc0NvbnRhaW5zWFkoXG4gIGZsYXRDb29yZGluYXRlcyxcbiAgb2Zmc2V0LFxuICBlbmRzLFxuICBzdHJpZGUsXG4gIHgsXG4gIHlcbikge1xuICBpZiAoZW5kcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKCFsaW5lYXJSaW5nQ29udGFpbnNYWShmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kc1swXSwgc3RyaWRlLCB4LCB5KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKGxldCBpID0gMSwgaWkgPSBlbmRzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICBpZiAoXG4gICAgICBsaW5lYXJSaW5nQ29udGFpbnNYWShmbGF0Q29vcmRpbmF0ZXMsIGVuZHNbaSAtIDFdLCBlbmRzW2ldLCBzdHJpZGUsIHgsIHkpXG4gICAgKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8bnVtYmVyPj59IGVuZHNzIEVuZHNzLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcGFyYW0ge251bWJlcn0geCBYLlxuICogQHBhcmFtIHtudW1iZXJ9IHkgWS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IENvbnRhaW5zICh4LCB5KS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxpbmVhclJpbmdzc0NvbnRhaW5zWFkoXG4gIGZsYXRDb29yZGluYXRlcyxcbiAgb2Zmc2V0LFxuICBlbmRzcyxcbiAgc3RyaWRlLFxuICB4LFxuICB5XG4pIHtcbiAgaWYgKGVuZHNzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKGxldCBpID0gMCwgaWkgPSBlbmRzcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgY29uc3QgZW5kcyA9IGVuZHNzW2ldO1xuICAgIGlmIChsaW5lYXJSaW5nc0NvbnRhaW5zWFkoZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZHMsIHN0cmlkZSwgeCwgeSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBvZmZzZXQgPSBlbmRzW2VuZHMubGVuZ3RoIC0gMV07XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2dlb20vZmxhdC9kZWZsYXRlXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gY29vcmRpbmF0ZSBDb29yZGluYXRlLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWZsYXRlQ29vcmRpbmF0ZShmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgY29vcmRpbmF0ZSwgc3RyaWRlKSB7XG4gIGZvciAobGV0IGkgPSAwLCBpaSA9IGNvb3JkaW5hdGUubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgIGZsYXRDb29yZGluYXRlc1tvZmZzZXQrK10gPSBjb29yZGluYXRlW2ldO1xuICB9XG4gIHJldHVybiBvZmZzZXQ7XG59XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtBcnJheTxpbXBvcnQoXCIuLi8uLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGU+fSBjb29yZGluYXRlcyBDb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHJldHVybiB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVmbGF0ZUNvb3JkaW5hdGVzKFxuICBmbGF0Q29vcmRpbmF0ZXMsXG4gIG9mZnNldCxcbiAgY29vcmRpbmF0ZXMsXG4gIHN0cmlkZVxuKSB7XG4gIGZvciAobGV0IGkgPSAwLCBpaSA9IGNvb3JkaW5hdGVzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICBjb25zdCBjb29yZGluYXRlID0gY29vcmRpbmF0ZXNbaV07XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBzdHJpZGU7ICsraikge1xuICAgICAgZmxhdENvb3JkaW5hdGVzW29mZnNldCsrXSA9IGNvb3JkaW5hdGVbal07XG4gICAgfVxuICB9XG4gIHJldHVybiBvZmZzZXQ7XG59XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtBcnJheTxBcnJheTxpbXBvcnQoXCIuLi8uLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGU+Pn0gY29vcmRpbmF0ZXNzIENvb3JkaW5hdGVzcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBbZW5kc10gRW5kcy5cbiAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IEVuZHMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWZsYXRlQ29vcmRpbmF0ZXNBcnJheShcbiAgZmxhdENvb3JkaW5hdGVzLFxuICBvZmZzZXQsXG4gIGNvb3JkaW5hdGVzcyxcbiAgc3RyaWRlLFxuICBlbmRzXG4pIHtcbiAgZW5kcyA9IGVuZHMgPyBlbmRzIDogW107XG4gIGxldCBpID0gMDtcbiAgZm9yIChsZXQgaiA9IDAsIGpqID0gY29vcmRpbmF0ZXNzLmxlbmd0aDsgaiA8IGpqOyArK2opIHtcbiAgICBjb25zdCBlbmQgPSBkZWZsYXRlQ29vcmRpbmF0ZXMoXG4gICAgICBmbGF0Q29vcmRpbmF0ZXMsXG4gICAgICBvZmZzZXQsXG4gICAgICBjb29yZGluYXRlc3Nbal0sXG4gICAgICBzdHJpZGVcbiAgICApO1xuICAgIGVuZHNbaSsrXSA9IGVuZDtcbiAgICBvZmZzZXQgPSBlbmQ7XG4gIH1cbiAgZW5kcy5sZW5ndGggPSBpO1xuICByZXR1cm4gZW5kcztcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gKiBAcGFyYW0ge0FycmF5PEFycmF5PEFycmF5PGltcG9ydChcIi4uLy4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZT4+Pn0gY29vcmRpbmF0ZXNzcyBDb29yZGluYXRlc3NzLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcGFyYW0ge0FycmF5PEFycmF5PG51bWJlcj4+fSBbZW5kc3NdIEVuZHNzLlxuICogQHJldHVybiB7QXJyYXk8QXJyYXk8bnVtYmVyPj59IEVuZHNzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVmbGF0ZU11bHRpQ29vcmRpbmF0ZXNBcnJheShcbiAgZmxhdENvb3JkaW5hdGVzLFxuICBvZmZzZXQsXG4gIGNvb3JkaW5hdGVzc3MsXG4gIHN0cmlkZSxcbiAgZW5kc3Ncbikge1xuICBlbmRzcyA9IGVuZHNzID8gZW5kc3MgOiBbXTtcbiAgbGV0IGkgPSAwO1xuICBmb3IgKGxldCBqID0gMCwgamogPSBjb29yZGluYXRlc3NzLmxlbmd0aDsgaiA8IGpqOyArK2opIHtcbiAgICBjb25zdCBlbmRzID0gZGVmbGF0ZUNvb3JkaW5hdGVzQXJyYXkoXG4gICAgICBmbGF0Q29vcmRpbmF0ZXMsXG4gICAgICBvZmZzZXQsXG4gICAgICBjb29yZGluYXRlc3NzW2pdLFxuICAgICAgc3RyaWRlLFxuICAgICAgZW5kc3NbaV1cbiAgICApO1xuICAgIGlmIChlbmRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgZW5kc1swXSA9IG9mZnNldDtcbiAgICB9XG4gICAgZW5kc3NbaSsrXSA9IGVuZHM7XG4gICAgb2Zmc2V0ID0gZW5kc1tlbmRzLmxlbmd0aCAtIDFdO1xuICB9XG4gIGVuZHNzLmxlbmd0aCA9IGk7XG4gIHJldHVybiBlbmRzcztcbn1cbiIsIi8qKlxuICogQG1vZHVsZSBvbC9nZW9tL2ZsYXQvaW5mbGF0ZVxuICovXG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtudW1iZXJ9IGVuZCBFbmQuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqIEBwYXJhbSB7QXJyYXk8aW1wb3J0KFwiLi4vLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlPn0gW2Nvb3JkaW5hdGVzXSBDb29yZGluYXRlcy5cbiAqIEByZXR1cm4ge0FycmF5PGltcG9ydChcIi4uLy4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZT59IENvb3JkaW5hdGVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaW5mbGF0ZUNvb3JkaW5hdGVzKFxuICBmbGF0Q29vcmRpbmF0ZXMsXG4gIG9mZnNldCxcbiAgZW5kLFxuICBzdHJpZGUsXG4gIGNvb3JkaW5hdGVzXG4pIHtcbiAgY29vcmRpbmF0ZXMgPSBjb29yZGluYXRlcyAhPT0gdW5kZWZpbmVkID8gY29vcmRpbmF0ZXMgOiBbXTtcbiAgbGV0IGkgPSAwO1xuICBmb3IgKGxldCBqID0gb2Zmc2V0OyBqIDwgZW5kOyBqICs9IHN0cmlkZSkge1xuICAgIGNvb3JkaW5hdGVzW2krK10gPSBmbGF0Q29vcmRpbmF0ZXMuc2xpY2UoaiwgaiArIHN0cmlkZSk7XG4gIH1cbiAgY29vcmRpbmF0ZXMubGVuZ3RoID0gaTtcbiAgcmV0dXJuIGNvb3JkaW5hdGVzO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZW5kcyBFbmRzLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcGFyYW0ge0FycmF5PEFycmF5PGltcG9ydChcIi4uLy4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZT4+fSBbY29vcmRpbmF0ZXNzXSBDb29yZGluYXRlc3MuXG4gKiBAcmV0dXJuIHtBcnJheTxBcnJheTxpbXBvcnQoXCIuLi8uLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGU+Pn0gQ29vcmRpbmF0ZXNzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaW5mbGF0ZUNvb3JkaW5hdGVzQXJyYXkoXG4gIGZsYXRDb29yZGluYXRlcyxcbiAgb2Zmc2V0LFxuICBlbmRzLFxuICBzdHJpZGUsXG4gIGNvb3JkaW5hdGVzc1xuKSB7XG4gIGNvb3JkaW5hdGVzcyA9IGNvb3JkaW5hdGVzcyAhPT0gdW5kZWZpbmVkID8gY29vcmRpbmF0ZXNzIDogW107XG4gIGxldCBpID0gMDtcbiAgZm9yIChsZXQgaiA9IDAsIGpqID0gZW5kcy5sZW5ndGg7IGogPCBqajsgKytqKSB7XG4gICAgY29uc3QgZW5kID0gZW5kc1tqXTtcbiAgICBjb29yZGluYXRlc3NbaSsrXSA9IGluZmxhdGVDb29yZGluYXRlcyhcbiAgICAgIGZsYXRDb29yZGluYXRlcyxcbiAgICAgIG9mZnNldCxcbiAgICAgIGVuZCxcbiAgICAgIHN0cmlkZSxcbiAgICAgIGNvb3JkaW5hdGVzc1tpXVxuICAgICk7XG4gICAgb2Zmc2V0ID0gZW5kO1xuICB9XG4gIGNvb3JkaW5hdGVzcy5sZW5ndGggPSBpO1xuICByZXR1cm4gY29vcmRpbmF0ZXNzO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8bnVtYmVyPj59IGVuZHNzIEVuZHNzLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcGFyYW0ge0FycmF5PEFycmF5PEFycmF5PGltcG9ydChcIi4uLy4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZT4+Pn0gW2Nvb3JkaW5hdGVzc3NdXG4gKiAgICAgQ29vcmRpbmF0ZXNzcy5cbiAqIEByZXR1cm4ge0FycmF5PEFycmF5PEFycmF5PGltcG9ydChcIi4uLy4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZT4+Pn0gQ29vcmRpbmF0ZXNzcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGluZmxhdGVNdWx0aUNvb3JkaW5hdGVzQXJyYXkoXG4gIGZsYXRDb29yZGluYXRlcyxcbiAgb2Zmc2V0LFxuICBlbmRzcyxcbiAgc3RyaWRlLFxuICBjb29yZGluYXRlc3NzXG4pIHtcbiAgY29vcmRpbmF0ZXNzcyA9IGNvb3JkaW5hdGVzc3MgIT09IHVuZGVmaW5lZCA/IGNvb3JkaW5hdGVzc3MgOiBbXTtcbiAgbGV0IGkgPSAwO1xuICBmb3IgKGxldCBqID0gMCwgamogPSBlbmRzcy5sZW5ndGg7IGogPCBqajsgKytqKSB7XG4gICAgY29uc3QgZW5kcyA9IGVuZHNzW2pdO1xuICAgIGNvb3JkaW5hdGVzc3NbaSsrXSA9XG4gICAgICBlbmRzLmxlbmd0aCA9PT0gMSAmJiBlbmRzWzBdID09PSBvZmZzZXRcbiAgICAgICAgPyBbXVxuICAgICAgICA6IGluZmxhdGVDb29yZGluYXRlc0FycmF5KFxuICAgICAgICAgICAgZmxhdENvb3JkaW5hdGVzLFxuICAgICAgICAgICAgb2Zmc2V0LFxuICAgICAgICAgICAgZW5kcyxcbiAgICAgICAgICAgIHN0cmlkZSxcbiAgICAgICAgICAgIGNvb3JkaW5hdGVzc3NbaV1cbiAgICAgICAgICApO1xuICAgIG9mZnNldCA9IGVuZHNbZW5kcy5sZW5ndGggLSAxXTtcbiAgfVxuICBjb29yZGluYXRlc3NzLmxlbmd0aCA9IGk7XG4gIHJldHVybiBjb29yZGluYXRlc3NzO1xufVxuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2dlb20vZmxhdC9pbnRlcmlvcnBvaW50XG4gKi9cbmltcG9ydCB7YXNjZW5kaW5nfSBmcm9tICcuLi8uLi9hcnJheS5qcyc7XG5pbXBvcnQge2xpbmVhclJpbmdzQ29udGFpbnNYWX0gZnJvbSAnLi9jb250YWlucy5qcyc7XG5cbi8qKlxuICogQ2FsY3VsYXRlcyBhIHBvaW50IHRoYXQgaXMgbGlrZWx5IHRvIGxpZSBpbiB0aGUgaW50ZXJpb3Igb2YgdGhlIGxpbmVhciByaW5ncy5cbiAqIEluc3BpcmVkIGJ5IEpUUydzIGNvbS52aXZpZHNvbHV0aW9ucy5qdHMuZ2VvbS5HZW9tZXRyeSNnZXRJbnRlcmlvclBvaW50LlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBlbmRzIEVuZHMuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENlbnRlcnMgRmxhdCBjZW50ZXJzLlxuICogQHBhcmFtIHtudW1iZXJ9IGZsYXRDZW50ZXJzT2Zmc2V0IEZsYXQgY2VudGVyIG9mZnNldC5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gW2Rlc3RdIERlc3RpbmF0aW9uLlxuICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gRGVzdGluYXRpb24gcG9pbnQgYXMgWFlNIGNvb3JkaW5hdGUsIHdoZXJlIE0gaXMgdGhlXG4gKiBsZW5ndGggb2YgdGhlIGhvcml6b250YWwgaW50ZXJzZWN0aW9uIHRoYXQgdGhlIHBvaW50IGJlbG9uZ3MgdG8uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRJbnRlcmlvclBvaW50T2ZBcnJheShcbiAgZmxhdENvb3JkaW5hdGVzLFxuICBvZmZzZXQsXG4gIGVuZHMsXG4gIHN0cmlkZSxcbiAgZmxhdENlbnRlcnMsXG4gIGZsYXRDZW50ZXJzT2Zmc2V0LFxuICBkZXN0XG4pIHtcbiAgbGV0IGksIGlpLCB4LCB4MSwgeDIsIHkxLCB5MjtcbiAgY29uc3QgeSA9IGZsYXRDZW50ZXJzW2ZsYXRDZW50ZXJzT2Zmc2V0ICsgMV07XG4gIC8qKiBAdHlwZSB7QXJyYXk8bnVtYmVyPn0gKi9cbiAgY29uc3QgaW50ZXJzZWN0aW9ucyA9IFtdO1xuICAvLyBDYWxjdWxhdGUgaW50ZXJzZWN0aW9ucyB3aXRoIHRoZSBob3Jpem9udGFsIGxpbmVcbiAgZm9yIChsZXQgciA9IDAsIHJyID0gZW5kcy5sZW5ndGg7IHIgPCBycjsgKytyKSB7XG4gICAgY29uc3QgZW5kID0gZW5kc1tyXTtcbiAgICB4MSA9IGZsYXRDb29yZGluYXRlc1tlbmQgLSBzdHJpZGVdO1xuICAgIHkxID0gZmxhdENvb3JkaW5hdGVzW2VuZCAtIHN0cmlkZSArIDFdO1xuICAgIGZvciAoaSA9IG9mZnNldDsgaSA8IGVuZDsgaSArPSBzdHJpZGUpIHtcbiAgICAgIHgyID0gZmxhdENvb3JkaW5hdGVzW2ldO1xuICAgICAgeTIgPSBmbGF0Q29vcmRpbmF0ZXNbaSArIDFdO1xuICAgICAgaWYgKCh5IDw9IHkxICYmIHkyIDw9IHkpIHx8ICh5MSA8PSB5ICYmIHkgPD0geTIpKSB7XG4gICAgICAgIHggPSAoKHkgLSB5MSkgLyAoeTIgLSB5MSkpICogKHgyIC0geDEpICsgeDE7XG4gICAgICAgIGludGVyc2VjdGlvbnMucHVzaCh4KTtcbiAgICAgIH1cbiAgICAgIHgxID0geDI7XG4gICAgICB5MSA9IHkyO1xuICAgIH1cbiAgfVxuICAvLyBGaW5kIHRoZSBsb25nZXN0IHNlZ21lbnQgb2YgdGhlIGhvcml6b250YWwgbGluZSB0aGF0IGhhcyBpdHMgY2VudGVyIHBvaW50XG4gIC8vIGluc2lkZSB0aGUgbGluZWFyIHJpbmcuXG4gIGxldCBwb2ludFggPSBOYU47XG4gIGxldCBtYXhTZWdtZW50TGVuZ3RoID0gLUluZmluaXR5O1xuICBpbnRlcnNlY3Rpb25zLnNvcnQoYXNjZW5kaW5nKTtcbiAgeDEgPSBpbnRlcnNlY3Rpb25zWzBdO1xuICBmb3IgKGkgPSAxLCBpaSA9IGludGVyc2VjdGlvbnMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgIHgyID0gaW50ZXJzZWN0aW9uc1tpXTtcbiAgICBjb25zdCBzZWdtZW50TGVuZ3RoID0gTWF0aC5hYnMoeDIgLSB4MSk7XG4gICAgaWYgKHNlZ21lbnRMZW5ndGggPiBtYXhTZWdtZW50TGVuZ3RoKSB7XG4gICAgICB4ID0gKHgxICsgeDIpIC8gMjtcbiAgICAgIGlmIChsaW5lYXJSaW5nc0NvbnRhaW5zWFkoZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZHMsIHN0cmlkZSwgeCwgeSkpIHtcbiAgICAgICAgcG9pbnRYID0geDtcbiAgICAgICAgbWF4U2VnbWVudExlbmd0aCA9IHNlZ21lbnRMZW5ndGg7XG4gICAgICB9XG4gICAgfVxuICAgIHgxID0geDI7XG4gIH1cbiAgaWYgKGlzTmFOKHBvaW50WCkpIHtcbiAgICAvLyBUaGVyZSBpcyBubyBob3Jpem9udGFsIGxpbmUgdGhhdCBoYXMgaXRzIGNlbnRlciBwb2ludCBpbnNpZGUgdGhlIGxpbmVhclxuICAgIC8vIHJpbmcuICBVc2UgdGhlIGNlbnRlciBvZiB0aGUgdGhlIGxpbmVhciByaW5nJ3MgZXh0ZW50LlxuICAgIHBvaW50WCA9IGZsYXRDZW50ZXJzW2ZsYXRDZW50ZXJzT2Zmc2V0XTtcbiAgfVxuICBpZiAoZGVzdCkge1xuICAgIGRlc3QucHVzaChwb2ludFgsIHksIG1heFNlZ21lbnRMZW5ndGgpO1xuICAgIHJldHVybiBkZXN0O1xuICB9XG4gIHJldHVybiBbcG9pbnRYLCB5LCBtYXhTZWdtZW50TGVuZ3RoXTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gKiBAcGFyYW0ge0FycmF5PEFycmF5PG51bWJlcj4+fSBlbmRzcyBFbmRzcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q2VudGVycyBGbGF0IGNlbnRlcnMuXG4gKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBJbnRlcmlvciBwb2ludHMgYXMgWFlNIGNvb3JkaW5hdGVzLCB3aGVyZSBNIGlzIHRoZVxuICogbGVuZ3RoIG9mIHRoZSBob3Jpem9udGFsIGludGVyc2VjdGlvbiB0aGF0IHRoZSBwb2ludCBiZWxvbmdzIHRvLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0SW50ZXJpb3JQb2ludHNPZk11bHRpQXJyYXkoXG4gIGZsYXRDb29yZGluYXRlcyxcbiAgb2Zmc2V0LFxuICBlbmRzcyxcbiAgc3RyaWRlLFxuICBmbGF0Q2VudGVyc1xuKSB7XG4gIGxldCBpbnRlcmlvclBvaW50cyA9IFtdO1xuICBmb3IgKGxldCBpID0gMCwgaWkgPSBlbmRzcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgY29uc3QgZW5kcyA9IGVuZHNzW2ldO1xuICAgIGludGVyaW9yUG9pbnRzID0gZ2V0SW50ZXJpb3JQb2ludE9mQXJyYXkoXG4gICAgICBmbGF0Q29vcmRpbmF0ZXMsXG4gICAgICBvZmZzZXQsXG4gICAgICBlbmRzLFxuICAgICAgc3RyaWRlLFxuICAgICAgZmxhdENlbnRlcnMsXG4gICAgICAyICogaSxcbiAgICAgIGludGVyaW9yUG9pbnRzXG4gICAgKTtcbiAgICBvZmZzZXQgPSBlbmRzW2VuZHMubGVuZ3RoIC0gMV07XG4gIH1cbiAgcmV0dXJuIGludGVyaW9yUG9pbnRzO1xufVxuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2dlb20vZmxhdC9pbnRlcnBvbGF0ZVxuICovXG5pbXBvcnQge2JpbmFyeVNlYXJjaH0gZnJvbSAnLi4vLi4vYXJyYXkuanMnO1xuaW1wb3J0IHtsZXJwfSBmcm9tICcuLi8uLi9tYXRoLmpzJztcblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gKiBAcGFyYW0ge251bWJlcn0gZW5kIEVuZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHBhcmFtIHtudW1iZXJ9IGZyYWN0aW9uIEZyYWN0aW9uLlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBbZGVzdF0gRGVzdGluYXRpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gW2RpbWVuc2lvbl0gRGVzdGluYXRpb24gZGltZW5zaW9uIChkZWZhdWx0IGlzIGAyYClcbiAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IERlc3RpbmF0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaW50ZXJwb2xhdGVQb2ludChcbiAgZmxhdENvb3JkaW5hdGVzLFxuICBvZmZzZXQsXG4gIGVuZCxcbiAgc3RyaWRlLFxuICBmcmFjdGlvbixcbiAgZGVzdCxcbiAgZGltZW5zaW9uXG4pIHtcbiAgbGV0IG8sIHQ7XG4gIGNvbnN0IG4gPSAoZW5kIC0gb2Zmc2V0KSAvIHN0cmlkZTtcbiAgaWYgKG4gPT09IDEpIHtcbiAgICBvID0gb2Zmc2V0O1xuICB9IGVsc2UgaWYgKG4gPT09IDIpIHtcbiAgICBvID0gb2Zmc2V0O1xuICAgIHQgPSBmcmFjdGlvbjtcbiAgfSBlbHNlIGlmIChuICE9PSAwKSB7XG4gICAgbGV0IHgxID0gZmxhdENvb3JkaW5hdGVzW29mZnNldF07XG4gICAgbGV0IHkxID0gZmxhdENvb3JkaW5hdGVzW29mZnNldCArIDFdO1xuICAgIGxldCBsZW5ndGggPSAwO1xuICAgIGNvbnN0IGN1bXVsYXRpdmVMZW5ndGhzID0gWzBdO1xuICAgIGZvciAobGV0IGkgPSBvZmZzZXQgKyBzdHJpZGU7IGkgPCBlbmQ7IGkgKz0gc3RyaWRlKSB7XG4gICAgICBjb25zdCB4MiA9IGZsYXRDb29yZGluYXRlc1tpXTtcbiAgICAgIGNvbnN0IHkyID0gZmxhdENvb3JkaW5hdGVzW2kgKyAxXTtcbiAgICAgIGxlbmd0aCArPSBNYXRoLnNxcnQoKHgyIC0geDEpICogKHgyIC0geDEpICsgKHkyIC0geTEpICogKHkyIC0geTEpKTtcbiAgICAgIGN1bXVsYXRpdmVMZW5ndGhzLnB1c2gobGVuZ3RoKTtcbiAgICAgIHgxID0geDI7XG4gICAgICB5MSA9IHkyO1xuICAgIH1cbiAgICBjb25zdCB0YXJnZXQgPSBmcmFjdGlvbiAqIGxlbmd0aDtcbiAgICBjb25zdCBpbmRleCA9IGJpbmFyeVNlYXJjaChjdW11bGF0aXZlTGVuZ3RocywgdGFyZ2V0KTtcbiAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICB0ID1cbiAgICAgICAgKHRhcmdldCAtIGN1bXVsYXRpdmVMZW5ndGhzWy1pbmRleCAtIDJdKSAvXG4gICAgICAgIChjdW11bGF0aXZlTGVuZ3Roc1staW5kZXggLSAxXSAtIGN1bXVsYXRpdmVMZW5ndGhzWy1pbmRleCAtIDJdKTtcbiAgICAgIG8gPSBvZmZzZXQgKyAoLWluZGV4IC0gMikgKiBzdHJpZGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIG8gPSBvZmZzZXQgKyBpbmRleCAqIHN0cmlkZTtcbiAgICB9XG4gIH1cbiAgZGltZW5zaW9uID0gZGltZW5zaW9uID4gMSA/IGRpbWVuc2lvbiA6IDI7XG4gIGRlc3QgPSBkZXN0ID8gZGVzdCA6IG5ldyBBcnJheShkaW1lbnNpb24pO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGRpbWVuc2lvbjsgKytpKSB7XG4gICAgZGVzdFtpXSA9XG4gICAgICBvID09PSB1bmRlZmluZWRcbiAgICAgICAgPyBOYU5cbiAgICAgICAgOiB0ID09PSB1bmRlZmluZWRcbiAgICAgICAgPyBmbGF0Q29vcmRpbmF0ZXNbbyArIGldXG4gICAgICAgIDogbGVycChmbGF0Q29vcmRpbmF0ZXNbbyArIGldLCBmbGF0Q29vcmRpbmF0ZXNbbyArIHN0cmlkZSArIGldLCB0KTtcbiAgfVxuICByZXR1cm4gZGVzdDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gKiBAcGFyYW0ge251bWJlcn0gZW5kIEVuZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHBhcmFtIHtudW1iZXJ9IG0gTS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gZXh0cmFwb2xhdGUgRXh0cmFwb2xhdGUuXG4gKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi8uLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV8bnVsbH0gQ29vcmRpbmF0ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxpbmVTdHJpbmdDb29yZGluYXRlQXRNKFxuICBmbGF0Q29vcmRpbmF0ZXMsXG4gIG9mZnNldCxcbiAgZW5kLFxuICBzdHJpZGUsXG4gIG0sXG4gIGV4dHJhcG9sYXRlXG4pIHtcbiAgaWYgKGVuZCA9PSBvZmZzZXQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBsZXQgY29vcmRpbmF0ZTtcbiAgaWYgKG0gPCBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0ICsgc3RyaWRlIC0gMV0pIHtcbiAgICBpZiAoZXh0cmFwb2xhdGUpIHtcbiAgICAgIGNvb3JkaW5hdGUgPSBmbGF0Q29vcmRpbmF0ZXMuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBzdHJpZGUpO1xuICAgICAgY29vcmRpbmF0ZVtzdHJpZGUgLSAxXSA9IG07XG4gICAgICByZXR1cm4gY29vcmRpbmF0ZTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKGZsYXRDb29yZGluYXRlc1tlbmQgLSAxXSA8IG0pIHtcbiAgICBpZiAoZXh0cmFwb2xhdGUpIHtcbiAgICAgIGNvb3JkaW5hdGUgPSBmbGF0Q29vcmRpbmF0ZXMuc2xpY2UoZW5kIC0gc3RyaWRlLCBlbmQpO1xuICAgICAgY29vcmRpbmF0ZVtzdHJpZGUgLSAxXSA9IG07XG4gICAgICByZXR1cm4gY29vcmRpbmF0ZTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgLy8gRklYTUUgdXNlIE8oMSkgc2VhcmNoXG4gIGlmIChtID09IGZsYXRDb29yZGluYXRlc1tvZmZzZXQgKyBzdHJpZGUgLSAxXSkge1xuICAgIHJldHVybiBmbGF0Q29vcmRpbmF0ZXMuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBzdHJpZGUpO1xuICB9XG4gIGxldCBsbyA9IG9mZnNldCAvIHN0cmlkZTtcbiAgbGV0IGhpID0gZW5kIC8gc3RyaWRlO1xuICB3aGlsZSAobG8gPCBoaSkge1xuICAgIGNvbnN0IG1pZCA9IChsbyArIGhpKSA+PiAxO1xuICAgIGlmIChtIDwgZmxhdENvb3JkaW5hdGVzWyhtaWQgKyAxKSAqIHN0cmlkZSAtIDFdKSB7XG4gICAgICBoaSA9IG1pZDtcbiAgICB9IGVsc2Uge1xuICAgICAgbG8gPSBtaWQgKyAxO1xuICAgIH1cbiAgfVxuICBjb25zdCBtMCA9IGZsYXRDb29yZGluYXRlc1tsbyAqIHN0cmlkZSAtIDFdO1xuICBpZiAobSA9PSBtMCkge1xuICAgIHJldHVybiBmbGF0Q29vcmRpbmF0ZXMuc2xpY2UoKGxvIC0gMSkgKiBzdHJpZGUsIChsbyAtIDEpICogc3RyaWRlICsgc3RyaWRlKTtcbiAgfVxuICBjb25zdCBtMSA9IGZsYXRDb29yZGluYXRlc1sobG8gKyAxKSAqIHN0cmlkZSAtIDFdO1xuICBjb25zdCB0ID0gKG0gLSBtMCkgLyAobTEgLSBtMCk7XG4gIGNvb3JkaW5hdGUgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHJpZGUgLSAxOyArK2kpIHtcbiAgICBjb29yZGluYXRlLnB1c2goXG4gICAgICBsZXJwKFxuICAgICAgICBmbGF0Q29vcmRpbmF0ZXNbKGxvIC0gMSkgKiBzdHJpZGUgKyBpXSxcbiAgICAgICAgZmxhdENvb3JkaW5hdGVzW2xvICogc3RyaWRlICsgaV0sXG4gICAgICAgIHRcbiAgICAgIClcbiAgICApO1xuICB9XG4gIGNvb3JkaW5hdGUucHVzaChtKTtcbiAgcmV0dXJuIGNvb3JkaW5hdGU7XG59XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBlbmRzIEVuZHMuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtIE0uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGV4dHJhcG9sYXRlIEV4dHJhcG9sYXRlLlxuICogQHBhcmFtIHtib29sZWFufSBpbnRlcnBvbGF0ZSBJbnRlcnBvbGF0ZS5cbiAqIEByZXR1cm4ge2ltcG9ydChcIi4uLy4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZXxudWxsfSBDb29yZGluYXRlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbGluZVN0cmluZ3NDb29yZGluYXRlQXRNKFxuICBmbGF0Q29vcmRpbmF0ZXMsXG4gIG9mZnNldCxcbiAgZW5kcyxcbiAgc3RyaWRlLFxuICBtLFxuICBleHRyYXBvbGF0ZSxcbiAgaW50ZXJwb2xhdGVcbikge1xuICBpZiAoaW50ZXJwb2xhdGUpIHtcbiAgICByZXR1cm4gbGluZVN0cmluZ0Nvb3JkaW5hdGVBdE0oXG4gICAgICBmbGF0Q29vcmRpbmF0ZXMsXG4gICAgICBvZmZzZXQsXG4gICAgICBlbmRzW2VuZHMubGVuZ3RoIC0gMV0sXG4gICAgICBzdHJpZGUsXG4gICAgICBtLFxuICAgICAgZXh0cmFwb2xhdGVcbiAgICApO1xuICB9XG4gIGxldCBjb29yZGluYXRlO1xuICBpZiAobSA8IGZsYXRDb29yZGluYXRlc1tzdHJpZGUgLSAxXSkge1xuICAgIGlmIChleHRyYXBvbGF0ZSkge1xuICAgICAgY29vcmRpbmF0ZSA9IGZsYXRDb29yZGluYXRlcy5zbGljZSgwLCBzdHJpZGUpO1xuICAgICAgY29vcmRpbmF0ZVtzdHJpZGUgLSAxXSA9IG07XG4gICAgICByZXR1cm4gY29vcmRpbmF0ZTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKGZsYXRDb29yZGluYXRlc1tmbGF0Q29vcmRpbmF0ZXMubGVuZ3RoIC0gMV0gPCBtKSB7XG4gICAgaWYgKGV4dHJhcG9sYXRlKSB7XG4gICAgICBjb29yZGluYXRlID0gZmxhdENvb3JkaW5hdGVzLnNsaWNlKGZsYXRDb29yZGluYXRlcy5sZW5ndGggLSBzdHJpZGUpO1xuICAgICAgY29vcmRpbmF0ZVtzdHJpZGUgLSAxXSA9IG07XG4gICAgICByZXR1cm4gY29vcmRpbmF0ZTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDAsIGlpID0gZW5kcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgY29uc3QgZW5kID0gZW5kc1tpXTtcbiAgICBpZiAob2Zmc2V0ID09IGVuZCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChtIDwgZmxhdENvb3JkaW5hdGVzW29mZnNldCArIHN0cmlkZSAtIDFdKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKG0gPD0gZmxhdENvb3JkaW5hdGVzW2VuZCAtIDFdKSB7XG4gICAgICByZXR1cm4gbGluZVN0cmluZ0Nvb3JkaW5hdGVBdE0oXG4gICAgICAgIGZsYXRDb29yZGluYXRlcyxcbiAgICAgICAgb2Zmc2V0LFxuICAgICAgICBlbmQsXG4gICAgICAgIHN0cmlkZSxcbiAgICAgICAgbSxcbiAgICAgICAgZmFsc2VcbiAgICAgICk7XG4gICAgfVxuICAgIG9mZnNldCA9IGVuZDtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbiIsIi8qKlxuICogQG1vZHVsZSBvbC9nZW9tL2ZsYXQvaW50ZXJzZWN0c2V4dGVudFxuICovXG5pbXBvcnQge1xuICBjb250YWluc0V4dGVudCxcbiAgY3JlYXRlRW1wdHksXG4gIGV4dGVuZEZsYXRDb29yZGluYXRlcyxcbiAgaW50ZXJzZWN0cyxcbiAgaW50ZXJzZWN0c1NlZ21lbnQsXG59IGZyb20gJy4uLy4uL2V4dGVudC5qcyc7XG5pbXBvcnQge2ZvckVhY2ggYXMgZm9yRWFjaFNlZ21lbnR9IGZyb20gJy4vc2VnbWVudHMuanMnO1xuaW1wb3J0IHtsaW5lYXJSaW5nQ29udGFpbnNFeHRlbnQsIGxpbmVhclJpbmdDb250YWluc1hZfSBmcm9tICcuL2NvbnRhaW5zLmpzJztcblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gKiBAcGFyYW0ge251bWJlcn0gZW5kIEVuZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9leHRlbnQuanNcIikuRXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgZ2VvbWV0cnkgYW5kIHRoZSBleHRlbnQgaW50ZXJzZWN0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gaW50ZXJzZWN0c0xpbmVTdHJpbmcoXG4gIGZsYXRDb29yZGluYXRlcyxcbiAgb2Zmc2V0LFxuICBlbmQsXG4gIHN0cmlkZSxcbiAgZXh0ZW50XG4pIHtcbiAgY29uc3QgY29vcmRpbmF0ZXNFeHRlbnQgPSBleHRlbmRGbGF0Q29vcmRpbmF0ZXMoXG4gICAgY3JlYXRlRW1wdHkoKSxcbiAgICBmbGF0Q29vcmRpbmF0ZXMsXG4gICAgb2Zmc2V0LFxuICAgIGVuZCxcbiAgICBzdHJpZGVcbiAgKTtcbiAgaWYgKCFpbnRlcnNlY3RzKGV4dGVudCwgY29vcmRpbmF0ZXNFeHRlbnQpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChjb250YWluc0V4dGVudChleHRlbnQsIGNvb3JkaW5hdGVzRXh0ZW50KSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChjb29yZGluYXRlc0V4dGVudFswXSA+PSBleHRlbnRbMF0gJiYgY29vcmRpbmF0ZXNFeHRlbnRbMl0gPD0gZXh0ZW50WzJdKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGNvb3JkaW5hdGVzRXh0ZW50WzFdID49IGV4dGVudFsxXSAmJiBjb29yZGluYXRlc0V4dGVudFszXSA8PSBleHRlbnRbM10pIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZm9yRWFjaFNlZ21lbnQoXG4gICAgZmxhdENvb3JkaW5hdGVzLFxuICAgIG9mZnNldCxcbiAgICBlbmQsXG4gICAgc3RyaWRlLFxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBwb2ludDEgU3RhcnQgcG9pbnQuXG4gICAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IHBvaW50MiBFbmQgcG9pbnQuXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSBzZWdtZW50IGFuZCB0aGUgZXh0ZW50IGludGVyc2VjdCxcbiAgICAgKiAgICAgYGZhbHNlYCBvdGhlcndpc2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gKHBvaW50MSwgcG9pbnQyKSB7XG4gICAgICByZXR1cm4gaW50ZXJzZWN0c1NlZ21lbnQoZXh0ZW50LCBwb2ludDEsIHBvaW50Mik7XG4gICAgfVxuICApO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZW5kcyBFbmRzLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBnZW9tZXRyeSBhbmQgdGhlIGV4dGVudCBpbnRlcnNlY3QuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnRlcnNlY3RzTGluZVN0cmluZ0FycmF5KFxuICBmbGF0Q29vcmRpbmF0ZXMsXG4gIG9mZnNldCxcbiAgZW5kcyxcbiAgc3RyaWRlLFxuICBleHRlbnRcbikge1xuICBmb3IgKGxldCBpID0gMCwgaWkgPSBlbmRzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICBpZiAoXG4gICAgICBpbnRlcnNlY3RzTGluZVN0cmluZyhmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kc1tpXSwgc3RyaWRlLCBleHRlbnQpXG4gICAgKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgb2Zmc2V0ID0gZW5kc1tpXTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtudW1iZXJ9IGVuZCBFbmQuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGdlb21ldHJ5IGFuZCB0aGUgZXh0ZW50IGludGVyc2VjdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGludGVyc2VjdHNMaW5lYXJSaW5nKFxuICBmbGF0Q29vcmRpbmF0ZXMsXG4gIG9mZnNldCxcbiAgZW5kLFxuICBzdHJpZGUsXG4gIGV4dGVudFxuKSB7XG4gIGlmIChpbnRlcnNlY3RzTGluZVN0cmluZyhmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kLCBzdHJpZGUsIGV4dGVudCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoXG4gICAgbGluZWFyUmluZ0NvbnRhaW5zWFkoXG4gICAgICBmbGF0Q29vcmRpbmF0ZXMsXG4gICAgICBvZmZzZXQsXG4gICAgICBlbmQsXG4gICAgICBzdHJpZGUsXG4gICAgICBleHRlbnRbMF0sXG4gICAgICBleHRlbnRbMV1cbiAgICApXG4gICkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChcbiAgICBsaW5lYXJSaW5nQ29udGFpbnNYWShcbiAgICAgIGZsYXRDb29yZGluYXRlcyxcbiAgICAgIG9mZnNldCxcbiAgICAgIGVuZCxcbiAgICAgIHN0cmlkZSxcbiAgICAgIGV4dGVudFswXSxcbiAgICAgIGV4dGVudFszXVxuICAgIClcbiAgKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKFxuICAgIGxpbmVhclJpbmdDb250YWluc1hZKFxuICAgICAgZmxhdENvb3JkaW5hdGVzLFxuICAgICAgb2Zmc2V0LFxuICAgICAgZW5kLFxuICAgICAgc3RyaWRlLFxuICAgICAgZXh0ZW50WzJdLFxuICAgICAgZXh0ZW50WzFdXG4gICAgKVxuICApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoXG4gICAgbGluZWFyUmluZ0NvbnRhaW5zWFkoXG4gICAgICBmbGF0Q29vcmRpbmF0ZXMsXG4gICAgICBvZmZzZXQsXG4gICAgICBlbmQsXG4gICAgICBzdHJpZGUsXG4gICAgICBleHRlbnRbMl0sXG4gICAgICBleHRlbnRbM11cbiAgICApXG4gICkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGVuZHMgRW5kcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9leHRlbnQuanNcIikuRXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgZ2VvbWV0cnkgYW5kIHRoZSBleHRlbnQgaW50ZXJzZWN0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gaW50ZXJzZWN0c0xpbmVhclJpbmdBcnJheShcbiAgZmxhdENvb3JkaW5hdGVzLFxuICBvZmZzZXQsXG4gIGVuZHMsXG4gIHN0cmlkZSxcbiAgZXh0ZW50XG4pIHtcbiAgaWYgKCFpbnRlcnNlY3RzTGluZWFyUmluZyhmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kc1swXSwgc3RyaWRlLCBleHRlbnQpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChlbmRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGZvciAobGV0IGkgPSAxLCBpaSA9IGVuZHMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgIGlmIChcbiAgICAgIGxpbmVhclJpbmdDb250YWluc0V4dGVudChcbiAgICAgICAgZmxhdENvb3JkaW5hdGVzLFxuICAgICAgICBlbmRzW2kgLSAxXSxcbiAgICAgICAgZW5kc1tpXSxcbiAgICAgICAgc3RyaWRlLFxuICAgICAgICBleHRlbnRcbiAgICAgIClcbiAgICApIHtcbiAgICAgIGlmIChcbiAgICAgICAgIWludGVyc2VjdHNMaW5lU3RyaW5nKFxuICAgICAgICAgIGZsYXRDb29yZGluYXRlcyxcbiAgICAgICAgICBlbmRzW2kgLSAxXSxcbiAgICAgICAgICBlbmRzW2ldLFxuICAgICAgICAgIHN0cmlkZSxcbiAgICAgICAgICBleHRlbnRcbiAgICAgICAgKVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtBcnJheTxBcnJheTxudW1iZXI+Pn0gZW5kc3MgRW5kc3MuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGdlb21ldHJ5IGFuZCB0aGUgZXh0ZW50IGludGVyc2VjdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGludGVyc2VjdHNMaW5lYXJSaW5nTXVsdGlBcnJheShcbiAgZmxhdENvb3JkaW5hdGVzLFxuICBvZmZzZXQsXG4gIGVuZHNzLFxuICBzdHJpZGUsXG4gIGV4dGVudFxuKSB7XG4gIGZvciAobGV0IGkgPSAwLCBpaSA9IGVuZHNzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICBjb25zdCBlbmRzID0gZW5kc3NbaV07XG4gICAgaWYgKFxuICAgICAgaW50ZXJzZWN0c0xpbmVhclJpbmdBcnJheShmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kcywgc3RyaWRlLCBleHRlbnQpXG4gICAgKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgb2Zmc2V0ID0gZW5kc1tlbmRzLmxlbmd0aCAtIDFdO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbiIsIi8qKlxuICogQG1vZHVsZSBvbC9nZW9tL2ZsYXQvbGVuZ3RoXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gKiBAcGFyYW0ge251bWJlcn0gZW5kIEVuZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHJldHVybiB7bnVtYmVyfSBMZW5ndGguXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsaW5lU3RyaW5nTGVuZ3RoKGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmQsIHN0cmlkZSkge1xuICBsZXQgeDEgPSBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0XTtcbiAgbGV0IHkxID0gZmxhdENvb3JkaW5hdGVzW29mZnNldCArIDFdO1xuICBsZXQgbGVuZ3RoID0gMDtcbiAgZm9yIChsZXQgaSA9IG9mZnNldCArIHN0cmlkZTsgaSA8IGVuZDsgaSArPSBzdHJpZGUpIHtcbiAgICBjb25zdCB4MiA9IGZsYXRDb29yZGluYXRlc1tpXTtcbiAgICBjb25zdCB5MiA9IGZsYXRDb29yZGluYXRlc1tpICsgMV07XG4gICAgbGVuZ3RoICs9IE1hdGguc3FydCgoeDIgLSB4MSkgKiAoeDIgLSB4MSkgKyAoeTIgLSB5MSkgKiAoeTIgLSB5MSkpO1xuICAgIHgxID0geDI7XG4gICAgeTEgPSB5MjtcbiAgfVxuICByZXR1cm4gbGVuZ3RoO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgRW5kLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFBlcmltZXRlci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxpbmVhclJpbmdMZW5ndGgoZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZCwgc3RyaWRlKSB7XG4gIGxldCBwZXJpbWV0ZXIgPSBsaW5lU3RyaW5nTGVuZ3RoKGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmQsIHN0cmlkZSk7XG4gIGNvbnN0IGR4ID0gZmxhdENvb3JkaW5hdGVzW2VuZCAtIHN0cmlkZV0gLSBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0XTtcbiAgY29uc3QgZHkgPSBmbGF0Q29vcmRpbmF0ZXNbZW5kIC0gc3RyaWRlICsgMV0gLSBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0ICsgMV07XG4gIHBlcmltZXRlciArPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICByZXR1cm4gcGVyaW1ldGVyO1xufVxuIiwiaW1wb3J0IHtsZXJwfSBmcm9tICcuLi8uLi9tYXRoLmpzJztcblxuLyoqXG4gKiBDcmVhdGVzIGNodW5rcyBvZiBlcXVhbCBsZW5ndGggZnJvbSBhIGxpbmVzdHJpbmdcbiAqIEBwYXJhbSB7bnVtYmVyfSBjaHVua0xlbmd0aCBMZW5ndGggb2YgZWFjaCBjaHVuay5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IFN0YXJ0IG9mZnNldCBvZiB0aGUgYGZsYXRDb29yZGluYXRlc2AuXG4gKiBAcGFyYW0ge251bWJlcn0gZW5kIEVuZCBvZmZzZXQgb2YgdGhlIGBmbGF0Q29vcmRpbmF0ZXNgLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcmV0dXJuIHtBcnJheTxBcnJheTxudW1iZXI+Pn0gQ2h1bmtzIG9mIGxpbmVzdHJpbmdzIHdpdGggc3RyaWRlIDIuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsaW5lQ2h1bmsoY2h1bmtMZW5ndGgsIGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmQsIHN0cmlkZSkge1xuICBjb25zdCBjaHVua3MgPSBbXTtcbiAgbGV0IGN1cnNvciA9IG9mZnNldDtcbiAgbGV0IGNodW5rTSA9IDA7XG4gIGxldCBjdXJyZW50Q2h1bmsgPSBmbGF0Q29vcmRpbmF0ZXMuc2xpY2Uob2Zmc2V0LCAyKTtcbiAgd2hpbGUgKGNodW5rTSA8IGNodW5rTGVuZ3RoICYmIGN1cnNvciArIHN0cmlkZSA8IGVuZCkge1xuICAgIGNvbnN0IFt4MSwgeTFdID0gY3VycmVudENodW5rLnNsaWNlKC0yKTtcbiAgICBjb25zdCB4MiA9IGZsYXRDb29yZGluYXRlc1tjdXJzb3IgKyBzdHJpZGVdO1xuICAgIGNvbnN0IHkyID0gZmxhdENvb3JkaW5hdGVzW2N1cnNvciArIHN0cmlkZSArIDFdO1xuICAgIGNvbnN0IHNlZ21lbnRMZW5ndGggPSBNYXRoLnNxcnQoXG4gICAgICAoeDIgLSB4MSkgKiAoeDIgLSB4MSkgKyAoeTIgLSB5MSkgKiAoeTIgLSB5MSlcbiAgICApO1xuICAgIGNodW5rTSArPSBzZWdtZW50TGVuZ3RoO1xuICAgIGlmIChjaHVua00gPj0gY2h1bmtMZW5ndGgpIHtcbiAgICAgIGNvbnN0IG0gPSAoY2h1bmtMZW5ndGggLSBjaHVua00gKyBzZWdtZW50TGVuZ3RoKSAvIHNlZ21lbnRMZW5ndGg7XG4gICAgICBjb25zdCB4ID0gbGVycCh4MSwgeDIsIG0pO1xuICAgICAgY29uc3QgeSA9IGxlcnAoeTEsIHkyLCBtKTtcbiAgICAgIGN1cnJlbnRDaHVuay5wdXNoKHgsIHkpO1xuICAgICAgY2h1bmtzLnB1c2goY3VycmVudENodW5rKTtcbiAgICAgIGN1cnJlbnRDaHVuayA9IFt4LCB5XTtcbiAgICAgIGlmIChjaHVua00gPT0gY2h1bmtMZW5ndGgpIHtcbiAgICAgICAgY3Vyc29yICs9IHN0cmlkZTtcbiAgICAgIH1cbiAgICAgIGNodW5rTSA9IDA7XG4gICAgfSBlbHNlIGlmIChjaHVua00gPCBjaHVua0xlbmd0aCkge1xuICAgICAgY3VycmVudENodW5rLnB1c2goXG4gICAgICAgIGZsYXRDb29yZGluYXRlc1tjdXJzb3IgKyBzdHJpZGVdLFxuICAgICAgICBmbGF0Q29vcmRpbmF0ZXNbY3Vyc29yICsgc3RyaWRlICsgMV1cbiAgICAgICk7XG4gICAgICBjdXJzb3IgKz0gc3RyaWRlO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBtaXNzaW5nID0gc2VnbWVudExlbmd0aCAtIGNodW5rTTtcbiAgICAgIGNvbnN0IHggPSBsZXJwKHgxLCB4MiwgbWlzc2luZyAvIHNlZ21lbnRMZW5ndGgpO1xuICAgICAgY29uc3QgeSA9IGxlcnAoeTEsIHkyLCBtaXNzaW5nIC8gc2VnbWVudExlbmd0aCk7XG4gICAgICBjdXJyZW50Q2h1bmsucHVzaCh4LCB5KTtcbiAgICAgIGNodW5rcy5wdXNoKGN1cnJlbnRDaHVuayk7XG4gICAgICBjdXJyZW50Q2h1bmsgPSBbeCwgeV07XG4gICAgICBjaHVua00gPSAwO1xuICAgICAgY3Vyc29yICs9IHN0cmlkZTtcbiAgICB9XG4gIH1cbiAgaWYgKGNodW5rTSA+IDApIHtcbiAgICBjaHVua3MucHVzaChjdXJyZW50Q2h1bmspO1xuICB9XG4gIHJldHVybiBjaHVua3M7XG59XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvZ2VvbS9mbGF0L29yaWVudFxuICovXG5pbXBvcnQge2Nvb3JkaW5hdGVzIGFzIHJldmVyc2VDb29yZGluYXRlc30gZnJvbSAnLi9yZXZlcnNlLmpzJztcblxuLyoqXG4gKiBJcyB0aGUgbGluZWFyIHJpbmcgb3JpZW50ZWQgY2xvY2t3aXNlIGluIGEgY29vcmRpbmF0ZSBzeXN0ZW0gd2l0aCBhIGJvdHRvbS1sZWZ0XG4gKiBjb29yZGluYXRlIG9yaWdpbj8gRm9yIGEgY29vcmRpbmF0ZSBzeXN0ZW0gd2l0aCBhIHRvcC1sZWZ0IGNvb3JkaW5hdGUgb3JpZ2luLFxuICogdGhlIHJpbmcncyBvcmllbnRhdGlvbiBpcyBjbG9ja3dpc2Ugd2hlbiB0aGlzIGZ1bmN0aW9uIHJldHVybnMgZmFsc2UuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gKiBAcGFyYW0ge251bWJlcn0gZW5kIEVuZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHJldHVybiB7Ym9vbGVhbn0gSXMgY2xvY2t3aXNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbGluZWFyUmluZ0lzQ2xvY2t3aXNlKGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmQsIHN0cmlkZSkge1xuICAvLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3EvMTE2NTY0Ny9jbG9ja3dpc2UtbWV0aG9kIzExNjU5NDNcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL09TR2VvL2dkYWwvYmxvYi9tYXN0ZXIvZ2RhbC9vZ3Ivb2dybGluZWFycmluZy5jcHBcbiAgbGV0IGVkZ2UgPSAwO1xuICBsZXQgeDEgPSBmbGF0Q29vcmRpbmF0ZXNbZW5kIC0gc3RyaWRlXTtcbiAgbGV0IHkxID0gZmxhdENvb3JkaW5hdGVzW2VuZCAtIHN0cmlkZSArIDFdO1xuICBmb3IgKDsgb2Zmc2V0IDwgZW5kOyBvZmZzZXQgKz0gc3RyaWRlKSB7XG4gICAgY29uc3QgeDIgPSBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0XTtcbiAgICBjb25zdCB5MiA9IGZsYXRDb29yZGluYXRlc1tvZmZzZXQgKyAxXTtcbiAgICBlZGdlICs9ICh4MiAtIHgxKSAqICh5MiArIHkxKTtcbiAgICB4MSA9IHgyO1xuICAgIHkxID0geTI7XG4gIH1cbiAgcmV0dXJuIGVkZ2UgPT09IDAgPyB1bmRlZmluZWQgOiBlZGdlID4gMDtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIGxpbmVhciByaW5ncyBhcmUgb3JpZW50ZWQuICBCeSBkZWZhdWx0LCBsZWZ0LWhhbmQgb3JpZW50YXRpb25cbiAqIGlzIHRlc3RlZCAoZmlyc3QgcmluZyBtdXN0IGJlIGNsb2Nrd2lzZSwgcmVtYWluaW5nIHJpbmdzIGNvdW50ZXItY2xvY2t3aXNlKS5cbiAqIFRvIHRlc3QgZm9yIHJpZ2h0LWhhbmQgb3JpZW50YXRpb24sIHVzZSB0aGUgYHJpZ2h0YCBhcmd1bWVudC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGVuZHMgQXJyYXkgb2YgZW5kIGluZGV4ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JpZ2h0XSBUZXN0IGZvciByaWdodC1oYW5kIG9yaWVudGF0aW9uXG4gKiAgICAgKGNvdW50ZXItY2xvY2t3aXNlIGV4dGVyaW9yIHJpbmcgYW5kIGNsb2Nrd2lzZSBpbnRlcmlvciByaW5ncykuXG4gKiBAcmV0dXJuIHtib29sZWFufSBSaW5ncyBhcmUgY29ycmVjdGx5IG9yaWVudGVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbGluZWFyUmluZ3NBcmVPcmllbnRlZChcbiAgZmxhdENvb3JkaW5hdGVzLFxuICBvZmZzZXQsXG4gIGVuZHMsXG4gIHN0cmlkZSxcbiAgcmlnaHRcbikge1xuICByaWdodCA9IHJpZ2h0ICE9PSB1bmRlZmluZWQgPyByaWdodCA6IGZhbHNlO1xuICBmb3IgKGxldCBpID0gMCwgaWkgPSBlbmRzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICBjb25zdCBlbmQgPSBlbmRzW2ldO1xuICAgIGNvbnN0IGlzQ2xvY2t3aXNlID0gbGluZWFyUmluZ0lzQ2xvY2t3aXNlKFxuICAgICAgZmxhdENvb3JkaW5hdGVzLFxuICAgICAgb2Zmc2V0LFxuICAgICAgZW5kLFxuICAgICAgc3RyaWRlXG4gICAgKTtcbiAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgaWYgKChyaWdodCAmJiBpc0Nsb2Nrd2lzZSkgfHwgKCFyaWdodCAmJiAhaXNDbG9ja3dpc2UpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKChyaWdodCAmJiAhaXNDbG9ja3dpc2UpIHx8ICghcmlnaHQgJiYgaXNDbG9ja3dpc2UpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgb2Zmc2V0ID0gZW5kO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIERldGVybWluZXMgaWYgbGluZWFyIHJpbmdzIGFyZSBvcmllbnRlZC4gIEJ5IGRlZmF1bHQsIGxlZnQtaGFuZCBvcmllbnRhdGlvblxuICogaXMgdGVzdGVkIChmaXJzdCByaW5nIG11c3QgYmUgY2xvY2t3aXNlLCByZW1haW5pbmcgcmluZ3MgY291bnRlci1jbG9ja3dpc2UpLlxuICogVG8gdGVzdCBmb3IgcmlnaHQtaGFuZCBvcmllbnRhdGlvbiwgdXNlIHRoZSBgcmlnaHRgIGFyZ3VtZW50LlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8bnVtYmVyPj59IGVuZHNzIEFycmF5IG9mIGFycmF5IG9mIGVuZCBpbmRleGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtyaWdodF0gVGVzdCBmb3IgcmlnaHQtaGFuZCBvcmllbnRhdGlvblxuICogICAgIChjb3VudGVyLWNsb2Nrd2lzZSBleHRlcmlvciByaW5nIGFuZCBjbG9ja3dpc2UgaW50ZXJpb3IgcmluZ3MpLlxuICogQHJldHVybiB7Ym9vbGVhbn0gUmluZ3MgYXJlIGNvcnJlY3RseSBvcmllbnRlZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxpbmVhclJpbmdzc0FyZU9yaWVudGVkKFxuICBmbGF0Q29vcmRpbmF0ZXMsXG4gIG9mZnNldCxcbiAgZW5kc3MsXG4gIHN0cmlkZSxcbiAgcmlnaHRcbikge1xuICBmb3IgKGxldCBpID0gMCwgaWkgPSBlbmRzcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgY29uc3QgZW5kcyA9IGVuZHNzW2ldO1xuICAgIGlmICghbGluZWFyUmluZ3NBcmVPcmllbnRlZChmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kcywgc3RyaWRlLCByaWdodCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGVuZHMubGVuZ3RoKSB7XG4gICAgICBvZmZzZXQgPSBlbmRzW2VuZHMubGVuZ3RoIC0gMV07XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIE9yaWVudCBjb29yZGluYXRlcyBpbiBhIGZsYXQgYXJyYXkgb2YgbGluZWFyIHJpbmdzLiAgQnkgZGVmYXVsdCwgcmluZ3NcbiAqIGFyZSBvcmllbnRlZCBmb2xsb3dpbmcgdGhlIGxlZnQtaGFuZCBydWxlIChjbG9ja3dpc2UgZm9yIGV4dGVyaW9yIGFuZFxuICogY291bnRlci1jbG9ja3dpc2UgZm9yIGludGVyaW9yIHJpbmdzKS4gIFRvIG9yaWVudCBhY2NvcmRpbmcgdG8gdGhlXG4gKiByaWdodC1oYW5kIHJ1bGUsIHVzZSB0aGUgYHJpZ2h0YCBhcmd1bWVudC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGVuZHMgRW5kcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHBhcmFtIHtib29sZWFufSBbcmlnaHRdIEZvbGxvdyB0aGUgcmlnaHQtaGFuZCBydWxlIGZvciBvcmllbnRhdGlvbi5cbiAqIEByZXR1cm4ge251bWJlcn0gRW5kLlxuICovXG5leHBvcnQgZnVuY3Rpb24gb3JpZW50TGluZWFyUmluZ3MoXG4gIGZsYXRDb29yZGluYXRlcyxcbiAgb2Zmc2V0LFxuICBlbmRzLFxuICBzdHJpZGUsXG4gIHJpZ2h0XG4pIHtcbiAgcmlnaHQgPSByaWdodCAhPT0gdW5kZWZpbmVkID8gcmlnaHQgOiBmYWxzZTtcbiAgZm9yIChsZXQgaSA9IDAsIGlpID0gZW5kcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgY29uc3QgZW5kID0gZW5kc1tpXTtcbiAgICBjb25zdCBpc0Nsb2Nrd2lzZSA9IGxpbmVhclJpbmdJc0Nsb2Nrd2lzZShcbiAgICAgIGZsYXRDb29yZGluYXRlcyxcbiAgICAgIG9mZnNldCxcbiAgICAgIGVuZCxcbiAgICAgIHN0cmlkZVxuICAgICk7XG4gICAgY29uc3QgcmV2ZXJzZSA9XG4gICAgICBpID09PSAwXG4gICAgICAgID8gKHJpZ2h0ICYmIGlzQ2xvY2t3aXNlKSB8fCAoIXJpZ2h0ICYmICFpc0Nsb2Nrd2lzZSlcbiAgICAgICAgOiAocmlnaHQgJiYgIWlzQ2xvY2t3aXNlKSB8fCAoIXJpZ2h0ICYmIGlzQ2xvY2t3aXNlKTtcbiAgICBpZiAocmV2ZXJzZSkge1xuICAgICAgcmV2ZXJzZUNvb3JkaW5hdGVzKGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmQsIHN0cmlkZSk7XG4gICAgfVxuICAgIG9mZnNldCA9IGVuZDtcbiAgfVxuICByZXR1cm4gb2Zmc2V0O1xufVxuXG4vKipcbiAqIE9yaWVudCBjb29yZGluYXRlcyBpbiBhIGZsYXQgYXJyYXkgb2YgbGluZWFyIHJpbmdzLiAgQnkgZGVmYXVsdCwgcmluZ3NcbiAqIGFyZSBvcmllbnRlZCBmb2xsb3dpbmcgdGhlIGxlZnQtaGFuZCBydWxlIChjbG9ja3dpc2UgZm9yIGV4dGVyaW9yIGFuZFxuICogY291bnRlci1jbG9ja3dpc2UgZm9yIGludGVyaW9yIHJpbmdzKS4gIFRvIG9yaWVudCBhY2NvcmRpbmcgdG8gdGhlXG4gKiByaWdodC1oYW5kIHJ1bGUsIHVzZSB0aGUgYHJpZ2h0YCBhcmd1bWVudC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gKiBAcGFyYW0ge0FycmF5PEFycmF5PG51bWJlcj4+fSBlbmRzcyBBcnJheSBvZiBhcnJheSBvZiBlbmQgaW5kZXhlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHBhcmFtIHtib29sZWFufSBbcmlnaHRdIEZvbGxvdyB0aGUgcmlnaHQtaGFuZCBydWxlIGZvciBvcmllbnRhdGlvbi5cbiAqIEByZXR1cm4ge251bWJlcn0gRW5kLlxuICovXG5leHBvcnQgZnVuY3Rpb24gb3JpZW50TGluZWFyUmluZ3NBcnJheShcbiAgZmxhdENvb3JkaW5hdGVzLFxuICBvZmZzZXQsXG4gIGVuZHNzLFxuICBzdHJpZGUsXG4gIHJpZ2h0XG4pIHtcbiAgZm9yIChsZXQgaSA9IDAsIGlpID0gZW5kc3MubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgIG9mZnNldCA9IG9yaWVudExpbmVhclJpbmdzKFxuICAgICAgZmxhdENvb3JkaW5hdGVzLFxuICAgICAgb2Zmc2V0LFxuICAgICAgZW5kc3NbaV0sXG4gICAgICBzdHJpZGUsXG4gICAgICByaWdodFxuICAgICk7XG4gIH1cbiAgcmV0dXJuIG9mZnNldDtcbn1cblxuLyoqXG4gKiBSZXR1cm4gYSB0d28tZGltZW5zaW9uYWwgZW5kc3NcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXNcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZW5kcyBMaW5lYXIgcmluZyBlbmQgaW5kZXhlc1xuICogQHJldHVybiB7QXJyYXk8QXJyYXk8bnVtYmVyPj59IFR3byBkaW1lbnNpb25hbCBlbmRzcyBhcnJheSB0aGF0IGNhblxuICogYmUgdXNlZCB0byBjb25zdHJ1Y3QgYSBNdWx0aVBvbHlnb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGluZmxhdGVFbmRzKGZsYXRDb29yZGluYXRlcywgZW5kcykge1xuICBjb25zdCBlbmRzcyA9IFtdO1xuICBsZXQgb2Zmc2V0ID0gMDtcbiAgbGV0IHByZXZFbmRJbmRleCA9IDA7XG4gIGZvciAobGV0IGkgPSAwLCBpaSA9IGVuZHMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgIGNvbnN0IGVuZCA9IGVuZHNbaV07XG4gICAgLy8gY2xhc3NpZmllcyBhbiBhcnJheSBvZiByaW5ncyBpbnRvIHBvbHlnb25zIHdpdGggb3V0ZXIgcmluZ3MgYW5kIGhvbGVzXG4gICAgaWYgKCFsaW5lYXJSaW5nSXNDbG9ja3dpc2UoZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZCwgMikpIHtcbiAgICAgIGVuZHNzLnB1c2goZW5kcy5zbGljZShwcmV2RW5kSW5kZXgsIGkgKyAxKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChlbmRzcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBlbmRzc1tlbmRzcy5sZW5ndGggLSAxXS5wdXNoKGVuZHNbcHJldkVuZEluZGV4XSk7XG4gICAgfVxuICAgIHByZXZFbmRJbmRleCA9IGkgKyAxO1xuICAgIG9mZnNldCA9IGVuZDtcbiAgfVxuICByZXR1cm4gZW5kc3M7XG59XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvZ2VvbS9mbGF0L3JldmVyc2VcbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgRW5kLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb29yZGluYXRlcyhmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kLCBzdHJpZGUpIHtcbiAgd2hpbGUgKG9mZnNldCA8IGVuZCAtIHN0cmlkZSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyaWRlOyArK2kpIHtcbiAgICAgIGNvbnN0IHRtcCA9IGZsYXRDb29yZGluYXRlc1tvZmZzZXQgKyBpXTtcbiAgICAgIGZsYXRDb29yZGluYXRlc1tvZmZzZXQgKyBpXSA9IGZsYXRDb29yZGluYXRlc1tlbmQgLSBzdHJpZGUgKyBpXTtcbiAgICAgIGZsYXRDb29yZGluYXRlc1tlbmQgLSBzdHJpZGUgKyBpXSA9IHRtcDtcbiAgICB9XG4gICAgb2Zmc2V0ICs9IHN0cmlkZTtcbiAgICBlbmQgLT0gc3RyaWRlO1xuICB9XG59XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvZ2VvbS9mbGF0L3NlZ21lbnRzXG4gKi9cblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGNhbGxzIGBjYWxsYmFja2AgZm9yIGVhY2ggc2VnbWVudCBvZiB0aGUgZmxhdCBjb29yZGluYXRlc1xuICogYXJyYXkuIElmIHRoZSBjYWxsYmFjayByZXR1cm5zIGEgdHJ1dGh5IHZhbHVlIHRoZSBmdW5jdGlvbiByZXR1cm5zIHRoYXRcbiAqIHZhbHVlIGltbWVkaWF0ZWx5LiBPdGhlcndpc2UgdGhlIGZ1bmN0aW9uIHJldHVybnMgYGZhbHNlYC5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgRW5kLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKGltcG9ydChcIi4uLy4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZSwgaW1wb3J0KFwiLi4vLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlKTogVH0gY2FsbGJhY2sgRnVuY3Rpb25cbiAqICAgICBjYWxsZWQgZm9yIGVhY2ggc2VnbWVudC5cbiAqIEByZXR1cm4ge1R8Ym9vbGVhbn0gVmFsdWUuXG4gKiBAdGVtcGxhdGUgVFxuICovXG5leHBvcnQgZnVuY3Rpb24gZm9yRWFjaChmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kLCBzdHJpZGUsIGNhbGxiYWNrKSB7XG4gIGxldCByZXQ7XG4gIG9mZnNldCArPSBzdHJpZGU7XG4gIGZvciAoOyBvZmZzZXQgPCBlbmQ7IG9mZnNldCArPSBzdHJpZGUpIHtcbiAgICByZXQgPSBjYWxsYmFjayhcbiAgICAgIGZsYXRDb29yZGluYXRlcy5zbGljZShvZmZzZXQgLSBzdHJpZGUsIG9mZnNldCksXG4gICAgICBmbGF0Q29vcmRpbmF0ZXMuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBzdHJpZGUpXG4gICAgKTtcbiAgICBpZiAocmV0KSB7XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvZ2VvbS9mbGF0L3NpbXBsaWZ5XG4gKi9cbi8vIEJhc2VkIG9uIHNpbXBsaWZ5LWpzIGh0dHBzOi8vZ2l0aHViLmNvbS9tb3VybmVyL3NpbXBsaWZ5LWpzXG4vLyBDb3B5cmlnaHQgKGMpIDIwMTIsIFZsYWRpbWlyIEFnYWZvbmtpblxuLy8gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vXG4vLyBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbi8vIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuLy9cbi8vICAgIDEuIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcbi8vICAgICAgIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4vL1xuLy8gICAgMi4gUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHRcbi8vICAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGVcbi8vICAgICAgIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG4vL1xuLy8gVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCJcbi8vIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEVcbi8vIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFXG4vLyBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBIT0xERVIgT1IgQ09OVFJJQlVUT1JTIEJFXG4vLyBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SXG4vLyBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRlxuLy8gU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTXG4vLyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTlxuLy8gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSlcbi8vIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFXG4vLyBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cblxuaW1wb3J0IHtzcXVhcmVkRGlzdGFuY2UsIHNxdWFyZWRTZWdtZW50RGlzdGFuY2V9IGZyb20gJy4uLy4uL21hdGguanMnO1xuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgRW5kLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcGFyYW0ge251bWJlcn0gc3F1YXJlZFRvbGVyYW5jZSBTcXVhcmVkIHRvbGVyYW5jZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaGlnaFF1YWxpdHkgSGlnaGVzdCBxdWFsaXR5LlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBbc2ltcGxpZmllZEZsYXRDb29yZGluYXRlc10gU2ltcGxpZmllZCBmbGF0XG4gKiAgICAgY29vcmRpbmF0ZXMuXG4gKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBTaW1wbGlmaWVkIGxpbmUgc3RyaW5nLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2ltcGxpZnlMaW5lU3RyaW5nKFxuICBmbGF0Q29vcmRpbmF0ZXMsXG4gIG9mZnNldCxcbiAgZW5kLFxuICBzdHJpZGUsXG4gIHNxdWFyZWRUb2xlcmFuY2UsXG4gIGhpZ2hRdWFsaXR5LFxuICBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzXG4pIHtcbiAgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcyA9XG4gICAgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcyAhPT0gdW5kZWZpbmVkID8gc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcyA6IFtdO1xuICBpZiAoIWhpZ2hRdWFsaXR5KSB7XG4gICAgZW5kID0gcmFkaWFsRGlzdGFuY2UoXG4gICAgICBmbGF0Q29vcmRpbmF0ZXMsXG4gICAgICBvZmZzZXQsXG4gICAgICBlbmQsXG4gICAgICBzdHJpZGUsXG4gICAgICBzcXVhcmVkVG9sZXJhbmNlLFxuICAgICAgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcyxcbiAgICAgIDBcbiAgICApO1xuICAgIGZsYXRDb29yZGluYXRlcyA9IHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXM7XG4gICAgb2Zmc2V0ID0gMDtcbiAgICBzdHJpZGUgPSAyO1xuICB9XG4gIHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXMubGVuZ3RoID0gZG91Z2xhc1BldWNrZXIoXG4gICAgZmxhdENvb3JkaW5hdGVzLFxuICAgIG9mZnNldCxcbiAgICBlbmQsXG4gICAgc3RyaWRlLFxuICAgIHNxdWFyZWRUb2xlcmFuY2UsXG4gICAgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcyxcbiAgICAwXG4gICk7XG4gIHJldHVybiBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgRW5kLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcGFyYW0ge251bWJlcn0gc3F1YXJlZFRvbGVyYW5jZSBTcXVhcmVkIHRvbGVyYW5jZS5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcyBTaW1wbGlmaWVkIGZsYXRcbiAqICAgICBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzaW1wbGlmaWVkT2Zmc2V0IFNpbXBsaWZpZWQgb2Zmc2V0LlxuICogQHJldHVybiB7bnVtYmVyfSBTaW1wbGlmaWVkIG9mZnNldC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRvdWdsYXNQZXVja2VyKFxuICBmbGF0Q29vcmRpbmF0ZXMsXG4gIG9mZnNldCxcbiAgZW5kLFxuICBzdHJpZGUsXG4gIHNxdWFyZWRUb2xlcmFuY2UsXG4gIHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXMsXG4gIHNpbXBsaWZpZWRPZmZzZXRcbikge1xuICBjb25zdCBuID0gKGVuZCAtIG9mZnNldCkgLyBzdHJpZGU7XG4gIGlmIChuIDwgMykge1xuICAgIGZvciAoOyBvZmZzZXQgPCBlbmQ7IG9mZnNldCArPSBzdHJpZGUpIHtcbiAgICAgIHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXNbc2ltcGxpZmllZE9mZnNldCsrXSA9IGZsYXRDb29yZGluYXRlc1tvZmZzZXRdO1xuICAgICAgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlc1tzaW1wbGlmaWVkT2Zmc2V0KytdID1cbiAgICAgICAgZmxhdENvb3JkaW5hdGVzW29mZnNldCArIDFdO1xuICAgIH1cbiAgICByZXR1cm4gc2ltcGxpZmllZE9mZnNldDtcbiAgfVxuICAvKiogQHR5cGUge0FycmF5PG51bWJlcj59ICovXG4gIGNvbnN0IG1hcmtlcnMgPSBuZXcgQXJyYXkobik7XG4gIG1hcmtlcnNbMF0gPSAxO1xuICBtYXJrZXJzW24gLSAxXSA9IDE7XG4gIC8qKiBAdHlwZSB7QXJyYXk8bnVtYmVyPn0gKi9cbiAgY29uc3Qgc3RhY2sgPSBbb2Zmc2V0LCBlbmQgLSBzdHJpZGVdO1xuICBsZXQgaW5kZXggPSAwO1xuICB3aGlsZSAoc3RhY2subGVuZ3RoID4gMCkge1xuICAgIGNvbnN0IGxhc3QgPSBzdGFjay5wb3AoKTtcbiAgICBjb25zdCBmaXJzdCA9IHN0YWNrLnBvcCgpO1xuICAgIGxldCBtYXhTcXVhcmVkRGlzdGFuY2UgPSAwO1xuICAgIGNvbnN0IHgxID0gZmxhdENvb3JkaW5hdGVzW2ZpcnN0XTtcbiAgICBjb25zdCB5MSA9IGZsYXRDb29yZGluYXRlc1tmaXJzdCArIDFdO1xuICAgIGNvbnN0IHgyID0gZmxhdENvb3JkaW5hdGVzW2xhc3RdO1xuICAgIGNvbnN0IHkyID0gZmxhdENvb3JkaW5hdGVzW2xhc3QgKyAxXTtcbiAgICBmb3IgKGxldCBpID0gZmlyc3QgKyBzdHJpZGU7IGkgPCBsYXN0OyBpICs9IHN0cmlkZSkge1xuICAgICAgY29uc3QgeCA9IGZsYXRDb29yZGluYXRlc1tpXTtcbiAgICAgIGNvbnN0IHkgPSBmbGF0Q29vcmRpbmF0ZXNbaSArIDFdO1xuICAgICAgY29uc3Qgc3F1YXJlZERpc3RhbmNlID0gc3F1YXJlZFNlZ21lbnREaXN0YW5jZSh4LCB5LCB4MSwgeTEsIHgyLCB5Mik7XG4gICAgICBpZiAoc3F1YXJlZERpc3RhbmNlID4gbWF4U3F1YXJlZERpc3RhbmNlKSB7XG4gICAgICAgIGluZGV4ID0gaTtcbiAgICAgICAgbWF4U3F1YXJlZERpc3RhbmNlID0gc3F1YXJlZERpc3RhbmNlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobWF4U3F1YXJlZERpc3RhbmNlID4gc3F1YXJlZFRvbGVyYW5jZSkge1xuICAgICAgbWFya2Vyc1soaW5kZXggLSBvZmZzZXQpIC8gc3RyaWRlXSA9IDE7XG4gICAgICBpZiAoZmlyc3QgKyBzdHJpZGUgPCBpbmRleCkge1xuICAgICAgICBzdGFjay5wdXNoKGZpcnN0LCBpbmRleCk7XG4gICAgICB9XG4gICAgICBpZiAoaW5kZXggKyBzdHJpZGUgPCBsYXN0KSB7XG4gICAgICAgIHN0YWNrLnB1c2goaW5kZXgsIGxhc3QpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgIGlmIChtYXJrZXJzW2ldKSB7XG4gICAgICBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzW3NpbXBsaWZpZWRPZmZzZXQrK10gPVxuICAgICAgICBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0ICsgaSAqIHN0cmlkZV07XG4gICAgICBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzW3NpbXBsaWZpZWRPZmZzZXQrK10gPVxuICAgICAgICBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0ICsgaSAqIHN0cmlkZSArIDFdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc2ltcGxpZmllZE9mZnNldDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGVuZHMgRW5kcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHBhcmFtIHtudW1iZXJ9IHNxdWFyZWRUb2xlcmFuY2UgU3F1YXJlZCB0b2xlcmFuY2UuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXMgU2ltcGxpZmllZCBmbGF0XG4gKiAgICAgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gc2ltcGxpZmllZE9mZnNldCBTaW1wbGlmaWVkIG9mZnNldC5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gc2ltcGxpZmllZEVuZHMgU2ltcGxpZmllZCBlbmRzLlxuICogQHJldHVybiB7bnVtYmVyfSBTaW1wbGlmaWVkIG9mZnNldC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRvdWdsYXNQZXVja2VyQXJyYXkoXG4gIGZsYXRDb29yZGluYXRlcyxcbiAgb2Zmc2V0LFxuICBlbmRzLFxuICBzdHJpZGUsXG4gIHNxdWFyZWRUb2xlcmFuY2UsXG4gIHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXMsXG4gIHNpbXBsaWZpZWRPZmZzZXQsXG4gIHNpbXBsaWZpZWRFbmRzXG4pIHtcbiAgZm9yIChsZXQgaSA9IDAsIGlpID0gZW5kcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgY29uc3QgZW5kID0gZW5kc1tpXTtcbiAgICBzaW1wbGlmaWVkT2Zmc2V0ID0gZG91Z2xhc1BldWNrZXIoXG4gICAgICBmbGF0Q29vcmRpbmF0ZXMsXG4gICAgICBvZmZzZXQsXG4gICAgICBlbmQsXG4gICAgICBzdHJpZGUsXG4gICAgICBzcXVhcmVkVG9sZXJhbmNlLFxuICAgICAgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcyxcbiAgICAgIHNpbXBsaWZpZWRPZmZzZXRcbiAgICApO1xuICAgIHNpbXBsaWZpZWRFbmRzLnB1c2goc2ltcGxpZmllZE9mZnNldCk7XG4gICAgb2Zmc2V0ID0gZW5kO1xuICB9XG4gIHJldHVybiBzaW1wbGlmaWVkT2Zmc2V0O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8bnVtYmVyPj59IGVuZHNzIEVuZHNzLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcGFyYW0ge251bWJlcn0gc3F1YXJlZFRvbGVyYW5jZSBTcXVhcmVkIHRvbGVyYW5jZS5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcyBTaW1wbGlmaWVkIGZsYXRcbiAqICAgICBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzaW1wbGlmaWVkT2Zmc2V0IFNpbXBsaWZpZWQgb2Zmc2V0LlxuICogQHBhcmFtIHtBcnJheTxBcnJheTxudW1iZXI+Pn0gc2ltcGxpZmllZEVuZHNzIFNpbXBsaWZpZWQgZW5kc3MuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFNpbXBsaWZpZWQgb2Zmc2V0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZG91Z2xhc1BldWNrZXJNdWx0aUFycmF5KFxuICBmbGF0Q29vcmRpbmF0ZXMsXG4gIG9mZnNldCxcbiAgZW5kc3MsXG4gIHN0cmlkZSxcbiAgc3F1YXJlZFRvbGVyYW5jZSxcbiAgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcyxcbiAgc2ltcGxpZmllZE9mZnNldCxcbiAgc2ltcGxpZmllZEVuZHNzXG4pIHtcbiAgZm9yIChsZXQgaSA9IDAsIGlpID0gZW5kc3MubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgIGNvbnN0IGVuZHMgPSBlbmRzc1tpXTtcbiAgICBjb25zdCBzaW1wbGlmaWVkRW5kcyA9IFtdO1xuICAgIHNpbXBsaWZpZWRPZmZzZXQgPSBkb3VnbGFzUGV1Y2tlckFycmF5KFxuICAgICAgZmxhdENvb3JkaW5hdGVzLFxuICAgICAgb2Zmc2V0LFxuICAgICAgZW5kcyxcbiAgICAgIHN0cmlkZSxcbiAgICAgIHNxdWFyZWRUb2xlcmFuY2UsXG4gICAgICBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzLFxuICAgICAgc2ltcGxpZmllZE9mZnNldCxcbiAgICAgIHNpbXBsaWZpZWRFbmRzXG4gICAgKTtcbiAgICBzaW1wbGlmaWVkRW5kc3MucHVzaChzaW1wbGlmaWVkRW5kcyk7XG4gICAgb2Zmc2V0ID0gZW5kc1tlbmRzLmxlbmd0aCAtIDFdO1xuICB9XG4gIHJldHVybiBzaW1wbGlmaWVkT2Zmc2V0O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgRW5kLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcGFyYW0ge251bWJlcn0gc3F1YXJlZFRvbGVyYW5jZSBTcXVhcmVkIHRvbGVyYW5jZS5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcyBTaW1wbGlmaWVkIGZsYXRcbiAqICAgICBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzaW1wbGlmaWVkT2Zmc2V0IFNpbXBsaWZpZWQgb2Zmc2V0LlxuICogQHJldHVybiB7bnVtYmVyfSBTaW1wbGlmaWVkIG9mZnNldC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJhZGlhbERpc3RhbmNlKFxuICBmbGF0Q29vcmRpbmF0ZXMsXG4gIG9mZnNldCxcbiAgZW5kLFxuICBzdHJpZGUsXG4gIHNxdWFyZWRUb2xlcmFuY2UsXG4gIHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXMsXG4gIHNpbXBsaWZpZWRPZmZzZXRcbikge1xuICBpZiAoZW5kIDw9IG9mZnNldCArIHN0cmlkZSkge1xuICAgIC8vIHplcm8gb3Igb25lIHBvaW50LCBubyBzaW1wbGlmaWNhdGlvbiBwb3NzaWJsZSwgc28gY29weSBhbmQgcmV0dXJuXG4gICAgZm9yICg7IG9mZnNldCA8IGVuZDsgb2Zmc2V0ICs9IHN0cmlkZSkge1xuICAgICAgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlc1tzaW1wbGlmaWVkT2Zmc2V0KytdID0gZmxhdENvb3JkaW5hdGVzW29mZnNldF07XG4gICAgICBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzW3NpbXBsaWZpZWRPZmZzZXQrK10gPVxuICAgICAgICBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0ICsgMV07XG4gICAgfVxuICAgIHJldHVybiBzaW1wbGlmaWVkT2Zmc2V0O1xuICB9XG4gIGxldCB4MSA9IGZsYXRDb29yZGluYXRlc1tvZmZzZXRdO1xuICBsZXQgeTEgPSBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0ICsgMV07XG4gIC8vIGNvcHkgZmlyc3QgcG9pbnRcbiAgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlc1tzaW1wbGlmaWVkT2Zmc2V0KytdID0geDE7XG4gIHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXNbc2ltcGxpZmllZE9mZnNldCsrXSA9IHkxO1xuICBsZXQgeDIgPSB4MTtcbiAgbGV0IHkyID0geTE7XG4gIGZvciAob2Zmc2V0ICs9IHN0cmlkZTsgb2Zmc2V0IDwgZW5kOyBvZmZzZXQgKz0gc3RyaWRlKSB7XG4gICAgeDIgPSBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0XTtcbiAgICB5MiA9IGZsYXRDb29yZGluYXRlc1tvZmZzZXQgKyAxXTtcbiAgICBpZiAoc3F1YXJlZERpc3RhbmNlKHgxLCB5MSwgeDIsIHkyKSA+IHNxdWFyZWRUb2xlcmFuY2UpIHtcbiAgICAgIC8vIGNvcHkgcG9pbnQgYXQgb2Zmc2V0XG4gICAgICBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzW3NpbXBsaWZpZWRPZmZzZXQrK10gPSB4MjtcbiAgICAgIHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXNbc2ltcGxpZmllZE9mZnNldCsrXSA9IHkyO1xuICAgICAgeDEgPSB4MjtcbiAgICAgIHkxID0geTI7XG4gICAgfVxuICB9XG4gIGlmICh4MiAhPSB4MSB8fCB5MiAhPSB5MSkge1xuICAgIC8vIGNvcHkgbGFzdCBwb2ludFxuICAgIHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXNbc2ltcGxpZmllZE9mZnNldCsrXSA9IHgyO1xuICAgIHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXNbc2ltcGxpZmllZE9mZnNldCsrXSA9IHkyO1xuICB9XG4gIHJldHVybiBzaW1wbGlmaWVkT2Zmc2V0O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB0b2xlcmFuY2UgVG9sZXJhbmNlLlxuICogQHJldHVybiB7bnVtYmVyfSBSb3VuZGVkIHZhbHVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc25hcCh2YWx1ZSwgdG9sZXJhbmNlKSB7XG4gIHJldHVybiB0b2xlcmFuY2UgKiBNYXRoLnJvdW5kKHZhbHVlIC8gdG9sZXJhbmNlKTtcbn1cblxuLyoqXG4gKiBTaW1wbGlmaWVzIGEgbGluZSBzdHJpbmcgdXNpbmcgYW4gYWxnb3JpdGhtIGRlc2lnbmVkIGJ5IFRpbSBTY2hhdWIuXG4gKiBDb29yZGluYXRlcyBhcmUgc25hcHBlZCB0byB0aGUgbmVhcmVzdCB2YWx1ZSBpbiBhIHZpcnR1YWwgZ3JpZCBhbmRcbiAqIGNvbnNlY3V0aXZlIGR1cGxpY2F0ZSBjb29yZGluYXRlcyBhcmUgZGlzY2FyZGVkLiAgVGhpcyBlZmZlY3RpdmVseSBwcmVzZXJ2ZXNcbiAqIHRvcG9sb2d5IGFzIHRoZSBzaW1wbGlmaWNhdGlvbiBvZiBhbnkgc3Vic2VjdGlvbiBvZiBhIGxpbmUgc3RyaW5nIGlzXG4gKiBpbmRlcGVuZGVudCBvZiB0aGUgcmVzdCBvZiB0aGUgbGluZSBzdHJpbmcuICBUaGlzIG1lYW5zIHRoYXQsIGZvciBleGFtcGxlcyxcbiAqIHRoZSBjb21tb24gZWRnZSBiZXR3ZWVuIHR3byBwb2x5Z29ucyB3aWxsIGJlIHNpbXBsaWZpZWQgdG8gdGhlIHNhbWUgbGluZVxuICogc3RyaW5nIGluZGVwZW5kZW50bHkgaW4gYm90aCBwb2x5Z29ucy4gIFRoaXMgaW1wbGVtZW50YXRpb24gdXNlcyBhIHNpbmdsZVxuICogcGFzcyBvdmVyIHRoZSBjb29yZGluYXRlcyBhbmQgZWxpbWluYXRlcyBpbnRlcm1lZGlhdGUgY29sbGluZWFyIHBvaW50cy5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgRW5kLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcGFyYW0ge251bWJlcn0gdG9sZXJhbmNlIFRvbGVyYW5jZS5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcyBTaW1wbGlmaWVkIGZsYXRcbiAqICAgICBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzaW1wbGlmaWVkT2Zmc2V0IFNpbXBsaWZpZWQgb2Zmc2V0LlxuICogQHJldHVybiB7bnVtYmVyfSBTaW1wbGlmaWVkIG9mZnNldC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHF1YW50aXplKFxuICBmbGF0Q29vcmRpbmF0ZXMsXG4gIG9mZnNldCxcbiAgZW5kLFxuICBzdHJpZGUsXG4gIHRvbGVyYW5jZSxcbiAgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcyxcbiAgc2ltcGxpZmllZE9mZnNldFxuKSB7XG4gIC8vIGRvIG5vdGhpbmcgaWYgdGhlIGxpbmUgaXMgZW1wdHlcbiAgaWYgKG9mZnNldCA9PSBlbmQpIHtcbiAgICByZXR1cm4gc2ltcGxpZmllZE9mZnNldDtcbiAgfVxuICAvLyBzbmFwIHRoZSBmaXJzdCBjb29yZGluYXRlIChQMSlcbiAgbGV0IHgxID0gc25hcChmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0XSwgdG9sZXJhbmNlKTtcbiAgbGV0IHkxID0gc25hcChmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0ICsgMV0sIHRvbGVyYW5jZSk7XG4gIG9mZnNldCArPSBzdHJpZGU7XG4gIC8vIGFkZCB0aGUgZmlyc3QgY29vcmRpbmF0ZSB0byB0aGUgb3V0cHV0XG4gIHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXNbc2ltcGxpZmllZE9mZnNldCsrXSA9IHgxO1xuICBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzW3NpbXBsaWZpZWRPZmZzZXQrK10gPSB5MTtcbiAgLy8gZmluZCB0aGUgbmV4dCBjb29yZGluYXRlIHRoYXQgZG9lcyBub3Qgc25hcCB0byB0aGUgc2FtZSB2YWx1ZSBhcyB0aGUgZmlyc3RcbiAgLy8gY29vcmRpbmF0ZSAoUDIpXG4gIGxldCB4MiwgeTI7XG4gIGRvIHtcbiAgICB4MiA9IHNuYXAoZmxhdENvb3JkaW5hdGVzW29mZnNldF0sIHRvbGVyYW5jZSk7XG4gICAgeTIgPSBzbmFwKGZsYXRDb29yZGluYXRlc1tvZmZzZXQgKyAxXSwgdG9sZXJhbmNlKTtcbiAgICBvZmZzZXQgKz0gc3RyaWRlO1xuICAgIGlmIChvZmZzZXQgPT0gZW5kKSB7XG4gICAgICAvLyBhbGwgY29vcmRpbmF0ZXMgc25hcCB0byB0aGUgc2FtZSB2YWx1ZSwgdGhlIGxpbmUgY29sbGFwc2VzIHRvIGEgcG9pbnRcbiAgICAgIC8vIHB1c2ggdGhlIGxhc3Qgc25hcHBlZCB2YWx1ZSBhbnl3YXkgdG8gZW5zdXJlIHRoYXQgdGhlIG91dHB1dCBjb250YWluc1xuICAgICAgLy8gYXQgbGVhc3QgdHdvIHBvaW50c1xuICAgICAgLy8gRklYTUUgc2hvdWxkIHdlIHJlYWxseSByZXR1cm4gYXQgbGVhc3QgdHdvIHBvaW50cyBhbnl3YXk/XG4gICAgICBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzW3NpbXBsaWZpZWRPZmZzZXQrK10gPSB4MjtcbiAgICAgIHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXNbc2ltcGxpZmllZE9mZnNldCsrXSA9IHkyO1xuICAgICAgcmV0dXJuIHNpbXBsaWZpZWRPZmZzZXQ7XG4gICAgfVxuICB9IHdoaWxlICh4MiA9PSB4MSAmJiB5MiA9PSB5MSk7XG4gIHdoaWxlIChvZmZzZXQgPCBlbmQpIHtcbiAgICAvLyBzbmFwIHRoZSBuZXh0IGNvb3JkaW5hdGUgKFAzKVxuICAgIGNvbnN0IHgzID0gc25hcChmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0XSwgdG9sZXJhbmNlKTtcbiAgICBjb25zdCB5MyA9IHNuYXAoZmxhdENvb3JkaW5hdGVzW29mZnNldCArIDFdLCB0b2xlcmFuY2UpO1xuICAgIG9mZnNldCArPSBzdHJpZGU7XG4gICAgLy8gc2tpcCBQMyBpZiBpdCBpcyBlcXVhbCB0byBQMlxuICAgIGlmICh4MyA9PSB4MiAmJiB5MyA9PSB5Mikge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIC8vIGNhbGN1bGF0ZSB0aGUgZGVsdGEgYmV0d2VlbiBQMSBhbmQgUDJcbiAgICBjb25zdCBkeDEgPSB4MiAtIHgxO1xuICAgIGNvbnN0IGR5MSA9IHkyIC0geTE7XG4gICAgLy8gY2FsY3VsYXRlIHRoZSBkZWx0YSBiZXR3ZWVuIFAzIGFuZCBQMVxuICAgIGNvbnN0IGR4MiA9IHgzIC0geDE7XG4gICAgY29uc3QgZHkyID0geTMgLSB5MTtcbiAgICAvLyBpZiBQMSwgUDIsIGFuZCBQMyBhcmUgY29saW5lYXIgYW5kIFAzIGlzIGZ1cnRoZXIgZnJvbSBQMSB0aGFuIFAyIGlzIGZyb21cbiAgICAvLyBQMSBpbiB0aGUgc2FtZSBkaXJlY3Rpb24gdGhlbiBQMiBpcyBvbiB0aGUgc3RyYWlnaHQgbGluZSBiZXR3ZWVuIFAxIGFuZFxuICAgIC8vIFAzXG4gICAgaWYgKFxuICAgICAgZHgxICogZHkyID09IGR5MSAqIGR4MiAmJlxuICAgICAgKChkeDEgPCAwICYmIGR4MiA8IGR4MSkgfHwgZHgxID09IGR4MiB8fCAoZHgxID4gMCAmJiBkeDIgPiBkeDEpKSAmJlxuICAgICAgKChkeTEgPCAwICYmIGR5MiA8IGR5MSkgfHwgZHkxID09IGR5MiB8fCAoZHkxID4gMCAmJiBkeTIgPiBkeTEpKVxuICAgICkge1xuICAgICAgLy8gZGlzY2FyZCBQMiBhbmQgc2V0IFAyID0gUDNcbiAgICAgIHgyID0geDM7XG4gICAgICB5MiA9IHkzO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIC8vIGVpdGhlciBQMSwgUDIsIGFuZCBQMyBhcmUgbm90IGNvbGluZWFyLCBvciB0aGV5IGFyZSBjb2xpbmVhciBidXQgUDMgaXNcbiAgICAvLyBiZXR3ZWVuIFAzIGFuZCBQMSBvciBvbiB0aGUgb3Bwb3NpdGUgaGFsZiBvZiB0aGUgbGluZSB0byBQMi4gIGFkZCBQMixcbiAgICAvLyBhbmQgY29udGludWUgd2l0aCBQMSA9IFAyIGFuZCBQMiA9IFAzXG4gICAgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlc1tzaW1wbGlmaWVkT2Zmc2V0KytdID0geDI7XG4gICAgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlc1tzaW1wbGlmaWVkT2Zmc2V0KytdID0geTI7XG4gICAgeDEgPSB4MjtcbiAgICB5MSA9IHkyO1xuICAgIHgyID0geDM7XG4gICAgeTIgPSB5MztcbiAgfVxuICAvLyBhZGQgdGhlIGxhc3QgcG9pbnQgKFAyKVxuICBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzW3NpbXBsaWZpZWRPZmZzZXQrK10gPSB4MjtcbiAgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlc1tzaW1wbGlmaWVkT2Zmc2V0KytdID0geTI7XG4gIHJldHVybiBzaW1wbGlmaWVkT2Zmc2V0O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZW5kcyBFbmRzLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcGFyYW0ge251bWJlcn0gdG9sZXJhbmNlIFRvbGVyYW5jZS5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcyBTaW1wbGlmaWVkIGZsYXRcbiAqICAgICBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzaW1wbGlmaWVkT2Zmc2V0IFNpbXBsaWZpZWQgb2Zmc2V0LlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBzaW1wbGlmaWVkRW5kcyBTaW1wbGlmaWVkIGVuZHMuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFNpbXBsaWZpZWQgb2Zmc2V0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gcXVhbnRpemVBcnJheShcbiAgZmxhdENvb3JkaW5hdGVzLFxuICBvZmZzZXQsXG4gIGVuZHMsXG4gIHN0cmlkZSxcbiAgdG9sZXJhbmNlLFxuICBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzLFxuICBzaW1wbGlmaWVkT2Zmc2V0LFxuICBzaW1wbGlmaWVkRW5kc1xuKSB7XG4gIGZvciAobGV0IGkgPSAwLCBpaSA9IGVuZHMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgIGNvbnN0IGVuZCA9IGVuZHNbaV07XG4gICAgc2ltcGxpZmllZE9mZnNldCA9IHF1YW50aXplKFxuICAgICAgZmxhdENvb3JkaW5hdGVzLFxuICAgICAgb2Zmc2V0LFxuICAgICAgZW5kLFxuICAgICAgc3RyaWRlLFxuICAgICAgdG9sZXJhbmNlLFxuICAgICAgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcyxcbiAgICAgIHNpbXBsaWZpZWRPZmZzZXRcbiAgICApO1xuICAgIHNpbXBsaWZpZWRFbmRzLnB1c2goc2ltcGxpZmllZE9mZnNldCk7XG4gICAgb2Zmc2V0ID0gZW5kO1xuICB9XG4gIHJldHVybiBzaW1wbGlmaWVkT2Zmc2V0O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8bnVtYmVyPj59IGVuZHNzIEVuZHNzLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcGFyYW0ge251bWJlcn0gdG9sZXJhbmNlIFRvbGVyYW5jZS5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcyBTaW1wbGlmaWVkIGZsYXRcbiAqICAgICBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzaW1wbGlmaWVkT2Zmc2V0IFNpbXBsaWZpZWQgb2Zmc2V0LlxuICogQHBhcmFtIHtBcnJheTxBcnJheTxudW1iZXI+Pn0gc2ltcGxpZmllZEVuZHNzIFNpbXBsaWZpZWQgZW5kc3MuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFNpbXBsaWZpZWQgb2Zmc2V0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gcXVhbnRpemVNdWx0aUFycmF5KFxuICBmbGF0Q29vcmRpbmF0ZXMsXG4gIG9mZnNldCxcbiAgZW5kc3MsXG4gIHN0cmlkZSxcbiAgdG9sZXJhbmNlLFxuICBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzLFxuICBzaW1wbGlmaWVkT2Zmc2V0LFxuICBzaW1wbGlmaWVkRW5kc3Ncbikge1xuICBmb3IgKGxldCBpID0gMCwgaWkgPSBlbmRzcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgY29uc3QgZW5kcyA9IGVuZHNzW2ldO1xuICAgIGNvbnN0IHNpbXBsaWZpZWRFbmRzID0gW107XG4gICAgc2ltcGxpZmllZE9mZnNldCA9IHF1YW50aXplQXJyYXkoXG4gICAgICBmbGF0Q29vcmRpbmF0ZXMsXG4gICAgICBvZmZzZXQsXG4gICAgICBlbmRzLFxuICAgICAgc3RyaWRlLFxuICAgICAgdG9sZXJhbmNlLFxuICAgICAgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcyxcbiAgICAgIHNpbXBsaWZpZWRPZmZzZXQsXG4gICAgICBzaW1wbGlmaWVkRW5kc1xuICAgICk7XG4gICAgc2ltcGxpZmllZEVuZHNzLnB1c2goc2ltcGxpZmllZEVuZHMpO1xuICAgIG9mZnNldCA9IGVuZHNbZW5kcy5sZW5ndGggLSAxXTtcbiAgfVxuICByZXR1cm4gc2ltcGxpZmllZE9mZnNldDtcbn1cbiIsIi8qKlxuICogQG1vZHVsZSBvbC9nZW9tL2ZsYXQvc3RyYWlnaHRjaHVua1xuICovXG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IG1heEFuZ2xlIE1heGltdW0gYWNjZXB0YWJsZSBhbmdsZSBkZWx0YSBiZXR3ZWVuIHNlZ21lbnRzLlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtudW1iZXJ9IGVuZCBFbmQuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IFN0YXJ0IGFuZCBlbmQgb2YgdGhlIGZpcnN0IHN1aXRhYmxlIGNodW5rIG9mIHRoZVxuICogZ2l2ZW4gYGZsYXRDb29yZGluYXRlc2AuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXRjaGluZ0NodW5rKG1heEFuZ2xlLCBmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kLCBzdHJpZGUpIHtcbiAgbGV0IGNodW5rU3RhcnQgPSBvZmZzZXQ7XG4gIGxldCBjaHVua0VuZCA9IG9mZnNldDtcbiAgbGV0IGNodW5rTSA9IDA7XG4gIGxldCBtID0gMDtcbiAgbGV0IHN0YXJ0ID0gb2Zmc2V0O1xuICBsZXQgYWNvcywgaSwgbTEyLCBtMjMsIHgxLCB5MSwgeDEyLCB5MTIsIHgyMywgeTIzO1xuICBmb3IgKGkgPSBvZmZzZXQ7IGkgPCBlbmQ7IGkgKz0gc3RyaWRlKSB7XG4gICAgY29uc3QgeDIgPSBmbGF0Q29vcmRpbmF0ZXNbaV07XG4gICAgY29uc3QgeTIgPSBmbGF0Q29vcmRpbmF0ZXNbaSArIDFdO1xuICAgIGlmICh4MSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB4MjMgPSB4MiAtIHgxO1xuICAgICAgeTIzID0geTIgLSB5MTtcbiAgICAgIG0yMyA9IE1hdGguc3FydCh4MjMgKiB4MjMgKyB5MjMgKiB5MjMpO1xuICAgICAgaWYgKHgxMiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG0gKz0gbTEyO1xuICAgICAgICBhY29zID0gTWF0aC5hY29zKCh4MTIgKiB4MjMgKyB5MTIgKiB5MjMpIC8gKG0xMiAqIG0yMykpO1xuICAgICAgICBpZiAoYWNvcyA+IG1heEFuZ2xlKSB7XG4gICAgICAgICAgaWYgKG0gPiBjaHVua00pIHtcbiAgICAgICAgICAgIGNodW5rTSA9IG07XG4gICAgICAgICAgICBjaHVua1N0YXJ0ID0gc3RhcnQ7XG4gICAgICAgICAgICBjaHVua0VuZCA9IGk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG0gPSAwO1xuICAgICAgICAgIHN0YXJ0ID0gaSAtIHN0cmlkZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbTEyID0gbTIzO1xuICAgICAgeDEyID0geDIzO1xuICAgICAgeTEyID0geTIzO1xuICAgIH1cbiAgICB4MSA9IHgyO1xuICAgIHkxID0geTI7XG4gIH1cbiAgbSArPSBtMjM7XG4gIHJldHVybiBtID4gY2h1bmtNID8gW3N0YXJ0LCBpXSA6IFtjaHVua1N0YXJ0LCBjaHVua0VuZF07XG59XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvZ2VvbS9mbGF0L3RleHRwYXRoXG4gKi9cbmltcG9ydCB7bGVycH0gZnJvbSAnLi4vLi4vbWF0aC5qcyc7XG5pbXBvcnQge3JvdGF0ZX0gZnJvbSAnLi90cmFuc2Zvcm0uanMnO1xuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIFBhdGggdG8gcHV0IHRleHQgb24uXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IFN0YXJ0IG9mZnNldCBvZiB0aGUgYGZsYXRDb29yZGluYXRlc2AuXG4gKiBAcGFyYW0ge251bWJlcn0gZW5kIEVuZCBvZmZzZXQgb2YgdGhlIGBmbGF0Q29vcmRpbmF0ZXNgLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBUZXh0IHRvIHBsYWNlIG9uIHRoZSBwYXRoLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0TSBtIGFsb25nIHRoZSBwYXRoIHdoZXJlIHRoZSB0ZXh0IHN0YXJ0cy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXhBbmdsZSBNYXggYW5nbGUgYmV0d2VlbiBhZGphY2VudCBjaGFycyBpbiByYWRpYW5zLlxuICogQHBhcmFtIHtudW1iZXJ9IHNjYWxlIFRoZSBwcm9kdWN0IG9mIHRoZSB0ZXh0IHNjYWxlIGFuZCB0aGUgZGV2aWNlIHBpeGVsIHJhdGlvLlxuICogQHBhcmFtIHtmdW5jdGlvbihzdHJpbmcsIHN0cmluZywgT2JqZWN0PHN0cmluZywgbnVtYmVyPik6bnVtYmVyfSBtZWFzdXJlQW5kQ2FjaGVUZXh0V2lkdGggTWVhc3VyZSBhbmQgY2FjaGUgdGV4dCB3aWR0aC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBmb250IFRoZSBmb250LlxuICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLCBudW1iZXI+fSBjYWNoZSBBIGNhY2hlIG9mIG1lYXN1cmVkIHdpZHRocy5cbiAqIEBwYXJhbSB7bnVtYmVyfSByb3RhdGlvbiBSb3RhdGlvbiB0byBhcHBseSB0byB0aGUgZmxhdENvb3JkaW5hdGVzIHRvIGRldGVybWluZSB3aGV0aGVyIHRleHQgbmVlZHMgdG8gYmUgcmV2ZXJzZWQuXG4gKiBAcmV0dXJuIHtBcnJheTxBcnJheTwqPj58bnVsbH0gVGhlIHJlc3VsdCBhcnJheSAob3IgbnVsbCBpZiBgbWF4QW5nbGVgIHdhc1xuICogZXhjZWVkZWQpLiBFbnRyaWVzIG9mIHRoZSBhcnJheSBhcmUgeCwgeSwgYW5jaG9yWCwgYW5nbGUsIGNodW5rLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZHJhd1RleHRPblBhdGgoXG4gIGZsYXRDb29yZGluYXRlcyxcbiAgb2Zmc2V0LFxuICBlbmQsXG4gIHN0cmlkZSxcbiAgdGV4dCxcbiAgc3RhcnRNLFxuICBtYXhBbmdsZSxcbiAgc2NhbGUsXG4gIG1lYXN1cmVBbmRDYWNoZVRleHRXaWR0aCxcbiAgZm9udCxcbiAgY2FjaGUsXG4gIHJvdGF0aW9uXG4pIHtcbiAgbGV0IHgyID0gZmxhdENvb3JkaW5hdGVzW29mZnNldF07XG4gIGxldCB5MiA9IGZsYXRDb29yZGluYXRlc1tvZmZzZXQgKyAxXTtcbiAgbGV0IHgxID0gMDtcbiAgbGV0IHkxID0gMDtcbiAgbGV0IHNlZ21lbnRMZW5ndGggPSAwO1xuICBsZXQgc2VnbWVudE0gPSAwO1xuXG4gIGZ1bmN0aW9uIGFkdmFuY2UoKSB7XG4gICAgeDEgPSB4MjtcbiAgICB5MSA9IHkyO1xuICAgIG9mZnNldCArPSBzdHJpZGU7XG4gICAgeDIgPSBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0XTtcbiAgICB5MiA9IGZsYXRDb29yZGluYXRlc1tvZmZzZXQgKyAxXTtcbiAgICBzZWdtZW50TSArPSBzZWdtZW50TGVuZ3RoO1xuICAgIHNlZ21lbnRMZW5ndGggPSBNYXRoLnNxcnQoKHgyIC0geDEpICogKHgyIC0geDEpICsgKHkyIC0geTEpICogKHkyIC0geTEpKTtcbiAgfVxuICBkbyB7XG4gICAgYWR2YW5jZSgpO1xuICB9IHdoaWxlIChvZmZzZXQgPCBlbmQgLSBzdHJpZGUgJiYgc2VnbWVudE0gKyBzZWdtZW50TGVuZ3RoIDwgc3RhcnRNKTtcblxuICBsZXQgaW50ZXJwb2xhdGUgPVxuICAgIHNlZ21lbnRMZW5ndGggPT09IDAgPyAwIDogKHN0YXJ0TSAtIHNlZ21lbnRNKSAvIHNlZ21lbnRMZW5ndGg7XG4gIGNvbnN0IGJlZ2luWCA9IGxlcnAoeDEsIHgyLCBpbnRlcnBvbGF0ZSk7XG4gIGNvbnN0IGJlZ2luWSA9IGxlcnAoeTEsIHkyLCBpbnRlcnBvbGF0ZSk7XG5cbiAgY29uc3Qgc3RhcnRPZmZzZXQgPSBvZmZzZXQgLSBzdHJpZGU7XG4gIGNvbnN0IHN0YXJ0TGVuZ3RoID0gc2VnbWVudE07XG4gIGNvbnN0IGVuZE0gPSBzdGFydE0gKyBzY2FsZSAqIG1lYXN1cmVBbmRDYWNoZVRleHRXaWR0aChmb250LCB0ZXh0LCBjYWNoZSk7XG4gIHdoaWxlIChvZmZzZXQgPCBlbmQgLSBzdHJpZGUgJiYgc2VnbWVudE0gKyBzZWdtZW50TGVuZ3RoIDwgZW5kTSkge1xuICAgIGFkdmFuY2UoKTtcbiAgfVxuICBpbnRlcnBvbGF0ZSA9IHNlZ21lbnRMZW5ndGggPT09IDAgPyAwIDogKGVuZE0gLSBzZWdtZW50TSkgLyBzZWdtZW50TGVuZ3RoO1xuICBjb25zdCBlbmRYID0gbGVycCh4MSwgeDIsIGludGVycG9sYXRlKTtcbiAgY29uc3QgZW5kWSA9IGxlcnAoeTEsIHkyLCBpbnRlcnBvbGF0ZSk7XG5cbiAgLy8gS2VlcCB0ZXh0IHVwcmlnaHRcbiAgbGV0IHJldmVyc2U7XG4gIGlmIChyb3RhdGlvbikge1xuICAgIGNvbnN0IGZsYXQgPSBbYmVnaW5YLCBiZWdpblksIGVuZFgsIGVuZFldO1xuICAgIHJvdGF0ZShmbGF0LCAwLCA0LCAyLCByb3RhdGlvbiwgZmxhdCwgZmxhdCk7XG4gICAgcmV2ZXJzZSA9IGZsYXRbMF0gPiBmbGF0WzJdO1xuICB9IGVsc2Uge1xuICAgIHJldmVyc2UgPSBiZWdpblggPiBlbmRYO1xuICB9XG5cbiAgY29uc3QgUEkgPSBNYXRoLlBJO1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgY29uc3Qgc2luZ2xlU2VnbWVudCA9IHN0YXJ0T2Zmc2V0ICsgc3RyaWRlID09PSBvZmZzZXQ7XG5cbiAgb2Zmc2V0ID0gc3RhcnRPZmZzZXQ7XG4gIHNlZ21lbnRMZW5ndGggPSAwO1xuICBzZWdtZW50TSA9IHN0YXJ0TGVuZ3RoO1xuICB4MiA9IGZsYXRDb29yZGluYXRlc1tvZmZzZXRdO1xuICB5MiA9IGZsYXRDb29yZGluYXRlc1tvZmZzZXQgKyAxXTtcblxuICBsZXQgcHJldmlvdXNBbmdsZTtcbiAgLy8gQWxsIG9uIHRoZSBzYW1lIHNlZ21lbnRcbiAgaWYgKHNpbmdsZVNlZ21lbnQpIHtcbiAgICBhZHZhbmNlKCk7XG5cbiAgICBwcmV2aW91c0FuZ2xlID0gTWF0aC5hdGFuMih5MiAtIHkxLCB4MiAtIHgxKTtcbiAgICBpZiAocmV2ZXJzZSkge1xuICAgICAgcHJldmlvdXNBbmdsZSArPSBwcmV2aW91c0FuZ2xlID4gMCA/IC1QSSA6IFBJO1xuICAgIH1cbiAgICBjb25zdCB4ID0gKGVuZFggKyBiZWdpblgpIC8gMjtcbiAgICBjb25zdCB5ID0gKGVuZFkgKyBiZWdpblkpIC8gMjtcbiAgICByZXN1bHRbMF0gPSBbeCwgeSwgKGVuZE0gLSBzdGFydE0pIC8gMiwgcHJldmlvdXNBbmdsZSwgdGV4dF07XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8vIHJlbmRlcmluZyBhY3Jvc3MgbGluZSBzZWdtZW50c1xuICB0ZXh0ID0gdGV4dC5yZXBsYWNlKC9cXG4vZywgJyAnKTsgLy8gZW5zdXJlIHJlbmRlcmluZyBpbiBzaW5nbGUtbGluZSBhcyBhbGwgY2FsY3VsYXRpb25zIGJlbG93IGRvbid0IGhhbmRsZSBtdWx0aS1saW5lc1xuXG4gIGZvciAobGV0IGkgPSAwLCBpaSA9IHRleHQubGVuZ3RoOyBpIDwgaWk7ICkge1xuICAgIGFkdmFuY2UoKTtcbiAgICBsZXQgYW5nbGUgPSBNYXRoLmF0YW4yKHkyIC0geTEsIHgyIC0geDEpO1xuICAgIGlmIChyZXZlcnNlKSB7XG4gICAgICBhbmdsZSArPSBhbmdsZSA+IDAgPyAtUEkgOiBQSTtcbiAgICB9XG4gICAgaWYgKHByZXZpb3VzQW5nbGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgbGV0IGRlbHRhID0gYW5nbGUgLSBwcmV2aW91c0FuZ2xlO1xuICAgICAgZGVsdGEgKz0gZGVsdGEgPiBQSSA/IC0yICogUEkgOiBkZWx0YSA8IC1QSSA/IDIgKiBQSSA6IDA7XG4gICAgICBpZiAoTWF0aC5hYnMoZGVsdGEpID4gbWF4QW5nbGUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIHByZXZpb3VzQW5nbGUgPSBhbmdsZTtcblxuICAgIGNvbnN0IGlTdGFydCA9IGk7XG4gICAgbGV0IGNoYXJMZW5ndGggPSAwO1xuICAgIGZvciAoOyBpIDwgaWk7ICsraSkge1xuICAgICAgY29uc3QgaW5kZXggPSByZXZlcnNlID8gaWkgLSBpIC0gMSA6IGk7XG4gICAgICBjb25zdCBsZW4gPSBzY2FsZSAqIG1lYXN1cmVBbmRDYWNoZVRleHRXaWR0aChmb250LCB0ZXh0W2luZGV4XSwgY2FjaGUpO1xuICAgICAgaWYgKFxuICAgICAgICBvZmZzZXQgKyBzdHJpZGUgPCBlbmQgJiZcbiAgICAgICAgc2VnbWVudE0gKyBzZWdtZW50TGVuZ3RoIDwgc3RhcnRNICsgY2hhckxlbmd0aCArIGxlbiAvIDJcbiAgICAgICkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNoYXJMZW5ndGggKz0gbGVuO1xuICAgIH1cbiAgICBpZiAoaSA9PT0gaVN0YXJ0KSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgY2hhcnMgPSByZXZlcnNlXG4gICAgICA/IHRleHQuc3Vic3RyaW5nKGlpIC0gaVN0YXJ0LCBpaSAtIGkpXG4gICAgICA6IHRleHQuc3Vic3RyaW5nKGlTdGFydCwgaSk7XG4gICAgaW50ZXJwb2xhdGUgPVxuICAgICAgc2VnbWVudExlbmd0aCA9PT0gMFxuICAgICAgICA/IDBcbiAgICAgICAgOiAoc3RhcnRNICsgY2hhckxlbmd0aCAvIDIgLSBzZWdtZW50TSkgLyBzZWdtZW50TGVuZ3RoO1xuICAgIGNvbnN0IHggPSBsZXJwKHgxLCB4MiwgaW50ZXJwb2xhdGUpO1xuICAgIGNvbnN0IHkgPSBsZXJwKHkxLCB5MiwgaW50ZXJwb2xhdGUpO1xuICAgIHJlc3VsdC5wdXNoKFt4LCB5LCBjaGFyTGVuZ3RoIC8gMiwgYW5nbGUsIGNoYXJzXSk7XG4gICAgc3RhcnRNICs9IGNoYXJMZW5ndGg7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbiIsIi8qKlxuICogQG1vZHVsZSBvbC9nZW9tL2ZsYXQvdHJhbnNmb3JtXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gKiBAcGFyYW0ge251bWJlcn0gZW5kIEVuZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi90cmFuc2Zvcm0uanNcIikuVHJhbnNmb3JtfSB0cmFuc2Zvcm0gVHJhbnNmb3JtLlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBbZGVzdF0gRGVzdGluYXRpb24uXG4gKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBUcmFuc2Zvcm1lZCBjb29yZGluYXRlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZm9ybTJEKFxuICBmbGF0Q29vcmRpbmF0ZXMsXG4gIG9mZnNldCxcbiAgZW5kLFxuICBzdHJpZGUsXG4gIHRyYW5zZm9ybSxcbiAgZGVzdFxuKSB7XG4gIGRlc3QgPSBkZXN0ID8gZGVzdCA6IFtdO1xuICBsZXQgaSA9IDA7XG4gIGZvciAobGV0IGogPSBvZmZzZXQ7IGogPCBlbmQ7IGogKz0gc3RyaWRlKSB7XG4gICAgY29uc3QgeCA9IGZsYXRDb29yZGluYXRlc1tqXTtcbiAgICBjb25zdCB5ID0gZmxhdENvb3JkaW5hdGVzW2ogKyAxXTtcbiAgICBkZXN0W2krK10gPSB0cmFuc2Zvcm1bMF0gKiB4ICsgdHJhbnNmb3JtWzJdICogeSArIHRyYW5zZm9ybVs0XTtcbiAgICBkZXN0W2krK10gPSB0cmFuc2Zvcm1bMV0gKiB4ICsgdHJhbnNmb3JtWzNdICogeSArIHRyYW5zZm9ybVs1XTtcbiAgfVxuICBpZiAoZGVzdCAmJiBkZXN0Lmxlbmd0aCAhPSBpKSB7XG4gICAgZGVzdC5sZW5ndGggPSBpO1xuICB9XG4gIHJldHVybiBkZXN0O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgRW5kLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcGFyYW0ge251bWJlcn0gYW5nbGUgQW5nbGUuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGFuY2hvciBSb3RhdGlvbiBhbmNob3IgcG9pbnQuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IFtkZXN0XSBEZXN0aW5hdGlvbi5cbiAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IFRyYW5zZm9ybWVkIGNvb3JkaW5hdGVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcm90YXRlKFxuICBmbGF0Q29vcmRpbmF0ZXMsXG4gIG9mZnNldCxcbiAgZW5kLFxuICBzdHJpZGUsXG4gIGFuZ2xlLFxuICBhbmNob3IsXG4gIGRlc3Rcbikge1xuICBkZXN0ID0gZGVzdCA/IGRlc3QgOiBbXTtcbiAgY29uc3QgY29zID0gTWF0aC5jb3MoYW5nbGUpO1xuICBjb25zdCBzaW4gPSBNYXRoLnNpbihhbmdsZSk7XG4gIGNvbnN0IGFuY2hvclggPSBhbmNob3JbMF07XG4gIGNvbnN0IGFuY2hvclkgPSBhbmNob3JbMV07XG4gIGxldCBpID0gMDtcbiAgZm9yIChsZXQgaiA9IG9mZnNldDsgaiA8IGVuZDsgaiArPSBzdHJpZGUpIHtcbiAgICBjb25zdCBkZWx0YVggPSBmbGF0Q29vcmRpbmF0ZXNbal0gLSBhbmNob3JYO1xuICAgIGNvbnN0IGRlbHRhWSA9IGZsYXRDb29yZGluYXRlc1tqICsgMV0gLSBhbmNob3JZO1xuICAgIGRlc3RbaSsrXSA9IGFuY2hvclggKyBkZWx0YVggKiBjb3MgLSBkZWx0YVkgKiBzaW47XG4gICAgZGVzdFtpKytdID0gYW5jaG9yWSArIGRlbHRhWCAqIHNpbiArIGRlbHRhWSAqIGNvcztcbiAgICBmb3IgKGxldCBrID0gaiArIDI7IGsgPCBqICsgc3RyaWRlOyArK2spIHtcbiAgICAgIGRlc3RbaSsrXSA9IGZsYXRDb29yZGluYXRlc1trXTtcbiAgICB9XG4gIH1cbiAgaWYgKGRlc3QgJiYgZGVzdC5sZW5ndGggIT0gaSkge1xuICAgIGRlc3QubGVuZ3RoID0gaTtcbiAgfVxuICByZXR1cm4gZGVzdDtcbn1cblxuLyoqXG4gKiBTY2FsZSB0aGUgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gKiBAcGFyYW0ge251bWJlcn0gZW5kIEVuZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHBhcmFtIHtudW1iZXJ9IHN4IFNjYWxlIGZhY3RvciBpbiB0aGUgeC1kaXJlY3Rpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gc3kgU2NhbGUgZmFjdG9yIGluIHRoZSB5LWRpcmVjdGlvbi5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gYW5jaG9yIFNjYWxlIGFuY2hvciBwb2ludC5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gW2Rlc3RdIERlc3RpbmF0aW9uLlxuICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gVHJhbnNmb3JtZWQgY29vcmRpbmF0ZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzY2FsZShcbiAgZmxhdENvb3JkaW5hdGVzLFxuICBvZmZzZXQsXG4gIGVuZCxcbiAgc3RyaWRlLFxuICBzeCxcbiAgc3ksXG4gIGFuY2hvcixcbiAgZGVzdFxuKSB7XG4gIGRlc3QgPSBkZXN0ID8gZGVzdCA6IFtdO1xuICBjb25zdCBhbmNob3JYID0gYW5jaG9yWzBdO1xuICBjb25zdCBhbmNob3JZID0gYW5jaG9yWzFdO1xuICBsZXQgaSA9IDA7XG4gIGZvciAobGV0IGogPSBvZmZzZXQ7IGogPCBlbmQ7IGogKz0gc3RyaWRlKSB7XG4gICAgY29uc3QgZGVsdGFYID0gZmxhdENvb3JkaW5hdGVzW2pdIC0gYW5jaG9yWDtcbiAgICBjb25zdCBkZWx0YVkgPSBmbGF0Q29vcmRpbmF0ZXNbaiArIDFdIC0gYW5jaG9yWTtcbiAgICBkZXN0W2krK10gPSBhbmNob3JYICsgc3ggKiBkZWx0YVg7XG4gICAgZGVzdFtpKytdID0gYW5jaG9yWSArIHN5ICogZGVsdGFZO1xuICAgIGZvciAobGV0IGsgPSBqICsgMjsgayA8IGogKyBzdHJpZGU7ICsraykge1xuICAgICAgZGVzdFtpKytdID0gZmxhdENvb3JkaW5hdGVzW2tdO1xuICAgIH1cbiAgfVxuICBpZiAoZGVzdCAmJiBkZXN0Lmxlbmd0aCAhPSBpKSB7XG4gICAgZGVzdC5sZW5ndGggPSBpO1xuICB9XG4gIHJldHVybiBkZXN0O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgRW5kLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcGFyYW0ge251bWJlcn0gZGVsdGFYIERlbHRhIFguXG4gKiBAcGFyYW0ge251bWJlcn0gZGVsdGFZIERlbHRhIFkuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IFtkZXN0XSBEZXN0aW5hdGlvbi5cbiAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IFRyYW5zZm9ybWVkIGNvb3JkaW5hdGVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNsYXRlKFxuICBmbGF0Q29vcmRpbmF0ZXMsXG4gIG9mZnNldCxcbiAgZW5kLFxuICBzdHJpZGUsXG4gIGRlbHRhWCxcbiAgZGVsdGFZLFxuICBkZXN0XG4pIHtcbiAgZGVzdCA9IGRlc3QgPyBkZXN0IDogW107XG4gIGxldCBpID0gMDtcbiAgZm9yIChsZXQgaiA9IG9mZnNldDsgaiA8IGVuZDsgaiArPSBzdHJpZGUpIHtcbiAgICBkZXN0W2krK10gPSBmbGF0Q29vcmRpbmF0ZXNbal0gKyBkZWx0YVg7XG4gICAgZGVzdFtpKytdID0gZmxhdENvb3JkaW5hdGVzW2ogKyAxXSArIGRlbHRhWTtcbiAgICBmb3IgKGxldCBrID0gaiArIDI7IGsgPCBqICsgc3RyaWRlOyArK2spIHtcbiAgICAgIGRlc3RbaSsrXSA9IGZsYXRDb29yZGluYXRlc1trXTtcbiAgICB9XG4gIH1cbiAgaWYgKGRlc3QgJiYgZGVzdC5sZW5ndGggIT0gaSkge1xuICAgIGRlc3QubGVuZ3RoID0gaTtcbiAgfVxuICByZXR1cm4gZGVzdDtcbn1cbiIsIi8qKlxuICogQG1vZHVsZSBvbC9oYXNcbiAqL1xuXG5jb25zdCB1YSA9XG4gIHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBuYXZpZ2F0b3IudXNlckFnZW50ICE9PSAndW5kZWZpbmVkJ1xuICAgID8gbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpXG4gICAgOiAnJztcblxuLyoqXG4gKiBVc2VyIGFnZW50IHN0cmluZyBzYXlzIHdlIGFyZSBkZWFsaW5nIHdpdGggRmlyZWZveCBhcyBicm93c2VyLlxuICogQHR5cGUge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBjb25zdCBGSVJFRk9YID0gdWEuaW5jbHVkZXMoJ2ZpcmVmb3gnKTtcblxuLyoqXG4gKiBVc2VyIGFnZW50IHN0cmluZyBzYXlzIHdlIGFyZSBkZWFsaW5nIHdpdGggU2FmYXJpIGFzIGJyb3dzZXIuXG4gKiBAdHlwZSB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGNvbnN0IFNBRkFSSSA9IHVhLmluY2x1ZGVzKCdzYWZhcmknKSAmJiAhdWEuaW5jbHVkZXMoJ2Nocm9tJyk7XG5cbi8qKlxuICogaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTIzNzkwNlxuICogQHR5cGUge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBjb25zdCBTQUZBUklfQlVHXzIzNzkwNiA9XG4gIFNBRkFSSSAmJlxuICAodWEuaW5jbHVkZXMoJ3ZlcnNpb24vMTUuNCcpIHx8XG4gICAgL2NwdSAob3N8aXBob25lIG9zKSAxNV80IGxpa2UgbWFjIG9zIHgvLnRlc3QodWEpKTtcblxuLyoqXG4gKiBVc2VyIGFnZW50IHN0cmluZyBzYXlzIHdlIGFyZSBkZWFsaW5nIHdpdGggYSBXZWJLaXQgZW5naW5lLlxuICogQHR5cGUge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBjb25zdCBXRUJLSVQgPSB1YS5pbmNsdWRlcygnd2Via2l0JykgJiYgIXVhLmluY2x1ZGVzKCdlZGdlJyk7XG5cbi8qKlxuICogVXNlciBhZ2VudCBzdHJpbmcgc2F5cyB3ZSBhcmUgZGVhbGluZyB3aXRoIGEgTWFjIGFzIHBsYXRmb3JtLlxuICogQHR5cGUge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBjb25zdCBNQUMgPSB1YS5pbmNsdWRlcygnbWFjaW50b3NoJyk7XG5cbi8qKlxuICogVGhlIHJhdGlvIGJldHdlZW4gcGh5c2ljYWwgcGl4ZWxzIGFuZCBkZXZpY2UtaW5kZXBlbmRlbnQgcGl4ZWxzXG4gKiAoZGlwcykgb24gdGhlIGRldmljZSAoYHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvYCkuXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBjb25zdCBERVZJQ0VfUElYRUxfUkFUSU8gPVxuICB0eXBlb2YgZGV2aWNlUGl4ZWxSYXRpbyAhPT0gJ3VuZGVmaW5lZCcgPyBkZXZpY2VQaXhlbFJhdGlvIDogMTtcblxuLyoqXG4gKiBUaGUgZXhlY3V0aW9uIGNvbnRleHQgaXMgYSB3b3JrZXIgd2l0aCBPZmZzY3JlZW5DYW52YXMgYXZhaWxhYmxlLlxuICogQGNvbnN0XG4gKiBAdHlwZSB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGNvbnN0IFdPUktFUl9PRkZTQ1JFRU5fQ0FOVkFTID1cbiAgdHlwZW9mIFdvcmtlckdsb2JhbFNjb3BlICE9PSAndW5kZWZpbmVkJyAmJlxuICB0eXBlb2YgT2Zmc2NyZWVuQ2FudmFzICE9PSAndW5kZWZpbmVkJyAmJlxuICBzZWxmIGluc3RhbmNlb2YgV29ya2VyR2xvYmFsU2NvcGU7IC8vZXNsaW50LWRpc2FibGUtbGluZVxuXG4vKipcbiAqIEltYWdlLnByb3RvdHlwZS5kZWNvZGUoKSBpcyBzdXBwb3J0ZWQuXG4gKiBAdHlwZSB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGNvbnN0IElNQUdFX0RFQ09ERSA9XG4gIHR5cGVvZiBJbWFnZSAhPT0gJ3VuZGVmaW5lZCcgJiYgSW1hZ2UucHJvdG90eXBlLmRlY29kZTtcblxuLyoqXG4gKiBjcmVhdGVJbWFnZUJpdG1hcCgpIGlzIHN1cHBvcnRlZC5cbiAqIEB0eXBlIHtib29sZWFufVxuICovXG5leHBvcnQgY29uc3QgQ1JFQVRFX0lNQUdFX0JJVE1BUCA9IHR5cGVvZiBjcmVhdGVJbWFnZUJpdG1hcCA9PT0gJ2Z1bmN0aW9uJztcblxuLyoqXG4gKiBAdHlwZSB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGNvbnN0IFBBU1NJVkVfRVZFTlRfTElTVEVORVJTID0gKGZ1bmN0aW9uICgpIHtcbiAgbGV0IHBhc3NpdmUgPSBmYWxzZTtcbiAgdHJ5IHtcbiAgICBjb25zdCBvcHRpb25zID0gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAncGFzc2l2ZScsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICBwYXNzaXZlID0gdHJ1ZTtcbiAgICAgIH0sXG4gICAgfSk7XG5cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignXycsIG51bGwsIG9wdGlvbnMpO1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdfJywgbnVsbCwgb3B0aW9ucyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgLy8gcGFzc2l2ZSBub3Qgc3VwcG9ydGVkXG4gIH1cbiAgcmV0dXJuIHBhc3NpdmU7XG59KSgpO1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2ludGVyYWN0aW9uL0RvdWJsZUNsaWNrWm9vbVxuICovXG5pbXBvcnQgSW50ZXJhY3Rpb24sIHt6b29tQnlEZWx0YX0gZnJvbSAnLi9JbnRlcmFjdGlvbi5qcyc7XG5pbXBvcnQgTWFwQnJvd3NlckV2ZW50VHlwZSBmcm9tICcuLi9NYXBCcm93c2VyRXZlbnRUeXBlLmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2R1cmF0aW9uPTI1MF0gQW5pbWF0aW9uIGR1cmF0aW9uIGluIG1pbGxpc2Vjb25kcy5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbZGVsdGE9MV0gVGhlIHpvb20gZGVsdGEgYXBwbGllZCBvbiBlYWNoIGRvdWJsZSBjbGljay5cbiAqL1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEFsbG93cyB0aGUgdXNlciB0byB6b29tIGJ5IGRvdWJsZS1jbGlja2luZyBvbiB0aGUgbWFwLlxuICogQGFwaVxuICovXG5jbGFzcyBEb3VibGVDbGlja1pvb20gZXh0ZW5kcyBJbnRlcmFjdGlvbiB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge09wdGlvbnN9IFtvcHRpb25zXSBPcHRpb25zLlxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHN1cGVyKCk7XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyA/IG9wdGlvbnMgOiB7fTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmRlbHRhXyA9IG9wdGlvbnMuZGVsdGEgPyBvcHRpb25zLmRlbHRhIDogMTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmR1cmF0aW9uXyA9IG9wdGlvbnMuZHVyYXRpb24gIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZHVyYXRpb24gOiAyNTA7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlcyB0aGUge0BsaW5rIG1vZHVsZTpvbC9NYXBCcm93c2VyRXZlbnR+TWFwQnJvd3NlckV2ZW50IG1hcCBicm93c2VyIGV2ZW50fSAoaWYgaXQgd2FzIGFcbiAgICogZG91YmxlY2xpY2spIGFuZCBldmVudHVhbGx5IHpvb21zIHRoZSBtYXAuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLmRlZmF1bHR9IG1hcEJyb3dzZXJFdmVudCBNYXAgYnJvd3NlciBldmVudC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gYGZhbHNlYCB0byBzdG9wIGV2ZW50IHByb3BhZ2F0aW9uLlxuICAgKi9cbiAgaGFuZGxlRXZlbnQobWFwQnJvd3NlckV2ZW50KSB7XG4gICAgbGV0IHN0b3BFdmVudCA9IGZhbHNlO1xuICAgIGlmIChtYXBCcm93c2VyRXZlbnQudHlwZSA9PSBNYXBCcm93c2VyRXZlbnRUeXBlLkRCTENMSUNLKSB7XG4gICAgICBjb25zdCBicm93c2VyRXZlbnQgPSAvKiogQHR5cGUge01vdXNlRXZlbnR9ICovIChcbiAgICAgICAgbWFwQnJvd3NlckV2ZW50Lm9yaWdpbmFsRXZlbnRcbiAgICAgICk7XG4gICAgICBjb25zdCBtYXAgPSBtYXBCcm93c2VyRXZlbnQubWFwO1xuICAgICAgY29uc3QgYW5jaG9yID0gbWFwQnJvd3NlckV2ZW50LmNvb3JkaW5hdGU7XG4gICAgICBjb25zdCBkZWx0YSA9IGJyb3dzZXJFdmVudC5zaGlmdEtleSA/IC10aGlzLmRlbHRhXyA6IHRoaXMuZGVsdGFfO1xuICAgICAgY29uc3QgdmlldyA9IG1hcC5nZXRWaWV3KCk7XG4gICAgICB6b29tQnlEZWx0YSh2aWV3LCBkZWx0YSwgYW5jaG9yLCB0aGlzLmR1cmF0aW9uXyk7XG4gICAgICBicm93c2VyRXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHN0b3BFdmVudCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiAhc3RvcEV2ZW50O1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IERvdWJsZUNsaWNrWm9vbTtcbiIsIi8qKlxuICogQG1vZHVsZSBvbC9pbnRlcmFjdGlvbi9EcmFnQm94XG4gKi9cbi8vIEZJWE1FIGRyYXcgZHJhZyBib3hcbmltcG9ydCBFdmVudCBmcm9tICcuLi9ldmVudHMvRXZlbnQuanMnO1xuaW1wb3J0IFBvaW50ZXJJbnRlcmFjdGlvbiBmcm9tICcuL1BvaW50ZXIuanMnO1xuaW1wb3J0IFJlbmRlckJveCBmcm9tICcuLi9yZW5kZXIvQm94LmpzJztcbmltcG9ydCB7bW91c2VBY3Rpb25CdXR0b259IGZyb20gJy4uL2V2ZW50cy9jb25kaXRpb24uanMnO1xuXG4vKipcbiAqIEEgZnVuY3Rpb24gdGhhdCB0YWtlcyBhIHtAbGluayBtb2R1bGU6b2wvTWFwQnJvd3NlckV2ZW50fk1hcEJyb3dzZXJFdmVudH0gYW5kIHR3b1xuICoge0BsaW5rIG1vZHVsZTpvbC9waXhlbH5QaXhlbH1zIGFuZCByZXR1cm5zIGEgYHtib29sZWFufWAuIElmIHRoZSBjb25kaXRpb24gaXMgbWV0LFxuICogdHJ1ZSBzaG91bGQgYmUgcmV0dXJuZWQuXG4gKiBAdHlwZWRlZiB7ZnVuY3Rpb24odGhpczogPywgaW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLmRlZmF1bHQsIGltcG9ydChcIi4uL3BpeGVsLmpzXCIpLlBpeGVsLCBpbXBvcnQoXCIuLi9waXhlbC5qc1wiKS5QaXhlbCk6Ym9vbGVhbn0gRW5kQ29uZGl0aW9uXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2NsYXNzTmFtZT0nb2wtZHJhZ2JveCddIENTUyBjbGFzcyBuYW1lIGZvciBzdHlsaW5nIHRoZSBib3guXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL2V2ZW50cy9jb25kaXRpb24uanNcIikuQ29uZGl0aW9ufSBbY29uZGl0aW9uXSBBIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYW4ge0BsaW5rIG1vZHVsZTpvbC9NYXBCcm93c2VyRXZlbnR+TWFwQnJvd3NlckV2ZW50fSBhbmQgcmV0dXJucyBhIGJvb2xlYW5cbiAqIHRvIGluZGljYXRlIHdoZXRoZXIgdGhhdCBldmVudCBzaG91bGQgYmUgaGFuZGxlZC5cbiAqIERlZmF1bHQgaXMge0BsaW5rIG9sL2V2ZW50cy9jb25kaXRpb25+bW91c2VBY3Rpb25CdXR0b259LlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFttaW5BcmVhPTY0XSBUaGUgbWluaW11bSBhcmVhIG9mIHRoZSBib3ggaW4gcGl4ZWwsIHRoaXMgdmFsdWUgaXMgdXNlZCBieSB0aGUgZGVmYXVsdFxuICogYGJveEVuZENvbmRpdGlvbmAgZnVuY3Rpb24uXG4gKiBAcHJvcGVydHkge0VuZENvbmRpdGlvbn0gW2JveEVuZENvbmRpdGlvbl0gQSBmdW5jdGlvbiB0aGF0IHRha2VzIGEge0BsaW5rIG1vZHVsZTpvbC9NYXBCcm93c2VyRXZlbnR+TWFwQnJvd3NlckV2ZW50fSBhbmQgdHdvXG4gKiB7QGxpbmsgbW9kdWxlOm9sL3BpeGVsflBpeGVsfXMgdG8gaW5kaWNhdGUgd2hldGhlciBhIGBib3hlbmRgIGV2ZW50IHNob3VsZCBiZSBmaXJlZC5cbiAqIERlZmF1bHQgaXMgYHRydWVgIGlmIHRoZSBhcmVhIG9mIHRoZSBib3ggaXMgYmlnZ2VyIHRoYW4gdGhlIGBtaW5BcmVhYCBvcHRpb24uXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9uKHRoaXM6RHJhZ0JveCwgaW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLmRlZmF1bHQpOnZvaWR9IFtvbkJveEVuZF0gQ29kZSB0byBleGVjdXRlIGp1c3RcbiAqIGJlZm9yZSBgYm94ZW5kYCBpcyBmaXJlZC5cbiAqL1xuXG4vKipcbiAqIEBlbnVtIHtzdHJpbmd9XG4gKi9cbmNvbnN0IERyYWdCb3hFdmVudFR5cGUgPSB7XG4gIC8qKlxuICAgKiBUcmlnZ2VyZWQgdXBvbiBkcmFnIGJveCBzdGFydC5cbiAgICogQGV2ZW50IERyYWdCb3hFdmVudCNib3hzdGFydFxuICAgKiBAYXBpXG4gICAqL1xuICBCT1hTVEFSVDogJ2JveHN0YXJ0JyxcblxuICAvKipcbiAgICogVHJpZ2dlcmVkIG9uIGRyYWcgd2hlbiBib3ggaXMgYWN0aXZlLlxuICAgKiBAZXZlbnQgRHJhZ0JveEV2ZW50I2JveGRyYWdcbiAgICogQGFwaVxuICAgKi9cbiAgQk9YRFJBRzogJ2JveGRyYWcnLFxuXG4gIC8qKlxuICAgKiBUcmlnZ2VyZWQgdXBvbiBkcmFnIGJveCBlbmQuXG4gICAqIEBldmVudCBEcmFnQm94RXZlbnQjYm94ZW5kXG4gICAqIEBhcGlcbiAgICovXG4gIEJPWEVORDogJ2JveGVuZCcsXG5cbiAgLyoqXG4gICAqIFRyaWdnZXJlZCB1cG9uIGRyYWcgYm94IGNhbmNlbGVkLlxuICAgKiBAZXZlbnQgRHJhZ0JveEV2ZW50I2JveGNhbmNlbFxuICAgKiBAYXBpXG4gICAqL1xuICBCT1hDQU5DRUw6ICdib3hjYW5jZWwnLFxufTtcblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBFdmVudHMgZW1pdHRlZCBieSB7QGxpbmsgbW9kdWxlOm9sL2ludGVyYWN0aW9uL0RyYWdCb3h+RHJhZ0JveH0gaW5zdGFuY2VzIGFyZSBpbnN0YW5jZXMgb2ZcbiAqIHRoaXMgdHlwZS5cbiAqL1xuZXhwb3J0IGNsYXNzIERyYWdCb3hFdmVudCBleHRlbmRzIEV2ZW50IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIFRoZSBldmVudCB0eXBlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gY29vcmRpbmF0ZSBUaGUgZXZlbnQgY29vcmRpbmF0ZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdH0gbWFwQnJvd3NlckV2ZW50IE9yaWdpbmF0aW5nIGV2ZW50LlxuICAgKi9cbiAgY29uc3RydWN0b3IodHlwZSwgY29vcmRpbmF0ZSwgbWFwQnJvd3NlckV2ZW50KSB7XG4gICAgc3VwZXIodHlwZSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY29vcmRpbmF0ZSBvZiB0aGUgZHJhZyBldmVudC5cbiAgICAgKiBAY29uc3RcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfVxuICAgICAqIEBhcGlcbiAgICAgKi9cbiAgICB0aGlzLmNvb3JkaW5hdGUgPSBjb29yZGluYXRlO1xuXG4gICAgLyoqXG4gICAgICogQGNvbnN0XG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL01hcEJyb3dzZXJFdmVudC5qc1wiKS5kZWZhdWx0fVxuICAgICAqIEBhcGlcbiAgICAgKi9cbiAgICB0aGlzLm1hcEJyb3dzZXJFdmVudCA9IG1hcEJyb3dzZXJFdmVudDtcbiAgfVxufVxuXG4vKioqXG4gKiBAdGVtcGxhdGUgUmV0dXJuXG4gKiBAdHlwZWRlZiB7aW1wb3J0KFwiLi4vT2JzZXJ2YWJsZVwiKS5PblNpZ25hdHVyZTxpbXBvcnQoXCIuLi9PYnNlcnZhYmxlXCIpLkV2ZW50VHlwZXMsIGltcG9ydChcIi4uL2V2ZW50cy9FdmVudC5qc1wiKS5kZWZhdWx0LCBSZXR1cm4+ICZcbiAqICAgaW1wb3J0KFwiLi4vT2JzZXJ2YWJsZVwiKS5PblNpZ25hdHVyZTxpbXBvcnQoXCIuLi9PYmplY3RFdmVudFR5cGVcIikuVHlwZXN8XG4gKiAgICAgJ2NoYW5nZTphY3RpdmUnLCBpbXBvcnQoXCIuLi9PYmplY3RcIikuT2JqZWN0RXZlbnQsIFJldHVybj4gJlxuICogICBpbXBvcnQoXCIuLi9PYnNlcnZhYmxlXCIpLk9uU2lnbmF0dXJlPCdib3hjYW5jZWwnfCdib3hkcmFnJ3wnYm94ZW5kJ3wnYm94c3RhcnQnLCBEcmFnQm94RXZlbnQsIFJldHVybj4gJlxuICogICBpbXBvcnQoXCIuLi9PYnNlcnZhYmxlXCIpLkNvbWJpbmVkT25TaWduYXR1cmU8aW1wb3J0KFwiLi4vT2JzZXJ2YWJsZVwiKS5FdmVudFR5cGVzfGltcG9ydChcIi4uL09iamVjdEV2ZW50VHlwZVwiKS5UeXBlc3xcbiAqICAgICAnY2hhbmdlOmFjdGl2ZSd8J2JveGNhbmNlbCd8J2JveGRyYWcnfCdib3hlbmQnLCBSZXR1cm4+fSBEcmFnQm94T25TaWduYXR1cmVcbiAqL1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEFsbG93cyB0aGUgdXNlciB0byBkcmF3IGEgdmVjdG9yIGJveCBieSBjbGlja2luZyBhbmQgZHJhZ2dpbmcgb24gdGhlIG1hcCxcbiAqIG5vcm1hbGx5IGNvbWJpbmVkIHdpdGggYW4ge0BsaW5rIG1vZHVsZTpvbC9ldmVudHMvY29uZGl0aW9ufSB0aGF0IGxpbWl0c1xuICogaXQgdG8gd2hlbiB0aGUgc2hpZnQgb3Igb3RoZXIga2V5IGlzIGhlbGQgZG93bi4gVGhpcyBpcyB1c2VkLCBmb3IgZXhhbXBsZSxcbiAqIGZvciB6b29taW5nIHRvIGEgc3BlY2lmaWMgYXJlYSBvZiB0aGUgbWFwXG4gKiAoc2VlIHtAbGluayBtb2R1bGU6b2wvaW50ZXJhY3Rpb24vRHJhZ1pvb21+RHJhZ1pvb219IGFuZFxuICoge0BsaW5rIG1vZHVsZTpvbC9pbnRlcmFjdGlvbi9EcmFnUm90YXRlQW5kWm9vbX5EcmFnUm90YXRlQW5kWm9vbX0pLlxuICpcbiAqIEBmaXJlcyBEcmFnQm94RXZlbnRcbiAqIEBhcGlcbiAqL1xuY2xhc3MgRHJhZ0JveCBleHRlbmRzIFBvaW50ZXJJbnRlcmFjdGlvbiB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge09wdGlvbnN9IFtvcHRpb25zXSBPcHRpb25zLlxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHN1cGVyKCk7XG5cbiAgICAvKioqXG4gICAgICogQHR5cGUge0RyYWdCb3hPblNpZ25hdHVyZTxpbXBvcnQoXCIuLi9ldmVudHNcIikuRXZlbnRzS2V5Pn1cbiAgICAgKi9cbiAgICB0aGlzLm9uO1xuXG4gICAgLyoqKlxuICAgICAqIEB0eXBlIHtEcmFnQm94T25TaWduYXR1cmU8aW1wb3J0KFwiLi4vZXZlbnRzXCIpLkV2ZW50c0tleT59XG4gICAgICovXG4gICAgdGhpcy5vbmNlO1xuXG4gICAgLyoqKlxuICAgICAqIEB0eXBlIHtEcmFnQm94T25TaWduYXR1cmU8dm9pZD59XG4gICAgICovXG4gICAgdGhpcy51bjtcblxuICAgIG9wdGlvbnMgPSBvcHRpb25zID8gb3B0aW9ucyA6IHt9O1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL3JlbmRlci9Cb3guanNcIikuZGVmYXVsdH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuYm94XyA9IG5ldyBSZW5kZXJCb3gob3B0aW9ucy5jbGFzc05hbWUgfHwgJ29sLWRyYWdib3gnKTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLm1pbkFyZWFfID0gb3B0aW9ucy5taW5BcmVhICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm1pbkFyZWEgOiA2NDtcblxuICAgIGlmIChvcHRpb25zLm9uQm94RW5kKSB7XG4gICAgICB0aGlzLm9uQm94RW5kID0gb3B0aW9ucy5vbkJveEVuZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vcGl4ZWwuanNcIikuUGl4ZWx9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLnN0YXJ0UGl4ZWxfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL2V2ZW50cy9jb25kaXRpb24uanNcIikuQ29uZGl0aW9ufVxuICAgICAqL1xuICAgIHRoaXMuY29uZGl0aW9uXyA9IG9wdGlvbnMuY29uZGl0aW9uID8gb3B0aW9ucy5jb25kaXRpb24gOiBtb3VzZUFjdGlvbkJ1dHRvbjtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0VuZENvbmRpdGlvbn1cbiAgICAgKi9cbiAgICB0aGlzLmJveEVuZENvbmRpdGlvbl8gPSBvcHRpb25zLmJveEVuZENvbmRpdGlvblxuICAgICAgPyBvcHRpb25zLmJveEVuZENvbmRpdGlvblxuICAgICAgOiB0aGlzLmRlZmF1bHRCb3hFbmRDb25kaXRpb247XG4gIH1cblxuICAvKipcbiAgICogVGhlIGRlZmF1bHQgY29uZGl0aW9uIGZvciBkZXRlcm1pbmluZyB3aGV0aGVyIHRoZSBib3hlbmQgZXZlbnRcbiAgICogc2hvdWxkIGZpcmUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLmRlZmF1bHR9IG1hcEJyb3dzZXJFdmVudCBUaGUgb3JpZ2luYXRpbmcgTWFwQnJvd3NlckV2ZW50XG4gICAqICAgICBsZWFkaW5nIHRvIHRoZSBib3ggZW5kLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3BpeGVsLmpzXCIpLlBpeGVsfSBzdGFydFBpeGVsIFRoZSBzdGFydGluZyBwaXhlbCBvZiB0aGUgYm94LlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3BpeGVsLmpzXCIpLlBpeGVsfSBlbmRQaXhlbCBUaGUgZW5kIHBpeGVsIG9mIHRoZSBib3guXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgb3Igbm90IHRoZSBib3hlbmQgY29uZGl0aW9uIHNob3VsZCBiZSBmaXJlZC5cbiAgICovXG4gIGRlZmF1bHRCb3hFbmRDb25kaXRpb24obWFwQnJvd3NlckV2ZW50LCBzdGFydFBpeGVsLCBlbmRQaXhlbCkge1xuICAgIGNvbnN0IHdpZHRoID0gZW5kUGl4ZWxbMF0gLSBzdGFydFBpeGVsWzBdO1xuICAgIGNvbnN0IGhlaWdodCA9IGVuZFBpeGVsWzFdIC0gc3RhcnRQaXhlbFsxXTtcbiAgICByZXR1cm4gd2lkdGggKiB3aWR0aCArIGhlaWdodCAqIGhlaWdodCA+PSB0aGlzLm1pbkFyZWFfO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZ2VvbWV0cnkgb2YgbGFzdCBkcmF3biBib3guXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL2dlb20vUG9seWdvbi5qc1wiKS5kZWZhdWx0fSBHZW9tZXRyeS5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0R2VvbWV0cnkoKSB7XG4gICAgcmV0dXJuIHRoaXMuYm94Xy5nZXRHZW9tZXRyeSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBwb2ludGVyIGRyYWcgZXZlbnRzLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcEJyb3dzZXJFdmVudC5qc1wiKS5kZWZhdWx0fSBtYXBCcm93c2VyRXZlbnQgRXZlbnQuXG4gICAqL1xuICBoYW5kbGVEcmFnRXZlbnQobWFwQnJvd3NlckV2ZW50KSB7XG4gICAgdGhpcy5ib3hfLnNldFBpeGVscyh0aGlzLnN0YXJ0UGl4ZWxfLCBtYXBCcm93c2VyRXZlbnQucGl4ZWwpO1xuXG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KFxuICAgICAgbmV3IERyYWdCb3hFdmVudChcbiAgICAgICAgRHJhZ0JveEV2ZW50VHlwZS5CT1hEUkFHLFxuICAgICAgICBtYXBCcm93c2VyRXZlbnQuY29vcmRpbmF0ZSxcbiAgICAgICAgbWFwQnJvd3NlckV2ZW50XG4gICAgICApXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgcG9pbnRlciB1cCBldmVudHMuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLmRlZmF1bHR9IG1hcEJyb3dzZXJFdmVudCBFdmVudC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gSWYgdGhlIGV2ZW50IHdhcyBjb25zdW1lZC5cbiAgICovXG4gIGhhbmRsZVVwRXZlbnQobWFwQnJvd3NlckV2ZW50KSB7XG4gICAgdGhpcy5ib3hfLnNldE1hcChudWxsKTtcblxuICAgIGNvbnN0IGNvbXBsZXRlQm94ID0gdGhpcy5ib3hFbmRDb25kaXRpb25fKFxuICAgICAgbWFwQnJvd3NlckV2ZW50LFxuICAgICAgdGhpcy5zdGFydFBpeGVsXyxcbiAgICAgIG1hcEJyb3dzZXJFdmVudC5waXhlbFxuICAgICk7XG4gICAgaWYgKGNvbXBsZXRlQm94KSB7XG4gICAgICB0aGlzLm9uQm94RW5kKG1hcEJyb3dzZXJFdmVudCk7XG4gICAgfVxuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChcbiAgICAgIG5ldyBEcmFnQm94RXZlbnQoXG4gICAgICAgIGNvbXBsZXRlQm94ID8gRHJhZ0JveEV2ZW50VHlwZS5CT1hFTkQgOiBEcmFnQm94RXZlbnRUeXBlLkJPWENBTkNFTCxcbiAgICAgICAgbWFwQnJvd3NlckV2ZW50LmNvb3JkaW5hdGUsXG4gICAgICAgIG1hcEJyb3dzZXJFdmVudFxuICAgICAgKVxuICAgICk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBwb2ludGVyIGRvd24gZXZlbnRzLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcEJyb3dzZXJFdmVudC5qc1wiKS5kZWZhdWx0fSBtYXBCcm93c2VyRXZlbnQgRXZlbnQuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IElmIHRoZSBldmVudCB3YXMgY29uc3VtZWQuXG4gICAqL1xuICBoYW5kbGVEb3duRXZlbnQobWFwQnJvd3NlckV2ZW50KSB7XG4gICAgaWYgKHRoaXMuY29uZGl0aW9uXyhtYXBCcm93c2VyRXZlbnQpKSB7XG4gICAgICB0aGlzLnN0YXJ0UGl4ZWxfID0gbWFwQnJvd3NlckV2ZW50LnBpeGVsO1xuICAgICAgdGhpcy5ib3hfLnNldE1hcChtYXBCcm93c2VyRXZlbnQubWFwKTtcbiAgICAgIHRoaXMuYm94Xy5zZXRQaXhlbHModGhpcy5zdGFydFBpeGVsXywgdGhpcy5zdGFydFBpeGVsXyk7XG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoXG4gICAgICAgIG5ldyBEcmFnQm94RXZlbnQoXG4gICAgICAgICAgRHJhZ0JveEV2ZW50VHlwZS5CT1hTVEFSVCxcbiAgICAgICAgICBtYXBCcm93c2VyRXZlbnQuY29vcmRpbmF0ZSxcbiAgICAgICAgICBtYXBCcm93c2VyRXZlbnRcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogRnVuY3Rpb24gdG8gZXhlY3V0ZSBqdXN0IGJlZm9yZSBgb25ib3hlbmRgIGlzIGZpcmVkXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLmRlZmF1bHR9IGV2ZW50IEV2ZW50LlxuICAgKi9cbiAgb25Cb3hFbmQoZXZlbnQpIHt9XG59XG5cbmV4cG9ydCBkZWZhdWx0IERyYWdCb3g7XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvaW50ZXJhY3Rpb24vRHJhZ1BhblxuICovXG5pbXBvcnQgUG9pbnRlckludGVyYWN0aW9uLCB7XG4gIGNlbnRyb2lkIGFzIGNlbnRyb2lkRnJvbVBvaW50ZXJzLFxufSBmcm9tICcuL1BvaW50ZXIuanMnO1xuaW1wb3J0IHtGQUxTRX0gZnJvbSAnLi4vZnVuY3Rpb25zLmpzJztcbmltcG9ydCB7XG4gIGFsbCxcbiAgZm9jdXNXaXRoVGFiaW5kZXgsXG4gIG5vTW9kaWZpZXJLZXlzLFxuICBwcmltYXJ5QWN0aW9uLFxufSBmcm9tICcuLi9ldmVudHMvY29uZGl0aW9uLmpzJztcbmltcG9ydCB7ZWFzZU91dH0gZnJvbSAnLi4vZWFzaW5nLmpzJztcbmltcG9ydCB7XG4gIHJvdGF0ZSBhcyByb3RhdGVDb29yZGluYXRlLFxuICBzY2FsZSBhcyBzY2FsZUNvb3JkaW5hdGUsXG59IGZyb20gJy4uL2Nvb3JkaW5hdGUuanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vZXZlbnRzL2NvbmRpdGlvbi5qc1wiKS5Db25kaXRpb259IFtjb25kaXRpb25dIEEgZnVuY3Rpb24gdGhhdCB0YWtlcyBhbiB7QGxpbmsgbW9kdWxlOm9sL01hcEJyb3dzZXJFdmVudH5NYXBCcm93c2VyRXZlbnR9IGFuZCByZXR1cm5zIGEgYm9vbGVhblxuICogdG8gaW5kaWNhdGUgd2hldGhlciB0aGF0IGV2ZW50IHNob3VsZCBiZSBoYW5kbGVkLlxuICogRGVmYXVsdCBpcyB7QGxpbmsgbW9kdWxlOm9sL2V2ZW50cy9jb25kaXRpb24ubm9Nb2RpZmllcktleXN9IGFuZCB7QGxpbmsgbW9kdWxlOm9sL2V2ZW50cy9jb25kaXRpb24ucHJpbWFyeUFjdGlvbn0uXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtvbkZvY3VzT25seT1mYWxzZV0gV2hlbiB0aGUgbWFwJ3MgdGFyZ2V0IGhhcyBhIGB0YWJpbmRleGAgYXR0cmlidXRlIHNldCxcbiAqIHRoZSBpbnRlcmFjdGlvbiB3aWxsIG9ubHkgaGFuZGxlIGV2ZW50cyB3aGVuIHRoZSBtYXAgaGFzIHRoZSBmb2N1cy5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vS2luZXRpYy5qc1wiKS5kZWZhdWx0fSBba2luZXRpY10gS2luZXRpYyBpbmVydGlhIHRvIGFwcGx5IHRvIHRoZSBwYW4uXG4gKi9cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBBbGxvd3MgdGhlIHVzZXIgdG8gcGFuIHRoZSBtYXAgYnkgZHJhZ2dpbmcgdGhlIG1hcC5cbiAqIEBhcGlcbiAqL1xuY2xhc3MgRHJhZ1BhbiBleHRlbmRzIFBvaW50ZXJJbnRlcmFjdGlvbiB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge09wdGlvbnN9IFtvcHRpb25zXSBPcHRpb25zLlxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHN1cGVyKHtcbiAgICAgIHN0b3BEb3duOiBGQUxTRSxcbiAgICB9KTtcblxuICAgIG9wdGlvbnMgPSBvcHRpb25zID8gb3B0aW9ucyA6IHt9O1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vS2luZXRpYy5qc1wiKS5kZWZhdWx0fHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLmtpbmV0aWNfID0gb3B0aW9ucy5raW5ldGljO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL3BpeGVsLmpzXCIpLlBpeGVsfVxuICAgICAqL1xuICAgIHRoaXMubGFzdENlbnRyb2lkID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5sYXN0UG9pbnRlcnNDb3VudF87XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLnBhbm5pbmdfID0gZmFsc2U7XG5cbiAgICBjb25zdCBjb25kaXRpb24gPSBvcHRpb25zLmNvbmRpdGlvblxuICAgICAgPyBvcHRpb25zLmNvbmRpdGlvblxuICAgICAgOiBhbGwobm9Nb2RpZmllcktleXMsIHByaW1hcnlBY3Rpb24pO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vZXZlbnRzL2NvbmRpdGlvbi5qc1wiKS5Db25kaXRpb259XG4gICAgICovXG4gICAgdGhpcy5jb25kaXRpb25fID0gb3B0aW9ucy5vbkZvY3VzT25seVxuICAgICAgPyBhbGwoZm9jdXNXaXRoVGFiaW5kZXgsIGNvbmRpdGlvbilcbiAgICAgIDogY29uZGl0aW9uO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLm5vS2luZXRpY18gPSBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgcG9pbnRlciBkcmFnIGV2ZW50cy5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdH0gbWFwQnJvd3NlckV2ZW50IEV2ZW50LlxuICAgKi9cbiAgaGFuZGxlRHJhZ0V2ZW50KG1hcEJyb3dzZXJFdmVudCkge1xuICAgIGNvbnN0IG1hcCA9IG1hcEJyb3dzZXJFdmVudC5tYXA7XG4gICAgaWYgKCF0aGlzLnBhbm5pbmdfKSB7XG4gICAgICB0aGlzLnBhbm5pbmdfID0gdHJ1ZTtcbiAgICAgIG1hcC5nZXRWaWV3KCkuYmVnaW5JbnRlcmFjdGlvbigpO1xuICAgIH1cbiAgICBjb25zdCB0YXJnZXRQb2ludGVycyA9IHRoaXMudGFyZ2V0UG9pbnRlcnM7XG4gICAgY29uc3QgY2VudHJvaWQgPSBtYXAuZ2V0RXZlbnRQaXhlbChjZW50cm9pZEZyb21Qb2ludGVycyh0YXJnZXRQb2ludGVycykpO1xuICAgIGlmICh0YXJnZXRQb2ludGVycy5sZW5ndGggPT0gdGhpcy5sYXN0UG9pbnRlcnNDb3VudF8pIHtcbiAgICAgIGlmICh0aGlzLmtpbmV0aWNfKSB7XG4gICAgICAgIHRoaXMua2luZXRpY18udXBkYXRlKGNlbnRyb2lkWzBdLCBjZW50cm9pZFsxXSk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5sYXN0Q2VudHJvaWQpIHtcbiAgICAgICAgY29uc3QgZGVsdGEgPSBbXG4gICAgICAgICAgdGhpcy5sYXN0Q2VudHJvaWRbMF0gLSBjZW50cm9pZFswXSxcbiAgICAgICAgICBjZW50cm9pZFsxXSAtIHRoaXMubGFzdENlbnRyb2lkWzFdLFxuICAgICAgICBdO1xuICAgICAgICBjb25zdCBtYXAgPSBtYXBCcm93c2VyRXZlbnQubWFwO1xuICAgICAgICBjb25zdCB2aWV3ID0gbWFwLmdldFZpZXcoKTtcbiAgICAgICAgc2NhbGVDb29yZGluYXRlKGRlbHRhLCB2aWV3LmdldFJlc29sdXRpb24oKSk7XG4gICAgICAgIHJvdGF0ZUNvb3JkaW5hdGUoZGVsdGEsIHZpZXcuZ2V0Um90YXRpb24oKSk7XG4gICAgICAgIHZpZXcuYWRqdXN0Q2VudGVySW50ZXJuYWwoZGVsdGEpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5raW5ldGljXykge1xuICAgICAgLy8gcmVzZXQgc28gd2UgZG9uJ3Qgb3ZlcmVzdGltYXRlIHRoZSBraW5ldGljIGVuZXJneSBhZnRlclxuICAgICAgLy8gYWZ0ZXIgb25lIGZpbmdlciBkb3duLCB0aW55IGRyYWcsIHNlY29uZCBmaW5nZXIgZG93blxuICAgICAgdGhpcy5raW5ldGljXy5iZWdpbigpO1xuICAgIH1cbiAgICB0aGlzLmxhc3RDZW50cm9pZCA9IGNlbnRyb2lkO1xuICAgIHRoaXMubGFzdFBvaW50ZXJzQ291bnRfID0gdGFyZ2V0UG9pbnRlcnMubGVuZ3RoO1xuICAgIG1hcEJyb3dzZXJFdmVudC5vcmlnaW5hbEV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlIHBvaW50ZXIgdXAgZXZlbnRzLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcEJyb3dzZXJFdmVudC5qc1wiKS5kZWZhdWx0fSBtYXBCcm93c2VyRXZlbnQgRXZlbnQuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IElmIHRoZSBldmVudCB3YXMgY29uc3VtZWQuXG4gICAqL1xuICBoYW5kbGVVcEV2ZW50KG1hcEJyb3dzZXJFdmVudCkge1xuICAgIGNvbnN0IG1hcCA9IG1hcEJyb3dzZXJFdmVudC5tYXA7XG4gICAgY29uc3QgdmlldyA9IG1hcC5nZXRWaWV3KCk7XG4gICAgaWYgKHRoaXMudGFyZ2V0UG9pbnRlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICBpZiAoIXRoaXMubm9LaW5ldGljXyAmJiB0aGlzLmtpbmV0aWNfICYmIHRoaXMua2luZXRpY18uZW5kKCkpIHtcbiAgICAgICAgY29uc3QgZGlzdGFuY2UgPSB0aGlzLmtpbmV0aWNfLmdldERpc3RhbmNlKCk7XG4gICAgICAgIGNvbnN0IGFuZ2xlID0gdGhpcy5raW5ldGljXy5nZXRBbmdsZSgpO1xuICAgICAgICBjb25zdCBjZW50ZXIgPSB2aWV3LmdldENlbnRlckludGVybmFsKCk7XG4gICAgICAgIGNvbnN0IGNlbnRlcnB4ID0gbWFwLmdldFBpeGVsRnJvbUNvb3JkaW5hdGVJbnRlcm5hbChjZW50ZXIpO1xuICAgICAgICBjb25zdCBkZXN0ID0gbWFwLmdldENvb3JkaW5hdGVGcm9tUGl4ZWxJbnRlcm5hbChbXG4gICAgICAgICAgY2VudGVycHhbMF0gLSBkaXN0YW5jZSAqIE1hdGguY29zKGFuZ2xlKSxcbiAgICAgICAgICBjZW50ZXJweFsxXSAtIGRpc3RhbmNlICogTWF0aC5zaW4oYW5nbGUpLFxuICAgICAgICBdKTtcbiAgICAgICAgdmlldy5hbmltYXRlSW50ZXJuYWwoe1xuICAgICAgICAgIGNlbnRlcjogdmlldy5nZXRDb25zdHJhaW5lZENlbnRlcihkZXN0KSxcbiAgICAgICAgICBkdXJhdGlvbjogNTAwLFxuICAgICAgICAgIGVhc2luZzogZWFzZU91dCxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5wYW5uaW5nXykge1xuICAgICAgICB0aGlzLnBhbm5pbmdfID0gZmFsc2U7XG4gICAgICAgIHZpZXcuZW5kSW50ZXJhY3Rpb24oKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHRoaXMua2luZXRpY18pIHtcbiAgICAgIC8vIHJlc2V0IHNvIHdlIGRvbid0IG92ZXJlc3RpbWF0ZSB0aGUga2luZXRpYyBlbmVyZ3kgYWZ0ZXJcbiAgICAgIC8vIGFmdGVyIG9uZSBmaW5nZXIgdXAsIHRpbnkgZHJhZywgc2Vjb25kIGZpbmdlciB1cFxuICAgICAgdGhpcy5raW5ldGljXy5iZWdpbigpO1xuICAgIH1cbiAgICB0aGlzLmxhc3RDZW50cm9pZCA9IG51bGw7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlIHBvaW50ZXIgZG93biBldmVudHMuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLmRlZmF1bHR9IG1hcEJyb3dzZXJFdmVudCBFdmVudC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gSWYgdGhlIGV2ZW50IHdhcyBjb25zdW1lZC5cbiAgICovXG4gIGhhbmRsZURvd25FdmVudChtYXBCcm93c2VyRXZlbnQpIHtcbiAgICBpZiAodGhpcy50YXJnZXRQb2ludGVycy5sZW5ndGggPiAwICYmIHRoaXMuY29uZGl0aW9uXyhtYXBCcm93c2VyRXZlbnQpKSB7XG4gICAgICBjb25zdCBtYXAgPSBtYXBCcm93c2VyRXZlbnQubWFwO1xuICAgICAgY29uc3QgdmlldyA9IG1hcC5nZXRWaWV3KCk7XG4gICAgICB0aGlzLmxhc3RDZW50cm9pZCA9IG51bGw7XG4gICAgICAvLyBzdG9wIGFueSBjdXJyZW50IGFuaW1hdGlvblxuICAgICAgaWYgKHZpZXcuZ2V0QW5pbWF0aW5nKCkpIHtcbiAgICAgICAgdmlldy5jYW5jZWxBbmltYXRpb25zKCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5raW5ldGljXykge1xuICAgICAgICB0aGlzLmtpbmV0aWNfLmJlZ2luKCk7XG4gICAgICB9XG4gICAgICAvLyBObyBraW5ldGljIGFzIHNvb24gYXMgbW9yZSB0aGFuIG9uZSBwb2ludGVyIG9uIHRoZSBzY3JlZW4gaXNcbiAgICAgIC8vIGRldGVjdGVkLiBUaGlzIGlzIHRvIHByZXZlbnQgbmFzdHkgcGFucyBhZnRlciBwaW5jaC5cbiAgICAgIHRoaXMubm9LaW5ldGljXyA9IHRoaXMudGFyZ2V0UG9pbnRlcnMubGVuZ3RoID4gMTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgRHJhZ1BhbjtcbiIsIi8qKlxuICogQG1vZHVsZSBvbC9pbnRlcmFjdGlvbi9EcmFnUm90YXRlXG4gKi9cbmltcG9ydCBQb2ludGVySW50ZXJhY3Rpb24gZnJvbSAnLi9Qb2ludGVyLmpzJztcbmltcG9ydCB7RkFMU0V9IGZyb20gJy4uL2Z1bmN0aW9ucy5qcyc7XG5pbXBvcnQge1xuICBhbHRTaGlmdEtleXNPbmx5LFxuICBtb3VzZUFjdGlvbkJ1dHRvbixcbiAgbW91c2VPbmx5LFxufSBmcm9tICcuLi9ldmVudHMvY29uZGl0aW9uLmpzJztcbmltcG9ydCB7ZGlzYWJsZX0gZnJvbSAnLi4vcm90YXRpb25jb25zdHJhaW50LmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL2V2ZW50cy9jb25kaXRpb24uanNcIikuQ29uZGl0aW9ufSBbY29uZGl0aW9uXSBBIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYW5cbiAqIHtAbGluayBtb2R1bGU6b2wvTWFwQnJvd3NlckV2ZW50fk1hcEJyb3dzZXJFdmVudH0gYW5kIHJldHVybnMgYSBib29sZWFuXG4gKiB0byBpbmRpY2F0ZSB3aGV0aGVyIHRoYXQgZXZlbnQgc2hvdWxkIGJlIGhhbmRsZWQuXG4gKiBEZWZhdWx0IGlzIHtAbGluayBtb2R1bGU6b2wvZXZlbnRzL2NvbmRpdGlvbi5hbHRTaGlmdEtleXNPbmx5fS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbZHVyYXRpb249MjUwXSBBbmltYXRpb24gZHVyYXRpb24gaW4gbWlsbGlzZWNvbmRzLlxuICovXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQWxsb3dzIHRoZSB1c2VyIHRvIHJvdGF0ZSB0aGUgbWFwIGJ5IGNsaWNraW5nIGFuZCBkcmFnZ2luZyBvbiB0aGUgbWFwLFxuICogbm9ybWFsbHkgY29tYmluZWQgd2l0aCBhbiB7QGxpbmsgbW9kdWxlOm9sL2V2ZW50cy9jb25kaXRpb259IHRoYXQgbGltaXRzXG4gKiBpdCB0byB3aGVuIHRoZSBhbHQgYW5kIHNoaWZ0IGtleXMgYXJlIGhlbGQgZG93bi5cbiAqXG4gKiBUaGlzIGludGVyYWN0aW9uIGlzIG9ubHkgc3VwcG9ydGVkIGZvciBtb3VzZSBkZXZpY2VzLlxuICogQGFwaVxuICovXG5jbGFzcyBEcmFnUm90YXRlIGV4dGVuZHMgUG9pbnRlckludGVyYWN0aW9uIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7T3B0aW9uc30gW29wdGlvbnNdIE9wdGlvbnMuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgPyBvcHRpb25zIDoge307XG5cbiAgICBzdXBlcih7XG4gICAgICBzdG9wRG93bjogRkFMU0UsXG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9ldmVudHMvY29uZGl0aW9uLmpzXCIpLkNvbmRpdGlvbn1cbiAgICAgKi9cbiAgICB0aGlzLmNvbmRpdGlvbl8gPSBvcHRpb25zLmNvbmRpdGlvbiA/IG9wdGlvbnMuY29uZGl0aW9uIDogYWx0U2hpZnRLZXlzT25seTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcnx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5sYXN0QW5nbGVfID0gdW5kZWZpbmVkO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuZHVyYXRpb25fID0gb3B0aW9ucy5kdXJhdGlvbiAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5kdXJhdGlvbiA6IDI1MDtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgcG9pbnRlciBkcmFnIGV2ZW50cy5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdH0gbWFwQnJvd3NlckV2ZW50IEV2ZW50LlxuICAgKi9cbiAgaGFuZGxlRHJhZ0V2ZW50KG1hcEJyb3dzZXJFdmVudCkge1xuICAgIGlmICghbW91c2VPbmx5KG1hcEJyb3dzZXJFdmVudCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBtYXAgPSBtYXBCcm93c2VyRXZlbnQubWFwO1xuICAgIGNvbnN0IHZpZXcgPSBtYXAuZ2V0VmlldygpO1xuICAgIGlmICh2aWV3LmdldENvbnN0cmFpbnRzKCkucm90YXRpb24gPT09IGRpc2FibGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc2l6ZSA9IG1hcC5nZXRTaXplKCk7XG4gICAgY29uc3Qgb2Zmc2V0ID0gbWFwQnJvd3NlckV2ZW50LnBpeGVsO1xuICAgIGNvbnN0IHRoZXRhID0gTWF0aC5hdGFuMihzaXplWzFdIC8gMiAtIG9mZnNldFsxXSwgb2Zmc2V0WzBdIC0gc2l6ZVswXSAvIDIpO1xuICAgIGlmICh0aGlzLmxhc3RBbmdsZV8gIT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc3QgZGVsdGEgPSB0aGV0YSAtIHRoaXMubGFzdEFuZ2xlXztcbiAgICAgIHZpZXcuYWRqdXN0Um90YXRpb25JbnRlcm5hbCgtZGVsdGEpO1xuICAgIH1cbiAgICB0aGlzLmxhc3RBbmdsZV8gPSB0aGV0YTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgcG9pbnRlciB1cCBldmVudHMuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLmRlZmF1bHR9IG1hcEJyb3dzZXJFdmVudCBFdmVudC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gSWYgdGhlIGV2ZW50IHdhcyBjb25zdW1lZC5cbiAgICovXG4gIGhhbmRsZVVwRXZlbnQobWFwQnJvd3NlckV2ZW50KSB7XG4gICAgaWYgKCFtb3VzZU9ubHkobWFwQnJvd3NlckV2ZW50KSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgY29uc3QgbWFwID0gbWFwQnJvd3NlckV2ZW50Lm1hcDtcbiAgICBjb25zdCB2aWV3ID0gbWFwLmdldFZpZXcoKTtcbiAgICB2aWV3LmVuZEludGVyYWN0aW9uKHRoaXMuZHVyYXRpb25fKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlIHBvaW50ZXIgZG93biBldmVudHMuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLmRlZmF1bHR9IG1hcEJyb3dzZXJFdmVudCBFdmVudC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gSWYgdGhlIGV2ZW50IHdhcyBjb25zdW1lZC5cbiAgICovXG4gIGhhbmRsZURvd25FdmVudChtYXBCcm93c2VyRXZlbnQpIHtcbiAgICBpZiAoIW1vdXNlT25seShtYXBCcm93c2VyRXZlbnQpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgbW91c2VBY3Rpb25CdXR0b24obWFwQnJvd3NlckV2ZW50KSAmJlxuICAgICAgdGhpcy5jb25kaXRpb25fKG1hcEJyb3dzZXJFdmVudClcbiAgICApIHtcbiAgICAgIGNvbnN0IG1hcCA9IG1hcEJyb3dzZXJFdmVudC5tYXA7XG4gICAgICBtYXAuZ2V0VmlldygpLmJlZ2luSW50ZXJhY3Rpb24oKTtcbiAgICAgIHRoaXMubGFzdEFuZ2xlXyA9IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgRHJhZ1JvdGF0ZTtcbiIsIi8qKlxuICogQG1vZHVsZSBvbC9pbnRlcmFjdGlvbi9EcmFnWm9vbVxuICovXG5pbXBvcnQgRHJhZ0JveCBmcm9tICcuL0RyYWdCb3guanMnO1xuaW1wb3J0IHtlYXNlT3V0fSBmcm9tICcuLi9lYXNpbmcuanMnO1xuaW1wb3J0IHtzaGlmdEtleU9ubHl9IGZyb20gJy4uL2V2ZW50cy9jb25kaXRpb24uanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbY2xhc3NOYW1lPSdvbC1kcmFnem9vbSddIENTUyBjbGFzcyBuYW1lIGZvciBzdHlsaW5nIHRoZVxuICogYm94LlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9ldmVudHMvY29uZGl0aW9uLmpzXCIpLkNvbmRpdGlvbn0gW2NvbmRpdGlvbl0gQSBmdW5jdGlvbiB0aGF0XG4gKiB0YWtlcyBhbiB7QGxpbmsgbW9kdWxlOm9sL01hcEJyb3dzZXJFdmVudH5NYXBCcm93c2VyRXZlbnR9IGFuZCByZXR1cm5zIGFcbiAqIGJvb2xlYW4gdG8gaW5kaWNhdGUgd2hldGhlciB0aGF0IGV2ZW50IHNob3VsZCBiZSBoYW5kbGVkLlxuICogRGVmYXVsdCBpcyB7QGxpbmsgbW9kdWxlOm9sL2V2ZW50cy9jb25kaXRpb24uc2hpZnRLZXlPbmx5fS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbZHVyYXRpb249MjAwXSBBbmltYXRpb24gZHVyYXRpb24gaW4gbWlsbGlzZWNvbmRzLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbb3V0PWZhbHNlXSBVc2UgaW50ZXJhY3Rpb24gZm9yIHpvb21pbmcgb3V0LlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFttaW5BcmVhPTY0XSBUaGUgbWluaW11bSBhcmVhIG9mIHRoZSBib3ggaW4gcGl4ZWwsIHRoaXMgdmFsdWUgaXMgdXNlZCBieSB0aGUgcGFyZW50IGRlZmF1bHRcbiAqIGBib3hFbmRDb25kaXRpb25gIGZ1bmN0aW9uLlxuICovXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQWxsb3dzIHRoZSB1c2VyIHRvIHpvb20gdGhlIG1hcCBieSBjbGlja2luZyBhbmQgZHJhZ2dpbmcgb24gdGhlIG1hcCxcbiAqIG5vcm1hbGx5IGNvbWJpbmVkIHdpdGggYW4ge0BsaW5rIG1vZHVsZTpvbC9ldmVudHMvY29uZGl0aW9ufSB0aGF0IGxpbWl0c1xuICogaXQgdG8gd2hlbiBhIGtleSwgc2hpZnQgYnkgZGVmYXVsdCwgaXMgaGVsZCBkb3duLlxuICpcbiAqIFRvIGNoYW5nZSB0aGUgc3R5bGUgb2YgdGhlIGJveCwgdXNlIENTUyBhbmQgdGhlIGAub2wtZHJhZ3pvb21gIHNlbGVjdG9yLCBvclxuICogeW91ciBjdXN0b20gb25lIGNvbmZpZ3VyZWQgd2l0aCBgY2xhc3NOYW1lYC5cbiAqIEBhcGlcbiAqL1xuY2xhc3MgRHJhZ1pvb20gZXh0ZW5kcyBEcmFnQm94IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7T3B0aW9uc30gW29wdGlvbnNdIE9wdGlvbnMuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgPyBvcHRpb25zIDoge307XG5cbiAgICBjb25zdCBjb25kaXRpb24gPSBvcHRpb25zLmNvbmRpdGlvbiA/IG9wdGlvbnMuY29uZGl0aW9uIDogc2hpZnRLZXlPbmx5O1xuXG4gICAgc3VwZXIoe1xuICAgICAgY29uZGl0aW9uOiBjb25kaXRpb24sXG4gICAgICBjbGFzc05hbWU6IG9wdGlvbnMuY2xhc3NOYW1lIHx8ICdvbC1kcmFnem9vbScsXG4gICAgICBtaW5BcmVhOiBvcHRpb25zLm1pbkFyZWEsXG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5kdXJhdGlvbl8gPSBvcHRpb25zLmR1cmF0aW9uICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmR1cmF0aW9uIDogMjAwO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLm91dF8gPSBvcHRpb25zLm91dCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5vdXQgOiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGdW5jdGlvbiB0byBleGVjdXRlIGp1c3QgYmVmb3JlIGBvbmJveGVuZGAgaXMgZmlyZWRcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdH0gZXZlbnQgRXZlbnQuXG4gICAqL1xuICBvbkJveEVuZChldmVudCkge1xuICAgIGNvbnN0IG1hcCA9IHRoaXMuZ2V0TWFwKCk7XG4gICAgY29uc3QgdmlldyA9IC8qKiBAdHlwZSB7IWltcG9ydChcIi4uL1ZpZXcuanNcIikuZGVmYXVsdH0gKi8gKG1hcC5nZXRWaWV3KCkpO1xuICAgIGxldCBnZW9tZXRyeSA9IHRoaXMuZ2V0R2VvbWV0cnkoKTtcblxuICAgIGlmICh0aGlzLm91dF8pIHtcbiAgICAgIGNvbnN0IHJvdGF0ZWRFeHRlbnQgPSB2aWV3LnJvdGF0ZWRFeHRlbnRGb3JHZW9tZXRyeShnZW9tZXRyeSk7XG4gICAgICBjb25zdCByZXNvbHV0aW9uID0gdmlldy5nZXRSZXNvbHV0aW9uRm9yRXh0ZW50SW50ZXJuYWwocm90YXRlZEV4dGVudCk7XG4gICAgICBjb25zdCBmYWN0b3IgPSB2aWV3LmdldFJlc29sdXRpb24oKSAvIHJlc29sdXRpb247XG4gICAgICBnZW9tZXRyeSA9IGdlb21ldHJ5LmNsb25lKCk7XG4gICAgICBnZW9tZXRyeS5zY2FsZShmYWN0b3IgKiBmYWN0b3IpO1xuICAgIH1cblxuICAgIHZpZXcuZml0SW50ZXJuYWwoZ2VvbWV0cnksIHtcbiAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uXyxcbiAgICAgIGVhc2luZzogZWFzZU91dCxcbiAgICB9KTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBEcmFnWm9vbTtcbiIsIi8qKlxuICogQG1vZHVsZSBvbC9pbnRlcmFjdGlvbi9JbnRlcmFjdGlvblxuICovXG5pbXBvcnQgQmFzZU9iamVjdCBmcm9tICcuLi9PYmplY3QuanMnO1xuaW1wb3J0IEludGVyYWN0aW9uUHJvcGVydHkgZnJvbSAnLi9Qcm9wZXJ0eS5qcyc7XG5pbXBvcnQge2Vhc2VPdXQsIGxpbmVhcn0gZnJvbSAnLi4vZWFzaW5nLmpzJztcblxuLyoqKlxuICogQHRlbXBsYXRlIFJldHVyblxuICogQHR5cGVkZWYge2ltcG9ydChcIi4uL09ic2VydmFibGVcIikuT25TaWduYXR1cmU8aW1wb3J0KFwiLi4vT2JzZXJ2YWJsZVwiKS5FdmVudFR5cGVzLCBpbXBvcnQoXCIuLi9ldmVudHMvRXZlbnQuanNcIikuZGVmYXVsdCwgUmV0dXJuPiAmXG4gKiAgIGltcG9ydChcIi4uL09ic2VydmFibGVcIikuT25TaWduYXR1cmU8aW1wb3J0KFwiLi4vT2JqZWN0RXZlbnRUeXBlXCIpLlR5cGVzfFxuICogICAgICdjaGFuZ2U6YWN0aXZlJywgaW1wb3J0KFwiLi4vT2JqZWN0XCIpLk9iamVjdEV2ZW50LCBSZXR1cm4+ICZcbiAqICAgaW1wb3J0KFwiLi4vT2JzZXJ2YWJsZVwiKS5Db21iaW5lZE9uU2lnbmF0dXJlPGltcG9ydChcIi4uL09ic2VydmFibGVcIikuRXZlbnRUeXBlc3xpbXBvcnQoXCIuLi9PYmplY3RFdmVudFR5cGVcIikuVHlwZXN8XG4gKiAgICAgJ2NoYW5nZTphY3RpdmUnLCBSZXR1cm4+fSBJbnRlcmFjdGlvbk9uU2lnbmF0dXJlXG4gKi9cblxuLyoqXG4gKiBPYmplY3QgbGl0ZXJhbCB3aXRoIGNvbmZpZyBvcHRpb25zIGZvciBpbnRlcmFjdGlvbnMuXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBJbnRlcmFjdGlvbk9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb24oaW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLmRlZmF1bHQpOmJvb2xlYW59IGhhbmRsZUV2ZW50XG4gKiBNZXRob2QgY2FsbGVkIGJ5IHRoZSBtYXAgdG8gbm90aWZ5IHRoZSBpbnRlcmFjdGlvbiB0aGF0IGEgYnJvd3NlciBldmVudCB3YXNcbiAqIGRpc3BhdGNoZWQgdG8gdGhlIG1hcC4gSWYgdGhlIGZ1bmN0aW9uIHJldHVybnMgYSBmYWxzeSB2YWx1ZSwgcHJvcGFnYXRpb24gb2ZcbiAqIHRoZSBldmVudCB0byBvdGhlciBpbnRlcmFjdGlvbnMgaW4gdGhlIG1hcCdzIGludGVyYWN0aW9ucyBjaGFpbiB3aWxsIGJlXG4gKiBwcmV2ZW50ZWQgKHRoaXMgaW5jbHVkZXMgZnVuY3Rpb25zIHdpdGggbm8gZXhwbGljaXQgcmV0dXJuKS4gVGhlIGludGVyYWN0aW9uc1xuICogYXJlIHRyYXZlcnNlZCBpbiByZXZlcnNlIG9yZGVyIG9mIHRoZSBpbnRlcmFjdGlvbnMgY29sbGVjdGlvbiBvZiB0aGUgbWFwLlxuICovXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQWJzdHJhY3QgYmFzZSBjbGFzczsgbm9ybWFsbHkgb25seSB1c2VkIGZvciBjcmVhdGluZyBzdWJjbGFzc2VzIGFuZCBub3RcbiAqIGluc3RhbnRpYXRlZCBpbiBhcHBzLlxuICogVXNlciBhY3Rpb25zIHRoYXQgY2hhbmdlIHRoZSBzdGF0ZSBvZiB0aGUgbWFwLiBTb21lIGFyZSBzaW1pbGFyIHRvIGNvbnRyb2xzLFxuICogYnV0IGFyZSBub3QgYXNzb2NpYXRlZCB3aXRoIGEgRE9NIGVsZW1lbnQuXG4gKiBGb3IgZXhhbXBsZSwge0BsaW5rIG1vZHVsZTpvbC9pbnRlcmFjdGlvbi9LZXlib2FyZFpvb21+S2V5Ym9hcmRab29tfSBpc1xuICogZnVuY3Rpb25hbGx5IHRoZSBzYW1lIGFzIHtAbGluayBtb2R1bGU6b2wvY29udHJvbC9ab29tflpvb219LCBidXQgdHJpZ2dlcmVkXG4gKiBieSBhIGtleWJvYXJkIGV2ZW50IG5vdCBhIGJ1dHRvbiBlbGVtZW50IGV2ZW50LlxuICogQWx0aG91Z2ggaW50ZXJhY3Rpb25zIGRvIG5vdCBoYXZlIGEgRE9NIGVsZW1lbnQsIHNvbWUgb2YgdGhlbSBkbyByZW5kZXJcbiAqIHZlY3RvcnMgYW5kIHNvIGFyZSB2aXNpYmxlIG9uIHRoZSBzY3JlZW4uXG4gKiBAYXBpXG4gKi9cbmNsYXNzIEludGVyYWN0aW9uIGV4dGVuZHMgQmFzZU9iamVjdCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0ludGVyYWN0aW9uT3B0aW9uc30gW29wdGlvbnNdIE9wdGlvbnMuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIC8qKipcbiAgICAgKiBAdHlwZSB7SW50ZXJhY3Rpb25PblNpZ25hdHVyZTxpbXBvcnQoXCIuLi9ldmVudHNcIikuRXZlbnRzS2V5Pn1cbiAgICAgKi9cbiAgICB0aGlzLm9uO1xuXG4gICAgLyoqKlxuICAgICAqIEB0eXBlIHtJbnRlcmFjdGlvbk9uU2lnbmF0dXJlPGltcG9ydChcIi4uL2V2ZW50c1wiKS5FdmVudHNLZXk+fVxuICAgICAqL1xuICAgIHRoaXMub25jZTtcblxuICAgIC8qKipcbiAgICAgKiBAdHlwZSB7SW50ZXJhY3Rpb25PblNpZ25hdHVyZTx2b2lkPn1cbiAgICAgKi9cbiAgICB0aGlzLnVuO1xuXG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5oYW5kbGVFdmVudCkge1xuICAgICAgdGhpcy5oYW5kbGVFdmVudCA9IG9wdGlvbnMuaGFuZGxlRXZlbnQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vTWFwLmpzXCIpLmRlZmF1bHR8bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLm1hcF8gPSBudWxsO1xuXG4gICAgdGhpcy5zZXRBY3RpdmUodHJ1ZSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHdoZXRoZXIgdGhlIGludGVyYWN0aW9uIGlzIGN1cnJlbnRseSBhY3RpdmUuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgaW50ZXJhY3Rpb24gaXMgYWN0aXZlLCBgZmFsc2VgIG90aGVyd2lzZS5cbiAgICogQG9ic2VydmFibGVcbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0QWN0aXZlKCkge1xuICAgIHJldHVybiAvKiogQHR5cGUge2Jvb2xlYW59ICovICh0aGlzLmdldChJbnRlcmFjdGlvblByb3BlcnR5LkFDVElWRSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbWFwIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGludGVyYWN0aW9uLlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9NYXAuanNcIikuZGVmYXVsdHxudWxsfSBNYXAuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldE1hcCgpIHtcbiAgICByZXR1cm4gdGhpcy5tYXBfO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgdGhlIHtAbGluayBtb2R1bGU6b2wvTWFwQnJvd3NlckV2ZW50fk1hcEJyb3dzZXJFdmVudCBtYXAgYnJvd3NlciBldmVudH0uXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLmRlZmF1bHR9IG1hcEJyb3dzZXJFdmVudCBNYXAgYnJvd3NlciBldmVudC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gYGZhbHNlYCB0byBzdG9wIGV2ZW50IHByb3BhZ2F0aW9uLlxuICAgKiBAYXBpXG4gICAqL1xuICBoYW5kbGVFdmVudChtYXBCcm93c2VyRXZlbnQpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBY3RpdmF0ZSBvciBkZWFjdGl2YXRlIHRoZSBpbnRlcmFjdGlvbi5cbiAgICogQHBhcmFtIHtib29sZWFufSBhY3RpdmUgQWN0aXZlLlxuICAgKiBAb2JzZXJ2YWJsZVxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRBY3RpdmUoYWN0aXZlKSB7XG4gICAgdGhpcy5zZXQoSW50ZXJhY3Rpb25Qcm9wZXJ0eS5BQ1RJVkUsIGFjdGl2ZSk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIHRoZSBpbnRlcmFjdGlvbiBmcm9tIGl0cyBjdXJyZW50IG1hcCBhbmQgYXR0YWNoIGl0IHRvIHRoZSBuZXcgbWFwLlxuICAgKiBTdWJjbGFzc2VzIG1heSBzZXQgdXAgZXZlbnQgaGFuZGxlcnMgdG8gZ2V0IG5vdGlmaWVkIGFib3V0IGNoYW5nZXMgdG9cbiAgICogdGhlIG1hcCBoZXJlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcC5qc1wiKS5kZWZhdWx0fG51bGx9IG1hcCBNYXAuXG4gICAqL1xuICBzZXRNYXAobWFwKSB7XG4gICAgdGhpcy5tYXBfID0gbWFwO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9WaWV3LmpzXCIpLmRlZmF1bHR9IHZpZXcgVmlldy5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBkZWx0YSBEZWx0YS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbZHVyYXRpb25dIER1cmF0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFuKHZpZXcsIGRlbHRhLCBkdXJhdGlvbikge1xuICBjb25zdCBjdXJyZW50Q2VudGVyID0gdmlldy5nZXRDZW50ZXJJbnRlcm5hbCgpO1xuICBpZiAoY3VycmVudENlbnRlcikge1xuICAgIGNvbnN0IGNlbnRlciA9IFtjdXJyZW50Q2VudGVyWzBdICsgZGVsdGFbMF0sIGN1cnJlbnRDZW50ZXJbMV0gKyBkZWx0YVsxXV07XG4gICAgdmlldy5hbmltYXRlSW50ZXJuYWwoe1xuICAgICAgZHVyYXRpb246IGR1cmF0aW9uICE9PSB1bmRlZmluZWQgPyBkdXJhdGlvbiA6IDI1MCxcbiAgICAgIGVhc2luZzogbGluZWFyLFxuICAgICAgY2VudGVyOiB2aWV3LmdldENvbnN0cmFpbmVkQ2VudGVyKGNlbnRlciksXG4gICAgfSk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL1ZpZXcuanNcIikuZGVmYXVsdH0gdmlldyBWaWV3LlxuICogQHBhcmFtIHtudW1iZXJ9IGRlbHRhIERlbHRhIGZyb20gcHJldmlvdXMgem9vbSBsZXZlbC5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBbYW5jaG9yXSBBbmNob3IgY29vcmRpbmF0ZSBpbiB0aGUgdXNlciBwcm9qZWN0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IFtkdXJhdGlvbl0gRHVyYXRpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB6b29tQnlEZWx0YSh2aWV3LCBkZWx0YSwgYW5jaG9yLCBkdXJhdGlvbikge1xuICBjb25zdCBjdXJyZW50Wm9vbSA9IHZpZXcuZ2V0Wm9vbSgpO1xuXG4gIGlmIChjdXJyZW50Wm9vbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgbmV3Wm9vbSA9IHZpZXcuZ2V0Q29uc3RyYWluZWRab29tKGN1cnJlbnRab29tICsgZGVsdGEpO1xuICBjb25zdCBuZXdSZXNvbHV0aW9uID0gdmlldy5nZXRSZXNvbHV0aW9uRm9yWm9vbShuZXdab29tKTtcblxuICBpZiAodmlldy5nZXRBbmltYXRpbmcoKSkge1xuICAgIHZpZXcuY2FuY2VsQW5pbWF0aW9ucygpO1xuICB9XG4gIHZpZXcuYW5pbWF0ZSh7XG4gICAgcmVzb2x1dGlvbjogbmV3UmVzb2x1dGlvbixcbiAgICBhbmNob3I6IGFuY2hvcixcbiAgICBkdXJhdGlvbjogZHVyYXRpb24gIT09IHVuZGVmaW5lZCA/IGR1cmF0aW9uIDogMjUwLFxuICAgIGVhc2luZzogZWFzZU91dCxcbiAgfSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IEludGVyYWN0aW9uO1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2ludGVyYWN0aW9uL0tleWJvYXJkUGFuXG4gKi9cbmltcG9ydCBFdmVudFR5cGUgZnJvbSAnLi4vZXZlbnRzL0V2ZW50VHlwZS5qcyc7XG5pbXBvcnQgSW50ZXJhY3Rpb24sIHtwYW59IGZyb20gJy4vSW50ZXJhY3Rpb24uanMnO1xuaW1wb3J0IEtleSBmcm9tICcuLi9ldmVudHMvS2V5LmpzJztcbmltcG9ydCB7bm9Nb2RpZmllcktleXMsIHRhcmdldE5vdEVkaXRhYmxlfSBmcm9tICcuLi9ldmVudHMvY29uZGl0aW9uLmpzJztcbmltcG9ydCB7cm90YXRlIGFzIHJvdGF0ZUNvb3JkaW5hdGV9IGZyb20gJy4uL2Nvb3JkaW5hdGUuanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vZXZlbnRzL2NvbmRpdGlvbi5qc1wiKS5Db25kaXRpb259IFtjb25kaXRpb25dIEEgZnVuY3Rpb24gdGhhdFxuICogdGFrZXMgYW4ge0BsaW5rIG1vZHVsZTpvbC9NYXBCcm93c2VyRXZlbnR+TWFwQnJvd3NlckV2ZW50fSBhbmQgcmV0dXJucyBhXG4gKiBib29sZWFuIHRvIGluZGljYXRlIHdoZXRoZXIgdGhhdCBldmVudCBzaG91bGQgYmUgaGFuZGxlZC4gRGVmYXVsdCBpc1xuICoge0BsaW5rIG1vZHVsZTpvbC9ldmVudHMvY29uZGl0aW9uLm5vTW9kaWZpZXJLZXlzfSBhbmRcbiAqIHtAbGluayBtb2R1bGU6b2wvZXZlbnRzL2NvbmRpdGlvbi50YXJnZXROb3RFZGl0YWJsZX0uXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2R1cmF0aW9uPTEwMF0gQW5pbWF0aW9uIGR1cmF0aW9uIGluIG1pbGxpc2Vjb25kcy5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbcGl4ZWxEZWx0YT0xMjhdIFRoZSBhbW91bnQgb2YgcGl4ZWxzIHRvIHBhbiBvbiBlYWNoIGtleVxuICogcHJlc3MuXG4gKi9cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBBbGxvd3MgdGhlIHVzZXIgdG8gcGFuIHRoZSBtYXAgdXNpbmcga2V5Ym9hcmQgYXJyb3dzLlxuICogTm90ZSB0aGF0LCBhbHRob3VnaCB0aGlzIGludGVyYWN0aW9uIGlzIGJ5IGRlZmF1bHQgaW5jbHVkZWQgaW4gbWFwcyxcbiAqIHRoZSBrZXlzIGNhbiBvbmx5IGJlIHVzZWQgd2hlbiBicm93c2VyIGZvY3VzIGlzIG9uIHRoZSBlbGVtZW50IHRvIHdoaWNoXG4gKiB0aGUga2V5Ym9hcmQgZXZlbnRzIGFyZSBhdHRhY2hlZC4gQnkgZGVmYXVsdCwgdGhpcyBpcyB0aGUgbWFwIGRpdixcbiAqIHRob3VnaCB5b3UgY2FuIGNoYW5nZSB0aGlzIHdpdGggdGhlIGBrZXlib2FyZEV2ZW50VGFyZ2V0YCBpblxuICoge0BsaW5rIG1vZHVsZTpvbC9NYXB+TWFwfS4gYGRvY3VtZW50YCBuZXZlciBsb3NlcyBmb2N1cyBidXQsIGZvciBhbnkgb3RoZXJcbiAqIGVsZW1lbnQsIGZvY3VzIHdpbGwgaGF2ZSB0byBiZSBvbiwgYW5kIHJldHVybmVkIHRvLCB0aGlzIGVsZW1lbnQgaWYgdGhlIGtleXNcbiAqIGFyZSB0byBmdW5jdGlvbi5cbiAqIFNlZSBhbHNvIHtAbGluayBtb2R1bGU6b2wvaW50ZXJhY3Rpb24vS2V5Ym9hcmRab29tfktleWJvYXJkWm9vbX0uXG4gKiBAYXBpXG4gKi9cbmNsYXNzIEtleWJvYXJkUGFuIGV4dGVuZHMgSW50ZXJhY3Rpb24ge1xuICAvKipcbiAgICogQHBhcmFtIHtPcHRpb25zfSBbb3B0aW9uc10gT3B0aW9ucy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLmRlZmF1bHR9IG1hcEJyb3dzZXJFdmVudCBCcm93c2VyIGV2ZW50LlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IENvbWJpbmVkIGNvbmRpdGlvbiByZXN1bHQuXG4gICAgICovXG4gICAgdGhpcy5kZWZhdWx0Q29uZGl0aW9uXyA9IGZ1bmN0aW9uIChtYXBCcm93c2VyRXZlbnQpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIG5vTW9kaWZpZXJLZXlzKG1hcEJyb3dzZXJFdmVudCkgJiYgdGFyZ2V0Tm90RWRpdGFibGUobWFwQnJvd3NlckV2ZW50KVxuICAgICAgKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vZXZlbnRzL2NvbmRpdGlvbi5qc1wiKS5Db25kaXRpb259XG4gICAgICovXG4gICAgdGhpcy5jb25kaXRpb25fID1cbiAgICAgIG9wdGlvbnMuY29uZGl0aW9uICE9PSB1bmRlZmluZWRcbiAgICAgICAgPyBvcHRpb25zLmNvbmRpdGlvblxuICAgICAgICA6IHRoaXMuZGVmYXVsdENvbmRpdGlvbl87XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5kdXJhdGlvbl8gPSBvcHRpb25zLmR1cmF0aW9uICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmR1cmF0aW9uIDogMTAwO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucGl4ZWxEZWx0YV8gPVxuICAgICAgb3B0aW9ucy5waXhlbERlbHRhICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnBpeGVsRGVsdGEgOiAxMjg7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlcyB0aGUge0BsaW5rIG1vZHVsZTpvbC9NYXBCcm93c2VyRXZlbnR+TWFwQnJvd3NlckV2ZW50IG1hcCBicm93c2VyIGV2ZW50fSBpZiBpdCB3YXMgYVxuICAgKiBgS2V5RXZlbnRgLCBhbmQgZGVjaWRlcyB0aGUgZGlyZWN0aW9uIHRvIHBhbiB0byAoaWYgYW4gYXJyb3cga2V5IHdhc1xuICAgKiBwcmVzc2VkKS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdH0gbWFwQnJvd3NlckV2ZW50IE1hcCBicm93c2VyIGV2ZW50LlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBgZmFsc2VgIHRvIHN0b3AgZXZlbnQgcHJvcGFnYXRpb24uXG4gICAqL1xuICBoYW5kbGVFdmVudChtYXBCcm93c2VyRXZlbnQpIHtcbiAgICBsZXQgc3RvcEV2ZW50ID0gZmFsc2U7XG4gICAgaWYgKG1hcEJyb3dzZXJFdmVudC50eXBlID09IEV2ZW50VHlwZS5LRVlET1dOKSB7XG4gICAgICBjb25zdCBrZXlFdmVudCA9IC8qKiBAdHlwZSB7S2V5Ym9hcmRFdmVudH0gKi8gKFxuICAgICAgICBtYXBCcm93c2VyRXZlbnQub3JpZ2luYWxFdmVudFxuICAgICAgKTtcbiAgICAgIGNvbnN0IGtleSA9IGtleUV2ZW50LmtleTtcbiAgICAgIGlmIChcbiAgICAgICAgdGhpcy5jb25kaXRpb25fKG1hcEJyb3dzZXJFdmVudCkgJiZcbiAgICAgICAgKGtleSA9PSBLZXkuRE9XTiB8fFxuICAgICAgICAgIGtleSA9PSBLZXkuTEVGVCB8fFxuICAgICAgICAgIGtleSA9PSBLZXkuUklHSFQgfHxcbiAgICAgICAgICBrZXkgPT0gS2V5LlVQKVxuICAgICAgKSB7XG4gICAgICAgIGNvbnN0IG1hcCA9IG1hcEJyb3dzZXJFdmVudC5tYXA7XG4gICAgICAgIGNvbnN0IHZpZXcgPSBtYXAuZ2V0VmlldygpO1xuICAgICAgICBjb25zdCBtYXBVbml0c0RlbHRhID0gdmlldy5nZXRSZXNvbHV0aW9uKCkgKiB0aGlzLnBpeGVsRGVsdGFfO1xuICAgICAgICBsZXQgZGVsdGFYID0gMCxcbiAgICAgICAgICBkZWx0YVkgPSAwO1xuICAgICAgICBpZiAoa2V5ID09IEtleS5ET1dOKSB7XG4gICAgICAgICAgZGVsdGFZID0gLW1hcFVuaXRzRGVsdGE7XG4gICAgICAgIH0gZWxzZSBpZiAoa2V5ID09IEtleS5MRUZUKSB7XG4gICAgICAgICAgZGVsdGFYID0gLW1hcFVuaXRzRGVsdGE7XG4gICAgICAgIH0gZWxzZSBpZiAoa2V5ID09IEtleS5SSUdIVCkge1xuICAgICAgICAgIGRlbHRhWCA9IG1hcFVuaXRzRGVsdGE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVsdGFZID0gbWFwVW5pdHNEZWx0YTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkZWx0YSA9IFtkZWx0YVgsIGRlbHRhWV07XG4gICAgICAgIHJvdGF0ZUNvb3JkaW5hdGUoZGVsdGEsIHZpZXcuZ2V0Um90YXRpb24oKSk7XG4gICAgICAgIHBhbih2aWV3LCBkZWx0YSwgdGhpcy5kdXJhdGlvbl8pO1xuICAgICAgICBrZXlFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBzdG9wRXZlbnQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gIXN0b3BFdmVudDtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBLZXlib2FyZFBhbjtcbiIsIi8qKlxuICogQG1vZHVsZSBvbC9pbnRlcmFjdGlvbi9LZXlib2FyZFpvb21cbiAqL1xuaW1wb3J0IEV2ZW50VHlwZSBmcm9tICcuLi9ldmVudHMvRXZlbnRUeXBlLmpzJztcbmltcG9ydCBJbnRlcmFjdGlvbiwge3pvb21CeURlbHRhfSBmcm9tICcuL0ludGVyYWN0aW9uLmpzJztcbmltcG9ydCB7cGxhdGZvcm1Nb2RpZmllcktleSwgdGFyZ2V0Tm90RWRpdGFibGV9IGZyb20gJy4uL2V2ZW50cy9jb25kaXRpb24uanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbZHVyYXRpb249MTAwXSBBbmltYXRpb24gZHVyYXRpb24gaW4gbWlsbGlzZWNvbmRzLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9ldmVudHMvY29uZGl0aW9uLmpzXCIpLkNvbmRpdGlvbn0gW2NvbmRpdGlvbl0gQSBmdW5jdGlvbiB0aGF0XG4gKiB0YWtlcyBhbiB7QGxpbmsgbW9kdWxlOm9sL01hcEJyb3dzZXJFdmVudH5NYXBCcm93c2VyRXZlbnR9IGFuZCByZXR1cm5zIGFcbiAqIGJvb2xlYW4gdG8gaW5kaWNhdGUgd2hldGhlciB0aGF0IGV2ZW50IHNob3VsZCBiZSBoYW5kbGVkLiBUaGUgZGVmYXVsdCBjb25kaXRpb24gaXNcbiAqIHRoYXQge0BsaW5rIG1vZHVsZTpvbC9ldmVudHMvY29uZGl0aW9uLnRhcmdldE5vdEVkaXRhYmxlfSBpcyBmdWxmaWxsZWQgYW5kIHRoYXRcbiAqIHRoZSBwbGF0Zm9ybSBtb2RpZmllciBrZXkgaXNuJ3QgcHJlc3NlZFxuICogKCF7QGxpbmsgbW9kdWxlOm9sL2V2ZW50cy9jb25kaXRpb24ucGxhdGZvcm1Nb2RpZmllcktleX0pLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtkZWx0YT0xXSBUaGUgem9vbSBsZXZlbCBkZWx0YSBvbiBlYWNoIGtleSBwcmVzcy5cbiAqL1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEFsbG93cyB0aGUgdXNlciB0byB6b29tIHRoZSBtYXAgdXNpbmcga2V5Ym9hcmQgKyBhbmQgLS5cbiAqIE5vdGUgdGhhdCwgYWx0aG91Z2ggdGhpcyBpbnRlcmFjdGlvbiBpcyBieSBkZWZhdWx0IGluY2x1ZGVkIGluIG1hcHMsXG4gKiB0aGUga2V5cyBjYW4gb25seSBiZSB1c2VkIHdoZW4gYnJvd3NlciBmb2N1cyBpcyBvbiB0aGUgZWxlbWVudCB0byB3aGljaFxuICogdGhlIGtleWJvYXJkIGV2ZW50cyBhcmUgYXR0YWNoZWQuIEJ5IGRlZmF1bHQsIHRoaXMgaXMgdGhlIG1hcCBkaXYsXG4gKiB0aG91Z2ggeW91IGNhbiBjaGFuZ2UgdGhpcyB3aXRoIHRoZSBga2V5Ym9hcmRFdmVudFRhcmdldGAgaW5cbiAqIHtAbGluayBtb2R1bGU6b2wvTWFwfk1hcH0uIGBkb2N1bWVudGAgbmV2ZXIgbG9zZXMgZm9jdXMgYnV0LCBmb3IgYW55IG90aGVyXG4gKiBlbGVtZW50LCBmb2N1cyB3aWxsIGhhdmUgdG8gYmUgb24sIGFuZCByZXR1cm5lZCB0bywgdGhpcyBlbGVtZW50IGlmIHRoZSBrZXlzXG4gKiBhcmUgdG8gZnVuY3Rpb24uXG4gKiBTZWUgYWxzbyB7QGxpbmsgbW9kdWxlOm9sL2ludGVyYWN0aW9uL0tleWJvYXJkUGFufktleWJvYXJkUGFufS5cbiAqIEBhcGlcbiAqL1xuY2xhc3MgS2V5Ym9hcmRab29tIGV4dGVuZHMgSW50ZXJhY3Rpb24ge1xuICAvKipcbiAgICogQHBhcmFtIHtPcHRpb25zfSBbb3B0aW9uc10gT3B0aW9ucy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgPyBvcHRpb25zIDoge307XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9ldmVudHMvY29uZGl0aW9uLmpzXCIpLkNvbmRpdGlvbn1cbiAgICAgKi9cbiAgICB0aGlzLmNvbmRpdGlvbl8gPSBvcHRpb25zLmNvbmRpdGlvblxuICAgICAgPyBvcHRpb25zLmNvbmRpdGlvblxuICAgICAgOiBmdW5jdGlvbiAobWFwQnJvd3NlckV2ZW50KSB7XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICFwbGF0Zm9ybU1vZGlmaWVyS2V5KG1hcEJyb3dzZXJFdmVudCkgJiZcbiAgICAgICAgICAgIHRhcmdldE5vdEVkaXRhYmxlKG1hcEJyb3dzZXJFdmVudClcbiAgICAgICAgICApO1xuICAgICAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuZGVsdGFfID0gb3B0aW9ucy5kZWx0YSA/IG9wdGlvbnMuZGVsdGEgOiAxO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuZHVyYXRpb25fID0gb3B0aW9ucy5kdXJhdGlvbiAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5kdXJhdGlvbiA6IDEwMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIHRoZSB7QGxpbmsgbW9kdWxlOm9sL01hcEJyb3dzZXJFdmVudH5NYXBCcm93c2VyRXZlbnQgbWFwIGJyb3dzZXIgZXZlbnR9IGlmIGl0IHdhcyBhXG4gICAqIGBLZXlFdmVudGAsIGFuZCBkZWNpZGVzIHdoZXRoZXIgdG8gem9vbSBpbiBvciBvdXQgKGRlcGVuZGluZyBvbiB3aGV0aGVyIHRoZVxuICAgKiBrZXkgcHJlc3NlZCB3YXMgJysnIG9yICctJykuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLmRlZmF1bHR9IG1hcEJyb3dzZXJFdmVudCBNYXAgYnJvd3NlciBldmVudC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gYGZhbHNlYCB0byBzdG9wIGV2ZW50IHByb3BhZ2F0aW9uLlxuICAgKi9cbiAgaGFuZGxlRXZlbnQobWFwQnJvd3NlckV2ZW50KSB7XG4gICAgbGV0IHN0b3BFdmVudCA9IGZhbHNlO1xuICAgIGlmIChcbiAgICAgIG1hcEJyb3dzZXJFdmVudC50eXBlID09IEV2ZW50VHlwZS5LRVlET1dOIHx8XG4gICAgICBtYXBCcm93c2VyRXZlbnQudHlwZSA9PSBFdmVudFR5cGUuS0VZUFJFU1NcbiAgICApIHtcbiAgICAgIGNvbnN0IGtleUV2ZW50ID0gLyoqIEB0eXBlIHtLZXlib2FyZEV2ZW50fSAqLyAoXG4gICAgICAgIG1hcEJyb3dzZXJFdmVudC5vcmlnaW5hbEV2ZW50XG4gICAgICApO1xuICAgICAgY29uc3Qga2V5ID0ga2V5RXZlbnQua2V5O1xuICAgICAgaWYgKHRoaXMuY29uZGl0aW9uXyhtYXBCcm93c2VyRXZlbnQpICYmIChrZXkgPT09ICcrJyB8fCBrZXkgPT09ICctJykpIHtcbiAgICAgICAgY29uc3QgbWFwID0gbWFwQnJvd3NlckV2ZW50Lm1hcDtcbiAgICAgICAgY29uc3QgZGVsdGEgPSBrZXkgPT09ICcrJyA/IHRoaXMuZGVsdGFfIDogLXRoaXMuZGVsdGFfO1xuICAgICAgICBjb25zdCB2aWV3ID0gbWFwLmdldFZpZXcoKTtcbiAgICAgICAgem9vbUJ5RGVsdGEodmlldywgZGVsdGEsIHVuZGVmaW5lZCwgdGhpcy5kdXJhdGlvbl8pO1xuICAgICAgICBrZXlFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBzdG9wRXZlbnQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gIXN0b3BFdmVudDtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBLZXlib2FyZFpvb207XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvaW50ZXJhY3Rpb24vTW91c2VXaGVlbFpvb21cbiAqL1xuaW1wb3J0IEV2ZW50VHlwZSBmcm9tICcuLi9ldmVudHMvRXZlbnRUeXBlLmpzJztcbmltcG9ydCBJbnRlcmFjdGlvbiwge3pvb21CeURlbHRhfSBmcm9tICcuL0ludGVyYWN0aW9uLmpzJztcbmltcG9ydCB7REVWSUNFX1BJWEVMX1JBVElPLCBGSVJFRk9YfSBmcm9tICcuLi9oYXMuanMnO1xuaW1wb3J0IHthbGwsIGFsd2F5cywgZm9jdXNXaXRoVGFiaW5kZXh9IGZyb20gJy4uL2V2ZW50cy9jb25kaXRpb24uanMnO1xuaW1wb3J0IHtjbGFtcH0gZnJvbSAnLi4vbWF0aC5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYgeyd0cmFja3BhZCcgfCAnd2hlZWwnfSBNb2RlXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL2V2ZW50cy9jb25kaXRpb24uanNcIikuQ29uZGl0aW9ufSBbY29uZGl0aW9uXSBBIGZ1bmN0aW9uIHRoYXRcbiAqIHRha2VzIGFuIHtAbGluayBtb2R1bGU6b2wvTWFwQnJvd3NlckV2ZW50fk1hcEJyb3dzZXJFdmVudH0gYW5kIHJldHVybnMgYVxuICogYm9vbGVhbiB0byBpbmRpY2F0ZSB3aGV0aGVyIHRoYXQgZXZlbnQgc2hvdWxkIGJlIGhhbmRsZWQuIERlZmF1bHQgaXNcbiAqIHtAbGluayBtb2R1bGU6b2wvZXZlbnRzL2NvbmRpdGlvbi5hbHdheXN9LlxuICogQHByb3BlcnR5IHtib29sZWFufSBbb25Gb2N1c09ubHk9ZmFsc2VdIFdoZW4gdGhlIG1hcCdzIHRhcmdldCBoYXMgYSBgdGFiaW5kZXhgIGF0dHJpYnV0ZSBzZXQsXG4gKiB0aGUgaW50ZXJhY3Rpb24gd2lsbCBvbmx5IGhhbmRsZSBldmVudHMgd2hlbiB0aGUgbWFwIGhhcyB0aGUgZm9jdXMuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW21heERlbHRhPTFdIE1heGltdW0gbW91c2Ugd2hlZWwgZGVsdGEuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2R1cmF0aW9uPTI1MF0gQW5pbWF0aW9uIGR1cmF0aW9uIGluIG1pbGxpc2Vjb25kcy5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbdGltZW91dD04MF0gTW91c2Ugd2hlZWwgdGltZW91dCBkdXJhdGlvbiBpbiBtaWxsaXNlY29uZHMuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFt1c2VBbmNob3I9dHJ1ZV0gRW5hYmxlIHpvb21pbmcgdXNpbmcgdGhlIG1vdXNlJ3NcbiAqIGxvY2F0aW9uIGFzIHRoZSBhbmNob3IuIFdoZW4gc2V0IHRvIGBmYWxzZWAsIHpvb21pbmcgaW4gYW5kIG91dCB3aWxsIHpvb20gdG9cbiAqIHRoZSBjZW50ZXIgb2YgdGhlIHNjcmVlbiBpbnN0ZWFkIG9mIHpvb21pbmcgb24gdGhlIG1vdXNlJ3MgbG9jYXRpb24uXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtjb25zdHJhaW5SZXNvbHV0aW9uPWZhbHNlXSBJZiB0cnVlLCB0aGUgbW91c2Ugd2hlZWwgem9vbVxuICogZXZlbnQgd2lsbCBhbHdheXMgYW5pbWF0ZSB0byB0aGUgY2xvc2VzdCB6b29tIGxldmVsIGFmdGVyIGFuIGludGVyYWN0aW9uO1xuICogZmFsc2UgbWVhbnMgaW50ZXJtZWRpYXJ5IHpvb20gbGV2ZWxzIGFyZSBhbGxvd2VkLlxuICovXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQWxsb3dzIHRoZSB1c2VyIHRvIHpvb20gdGhlIG1hcCBieSBzY3JvbGxpbmcgdGhlIG1vdXNlIHdoZWVsLlxuICogQGFwaVxuICovXG5jbGFzcyBNb3VzZVdoZWVsWm9vbSBleHRlbmRzIEludGVyYWN0aW9uIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7T3B0aW9uc30gW29wdGlvbnNdIE9wdGlvbnMuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgPyBvcHRpb25zIDoge307XG5cbiAgICBzdXBlcihcbiAgICAgIC8qKiBAdHlwZSB7aW1wb3J0KFwiLi9JbnRlcmFjdGlvbi5qc1wiKS5JbnRlcmFjdGlvbk9wdGlvbnN9ICovIChvcHRpb25zKVxuICAgICk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy50b3RhbERlbHRhXyA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5sYXN0RGVsdGFfID0gMDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLm1heERlbHRhXyA9IG9wdGlvbnMubWF4RGVsdGEgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMubWF4RGVsdGEgOiAxO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuZHVyYXRpb25fID0gb3B0aW9ucy5kdXJhdGlvbiAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5kdXJhdGlvbiA6IDI1MDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnRpbWVvdXRfID0gb3B0aW9ucy50aW1lb3V0ICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnRpbWVvdXQgOiA4MDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy51c2VBbmNob3JfID1cbiAgICAgIG9wdGlvbnMudXNlQW5jaG9yICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnVzZUFuY2hvciA6IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuY29uc3RyYWluUmVzb2x1dGlvbl8gPVxuICAgICAgb3B0aW9ucy5jb25zdHJhaW5SZXNvbHV0aW9uICE9PSB1bmRlZmluZWRcbiAgICAgICAgPyBvcHRpb25zLmNvbnN0cmFpblJlc29sdXRpb25cbiAgICAgICAgOiBmYWxzZTtcblxuICAgIGNvbnN0IGNvbmRpdGlvbiA9IG9wdGlvbnMuY29uZGl0aW9uID8gb3B0aW9ucy5jb25kaXRpb24gOiBhbHdheXM7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9ldmVudHMvY29uZGl0aW9uLmpzXCIpLkNvbmRpdGlvbn1cbiAgICAgKi9cbiAgICB0aGlzLmNvbmRpdGlvbl8gPSBvcHRpb25zLm9uRm9jdXNPbmx5XG4gICAgICA/IGFsbChmb2N1c1dpdGhUYWJpbmRleCwgY29uZGl0aW9uKVxuICAgICAgOiBjb25kaXRpb247XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHs/aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfVxuICAgICAqL1xuICAgIHRoaXMubGFzdEFuY2hvcl8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLnN0YXJ0VGltZV8gPSB1bmRlZmluZWQ7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtSZXR1cm5UeXBlPHR5cGVvZiBzZXRUaW1lb3V0Pn1cbiAgICAgKi9cbiAgICB0aGlzLnRpbWVvdXRJZF87XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtNb2RlfHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLm1vZGVfID0gdW5kZWZpbmVkO1xuXG4gICAgLyoqXG4gICAgICogVHJhY2twYWQgZXZlbnRzIHNlcGFyYXRlZCBieSB0aGlzIGRlbGF5IHdpbGwgYmUgY29uc2lkZXJlZCBzZXBhcmF0ZVxuICAgICAqIGludGVyYWN0aW9ucy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy50cmFja3BhZEV2ZW50R2FwXyA9IDQwMDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge1JldHVyblR5cGU8dHlwZW9mIHNldFRpbWVvdXQ+fVxuICAgICAqL1xuICAgIHRoaXMudHJhY2twYWRUaW1lb3V0SWRfO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG51bWJlciBvZiBkZWx0YSB2YWx1ZXMgcGVyIHpvb20gbGV2ZWxcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5kZWx0YVBlclpvb21fID0gMzAwO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBlbmRJbnRlcmFjdGlvbl8oKSB7XG4gICAgdGhpcy50cmFja3BhZFRpbWVvdXRJZF8gPSB1bmRlZmluZWQ7XG4gICAgY29uc3QgbWFwID0gdGhpcy5nZXRNYXAoKTtcbiAgICBpZiAoIW1hcCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB2aWV3ID0gbWFwLmdldFZpZXcoKTtcbiAgICB2aWV3LmVuZEludGVyYWN0aW9uKFxuICAgICAgdW5kZWZpbmVkLFxuICAgICAgdGhpcy5sYXN0RGVsdGFfID8gKHRoaXMubGFzdERlbHRhXyA+IDAgPyAxIDogLTEpIDogMCxcbiAgICAgIHRoaXMubGFzdEFuY2hvcl9cbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgdGhlIHtAbGluayBtb2R1bGU6b2wvTWFwQnJvd3NlckV2ZW50fk1hcEJyb3dzZXJFdmVudCBtYXAgYnJvd3NlciBldmVudH0gKGlmIGl0IHdhcyBhIG1vdXNld2hlZWwtZXZlbnQpIGFuZCBldmVudHVhbGx5XG4gICAqIHpvb21zIHRoZSBtYXAuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLmRlZmF1bHR9IG1hcEJyb3dzZXJFdmVudCBNYXAgYnJvd3NlciBldmVudC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gYGZhbHNlYCB0byBzdG9wIGV2ZW50IHByb3BhZ2F0aW9uLlxuICAgKi9cbiAgaGFuZGxlRXZlbnQobWFwQnJvd3NlckV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLmNvbmRpdGlvbl8obWFwQnJvd3NlckV2ZW50KSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNvbnN0IHR5cGUgPSBtYXBCcm93c2VyRXZlbnQudHlwZTtcbiAgICBpZiAodHlwZSAhPT0gRXZlbnRUeXBlLldIRUVMKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBjb25zdCBtYXAgPSBtYXBCcm93c2VyRXZlbnQubWFwO1xuICAgIGNvbnN0IHdoZWVsRXZlbnQgPSAvKiogQHR5cGUge1doZWVsRXZlbnR9ICovIChcbiAgICAgIG1hcEJyb3dzZXJFdmVudC5vcmlnaW5hbEV2ZW50XG4gICAgKTtcbiAgICB3aGVlbEV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICBpZiAodGhpcy51c2VBbmNob3JfKSB7XG4gICAgICB0aGlzLmxhc3RBbmNob3JfID0gbWFwQnJvd3NlckV2ZW50LmNvb3JkaW5hdGU7XG4gICAgfVxuXG4gICAgLy8gRGVsdGEgbm9ybWFsaXNhdGlvbiBpbnNwaXJlZCBieVxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXBib3gvbWFwYm94LWdsLWpzL2Jsb2IvMDAxYzdiOS9qcy91aS9oYW5kbGVyL3Njcm9sbF96b29tLmpzXG4gICAgbGV0IGRlbHRhO1xuICAgIGlmIChtYXBCcm93c2VyRXZlbnQudHlwZSA9PSBFdmVudFR5cGUuV0hFRUwpIHtcbiAgICAgIGRlbHRhID0gd2hlZWxFdmVudC5kZWx0YVk7XG4gICAgICBpZiAoRklSRUZPWCAmJiB3aGVlbEV2ZW50LmRlbHRhTW9kZSA9PT0gV2hlZWxFdmVudC5ET01fREVMVEFfUElYRUwpIHtcbiAgICAgICAgZGVsdGEgLz0gREVWSUNFX1BJWEVMX1JBVElPO1xuICAgICAgfVxuICAgICAgaWYgKHdoZWVsRXZlbnQuZGVsdGFNb2RlID09PSBXaGVlbEV2ZW50LkRPTV9ERUxUQV9MSU5FKSB7XG4gICAgICAgIGRlbHRhICo9IDQwO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChkZWx0YSA9PT0gMCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLmxhc3REZWx0YV8gPSBkZWx0YTtcblxuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG5cbiAgICBpZiAodGhpcy5zdGFydFRpbWVfID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuc3RhcnRUaW1lXyA9IG5vdztcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMubW9kZV8gfHwgbm93IC0gdGhpcy5zdGFydFRpbWVfID4gdGhpcy50cmFja3BhZEV2ZW50R2FwXykge1xuICAgICAgdGhpcy5tb2RlXyA9IE1hdGguYWJzKGRlbHRhKSA8IDQgPyAndHJhY2twYWQnIDogJ3doZWVsJztcbiAgICB9XG5cbiAgICBjb25zdCB2aWV3ID0gbWFwLmdldFZpZXcoKTtcbiAgICBpZiAoXG4gICAgICB0aGlzLm1vZGVfID09PSAndHJhY2twYWQnICYmXG4gICAgICAhKHZpZXcuZ2V0Q29uc3RyYWluUmVzb2x1dGlvbigpIHx8IHRoaXMuY29uc3RyYWluUmVzb2x1dGlvbl8pXG4gICAgKSB7XG4gICAgICBpZiAodGhpcy50cmFja3BhZFRpbWVvdXRJZF8pIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudHJhY2twYWRUaW1lb3V0SWRfKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh2aWV3LmdldEFuaW1hdGluZygpKSB7XG4gICAgICAgICAgdmlldy5jYW5jZWxBbmltYXRpb25zKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmlldy5iZWdpbkludGVyYWN0aW9uKCk7XG4gICAgICB9XG4gICAgICB0aGlzLnRyYWNrcGFkVGltZW91dElkXyA9IHNldFRpbWVvdXQoXG4gICAgICAgIHRoaXMuZW5kSW50ZXJhY3Rpb25fLmJpbmQodGhpcyksXG4gICAgICAgIHRoaXMudGltZW91dF9cbiAgICAgICk7XG4gICAgICB2aWV3LmFkanVzdFpvb20oLWRlbHRhIC8gdGhpcy5kZWx0YVBlclpvb21fLCB0aGlzLmxhc3RBbmNob3JfKTtcbiAgICAgIHRoaXMuc3RhcnRUaW1lXyA9IG5vdztcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB0aGlzLnRvdGFsRGVsdGFfICs9IGRlbHRhO1xuXG4gICAgY29uc3QgdGltZUxlZnQgPSBNYXRoLm1heCh0aGlzLnRpbWVvdXRfIC0gKG5vdyAtIHRoaXMuc3RhcnRUaW1lXyksIDApO1xuXG4gICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZW91dElkXyk7XG4gICAgdGhpcy50aW1lb3V0SWRfID0gc2V0VGltZW91dChcbiAgICAgIHRoaXMuaGFuZGxlV2hlZWxab29tXy5iaW5kKHRoaXMsIG1hcCksXG4gICAgICB0aW1lTGVmdFxuICAgICk7XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXAuanNcIikuZGVmYXVsdH0gbWFwIE1hcC5cbiAgICovXG4gIGhhbmRsZVdoZWVsWm9vbV8obWFwKSB7XG4gICAgY29uc3QgdmlldyA9IG1hcC5nZXRWaWV3KCk7XG4gICAgaWYgKHZpZXcuZ2V0QW5pbWF0aW5nKCkpIHtcbiAgICAgIHZpZXcuY2FuY2VsQW5pbWF0aW9ucygpO1xuICAgIH1cbiAgICBsZXQgZGVsdGEgPVxuICAgICAgLWNsYW1wKFxuICAgICAgICB0aGlzLnRvdGFsRGVsdGFfLFxuICAgICAgICAtdGhpcy5tYXhEZWx0YV8gKiB0aGlzLmRlbHRhUGVyWm9vbV8sXG4gICAgICAgIHRoaXMubWF4RGVsdGFfICogdGhpcy5kZWx0YVBlclpvb21fXG4gICAgICApIC8gdGhpcy5kZWx0YVBlclpvb21fO1xuICAgIGlmICh2aWV3LmdldENvbnN0cmFpblJlc29sdXRpb24oKSB8fCB0aGlzLmNvbnN0cmFpblJlc29sdXRpb25fKSB7XG4gICAgICAvLyB2aWV3IGhhcyBhIHpvb20gY29uc3RyYWludCwgem9vbSBieSAxXG4gICAgICBkZWx0YSA9IGRlbHRhID8gKGRlbHRhID4gMCA/IDEgOiAtMSkgOiAwO1xuICAgIH1cbiAgICB6b29tQnlEZWx0YSh2aWV3LCBkZWx0YSwgdGhpcy5sYXN0QW5jaG9yXywgdGhpcy5kdXJhdGlvbl8pO1xuXG4gICAgdGhpcy5tb2RlXyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnRvdGFsRGVsdGFfID0gMDtcbiAgICB0aGlzLmxhc3RBbmNob3JfID0gbnVsbDtcbiAgICB0aGlzLnN0YXJ0VGltZV8gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy50aW1lb3V0SWRfID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEVuYWJsZSBvciBkaXNhYmxlIHVzaW5nIHRoZSBtb3VzZSdzIGxvY2F0aW9uIGFzIGFuIGFuY2hvciB3aGVuIHpvb21pbmdcbiAgICogQHBhcmFtIHtib29sZWFufSB1c2VBbmNob3IgdHJ1ZSB0byB6b29tIHRvIHRoZSBtb3VzZSdzIGxvY2F0aW9uLCBmYWxzZVxuICAgKiB0byB6b29tIHRvIHRoZSBjZW50ZXIgb2YgdGhlIG1hcFxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRNb3VzZUFuY2hvcih1c2VBbmNob3IpIHtcbiAgICB0aGlzLnVzZUFuY2hvcl8gPSB1c2VBbmNob3I7XG4gICAgaWYgKCF1c2VBbmNob3IpIHtcbiAgICAgIHRoaXMubGFzdEFuY2hvcl8gPSBudWxsO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBNb3VzZVdoZWVsWm9vbTtcbiIsIi8qKlxuICogQG1vZHVsZSBvbC9pbnRlcmFjdGlvbi9QaW5jaFJvdGF0ZVxuICovXG5pbXBvcnQgUG9pbnRlckludGVyYWN0aW9uLCB7XG4gIGNlbnRyb2lkIGFzIGNlbnRyb2lkRnJvbVBvaW50ZXJzLFxufSBmcm9tICcuL1BvaW50ZXIuanMnO1xuaW1wb3J0IHtGQUxTRX0gZnJvbSAnLi4vZnVuY3Rpb25zLmpzJztcbmltcG9ydCB7ZGlzYWJsZX0gZnJvbSAnLi4vcm90YXRpb25jb25zdHJhaW50LmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2R1cmF0aW9uPTI1MF0gVGhlIGR1cmF0aW9uIG9mIHRoZSBhbmltYXRpb24gaW5cbiAqIG1pbGxpc2Vjb25kcy5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbdGhyZXNob2xkPTAuM10gTWluaW1hbCBhbmdsZSBpbiByYWRpYW5zIHRvIHN0YXJ0IGEgcm90YXRpb24uXG4gKi9cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBBbGxvd3MgdGhlIHVzZXIgdG8gcm90YXRlIHRoZSBtYXAgYnkgdHdpc3Rpbmcgd2l0aCB0d28gZmluZ2Vyc1xuICogb24gYSB0b3VjaCBzY3JlZW4uXG4gKiBAYXBpXG4gKi9cbmNsYXNzIFBpbmNoUm90YXRlIGV4dGVuZHMgUG9pbnRlckludGVyYWN0aW9uIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7T3B0aW9uc30gW29wdGlvbnNdIE9wdGlvbnMuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgPyBvcHRpb25zIDoge307XG5cbiAgICBjb25zdCBwb2ludGVyT3B0aW9ucyA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi9Qb2ludGVyLmpzXCIpLk9wdGlvbnN9ICovIChcbiAgICAgIG9wdGlvbnNcbiAgICApO1xuXG4gICAgaWYgKCFwb2ludGVyT3B0aW9ucy5zdG9wRG93bikge1xuICAgICAgcG9pbnRlck9wdGlvbnMuc3RvcERvd24gPSBGQUxTRTtcbiAgICB9XG5cbiAgICBzdXBlcihwb2ludGVyT3B0aW9ucyk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9XG4gICAgICovXG4gICAgdGhpcy5hbmNob3JfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcnx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5sYXN0QW5nbGVfID0gdW5kZWZpbmVkO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLnJvdGF0aW5nXyA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucm90YXRpb25EZWx0YV8gPSAwLjA7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy50aHJlc2hvbGRfID0gb3B0aW9ucy50aHJlc2hvbGQgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMudGhyZXNob2xkIDogMC4zO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuZHVyYXRpb25fID0gb3B0aW9ucy5kdXJhdGlvbiAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5kdXJhdGlvbiA6IDI1MDtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgcG9pbnRlciBkcmFnIGV2ZW50cy5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdH0gbWFwQnJvd3NlckV2ZW50IEV2ZW50LlxuICAgKi9cbiAgaGFuZGxlRHJhZ0V2ZW50KG1hcEJyb3dzZXJFdmVudCkge1xuICAgIGxldCByb3RhdGlvbkRlbHRhID0gMC4wO1xuXG4gICAgY29uc3QgdG91Y2gwID0gdGhpcy50YXJnZXRQb2ludGVyc1swXTtcbiAgICBjb25zdCB0b3VjaDEgPSB0aGlzLnRhcmdldFBvaW50ZXJzWzFdO1xuXG4gICAgLy8gYW5nbGUgYmV0d2VlbiB0b3VjaGVzXG4gICAgY29uc3QgYW5nbGUgPSBNYXRoLmF0YW4yKFxuICAgICAgdG91Y2gxLmNsaWVudFkgLSB0b3VjaDAuY2xpZW50WSxcbiAgICAgIHRvdWNoMS5jbGllbnRYIC0gdG91Y2gwLmNsaWVudFhcbiAgICApO1xuXG4gICAgaWYgKHRoaXMubGFzdEFuZ2xlXyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zdCBkZWx0YSA9IGFuZ2xlIC0gdGhpcy5sYXN0QW5nbGVfO1xuICAgICAgdGhpcy5yb3RhdGlvbkRlbHRhXyArPSBkZWx0YTtcbiAgICAgIGlmICghdGhpcy5yb3RhdGluZ18gJiYgTWF0aC5hYnModGhpcy5yb3RhdGlvbkRlbHRhXykgPiB0aGlzLnRocmVzaG9sZF8pIHtcbiAgICAgICAgdGhpcy5yb3RhdGluZ18gPSB0cnVlO1xuICAgICAgfVxuICAgICAgcm90YXRpb25EZWx0YSA9IGRlbHRhO1xuICAgIH1cbiAgICB0aGlzLmxhc3RBbmdsZV8gPSBhbmdsZTtcblxuICAgIGNvbnN0IG1hcCA9IG1hcEJyb3dzZXJFdmVudC5tYXA7XG4gICAgY29uc3QgdmlldyA9IG1hcC5nZXRWaWV3KCk7XG4gICAgaWYgKHZpZXcuZ2V0Q29uc3RyYWludHMoKS5yb3RhdGlvbiA9PT0gZGlzYWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIHJvdGF0ZSBhbmNob3IgcG9pbnQuXG4gICAgLy8gRklYTUU6IHNob3VsZCBiZSB0aGUgaW50ZXJzZWN0aW9uIHBvaW50IGJldHdlZW4gdGhlIGxpbmVzOlxuICAgIC8vICAgICB0b3VjaDAsdG91Y2gxIGFuZCBwcmV2aW91c1RvdWNoMCxwcmV2aW91c1RvdWNoMVxuICAgIHRoaXMuYW5jaG9yXyA9IG1hcC5nZXRDb29yZGluYXRlRnJvbVBpeGVsSW50ZXJuYWwoXG4gICAgICBtYXAuZ2V0RXZlbnRQaXhlbChjZW50cm9pZEZyb21Qb2ludGVycyh0aGlzLnRhcmdldFBvaW50ZXJzKSlcbiAgICApO1xuXG4gICAgLy8gcm90YXRlXG4gICAgaWYgKHRoaXMucm90YXRpbmdfKSB7XG4gICAgICBtYXAucmVuZGVyKCk7XG4gICAgICB2aWV3LmFkanVzdFJvdGF0aW9uSW50ZXJuYWwocm90YXRpb25EZWx0YSwgdGhpcy5hbmNob3JfKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlIHBvaW50ZXIgdXAgZXZlbnRzLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcEJyb3dzZXJFdmVudC5qc1wiKS5kZWZhdWx0fSBtYXBCcm93c2VyRXZlbnQgRXZlbnQuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IElmIHRoZSBldmVudCB3YXMgY29uc3VtZWQuXG4gICAqL1xuICBoYW5kbGVVcEV2ZW50KG1hcEJyb3dzZXJFdmVudCkge1xuICAgIGlmICh0aGlzLnRhcmdldFBvaW50ZXJzLmxlbmd0aCA8IDIpIHtcbiAgICAgIGNvbnN0IG1hcCA9IG1hcEJyb3dzZXJFdmVudC5tYXA7XG4gICAgICBjb25zdCB2aWV3ID0gbWFwLmdldFZpZXcoKTtcbiAgICAgIHZpZXcuZW5kSW50ZXJhY3Rpb24odGhpcy5kdXJhdGlvbl8pO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgcG9pbnRlciBkb3duIGV2ZW50cy5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdH0gbWFwQnJvd3NlckV2ZW50IEV2ZW50LlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBJZiB0aGUgZXZlbnQgd2FzIGNvbnN1bWVkLlxuICAgKi9cbiAgaGFuZGxlRG93bkV2ZW50KG1hcEJyb3dzZXJFdmVudCkge1xuICAgIGlmICh0aGlzLnRhcmdldFBvaW50ZXJzLmxlbmd0aCA+PSAyKSB7XG4gICAgICBjb25zdCBtYXAgPSBtYXBCcm93c2VyRXZlbnQubWFwO1xuICAgICAgdGhpcy5hbmNob3JfID0gbnVsbDtcbiAgICAgIHRoaXMubGFzdEFuZ2xlXyA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMucm90YXRpbmdfID0gZmFsc2U7XG4gICAgICB0aGlzLnJvdGF0aW9uRGVsdGFfID0gMC4wO1xuICAgICAgaWYgKCF0aGlzLmhhbmRsaW5nRG93blVwU2VxdWVuY2UpIHtcbiAgICAgICAgbWFwLmdldFZpZXcoKS5iZWdpbkludGVyYWN0aW9uKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFBpbmNoUm90YXRlO1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2ludGVyYWN0aW9uL1BpbmNoWm9vbVxuICovXG5pbXBvcnQgUG9pbnRlckludGVyYWN0aW9uLCB7XG4gIGNlbnRyb2lkIGFzIGNlbnRyb2lkRnJvbVBvaW50ZXJzLFxufSBmcm9tICcuL1BvaW50ZXIuanMnO1xuaW1wb3J0IHtGQUxTRX0gZnJvbSAnLi4vZnVuY3Rpb25zLmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2R1cmF0aW9uPTQwMF0gQW5pbWF0aW9uIGR1cmF0aW9uIGluIG1pbGxpc2Vjb25kcy5cbiAqL1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEFsbG93cyB0aGUgdXNlciB0byB6b29tIHRoZSBtYXAgYnkgcGluY2hpbmcgd2l0aCB0d28gZmluZ2Vyc1xuICogb24gYSB0b3VjaCBzY3JlZW4uXG4gKiBAYXBpXG4gKi9cbmNsYXNzIFBpbmNoWm9vbSBleHRlbmRzIFBvaW50ZXJJbnRlcmFjdGlvbiB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge09wdGlvbnN9IFtvcHRpb25zXSBPcHRpb25zLlxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zID8gb3B0aW9ucyA6IHt9O1xuXG4gICAgY29uc3QgcG9pbnRlck9wdGlvbnMgPSAvKiogQHR5cGUge2ltcG9ydChcIi4vUG9pbnRlci5qc1wiKS5PcHRpb25zfSAqLyAoXG4gICAgICBvcHRpb25zXG4gICAgKTtcblxuICAgIGlmICghcG9pbnRlck9wdGlvbnMuc3RvcERvd24pIHtcbiAgICAgIHBvaW50ZXJPcHRpb25zLnN0b3BEb3duID0gRkFMU0U7XG4gICAgfVxuXG4gICAgc3VwZXIocG9pbnRlck9wdGlvbnMpO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfVxuICAgICAqL1xuICAgIHRoaXMuYW5jaG9yXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5kdXJhdGlvbl8gPSBvcHRpb25zLmR1cmF0aW9uICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmR1cmF0aW9uIDogNDAwO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLmxhc3REaXN0YW5jZV8gPSB1bmRlZmluZWQ7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5sYXN0U2NhbGVEZWx0YV8gPSAxO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBwb2ludGVyIGRyYWcgZXZlbnRzLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcEJyb3dzZXJFdmVudC5qc1wiKS5kZWZhdWx0fSBtYXBCcm93c2VyRXZlbnQgRXZlbnQuXG4gICAqL1xuICBoYW5kbGVEcmFnRXZlbnQobWFwQnJvd3NlckV2ZW50KSB7XG4gICAgbGV0IHNjYWxlRGVsdGEgPSAxLjA7XG5cbiAgICBjb25zdCB0b3VjaDAgPSB0aGlzLnRhcmdldFBvaW50ZXJzWzBdO1xuICAgIGNvbnN0IHRvdWNoMSA9IHRoaXMudGFyZ2V0UG9pbnRlcnNbMV07XG4gICAgY29uc3QgZHggPSB0b3VjaDAuY2xpZW50WCAtIHRvdWNoMS5jbGllbnRYO1xuICAgIGNvbnN0IGR5ID0gdG91Y2gwLmNsaWVudFkgLSB0b3VjaDEuY2xpZW50WTtcblxuICAgIC8vIGRpc3RhbmNlIGJldHdlZW4gdG91Y2hlc1xuICAgIGNvbnN0IGRpc3RhbmNlID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcblxuICAgIGlmICh0aGlzLmxhc3REaXN0YW5jZV8gIT09IHVuZGVmaW5lZCkge1xuICAgICAgc2NhbGVEZWx0YSA9IHRoaXMubGFzdERpc3RhbmNlXyAvIGRpc3RhbmNlO1xuICAgIH1cbiAgICB0aGlzLmxhc3REaXN0YW5jZV8gPSBkaXN0YW5jZTtcblxuICAgIGNvbnN0IG1hcCA9IG1hcEJyb3dzZXJFdmVudC5tYXA7XG4gICAgY29uc3QgdmlldyA9IG1hcC5nZXRWaWV3KCk7XG5cbiAgICBpZiAoc2NhbGVEZWx0YSAhPSAxLjApIHtcbiAgICAgIHRoaXMubGFzdFNjYWxlRGVsdGFfID0gc2NhbGVEZWx0YTtcbiAgICB9XG5cbiAgICAvLyBzY2FsZSBhbmNob3IgcG9pbnQuXG4gICAgdGhpcy5hbmNob3JfID0gbWFwLmdldENvb3JkaW5hdGVGcm9tUGl4ZWxJbnRlcm5hbChcbiAgICAgIG1hcC5nZXRFdmVudFBpeGVsKGNlbnRyb2lkRnJvbVBvaW50ZXJzKHRoaXMudGFyZ2V0UG9pbnRlcnMpKVxuICAgICk7XG5cbiAgICAvLyBzY2FsZSwgYnlwYXNzIHRoZSByZXNvbHV0aW9uIGNvbnN0cmFpbnRcbiAgICBtYXAucmVuZGVyKCk7XG4gICAgdmlldy5hZGp1c3RSZXNvbHV0aW9uSW50ZXJuYWwoc2NhbGVEZWx0YSwgdGhpcy5hbmNob3JfKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgcG9pbnRlciB1cCBldmVudHMuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLmRlZmF1bHR9IG1hcEJyb3dzZXJFdmVudCBFdmVudC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gSWYgdGhlIGV2ZW50IHdhcyBjb25zdW1lZC5cbiAgICovXG4gIGhhbmRsZVVwRXZlbnQobWFwQnJvd3NlckV2ZW50KSB7XG4gICAgaWYgKHRoaXMudGFyZ2V0UG9pbnRlcnMubGVuZ3RoIDwgMikge1xuICAgICAgY29uc3QgbWFwID0gbWFwQnJvd3NlckV2ZW50Lm1hcDtcbiAgICAgIGNvbnN0IHZpZXcgPSBtYXAuZ2V0VmlldygpO1xuICAgICAgY29uc3QgZGlyZWN0aW9uID0gdGhpcy5sYXN0U2NhbGVEZWx0YV8gPiAxID8gMSA6IC0xO1xuICAgICAgdmlldy5lbmRJbnRlcmFjdGlvbih0aGlzLmR1cmF0aW9uXywgZGlyZWN0aW9uKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlIHBvaW50ZXIgZG93biBldmVudHMuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLmRlZmF1bHR9IG1hcEJyb3dzZXJFdmVudCBFdmVudC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gSWYgdGhlIGV2ZW50IHdhcyBjb25zdW1lZC5cbiAgICovXG4gIGhhbmRsZURvd25FdmVudChtYXBCcm93c2VyRXZlbnQpIHtcbiAgICBpZiAodGhpcy50YXJnZXRQb2ludGVycy5sZW5ndGggPj0gMikge1xuICAgICAgY29uc3QgbWFwID0gbWFwQnJvd3NlckV2ZW50Lm1hcDtcbiAgICAgIHRoaXMuYW5jaG9yXyA9IG51bGw7XG4gICAgICB0aGlzLmxhc3REaXN0YW5jZV8gPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmxhc3RTY2FsZURlbHRhXyA9IDE7XG4gICAgICBpZiAoIXRoaXMuaGFuZGxpbmdEb3duVXBTZXF1ZW5jZSkge1xuICAgICAgICBtYXAuZ2V0VmlldygpLmJlZ2luSW50ZXJhY3Rpb24oKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgUGluY2hab29tO1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2ludGVyYWN0aW9uL1BvaW50ZXJcbiAqL1xuaW1wb3J0IEludGVyYWN0aW9uIGZyb20gJy4vSW50ZXJhY3Rpb24uanMnO1xuaW1wb3J0IE1hcEJyb3dzZXJFdmVudFR5cGUgZnJvbSAnLi4vTWFwQnJvd3NlckV2ZW50VHlwZS5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHtmdW5jdGlvbihpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdCk6Ym9vbGVhbn0gW2hhbmRsZURvd25FdmVudF1cbiAqIEZ1bmN0aW9uIGhhbmRsaW5nIFwiZG93blwiIGV2ZW50cy4gSWYgdGhlIGZ1bmN0aW9uIHJldHVybnMgYHRydWVgIHRoZW4gYSBkcmFnXG4gKiBzZXF1ZW5jZSBpcyBzdGFydGVkLlxuICogQHByb3BlcnR5IHtmdW5jdGlvbihpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdCk6dm9pZH0gW2hhbmRsZURyYWdFdmVudF1cbiAqIEZ1bmN0aW9uIGhhbmRsaW5nIFwiZHJhZ1wiIGV2ZW50cy4gVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgb24gXCJtb3ZlXCIgZXZlbnRzXG4gKiBkdXJpbmcgYSBkcmFnIHNlcXVlbmNlLlxuICogQHByb3BlcnR5IHtmdW5jdGlvbihpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdCk6Ym9vbGVhbn0gW2hhbmRsZUV2ZW50XVxuICogTWV0aG9kIGNhbGxlZCBieSB0aGUgbWFwIHRvIG5vdGlmeSB0aGUgaW50ZXJhY3Rpb24gdGhhdCBhIGJyb3dzZXIgZXZlbnQgd2FzXG4gKiBkaXNwYXRjaGVkIHRvIHRoZSBtYXAuIFRoZSBmdW5jdGlvbiBtYXkgcmV0dXJuIGBmYWxzZWAgdG8gcHJldmVudCB0aGVcbiAqIHByb3BhZ2F0aW9uIG9mIHRoZSBldmVudCB0byBvdGhlciBpbnRlcmFjdGlvbnMgaW4gdGhlIG1hcCdzIGludGVyYWN0aW9uc1xuICogY2hhaW4uXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9uKGltcG9ydChcIi4uL01hcEJyb3dzZXJFdmVudC5qc1wiKS5kZWZhdWx0KTp2b2lkfSBbaGFuZGxlTW92ZUV2ZW50XVxuICogRnVuY3Rpb24gaGFuZGxpbmcgXCJtb3ZlXCIgZXZlbnRzLiBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbiBcIm1vdmVcIiBldmVudHMuXG4gKiBUaGlzIGZ1bmN0aW9ucyBpcyBhbHNvIGNhbGxlZCBkdXJpbmcgYSBkcmFnIHNlcXVlbmNlLCBzbyBkdXJpbmcgYSBkcmFnXG4gKiBzZXF1ZW5jZSBib3RoIHRoZSBgaGFuZGxlRHJhZ0V2ZW50YCBmdW5jdGlvbiBhbmQgdGhpcyBmdW5jdGlvbiBhcmUgY2FsbGVkLlxuICogSWYgYGhhbmRsZURvd25FdmVudGAgaXMgZGVmaW5lZCBhbmQgaXQgcmV0dXJucyB0cnVlIHRoaXMgZnVuY3Rpb24gd2lsbCBub3RcbiAqIGJlIGNhbGxlZCBkdXJpbmcgYSBkcmFnIHNlcXVlbmNlLlxuICogQHByb3BlcnR5IHtmdW5jdGlvbihpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdCk6Ym9vbGVhbn0gW2hhbmRsZVVwRXZlbnRdXG4gKiAgRnVuY3Rpb24gaGFuZGxpbmcgXCJ1cFwiIGV2ZW50cy4gSWYgdGhlIGZ1bmN0aW9uIHJldHVybnMgYGZhbHNlYCB0aGVuIHRoZVxuICogY3VycmVudCBkcmFnIHNlcXVlbmNlIGlzIHN0b3BwZWQuXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9uKGJvb2xlYW4pOmJvb2xlYW59IFtzdG9wRG93bl1cbiAqIFNob3VsZCB0aGUgZG93biBldmVudCBiZSBwcm9wYWdhdGVkIHRvIG90aGVyIGludGVyYWN0aW9ucywgb3Igc2hvdWxkIGJlXG4gKiBzdG9wcGVkP1xuICovXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQmFzZSBjbGFzcyB0aGF0IGNhbGxzIHVzZXItZGVmaW5lZCBmdW5jdGlvbnMgb24gYGRvd25gLCBgbW92ZWAgYW5kIGB1cGBcbiAqIGV2ZW50cy4gVGhpcyBjbGFzcyBhbHNvIG1hbmFnZXMgXCJkcmFnIHNlcXVlbmNlc1wiLlxuICpcbiAqIFdoZW4gdGhlIGBoYW5kbGVEb3duRXZlbnRgIHVzZXIgZnVuY3Rpb24gcmV0dXJucyBgdHJ1ZWAgYSBkcmFnIHNlcXVlbmNlIGlzXG4gKiBzdGFydGVkLiBEdXJpbmcgYSBkcmFnIHNlcXVlbmNlIHRoZSBgaGFuZGxlRHJhZ0V2ZW50YCB1c2VyIGZ1bmN0aW9uIGlzXG4gKiBjYWxsZWQgb24gYG1vdmVgIGV2ZW50cy4gVGhlIGRyYWcgc2VxdWVuY2UgZW5kcyB3aGVuIHRoZSBgaGFuZGxlVXBFdmVudGBcbiAqIHVzZXIgZnVuY3Rpb24gaXMgY2FsbGVkIGFuZCByZXR1cm5zIGBmYWxzZWAuXG4gKiBAYXBpXG4gKi9cbmNsYXNzIFBvaW50ZXJJbnRlcmFjdGlvbiBleHRlbmRzIEludGVyYWN0aW9uIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7T3B0aW9uc30gW29wdGlvbnNdIE9wdGlvbnMuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgPyBvcHRpb25zIDoge307XG5cbiAgICBzdXBlcihcbiAgICAgIC8qKiBAdHlwZSB7aW1wb3J0KFwiLi9JbnRlcmFjdGlvbi5qc1wiKS5JbnRlcmFjdGlvbk9wdGlvbnN9ICovIChvcHRpb25zKVxuICAgICk7XG5cbiAgICBpZiAob3B0aW9ucy5oYW5kbGVEb3duRXZlbnQpIHtcbiAgICAgIHRoaXMuaGFuZGxlRG93bkV2ZW50ID0gb3B0aW9ucy5oYW5kbGVEb3duRXZlbnQ7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuaGFuZGxlRHJhZ0V2ZW50KSB7XG4gICAgICB0aGlzLmhhbmRsZURyYWdFdmVudCA9IG9wdGlvbnMuaGFuZGxlRHJhZ0V2ZW50O1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmhhbmRsZU1vdmVFdmVudCkge1xuICAgICAgdGhpcy5oYW5kbGVNb3ZlRXZlbnQgPSBvcHRpb25zLmhhbmRsZU1vdmVFdmVudDtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5oYW5kbGVVcEV2ZW50KSB7XG4gICAgICB0aGlzLmhhbmRsZVVwRXZlbnQgPSBvcHRpb25zLmhhbmRsZVVwRXZlbnQ7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuc3RvcERvd24pIHtcbiAgICAgIHRoaXMuc3RvcERvd24gPSBvcHRpb25zLnN0b3BEb3duO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICB0aGlzLmhhbmRsaW5nRG93blVwU2VxdWVuY2UgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtBcnJheTxQb2ludGVyRXZlbnQ+fVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICB0aGlzLnRhcmdldFBvaW50ZXJzID0gW107XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCBudW1iZXIgb2YgcG9pbnRlcnMgaW52b2x2ZWQgaW4gdGhlIGludGVyYWN0aW9uLFxuICAgKiBlLmcuIGAyYCB3aGVuIHR3byBmaW5nZXJzIGFyZSB1c2VkLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgcG9pbnRlcnMuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldFBvaW50ZXJDb3VudCgpIHtcbiAgICByZXR1cm4gdGhpcy50YXJnZXRQb2ludGVycy5sZW5ndGg7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlIHBvaW50ZXIgZG93biBldmVudHMuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLmRlZmF1bHR9IG1hcEJyb3dzZXJFdmVudCBFdmVudC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gSWYgdGhlIGV2ZW50IHdhcyBjb25zdW1lZC5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgaGFuZGxlRG93bkV2ZW50KG1hcEJyb3dzZXJFdmVudCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgcG9pbnRlciBkcmFnIGV2ZW50cy5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdH0gbWFwQnJvd3NlckV2ZW50IEV2ZW50LlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBoYW5kbGVEcmFnRXZlbnQobWFwQnJvd3NlckV2ZW50KSB7fVxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIHRoZSB7QGxpbmsgbW9kdWxlOm9sL01hcEJyb3dzZXJFdmVudH5NYXBCcm93c2VyRXZlbnQgbWFwIGJyb3dzZXIgZXZlbnR9IGFuZCBtYXkgY2FsbCBpbnRvXG4gICAqIG90aGVyIGZ1bmN0aW9ucywgaWYgZXZlbnQgc2VxdWVuY2VzIGxpa2UgZS5nLiAnZHJhZycgb3IgJ2Rvd24tdXAnIGV0Yy4gYXJlXG4gICAqIGRldGVjdGVkLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcEJyb3dzZXJFdmVudC5qc1wiKS5kZWZhdWx0fSBtYXBCcm93c2VyRXZlbnQgTWFwIGJyb3dzZXIgZXZlbnQuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IGBmYWxzZWAgdG8gc3RvcCBldmVudCBwcm9wYWdhdGlvbi5cbiAgICogQGFwaVxuICAgKi9cbiAgaGFuZGxlRXZlbnQobWFwQnJvd3NlckV2ZW50KSB7XG4gICAgaWYgKCFtYXBCcm93c2VyRXZlbnQub3JpZ2luYWxFdmVudCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgbGV0IHN0b3BFdmVudCA9IGZhbHNlO1xuICAgIHRoaXMudXBkYXRlVHJhY2tlZFBvaW50ZXJzXyhtYXBCcm93c2VyRXZlbnQpO1xuICAgIGlmICh0aGlzLmhhbmRsaW5nRG93blVwU2VxdWVuY2UpIHtcbiAgICAgIGlmIChtYXBCcm93c2VyRXZlbnQudHlwZSA9PSBNYXBCcm93c2VyRXZlbnRUeXBlLlBPSU5URVJEUkFHKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlRHJhZ0V2ZW50KG1hcEJyb3dzZXJFdmVudCk7XG4gICAgICAgIC8vIHByZXZlbnQgcGFnZSBzY3JvbGxpbmcgZHVyaW5nIGRyYWdnaW5nXG4gICAgICAgIG1hcEJyb3dzZXJFdmVudC5vcmlnaW5hbEV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9IGVsc2UgaWYgKG1hcEJyb3dzZXJFdmVudC50eXBlID09IE1hcEJyb3dzZXJFdmVudFR5cGUuUE9JTlRFUlVQKSB7XG4gICAgICAgIGNvbnN0IGhhbmRsZWRVcCA9IHRoaXMuaGFuZGxlVXBFdmVudChtYXBCcm93c2VyRXZlbnQpO1xuICAgICAgICB0aGlzLmhhbmRsaW5nRG93blVwU2VxdWVuY2UgPVxuICAgICAgICAgIGhhbmRsZWRVcCAmJiB0aGlzLnRhcmdldFBvaW50ZXJzLmxlbmd0aCA+IDA7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChtYXBCcm93c2VyRXZlbnQudHlwZSA9PSBNYXBCcm93c2VyRXZlbnRUeXBlLlBPSU5URVJET1dOKSB7XG4gICAgICAgIGNvbnN0IGhhbmRsZWQgPSB0aGlzLmhhbmRsZURvd25FdmVudChtYXBCcm93c2VyRXZlbnQpO1xuICAgICAgICB0aGlzLmhhbmRsaW5nRG93blVwU2VxdWVuY2UgPSBoYW5kbGVkO1xuICAgICAgICBzdG9wRXZlbnQgPSB0aGlzLnN0b3BEb3duKGhhbmRsZWQpO1xuICAgICAgfSBlbHNlIGlmIChtYXBCcm93c2VyRXZlbnQudHlwZSA9PSBNYXBCcm93c2VyRXZlbnRUeXBlLlBPSU5URVJNT1ZFKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlTW92ZUV2ZW50KG1hcEJyb3dzZXJFdmVudCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAhc3RvcEV2ZW50O1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBwb2ludGVyIG1vdmUgZXZlbnRzLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcEJyb3dzZXJFdmVudC5qc1wiKS5kZWZhdWx0fSBtYXBCcm93c2VyRXZlbnQgRXZlbnQuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIGhhbmRsZU1vdmVFdmVudChtYXBCcm93c2VyRXZlbnQpIHt9XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBwb2ludGVyIHVwIGV2ZW50cy5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdH0gbWFwQnJvd3NlckV2ZW50IEV2ZW50LlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBJZiB0aGUgZXZlbnQgd2FzIGNvbnN1bWVkLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBoYW5kbGVVcEV2ZW50KG1hcEJyb3dzZXJFdmVudCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgdG8gZGV0ZXJtaW5lIGlmIFwiZG93blwiIGV2ZW50cyBzaG91bGQgYmUgcHJvcGFnYXRlZFxuICAgKiB0byBvdGhlciBpbnRlcmFjdGlvbnMgb3Igc2hvdWxkIGJlIHN0b3BwZWQuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaGFuZGxlZCBXYXMgdGhlIGV2ZW50IGhhbmRsZWQgYnkgdGhlIGludGVyYWN0aW9uP1xuICAgKiBAcmV0dXJuIHtib29sZWFufSBTaG91bGQgdGhlIGBkb3duYCBldmVudCBiZSBzdG9wcGVkP1xuICAgKi9cbiAgc3RvcERvd24oaGFuZGxlZCkge1xuICAgIHJldHVybiBoYW5kbGVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLmRlZmF1bHR9IG1hcEJyb3dzZXJFdmVudCBFdmVudC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHVwZGF0ZVRyYWNrZWRQb2ludGVyc18obWFwQnJvd3NlckV2ZW50KSB7XG4gICAgaWYgKG1hcEJyb3dzZXJFdmVudC5hY3RpdmVQb2ludGVycykge1xuICAgICAgdGhpcy50YXJnZXRQb2ludGVycyA9IG1hcEJyb3dzZXJFdmVudC5hY3RpdmVQb2ludGVycztcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PFBvaW50ZXJFdmVudD59IHBvaW50ZXJFdmVudHMgTGlzdCBvZiBldmVudHMuXG4gKiBAcmV0dXJuIHt7Y2xpZW50WDogbnVtYmVyLCBjbGllbnRZOiBudW1iZXJ9fSBDZW50cm9pZCBwaXhlbC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNlbnRyb2lkKHBvaW50ZXJFdmVudHMpIHtcbiAgY29uc3QgbGVuZ3RoID0gcG9pbnRlckV2ZW50cy5sZW5ndGg7XG4gIGxldCBjbGllbnRYID0gMDtcbiAgbGV0IGNsaWVudFkgPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgY2xpZW50WCArPSBwb2ludGVyRXZlbnRzW2ldLmNsaWVudFg7XG4gICAgY2xpZW50WSArPSBwb2ludGVyRXZlbnRzW2ldLmNsaWVudFk7XG4gIH1cbiAgcmV0dXJuIHtjbGllbnRYOiBjbGllbnRYIC8gbGVuZ3RoLCBjbGllbnRZOiBjbGllbnRZIC8gbGVuZ3RofTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgUG9pbnRlckludGVyYWN0aW9uO1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2ludGVyYWN0aW9uL1Byb3BlcnR5XG4gKi9cblxuLyoqXG4gKiBAZW51bSB7c3RyaW5nfVxuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gIEFDVElWRTogJ2FjdGl2ZScsXG59O1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2ludGVyYWN0aW9uL2RlZmF1bHRzXG4gKi9cbmltcG9ydCBDb2xsZWN0aW9uIGZyb20gJy4uL0NvbGxlY3Rpb24uanMnO1xuaW1wb3J0IERvdWJsZUNsaWNrWm9vbSBmcm9tICcuL0RvdWJsZUNsaWNrWm9vbS5qcyc7XG5pbXBvcnQgRHJhZ1BhbiBmcm9tICcuL0RyYWdQYW4uanMnO1xuaW1wb3J0IERyYWdSb3RhdGUgZnJvbSAnLi9EcmFnUm90YXRlLmpzJztcbmltcG9ydCBEcmFnWm9vbSBmcm9tICcuL0RyYWdab29tLmpzJztcbmltcG9ydCBLZXlib2FyZFBhbiBmcm9tICcuL0tleWJvYXJkUGFuLmpzJztcbmltcG9ydCBLZXlib2FyZFpvb20gZnJvbSAnLi9LZXlib2FyZFpvb20uanMnO1xuaW1wb3J0IEtpbmV0aWMgZnJvbSAnLi4vS2luZXRpYy5qcyc7XG5pbXBvcnQgTW91c2VXaGVlbFpvb20gZnJvbSAnLi9Nb3VzZVdoZWVsWm9vbS5qcyc7XG5pbXBvcnQgUGluY2hSb3RhdGUgZnJvbSAnLi9QaW5jaFJvdGF0ZS5qcyc7XG5pbXBvcnQgUGluY2hab29tIGZyb20gJy4vUGluY2hab29tLmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBEZWZhdWx0c09wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2FsdFNoaWZ0RHJhZ1JvdGF0ZT10cnVlXSBXaGV0aGVyIEFsdC1TaGlmdC1kcmFnIHJvdGF0ZSBpc1xuICogZGVzaXJlZC5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW29uRm9jdXNPbmx5PWZhbHNlXSBJbnRlcmFjdCBvbmx5IHdoZW4gdGhlIG1hcCBoYXMgdGhlXG4gKiBmb2N1cy4gVGhpcyBhZmZlY3RzIHRoZSBgTW91c2VXaGVlbFpvb21gIGFuZCBgRHJhZ1BhbmAgaW50ZXJhY3Rpb25zIGFuZCBpc1xuICogdXNlZnVsIHdoZW4gcGFnZSBzY3JvbGwgaXMgZGVzaXJlZCBmb3IgbWFwcyB0aGF0IGRvIG5vdCBoYXZlIHRoZSBicm93c2VyJ3NcbiAqIGZvY3VzLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbZG91YmxlQ2xpY2tab29tPXRydWVdIFdoZXRoZXIgZG91YmxlIGNsaWNrIHpvb20gaXNcbiAqIGRlc2lyZWQuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtrZXlib2FyZD10cnVlXSBXaGV0aGVyIGtleWJvYXJkIGludGVyYWN0aW9uIGlzIGRlc2lyZWQuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFttb3VzZVdoZWVsWm9vbT10cnVlXSBXaGV0aGVyIG1vdXNld2hlZWwgem9vbSBpcyBkZXNpcmVkLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbc2hpZnREcmFnWm9vbT10cnVlXSBXaGV0aGVyIFNoaWZ0LWRyYWcgem9vbSBpcyBkZXNpcmVkLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbZHJhZ1Bhbj10cnVlXSBXaGV0aGVyIGRyYWcgcGFuIGlzIGRlc2lyZWQuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtwaW5jaFJvdGF0ZT10cnVlXSBXaGV0aGVyIHBpbmNoIHJvdGF0ZSBpcyBkZXNpcmVkLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbcGluY2hab29tPXRydWVdIFdoZXRoZXIgcGluY2ggem9vbSBpcyBkZXNpcmVkLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFt6b29tRGVsdGFdIFpvb20gbGV2ZWwgZGVsdGEgd2hlbiB1c2luZyBrZXlib2FyZCBvciBkb3VibGUgY2xpY2sgem9vbS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbem9vbUR1cmF0aW9uXSBEdXJhdGlvbiBvZiB0aGUgem9vbSBhbmltYXRpb24gaW5cbiAqIG1pbGxpc2Vjb25kcy5cbiAqL1xuXG4vKipcbiAqIFNldCBvZiBpbnRlcmFjdGlvbnMgaW5jbHVkZWQgaW4gbWFwcyBieSBkZWZhdWx0LiBTcGVjaWZpYyBpbnRlcmFjdGlvbnMgY2FuIGJlXG4gKiBleGNsdWRlZCBieSBzZXR0aW5nIHRoZSBhcHByb3ByaWF0ZSBvcHRpb24gdG8gZmFsc2UgaW4gdGhlIGNvbnN0cnVjdG9yXG4gKiBvcHRpb25zLCBidXQgdGhlIG9yZGVyIG9mIHRoZSBpbnRlcmFjdGlvbnMgaXMgZml4ZWQuICBJZiB5b3Ugd2FudCB0byBzcGVjaWZ5XG4gKiBhIGRpZmZlcmVudCBvcmRlciBmb3IgaW50ZXJhY3Rpb25zLCB5b3Ugd2lsbCBuZWVkIHRvIGNyZWF0ZSB5b3VyIG93blxuICoge0BsaW5rIG1vZHVsZTpvbC9pbnRlcmFjdGlvbi9JbnRlcmFjdGlvbn5JbnRlcmFjdGlvbn0gaW5zdGFuY2VzIGFuZCBpbnNlcnRcbiAqIHRoZW0gaW50byBhIHtAbGluayBtb2R1bGU6b2wvQ29sbGVjdGlvbn5Db2xsZWN0aW9ufSBpbiB0aGUgb3JkZXIgeW91IHdhbnRcbiAqIGJlZm9yZSBjcmVhdGluZyB5b3VyIHtAbGluayBtb2R1bGU6b2wvTWFwfk1hcH0gaW5zdGFuY2UuIENoYW5naW5nIHRoZSBvcmRlciBjYW5cbiAqIGJlIG9mIGludGVyZXN0IGlmIHRoZSBldmVudCBwcm9wYWdhdGlvbiBuZWVkcyB0byBiZSBzdG9wcGVkIGF0IGEgcG9pbnQuXG4gKiBUaGUgZGVmYXVsdCBzZXQgb2YgaW50ZXJhY3Rpb25zLCBpbiBzZXF1ZW5jZSwgaXM6XG4gKiAqIHtAbGluayBtb2R1bGU6b2wvaW50ZXJhY3Rpb24vRHJhZ1JvdGF0ZX5EcmFnUm90YXRlfVxuICogKiB7QGxpbmsgbW9kdWxlOm9sL2ludGVyYWN0aW9uL0RvdWJsZUNsaWNrWm9vbX5Eb3VibGVDbGlja1pvb219XG4gKiAqIHtAbGluayBtb2R1bGU6b2wvaW50ZXJhY3Rpb24vRHJhZ1Bhbn5EcmFnUGFufVxuICogKiB7QGxpbmsgbW9kdWxlOm9sL2ludGVyYWN0aW9uL1BpbmNoUm90YXRlflBpbmNoUm90YXRlfVxuICogKiB7QGxpbmsgbW9kdWxlOm9sL2ludGVyYWN0aW9uL1BpbmNoWm9vbX5QaW5jaFpvb219XG4gKiAqIHtAbGluayBtb2R1bGU6b2wvaW50ZXJhY3Rpb24vS2V5Ym9hcmRQYW5+S2V5Ym9hcmRQYW59XG4gKiAqIHtAbGluayBtb2R1bGU6b2wvaW50ZXJhY3Rpb24vS2V5Ym9hcmRab29tfktleWJvYXJkWm9vbX1cbiAqICoge0BsaW5rIG1vZHVsZTpvbC9pbnRlcmFjdGlvbi9Nb3VzZVdoZWVsWm9vbX5Nb3VzZVdoZWVsWm9vbX1cbiAqICoge0BsaW5rIG1vZHVsZTpvbC9pbnRlcmFjdGlvbi9EcmFnWm9vbX5EcmFnWm9vbX1cbiAqXG4gKiBAcGFyYW0ge0RlZmF1bHRzT3B0aW9uc30gW29wdGlvbnNdIERlZmF1bHRzIG9wdGlvbnMuXG4gKiBAcmV0dXJuIHtDb2xsZWN0aW9uPGltcG9ydChcIi4vSW50ZXJhY3Rpb24uanNcIikuZGVmYXVsdD59XG4gKiBBIGNvbGxlY3Rpb24gb2YgaW50ZXJhY3Rpb25zIHRvIGJlIHVzZWQgd2l0aCB0aGUge0BsaW5rIG1vZHVsZTpvbC9NYXB+TWFwfVxuICogY29uc3RydWN0b3IncyBgaW50ZXJhY3Rpb25zYCBvcHRpb24uXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0cyhvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zID8gb3B0aW9ucyA6IHt9O1xuXG4gIC8qKiBAdHlwZSB7Q29sbGVjdGlvbjxpbXBvcnQoXCIuL0ludGVyYWN0aW9uLmpzXCIpLmRlZmF1bHQ+fSAqL1xuICBjb25zdCBpbnRlcmFjdGlvbnMgPSBuZXcgQ29sbGVjdGlvbigpO1xuXG4gIGNvbnN0IGtpbmV0aWMgPSBuZXcgS2luZXRpYygtMC4wMDUsIDAuMDUsIDEwMCk7XG5cbiAgY29uc3QgYWx0U2hpZnREcmFnUm90YXRlID1cbiAgICBvcHRpb25zLmFsdFNoaWZ0RHJhZ1JvdGF0ZSAhPT0gdW5kZWZpbmVkXG4gICAgICA/IG9wdGlvbnMuYWx0U2hpZnREcmFnUm90YXRlXG4gICAgICA6IHRydWU7XG4gIGlmIChhbHRTaGlmdERyYWdSb3RhdGUpIHtcbiAgICBpbnRlcmFjdGlvbnMucHVzaChuZXcgRHJhZ1JvdGF0ZSgpKTtcbiAgfVxuXG4gIGNvbnN0IGRvdWJsZUNsaWNrWm9vbSA9XG4gICAgb3B0aW9ucy5kb3VibGVDbGlja1pvb20gIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZG91YmxlQ2xpY2tab29tIDogdHJ1ZTtcbiAgaWYgKGRvdWJsZUNsaWNrWm9vbSkge1xuICAgIGludGVyYWN0aW9ucy5wdXNoKFxuICAgICAgbmV3IERvdWJsZUNsaWNrWm9vbSh7XG4gICAgICAgIGRlbHRhOiBvcHRpb25zLnpvb21EZWx0YSxcbiAgICAgICAgZHVyYXRpb246IG9wdGlvbnMuem9vbUR1cmF0aW9uLFxuICAgICAgfSlcbiAgICApO1xuICB9XG5cbiAgY29uc3QgZHJhZ1BhbiA9IG9wdGlvbnMuZHJhZ1BhbiAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5kcmFnUGFuIDogdHJ1ZTtcbiAgaWYgKGRyYWdQYW4pIHtcbiAgICBpbnRlcmFjdGlvbnMucHVzaChcbiAgICAgIG5ldyBEcmFnUGFuKHtcbiAgICAgICAgb25Gb2N1c09ubHk6IG9wdGlvbnMub25Gb2N1c09ubHksXG4gICAgICAgIGtpbmV0aWM6IGtpbmV0aWMsXG4gICAgICB9KVxuICAgICk7XG4gIH1cblxuICBjb25zdCBwaW5jaFJvdGF0ZSA9XG4gICAgb3B0aW9ucy5waW5jaFJvdGF0ZSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5waW5jaFJvdGF0ZSA6IHRydWU7XG4gIGlmIChwaW5jaFJvdGF0ZSkge1xuICAgIGludGVyYWN0aW9ucy5wdXNoKG5ldyBQaW5jaFJvdGF0ZSgpKTtcbiAgfVxuXG4gIGNvbnN0IHBpbmNoWm9vbSA9IG9wdGlvbnMucGluY2hab29tICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnBpbmNoWm9vbSA6IHRydWU7XG4gIGlmIChwaW5jaFpvb20pIHtcbiAgICBpbnRlcmFjdGlvbnMucHVzaChcbiAgICAgIG5ldyBQaW5jaFpvb20oe1xuICAgICAgICBkdXJhdGlvbjogb3B0aW9ucy56b29tRHVyYXRpb24sXG4gICAgICB9KVxuICAgICk7XG4gIH1cblxuICBjb25zdCBrZXlib2FyZCA9IG9wdGlvbnMua2V5Ym9hcmQgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMua2V5Ym9hcmQgOiB0cnVlO1xuICBpZiAoa2V5Ym9hcmQpIHtcbiAgICBpbnRlcmFjdGlvbnMucHVzaChuZXcgS2V5Ym9hcmRQYW4oKSk7XG4gICAgaW50ZXJhY3Rpb25zLnB1c2goXG4gICAgICBuZXcgS2V5Ym9hcmRab29tKHtcbiAgICAgICAgZGVsdGE6IG9wdGlvbnMuem9vbURlbHRhLFxuICAgICAgICBkdXJhdGlvbjogb3B0aW9ucy56b29tRHVyYXRpb24sXG4gICAgICB9KVxuICAgICk7XG4gIH1cblxuICBjb25zdCBtb3VzZVdoZWVsWm9vbSA9XG4gICAgb3B0aW9ucy5tb3VzZVdoZWVsWm9vbSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5tb3VzZVdoZWVsWm9vbSA6IHRydWU7XG4gIGlmIChtb3VzZVdoZWVsWm9vbSkge1xuICAgIGludGVyYWN0aW9ucy5wdXNoKFxuICAgICAgbmV3IE1vdXNlV2hlZWxab29tKHtcbiAgICAgICAgb25Gb2N1c09ubHk6IG9wdGlvbnMub25Gb2N1c09ubHksXG4gICAgICAgIGR1cmF0aW9uOiBvcHRpb25zLnpvb21EdXJhdGlvbixcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuXG4gIGNvbnN0IHNoaWZ0RHJhZ1pvb20gPVxuICAgIG9wdGlvbnMuc2hpZnREcmFnWm9vbSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5zaGlmdERyYWdab29tIDogdHJ1ZTtcbiAgaWYgKHNoaWZ0RHJhZ1pvb20pIHtcbiAgICBpbnRlcmFjdGlvbnMucHVzaChcbiAgICAgIG5ldyBEcmFnWm9vbSh7XG4gICAgICAgIGR1cmF0aW9uOiBvcHRpb25zLnpvb21EdXJhdGlvbixcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiBpbnRlcmFjdGlvbnM7XG59XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvbGF5ZXIvQmFzZVxuICovXG5pbXBvcnQgQmFzZU9iamVjdCBmcm9tICcuLi9PYmplY3QuanMnO1xuaW1wb3J0IExheWVyUHJvcGVydHkgZnJvbSAnLi9Qcm9wZXJ0eS5qcyc7XG5pbXBvcnQge2Fic3RyYWN0fSBmcm9tICcuLi91dGlsLmpzJztcbmltcG9ydCB7YXNzZXJ0fSBmcm9tICcuLi9hc3NlcnRzLmpzJztcbmltcG9ydCB7Y2xhbXB9IGZyb20gJy4uL21hdGguanMnO1xuXG4vKipcbiAqIEEgY3NzIGNvbG9yLCBvciBhIGZ1bmN0aW9uIGNhbGxlZCB3aXRoIGEgdmlldyByZXNvbHV0aW9uIHJldHVybmluZyBhIGNzcyBjb2xvci5cbiAqXG4gKiBAdHlwZWRlZiB7c3RyaW5nfGZ1bmN0aW9uKG51bWJlcik6c3RyaW5nfSBCYWNrZ3JvdW5kQ29sb3JcbiAqIEBhcGlcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoXCIuLi9PYmplY3RFdmVudFR5cGVcIikuVHlwZXN8J2NoYW5nZTpleHRlbnQnfCdjaGFuZ2U6bWF4UmVzb2x1dGlvbid8J2NoYW5nZTptYXhab29tJ3xcbiAqICAgICdjaGFuZ2U6bWluUmVzb2x1dGlvbid8J2NoYW5nZTptaW5ab29tJ3wnY2hhbmdlOm9wYWNpdHknfCdjaGFuZ2U6dmlzaWJsZSd8J2NoYW5nZTp6SW5kZXgnfSBCYXNlTGF5ZXJPYmplY3RFdmVudFR5cGVzXG4gKi9cblxuLyoqKlxuICogQHRlbXBsYXRlIFJldHVyblxuICogQHR5cGVkZWYge2ltcG9ydChcIi4uL09ic2VydmFibGVcIikuT25TaWduYXR1cmU8aW1wb3J0KFwiLi4vT2JzZXJ2YWJsZVwiKS5FdmVudFR5cGVzLCBpbXBvcnQoXCIuLi9ldmVudHMvRXZlbnQuanNcIikuZGVmYXVsdCwgUmV0dXJuPiAmXG4gKiAgIGltcG9ydChcIi4uL09ic2VydmFibGVcIikuT25TaWduYXR1cmU8QmFzZUxheWVyT2JqZWN0RXZlbnRUeXBlcywgaW1wb3J0KFwiLi4vT2JqZWN0XCIpLk9iamVjdEV2ZW50LCBSZXR1cm4+ICZcbiAqICAgaW1wb3J0KFwiLi4vT2JzZXJ2YWJsZVwiKS5Db21iaW5lZE9uU2lnbmF0dXJlPGltcG9ydChcIi4uL09ic2VydmFibGVcIikuRXZlbnRUeXBlc3xCYXNlTGF5ZXJPYmplY3RFdmVudFR5cGVzLCBSZXR1cm4+fSBCYXNlTGF5ZXJPblNpZ25hdHVyZVxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHtzdHJpbmd9IFtjbGFzc05hbWU9J29sLWxheWVyJ10gQSBDU1MgY2xhc3MgbmFtZSB0byBzZXQgdG8gdGhlIGxheWVyIGVsZW1lbnQuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW29wYWNpdHk9MV0gT3BhY2l0eSAoMCwgMSkuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFt2aXNpYmxlPXRydWVdIFZpc2liaWxpdHkuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IFtleHRlbnRdIFRoZSBib3VuZGluZyBleHRlbnQgZm9yIGxheWVyIHJlbmRlcmluZy4gIFRoZSBsYXllciB3aWxsIG5vdCBiZVxuICogcmVuZGVyZWQgb3V0c2lkZSBvZiB0aGlzIGV4dGVudC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyIHwgdW5kZWZpbmVkfSBbekluZGV4XSBUaGUgei1pbmRleCBmb3IgbGF5ZXIgcmVuZGVyaW5nLiAgQXQgcmVuZGVyaW5nIHRpbWUsIHRoZSBsYXllcnNcbiAqIHdpbGwgYmUgb3JkZXJlZCwgZmlyc3QgYnkgWi1pbmRleCBhbmQgdGhlbiBieSBwb3NpdGlvbi4gV2hlbiBgdW5kZWZpbmVkYCwgYSBgekluZGV4YCBvZiAwIGlzIGFzc3VtZWRcbiAqIGZvciBsYXllcnMgdGhhdCBhcmUgYWRkZWQgdG8gdGhlIG1hcCdzIGBsYXllcnNgIGNvbGxlY3Rpb24sIG9yIGBJbmZpbml0eWAgd2hlbiB0aGUgbGF5ZXIncyBgc2V0TWFwKClgXG4gKiBtZXRob2Qgd2FzIHVzZWQuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW21pblJlc29sdXRpb25dIFRoZSBtaW5pbXVtIHJlc29sdXRpb24gKGluY2x1c2l2ZSkgYXQgd2hpY2ggdGhpcyBsYXllciB3aWxsIGJlXG4gKiB2aXNpYmxlLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFttYXhSZXNvbHV0aW9uXSBUaGUgbWF4aW11bSByZXNvbHV0aW9uIChleGNsdXNpdmUpIGJlbG93IHdoaWNoIHRoaXMgbGF5ZXIgd2lsbFxuICogYmUgdmlzaWJsZS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbWluWm9vbV0gVGhlIG1pbmltdW0gdmlldyB6b29tIGxldmVsIChleGNsdXNpdmUpIGFib3ZlIHdoaWNoIHRoaXMgbGF5ZXIgd2lsbCBiZVxuICogdmlzaWJsZS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbWF4Wm9vbV0gVGhlIG1heGltdW0gdmlldyB6b29tIGxldmVsIChpbmNsdXNpdmUpIGF0IHdoaWNoIHRoaXMgbGF5ZXIgd2lsbFxuICogYmUgdmlzaWJsZS5cbiAqIEBwcm9wZXJ0eSB7QmFja2dyb3VuZENvbG9yfSBbYmFja2dyb3VuZF0gQmFja2dyb3VuZCBjb2xvciBmb3IgdGhlIGxheWVyLiBJZiBub3Qgc3BlY2lmaWVkLCBubyBiYWNrZ3JvdW5kXG4gKiB3aWxsIGJlIHJlbmRlcmVkLlxuICogQHByb3BlcnR5IHtPYmplY3Q8c3RyaW5nLCAqPn0gW3Byb3BlcnRpZXNdIEFyYml0cmFyeSBvYnNlcnZhYmxlIHByb3BlcnRpZXMuIENhbiBiZSBhY2Nlc3NlZCB3aXRoIGAjZ2V0KClgIGFuZCBgI3NldCgpYC5cbiAqL1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEFic3RyYWN0IGJhc2UgY2xhc3M7IG5vcm1hbGx5IG9ubHkgdXNlZCBmb3IgY3JlYXRpbmcgc3ViY2xhc3NlcyBhbmQgbm90XG4gKiBpbnN0YW50aWF0ZWQgaW4gYXBwcy5cbiAqIE5vdGUgdGhhdCB3aXRoIHtAbGluayBtb2R1bGU6b2wvbGF5ZXIvQmFzZX5CYXNlTGF5ZXJ9IGFuZCBhbGwgaXRzIHN1YmNsYXNzZXMsIGFueSBwcm9wZXJ0eSBzZXQgaW5cbiAqIHRoZSBvcHRpb25zIGlzIHNldCBhcyBhIHtAbGluayBtb2R1bGU6b2wvT2JqZWN0fkJhc2VPYmplY3R9IHByb3BlcnR5IG9uIHRoZSBsYXllciBvYmplY3QsIHNvXG4gKiBpcyBvYnNlcnZhYmxlLCBhbmQgaGFzIGdldC9zZXQgYWNjZXNzb3JzLlxuICpcbiAqIEBhcGlcbiAqL1xuY2xhc3MgQmFzZUxheWVyIGV4dGVuZHMgQmFzZU9iamVjdCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge09wdGlvbnN9IG9wdGlvbnMgTGF5ZXIgb3B0aW9ucy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgLyoqKlxuICAgICAqIEB0eXBlIHtCYXNlTGF5ZXJPblNpZ25hdHVyZTxpbXBvcnQoXCIuLi9ldmVudHNcIikuRXZlbnRzS2V5Pn1cbiAgICAgKi9cbiAgICB0aGlzLm9uO1xuXG4gICAgLyoqKlxuICAgICAqIEB0eXBlIHtCYXNlTGF5ZXJPblNpZ25hdHVyZTxpbXBvcnQoXCIuLi9ldmVudHNcIikuRXZlbnRzS2V5Pn1cbiAgICAgKi9cbiAgICB0aGlzLm9uY2U7XG5cbiAgICAvKioqXG4gICAgICogQHR5cGUge0Jhc2VMYXllck9uU2lnbmF0dXJlPHZvaWQ+fVxuICAgICAqL1xuICAgIHRoaXMudW47XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QmFja2dyb3VuZENvbG9yfGZhbHNlfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5iYWNrZ3JvdW5kXyA9IG9wdGlvbnMuYmFja2dyb3VuZDtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCAqPn1cbiAgICAgKi9cbiAgICBjb25zdCBwcm9wZXJ0aWVzID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyk7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnByb3BlcnRpZXMgPT09ICdvYmplY3QnKSB7XG4gICAgICBkZWxldGUgcHJvcGVydGllcy5wcm9wZXJ0aWVzO1xuICAgICAgT2JqZWN0LmFzc2lnbihwcm9wZXJ0aWVzLCBvcHRpb25zLnByb3BlcnRpZXMpO1xuICAgIH1cblxuICAgIHByb3BlcnRpZXNbTGF5ZXJQcm9wZXJ0eS5PUEFDSVRZXSA9XG4gICAgICBvcHRpb25zLm9wYWNpdHkgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMub3BhY2l0eSA6IDE7XG4gICAgYXNzZXJ0KFxuICAgICAgdHlwZW9mIHByb3BlcnRpZXNbTGF5ZXJQcm9wZXJ0eS5PUEFDSVRZXSA9PT0gJ251bWJlcicsXG4gICAgICAnTGF5ZXIgb3BhY2l0eSBtdXN0IGJlIGEgbnVtYmVyJ1xuICAgICk7XG5cbiAgICBwcm9wZXJ0aWVzW0xheWVyUHJvcGVydHkuVklTSUJMRV0gPVxuICAgICAgb3B0aW9ucy52aXNpYmxlICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnZpc2libGUgOiB0cnVlO1xuICAgIHByb3BlcnRpZXNbTGF5ZXJQcm9wZXJ0eS5aX0lOREVYXSA9IG9wdGlvbnMuekluZGV4O1xuICAgIHByb3BlcnRpZXNbTGF5ZXJQcm9wZXJ0eS5NQVhfUkVTT0xVVElPTl0gPVxuICAgICAgb3B0aW9ucy5tYXhSZXNvbHV0aW9uICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm1heFJlc29sdXRpb24gOiBJbmZpbml0eTtcbiAgICBwcm9wZXJ0aWVzW0xheWVyUHJvcGVydHkuTUlOX1JFU09MVVRJT05dID1cbiAgICAgIG9wdGlvbnMubWluUmVzb2x1dGlvbiAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5taW5SZXNvbHV0aW9uIDogMDtcbiAgICBwcm9wZXJ0aWVzW0xheWVyUHJvcGVydHkuTUlOX1pPT01dID1cbiAgICAgIG9wdGlvbnMubWluWm9vbSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5taW5ab29tIDogLUluZmluaXR5O1xuICAgIHByb3BlcnRpZXNbTGF5ZXJQcm9wZXJ0eS5NQVhfWk9PTV0gPVxuICAgICAgb3B0aW9ucy5tYXhab29tICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm1heFpvb20gOiBJbmZpbml0eTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmNsYXNzTmFtZV8gPVxuICAgICAgcHJvcGVydGllcy5jbGFzc05hbWUgIT09IHVuZGVmaW5lZCA/IHByb3BlcnRpZXMuY2xhc3NOYW1lIDogJ29sLWxheWVyJztcbiAgICBkZWxldGUgcHJvcGVydGllcy5jbGFzc05hbWU7XG5cbiAgICB0aGlzLnNldFByb3BlcnRpZXMocHJvcGVydGllcyk7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi9MYXllci5qc1wiKS5TdGF0ZX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuc3RhdGVfID0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGJhY2tncm91bmQgZm9yIHRoaXMgbGF5ZXIuXG4gICAqIEByZXR1cm4ge0JhY2tncm91bmRDb2xvcnxmYWxzZX0gTGF5ZXIgYmFja2dyb3VuZC5cbiAgICovXG4gIGdldEJhY2tncm91bmQoKSB7XG4gICAgcmV0dXJuIHRoaXMuYmFja2dyb3VuZF87XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7c3RyaW5nfSBDU1MgY2xhc3MgbmFtZS5cbiAgICovXG4gIGdldENsYXNzTmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5jbGFzc05hbWVfO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIGlzIG5vdCBtZWFudCB0byBiZSBjYWxsZWQgYnkgbGF5ZXJzIG9yIGxheWVyIHJlbmRlcmVycyBiZWNhdXNlIHRoZSBzdGF0ZVxuICAgKiBpcyBpbmNvcnJlY3QgaWYgdGhlIGxheWVyIGlzIGluY2x1ZGVkIGluIGEgbGF5ZXIgZ3JvdXAuXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW21hbmFnZWRdIExheWVyIGlzIG1hbmFnZWQuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4vTGF5ZXIuanNcIikuU3RhdGV9IExheWVyIHN0YXRlLlxuICAgKi9cbiAgZ2V0TGF5ZXJTdGF0ZShtYW5hZ2VkKSB7XG4gICAgLyoqIEB0eXBlIHtpbXBvcnQoXCIuL0xheWVyLmpzXCIpLlN0YXRlfSAqL1xuICAgIGNvbnN0IHN0YXRlID1cbiAgICAgIHRoaXMuc3RhdGVfIHx8XG4gICAgICAvKiogQHR5cGUgez99ICovICh7XG4gICAgICAgIGxheWVyOiB0aGlzLFxuICAgICAgICBtYW5hZ2VkOiBtYW5hZ2VkID09PSB1bmRlZmluZWQgPyB0cnVlIDogbWFuYWdlZCxcbiAgICAgIH0pO1xuICAgIGNvbnN0IHpJbmRleCA9IHRoaXMuZ2V0WkluZGV4KCk7XG4gICAgc3RhdGUub3BhY2l0eSA9IGNsYW1wKE1hdGgucm91bmQodGhpcy5nZXRPcGFjaXR5KCkgKiAxMDApIC8gMTAwLCAwLCAxKTtcbiAgICBzdGF0ZS52aXNpYmxlID0gdGhpcy5nZXRWaXNpYmxlKCk7XG4gICAgc3RhdGUuZXh0ZW50ID0gdGhpcy5nZXRFeHRlbnQoKTtcbiAgICBzdGF0ZS56SW5kZXggPSB6SW5kZXggPT09IHVuZGVmaW5lZCAmJiAhc3RhdGUubWFuYWdlZCA/IEluZmluaXR5IDogekluZGV4O1xuICAgIHN0YXRlLm1heFJlc29sdXRpb24gPSB0aGlzLmdldE1heFJlc29sdXRpb24oKTtcbiAgICBzdGF0ZS5taW5SZXNvbHV0aW9uID0gTWF0aC5tYXgodGhpcy5nZXRNaW5SZXNvbHV0aW9uKCksIDApO1xuICAgIHN0YXRlLm1pblpvb20gPSB0aGlzLmdldE1pblpvb20oKTtcbiAgICBzdGF0ZS5tYXhab29tID0gdGhpcy5nZXRNYXhab29tKCk7XG4gICAgdGhpcy5zdGF0ZV8gPSBzdGF0ZTtcblxuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHBhcmFtIHtBcnJheTxpbXBvcnQoXCIuL0xheWVyLmpzXCIpLmRlZmF1bHQ+fSBbYXJyYXldIEFycmF5IG9mIGxheWVycyAodG8gYmVcbiAgICogICAgIG1vZGlmaWVkIGluIHBsYWNlKS5cbiAgICogQHJldHVybiB7QXJyYXk8aW1wb3J0KFwiLi9MYXllci5qc1wiKS5kZWZhdWx0Pn0gQXJyYXkgb2YgbGF5ZXJzLlxuICAgKi9cbiAgZ2V0TGF5ZXJzQXJyYXkoYXJyYXkpIHtcbiAgICByZXR1cm4gYWJzdHJhY3QoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHBhcmFtIHtBcnJheTxpbXBvcnQoXCIuL0xheWVyLmpzXCIpLlN0YXRlPn0gW3N0YXRlc10gT3B0aW9uYWwgbGlzdCBvZiBsYXllclxuICAgKiAgICAgc3RhdGVzICh0byBiZSBtb2RpZmllZCBpbiBwbGFjZSkuXG4gICAqIEByZXR1cm4ge0FycmF5PGltcG9ydChcIi4vTGF5ZXIuanNcIikuU3RhdGU+fSBMaXN0IG9mIGxheWVyIHN0YXRlcy5cbiAgICovXG4gIGdldExheWVyU3RhdGVzQXJyYXkoc3RhdGVzKSB7XG4gICAgcmV0dXJuIGFic3RyYWN0KCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSB7QGxpbmsgbW9kdWxlOm9sL2V4dGVudH5FeHRlbnQgZXh0ZW50fSBvZiB0aGUgbGF5ZXIgb3IgYHVuZGVmaW5lZGAgaWYgaXRcbiAgICogd2lsbCBiZSB2aXNpYmxlIHJlZ2FyZGxlc3Mgb2YgZXh0ZW50LlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fHVuZGVmaW5lZH0gVGhlIGxheWVyIGV4dGVudC5cbiAgICogQG9ic2VydmFibGVcbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0RXh0ZW50KCkge1xuICAgIHJldHVybiAvKiogQHR5cGUge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR8dW5kZWZpbmVkfSAqLyAoXG4gICAgICB0aGlzLmdldChMYXllclByb3BlcnR5LkVYVEVOVClcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgbWF4aW11bSByZXNvbHV0aW9uIG9mIHRoZSBsYXllci4gUmV0dXJucyBJbmZpbml0eSBpZlxuICAgKiB0aGUgbGF5ZXIgaGFzIG5vIG1heGltdW0gcmVzb2x1dGlvbiBzZXQuXG4gICAqIEByZXR1cm4ge251bWJlcn0gVGhlIG1heGltdW0gcmVzb2x1dGlvbiBvZiB0aGUgbGF5ZXIuXG4gICAqIEBvYnNlcnZhYmxlXG4gICAqIEBhcGlcbiAgICovXG4gIGdldE1heFJlc29sdXRpb24oKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAodGhpcy5nZXQoTGF5ZXJQcm9wZXJ0eS5NQVhfUkVTT0xVVElPTikpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgbWluaW11bSByZXNvbHV0aW9uIG9mIHRoZSBsYXllci4gUmV0dXJucyAwIGlmXG4gICAqIHRoZSBsYXllciBoYXMgbm8gbWluaW11bSByZXNvbHV0aW9uIHNldC5cbiAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgbWluaW11bSByZXNvbHV0aW9uIG9mIHRoZSBsYXllci5cbiAgICogQG9ic2VydmFibGVcbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0TWluUmVzb2x1dGlvbigpIHtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHtudW1iZXJ9ICovICh0aGlzLmdldChMYXllclByb3BlcnR5Lk1JTl9SRVNPTFVUSU9OKSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBtaW5pbXVtIHpvb20gbGV2ZWwgb2YgdGhlIGxheWVyLiBSZXR1cm5zIC1JbmZpbml0eSBpZlxuICAgKiB0aGUgbGF5ZXIgaGFzIG5vIG1pbmltdW0gem9vbSBzZXQuXG4gICAqIEByZXR1cm4ge251bWJlcn0gVGhlIG1pbmltdW0gem9vbSBsZXZlbCBvZiB0aGUgbGF5ZXIuXG4gICAqIEBvYnNlcnZhYmxlXG4gICAqIEBhcGlcbiAgICovXG4gIGdldE1pblpvb20oKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAodGhpcy5nZXQoTGF5ZXJQcm9wZXJ0eS5NSU5fWk9PTSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgbWF4aW11bSB6b29tIGxldmVsIG9mIHRoZSBsYXllci4gUmV0dXJucyBJbmZpbml0eSBpZlxuICAgKiB0aGUgbGF5ZXIgaGFzIG5vIG1heGltdW0gem9vbSBzZXQuXG4gICAqIEByZXR1cm4ge251bWJlcn0gVGhlIG1heGltdW0gem9vbSBsZXZlbCBvZiB0aGUgbGF5ZXIuXG4gICAqIEBvYnNlcnZhYmxlXG4gICAqIEBhcGlcbiAgICovXG4gIGdldE1heFpvb20oKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAodGhpcy5nZXQoTGF5ZXJQcm9wZXJ0eS5NQVhfWk9PTSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgb3BhY2l0eSBvZiB0aGUgbGF5ZXIgKGJldHdlZW4gMCBhbmQgMSkuXG4gICAqIEByZXR1cm4ge251bWJlcn0gVGhlIG9wYWNpdHkgb2YgdGhlIGxheWVyLlxuICAgKiBAb2JzZXJ2YWJsZVxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRPcGFjaXR5KCkge1xuICAgIHJldHVybiAvKiogQHR5cGUge251bWJlcn0gKi8gKHRoaXMuZ2V0KExheWVyUHJvcGVydHkuT1BBQ0lUWSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9zb3VyY2UvU291cmNlLmpzXCIpLlN0YXRlfSBTb3VyY2Ugc3RhdGUuXG4gICAqL1xuICBnZXRTb3VyY2VTdGF0ZSgpIHtcbiAgICByZXR1cm4gYWJzdHJhY3QoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIHZhbHVlIG9mIHRoaXMgbGF5ZXIncyBgdmlzaWJsZWAgcHJvcGVydHkuIFRvIGZpbmQgb3V0IHdoZXRoZXIgdGhlIGxheWVyXG4gICAqIGlzIHZpc2libGUgb24gYSBtYXAsIHVzZSBgaXNWaXNpYmxlKClgIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSB2YWx1ZSBvZiB0aGUgYHZpc2libGVgIHByb3BlcnR5IG9mIHRoZSBsYXllci5cbiAgICogQG9ic2VydmFibGVcbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0VmlzaWJsZSgpIHtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHtib29sZWFufSAqLyAodGhpcy5nZXQoTGF5ZXJQcm9wZXJ0eS5WSVNJQkxFKSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBaLWluZGV4IG9mIHRoZSBsYXllciwgd2hpY2ggaXMgdXNlZCB0byBvcmRlciBsYXllcnMgYmVmb3JlXG4gICAqIHJlbmRlcmluZy4gUmV0dXJucyB1bmRlZmluZWQgaWYgdGhlIGxheWVyIGlzIHVubWFuYWdlZC5cbiAgICogQHJldHVybiB7bnVtYmVyfHVuZGVmaW5lZH0gVGhlIFotaW5kZXggb2YgdGhlIGxheWVyLlxuICAgKiBAb2JzZXJ2YWJsZVxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRaSW5kZXgoKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7bnVtYmVyfHVuZGVmaW5lZH0gKi8gKHRoaXMuZ2V0KExheWVyUHJvcGVydHkuWl9JTkRFWCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGJhY2tncm91bmQgY29sb3IuXG4gICAqIEBwYXJhbSB7QmFja2dyb3VuZENvbG9yfSBbYmFja2dyb3VuZF0gQmFja2dyb3VuZCBjb2xvci5cbiAgICovXG4gIHNldEJhY2tncm91bmQoYmFja2dyb3VuZCkge1xuICAgIHRoaXMuYmFja2dyb3VuZF8gPSBiYWNrZ3JvdW5kO1xuICAgIHRoaXMuY2hhbmdlZCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgZXh0ZW50IGF0IHdoaWNoIHRoZSBsYXllciBpcyB2aXNpYmxlLiAgSWYgYHVuZGVmaW5lZGAsIHRoZSBsYXllclxuICAgKiB3aWxsIGJlIHZpc2libGUgYXQgYWxsIGV4dGVudHMuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudHx1bmRlZmluZWR9IGV4dGVudCBUaGUgZXh0ZW50IG9mIHRoZSBsYXllci5cbiAgICogQG9ic2VydmFibGVcbiAgICogQGFwaVxuICAgKi9cbiAgc2V0RXh0ZW50KGV4dGVudCkge1xuICAgIHRoaXMuc2V0KExheWVyUHJvcGVydHkuRVhURU5ULCBleHRlbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgbWF4aW11bSByZXNvbHV0aW9uIGF0IHdoaWNoIHRoZSBsYXllciBpcyB2aXNpYmxlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gbWF4UmVzb2x1dGlvbiBUaGUgbWF4aW11bSByZXNvbHV0aW9uIG9mIHRoZSBsYXllci5cbiAgICogQG9ic2VydmFibGVcbiAgICogQGFwaVxuICAgKi9cbiAgc2V0TWF4UmVzb2x1dGlvbihtYXhSZXNvbHV0aW9uKSB7XG4gICAgdGhpcy5zZXQoTGF5ZXJQcm9wZXJ0eS5NQVhfUkVTT0xVVElPTiwgbWF4UmVzb2x1dGlvbik7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBtaW5pbXVtIHJlc29sdXRpb24gYXQgd2hpY2ggdGhlIGxheWVyIGlzIHZpc2libGUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtaW5SZXNvbHV0aW9uIFRoZSBtaW5pbXVtIHJlc29sdXRpb24gb2YgdGhlIGxheWVyLlxuICAgKiBAb2JzZXJ2YWJsZVxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRNaW5SZXNvbHV0aW9uKG1pblJlc29sdXRpb24pIHtcbiAgICB0aGlzLnNldChMYXllclByb3BlcnR5Lk1JTl9SRVNPTFVUSU9OLCBtaW5SZXNvbHV0aW9uKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIG1heGltdW0gem9vbSAoZXhjbHVzaXZlKSBhdCB3aGljaCB0aGUgbGF5ZXIgaXMgdmlzaWJsZS5cbiAgICogTm90ZSB0aGF0IHRoZSB6b29tIGxldmVscyBmb3IgbGF5ZXIgdmlzaWJpbGl0eSBhcmUgYmFzZWQgb24gdGhlXG4gICAqIHZpZXcgem9vbSBsZXZlbCwgd2hpY2ggbWF5IGJlIGRpZmZlcmVudCBmcm9tIGEgdGlsZSBzb3VyY2Ugem9vbSBsZXZlbC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG1heFpvb20gVGhlIG1heGltdW0gem9vbSBvZiB0aGUgbGF5ZXIuXG4gICAqIEBvYnNlcnZhYmxlXG4gICAqIEBhcGlcbiAgICovXG4gIHNldE1heFpvb20obWF4Wm9vbSkge1xuICAgIHRoaXMuc2V0KExheWVyUHJvcGVydHkuTUFYX1pPT00sIG1heFpvb20pO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgbWluaW11bSB6b29tIChpbmNsdXNpdmUpIGF0IHdoaWNoIHRoZSBsYXllciBpcyB2aXNpYmxlLlxuICAgKiBOb3RlIHRoYXQgdGhlIHpvb20gbGV2ZWxzIGZvciBsYXllciB2aXNpYmlsaXR5IGFyZSBiYXNlZCBvbiB0aGVcbiAgICogdmlldyB6b29tIGxldmVsLCB3aGljaCBtYXkgYmUgZGlmZmVyZW50IGZyb20gYSB0aWxlIHNvdXJjZSB6b29tIGxldmVsLlxuICAgKiBAcGFyYW0ge251bWJlcn0gbWluWm9vbSBUaGUgbWluaW11bSB6b29tIG9mIHRoZSBsYXllci5cbiAgICogQG9ic2VydmFibGVcbiAgICogQGFwaVxuICAgKi9cbiAgc2V0TWluWm9vbShtaW5ab29tKSB7XG4gICAgdGhpcy5zZXQoTGF5ZXJQcm9wZXJ0eS5NSU5fWk9PTSwgbWluWm9vbSk7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBvcGFjaXR5IG9mIHRoZSBsYXllciwgYWxsb3dlZCB2YWx1ZXMgcmFuZ2UgZnJvbSAwIHRvIDEuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvcGFjaXR5IFRoZSBvcGFjaXR5IG9mIHRoZSBsYXllci5cbiAgICogQG9ic2VydmFibGVcbiAgICogQGFwaVxuICAgKi9cbiAgc2V0T3BhY2l0eShvcGFjaXR5KSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBvcGFjaXR5ID09PSAnbnVtYmVyJywgJ0xheWVyIG9wYWNpdHkgbXVzdCBiZSBhIG51bWJlcicpO1xuICAgIHRoaXMuc2V0KExheWVyUHJvcGVydHkuT1BBQ0lUWSwgb3BhY2l0eSk7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSB2aXNpYmlsaXR5IG9mIHRoZSBsYXllciAoYHRydWVgIG9yIGBmYWxzZWApLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHZpc2libGUgVGhlIHZpc2liaWxpdHkgb2YgdGhlIGxheWVyLlxuICAgKiBAb2JzZXJ2YWJsZVxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRWaXNpYmxlKHZpc2libGUpIHtcbiAgICB0aGlzLnNldChMYXllclByb3BlcnR5LlZJU0lCTEUsIHZpc2libGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCBaLWluZGV4IG9mIHRoZSBsYXllciwgd2hpY2ggaXMgdXNlZCB0byBvcmRlciBsYXllcnMgYmVmb3JlIHJlbmRlcmluZy5cbiAgICogVGhlIGRlZmF1bHQgWi1pbmRleCBpcyAwLlxuICAgKiBAcGFyYW0ge251bWJlcn0gemluZGV4IFRoZSB6LWluZGV4IG9mIHRoZSBsYXllci5cbiAgICogQG9ic2VydmFibGVcbiAgICogQGFwaVxuICAgKi9cbiAgc2V0WkluZGV4KHppbmRleCkge1xuICAgIHRoaXMuc2V0KExheWVyUHJvcGVydHkuWl9JTkRFWCwgemluZGV4KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhbiB1cC5cbiAgICovXG4gIGRpc3Bvc2VJbnRlcm5hbCgpIHtcbiAgICBpZiAodGhpcy5zdGF0ZV8pIHtcbiAgICAgIHRoaXMuc3RhdGVfLmxheWVyID0gbnVsbDtcbiAgICAgIHRoaXMuc3RhdGVfID0gbnVsbDtcbiAgICB9XG4gICAgc3VwZXIuZGlzcG9zZUludGVybmFsKCk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQmFzZUxheWVyO1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2xheWVyL0Jhc2VUaWxlXG4gKi9cbmltcG9ydCBMYXllciBmcm9tICcuL0xheWVyLmpzJztcbmltcG9ydCBUaWxlUHJvcGVydHkgZnJvbSAnLi9UaWxlUHJvcGVydHkuanMnO1xuXG4vKioqXG4gKiBAdGVtcGxhdGUgUmV0dXJuXG4gKiBAdHlwZWRlZiB7aW1wb3J0KFwiLi4vT2JzZXJ2YWJsZVwiKS5PblNpZ25hdHVyZTxpbXBvcnQoXCIuLi9PYnNlcnZhYmxlXCIpLkV2ZW50VHlwZXMsIGltcG9ydChcIi4uL2V2ZW50cy9FdmVudC5qc1wiKS5kZWZhdWx0LCBSZXR1cm4+ICZcbiAqICAgaW1wb3J0KFwiLi4vT2JzZXJ2YWJsZVwiKS5PblNpZ25hdHVyZTxpbXBvcnQoXCIuL0Jhc2VcIikuQmFzZUxheWVyT2JqZWN0RXZlbnRUeXBlc3xcbiAqICAgICBpbXBvcnQoXCIuL0xheWVyLmpzXCIpLkxheWVyRXZlbnRUeXBlfCdjaGFuZ2U6cHJlbG9hZCd8J2NoYW5nZTp1c2VJbnRlcmltVGlsZXNPbkVycm9yJywgaW1wb3J0KFwiLi4vT2JqZWN0XCIpLk9iamVjdEV2ZW50LCBSZXR1cm4+ICZcbiAqICAgaW1wb3J0KFwiLi4vT2JzZXJ2YWJsZVwiKS5PblNpZ25hdHVyZTxpbXBvcnQoXCIuLi9yZW5kZXIvRXZlbnRUeXBlXCIpLkxheWVyUmVuZGVyRXZlbnRUeXBlcywgaW1wb3J0KFwiLi4vcmVuZGVyL0V2ZW50XCIpLmRlZmF1bHQsIFJldHVybj4gJlxuICogICBpbXBvcnQoXCIuLi9PYnNlcnZhYmxlXCIpLkNvbWJpbmVkT25TaWduYXR1cmU8aW1wb3J0KFwiLi4vT2JzZXJ2YWJsZVwiKS5FdmVudFR5cGVzfGltcG9ydChcIi4vQmFzZVwiKS5CYXNlTGF5ZXJPYmplY3RFdmVudFR5cGVzfFxuICogICBpbXBvcnQoXCIuL0xheWVyLmpzXCIpLkxheWVyRXZlbnRUeXBlfCdjaGFuZ2U6cHJlbG9hZCd8J2NoYW5nZTp1c2VJbnRlcmltVGlsZXNPbkVycm9yJ3xpbXBvcnQoXCIuLi9yZW5kZXIvRXZlbnRUeXBlXCIpLkxheWVyUmVuZGVyRXZlbnRUeXBlcywgUmV0dXJuPn0gQmFzZVRpbGVMYXllck9uU2lnbmF0dXJlXG4gKi9cblxuLyoqXG4gKiBAdGVtcGxhdGUge2ltcG9ydChcIi4uL3NvdXJjZS9UaWxlLmpzXCIpLmRlZmF1bHR9IFRpbGVTb3VyY2VUeXBlXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2NsYXNzTmFtZT0nb2wtbGF5ZXInXSBBIENTUyBjbGFzcyBuYW1lIHRvIHNldCB0byB0aGUgbGF5ZXIgZWxlbWVudC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbb3BhY2l0eT0xXSBPcGFjaXR5ICgwLCAxKS5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3Zpc2libGU9dHJ1ZV0gVmlzaWJpbGl0eS5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gW2V4dGVudF0gVGhlIGJvdW5kaW5nIGV4dGVudCBmb3IgbGF5ZXIgcmVuZGVyaW5nLiAgVGhlIGxheWVyIHdpbGwgbm90IGJlXG4gKiByZW5kZXJlZCBvdXRzaWRlIG9mIHRoaXMgZXh0ZW50LlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFt6SW5kZXhdIFRoZSB6LWluZGV4IGZvciBsYXllciByZW5kZXJpbmcuICBBdCByZW5kZXJpbmcgdGltZSwgdGhlIGxheWVyc1xuICogd2lsbCBiZSBvcmRlcmVkLCBmaXJzdCBieSBaLWluZGV4IGFuZCB0aGVuIGJ5IHBvc2l0aW9uLiBXaGVuIGB1bmRlZmluZWRgLCBhIGB6SW5kZXhgIG9mIDAgaXMgYXNzdW1lZFxuICogZm9yIGxheWVycyB0aGF0IGFyZSBhZGRlZCB0byB0aGUgbWFwJ3MgYGxheWVyc2AgY29sbGVjdGlvbiwgb3IgYEluZmluaXR5YCB3aGVuIHRoZSBsYXllcidzIGBzZXRNYXAoKWBcbiAqIG1ldGhvZCB3YXMgdXNlZC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbWluUmVzb2x1dGlvbl0gVGhlIG1pbmltdW0gcmVzb2x1dGlvbiAoaW5jbHVzaXZlKSBhdCB3aGljaCB0aGlzIGxheWVyIHdpbGwgYmVcbiAqIHZpc2libGUuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW21heFJlc29sdXRpb25dIFRoZSBtYXhpbXVtIHJlc29sdXRpb24gKGV4Y2x1c2l2ZSkgYmVsb3cgd2hpY2ggdGhpcyBsYXllciB3aWxsXG4gKiBiZSB2aXNpYmxlLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFttaW5ab29tXSBUaGUgbWluaW11bSB2aWV3IHpvb20gbGV2ZWwgKGV4Y2x1c2l2ZSkgYWJvdmUgd2hpY2ggdGhpcyBsYXllciB3aWxsIGJlXG4gKiB2aXNpYmxlLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFttYXhab29tXSBUaGUgbWF4aW11bSB2aWV3IHpvb20gbGV2ZWwgKGluY2x1c2l2ZSkgYXQgd2hpY2ggdGhpcyBsYXllciB3aWxsXG4gKiBiZSB2aXNpYmxlLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtwcmVsb2FkPTBdIFByZWxvYWQuIExvYWQgbG93LXJlc29sdXRpb24gdGlsZXMgdXAgdG8gYHByZWxvYWRgIGxldmVscy4gYDBgXG4gKiBtZWFucyBubyBwcmVsb2FkaW5nLlxuICogQHByb3BlcnR5IHtUaWxlU291cmNlVHlwZX0gW3NvdXJjZV0gU291cmNlIGZvciB0aGlzIGxheWVyLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9NYXAuanNcIikuZGVmYXVsdH0gW21hcF0gU2V0cyB0aGUgbGF5ZXIgYXMgb3ZlcmxheSBvbiBhIG1hcC4gVGhlIG1hcCB3aWxsIG5vdCBtYW5hZ2VcbiAqIHRoaXMgbGF5ZXIgaW4gaXRzIGxheWVycyBjb2xsZWN0aW9uLCBhbmQgdGhlIGxheWVyIHdpbGwgYmUgcmVuZGVyZWQgb24gdG9wLiBUaGlzIGlzIHVzZWZ1bCBmb3JcbiAqIHRlbXBvcmFyeSBsYXllcnMuIFRoZSBzdGFuZGFyZCB3YXkgdG8gYWRkIGEgbGF5ZXIgdG8gYSBtYXAgYW5kIGhhdmUgaXQgbWFuYWdlZCBieSB0aGUgbWFwIGlzIHRvXG4gKiB1c2Uge0BsaW5rIGltcG9ydChcIi4uL01hcC5qc1wiKS5kZWZhdWx0I2FkZExheWVyIG1hcC5hZGRMYXllcigpfS5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3VzZUludGVyaW1UaWxlc09uRXJyb3I9dHJ1ZV0gVXNlIGludGVyaW0gdGlsZXMgb24gZXJyb3IuXG4gKiBAcHJvcGVydHkge09iamVjdDxzdHJpbmcsICo+fSBbcHJvcGVydGllc10gQXJiaXRyYXJ5IG9ic2VydmFibGUgcHJvcGVydGllcy4gQ2FuIGJlIGFjY2Vzc2VkIHdpdGggYCNnZXQoKWAgYW5kIGAjc2V0KClgLlxuICovXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogRm9yIGxheWVyIHNvdXJjZXMgdGhhdCBwcm92aWRlIHByZS1yZW5kZXJlZCwgdGlsZWQgaW1hZ2VzIGluIGdyaWRzIHRoYXQgYXJlXG4gKiBvcmdhbml6ZWQgYnkgem9vbSBsZXZlbHMgZm9yIHNwZWNpZmljIHJlc29sdXRpb25zLlxuICogTm90ZSB0aGF0IGFueSBwcm9wZXJ0eSBzZXQgaW4gdGhlIG9wdGlvbnMgaXMgc2V0IGFzIGEge0BsaW5rIG1vZHVsZTpvbC9PYmplY3R+QmFzZU9iamVjdH1cbiAqIHByb3BlcnR5IG9uIHRoZSBsYXllciBvYmplY3Q7IGZvciBleGFtcGxlLCBzZXR0aW5nIGB0aXRsZTogJ015IFRpdGxlJ2AgaW4gdGhlXG4gKiBvcHRpb25zIG1lYW5zIHRoYXQgYHRpdGxlYCBpcyBvYnNlcnZhYmxlLCBhbmQgaGFzIGdldC9zZXQgYWNjZXNzb3JzLlxuICpcbiAqIEB0ZW1wbGF0ZSB7aW1wb3J0KFwiLi4vc291cmNlL1RpbGUuanNcIikuZGVmYXVsdH0gVGlsZVNvdXJjZVR5cGVcbiAqIEB0ZW1wbGF0ZSB7aW1wb3J0KFwiLi4vcmVuZGVyZXIvTGF5ZXIuanNcIikuZGVmYXVsdH0gUmVuZGVyZXJUeXBlXG4gKiBAZXh0ZW5kcyB7TGF5ZXI8VGlsZVNvdXJjZVR5cGUsIFJlbmRlcmVyVHlwZT59XG4gKiBAYXBpXG4gKi9cbmNsYXNzIEJhc2VUaWxlTGF5ZXIgZXh0ZW5kcyBMYXllciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge09wdGlvbnM8VGlsZVNvdXJjZVR5cGU+fSBbb3B0aW9uc10gVGlsZSBsYXllciBvcHRpb25zLlxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zID8gb3B0aW9ucyA6IHt9O1xuXG4gICAgY29uc3QgYmFzZU9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKTtcblxuICAgIGRlbGV0ZSBiYXNlT3B0aW9ucy5wcmVsb2FkO1xuICAgIGRlbGV0ZSBiYXNlT3B0aW9ucy51c2VJbnRlcmltVGlsZXNPbkVycm9yO1xuICAgIHN1cGVyKGJhc2VPcHRpb25zKTtcblxuICAgIC8qKipcbiAgICAgKiBAdHlwZSB7QmFzZVRpbGVMYXllck9uU2lnbmF0dXJlPGltcG9ydChcIi4uL2V2ZW50c1wiKS5FdmVudHNLZXk+fVxuICAgICAqL1xuICAgIHRoaXMub247XG5cbiAgICAvKioqXG4gICAgICogQHR5cGUge0Jhc2VUaWxlTGF5ZXJPblNpZ25hdHVyZTxpbXBvcnQoXCIuLi9ldmVudHNcIikuRXZlbnRzS2V5Pn1cbiAgICAgKi9cbiAgICB0aGlzLm9uY2U7XG5cbiAgICAvKioqXG4gICAgICogQHR5cGUge0Jhc2VUaWxlTGF5ZXJPblNpZ25hdHVyZTx2b2lkPn1cbiAgICAgKi9cbiAgICB0aGlzLnVuO1xuXG4gICAgdGhpcy5zZXRQcmVsb2FkKG9wdGlvbnMucHJlbG9hZCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5wcmVsb2FkIDogMCk7XG4gICAgdGhpcy5zZXRVc2VJbnRlcmltVGlsZXNPbkVycm9yKFxuICAgICAgb3B0aW9ucy51c2VJbnRlcmltVGlsZXNPbkVycm9yICE9PSB1bmRlZmluZWRcbiAgICAgICAgPyBvcHRpb25zLnVzZUludGVyaW1UaWxlc09uRXJyb3JcbiAgICAgICAgOiB0cnVlXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGxldmVsIGFzIG51bWJlciB0byB3aGljaCB3ZSB3aWxsIHByZWxvYWQgdGlsZXMgdXAgdG8uXG4gICAqIEByZXR1cm4ge251bWJlcn0gVGhlIGxldmVsIHRvIHByZWxvYWQgdGlsZXMgdXAgdG8uXG4gICAqIEBvYnNlcnZhYmxlXG4gICAqIEBhcGlcbiAgICovXG4gIGdldFByZWxvYWQoKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAodGhpcy5nZXQoVGlsZVByb3BlcnR5LlBSRUxPQUQpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGxldmVsIGFzIG51bWJlciB0byB3aGljaCB3ZSB3aWxsIHByZWxvYWQgdGlsZXMgdXAgdG8uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwcmVsb2FkIFRoZSBsZXZlbCB0byBwcmVsb2FkIHRpbGVzIHVwIHRvLlxuICAgKiBAb2JzZXJ2YWJsZVxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRQcmVsb2FkKHByZWxvYWQpIHtcbiAgICB0aGlzLnNldChUaWxlUHJvcGVydHkuUFJFTE9BRCwgcHJlbG9hZCk7XG4gIH1cblxuICAvKipcbiAgICogV2hldGhlciB3ZSB1c2UgaW50ZXJpbSB0aWxlcyBvbiBlcnJvci5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVXNlIGludGVyaW0gdGlsZXMgb24gZXJyb3IuXG4gICAqIEBvYnNlcnZhYmxlXG4gICAqIEBhcGlcbiAgICovXG4gIGdldFVzZUludGVyaW1UaWxlc09uRXJyb3IoKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi8gKFxuICAgICAgdGhpcy5nZXQoVGlsZVByb3BlcnR5LlVTRV9JTlRFUklNX1RJTEVTX09OX0VSUk9SKVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHdoZXRoZXIgd2UgdXNlIGludGVyaW0gdGlsZXMgb24gZXJyb3IuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gdXNlSW50ZXJpbVRpbGVzT25FcnJvciBVc2UgaW50ZXJpbSB0aWxlcyBvbiBlcnJvci5cbiAgICogQG9ic2VydmFibGVcbiAgICogQGFwaVxuICAgKi9cbiAgc2V0VXNlSW50ZXJpbVRpbGVzT25FcnJvcih1c2VJbnRlcmltVGlsZXNPbkVycm9yKSB7XG4gICAgdGhpcy5zZXQoVGlsZVByb3BlcnR5LlVTRV9JTlRFUklNX1RJTEVTX09OX0VSUk9SLCB1c2VJbnRlcmltVGlsZXNPbkVycm9yKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgZGF0YSBmb3IgYSBwaXhlbCBsb2NhdGlvbi4gIFRoZSByZXR1cm4gdHlwZSBkZXBlbmRzIG9uIHRoZSBzb3VyY2UgZGF0YS4gIEZvciBpbWFnZSB0aWxlcyxcbiAgICogYSBmb3VyIGVsZW1lbnQgUkdCQSBhcnJheSB3aWxsIGJlIHJldHVybmVkLiAgRm9yIGRhdGEgdGlsZXMsIHRoZSBhcnJheSBsZW5ndGggd2lsbCBtYXRjaCB0aGVcbiAgICogbnVtYmVyIG9mIGJhbmRzIGluIHRoZSBkYXRhc2V0LiAgRm9yIHJlcXVlc3RzIG91dHNpZGUgdGhlIGxheWVyIGV4dGVudCwgYG51bGxgIHdpbGwgYmUgcmV0dXJuZWQuXG4gICAqIERhdGEgZm9yIGEgaW1hZ2UgdGlsZXMgY2FuIG9ubHkgYmUgcmV0cmlldmVkIGlmIHRoZSBzb3VyY2UncyBgY3Jvc3NPcmlnaW5gIHByb3BlcnR5IGlzIHNldC5cbiAgICpcbiAgICogYGBganNcbiAgICogLy8gZGlzcGxheSBsYXllciBkYXRhIG9uIGV2ZXJ5IHBvaW50ZXIgbW92ZVxuICAgKiBtYXAub24oJ3BvaW50ZXJtb3ZlJywgKGV2ZW50KSA9PiB7XG4gICAqICAgY29uc29sZS5sb2cobGF5ZXIuZ2V0RGF0YShldmVudC5waXhlbCkpO1xuICAgKiB9KTtcbiAgICogYGBgXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcGl4ZWxcIikuUGl4ZWx9IHBpeGVsIFBpeGVsLlxuICAgKiBAcmV0dXJuIHtVaW50OENsYW1wZWRBcnJheXxVaW50OEFycmF5fEZsb2F0MzJBcnJheXxEYXRhVmlld3xudWxsfSBQaXhlbCBkYXRhLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXREYXRhKHBpeGVsKSB7XG4gICAgcmV0dXJuIHN1cGVyLmdldERhdGEocGl4ZWwpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEJhc2VUaWxlTGF5ZXI7XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvbGF5ZXIvQmFzZVZlY3RvclxuICovXG5pbXBvcnQgTGF5ZXIgZnJvbSAnLi9MYXllci5qcyc7XG5pbXBvcnQgUkJ1c2ggZnJvbSAncmJ1c2gnO1xuaW1wb3J0IFN0eWxlLCB7XG4gIGNyZWF0ZURlZmF1bHRTdHlsZSxcbiAgdG9GdW5jdGlvbiBhcyB0b1N0eWxlRnVuY3Rpb24sXG59IGZyb20gJy4uL3N0eWxlL1N0eWxlLmpzJztcbmltcG9ydCB7XG4gIGZsYXRTdHlsZXNUb1N0eWxlRnVuY3Rpb24sXG4gIHJ1bGVzVG9TdHlsZUZ1bmN0aW9uLFxufSBmcm9tICcuLi9yZW5kZXIvY2FudmFzL3N0eWxlLmpzJztcblxuLyoqXG4gKiBAdGVtcGxhdGUge2ltcG9ydChcIi4uL3NvdXJjZS9WZWN0b3IuanNcIikuZGVmYXVsdHxpbXBvcnQoXCIuLi9zb3VyY2UvVmVjdG9yVGlsZS5qc1wiKS5kZWZhdWx0fSBWZWN0b3JTb3VyY2VUeXBlXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2NsYXNzTmFtZT0nb2wtbGF5ZXInXSBBIENTUyBjbGFzcyBuYW1lIHRvIHNldCB0byB0aGUgbGF5ZXIgZWxlbWVudC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbb3BhY2l0eT0xXSBPcGFjaXR5ICgwLCAxKS5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3Zpc2libGU9dHJ1ZV0gVmlzaWJpbGl0eS5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gW2V4dGVudF0gVGhlIGJvdW5kaW5nIGV4dGVudCBmb3IgbGF5ZXIgcmVuZGVyaW5nLiAgVGhlIGxheWVyIHdpbGwgbm90IGJlXG4gKiByZW5kZXJlZCBvdXRzaWRlIG9mIHRoaXMgZXh0ZW50LlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFt6SW5kZXhdIFRoZSB6LWluZGV4IGZvciBsYXllciByZW5kZXJpbmcuICBBdCByZW5kZXJpbmcgdGltZSwgdGhlIGxheWVyc1xuICogd2lsbCBiZSBvcmRlcmVkLCBmaXJzdCBieSBaLWluZGV4IGFuZCB0aGVuIGJ5IHBvc2l0aW9uLiBXaGVuIGB1bmRlZmluZWRgLCBhIGB6SW5kZXhgIG9mIDAgaXMgYXNzdW1lZFxuICogZm9yIGxheWVycyB0aGF0IGFyZSBhZGRlZCB0byB0aGUgbWFwJ3MgYGxheWVyc2AgY29sbGVjdGlvbiwgb3IgYEluZmluaXR5YCB3aGVuIHRoZSBsYXllcidzIGBzZXRNYXAoKWBcbiAqIG1ldGhvZCB3YXMgdXNlZC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbWluUmVzb2x1dGlvbl0gVGhlIG1pbmltdW0gcmVzb2x1dGlvbiAoaW5jbHVzaXZlKSBhdCB3aGljaCB0aGlzIGxheWVyIHdpbGwgYmVcbiAqIHZpc2libGUuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW21heFJlc29sdXRpb25dIFRoZSBtYXhpbXVtIHJlc29sdXRpb24gKGV4Y2x1c2l2ZSkgYmVsb3cgd2hpY2ggdGhpcyBsYXllciB3aWxsXG4gKiBiZSB2aXNpYmxlLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFttaW5ab29tXSBUaGUgbWluaW11bSB2aWV3IHpvb20gbGV2ZWwgKGV4Y2x1c2l2ZSkgYWJvdmUgd2hpY2ggdGhpcyBsYXllciB3aWxsIGJlXG4gKiB2aXNpYmxlLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFttYXhab29tXSBUaGUgbWF4aW11bSB2aWV3IHpvb20gbGV2ZWwgKGluY2x1c2l2ZSkgYXQgd2hpY2ggdGhpcyBsYXllciB3aWxsXG4gKiBiZSB2aXNpYmxlLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9yZW5kZXIuanNcIikuT3JkZXJGdW5jdGlvbn0gW3JlbmRlck9yZGVyXSBSZW5kZXIgb3JkZXIuIEZ1bmN0aW9uIHRvIGJlIHVzZWQgd2hlbiBzb3J0aW5nXG4gKiBmZWF0dXJlcyBiZWZvcmUgcmVuZGVyaW5nLiBCeSBkZWZhdWx0IGZlYXR1cmVzIGFyZSBkcmF3biBpbiB0aGUgb3JkZXIgdGhhdCB0aGV5IGFyZSBjcmVhdGVkLiBVc2VcbiAqIGBudWxsYCB0byBhdm9pZCB0aGUgc29ydCwgYnV0IGdldCBhbiB1bmRlZmluZWQgZHJhdyBvcmRlci5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbcmVuZGVyQnVmZmVyPTEwMF0gVGhlIGJ1ZmZlciBpbiBwaXhlbHMgYXJvdW5kIHRoZSB2aWV3cG9ydCBleHRlbnQgdXNlZCBieSB0aGVcbiAqIHJlbmRlcmVyIHdoZW4gZ2V0dGluZyBmZWF0dXJlcyBmcm9tIHRoZSB2ZWN0b3Igc291cmNlIGZvciB0aGUgcmVuZGVyaW5nIG9yIGhpdC1kZXRlY3Rpb24uXG4gKiBSZWNvbW1lbmRlZCB2YWx1ZTogdGhlIHNpemUgb2YgdGhlIGxhcmdlc3Qgc3ltYm9sLCBsaW5lIHdpZHRoIG9yIGxhYmVsLlxuICogQHByb3BlcnR5IHtWZWN0b3JTb3VyY2VUeXBlfSBbc291cmNlXSBTb3VyY2UuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL01hcC5qc1wiKS5kZWZhdWx0fSBbbWFwXSBTZXRzIHRoZSBsYXllciBhcyBvdmVybGF5IG9uIGEgbWFwLiBUaGUgbWFwIHdpbGwgbm90IG1hbmFnZVxuICogdGhpcyBsYXllciBpbiBpdHMgbGF5ZXJzIGNvbGxlY3Rpb24sIGFuZCB0aGUgbGF5ZXIgd2lsbCBiZSByZW5kZXJlZCBvbiB0b3AuIFRoaXMgaXMgdXNlZnVsIGZvclxuICogdGVtcG9yYXJ5IGxheWVycy4gVGhlIHN0YW5kYXJkIHdheSB0byBhZGQgYSBsYXllciB0byBhIG1hcCBhbmQgaGF2ZSBpdCBtYW5hZ2VkIGJ5IHRoZSBtYXAgaXMgdG9cbiAqIHVzZSBbbWFwLmFkZExheWVyKClde0BsaW5rIGltcG9ydChcIi4uL01hcC5qc1wiKS5kZWZhdWx0I2FkZExheWVyfS5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2RlY2x1dHRlcj1mYWxzZV0gRGVjbHV0dGVyIGltYWdlcyBhbmQgdGV4dC4gRGVjbHV0dGVyaW5nIGlzIGFwcGxpZWQgdG8gYWxsXG4gKiBpbWFnZSBhbmQgdGV4dCBzdHlsZXMgb2YgYWxsIFZlY3RvciBhbmQgVmVjdG9yVGlsZSBsYXllcnMgdGhhdCBoYXZlIHNldCB0aGlzIHRvIGB0cnVlYC4gVGhlIHByaW9yaXR5XG4gKiBpcyBkZWZpbmVkIGJ5IHRoZSB6LWluZGV4IG9mIHRoZSBsYXllciwgdGhlIGB6SW5kZXhgIG9mIHRoZSBzdHlsZSBhbmQgdGhlIHJlbmRlciBvcmRlciBvZiBmZWF0dXJlcy5cbiAqIEhpZ2hlciB6LWluZGV4IG1lYW5zIGhpZ2hlciBwcmlvcml0eS4gV2l0aGluIHRoZSBzYW1lIHotaW5kZXgsIGEgZmVhdHVyZSByZW5kZXJlZCBiZWZvcmUgYW5vdGhlciBoYXNcbiAqIGhpZ2hlciBwcmlvcml0eS5cbiAqXG4gKiBBcyBhbiBvcHRpbWl6YXRpb24gZGVjbHV0dGVyZWQgZmVhdHVyZXMgZnJvbSBsYXllcnMgd2l0aCB0aGUgc2FtZSBgY2xhc3NOYW1lYCBhcmUgcmVuZGVyZWQgYWJvdmVcbiAqIHRoZSBmaWxsIGFuZCBzdHJva2Ugc3R5bGVzIG9mIGFsbCBvZiB0aG9zZSBsYXllcnMgcmVnYXJkbGVzcyBvZiB6LWluZGV4LiAgVG8gb3B0IG91dCBvZiB0aGlzXG4gKiBiZWhhdmlvciBhbmQgcGxhY2UgZGVjbHV0dGVyZCBmZWF0dXJlcyB3aXRoIHRoZWlyIG93biBsYXllciBjb25maWd1cmUgdGhlIGxheWVyIHdpdGggYSBgY2xhc3NOYW1lYFxuICogb3RoZXIgdGhhbiBgb2wtbGF5ZXJgLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9zdHlsZS9TdHlsZS5qc1wiKS5TdHlsZUxpa2V8aW1wb3J0KFwiLi4vc3R5bGUvZmxhdC5qc1wiKS5GbGF0U3R5bGVMaWtlfG51bGx9IFtzdHlsZV0gTGF5ZXIgc3R5bGUuIFdoZW4gc2V0IHRvIGBudWxsYCwgb25seVxuICogZmVhdHVyZXMgdGhhdCBoYXZlIHRoZWlyIG93biBzdHlsZSB3aWxsIGJlIHJlbmRlcmVkLiBTZWUge0BsaW5rIG1vZHVsZTpvbC9zdHlsZS9TdHlsZX5TdHlsZX0gZm9yIHRoZSBkZWZhdWx0IHN0eWxlXG4gKiB3aGljaCB3aWxsIGJlIHVzZWQgaWYgdGhpcyBpcyBub3Qgc2V0LlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL0Jhc2UuanNcIikuQmFja2dyb3VuZENvbG9yfSBbYmFja2dyb3VuZF0gQmFja2dyb3VuZCBjb2xvciBmb3IgdGhlIGxheWVyLiBJZiBub3Qgc3BlY2lmaWVkLCBubyBiYWNrZ3JvdW5kXG4gKiB3aWxsIGJlIHJlbmRlcmVkLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbdXBkYXRlV2hpbGVBbmltYXRpbmc9ZmFsc2VdIFdoZW4gc2V0IHRvIGB0cnVlYCwgZmVhdHVyZSBiYXRjaGVzIHdpbGxcbiAqIGJlIHJlY3JlYXRlZCBkdXJpbmcgYW5pbWF0aW9ucy4gVGhpcyBtZWFucyB0aGF0IG5vIHZlY3RvcnMgd2lsbCBiZSBzaG93biBjbGlwcGVkLCBidXQgdGhlXG4gKiBzZXR0aW5nIHdpbGwgaGF2ZSBhIHBlcmZvcm1hbmNlIGltcGFjdCBmb3IgbGFyZ2UgYW1vdW50cyBvZiB2ZWN0b3IgZGF0YS4gV2hlbiBzZXQgdG8gYGZhbHNlYCxcbiAqIGJhdGNoZXMgd2lsbCBiZSByZWNyZWF0ZWQgd2hlbiBubyBhbmltYXRpb24gaXMgYWN0aXZlLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbdXBkYXRlV2hpbGVJbnRlcmFjdGluZz1mYWxzZV0gV2hlbiBzZXQgdG8gYHRydWVgLCBmZWF0dXJlIGJhdGNoZXMgd2lsbFxuICogYmUgcmVjcmVhdGVkIGR1cmluZyBpbnRlcmFjdGlvbnMuIFNlZSBhbHNvIGB1cGRhdGVXaGlsZUFuaW1hdGluZ2AuXG4gKiBAcHJvcGVydHkge09iamVjdDxzdHJpbmcsICo+fSBbcHJvcGVydGllc10gQXJiaXRyYXJ5IG9ic2VydmFibGUgcHJvcGVydGllcy4gQ2FuIGJlIGFjY2Vzc2VkIHdpdGggYCNnZXQoKWAgYW5kIGAjc2V0KClgLlxuICovXG5cbi8qKlxuICogQGVudW0ge3N0cmluZ31cbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IFByb3BlcnR5ID0ge1xuICBSRU5ERVJfT1JERVI6ICdyZW5kZXJPcmRlcicsXG59O1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIFZlY3RvciBkYXRhIHRoYXQgaXMgcmVuZGVyZWQgY2xpZW50LXNpZGUuXG4gKiBOb3RlIHRoYXQgYW55IHByb3BlcnR5IHNldCBpbiB0aGUgb3B0aW9ucyBpcyBzZXQgYXMgYSB7QGxpbmsgbW9kdWxlOm9sL09iamVjdH5CYXNlT2JqZWN0fVxuICogcHJvcGVydHkgb24gdGhlIGxheWVyIG9iamVjdDsgZm9yIGV4YW1wbGUsIHNldHRpbmcgYHRpdGxlOiAnTXkgVGl0bGUnYCBpbiB0aGVcbiAqIG9wdGlvbnMgbWVhbnMgdGhhdCBgdGl0bGVgIGlzIG9ic2VydmFibGUsIGFuZCBoYXMgZ2V0L3NldCBhY2Nlc3NvcnMuXG4gKlxuICogQHRlbXBsYXRlIHtpbXBvcnQoXCIuLi9zb3VyY2UvVmVjdG9yLmpzXCIpLmRlZmF1bHR8aW1wb3J0KFwiLi4vc291cmNlL1ZlY3RvclRpbGUuanNcIikuZGVmYXVsdH0gVmVjdG9yU291cmNlVHlwZVxuICogQHRlbXBsYXRlIHtpbXBvcnQoXCIuLi9yZW5kZXJlci9jYW52YXMvVmVjdG9yTGF5ZXIuanNcIikuZGVmYXVsdHxpbXBvcnQoXCIuLi9yZW5kZXJlci9jYW52YXMvVmVjdG9yVGlsZUxheWVyLmpzXCIpLmRlZmF1bHR8aW1wb3J0KFwiLi4vcmVuZGVyZXIvY2FudmFzL1ZlY3RvckltYWdlTGF5ZXIuanNcIikuZGVmYXVsdHxpbXBvcnQoXCIuLi9yZW5kZXJlci93ZWJnbC9Qb2ludHNMYXllci5qc1wiKS5kZWZhdWx0fSBSZW5kZXJlclR5cGVcbiAqIEBleHRlbmRzIHtMYXllcjxWZWN0b3JTb3VyY2VUeXBlLCBSZW5kZXJlclR5cGU+fVxuICogQGFwaVxuICovXG5jbGFzcyBCYXNlVmVjdG9yTGF5ZXIgZXh0ZW5kcyBMYXllciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge09wdGlvbnM8VmVjdG9yU291cmNlVHlwZT59IFtvcHRpb25zXSBPcHRpb25zLlxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zID8gb3B0aW9ucyA6IHt9O1xuXG4gICAgY29uc3QgYmFzZU9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKTtcblxuICAgIGRlbGV0ZSBiYXNlT3B0aW9ucy5zdHlsZTtcbiAgICBkZWxldGUgYmFzZU9wdGlvbnMucmVuZGVyQnVmZmVyO1xuICAgIGRlbGV0ZSBiYXNlT3B0aW9ucy51cGRhdGVXaGlsZUFuaW1hdGluZztcbiAgICBkZWxldGUgYmFzZU9wdGlvbnMudXBkYXRlV2hpbGVJbnRlcmFjdGluZztcbiAgICBzdXBlcihiYXNlT3B0aW9ucyk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuZGVjbHV0dGVyXyA9XG4gICAgICBvcHRpb25zLmRlY2x1dHRlciAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5kZWNsdXR0ZXIgOiBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLnJlbmRlckJ1ZmZlcl8gPVxuICAgICAgb3B0aW9ucy5yZW5kZXJCdWZmZXIgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMucmVuZGVyQnVmZmVyIDogMTAwO1xuXG4gICAgLyoqXG4gICAgICogVXNlciBwcm92aWRlZCBzdHlsZS5cbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vc3R5bGUvU3R5bGUuanNcIikuU3R5bGVMaWtlfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5zdHlsZV8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogU3R5bGUgZnVuY3Rpb24gZm9yIHVzZSB3aXRoaW4gdGhlIGxpYnJhcnkuXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL3N0eWxlL1N0eWxlLmpzXCIpLlN0eWxlRnVuY3Rpb258dW5kZWZpbmVkfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5zdHlsZUZ1bmN0aW9uXyA9IHVuZGVmaW5lZDtcblxuICAgIHRoaXMuc2V0U3R5bGUob3B0aW9ucy5zdHlsZSk7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMudXBkYXRlV2hpbGVBbmltYXRpbmdfID1cbiAgICAgIG9wdGlvbnMudXBkYXRlV2hpbGVBbmltYXRpbmcgIT09IHVuZGVmaW5lZFxuICAgICAgICA/IG9wdGlvbnMudXBkYXRlV2hpbGVBbmltYXRpbmdcbiAgICAgICAgOiBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy51cGRhdGVXaGlsZUludGVyYWN0aW5nXyA9XG4gICAgICBvcHRpb25zLnVwZGF0ZVdoaWxlSW50ZXJhY3RpbmcgIT09IHVuZGVmaW5lZFxuICAgICAgICA/IG9wdGlvbnMudXBkYXRlV2hpbGVJbnRlcmFjdGluZ1xuICAgICAgICA6IGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IERlY2x1dHRlci5cbiAgICovXG4gIGdldERlY2x1dHRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5kZWNsdXR0ZXJfO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdG9wbW9zdCBmZWF0dXJlIHRoYXQgaW50ZXJzZWN0cyB0aGUgZ2l2ZW4gcGl4ZWwgb24gdGhlIHZpZXdwb3J0LiBSZXR1cm5zIGEgcHJvbWlzZVxuICAgKiB0aGF0IHJlc29sdmVzIHdpdGggYW4gYXJyYXkgb2YgZmVhdHVyZXMuIFRoZSBhcnJheSB3aWxsIGVpdGhlciBjb250YWluIHRoZSB0b3Btb3N0IGZlYXR1cmVcbiAgICogd2hlbiBhIGhpdCB3YXMgZGV0ZWN0ZWQsIG9yIGl0IHdpbGwgYmUgZW1wdHkuXG4gICAqXG4gICAqIFRoZSBoaXQgZGV0ZWN0aW9uIGFsZ29yaXRobSB1c2VkIGZvciB0aGlzIG1ldGhvZCBpcyBvcHRpbWl6ZWQgZm9yIHBlcmZvcm1hbmNlLCBidXQgaXMgbGVzc1xuICAgKiBhY2N1cmF0ZSB0aGFuIHRoZSBvbmUgdXNlZCBpbiBbbWFwLmdldEZlYXR1cmVzQXRQaXhlbCgpXXtAbGluayBpbXBvcnQoXCIuLi9NYXAuanNcIikuZGVmYXVsdCNnZXRGZWF0dXJlc0F0UGl4ZWx9LlxuICAgKiBUZXh0IGlzIG5vdCBjb25zaWRlcmVkLCBhbmQgaWNvbnMgYXJlIG9ubHkgcmVwcmVzZW50ZWQgYnkgdGhlaXIgYm91bmRpbmcgYm94IGluc3RlYWQgb2YgdGhlIGV4YWN0XG4gICAqIGltYWdlLlxuICAgKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3BpeGVsLmpzXCIpLlBpeGVsfSBwaXhlbCBQaXhlbC5cbiAgICogQHJldHVybiB7UHJvbWlzZTxBcnJheTxpbXBvcnQoXCIuLi9GZWF0dXJlXCIpLkZlYXR1cmVMaWtlPj59IFByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIGFuIGFycmF5IG9mIGZlYXR1cmVzLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRGZWF0dXJlcyhwaXhlbCkge1xuICAgIHJldHVybiBzdXBlci5nZXRGZWF0dXJlcyhwaXhlbCk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfHVuZGVmaW5lZH0gUmVuZGVyIGJ1ZmZlci5cbiAgICovXG4gIGdldFJlbmRlckJ1ZmZlcigpIHtcbiAgICByZXR1cm4gdGhpcy5yZW5kZXJCdWZmZXJfO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Z1bmN0aW9uKGltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdCwgaW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0KTogbnVtYmVyfG51bGx8dW5kZWZpbmVkfSBSZW5kZXJcbiAgICogICAgIG9yZGVyLlxuICAgKi9cbiAgZ2V0UmVuZGVyT3JkZXIoKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vcmVuZGVyLmpzXCIpLk9yZGVyRnVuY3Rpb258bnVsbHx1bmRlZmluZWR9ICovIChcbiAgICAgIHRoaXMuZ2V0KFByb3BlcnR5LlJFTkRFUl9PUkRFUilcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgc3R5bGUgZm9yIGZlYXR1cmVzLiAgVGhpcyByZXR1cm5zIHdoYXRldmVyIHdhcyBwYXNzZWQgdG8gdGhlIGBzdHlsZWBcbiAgICogb3B0aW9uIGF0IGNvbnN0cnVjdGlvbiBvciB0byB0aGUgYHNldFN0eWxlYCBtZXRob2QuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL3N0eWxlL1N0eWxlLmpzXCIpLlN0eWxlTGlrZXxudWxsfHVuZGVmaW5lZH0gTGF5ZXIgc3R5bGUuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldFN0eWxlKCkge1xuICAgIHJldHVybiB0aGlzLnN0eWxlXztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHN0eWxlIGZ1bmN0aW9uLlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9zdHlsZS9TdHlsZS5qc1wiKS5TdHlsZUZ1bmN0aW9ufHVuZGVmaW5lZH0gTGF5ZXIgc3R5bGUgZnVuY3Rpb24uXG4gICAqIEBhcGlcbiAgICovXG4gIGdldFN0eWxlRnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuc3R5bGVGdW5jdGlvbl87XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgcmVuZGVyZWQgbGF5ZXIgc2hvdWxkIGJlIHVwZGF0ZWQgd2hpbGVcbiAgICogICAgIGFuaW1hdGluZy5cbiAgICovXG4gIGdldFVwZGF0ZVdoaWxlQW5pbWF0aW5nKCkge1xuICAgIHJldHVybiB0aGlzLnVwZGF0ZVdoaWxlQW5pbWF0aW5nXztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSByZW5kZXJlZCBsYXllciBzaG91bGQgYmUgdXBkYXRlZCB3aGlsZVxuICAgKiAgICAgaW50ZXJhY3RpbmcuXG4gICAqL1xuICBnZXRVcGRhdGVXaGlsZUludGVyYWN0aW5nKCkge1xuICAgIHJldHVybiB0aGlzLnVwZGF0ZVdoaWxlSW50ZXJhY3RpbmdfO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlciBkZWNsdXR0ZXIgaXRlbXMgZm9yIHRoaXMgbGF5ZXJcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXAuanNcIikuRnJhbWVTdGF0ZX0gZnJhbWVTdGF0ZSBGcmFtZSBzdGF0ZS5cbiAgICovXG4gIHJlbmRlckRlY2x1dHRlcihmcmFtZVN0YXRlKSB7XG4gICAgaWYgKCFmcmFtZVN0YXRlLmRlY2x1dHRlclRyZWUpIHtcbiAgICAgIGZyYW1lU3RhdGUuZGVjbHV0dGVyVHJlZSA9IG5ldyBSQnVzaCg5KTtcbiAgICB9XG4gICAgLyoqIEB0eXBlIHsqfSAqLyAodGhpcy5nZXRSZW5kZXJlcigpKS5yZW5kZXJEZWNsdXR0ZXIoZnJhbWVTdGF0ZSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9yZW5kZXIuanNcIikuT3JkZXJGdW5jdGlvbnxudWxsfHVuZGVmaW5lZH0gcmVuZGVyT3JkZXJcbiAgICogICAgIFJlbmRlciBvcmRlci5cbiAgICovXG4gIHNldFJlbmRlck9yZGVyKHJlbmRlck9yZGVyKSB7XG4gICAgdGhpcy5zZXQoUHJvcGVydHkuUkVOREVSX09SREVSLCByZW5kZXJPcmRlcik7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBzdHlsZSBmb3IgZmVhdHVyZXMuICBUaGlzIGNhbiBiZSBhIHNpbmdsZSBzdHlsZSBvYmplY3QsIGFuIGFycmF5XG4gICAqIG9mIHN0eWxlcywgb3IgYSBmdW5jdGlvbiB0aGF0IHRha2VzIGEgZmVhdHVyZSBhbmQgcmVzb2x1dGlvbiBhbmQgcmV0dXJuc1xuICAgKiBhbiBhcnJheSBvZiBzdHlsZXMuIElmIHNldCB0byBgbnVsbGAsIHRoZSBsYXllciBoYXMgbm8gc3R5bGUgKGEgYG51bGxgIHN0eWxlKSxcbiAgICogc28gb25seSBmZWF0dXJlcyB0aGF0IGhhdmUgdGhlaXIgb3duIHN0eWxlcyB3aWxsIGJlIHJlbmRlcmVkIGluIHRoZSBsYXllci4gQ2FsbFxuICAgKiBgc2V0U3R5bGUoKWAgd2l0aG91dCBhcmd1bWVudHMgdG8gcmVzZXQgdG8gdGhlIGRlZmF1bHQgc3R5bGUuIFNlZVxuICAgKiBbdGhlIG9sL3N0eWxlL1N0eWxlIG1vZHVsZV17QGxpbmsgbW9kdWxlOm9sL3N0eWxlL1N0eWxlflN0eWxlfSBmb3IgaW5mb3JtYXRpb24gb24gdGhlIGRlZmF1bHQgc3R5bGUuXG4gICAqXG4gICAqIElmIHlvdXIgbGF5ZXIgaGFzIGEgc3RhdGljIHN0eWxlLCB5b3UgY2FuIHVzZSBbZmxhdCBzdHlsZV17QGxpbmsgbW9kdWxlOm9sL3N0eWxlL2ZsYXR+RmxhdFN0eWxlfSBvYmplY3RcbiAgICogbGl0ZXJhbHMgaW5zdGVhZCBvZiB1c2luZyB0aGUgYFN0eWxlYCBhbmQgc3ltYm9saXplciBjb25zdHJ1Y3RvcnMgKGBGaWxsYCwgYFN0cm9rZWAsIGV0Yy4pOlxuICAgKiBgYGBqc1xuICAgKiB2ZWN0b3JMYXllci5zZXRTdHlsZSh7XG4gICAqICAgXCJmaWxsLWNvbG9yXCI6IFwieWVsbG93XCIsXG4gICAqICAgXCJzdHJva2UtY29sb3JcIjogXCJibGFja1wiLFxuICAgKiAgIFwic3Ryb2tlLXdpZHRoXCI6IDRcbiAgICogfSlcbiAgICogYGBgXG4gICAqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vc3R5bGUvU3R5bGUuanNcIikuU3R5bGVMaWtlfGltcG9ydChcIi4uL3N0eWxlL2ZsYXQuanNcIikuRmxhdFN0eWxlTGlrZXxudWxsfSBbc3R5bGVdIExheWVyIHN0eWxlLlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRTdHlsZShzdHlsZSkge1xuICAgIHRoaXMuc3R5bGVfID0gdG9TdHlsZUxpa2Uoc3R5bGUpO1xuICAgIHRoaXMuc3R5bGVGdW5jdGlvbl8gPVxuICAgICAgc3R5bGUgPT09IG51bGwgPyB1bmRlZmluZWQgOiB0b1N0eWxlRnVuY3Rpb24odGhpcy5zdHlsZV8pO1xuICAgIHRoaXMuY2hhbmdlZCgpO1xuICB9XG59XG5cbi8qKlxuICogQ29lcmNlIHRoZSBhbGxvd2VkIHN0eWxlIHR5cGVzIGludG8gYSBzaG9ydGVyIGxpc3Qgb2YgdHlwZXMuICBGbGF0IHN0eWxlcywgYXJyYXlzIG9mIGZsYXRcbiAqIHN0eWxlcywgYW5kIGFycmF5cyBvZiBydWxlcyBhcmUgY29udmVydGVkIGludG8gc3R5bGUgZnVuY3Rpb25zLlxuICpcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vc3R5bGUvU3R5bGUuanNcIikuU3R5bGVMaWtlfGltcG9ydChcIi4uL3N0eWxlL2ZsYXQuanNcIikuRmxhdFN0eWxlTGlrZXxudWxsfSBbc3R5bGVdIExheWVyIHN0eWxlLlxuICogQHJldHVybiB7aW1wb3J0KFwiLi4vc3R5bGUvU3R5bGUuanNcIikuU3R5bGVMaWtlfG51bGx9IFRoZSBzdHlsZS5cbiAqL1xuZnVuY3Rpb24gdG9TdHlsZUxpa2Uoc3R5bGUpIHtcbiAgaWYgKHN0eWxlID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gY3JlYXRlRGVmYXVsdFN0eWxlO1xuICB9XG4gIGlmICghc3R5bGUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAodHlwZW9mIHN0eWxlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHN0eWxlO1xuICB9XG4gIGlmIChzdHlsZSBpbnN0YW5jZW9mIFN0eWxlKSB7XG4gICAgcmV0dXJuIHN0eWxlO1xuICB9XG4gIGlmICghQXJyYXkuaXNBcnJheShzdHlsZSkpIHtcbiAgICByZXR1cm4gZmxhdFN0eWxlc1RvU3R5bGVGdW5jdGlvbihbc3R5bGVdKTtcbiAgfVxuICBpZiAoc3R5bGUubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgY29uc3QgbGVuZ3RoID0gc3R5bGUubGVuZ3RoO1xuICBjb25zdCBmaXJzdCA9IHN0eWxlWzBdO1xuXG4gIGlmIChmaXJzdCBpbnN0YW5jZW9mIFN0eWxlKSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge0FycmF5PFN0eWxlPn1cbiAgICAgKi9cbiAgICBjb25zdCBzdHlsZXMgPSBuZXcgQXJyYXkobGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICBjb25zdCBjYW5kaWRhdGUgPSBzdHlsZVtpXTtcbiAgICAgIGlmICghKGNhbmRpZGF0ZSBpbnN0YW5jZW9mIFN0eWxlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGEgbGlzdCBvZiBzdHlsZSBpbnN0YW5jZXMnKTtcbiAgICAgIH1cbiAgICAgIHN0eWxlc1tpXSA9IGNhbmRpZGF0ZTtcbiAgICB9XG4gICAgcmV0dXJuIHN0eWxlcztcbiAgfVxuXG4gIGlmICgnc3R5bGUnIGluIGZpcnN0KSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUgQXJyYXk8aW1wb3J0KFwiLi4vc3R5bGUvZmxhdC5qc1wiKS5SdWxlPlxuICAgICAqL1xuICAgIGNvbnN0IHJ1bGVzID0gbmV3IEFycmF5KGxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgICAgY29uc3QgY2FuZGlkYXRlID0gc3R5bGVbaV07XG4gICAgICBpZiAoISgnc3R5bGUnIGluIGNhbmRpZGF0ZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBhIGxpc3Qgb2YgcnVsZXMgd2l0aCBhIHN0eWxlIHByb3BlcnR5Jyk7XG4gICAgICB9XG4gICAgICBydWxlc1tpXSA9IGNhbmRpZGF0ZTtcbiAgICB9XG4gICAgcmV0dXJuIHJ1bGVzVG9TdHlsZUZ1bmN0aW9uKHJ1bGVzKTtcbiAgfVxuXG4gIGNvbnN0IGZsYXRTdHlsZXMgPVxuICAgIC8qKiBAdHlwZSB7QXJyYXk8aW1wb3J0KFwiLi4vc3R5bGUvZmxhdC5qc1wiKS5GbGF0U3R5bGU+fSAqLyAoc3R5bGUpO1xuICByZXR1cm4gZmxhdFN0eWxlc1RvU3R5bGVGdW5jdGlvbihmbGF0U3R5bGVzKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgQmFzZVZlY3RvckxheWVyO1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2xheWVyL0dyb3VwXG4gKi9cbmltcG9ydCBCYXNlTGF5ZXIgZnJvbSAnLi9CYXNlLmpzJztcbmltcG9ydCBDb2xsZWN0aW9uIGZyb20gJy4uL0NvbGxlY3Rpb24uanMnO1xuaW1wb3J0IENvbGxlY3Rpb25FdmVudFR5cGUgZnJvbSAnLi4vQ29sbGVjdGlvbkV2ZW50VHlwZS5qcyc7XG5pbXBvcnQgRXZlbnQgZnJvbSAnLi4vZXZlbnRzL0V2ZW50LmpzJztcbmltcG9ydCBFdmVudFR5cGUgZnJvbSAnLi4vZXZlbnRzL0V2ZW50VHlwZS5qcyc7XG5pbXBvcnQgT2JqZWN0RXZlbnRUeXBlIGZyb20gJy4uL09iamVjdEV2ZW50VHlwZS5qcyc7XG5pbXBvcnQge2Fzc2VydH0gZnJvbSAnLi4vYXNzZXJ0cy5qcyc7XG5pbXBvcnQge2NsZWFyfSBmcm9tICcuLi9vYmouanMnO1xuaW1wb3J0IHtnZXRJbnRlcnNlY3Rpb259IGZyb20gJy4uL2V4dGVudC5qcyc7XG5pbXBvcnQge2dldFVpZH0gZnJvbSAnLi4vdXRpbC5qcyc7XG5pbXBvcnQge2xpc3RlbiwgdW5saXN0ZW5CeUtleX0gZnJvbSAnLi4vZXZlbnRzLmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7J2FkZGxheWVyJ3wncmVtb3ZlbGF5ZXInfSBFdmVudFR5cGVcbiAqL1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEEgbGF5ZXIgZ3JvdXAgdHJpZ2dlcnMgJ2FkZGxheWVyJyBhbmQgJ3JlbW92ZWxheWVyJyBldmVudHMgd2hlbiBsYXllcnMgYXJlIGFkZGVkIHRvIG9yIHJlbW92ZWQgZnJvbVxuICogdGhlIGdyb3VwIG9yIG9uZSBvZiBpdHMgY2hpbGQgZ3JvdXBzLiAgV2hlbiBhIGxheWVyIGdyb3VwIGlzIGFkZGVkIHRvIG9yIHJlbW92ZWQgZnJvbSBhbm90aGVyIGxheWVyIGdyb3VwLFxuICogYSBzaW5nbGUgZXZlbnQgd2lsbCBiZSB0cmlnZ2VyZWQgKGluc3RlYWQgb2Ygb25lIHBlciBsYXllciBpbiB0aGUgZ3JvdXAgYWRkZWQgb3IgcmVtb3ZlZCkuXG4gKi9cbmV4cG9ydCBjbGFzcyBHcm91cEV2ZW50IGV4dGVuZHMgRXZlbnQge1xuICAvKipcbiAgICogQHBhcmFtIHtFdmVudFR5cGV9IHR5cGUgVGhlIGV2ZW50IHR5cGUuXG4gICAqIEBwYXJhbSB7QmFzZUxheWVyfSBsYXllciBUaGUgbGF5ZXIuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih0eXBlLCBsYXllcikge1xuICAgIHN1cGVyKHR5cGUpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGFkZGVkIG9yIHJlbW92ZWQgbGF5ZXIuXG4gICAgICogQHR5cGUge0Jhc2VMYXllcn1cbiAgICAgKiBAYXBpXG4gICAgICovXG4gICAgdGhpcy5sYXllciA9IGxheWVyO1xuICB9XG59XG5cbi8qKipcbiAqIEB0ZW1wbGF0ZSBSZXR1cm5cbiAqIEB0eXBlZGVmIHtpbXBvcnQoXCIuLi9PYnNlcnZhYmxlXCIpLk9uU2lnbmF0dXJlPGltcG9ydChcIi4uL09ic2VydmFibGVcIikuRXZlbnRUeXBlcywgaW1wb3J0KFwiLi4vZXZlbnRzL0V2ZW50LmpzXCIpLmRlZmF1bHQsIFJldHVybj4gJlxuICogICBpbXBvcnQoXCIuLi9PYnNlcnZhYmxlXCIpLk9uU2lnbmF0dXJlPGltcG9ydChcIi4vQmFzZVwiKS5CYXNlTGF5ZXJPYmplY3RFdmVudFR5cGVzfFxuICogICAgICdjaGFuZ2U6bGF5ZXJzJywgaW1wb3J0KFwiLi4vT2JqZWN0XCIpLk9iamVjdEV2ZW50LCBSZXR1cm4+ICZcbiAqICAgaW1wb3J0KFwiLi4vT2JzZXJ2YWJsZVwiKS5Db21iaW5lZE9uU2lnbmF0dXJlPGltcG9ydChcIi4uL09ic2VydmFibGVcIikuRXZlbnRUeXBlc3xpbXBvcnQoXCIuL0Jhc2VcIikuQmFzZUxheWVyT2JqZWN0RXZlbnRUeXBlc3wnY2hhbmdlOmxheWVycycsIFJldHVybj59IEdyb3VwT25TaWduYXR1cmVcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbb3BhY2l0eT0xXSBPcGFjaXR5ICgwLCAxKS5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3Zpc2libGU9dHJ1ZV0gVmlzaWJpbGl0eS5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gW2V4dGVudF0gVGhlIGJvdW5kaW5nIGV4dGVudCBmb3IgbGF5ZXIgcmVuZGVyaW5nLiAgVGhlIGxheWVyIHdpbGwgbm90IGJlXG4gKiByZW5kZXJlZCBvdXRzaWRlIG9mIHRoaXMgZXh0ZW50LlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFt6SW5kZXhdIFRoZSB6LWluZGV4IGZvciBsYXllciByZW5kZXJpbmcuICBBdCByZW5kZXJpbmcgdGltZSwgdGhlIGxheWVyc1xuICogd2lsbCBiZSBvcmRlcmVkLCBmaXJzdCBieSBaLWluZGV4IGFuZCB0aGVuIGJ5IHBvc2l0aW9uLiBXaGVuIGB1bmRlZmluZWRgLCBhIGB6SW5kZXhgIG9mIDAgaXMgYXNzdW1lZFxuICogZm9yIGxheWVycyB0aGF0IGFyZSBhZGRlZCB0byB0aGUgbWFwJ3MgYGxheWVyc2AgY29sbGVjdGlvbiwgb3IgYEluZmluaXR5YCB3aGVuIHRoZSBsYXllcidzIGBzZXRNYXAoKWBcbiAqIG1ldGhvZCB3YXMgdXNlZC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbWluUmVzb2x1dGlvbl0gVGhlIG1pbmltdW0gcmVzb2x1dGlvbiAoaW5jbHVzaXZlKSBhdCB3aGljaCB0aGlzIGxheWVyIHdpbGwgYmVcbiAqIHZpc2libGUuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW21heFJlc29sdXRpb25dIFRoZSBtYXhpbXVtIHJlc29sdXRpb24gKGV4Y2x1c2l2ZSkgYmVsb3cgd2hpY2ggdGhpcyBsYXllciB3aWxsXG4gKiBiZSB2aXNpYmxlLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFttaW5ab29tXSBUaGUgbWluaW11bSB2aWV3IHpvb20gbGV2ZWwgKGV4Y2x1c2l2ZSkgYWJvdmUgd2hpY2ggdGhpcyBsYXllciB3aWxsIGJlXG4gKiB2aXNpYmxlLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFttYXhab29tXSBUaGUgbWF4aW11bSB2aWV3IHpvb20gbGV2ZWwgKGluY2x1c2l2ZSkgYXQgd2hpY2ggdGhpcyBsYXllciB3aWxsXG4gKiBiZSB2aXNpYmxlLlxuICogQHByb3BlcnR5IHtBcnJheTxpbXBvcnQoXCIuL0Jhc2UuanNcIikuZGVmYXVsdD58Q29sbGVjdGlvbjxpbXBvcnQoXCIuL0Jhc2UuanNcIikuZGVmYXVsdD59IFtsYXllcnNdIENoaWxkIGxheWVycy5cbiAqIEBwcm9wZXJ0eSB7T2JqZWN0PHN0cmluZywgKj59IFtwcm9wZXJ0aWVzXSBBcmJpdHJhcnkgb2JzZXJ2YWJsZSBwcm9wZXJ0aWVzLiBDYW4gYmUgYWNjZXNzZWQgd2l0aCBgI2dldCgpYCBhbmQgYCNzZXQoKWAuXG4gKi9cblxuLyoqXG4gKiBAZW51bSB7c3RyaW5nfVxuICogQHByaXZhdGVcbiAqL1xuY29uc3QgUHJvcGVydHkgPSB7XG4gIExBWUVSUzogJ2xheWVycycsXG59O1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEEge0BsaW5rIG1vZHVsZTpvbC9Db2xsZWN0aW9ufkNvbGxlY3Rpb259IG9mIGxheWVycyB0aGF0IGFyZSBoYW5kbGVkIHRvZ2V0aGVyLlxuICpcbiAqIEEgZ2VuZXJpYyBgY2hhbmdlYCBldmVudCBpcyB0cmlnZ2VyZWQgd2hlbiB0aGUgZ3JvdXAvQ29sbGVjdGlvbiBjaGFuZ2VzLlxuICpcbiAqIEBhcGlcbiAqL1xuY2xhc3MgTGF5ZXJHcm91cCBleHRlbmRzIEJhc2VMYXllciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge09wdGlvbnN9IFtvcHRpb25zXSBMYXllciBvcHRpb25zLlxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGNvbnN0IGJhc2VPcHRpb25zID0gLyoqIEB0eXBlIHtPcHRpb25zfSAqLyAoT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucykpO1xuICAgIGRlbGV0ZSBiYXNlT3B0aW9ucy5sYXllcnM7XG5cbiAgICBsZXQgbGF5ZXJzID0gb3B0aW9ucy5sYXllcnM7XG5cbiAgICBzdXBlcihiYXNlT3B0aW9ucyk7XG5cbiAgICAvKioqXG4gICAgICogQHR5cGUge0dyb3VwT25TaWduYXR1cmU8aW1wb3J0KFwiLi4vZXZlbnRzXCIpLkV2ZW50c0tleT59XG4gICAgICovXG4gICAgdGhpcy5vbjtcblxuICAgIC8qKipcbiAgICAgKiBAdHlwZSB7R3JvdXBPblNpZ25hdHVyZTxpbXBvcnQoXCIuLi9ldmVudHNcIikuRXZlbnRzS2V5Pn1cbiAgICAgKi9cbiAgICB0aGlzLm9uY2U7XG5cbiAgICAvKioqXG4gICAgICogQHR5cGUge0dyb3VwT25TaWduYXR1cmU8dm9pZD59XG4gICAgICovXG4gICAgdGhpcy51bjtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0FycmF5PGltcG9ydChcIi4uL2V2ZW50cy5qc1wiKS5FdmVudHNLZXk+fVxuICAgICAqL1xuICAgIHRoaXMubGF5ZXJzTGlzdGVuZXJLZXlzXyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgQXJyYXk8aW1wb3J0KFwiLi4vZXZlbnRzLmpzXCIpLkV2ZW50c0tleT4+fVxuICAgICAqL1xuICAgIHRoaXMubGlzdGVuZXJLZXlzXyA9IHt9O1xuXG4gICAgdGhpcy5hZGRDaGFuZ2VMaXN0ZW5lcihQcm9wZXJ0eS5MQVlFUlMsIHRoaXMuaGFuZGxlTGF5ZXJzQ2hhbmdlZF8pO1xuXG4gICAgaWYgKGxheWVycykge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkobGF5ZXJzKSkge1xuICAgICAgICBsYXllcnMgPSBuZXcgQ29sbGVjdGlvbihsYXllcnMuc2xpY2UoKSwge3VuaXF1ZTogdHJ1ZX0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXNzZXJ0KFxuICAgICAgICAgIHR5cGVvZiAoLyoqIEB0eXBlIHs/fSAqLyAobGF5ZXJzKS5nZXRBcnJheSkgPT09ICdmdW5jdGlvbicsXG4gICAgICAgICAgJ0V4cGVjdGVkIGBsYXllcnNgIHRvIGJlIGFuIGFycmF5IG9yIGEgYENvbGxlY3Rpb25gJ1xuICAgICAgICApO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsYXllcnMgPSBuZXcgQ29sbGVjdGlvbih1bmRlZmluZWQsIHt1bmlxdWU6IHRydWV9KTtcbiAgICB9XG5cbiAgICB0aGlzLnNldExheWVycyhsYXllcnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBoYW5kbGVMYXllckNoYW5nZV8oKSB7XG4gICAgdGhpcy5jaGFuZ2VkKCk7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGhhbmRsZUxheWVyc0NoYW5nZWRfKCkge1xuICAgIHRoaXMubGF5ZXJzTGlzdGVuZXJLZXlzXy5mb3JFYWNoKHVubGlzdGVuQnlLZXkpO1xuICAgIHRoaXMubGF5ZXJzTGlzdGVuZXJLZXlzXy5sZW5ndGggPSAwO1xuXG4gICAgY29uc3QgbGF5ZXJzID0gdGhpcy5nZXRMYXllcnMoKTtcbiAgICB0aGlzLmxheWVyc0xpc3RlbmVyS2V5c18ucHVzaChcbiAgICAgIGxpc3RlbihsYXllcnMsIENvbGxlY3Rpb25FdmVudFR5cGUuQURELCB0aGlzLmhhbmRsZUxheWVyc0FkZF8sIHRoaXMpLFxuICAgICAgbGlzdGVuKGxheWVycywgQ29sbGVjdGlvbkV2ZW50VHlwZS5SRU1PVkUsIHRoaXMuaGFuZGxlTGF5ZXJzUmVtb3ZlXywgdGhpcylcbiAgICApO1xuXG4gICAgZm9yIChjb25zdCBpZCBpbiB0aGlzLmxpc3RlbmVyS2V5c18pIHtcbiAgICAgIHRoaXMubGlzdGVuZXJLZXlzX1tpZF0uZm9yRWFjaCh1bmxpc3RlbkJ5S2V5KTtcbiAgICB9XG4gICAgY2xlYXIodGhpcy5saXN0ZW5lcktleXNfKTtcblxuICAgIGNvbnN0IGxheWVyc0FycmF5ID0gbGF5ZXJzLmdldEFycmF5KCk7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gbGF5ZXJzQXJyYXkubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgY29uc3QgbGF5ZXIgPSBsYXllcnNBcnJheVtpXTtcbiAgICAgIHRoaXMucmVnaXN0ZXJMYXllckxpc3RlbmVyc18obGF5ZXIpO1xuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBHcm91cEV2ZW50KCdhZGRsYXllcicsIGxheWVyKSk7XG4gICAgfVxuICAgIHRoaXMuY2hhbmdlZCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7QmFzZUxheWVyfSBsYXllciBUaGUgbGF5ZXIuXG4gICAqL1xuICByZWdpc3RlckxheWVyTGlzdGVuZXJzXyhsYXllcikge1xuICAgIGNvbnN0IGxpc3RlbmVyS2V5cyA9IFtcbiAgICAgIGxpc3RlbihcbiAgICAgICAgbGF5ZXIsXG4gICAgICAgIE9iamVjdEV2ZW50VHlwZS5QUk9QRVJUWUNIQU5HRSxcbiAgICAgICAgdGhpcy5oYW5kbGVMYXllckNoYW5nZV8sXG4gICAgICAgIHRoaXNcbiAgICAgICksXG4gICAgICBsaXN0ZW4obGF5ZXIsIEV2ZW50VHlwZS5DSEFOR0UsIHRoaXMuaGFuZGxlTGF5ZXJDaGFuZ2VfLCB0aGlzKSxcbiAgICBdO1xuXG4gICAgaWYgKGxheWVyIGluc3RhbmNlb2YgTGF5ZXJHcm91cCkge1xuICAgICAgbGlzdGVuZXJLZXlzLnB1c2goXG4gICAgICAgIGxpc3RlbihsYXllciwgJ2FkZGxheWVyJywgdGhpcy5oYW5kbGVMYXllckdyb3VwQWRkXywgdGhpcyksXG4gICAgICAgIGxpc3RlbihsYXllciwgJ3JlbW92ZWxheWVyJywgdGhpcy5oYW5kbGVMYXllckdyb3VwUmVtb3ZlXywgdGhpcylcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdGhpcy5saXN0ZW5lcktleXNfW2dldFVpZChsYXllcildID0gbGlzdGVuZXJLZXlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7R3JvdXBFdmVudH0gZXZlbnQgVGhlIGxheWVyIGdyb3VwIGV2ZW50LlxuICAgKi9cbiAgaGFuZGxlTGF5ZXJHcm91cEFkZF8oZXZlbnQpIHtcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEdyb3VwRXZlbnQoJ2FkZGxheWVyJywgZXZlbnQubGF5ZXIpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0dyb3VwRXZlbnR9IGV2ZW50IFRoZSBsYXllciBncm91cCBldmVudC5cbiAgICovXG4gIGhhbmRsZUxheWVyR3JvdXBSZW1vdmVfKGV2ZW50KSB7XG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBHcm91cEV2ZW50KCdyZW1vdmVsYXllcicsIGV2ZW50LmxheWVyKSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9Db2xsZWN0aW9uLmpzXCIpLkNvbGxlY3Rpb25FdmVudDxpbXBvcnQoXCIuL0Jhc2UuanNcIikuZGVmYXVsdD59IGNvbGxlY3Rpb25FdmVudCBDb2xsZWN0aW9uRXZlbnQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBoYW5kbGVMYXllcnNBZGRfKGNvbGxlY3Rpb25FdmVudCkge1xuICAgIGNvbnN0IGxheWVyID0gY29sbGVjdGlvbkV2ZW50LmVsZW1lbnQ7XG4gICAgdGhpcy5yZWdpc3RlckxheWVyTGlzdGVuZXJzXyhsYXllcik7XG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBHcm91cEV2ZW50KCdhZGRsYXllcicsIGxheWVyKSk7XG4gICAgdGhpcy5jaGFuZ2VkKCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9Db2xsZWN0aW9uLmpzXCIpLkNvbGxlY3Rpb25FdmVudDxpbXBvcnQoXCIuL0Jhc2UuanNcIikuZGVmYXVsdD59IGNvbGxlY3Rpb25FdmVudCBDb2xsZWN0aW9uRXZlbnQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBoYW5kbGVMYXllcnNSZW1vdmVfKGNvbGxlY3Rpb25FdmVudCkge1xuICAgIGNvbnN0IGxheWVyID0gY29sbGVjdGlvbkV2ZW50LmVsZW1lbnQ7XG4gICAgY29uc3Qga2V5ID0gZ2V0VWlkKGxheWVyKTtcbiAgICB0aGlzLmxpc3RlbmVyS2V5c19ba2V5XS5mb3JFYWNoKHVubGlzdGVuQnlLZXkpO1xuICAgIGRlbGV0ZSB0aGlzLmxpc3RlbmVyS2V5c19ba2V5XTtcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEdyb3VwRXZlbnQoJ3JlbW92ZWxheWVyJywgbGF5ZXIpKTtcbiAgICB0aGlzLmNoYW5nZWQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB7QGxpbmsgbW9kdWxlOm9sL0NvbGxlY3Rpb25+Q29sbGVjdGlvbiBjb2xsZWN0aW9ufSBvZiB7QGxpbmsgbW9kdWxlOm9sL2xheWVyL0xheWVyfkxheWVyIGxheWVyc31cbiAgICogaW4gdGhpcyBncm91cC5cbiAgICogQHJldHVybiB7IUNvbGxlY3Rpb248aW1wb3J0KFwiLi9CYXNlLmpzXCIpLmRlZmF1bHQ+fSBDb2xsZWN0aW9uIG9mXG4gICAqICAge0BsaW5rIG1vZHVsZTpvbC9sYXllci9CYXNlfkJhc2VMYXllciBsYXllcnN9IHRoYXQgYXJlIHBhcnQgb2YgdGhpcyBncm91cC5cbiAgICogQG9ic2VydmFibGVcbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0TGF5ZXJzKCkge1xuICAgIHJldHVybiAvKiogQHR5cGUgeyFDb2xsZWN0aW9uPGltcG9ydChcIi4vQmFzZS5qc1wiKS5kZWZhdWx0Pn0gKi8gKFxuICAgICAgdGhpcy5nZXQoUHJvcGVydHkuTEFZRVJTKVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSB7QGxpbmsgbW9kdWxlOm9sL0NvbGxlY3Rpb25+Q29sbGVjdGlvbiBjb2xsZWN0aW9ufSBvZiB7QGxpbmsgbW9kdWxlOm9sL2xheWVyL0xheWVyfkxheWVyIGxheWVyc31cbiAgICogaW4gdGhpcyBncm91cC5cbiAgICogQHBhcmFtIHshQ29sbGVjdGlvbjxpbXBvcnQoXCIuL0Jhc2UuanNcIikuZGVmYXVsdD59IGxheWVycyBDb2xsZWN0aW9uIG9mXG4gICAqICAge0BsaW5rIG1vZHVsZTpvbC9sYXllci9CYXNlfkJhc2VMYXllciBsYXllcnN9IHRoYXQgYXJlIHBhcnQgb2YgdGhpcyBncm91cC5cbiAgICogQG9ic2VydmFibGVcbiAgICogQGFwaVxuICAgKi9cbiAgc2V0TGF5ZXJzKGxheWVycykge1xuICAgIGNvbnN0IGNvbGxlY3Rpb24gPSB0aGlzLmdldExheWVycygpO1xuICAgIGlmIChjb2xsZWN0aW9uKSB7XG4gICAgICBjb25zdCBjdXJyZW50TGF5ZXJzID0gY29sbGVjdGlvbi5nZXRBcnJheSgpO1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gY3VycmVudExheWVycy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgR3JvdXBFdmVudCgncmVtb3ZlbGF5ZXInLCBjdXJyZW50TGF5ZXJzW2ldKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5zZXQoUHJvcGVydHkuTEFZRVJTLCBsYXllcnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7QXJyYXk8aW1wb3J0KFwiLi9MYXllci5qc1wiKS5kZWZhdWx0Pn0gW2FycmF5XSBBcnJheSBvZiBsYXllcnMgKHRvIGJlIG1vZGlmaWVkIGluIHBsYWNlKS5cbiAgICogQHJldHVybiB7QXJyYXk8aW1wb3J0KFwiLi9MYXllci5qc1wiKS5kZWZhdWx0Pn0gQXJyYXkgb2YgbGF5ZXJzLlxuICAgKi9cbiAgZ2V0TGF5ZXJzQXJyYXkoYXJyYXkpIHtcbiAgICBhcnJheSA9IGFycmF5ICE9PSB1bmRlZmluZWQgPyBhcnJheSA6IFtdO1xuICAgIHRoaXMuZ2V0TGF5ZXJzKCkuZm9yRWFjaChmdW5jdGlvbiAobGF5ZXIpIHtcbiAgICAgIGxheWVyLmdldExheWVyc0FycmF5KGFycmF5KTtcbiAgICB9KTtcbiAgICByZXR1cm4gYXJyYXk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBsYXllciBzdGF0ZXMgbGlzdCBhbmQgdXNlIHRoaXMgZ3JvdXBzIHotaW5kZXggYXMgdGhlIGRlZmF1bHRcbiAgICogZm9yIGFsbCBsYXllcnMgaW4gdGhpcyBhbmQgbmVzdGVkIGdyb3VwcywgaWYgaXQgaXMgdW5zZXQgYXQgdGhpcyBwb2ludC5cbiAgICogSWYgZGVzdCBpcyBub3QgcHJvdmlkZWQgYW5kIHRoaXMgZ3JvdXAncyB6LWluZGV4IGlzIHVuZGVmaW5lZFxuICAgKiAwIGlzIHVzZWQgYSB0aGUgZGVmYXVsdCB6LWluZGV4LlxuICAgKiBAcGFyYW0ge0FycmF5PGltcG9ydChcIi4vTGF5ZXIuanNcIikuU3RhdGU+fSBbZGVzdF0gT3B0aW9uYWwgbGlzdFxuICAgKiBvZiBsYXllciBzdGF0ZXMgKHRvIGJlIG1vZGlmaWVkIGluIHBsYWNlKS5cbiAgICogQHJldHVybiB7QXJyYXk8aW1wb3J0KFwiLi9MYXllci5qc1wiKS5TdGF0ZT59IExpc3Qgb2YgbGF5ZXIgc3RhdGVzLlxuICAgKi9cbiAgZ2V0TGF5ZXJTdGF0ZXNBcnJheShkZXN0KSB7XG4gICAgY29uc3Qgc3RhdGVzID0gZGVzdCAhPT0gdW5kZWZpbmVkID8gZGVzdCA6IFtdO1xuICAgIGNvbnN0IHBvcyA9IHN0YXRlcy5sZW5ndGg7XG5cbiAgICB0aGlzLmdldExheWVycygpLmZvckVhY2goZnVuY3Rpb24gKGxheWVyKSB7XG4gICAgICBsYXllci5nZXRMYXllclN0YXRlc0FycmF5KHN0YXRlcyk7XG4gICAgfSk7XG5cbiAgICBjb25zdCBvd25MYXllclN0YXRlID0gdGhpcy5nZXRMYXllclN0YXRlKCk7XG4gICAgbGV0IGRlZmF1bHRaSW5kZXggPSBvd25MYXllclN0YXRlLnpJbmRleDtcbiAgICBpZiAoIWRlc3QgJiYgb3duTGF5ZXJTdGF0ZS56SW5kZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgZGVmYXVsdFpJbmRleCA9IDA7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSBwb3MsIGlpID0gc3RhdGVzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgIGNvbnN0IGxheWVyU3RhdGUgPSBzdGF0ZXNbaV07XG4gICAgICBsYXllclN0YXRlLm9wYWNpdHkgKj0gb3duTGF5ZXJTdGF0ZS5vcGFjaXR5O1xuICAgICAgbGF5ZXJTdGF0ZS52aXNpYmxlID0gbGF5ZXJTdGF0ZS52aXNpYmxlICYmIG93bkxheWVyU3RhdGUudmlzaWJsZTtcbiAgICAgIGxheWVyU3RhdGUubWF4UmVzb2x1dGlvbiA9IE1hdGgubWluKFxuICAgICAgICBsYXllclN0YXRlLm1heFJlc29sdXRpb24sXG4gICAgICAgIG93bkxheWVyU3RhdGUubWF4UmVzb2x1dGlvblxuICAgICAgKTtcbiAgICAgIGxheWVyU3RhdGUubWluUmVzb2x1dGlvbiA9IE1hdGgubWF4KFxuICAgICAgICBsYXllclN0YXRlLm1pblJlc29sdXRpb24sXG4gICAgICAgIG93bkxheWVyU3RhdGUubWluUmVzb2x1dGlvblxuICAgICAgKTtcbiAgICAgIGxheWVyU3RhdGUubWluWm9vbSA9IE1hdGgubWF4KGxheWVyU3RhdGUubWluWm9vbSwgb3duTGF5ZXJTdGF0ZS5taW5ab29tKTtcbiAgICAgIGxheWVyU3RhdGUubWF4Wm9vbSA9IE1hdGgubWluKGxheWVyU3RhdGUubWF4Wm9vbSwgb3duTGF5ZXJTdGF0ZS5tYXhab29tKTtcbiAgICAgIGlmIChvd25MYXllclN0YXRlLmV4dGVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChsYXllclN0YXRlLmV4dGVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgbGF5ZXJTdGF0ZS5leHRlbnQgPSBnZXRJbnRlcnNlY3Rpb24oXG4gICAgICAgICAgICBsYXllclN0YXRlLmV4dGVudCxcbiAgICAgICAgICAgIG93bkxheWVyU3RhdGUuZXh0ZW50XG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsYXllclN0YXRlLmV4dGVudCA9IG93bkxheWVyU3RhdGUuZXh0ZW50O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobGF5ZXJTdGF0ZS56SW5kZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBsYXllclN0YXRlLnpJbmRleCA9IGRlZmF1bHRaSW5kZXg7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0YXRlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9zb3VyY2UvU291cmNlLmpzXCIpLlN0YXRlfSBTb3VyY2Ugc3RhdGUuXG4gICAqL1xuICBnZXRTb3VyY2VTdGF0ZSgpIHtcbiAgICByZXR1cm4gJ3JlYWR5JztcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBMYXllckdyb3VwO1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2xheWVyL0xheWVyXG4gKi9cbmltcG9ydCBCYXNlTGF5ZXIgZnJvbSAnLi9CYXNlLmpzJztcbmltcG9ydCBFdmVudFR5cGUgZnJvbSAnLi4vZXZlbnRzL0V2ZW50VHlwZS5qcyc7XG5pbXBvcnQgTGF5ZXJQcm9wZXJ0eSBmcm9tICcuL1Byb3BlcnR5LmpzJztcbmltcG9ydCBSZW5kZXJFdmVudFR5cGUgZnJvbSAnLi4vcmVuZGVyL0V2ZW50VHlwZS5qcyc7XG5pbXBvcnQgVmlldyBmcm9tICcuLi9WaWV3LmpzJztcbmltcG9ydCB7YXNzZXJ0fSBmcm9tICcuLi9hc3NlcnRzLmpzJztcbmltcG9ydCB7aW50ZXJzZWN0c30gZnJvbSAnLi4vZXh0ZW50LmpzJztcbmltcG9ydCB7bGlzdGVuLCB1bmxpc3RlbkJ5S2V5fSBmcm9tICcuLi9ldmVudHMuanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtmdW5jdGlvbihpbXBvcnQoXCIuLi9NYXAuanNcIikuRnJhbWVTdGF0ZSk6SFRNTEVsZW1lbnR9IFJlbmRlckZ1bmN0aW9uXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7J3NvdXJjZXJlYWR5J3wnY2hhbmdlOnNvdXJjZSd9IExheWVyRXZlbnRUeXBlXG4gKi9cblxuLyoqKlxuICogQHRlbXBsYXRlIFJldHVyblxuICogQHR5cGVkZWYge2ltcG9ydChcIi4uL09ic2VydmFibGVcIikuT25TaWduYXR1cmU8aW1wb3J0KFwiLi4vT2JzZXJ2YWJsZVwiKS5FdmVudFR5cGVzLCBpbXBvcnQoXCIuLi9ldmVudHMvRXZlbnQuanNcIikuZGVmYXVsdCwgUmV0dXJuPiAmXG4gKiAgIGltcG9ydChcIi4uL09ic2VydmFibGVcIikuT25TaWduYXR1cmU8aW1wb3J0KFwiLi9CYXNlXCIpLkJhc2VMYXllck9iamVjdEV2ZW50VHlwZXN8XG4gKiAgICAgTGF5ZXJFdmVudFR5cGUsIGltcG9ydChcIi4uL09iamVjdFwiKS5PYmplY3RFdmVudCwgUmV0dXJuPiAmXG4gKiAgIGltcG9ydChcIi4uL09ic2VydmFibGVcIikuT25TaWduYXR1cmU8aW1wb3J0KFwiLi4vcmVuZGVyL0V2ZW50VHlwZVwiKS5MYXllclJlbmRlckV2ZW50VHlwZXMsIGltcG9ydChcIi4uL3JlbmRlci9FdmVudFwiKS5kZWZhdWx0LCBSZXR1cm4+ICZcbiAqICAgaW1wb3J0KFwiLi4vT2JzZXJ2YWJsZVwiKS5Db21iaW5lZE9uU2lnbmF0dXJlPGltcG9ydChcIi4uL09ic2VydmFibGVcIikuRXZlbnRUeXBlc3xpbXBvcnQoXCIuL0Jhc2VcIikuQmFzZUxheWVyT2JqZWN0RXZlbnRUeXBlc3xMYXllckV2ZW50VHlwZXxcbiAqICAgICBpbXBvcnQoXCIuLi9yZW5kZXIvRXZlbnRUeXBlXCIpLkxheWVyUmVuZGVyRXZlbnRUeXBlcywgUmV0dXJuPn0gTGF5ZXJPblNpZ25hdHVyZVxuICovXG5cbi8qKlxuICogQHRlbXBsYXRlIHtpbXBvcnQoXCIuLi9zb3VyY2UvU291cmNlLmpzXCIpLmRlZmF1bHR9IFtTb3VyY2VUeXBlPWltcG9ydChcIi4uL3NvdXJjZS9Tb3VyY2UuanNcIikuZGVmYXVsdF1cbiAqIEB0eXBlZGVmIHtPYmplY3R9IE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbY2xhc3NOYW1lPSdvbC1sYXllciddIEEgQ1NTIGNsYXNzIG5hbWUgdG8gc2V0IHRvIHRoZSBsYXllciBlbGVtZW50LlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtvcGFjaXR5PTFdIE9wYWNpdHkgKDAsIDEpLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbdmlzaWJsZT10cnVlXSBWaXNpYmlsaXR5LlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fSBbZXh0ZW50XSBUaGUgYm91bmRpbmcgZXh0ZW50IGZvciBsYXllciByZW5kZXJpbmcuICBUaGUgbGF5ZXIgd2lsbCBub3QgYmVcbiAqIHJlbmRlcmVkIG91dHNpZGUgb2YgdGhpcyBleHRlbnQuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3pJbmRleF0gVGhlIHotaW5kZXggZm9yIGxheWVyIHJlbmRlcmluZy4gIEF0IHJlbmRlcmluZyB0aW1lLCB0aGUgbGF5ZXJzXG4gKiB3aWxsIGJlIG9yZGVyZWQsIGZpcnN0IGJ5IFotaW5kZXggYW5kIHRoZW4gYnkgcG9zaXRpb24uIFdoZW4gYHVuZGVmaW5lZGAsIGEgYHpJbmRleGAgb2YgMCBpcyBhc3N1bWVkXG4gKiBmb3IgbGF5ZXJzIHRoYXQgYXJlIGFkZGVkIHRvIHRoZSBtYXAncyBgbGF5ZXJzYCBjb2xsZWN0aW9uLCBvciBgSW5maW5pdHlgIHdoZW4gdGhlIGxheWVyJ3MgYHNldE1hcCgpYFxuICogbWV0aG9kIHdhcyB1c2VkLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFttaW5SZXNvbHV0aW9uXSBUaGUgbWluaW11bSByZXNvbHV0aW9uIChpbmNsdXNpdmUpIGF0IHdoaWNoIHRoaXMgbGF5ZXIgd2lsbCBiZVxuICogdmlzaWJsZS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbWF4UmVzb2x1dGlvbl0gVGhlIG1heGltdW0gcmVzb2x1dGlvbiAoZXhjbHVzaXZlKSBiZWxvdyB3aGljaCB0aGlzIGxheWVyIHdpbGxcbiAqIGJlIHZpc2libGUuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW21pblpvb21dIFRoZSBtaW5pbXVtIHZpZXcgem9vbSBsZXZlbCAoZXhjbHVzaXZlKSBhYm92ZSB3aGljaCB0aGlzIGxheWVyIHdpbGwgYmVcbiAqIHZpc2libGUuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW21heFpvb21dIFRoZSBtYXhpbXVtIHZpZXcgem9vbSBsZXZlbCAoaW5jbHVzaXZlKSBhdCB3aGljaCB0aGlzIGxheWVyIHdpbGxcbiAqIGJlIHZpc2libGUuXG4gKiBAcHJvcGVydHkge1NvdXJjZVR5cGV9IFtzb3VyY2VdIFNvdXJjZSBmb3IgdGhpcyBsYXllci4gIElmIG5vdCBwcm92aWRlZCB0byB0aGUgY29uc3RydWN0b3IsXG4gKiB0aGUgc291cmNlIGNhbiBiZSBzZXQgYnkgY2FsbGluZyB7QGxpbmsgbW9kdWxlOm9sL2xheWVyL0xheWVyfkxheWVyI3NldFNvdXJjZSBsYXllci5zZXRTb3VyY2Uoc291cmNlKX0gYWZ0ZXJcbiAqIGNvbnN0cnVjdGlvbi5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vTWFwLmpzXCIpLmRlZmF1bHR8bnVsbH0gW21hcF0gTWFwLlxuICogQHByb3BlcnR5IHtSZW5kZXJGdW5jdGlvbn0gW3JlbmRlcl0gUmVuZGVyIGZ1bmN0aW9uLiBUYWtlcyB0aGUgZnJhbWUgc3RhdGUgYXMgaW5wdXQgYW5kIGlzIGV4cGVjdGVkIHRvIHJldHVybiBhblxuICogSFRNTCBlbGVtZW50LiBXaWxsIG92ZXJ3cml0ZSB0aGUgZGVmYXVsdCByZW5kZXJpbmcgZm9yIHRoZSBsYXllci5cbiAqIEBwcm9wZXJ0eSB7T2JqZWN0PHN0cmluZywgKj59IFtwcm9wZXJ0aWVzXSBBcmJpdHJhcnkgb2JzZXJ2YWJsZSBwcm9wZXJ0aWVzLiBDYW4gYmUgYWNjZXNzZWQgd2l0aCBgI2dldCgpYCBhbmQgYCNzZXQoKWAuXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBTdGF0ZVxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL0xheWVyLmpzXCIpLmRlZmF1bHR9IGxheWVyIExheWVyLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IG9wYWNpdHkgT3BhY2l0eSwgdGhlIHZhbHVlIGlzIHJvdW5kZWQgdG8gdHdvIGRpZ2l0cyB0byBhcHBlYXIgYWZ0ZXIgdGhlIGRlY2ltYWwgcG9pbnQuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IHZpc2libGUgVmlzaWJsZS5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gbWFuYWdlZCBNYW5hZ2VkLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fSBbZXh0ZW50XSBFeHRlbnQuXG4gKiBAcHJvcGVydHkge251bWJlciB8IHVuZGVmaW5lZH0gekluZGV4IFpJbmRleC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtYXhSZXNvbHV0aW9uIE1heGltdW0gcmVzb2x1dGlvbi5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtaW5SZXNvbHV0aW9uIE1pbmltdW0gcmVzb2x1dGlvbi5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtaW5ab29tIE1pbmltdW0gem9vbS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtYXhab29tIE1heGltdW0gem9vbS5cbiAqL1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEJhc2UgY2xhc3MgZnJvbSB3aGljaCBhbGwgbGF5ZXIgdHlwZXMgYXJlIGRlcml2ZWQuIFRoaXMgc2hvdWxkIG9ubHkgYmUgaW5zdGFudGlhdGVkXG4gKiBpbiB0aGUgY2FzZSB3aGVyZSBhIGN1c3RvbSBsYXllciBpcyBhZGRlZCB0byB0aGUgbWFwIHdpdGggYSBjdXN0b20gYHJlbmRlcmAgZnVuY3Rpb24uXG4gKiBTdWNoIGEgZnVuY3Rpb24gY2FuIGJlIHNwZWNpZmllZCBpbiB0aGUgYG9wdGlvbnNgIG9iamVjdCwgYW5kIGlzIGV4cGVjdGVkIHRvIHJldHVybiBhbiBIVE1MIGVsZW1lbnQuXG4gKlxuICogQSB2aXN1YWwgcmVwcmVzZW50YXRpb24gb2YgcmFzdGVyIG9yIHZlY3RvciBtYXAgZGF0YS5cbiAqIExheWVycyBncm91cCB0b2dldGhlciB0aG9zZSBwcm9wZXJ0aWVzIHRoYXQgcGVydGFpbiB0byBob3cgdGhlIGRhdGEgaXMgdG8gYmVcbiAqIGRpc3BsYXllZCwgaXJyZXNwZWN0aXZlIG9mIHRoZSBzb3VyY2Ugb2YgdGhhdCBkYXRhLlxuICpcbiAqIExheWVycyBhcmUgdXN1YWxseSBhZGRlZCB0byBhIG1hcCB3aXRoIFttYXAuYWRkTGF5ZXIoKV17QGxpbmsgaW1wb3J0KFwiLi4vTWFwLmpzXCIpLmRlZmF1bHQjYWRkTGF5ZXJ9LlxuICogQ29tcG9uZW50cyBsaWtlIHtAbGluayBtb2R1bGU6b2wvaW50ZXJhY3Rpb24vRHJhd35EcmF3fSB1c2UgdW5tYW5hZ2VkIGxheWVyc1xuICogaW50ZXJuYWxseS4gVGhlc2UgdW5tYW5hZ2VkIGxheWVycyBhcmUgYXNzb2NpYXRlZCB3aXRoIHRoZSBtYXAgdXNpbmdcbiAqIFtsYXllci5zZXRNYXAoKV17QGxpbmsgbW9kdWxlOm9sL2xheWVyL0xheWVyfkxheWVyI3NldE1hcH0gaW5zdGVhZC5cbiAqXG4gKiBBIGdlbmVyaWMgYGNoYW5nZWAgZXZlbnQgaXMgZmlyZWQgd2hlbiB0aGUgc3RhdGUgb2YgdGhlIHNvdXJjZSBjaGFuZ2VzLlxuICogQSBgc291cmNlcmVhZHlgIGV2ZW50IGlzIGZpcmVkIHdoZW4gdGhlIGxheWVyJ3Mgc291cmNlIGlzIHJlYWR5LlxuICpcbiAqIEBmaXJlcyBpbXBvcnQoXCIuLi9yZW5kZXIvRXZlbnQuanNcIikuUmVuZGVyRXZlbnQjcHJlcmVuZGVyXG4gKiBAZmlyZXMgaW1wb3J0KFwiLi4vcmVuZGVyL0V2ZW50LmpzXCIpLlJlbmRlckV2ZW50I3Bvc3RyZW5kZXJcbiAqIEBmaXJlcyBpbXBvcnQoXCIuLi9ldmVudHMvRXZlbnQuanNcIikuQmFzZUV2ZW50I3NvdXJjZXJlYWR5XG4gKlxuICogQHRlbXBsYXRlIHtpbXBvcnQoXCIuLi9zb3VyY2UvU291cmNlLmpzXCIpLmRlZmF1bHR9IFtTb3VyY2VUeXBlPWltcG9ydChcIi4uL3NvdXJjZS9Tb3VyY2UuanNcIikuZGVmYXVsdF1cbiAqIEB0ZW1wbGF0ZSB7aW1wb3J0KFwiLi4vcmVuZGVyZXIvTGF5ZXIuanNcIikuZGVmYXVsdH0gW1JlbmRlcmVyVHlwZT1pbXBvcnQoXCIuLi9yZW5kZXJlci9MYXllci5qc1wiKS5kZWZhdWx0XVxuICogQGFwaVxuICovXG5jbGFzcyBMYXllciBleHRlbmRzIEJhc2VMYXllciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge09wdGlvbnM8U291cmNlVHlwZT59IG9wdGlvbnMgTGF5ZXIgb3B0aW9ucy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBjb25zdCBiYXNlT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpO1xuICAgIGRlbGV0ZSBiYXNlT3B0aW9ucy5zb3VyY2U7XG5cbiAgICBzdXBlcihiYXNlT3B0aW9ucyk7XG5cbiAgICAvKioqXG4gICAgICogQHR5cGUge0xheWVyT25TaWduYXR1cmU8aW1wb3J0KFwiLi4vZXZlbnRzXCIpLkV2ZW50c0tleT59XG4gICAgICovXG4gICAgdGhpcy5vbjtcblxuICAgIC8qKipcbiAgICAgKiBAdHlwZSB7TGF5ZXJPblNpZ25hdHVyZTxpbXBvcnQoXCIuLi9ldmVudHNcIikuRXZlbnRzS2V5Pn1cbiAgICAgKi9cbiAgICB0aGlzLm9uY2U7XG5cbiAgICAvKioqXG4gICAgICogQHR5cGUge0xheWVyT25TaWduYXR1cmU8dm9pZD59XG4gICAgICovXG4gICAgdGhpcy51bjtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgez9pbXBvcnQoXCIuLi9ldmVudHMuanNcIikuRXZlbnRzS2V5fVxuICAgICAqL1xuICAgIHRoaXMubWFwUHJlY29tcG9zZUtleV8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7P2ltcG9ydChcIi4uL2V2ZW50cy5qc1wiKS5FdmVudHNLZXl9XG4gICAgICovXG4gICAgdGhpcy5tYXBSZW5kZXJLZXlfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgez9pbXBvcnQoXCIuLi9ldmVudHMuanNcIikuRXZlbnRzS2V5fVxuICAgICAqL1xuICAgIHRoaXMuc291cmNlQ2hhbmdlS2V5XyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtSZW5kZXJlclR5cGV9XG4gICAgICovXG4gICAgdGhpcy5yZW5kZXJlcl8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLnNvdXJjZVJlYWR5XyA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMucmVuZGVyZWQgPSBmYWxzZTtcblxuICAgIC8vIE92ZXJ3cml0ZSBkZWZhdWx0IHJlbmRlciBtZXRob2Qgd2l0aCBhIGN1c3RvbSBvbmVcbiAgICBpZiAob3B0aW9ucy5yZW5kZXIpIHtcbiAgICAgIHRoaXMucmVuZGVyID0gb3B0aW9ucy5yZW5kZXI7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMubWFwKSB7XG4gICAgICB0aGlzLnNldE1hcChvcHRpb25zLm1hcCk7XG4gICAgfVxuXG4gICAgdGhpcy5hZGRDaGFuZ2VMaXN0ZW5lcihcbiAgICAgIExheWVyUHJvcGVydHkuU09VUkNFLFxuICAgICAgdGhpcy5oYW5kbGVTb3VyY2VQcm9wZXJ0eUNoYW5nZV9cbiAgICApO1xuXG4gICAgY29uc3Qgc291cmNlID0gb3B0aW9ucy5zb3VyY2VcbiAgICAgID8gLyoqIEB0eXBlIHtTb3VyY2VUeXBlfSAqLyAob3B0aW9ucy5zb3VyY2UpXG4gICAgICA6IG51bGw7XG4gICAgdGhpcy5zZXRTb3VyY2Uoc291cmNlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0FycmF5PGltcG9ydChcIi4vTGF5ZXIuanNcIikuZGVmYXVsdD59IFthcnJheV0gQXJyYXkgb2YgbGF5ZXJzICh0byBiZSBtb2RpZmllZCBpbiBwbGFjZSkuXG4gICAqIEByZXR1cm4ge0FycmF5PGltcG9ydChcIi4vTGF5ZXIuanNcIikuZGVmYXVsdD59IEFycmF5IG9mIGxheWVycy5cbiAgICovXG4gIGdldExheWVyc0FycmF5KGFycmF5KSB7XG4gICAgYXJyYXkgPSBhcnJheSA/IGFycmF5IDogW107XG4gICAgYXJyYXkucHVzaCh0aGlzKTtcbiAgICByZXR1cm4gYXJyYXk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtBcnJheTxpbXBvcnQoXCIuL0xheWVyLmpzXCIpLlN0YXRlPn0gW3N0YXRlc10gT3B0aW9uYWwgbGlzdCBvZiBsYXllciBzdGF0ZXMgKHRvIGJlIG1vZGlmaWVkIGluIHBsYWNlKS5cbiAgICogQHJldHVybiB7QXJyYXk8aW1wb3J0KFwiLi9MYXllci5qc1wiKS5TdGF0ZT59IExpc3Qgb2YgbGF5ZXIgc3RhdGVzLlxuICAgKi9cbiAgZ2V0TGF5ZXJTdGF0ZXNBcnJheShzdGF0ZXMpIHtcbiAgICBzdGF0ZXMgPSBzdGF0ZXMgPyBzdGF0ZXMgOiBbXTtcbiAgICBzdGF0ZXMucHVzaCh0aGlzLmdldExheWVyU3RhdGUoKSk7XG4gICAgcmV0dXJuIHN0YXRlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGxheWVyIHNvdXJjZS5cbiAgICogQHJldHVybiB7U291cmNlVHlwZXxudWxsfSBUaGUgbGF5ZXIgc291cmNlIChvciBgbnVsbGAgaWYgbm90IHlldCBzZXQpLlxuICAgKiBAb2JzZXJ2YWJsZVxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRTb3VyY2UoKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7U291cmNlVHlwZX0gKi8gKHRoaXMuZ2V0KExheWVyUHJvcGVydHkuU09VUkNFKSkgfHwgbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtTb3VyY2VUeXBlfG51bGx9IFRoZSBzb3VyY2UgYmVpbmcgcmVuZGVyZWQuXG4gICAqL1xuICBnZXRSZW5kZXJTb3VyY2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0U291cmNlKCk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vc291cmNlL1NvdXJjZS5qc1wiKS5TdGF0ZX0gU291cmNlIHN0YXRlLlxuICAgKi9cbiAgZ2V0U291cmNlU3RhdGUoKSB7XG4gICAgY29uc3Qgc291cmNlID0gdGhpcy5nZXRTb3VyY2UoKTtcbiAgICByZXR1cm4gIXNvdXJjZSA/ICd1bmRlZmluZWQnIDogc291cmNlLmdldFN0YXRlKCk7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGhhbmRsZVNvdXJjZUNoYW5nZV8oKSB7XG4gICAgdGhpcy5jaGFuZ2VkKCk7XG4gICAgaWYgKHRoaXMuc291cmNlUmVhZHlfIHx8IHRoaXMuZ2V0U291cmNlKCkuZ2V0U3RhdGUoKSAhPT0gJ3JlYWR5Jykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnNvdXJjZVJlYWR5XyA9IHRydWU7XG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KCdzb3VyY2VyZWFkeScpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBoYW5kbGVTb3VyY2VQcm9wZXJ0eUNoYW5nZV8oKSB7XG4gICAgaWYgKHRoaXMuc291cmNlQ2hhbmdlS2V5Xykge1xuICAgICAgdW5saXN0ZW5CeUtleSh0aGlzLnNvdXJjZUNoYW5nZUtleV8pO1xuICAgICAgdGhpcy5zb3VyY2VDaGFuZ2VLZXlfID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5zb3VyY2VSZWFkeV8gPSBmYWxzZTtcbiAgICBjb25zdCBzb3VyY2UgPSB0aGlzLmdldFNvdXJjZSgpO1xuICAgIGlmIChzb3VyY2UpIHtcbiAgICAgIHRoaXMuc291cmNlQ2hhbmdlS2V5XyA9IGxpc3RlbihcbiAgICAgICAgc291cmNlLFxuICAgICAgICBFdmVudFR5cGUuQ0hBTkdFLFxuICAgICAgICB0aGlzLmhhbmRsZVNvdXJjZUNoYW5nZV8sXG4gICAgICAgIHRoaXNcbiAgICAgICk7XG4gICAgICBpZiAoc291cmNlLmdldFN0YXRlKCkgPT09ICdyZWFkeScpIHtcbiAgICAgICAgdGhpcy5zb3VyY2VSZWFkeV8gPSB0cnVlO1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoJ3NvdXJjZXJlYWR5Jyk7XG4gICAgICAgIH0sIDApO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmNoYW5nZWQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3BpeGVsXCIpLlBpeGVsfSBwaXhlbCBQaXhlbC5cbiAgICogQHJldHVybiB7UHJvbWlzZTxBcnJheTxpbXBvcnQoXCIuLi9GZWF0dXJlXCIpLkZlYXR1cmVMaWtlPj59IFByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoXG4gICAqIGFuIGFycmF5IG9mIGZlYXR1cmVzLlxuICAgKi9cbiAgZ2V0RmVhdHVyZXMocGl4ZWwpIHtcbiAgICBpZiAoIXRoaXMucmVuZGVyZXJfKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKFtdKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucmVuZGVyZXJfLmdldEZlYXR1cmVzKHBpeGVsKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3BpeGVsXCIpLlBpeGVsfSBwaXhlbCBQaXhlbC5cbiAgICogQHJldHVybiB7VWludDhDbGFtcGVkQXJyYXl8VWludDhBcnJheXxGbG9hdDMyQXJyYXl8RGF0YVZpZXd8bnVsbH0gUGl4ZWwgZGF0YS5cbiAgICovXG4gIGdldERhdGEocGl4ZWwpIHtcbiAgICBpZiAoIXRoaXMucmVuZGVyZXJfIHx8ICF0aGlzLnJlbmRlcmVkKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucmVuZGVyZXJfLmdldERhdGEocGl4ZWwpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBsYXllciBpcyB2aXNpYmxlIG9uIHRoZSBtYXAgdmlldywgaS5lLiB3aXRoaW4gaXRzIG1pbi9tYXggcmVzb2x1dGlvbiBvciB6b29tIGFuZFxuICAgKiBleHRlbnQsIG5vdCBzZXQgdG8gYHZpc2libGU6IGZhbHNlYCwgYW5kIG5vdCBpbnNpZGUgYSBsYXllciBncm91cCB0aGF0IGlzIHNldFxuICAgKiB0byBgdmlzaWJsZTogZmFsc2VgLlxuICAgKiBAcGFyYW0ge1ZpZXd8aW1wb3J0KFwiLi4vVmlldy5qc1wiKS5WaWV3U3RhdGVMYXllclN0YXRlRXh0ZW50fSBbdmlld10gVmlldyBvciB7QGxpbmsgaW1wb3J0KFwiLi4vTWFwLmpzXCIpLkZyYW1lU3RhdGV9LlxuICAgKiBPbmx5IHJlcXVpcmVkIHdoZW4gdGhlIGxheWVyIGlzIG5vdCBhZGRlZCB0byBhIG1hcC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVGhlIGxheWVyIGlzIHZpc2libGUgaW4gdGhlIG1hcCB2aWV3LlxuICAgKiBAYXBpXG4gICAqL1xuICBpc1Zpc2libGUodmlldykge1xuICAgIGxldCBmcmFtZVN0YXRlO1xuICAgIGNvbnN0IG1hcCA9IHRoaXMuZ2V0TWFwSW50ZXJuYWwoKTtcbiAgICBpZiAoIXZpZXcgJiYgbWFwKSB7XG4gICAgICB2aWV3ID0gbWFwLmdldFZpZXcoKTtcbiAgICB9XG4gICAgaWYgKHZpZXcgaW5zdGFuY2VvZiBWaWV3KSB7XG4gICAgICBmcmFtZVN0YXRlID0ge1xuICAgICAgICB2aWV3U3RhdGU6IHZpZXcuZ2V0U3RhdGUoKSxcbiAgICAgICAgZXh0ZW50OiB2aWV3LmNhbGN1bGF0ZUV4dGVudCgpLFxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgZnJhbWVTdGF0ZSA9IHZpZXc7XG4gICAgfVxuICAgIGlmICghZnJhbWVTdGF0ZS5sYXllclN0YXRlc0FycmF5ICYmIG1hcCkge1xuICAgICAgZnJhbWVTdGF0ZS5sYXllclN0YXRlc0FycmF5ID0gbWFwLmdldExheWVyR3JvdXAoKS5nZXRMYXllclN0YXRlc0FycmF5KCk7XG4gICAgfVxuICAgIGxldCBsYXllclN0YXRlO1xuICAgIGlmIChmcmFtZVN0YXRlLmxheWVyU3RhdGVzQXJyYXkpIHtcbiAgICAgIGxheWVyU3RhdGUgPSBmcmFtZVN0YXRlLmxheWVyU3RhdGVzQXJyYXkuZmluZChcbiAgICAgICAgKGxheWVyU3RhdGUpID0+IGxheWVyU3RhdGUubGF5ZXIgPT09IHRoaXNcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxheWVyU3RhdGUgPSB0aGlzLmdldExheWVyU3RhdGUoKTtcbiAgICB9XG5cbiAgICBjb25zdCBsYXllckV4dGVudCA9IHRoaXMuZ2V0RXh0ZW50KCk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgaW5WaWV3KGxheWVyU3RhdGUsIGZyYW1lU3RhdGUudmlld1N0YXRlKSAmJlxuICAgICAgKCFsYXllckV4dGVudCB8fCBpbnRlcnNlY3RzKGxheWVyRXh0ZW50LCBmcmFtZVN0YXRlLmV4dGVudCkpXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGF0dHJpYnV0aW9ucyBvZiB0aGUgc291cmNlIG9mIHRoaXMgbGF5ZXIgZm9yIHRoZSBnaXZlbiB2aWV3LlxuICAgKiBAcGFyYW0ge1ZpZXd8aW1wb3J0KFwiLi4vVmlldy5qc1wiKS5WaWV3U3RhdGVMYXllclN0YXRlRXh0ZW50fSBbdmlld10gVmlldyBvciB7QGxpbmsgaW1wb3J0KFwiLi4vTWFwLmpzXCIpLkZyYW1lU3RhdGV9LlxuICAgKiBPbmx5IHJlcXVpcmVkIHdoZW4gdGhlIGxheWVyIGlzIG5vdCBhZGRlZCB0byBhIG1hcC5cbiAgICogQHJldHVybiB7QXJyYXk8c3RyaW5nPn0gQXR0cmlidXRpb25zIGZvciB0aGlzIGxheWVyIGF0IHRoZSBnaXZlbiB2aWV3LlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRBdHRyaWJ1dGlvbnModmlldykge1xuICAgIGlmICghdGhpcy5pc1Zpc2libGUodmlldykpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgbGV0IGdldEF0dHJpYnV0aW9ucztcbiAgICBjb25zdCBzb3VyY2UgPSB0aGlzLmdldFNvdXJjZSgpO1xuICAgIGlmIChzb3VyY2UpIHtcbiAgICAgIGdldEF0dHJpYnV0aW9ucyA9IHNvdXJjZS5nZXRBdHRyaWJ1dGlvbnMoKTtcbiAgICB9XG4gICAgaWYgKCFnZXRBdHRyaWJ1dGlvbnMpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgY29uc3QgZnJhbWVTdGF0ZSA9XG4gICAgICB2aWV3IGluc3RhbmNlb2YgVmlldyA/IHZpZXcuZ2V0Vmlld1N0YXRlQW5kRXh0ZW50KCkgOiB2aWV3O1xuICAgIGxldCBhdHRyaWJ1dGlvbnMgPSBnZXRBdHRyaWJ1dGlvbnMoZnJhbWVTdGF0ZSk7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGF0dHJpYnV0aW9ucykpIHtcbiAgICAgIGF0dHJpYnV0aW9ucyA9IFthdHRyaWJ1dGlvbnNdO1xuICAgIH1cbiAgICByZXR1cm4gYXR0cmlidXRpb25zO1xuICB9XG5cbiAgLyoqXG4gICAqIEluIGNoYXJnZSB0byBtYW5hZ2UgdGhlIHJlbmRlcmluZyBvZiB0aGUgbGF5ZXIuIE9uZSBsYXllciB0eXBlIGlzXG4gICAqIGJvdW5kZWQgd2l0aCBvbmUgbGF5ZXIgcmVuZGVyZXIuXG4gICAqIEBwYXJhbSB7P2ltcG9ydChcIi4uL01hcC5qc1wiKS5GcmFtZVN0YXRlfSBmcmFtZVN0YXRlIEZyYW1lIHN0YXRlLlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSB0YXJnZXQgVGFyZ2V0IHdoaWNoIHRoZSByZW5kZXJlciBtYXkgKGJ1dCBuZWVkIG5vdCkgdXNlXG4gICAqIGZvciByZW5kZXJpbmcgaXRzIGNvbnRlbnQuXG4gICAqIEByZXR1cm4ge0hUTUxFbGVtZW50fG51bGx9IFRoZSByZW5kZXJlZCBlbGVtZW50LlxuICAgKi9cbiAgcmVuZGVyKGZyYW1lU3RhdGUsIHRhcmdldCkge1xuICAgIGNvbnN0IGxheWVyUmVuZGVyZXIgPSB0aGlzLmdldFJlbmRlcmVyKCk7XG5cbiAgICBpZiAobGF5ZXJSZW5kZXJlci5wcmVwYXJlRnJhbWUoZnJhbWVTdGF0ZSkpIHtcbiAgICAgIHRoaXMucmVuZGVyZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuIGxheWVyUmVuZGVyZXIucmVuZGVyRnJhbWUoZnJhbWVTdGF0ZSwgdGFyZ2V0KTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gYSBsYXllciBpcyBub3QgdmlzaWJsZSBkdXJpbmcgYSBtYXAgcmVuZGVyLlxuICAgKi9cbiAgdW5yZW5kZXIoKSB7XG4gICAgdGhpcy5yZW5kZXJlZCA9IGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEZvciB1c2UgaW5zaWRlIHRoZSBsaWJyYXJ5IG9ubHkuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwLmpzXCIpLmRlZmF1bHR8bnVsbH0gbWFwIE1hcC5cbiAgICovXG4gIHNldE1hcEludGVybmFsKG1hcCkge1xuICAgIGlmICghbWFwKSB7XG4gICAgICB0aGlzLnVucmVuZGVyKCk7XG4gICAgfVxuICAgIHRoaXMuc2V0KExheWVyUHJvcGVydHkuTUFQLCBtYXApO1xuICB9XG5cbiAgLyoqXG4gICAqIEZvciB1c2UgaW5zaWRlIHRoZSBsaWJyYXJ5IG9ubHkuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL01hcC5qc1wiKS5kZWZhdWx0fG51bGx9IE1hcC5cbiAgICovXG4gIGdldE1hcEludGVybmFsKCkge1xuICAgIHJldHVybiB0aGlzLmdldChMYXllclByb3BlcnR5Lk1BUCk7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgbGF5ZXIgdG8gYmUgcmVuZGVyZWQgb24gdG9wIG9mIG90aGVyIGxheWVycyBvbiBhIG1hcC4gVGhlIG1hcCB3aWxsXG4gICAqIG5vdCBtYW5hZ2UgdGhpcyBsYXllciBpbiBpdHMgbGF5ZXJzIGNvbGxlY3Rpb24uIFRoaXNcbiAgICogaXMgdXNlZnVsIGZvciB0ZW1wb3JhcnkgbGF5ZXJzLiBUbyByZW1vdmUgYW4gdW5tYW5hZ2VkIGxheWVyIGZyb20gdGhlIG1hcCxcbiAgICogdXNlIGAjc2V0TWFwKG51bGwpYC5cbiAgICpcbiAgICogVG8gYWRkIHRoZSBsYXllciB0byBhIG1hcCBhbmQgaGF2ZSBpdCBtYW5hZ2VkIGJ5IHRoZSBtYXAsIHVzZVxuICAgKiB7QGxpbmsgbW9kdWxlOm9sL01hcH5NYXAjYWRkTGF5ZXJ9IGluc3RlYWQuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwLmpzXCIpLmRlZmF1bHR8bnVsbH0gbWFwIE1hcC5cbiAgICogQGFwaVxuICAgKi9cbiAgc2V0TWFwKG1hcCkge1xuICAgIGlmICh0aGlzLm1hcFByZWNvbXBvc2VLZXlfKSB7XG4gICAgICB1bmxpc3RlbkJ5S2V5KHRoaXMubWFwUHJlY29tcG9zZUtleV8pO1xuICAgICAgdGhpcy5tYXBQcmVjb21wb3NlS2V5XyA9IG51bGw7XG4gICAgfVxuICAgIGlmICghbWFwKSB7XG4gICAgICB0aGlzLmNoYW5nZWQoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMubWFwUmVuZGVyS2V5Xykge1xuICAgICAgdW5saXN0ZW5CeUtleSh0aGlzLm1hcFJlbmRlcktleV8pO1xuICAgICAgdGhpcy5tYXBSZW5kZXJLZXlfID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKG1hcCkge1xuICAgICAgdGhpcy5tYXBQcmVjb21wb3NlS2V5XyA9IGxpc3RlbihcbiAgICAgICAgbWFwLFxuICAgICAgICBSZW5kZXJFdmVudFR5cGUuUFJFQ09NUE9TRSxcbiAgICAgICAgZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICAgIGNvbnN0IHJlbmRlckV2ZW50ID1cbiAgICAgICAgICAgIC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vcmVuZGVyL0V2ZW50LmpzXCIpLmRlZmF1bHR9ICovIChldnQpO1xuICAgICAgICAgIGNvbnN0IGxheWVyU3RhdGVzQXJyYXkgPSByZW5kZXJFdmVudC5mcmFtZVN0YXRlLmxheWVyU3RhdGVzQXJyYXk7XG4gICAgICAgICAgY29uc3QgbGF5ZXJTdGF0ZSA9IHRoaXMuZ2V0TGF5ZXJTdGF0ZShmYWxzZSk7XG4gICAgICAgICAgYXNzZXJ0KFxuICAgICAgICAgICAgIWxheWVyU3RhdGVzQXJyYXkuc29tZShmdW5jdGlvbiAoYXJyYXlMYXllclN0YXRlKSB7XG4gICAgICAgICAgICAgIHJldHVybiBhcnJheUxheWVyU3RhdGUubGF5ZXIgPT09IGxheWVyU3RhdGUubGF5ZXI7XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICdBIGxheWVyIGNhbiBvbmx5IGJlIGFkZGVkIHRvIHRoZSBtYXAgb25jZS4gVXNlIGVpdGhlciBgbGF5ZXIuc2V0TWFwKClgIG9yIGBtYXAuYWRkTGF5ZXIoKWAsIG5vdCBib3RoLidcbiAgICAgICAgICApO1xuICAgICAgICAgIGxheWVyU3RhdGVzQXJyYXkucHVzaChsYXllclN0YXRlKTtcbiAgICAgICAgfSxcbiAgICAgICAgdGhpc1xuICAgICAgKTtcbiAgICAgIHRoaXMubWFwUmVuZGVyS2V5XyA9IGxpc3Rlbih0aGlzLCBFdmVudFR5cGUuQ0hBTkdFLCBtYXAucmVuZGVyLCBtYXApO1xuICAgICAgdGhpcy5jaGFuZ2VkKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgbGF5ZXIgc291cmNlLlxuICAgKiBAcGFyYW0ge1NvdXJjZVR5cGV8bnVsbH0gc291cmNlIFRoZSBsYXllciBzb3VyY2UuXG4gICAqIEBvYnNlcnZhYmxlXG4gICAqIEBhcGlcbiAgICovXG4gIHNldFNvdXJjZShzb3VyY2UpIHtcbiAgICB0aGlzLnNldChMYXllclByb3BlcnR5LlNPVVJDRSwgc291cmNlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHJlbmRlcmVyIGZvciB0aGlzIGxheWVyLlxuICAgKiBAcmV0dXJuIHtSZW5kZXJlclR5cGV8bnVsbH0gVGhlIGxheWVyIHJlbmRlcmVyLlxuICAgKi9cbiAgZ2V0UmVuZGVyZXIoKSB7XG4gICAgaWYgKCF0aGlzLnJlbmRlcmVyXykge1xuICAgICAgdGhpcy5yZW5kZXJlcl8gPSB0aGlzLmNyZWF0ZVJlbmRlcmVyKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnJlbmRlcmVyXztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUaGUgbGF5ZXIgaGFzIGEgcmVuZGVyZXIuXG4gICAqL1xuICBoYXNSZW5kZXJlcigpIHtcbiAgICByZXR1cm4gISF0aGlzLnJlbmRlcmVyXztcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSByZW5kZXJlciBmb3IgdGhpcyBsYXllci5cbiAgICogQHJldHVybiB7UmVuZGVyZXJUeXBlfSBBIGxheWVyIHJlbmRlcmVyLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBjcmVhdGVSZW5kZXJlcigpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhbiB1cC5cbiAgICovXG4gIGRpc3Bvc2VJbnRlcm5hbCgpIHtcbiAgICBpZiAodGhpcy5yZW5kZXJlcl8pIHtcbiAgICAgIHRoaXMucmVuZGVyZXJfLmRpc3Bvc2UoKTtcbiAgICAgIGRlbGV0ZSB0aGlzLnJlbmRlcmVyXztcbiAgICB9XG5cbiAgICB0aGlzLnNldFNvdXJjZShudWxsKTtcbiAgICBzdXBlci5kaXNwb3NlSW50ZXJuYWwoKTtcbiAgfVxufVxuXG4vKipcbiAqIFJldHVybiBgdHJ1ZWAgaWYgdGhlIGxheWVyIGlzIHZpc2libGUgYW5kIGlmIHRoZSBwcm92aWRlZCB2aWV3IHN0YXRlXG4gKiBoYXMgcmVzb2x1dGlvbiBhbmQgem9vbSBsZXZlbHMgdGhhdCBhcmUgaW4gcmFuZ2Ugb2YgdGhlIGxheWVyJ3MgbWluL21heC5cbiAqIEBwYXJhbSB7U3RhdGV9IGxheWVyU3RhdGUgTGF5ZXIgc3RhdGUuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL1ZpZXcuanNcIikuU3RhdGV9IHZpZXdTdGF0ZSBWaWV3IHN0YXRlLlxuICogQHJldHVybiB7Ym9vbGVhbn0gVGhlIGxheWVyIGlzIHZpc2libGUgYXQgdGhlIGdpdmVuIHZpZXcgc3RhdGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpblZpZXcobGF5ZXJTdGF0ZSwgdmlld1N0YXRlKSB7XG4gIGlmICghbGF5ZXJTdGF0ZS52aXNpYmxlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IHJlc29sdXRpb24gPSB2aWV3U3RhdGUucmVzb2x1dGlvbjtcbiAgaWYgKFxuICAgIHJlc29sdXRpb24gPCBsYXllclN0YXRlLm1pblJlc29sdXRpb24gfHxcbiAgICByZXNvbHV0aW9uID49IGxheWVyU3RhdGUubWF4UmVzb2x1dGlvblxuICApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3Qgem9vbSA9IHZpZXdTdGF0ZS56b29tO1xuICByZXR1cm4gem9vbSA+IGxheWVyU3RhdGUubWluWm9vbSAmJiB6b29tIDw9IGxheWVyU3RhdGUubWF4Wm9vbTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgTGF5ZXI7XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvbGF5ZXIvUHJvcGVydHlcbiAqL1xuXG4vKipcbiAqIEBlbnVtIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IHtcbiAgT1BBQ0lUWTogJ29wYWNpdHknLFxuICBWSVNJQkxFOiAndmlzaWJsZScsXG4gIEVYVEVOVDogJ2V4dGVudCcsXG4gIFpfSU5ERVg6ICd6SW5kZXgnLFxuICBNQVhfUkVTT0xVVElPTjogJ21heFJlc29sdXRpb24nLFxuICBNSU5fUkVTT0xVVElPTjogJ21pblJlc29sdXRpb24nLFxuICBNQVhfWk9PTTogJ21heFpvb20nLFxuICBNSU5fWk9PTTogJ21pblpvb20nLFxuICBTT1VSQ0U6ICdzb3VyY2UnLFxuICBNQVA6ICdtYXAnLFxufTtcbiIsIi8qKlxuICogQG1vZHVsZSBvbC9sYXllci9UaWxlXG4gKi9cbmltcG9ydCBCYXNlVGlsZUxheWVyIGZyb20gJy4vQmFzZVRpbGUuanMnO1xuaW1wb3J0IENhbnZhc1RpbGVMYXllclJlbmRlcmVyIGZyb20gJy4uL3JlbmRlcmVyL2NhbnZhcy9UaWxlTGF5ZXIuanMnO1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEZvciBsYXllciBzb3VyY2VzIHRoYXQgcHJvdmlkZSBwcmUtcmVuZGVyZWQsIHRpbGVkIGltYWdlcyBpbiBncmlkcyB0aGF0IGFyZVxuICogb3JnYW5pemVkIGJ5IHpvb20gbGV2ZWxzIGZvciBzcGVjaWZpYyByZXNvbHV0aW9ucy5cbiAqIE5vdGUgdGhhdCBhbnkgcHJvcGVydHkgc2V0IGluIHRoZSBvcHRpb25zIGlzIHNldCBhcyBhIHtAbGluayBtb2R1bGU6b2wvT2JqZWN0fkJhc2VPYmplY3R9XG4gKiBwcm9wZXJ0eSBvbiB0aGUgbGF5ZXIgb2JqZWN0OyBmb3IgZXhhbXBsZSwgc2V0dGluZyBgdGl0bGU6ICdNeSBUaXRsZSdgIGluIHRoZVxuICogb3B0aW9ucyBtZWFucyB0aGF0IGB0aXRsZWAgaXMgb2JzZXJ2YWJsZSwgYW5kIGhhcyBnZXQvc2V0IGFjY2Vzc29ycy5cbiAqXG4gKiBAdGVtcGxhdGUge2ltcG9ydChcIi4uL3NvdXJjZS9UaWxlLmpzXCIpLmRlZmF1bHR9IFRpbGVTb3VyY2VUeXBlXG4gKiBAZXh0ZW5kcyBCYXNlVGlsZUxheWVyPFRpbGVTb3VyY2VUeXBlLCBDYW52YXNUaWxlTGF5ZXJSZW5kZXJlcj5cbiAqIEBhcGlcbiAqL1xuY2xhc3MgVGlsZUxheWVyIGV4dGVuZHMgQmFzZVRpbGVMYXllciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vQmFzZVRpbGUuanNcIikuT3B0aW9uczxUaWxlU291cmNlVHlwZT59IFtvcHRpb25zXSBUaWxlIGxheWVyIG9wdGlvbnMuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgc3VwZXIob3B0aW9ucyk7XG4gIH1cblxuICBjcmVhdGVSZW5kZXJlcigpIHtcbiAgICByZXR1cm4gbmV3IENhbnZhc1RpbGVMYXllclJlbmRlcmVyKHRoaXMpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFRpbGVMYXllcjtcbiIsIi8qKlxuICogQG1vZHVsZSBvbC9sYXllci9UaWxlUHJvcGVydHlcbiAqL1xuXG4vKipcbiAqIEBlbnVtIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IHtcbiAgUFJFTE9BRDogJ3ByZWxvYWQnLFxuICBVU0VfSU5URVJJTV9USUxFU19PTl9FUlJPUjogJ3VzZUludGVyaW1UaWxlc09uRXJyb3InLFxufTtcbiIsIi8qKlxuICogQG1vZHVsZSBvbC9sYXllci9WZWN0b3JcbiAqL1xuaW1wb3J0IEJhc2VWZWN0b3JMYXllciBmcm9tICcuL0Jhc2VWZWN0b3IuanMnO1xuaW1wb3J0IENhbnZhc1ZlY3RvckxheWVyUmVuZGVyZXIgZnJvbSAnLi4vcmVuZGVyZXIvY2FudmFzL1ZlY3RvckxheWVyLmpzJztcblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBWZWN0b3IgZGF0YSBpcyByZW5kZXJlZCBjbGllbnQtc2lkZSwgYXMgdmVjdG9ycy4gVGhpcyBsYXllciB0eXBlIHByb3ZpZGVzIG1vc3QgYWNjdXJhdGUgcmVuZGVyaW5nXG4gKiBldmVuIGR1cmluZyBhbmltYXRpb25zLiBQb2ludHMgYW5kIGxhYmVscyBzdGF5IHVwcmlnaHQgb24gcm90YXRlZCB2aWV3cy4gRm9yIHZlcnkgbGFyZ2VcbiAqIGFtb3VudHMgb2YgdmVjdG9yIGRhdGEsIHBlcmZvcm1hbmNlIG1heSBzdWZmZXIgZHVyaW5nIHBhbiBhbmQgem9vbSBhbmltYXRpb25zLiBJbiB0aGlzIGNhc2UsXG4gKiB0cnkge0BsaW5rIG1vZHVsZTpvbC9sYXllci9WZWN0b3JJbWFnZX5WZWN0b3JJbWFnZUxheWVyfS5cbiAqXG4gKiBOb3RlIHRoYXQgYW55IHByb3BlcnR5IHNldCBpbiB0aGUgb3B0aW9ucyBpcyBzZXQgYXMgYSB7QGxpbmsgbW9kdWxlOm9sL09iamVjdH5CYXNlT2JqZWN0fVxuICogcHJvcGVydHkgb24gdGhlIGxheWVyIG9iamVjdDsgZm9yIGV4YW1wbGUsIHNldHRpbmcgYHRpdGxlOiAnTXkgVGl0bGUnYCBpbiB0aGVcbiAqIG9wdGlvbnMgbWVhbnMgdGhhdCBgdGl0bGVgIGlzIG9ic2VydmFibGUsIGFuZCBoYXMgZ2V0L3NldCBhY2Nlc3NvcnMuXG4gKlxuICogQHRlbXBsYXRlIHtpbXBvcnQoXCIuLi9zb3VyY2UvVmVjdG9yLmpzXCIpLmRlZmF1bHR9IFZlY3RvclNvdXJjZVR5cGVcbiAqIEBleHRlbmRzIHtCYXNlVmVjdG9yTGF5ZXI8VmVjdG9yU291cmNlVHlwZSwgQ2FudmFzVmVjdG9yTGF5ZXJSZW5kZXJlcj59XG4gKiBAYXBpXG4gKi9cbmNsYXNzIFZlY3RvckxheWVyIGV4dGVuZHMgQmFzZVZlY3RvckxheWVyIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9CYXNlVmVjdG9yLmpzXCIpLk9wdGlvbnM8VmVjdG9yU291cmNlVHlwZT59IFtvcHRpb25zXSBPcHRpb25zLlxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHN1cGVyKG9wdGlvbnMpO1xuICB9XG5cbiAgY3JlYXRlUmVuZGVyZXIoKSB7XG4gICAgcmV0dXJuIG5ldyBDYW52YXNWZWN0b3JMYXllclJlbmRlcmVyKHRoaXMpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFZlY3RvckxheWVyO1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2xvYWRpbmdzdHJhdGVneVxuICovXG5cbmltcG9ydCB7ZnJvbVVzZXJFeHRlbnQsIGZyb21Vc2VyUmVzb2x1dGlvbiwgdG9Vc2VyRXh0ZW50fSBmcm9tICcuL3Byb2ouanMnO1xuXG4vKipcbiAqIFN0cmF0ZWd5IGZ1bmN0aW9uIGZvciBsb2FkaW5nIGFsbCBmZWF0dXJlcyB3aXRoIGEgc2luZ2xlIHJlcXVlc3QuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEBwYXJhbSB7bnVtYmVyfSByZXNvbHV0aW9uIFJlc29sdXRpb24uXG4gKiBAcmV0dXJuIHtBcnJheTxpbXBvcnQoXCIuL2V4dGVudC5qc1wiKS5FeHRlbnQ+fSBFeHRlbnRzLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gYWxsKGV4dGVudCwgcmVzb2x1dGlvbikge1xuICByZXR1cm4gW1stSW5maW5pdHksIC1JbmZpbml0eSwgSW5maW5pdHksIEluZmluaXR5XV07XG59XG5cbi8qKlxuICogU3RyYXRlZ3kgZnVuY3Rpb24gZm9yIGxvYWRpbmcgZmVhdHVyZXMgYmFzZWQgb24gdGhlIHZpZXcncyBleHRlbnQgYW5kXG4gKiByZXNvbHV0aW9uLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL2V4dGVudC5qc1wiKS5FeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gcmVzb2x1dGlvbiBSZXNvbHV0aW9uLlxuICogQHJldHVybiB7QXJyYXk8aW1wb3J0KFwiLi9leHRlbnQuanNcIikuRXh0ZW50Pn0gRXh0ZW50cy5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJib3goZXh0ZW50LCByZXNvbHV0aW9uKSB7XG4gIHJldHVybiBbZXh0ZW50XTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgc3RyYXRlZ3kgZnVuY3Rpb24gZm9yIGxvYWRpbmcgZmVhdHVyZXMgYmFzZWQgb24gYSB0aWxlIGdyaWQuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vdGlsZWdyaWQvVGlsZUdyaWQuanNcIikuZGVmYXVsdH0gdGlsZUdyaWQgVGlsZSBncmlkLlxuICogQHJldHVybiB7ZnVuY3Rpb24oaW1wb3J0KFwiLi9leHRlbnQuanNcIikuRXh0ZW50LCBudW1iZXIsIGltcG9ydChcIi4vcHJvai5qc1wiKS5Qcm9qZWN0aW9uKTogQXJyYXk8aW1wb3J0KFwiLi9leHRlbnQuanNcIikuRXh0ZW50Pn0gTG9hZGluZyBzdHJhdGVneS5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRpbGUodGlsZUdyaWQpIHtcbiAgcmV0dXJuIChcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcmVzb2x1dGlvbiBSZXNvbHV0aW9uLlxuICAgICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9wcm9qLmpzXCIpLlByb2plY3Rpb259IHByb2plY3Rpb24gUHJvamVjdGlvbi5cbiAgICAgKiBAcmV0dXJuIHtBcnJheTxpbXBvcnQoXCIuL2V4dGVudC5qc1wiKS5FeHRlbnQ+fSBFeHRlbnRzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChleHRlbnQsIHJlc29sdXRpb24sIHByb2plY3Rpb24pIHtcbiAgICAgIGNvbnN0IHogPSB0aWxlR3JpZC5nZXRaRm9yUmVzb2x1dGlvbihcbiAgICAgICAgZnJvbVVzZXJSZXNvbHV0aW9uKHJlc29sdXRpb24sIHByb2plY3Rpb24pXG4gICAgICApO1xuICAgICAgY29uc3QgdGlsZVJhbmdlID0gdGlsZUdyaWQuZ2V0VGlsZVJhbmdlRm9yRXh0ZW50QW5kWihcbiAgICAgICAgZnJvbVVzZXJFeHRlbnQoZXh0ZW50LCBwcm9qZWN0aW9uKSxcbiAgICAgICAgelxuICAgICAgKTtcbiAgICAgIC8qKiBAdHlwZSB7QXJyYXk8aW1wb3J0KFwiLi9leHRlbnQuanNcIikuRXh0ZW50Pn0gKi9cbiAgICAgIGNvbnN0IGV4dGVudHMgPSBbXTtcbiAgICAgIC8qKiBAdHlwZSB7aW1wb3J0KFwiLi90aWxlY29vcmQuanNcIikuVGlsZUNvb3JkfSAqL1xuICAgICAgY29uc3QgdGlsZUNvb3JkID0gW3osIDAsIDBdO1xuICAgICAgZm9yIChcbiAgICAgICAgdGlsZUNvb3JkWzFdID0gdGlsZVJhbmdlLm1pblg7XG4gICAgICAgIHRpbGVDb29yZFsxXSA8PSB0aWxlUmFuZ2UubWF4WDtcbiAgICAgICAgKyt0aWxlQ29vcmRbMV1cbiAgICAgICkge1xuICAgICAgICBmb3IgKFxuICAgICAgICAgIHRpbGVDb29yZFsyXSA9IHRpbGVSYW5nZS5taW5ZO1xuICAgICAgICAgIHRpbGVDb29yZFsyXSA8PSB0aWxlUmFuZ2UubWF4WTtcbiAgICAgICAgICArK3RpbGVDb29yZFsyXVxuICAgICAgICApIHtcbiAgICAgICAgICBleHRlbnRzLnB1c2goXG4gICAgICAgICAgICB0b1VzZXJFeHRlbnQodGlsZUdyaWQuZ2V0VGlsZUNvb3JkRXh0ZW50KHRpbGVDb29yZCksIHByb2plY3Rpb24pXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGV4dGVudHM7XG4gICAgfVxuICApO1xufVxuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL21hdGhcbiAqL1xuXG4vKipcbiAqIFRha2VzIGEgbnVtYmVyIGFuZCBjbGFtcHMgaXQgdG8gd2l0aGluIHRoZSBwcm92aWRlZCBib3VuZHMuXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVGhlIGlucHV0IG51bWJlci5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtaW4gVGhlIG1pbmltdW0gdmFsdWUgdG8gcmV0dXJuLlxuICogQHBhcmFtIHtudW1iZXJ9IG1heCBUaGUgbWF4aW11bSB2YWx1ZSB0byByZXR1cm4uXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBpbnB1dCBudW1iZXIgaWYgaXQgaXMgd2l0aGluIGJvdW5kcywgb3IgdGhlIG5lYXJlc3RcbiAqICAgICBudW1iZXIgd2l0aGluIHRoZSBib3VuZHMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbGFtcCh2YWx1ZSwgbWluLCBtYXgpIHtcbiAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KHZhbHVlLCBtaW4pLCBtYXgpO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIHNxdWFyZSBvZiB0aGUgY2xvc2VzdCBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBwb2ludCAoeCwgeSkgYW5kIHRoZVxuICogbGluZSBzZWdtZW50ICh4MSwgeTEpIHRvICh4MiwgeTIpLlxuICogQHBhcmFtIHtudW1iZXJ9IHggWC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB5IFkuXG4gKiBAcGFyYW0ge251bWJlcn0geDEgWDEuXG4gKiBAcGFyYW0ge251bWJlcn0geTEgWTEuXG4gKiBAcGFyYW0ge251bWJlcn0geDIgWDIuXG4gKiBAcGFyYW0ge251bWJlcn0geTIgWTIuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFNxdWFyZWQgZGlzdGFuY2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzcXVhcmVkU2VnbWVudERpc3RhbmNlKHgsIHksIHgxLCB5MSwgeDIsIHkyKSB7XG4gIGNvbnN0IGR4ID0geDIgLSB4MTtcbiAgY29uc3QgZHkgPSB5MiAtIHkxO1xuICBpZiAoZHggIT09IDAgfHwgZHkgIT09IDApIHtcbiAgICBjb25zdCB0ID0gKCh4IC0geDEpICogZHggKyAoeSAtIHkxKSAqIGR5KSAvIChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgaWYgKHQgPiAxKSB7XG4gICAgICB4MSA9IHgyO1xuICAgICAgeTEgPSB5MjtcbiAgICB9IGVsc2UgaWYgKHQgPiAwKSB7XG4gICAgICB4MSArPSBkeCAqIHQ7XG4gICAgICB5MSArPSBkeSAqIHQ7XG4gICAgfVxuICB9XG4gIHJldHVybiBzcXVhcmVkRGlzdGFuY2UoeCwgeSwgeDEsIHkxKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBzcXVhcmUgb2YgdGhlIGRpc3RhbmNlIGJldHdlZW4gdGhlIHBvaW50cyAoeDEsIHkxKSBhbmQgKHgyLCB5MikuXG4gKiBAcGFyYW0ge251bWJlcn0geDEgWDEuXG4gKiBAcGFyYW0ge251bWJlcn0geTEgWTEuXG4gKiBAcGFyYW0ge251bWJlcn0geDIgWDIuXG4gKiBAcGFyYW0ge251bWJlcn0geTIgWTIuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFNxdWFyZWQgZGlzdGFuY2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzcXVhcmVkRGlzdGFuY2UoeDEsIHkxLCB4MiwgeTIpIHtcbiAgY29uc3QgZHggPSB4MiAtIHgxO1xuICBjb25zdCBkeSA9IHkyIC0geTE7XG4gIHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeTtcbn1cblxuLyoqXG4gKiBTb2x2ZXMgc3lzdGVtIG9mIGxpbmVhciBlcXVhdGlvbnMgdXNpbmcgR2F1c3NpYW4gZWxpbWluYXRpb24gbWV0aG9kLlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8bnVtYmVyPj59IG1hdCBBdWdtZW50ZWQgbWF0cml4IChuIHggbiArIDEgY29sdW1uKVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW4gcm93LW1ham9yIG9yZGVyLlxuICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gVGhlIHJlc3VsdGluZyB2ZWN0b3IuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzb2x2ZUxpbmVhclN5c3RlbShtYXQpIHtcbiAgY29uc3QgbiA9IG1hdC5sZW5ndGg7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAvLyBGaW5kIG1heCBpbiB0aGUgaS10aCBjb2x1bW4gKGlnbm9yaW5nIGkgLSAxIGZpcnN0IHJvd3MpXG4gICAgbGV0IG1heFJvdyA9IGk7XG4gICAgbGV0IG1heEVsID0gTWF0aC5hYnMobWF0W2ldW2ldKTtcbiAgICBmb3IgKGxldCByID0gaSArIDE7IHIgPCBuOyByKyspIHtcbiAgICAgIGNvbnN0IGFic1ZhbHVlID0gTWF0aC5hYnMobWF0W3JdW2ldKTtcbiAgICAgIGlmIChhYnNWYWx1ZSA+IG1heEVsKSB7XG4gICAgICAgIG1heEVsID0gYWJzVmFsdWU7XG4gICAgICAgIG1heFJvdyA9IHI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG1heEVsID09PSAwKSB7XG4gICAgICByZXR1cm4gbnVsbDsgLy8gbWF0cml4IGlzIHNpbmd1bGFyXG4gICAgfVxuXG4gICAgLy8gU3dhcCBtYXggcm93IHdpdGggaS10aCAoY3VycmVudCkgcm93XG4gICAgY29uc3QgdG1wID0gbWF0W21heFJvd107XG4gICAgbWF0W21heFJvd10gPSBtYXRbaV07XG4gICAgbWF0W2ldID0gdG1wO1xuXG4gICAgLy8gU3VidHJhY3QgdGhlIGktdGggcm93IHRvIG1ha2UgYWxsIHRoZSByZW1haW5pbmcgcm93cyAwIGluIHRoZSBpLXRoIGNvbHVtblxuICAgIGZvciAobGV0IGogPSBpICsgMTsgaiA8IG47IGorKykge1xuICAgICAgY29uc3QgY29lZiA9IC1tYXRbal1baV0gLyBtYXRbaV1baV07XG4gICAgICBmb3IgKGxldCBrID0gaTsgayA8IG4gKyAxOyBrKyspIHtcbiAgICAgICAgaWYgKGkgPT0gaykge1xuICAgICAgICAgIG1hdFtqXVtrXSA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWF0W2pdW2tdICs9IGNvZWYgKiBtYXRbaV1ba107XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBTb2x2ZSBBeD1iIGZvciB1cHBlciB0cmlhbmd1bGFyIG1hdHJpeCBBIChtYXQpXG4gIGNvbnN0IHggPSBuZXcgQXJyYXkobik7XG4gIGZvciAobGV0IGwgPSBuIC0gMTsgbCA+PSAwOyBsLS0pIHtcbiAgICB4W2xdID0gbWF0W2xdW25dIC8gbWF0W2xdW2xdO1xuICAgIGZvciAobGV0IG0gPSBsIC0gMTsgbSA+PSAwOyBtLS0pIHtcbiAgICAgIG1hdFttXVtuXSAtPSBtYXRbbV1bbF0gKiB4W2xdO1xuICAgIH1cbiAgfVxuICByZXR1cm4geDtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyByYWRpYW5zIHRvIHRvIGRlZ3JlZXMuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGFuZ2xlSW5SYWRpYW5zIEFuZ2xlIGluIHJhZGlhbnMuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEFuZ2xlIGluIGRlZ3JlZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0RlZ3JlZXMoYW5nbGVJblJhZGlhbnMpIHtcbiAgcmV0dXJuIChhbmdsZUluUmFkaWFucyAqIDE4MCkgLyBNYXRoLlBJO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGRlZ3JlZXMgdG8gcmFkaWFucy5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gYW5nbGVJbkRlZ3JlZXMgQW5nbGUgaW4gZGVncmVlcy5cbiAqIEByZXR1cm4ge251bWJlcn0gQW5nbGUgaW4gcmFkaWFucy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvUmFkaWFucyhhbmdsZUluRGVncmVlcykge1xuICByZXR1cm4gKGFuZ2xlSW5EZWdyZWVzICogTWF0aC5QSSkgLyAxODA7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbW9kdWxvIG9mIGEgLyBiLCBkZXBlbmRpbmcgb24gdGhlIHNpZ24gb2YgYi5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gYSBEaXZpZGVuZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiIERpdmlzb3IuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IE1vZHVsby5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1vZHVsbyhhLCBiKSB7XG4gIGNvbnN0IHIgPSBhICUgYjtcbiAgcmV0dXJuIHIgKiBiIDwgMCA/IHIgKyBiIDogcjtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBsaW5lYXJseSBpbnRlcnBvbGF0ZWQgdmFsdWUgb2YgeCBiZXR3ZWVuIGEgYW5kIGIuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGEgTnVtYmVyXG4gKiBAcGFyYW0ge251bWJlcn0gYiBOdW1iZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSB4IFZhbHVlIHRvIGJlIGludGVycG9sYXRlZC5cbiAqIEByZXR1cm4ge251bWJlcn0gSW50ZXJwb2xhdGVkIHZhbHVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbGVycChhLCBiLCB4KSB7XG4gIHJldHVybiBhICsgeCAqIChiIC0gYSk7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIG51bWJlciB3aXRoIGEgbGltaXRlZCBudW1iZXIgb2YgZGVjaW1hbCBkaWdpdHMuXG4gKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgaW5wdXQgbnVtYmVyLlxuICogQHBhcmFtIHtudW1iZXJ9IGRlY2ltYWxzIFRoZSBtYXhpbXVtIG51bWJlciBvZiBkZWNpbWFsIGRpZ2l0cy5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIGlucHV0IG51bWJlciB3aXRoIGEgbGltaXRlZCBudW1iZXIgb2YgZGVjaW1hbCBkaWdpdHMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0ZpeGVkKG4sIGRlY2ltYWxzKSB7XG4gIGNvbnN0IGZhY3RvciA9IE1hdGgucG93KDEwLCBkZWNpbWFscyk7XG4gIHJldHVybiBNYXRoLnJvdW5kKG4gKiBmYWN0b3IpIC8gZmFjdG9yO1xufVxuXG4vKipcbiAqIFJvdW5kcyBhIG51bWJlciB0byB0aGUgbmVhcmVzdCBpbnRlZ2VyIHZhbHVlIGNvbnNpZGVyaW5nIG9ubHkgdGhlIGdpdmVuIG51bWJlclxuICogb2YgZGVjaW1hbCBkaWdpdHMgKHdpdGggcm91bmRpbmcgb24gdGhlIGZpbmFsIGRpZ2l0KS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBpbnB1dCBudW1iZXIuXG4gKiBAcGFyYW0ge251bWJlcn0gZGVjaW1hbHMgVGhlIG1heGltdW0gbnVtYmVyIG9mIGRlY2ltYWwgZGlnaXRzLlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgbmVhcmVzdCBpbnRlZ2VyLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcm91bmQobiwgZGVjaW1hbHMpIHtcbiAgcmV0dXJuIE1hdGgucm91bmQodG9GaXhlZChuLCBkZWNpbWFscykpO1xufVxuXG4vKipcbiAqIFJvdW5kcyBhIG51bWJlciB0byB0aGUgbmV4dCBzbWFsbGVyIGludGVnZXIgY29uc2lkZXJpbmcgb25seSB0aGUgZ2l2ZW4gbnVtYmVyXG4gKiBvZiBkZWNpbWFsIGRpZ2l0cyAod2l0aCByb3VuZGluZyBvbiB0aGUgZmluYWwgZGlnaXQpLlxuICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIGlucHV0IG51bWJlci5cbiAqIEBwYXJhbSB7bnVtYmVyfSBkZWNpbWFscyBUaGUgbWF4aW11bSBudW1iZXIgb2YgZGVjaW1hbCBkaWdpdHMuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBuZXh0IHNtYWxsZXIgaW50ZWdlci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZsb29yKG4sIGRlY2ltYWxzKSB7XG4gIHJldHVybiBNYXRoLmZsb29yKHRvRml4ZWQobiwgZGVjaW1hbHMpKTtcbn1cblxuLyoqXG4gKiBSb3VuZHMgYSBudW1iZXIgdG8gdGhlIG5leHQgYmlnZ2VyIGludGVnZXIgY29uc2lkZXJpbmcgb25seSB0aGUgZ2l2ZW4gbnVtYmVyXG4gKiBvZiBkZWNpbWFsIGRpZ2l0cyAod2l0aCByb3VuZGluZyBvbiB0aGUgZmluYWwgZGlnaXQpLlxuICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIGlucHV0IG51bWJlci5cbiAqIEBwYXJhbSB7bnVtYmVyfSBkZWNpbWFscyBUaGUgbWF4aW11bSBudW1iZXIgb2YgZGVjaW1hbCBkaWdpdHMuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBuZXh0IGJpZ2dlciBpbnRlZ2VyLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY2VpbChuLCBkZWNpbWFscykge1xuICByZXR1cm4gTWF0aC5jZWlsKHRvRml4ZWQobiwgZGVjaW1hbHMpKTtcbn1cbiIsIi8qKlxuICogQG1vZHVsZSBvbC9vYmpcbiAqL1xuXG4vKipcbiAqIFJlbW92ZXMgYWxsIHByb3BlcnRpZXMgZnJvbSBhbiBvYmplY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY2xlYXIuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbGVhcihvYmplY3QpIHtcbiAgZm9yIChjb25zdCBwcm9wZXJ0eSBpbiBvYmplY3QpIHtcbiAgICBkZWxldGUgb2JqZWN0W3Byb3BlcnR5XTtcbiAgfVxufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhbiBvYmplY3QgaGFzIGFueSBwcm9wZXJ0aWVzLlxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNoZWNrLlxuICogQHJldHVybiB7Ym9vbGVhbn0gVGhlIG9iamVjdCBpcyBlbXB0eS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzRW1wdHkob2JqZWN0KSB7XG4gIGxldCBwcm9wZXJ0eTtcbiAgZm9yIChwcm9wZXJ0eSBpbiBvYmplY3QpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuICFwcm9wZXJ0eTtcbn1cbiIsIi8qKlxuICogQG1vZHVsZSBvbC9wb2ludGVyL0V2ZW50VHlwZVxuICovXG5cbi8qKlxuICogQ29uc3RhbnRzIGZvciBldmVudCBuYW1lcy5cbiAqIEBlbnVtIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IHtcbiAgUE9JTlRFUk1PVkU6ICdwb2ludGVybW92ZScsXG4gIFBPSU5URVJET1dOOiAncG9pbnRlcmRvd24nLFxuICBQT0lOVEVSVVA6ICdwb2ludGVydXAnLFxuICBQT0lOVEVST1ZFUjogJ3BvaW50ZXJvdmVyJyxcbiAgUE9JTlRFUk9VVDogJ3BvaW50ZXJvdXQnLFxuICBQT0lOVEVSRU5URVI6ICdwb2ludGVyZW50ZXInLFxuICBQT0lOVEVSTEVBVkU6ICdwb2ludGVybGVhdmUnLFxuICBQT0lOVEVSQ0FOQ0VMOiAncG9pbnRlcmNhbmNlbCcsXG59O1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3Byb2pcbiAqL1xuXG4vKipcbiAqIFRoZSBvbC9wcm9qIG1vZHVsZSBzdG9yZXM6XG4gKiAqIGEgbGlzdCBvZiB7QGxpbmsgbW9kdWxlOm9sL3Byb2ovUHJvamVjdGlvbn5Qcm9qZWN0aW9ufVxuICogb2JqZWN0cywgb25lIGZvciBlYWNoIHByb2plY3Rpb24gc3VwcG9ydGVkIGJ5IHRoZSBhcHBsaWNhdGlvblxuICogKiBhIGxpc3Qgb2YgdHJhbnNmb3JtIGZ1bmN0aW9ucyBuZWVkZWQgdG8gY29udmVydCBjb29yZGluYXRlcyBpbiBvbmUgcHJvamVjdGlvblxuICogaW50byBhbm90aGVyLlxuICpcbiAqIFRoZSBzdGF0aWMgZnVuY3Rpb25zIGFyZSB0aGUgbWV0aG9kcyB1c2VkIHRvIG1haW50YWluIHRoZXNlLlxuICogRWFjaCB0cmFuc2Zvcm0gZnVuY3Rpb24gY2FuIGhhbmRsZSBub3Qgb25seSBzaW1wbGUgY29vcmRpbmF0ZSBwYWlycywgYnV0IGFsc29cbiAqIGxhcmdlIGFycmF5cyBvZiBjb29yZGluYXRlcyBzdWNoIGFzIHZlY3RvciBnZW9tZXRyaWVzLlxuICpcbiAqIFdoZW4gbG9hZGVkLCB0aGUgbGlicmFyeSBhZGRzIHByb2plY3Rpb24gb2JqZWN0cyBmb3IgRVBTRzo0MzI2IChXR1M4NFxuICogZ2VvZ3JhcGhpYyBjb29yZGluYXRlcykgYW5kIEVQU0c6Mzg1NyAoV2ViIG9yIFNwaGVyaWNhbCBNZXJjYXRvciwgYXMgdXNlZFxuICogZm9yIGV4YW1wbGUgYnkgQmluZyBNYXBzIG9yIE9wZW5TdHJlZXRNYXApLCB0b2dldGhlciB3aXRoIHRoZSByZWxldmFudFxuICogdHJhbnNmb3JtIGZ1bmN0aW9ucy5cbiAqXG4gKiBBZGRpdGlvbmFsIHRyYW5zZm9ybXMgbWF5IGJlIGFkZGVkIGJ5IHVzaW5nIHRoZSBodHRwOi8vcHJvajRqcy5vcmcvXG4gKiBsaWJyYXJ5ICh2ZXJzaW9uIDIuMiBvciBsYXRlcikuIFlvdSBjYW4gdXNlIHRoZSBmdWxsIGJ1aWxkIHN1cHBsaWVkIGJ5XG4gKiBQcm9qNGpzLCBvciBjcmVhdGUgYSBjdXN0b20gYnVpbGQgdG8gc3VwcG9ydCB0aG9zZSBwcm9qZWN0aW9ucyB5b3UgbmVlZDsgc2VlXG4gKiB0aGUgUHJvajRqcyB3ZWJzaXRlIGZvciBob3cgdG8gZG8gdGhpcy4gWW91IGFsc28gbmVlZCB0aGUgUHJvajRqcyBkZWZpbml0aW9uc1xuICogZm9yIHRoZSByZXF1aXJlZCBwcm9qZWN0aW9ucy4gVGhlc2UgZGVmaW5pdGlvbnMgY2FuIGJlIG9idGFpbmVkIGZyb21cbiAqIGh0dHBzOi8vZXBzZy5pby8sIGFuZCBhcmUgYSBKUyBmdW5jdGlvbiwgc28gY2FuIGJlIGxvYWRlZCBpbiBhIHNjcmlwdFxuICogdGFnIChhcyBpbiB0aGUgZXhhbXBsZXMpIG9yIHBhc3RlZCBpbnRvIHlvdXIgYXBwbGljYXRpb24uXG4gKlxuICogQWZ0ZXIgYWxsIHJlcXVpcmVkIHByb2plY3Rpb24gZGVmaW5pdGlvbnMgYXJlIGFkZGVkIHRvIHByb2o0J3MgcmVnaXN0cnkgKGJ5XG4gKiB1c2luZyBgcHJvajQuZGVmcygpYCksIHNpbXBseSBjYWxsIGByZWdpc3Rlcihwcm9qNClgIGZyb20gdGhlIGBvbC9wcm9qL3Byb2o0YFxuICogcGFja2FnZS4gRXhpc3RpbmcgdHJhbnNmb3JtcyBhcmUgbm90IGNoYW5nZWQgYnkgdGhpcyBmdW5jdGlvbi4gU2VlXG4gKiBleGFtcGxlcy93bXMtaW1hZ2UtY3VzdG9tLXByb2ogZm9yIGFuIGV4YW1wbGUgb2YgdGhpcy5cbiAqXG4gKiBBZGRpdGlvbmFsIHByb2plY3Rpb24gZGVmaW5pdGlvbnMgY2FuIGJlIHJlZ2lzdGVyZWQgd2l0aCBgcHJvajQuZGVmcygpYCBhbnlcbiAqIHRpbWUuIEp1c3QgbWFrZSBzdXJlIHRvIGNhbGwgYHJlZ2lzdGVyKHByb2o0KWAgYWdhaW47IGZvciBleGFtcGxlLCB3aXRoIHVzZXItc3VwcGxpZWQgZGF0YSB3aGVyZSB5b3UgZG9uJ3RcbiAqIGtub3cgaW4gYWR2YW5jZSB3aGF0IHByb2plY3Rpb25zIGFyZSBuZWVkZWQsIHlvdSBjYW4gaW5pdGlhbGx5IGxvYWQgbWluaW1hbFxuICogc3VwcG9ydCBhbmQgdGhlbiBsb2FkIHdoaWNoZXZlciBhcmUgcmVxdWVzdGVkLlxuICpcbiAqIE5vdGUgdGhhdCBQcm9qNGpzIGRvZXMgbm90IHN1cHBvcnQgcHJvamVjdGlvbiBleHRlbnRzLiBJZiB5b3Ugd2FudCB0byBhZGRcbiAqIG9uZSBmb3IgY3JlYXRpbmcgZGVmYXVsdCB0aWxlIGdyaWRzLCB5b3UgY2FuIGFkZCBpdCBhZnRlciB0aGUgUHJvamVjdGlvblxuICogb2JqZWN0IGhhcyBiZWVuIGNyZWF0ZWQgd2l0aCBgc2V0RXh0ZW50YCwgZm9yIGV4YW1wbGUsXG4gKiBgZ2V0KCdFUFNHOjEyMzQnKS5zZXRFeHRlbnQoZXh0ZW50KWAuXG4gKlxuICogSW4gYWRkaXRpb24gdG8gUHJvajRqcyBzdXBwb3J0LCBhbnkgdHJhbnNmb3JtIGZ1bmN0aW9ucyBjYW4gYmUgYWRkZWQgd2l0aFxuICoge0BsaW5rIG1vZHVsZTpvbC9wcm9qLmFkZENvb3JkaW5hdGVUcmFuc2Zvcm1zfS4gVG8gdXNlIHRoaXMsIHlvdSBtdXN0IGZpcnN0IGNyZWF0ZVxuICogYSB7QGxpbmsgbW9kdWxlOm9sL3Byb2ovUHJvamVjdGlvbn5Qcm9qZWN0aW9ufSBvYmplY3QgZm9yIHRoZSBuZXcgcHJvamVjdGlvbiBhbmQgYWRkIGl0IHdpdGhcbiAqIHtAbGluayBtb2R1bGU6b2wvcHJvai5hZGRQcm9qZWN0aW9ufS4gWW91IGNhbiB0aGVuIGFkZCB0aGUgZm9yd2FyZCBhbmQgaW52ZXJzZVxuICogZnVuY3Rpb25zIHdpdGgge0BsaW5rIG1vZHVsZTpvbC9wcm9qLmFkZENvb3JkaW5hdGVUcmFuc2Zvcm1zfS4gU2VlXG4gKiBleGFtcGxlcy93bXMtY3VzdG9tLXByb2ogZm9yIGFuIGV4YW1wbGUgb2YgdGhpcy5cbiAqXG4gKiBOb3RlIHRoYXQgaWYgbm8gdHJhbnNmb3JtcyBhcmUgbmVlZGVkIGFuZCB5b3Ugb25seSBuZWVkIHRvIGRlZmluZSB0aGVcbiAqIHByb2plY3Rpb24sIGp1c3QgYWRkIGEge0BsaW5rIG1vZHVsZTpvbC9wcm9qL1Byb2plY3Rpb25+UHJvamVjdGlvbn0gd2l0aFxuICoge0BsaW5rIG1vZHVsZTpvbC9wcm9qLmFkZFByb2plY3Rpb259LiBTZWUgZXhhbXBsZXMvd21zLW5vLXByb2ogZm9yIGFuIGV4YW1wbGUgb2ZcbiAqIHRoaXMuXG4gKi9cbmltcG9ydCBQcm9qZWN0aW9uIGZyb20gJy4vcHJvai9Qcm9qZWN0aW9uLmpzJztcbmltcG9ydCB7XG4gIFBST0pFQ1RJT05TIGFzIEVQU0czODU3X1BST0pFQ1RJT05TLFxuICBmcm9tRVBTRzQzMjYsXG4gIHRvRVBTRzQzMjYsXG59IGZyb20gJy4vcHJvai9lcHNnMzg1Ny5qcyc7XG5pbXBvcnQge1BST0pFQ1RJT05TIGFzIEVQU0c0MzI2X1BST0pFQ1RJT05TfSBmcm9tICcuL3Byb2ovZXBzZzQzMjYuanMnO1xuaW1wb3J0IHtNRVRFUlNfUEVSX1VOSVR9IGZyb20gJy4vcHJvai9Vbml0cy5qcyc7XG5pbXBvcnQge1xuICBhZGQgYXMgYWRkUHJvaixcbiAgY2xlYXIgYXMgY2xlYXJQcm9qLFxuICBnZXQgYXMgZ2V0UHJvaixcbn0gZnJvbSAnLi9wcm9qL3Byb2plY3Rpb25zLmpzJztcbmltcG9ydCB7XG4gIGFkZCBhcyBhZGRUcmFuc2Zvcm1GdW5jLFxuICBjbGVhciBhcyBjbGVhclRyYW5zZm9ybUZ1bmNzLFxuICBnZXQgYXMgZ2V0VHJhbnNmb3JtRnVuYyxcbn0gZnJvbSAnLi9wcm9qL3RyYW5zZm9ybXMuanMnO1xuaW1wb3J0IHthcHBseVRyYW5zZm9ybSwgZ2V0V2lkdGh9IGZyb20gJy4vZXh0ZW50LmpzJztcbmltcG9ydCB7Y2xhbXAsIG1vZHVsb30gZnJvbSAnLi9tYXRoLmpzJztcbmltcG9ydCB7ZXF1YWxzLCBnZXRXb3JsZHNBd2F5fSBmcm9tICcuL2Nvb3JkaW5hdGUuanMnO1xuaW1wb3J0IHtnZXREaXN0YW5jZX0gZnJvbSAnLi9zcGhlcmUuanMnO1xuaW1wb3J0IHt3YXJufSBmcm9tICcuL2NvbnNvbGUuanMnO1xuXG4vKipcbiAqIEEgcHJvamVjdGlvbiBhcyB7QGxpbmsgbW9kdWxlOm9sL3Byb2ovUHJvamVjdGlvbn5Qcm9qZWN0aW9ufSwgU1JTIGlkZW50aWZpZXJcbiAqIHN0cmluZyBvciB1bmRlZmluZWQuXG4gKiBAdHlwZWRlZiB7UHJvamVjdGlvbnxzdHJpbmd8dW5kZWZpbmVkfSBQcm9qZWN0aW9uTGlrZVxuICogQGFwaVxuICovXG5cbi8qKlxuICogQSB0cmFuc2Zvcm0gZnVuY3Rpb24gYWNjZXB0cyBhbiBhcnJheSBvZiBpbnB1dCBjb29yZGluYXRlIHZhbHVlcywgYW4gb3B0aW9uYWxcbiAqIG91dHB1dCBhcnJheSwgYW5kIGFuIG9wdGlvbmFsIGRpbWVuc2lvbiAoZGVmYXVsdCBzaG91bGQgYmUgMikuICBUaGUgZnVuY3Rpb25cbiAqIHRyYW5zZm9ybXMgdGhlIGlucHV0IGNvb3JkaW5hdGUgdmFsdWVzLCBwb3B1bGF0ZXMgdGhlIG91dHB1dCBhcnJheSwgYW5kXG4gKiByZXR1cm5zIHRoZSBvdXRwdXQgYXJyYXkuXG4gKlxuICogQHR5cGVkZWYge2Z1bmN0aW9uKEFycmF5PG51bWJlcj4sIEFycmF5PG51bWJlcj49LCBudW1iZXI9KTogQXJyYXk8bnVtYmVyPn0gVHJhbnNmb3JtRnVuY3Rpb25cbiAqIEBhcGlcbiAqL1xuXG5leHBvcnQge01FVEVSU19QRVJfVU5JVH07XG5cbmV4cG9ydCB7UHJvamVjdGlvbn07XG5cbmxldCBzaG93Q29vcmRpbmF0ZVdhcm5pbmcgPSB0cnVlO1xuXG4vKipcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Rpc2FibGUgPSB0cnVlXSBEaXNhYmxlIGNvbnNvbGUgaW5mbyBhYm91dCBgdXNlR2VvZ3JhcGhpYygpYFxuICovXG5leHBvcnQgZnVuY3Rpb24gZGlzYWJsZUNvb3JkaW5hdGVXYXJuaW5nKGRpc2FibGUpIHtcbiAgY29uc3QgaGlkZSA9IGRpc2FibGUgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBkaXNhYmxlO1xuICBzaG93Q29vcmRpbmF0ZVdhcm5pbmcgPSAhaGlkZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGlucHV0IElucHV0IGNvb3JkaW5hdGUgYXJyYXkuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IFtvdXRwdXRdIE91dHB1dCBhcnJheSBvZiBjb29yZGluYXRlIHZhbHVlcy5cbiAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IE91dHB1dCBjb29yZGluYXRlIGFycmF5IChuZXcgYXJyYXksIHNhbWUgY29vcmRpbmF0ZVxuICogICAgIHZhbHVlcykuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbG9uZVRyYW5zZm9ybShpbnB1dCwgb3V0cHV0KSB7XG4gIGlmIChvdXRwdXQgIT09IHVuZGVmaW5lZCkge1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IGlucHV0Lmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgIG91dHB1dFtpXSA9IGlucHV0W2ldO1xuICAgIH1cbiAgICBvdXRwdXQgPSBvdXRwdXQ7XG4gIH0gZWxzZSB7XG4gICAgb3V0cHV0ID0gaW5wdXQuc2xpY2UoKTtcbiAgfVxuICByZXR1cm4gb3V0cHV0O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gaW5wdXQgSW5wdXQgY29vcmRpbmF0ZSBhcnJheS5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gW291dHB1dF0gT3V0cHV0IGFycmF5IG9mIGNvb3JkaW5hdGUgdmFsdWVzLlxuICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gSW5wdXQgY29vcmRpbmF0ZSBhcnJheSAoc2FtZSBhcnJheSBhcyBpbnB1dCkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpZGVudGl0eVRyYW5zZm9ybShpbnB1dCwgb3V0cHV0KSB7XG4gIGlmIChvdXRwdXQgIT09IHVuZGVmaW5lZCAmJiBpbnB1dCAhPT0gb3V0cHV0KSB7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gaW5wdXQubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgb3V0cHV0W2ldID0gaW5wdXRbaV07XG4gICAgfVxuICAgIGlucHV0ID0gb3V0cHV0O1xuICB9XG4gIHJldHVybiBpbnB1dDtcbn1cblxuLyoqXG4gKiBBZGQgYSBQcm9qZWN0aW9uIG9iamVjdCB0byB0aGUgbGlzdCBvZiBzdXBwb3J0ZWQgcHJvamVjdGlvbnMgdGhhdCBjYW4gYmVcbiAqIGxvb2tlZCB1cCBieSB0aGVpciBjb2RlLlxuICpcbiAqIEBwYXJhbSB7UHJvamVjdGlvbn0gcHJvamVjdGlvbiBQcm9qZWN0aW9uIGluc3RhbmNlLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkUHJvamVjdGlvbihwcm9qZWN0aW9uKSB7XG4gIGFkZFByb2oocHJvamVjdGlvbi5nZXRDb2RlKCksIHByb2plY3Rpb24pO1xuICBhZGRUcmFuc2Zvcm1GdW5jKHByb2plY3Rpb24sIHByb2plY3Rpb24sIGNsb25lVHJhbnNmb3JtKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PFByb2plY3Rpb24+fSBwcm9qZWN0aW9ucyBQcm9qZWN0aW9ucy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZFByb2plY3Rpb25zKHByb2plY3Rpb25zKSB7XG4gIHByb2plY3Rpb25zLmZvckVhY2goYWRkUHJvamVjdGlvbik7XG59XG5cbi8qKlxuICogRmV0Y2hlcyBhIFByb2plY3Rpb24gb2JqZWN0IGZvciB0aGUgY29kZSBzcGVjaWZpZWQuXG4gKlxuICogQHBhcmFtIHtQcm9qZWN0aW9uTGlrZX0gcHJvamVjdGlvbkxpa2UgRWl0aGVyIGEgY29kZSBzdHJpbmcgd2hpY2ggaXNcbiAqICAgICBhIGNvbWJpbmF0aW9uIG9mIGF1dGhvcml0eSBhbmQgaWRlbnRpZmllciBzdWNoIGFzIFwiRVBTRzo0MzI2XCIsIG9yIGFuXG4gKiAgICAgZXhpc3RpbmcgcHJvamVjdGlvbiBvYmplY3QsIG9yIHVuZGVmaW5lZC5cbiAqIEByZXR1cm4ge1Byb2plY3Rpb258bnVsbH0gUHJvamVjdGlvbiBvYmplY3QsIG9yIG51bGwgaWYgbm90IGluIGxpc3QuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXQocHJvamVjdGlvbkxpa2UpIHtcbiAgcmV0dXJuIHR5cGVvZiBwcm9qZWN0aW9uTGlrZSA9PT0gJ3N0cmluZydcbiAgICA/IGdldFByb2ooLyoqIEB0eXBlIHtzdHJpbmd9ICovIChwcm9qZWN0aW9uTGlrZSkpXG4gICAgOiAvKiogQHR5cGUge1Byb2plY3Rpb259ICovIChwcm9qZWN0aW9uTGlrZSkgfHwgbnVsbDtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHJlc29sdXRpb24gb2YgdGhlIHBvaW50IGluIGRlZ3JlZXMgb3IgZGlzdGFuY2UgdW5pdHMuXG4gKiBGb3IgcHJvamVjdGlvbnMgd2l0aCBkZWdyZWVzIGFzIHRoZSB1bml0IHRoaXMgd2lsbCBzaW1wbHkgcmV0dXJuIHRoZVxuICogcHJvdmlkZWQgcmVzb2x1dGlvbi4gRm9yIG90aGVyIHByb2plY3Rpb25zIHRoZSBwb2ludCByZXNvbHV0aW9uIGlzXG4gKiBieSBkZWZhdWx0IGVzdGltYXRlZCBieSB0cmFuc2Zvcm1pbmcgdGhlIGBwb2ludGAgcGl4ZWwgdG8gRVBTRzo0MzI2LFxuICogbWVhc3VyaW5nIGl0cyB3aWR0aCBhbmQgaGVpZ2h0IG9uIHRoZSBub3JtYWwgc3BoZXJlLFxuICogYW5kIHRha2luZyB0aGUgYXZlcmFnZSBvZiB0aGUgd2lkdGggYW5kIGhlaWdodC5cbiAqIEEgY3VzdG9tIGZ1bmN0aW9uIGNhbiBiZSBwcm92aWRlZCBmb3IgYSBzcGVjaWZpYyBwcm9qZWN0aW9uLCBlaXRoZXJcbiAqIGJ5IHNldHRpbmcgdGhlIGBnZXRQb2ludFJlc29sdXRpb25gIG9wdGlvbiBpbiB0aGVcbiAqIHtAbGluayBtb2R1bGU6b2wvcHJvai9Qcm9qZWN0aW9uflByb2plY3Rpb259IGNvbnN0cnVjdG9yIG9yIGJ5IHVzaW5nXG4gKiB7QGxpbmsgbW9kdWxlOm9sL3Byb2ovUHJvamVjdGlvbn5Qcm9qZWN0aW9uI3NldEdldFBvaW50UmVzb2x1dGlvbn0gdG8gY2hhbmdlIGFuIGV4aXN0aW5nXG4gKiBwcm9qZWN0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7UHJvamVjdGlvbkxpa2V9IHByb2plY3Rpb24gVGhlIHByb2plY3Rpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gcmVzb2x1dGlvbiBOb21pbmFsIHJlc29sdXRpb24gaW4gcHJvamVjdGlvbiB1bml0cy5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IHBvaW50IFBvaW50IHRvIGZpbmQgYWRqdXN0ZWQgcmVzb2x1dGlvbiBhdC5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9wcm9qL1VuaXRzLmpzXCIpLlVuaXRzfSBbdW5pdHNdIFVuaXRzIHRvIGdldCB0aGUgcG9pbnQgcmVzb2x1dGlvbiBpbi5cbiAqIERlZmF1bHQgaXMgdGhlIHByb2plY3Rpb24ncyB1bml0cy5cbiAqIEByZXR1cm4ge251bWJlcn0gUG9pbnQgcmVzb2x1dGlvbi5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFBvaW50UmVzb2x1dGlvbihwcm9qZWN0aW9uLCByZXNvbHV0aW9uLCBwb2ludCwgdW5pdHMpIHtcbiAgcHJvamVjdGlvbiA9IGdldChwcm9qZWN0aW9uKTtcbiAgbGV0IHBvaW50UmVzb2x1dGlvbjtcbiAgY29uc3QgZ2V0dGVyID0gcHJvamVjdGlvbi5nZXRQb2ludFJlc29sdXRpb25GdW5jKCk7XG4gIGlmIChnZXR0ZXIpIHtcbiAgICBwb2ludFJlc29sdXRpb24gPSBnZXR0ZXIocmVzb2x1dGlvbiwgcG9pbnQpO1xuICAgIGlmICh1bml0cyAmJiB1bml0cyAhPT0gcHJvamVjdGlvbi5nZXRVbml0cygpKSB7XG4gICAgICBjb25zdCBtZXRlcnNQZXJVbml0ID0gcHJvamVjdGlvbi5nZXRNZXRlcnNQZXJVbml0KCk7XG4gICAgICBpZiAobWV0ZXJzUGVyVW5pdCkge1xuICAgICAgICBwb2ludFJlc29sdXRpb24gPVxuICAgICAgICAgIChwb2ludFJlc29sdXRpb24gKiBtZXRlcnNQZXJVbml0KSAvIE1FVEVSU19QRVJfVU5JVFt1bml0c107XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNvbnN0IHByb2pVbml0cyA9IHByb2plY3Rpb24uZ2V0VW5pdHMoKTtcbiAgICBpZiAoKHByb2pVbml0cyA9PSAnZGVncmVlcycgJiYgIXVuaXRzKSB8fCB1bml0cyA9PSAnZGVncmVlcycpIHtcbiAgICAgIHBvaW50UmVzb2x1dGlvbiA9IHJlc29sdXRpb247XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEVzdGltYXRlIHBvaW50IHJlc29sdXRpb24gYnkgdHJhbnNmb3JtaW5nIHRoZSBjZW50ZXIgcGl4ZWwgdG8gRVBTRzo0MzI2LFxuICAgICAgLy8gbWVhc3VyaW5nIGl0cyB3aWR0aCBhbmQgaGVpZ2h0IG9uIHRoZSBub3JtYWwgc3BoZXJlLCBhbmQgdGFraW5nIHRoZVxuICAgICAgLy8gYXZlcmFnZSBvZiB0aGUgd2lkdGggYW5kIGhlaWdodC5cbiAgICAgIGNvbnN0IHRvRVBTRzQzMjYgPSBnZXRUcmFuc2Zvcm1Gcm9tUHJvamVjdGlvbnMoXG4gICAgICAgIHByb2plY3Rpb24sXG4gICAgICAgIGdldCgnRVBTRzo0MzI2JylcbiAgICAgICk7XG4gICAgICBpZiAodG9FUFNHNDMyNiA9PT0gaWRlbnRpdHlUcmFuc2Zvcm0gJiYgcHJvalVuaXRzICE9PSAnZGVncmVlcycpIHtcbiAgICAgICAgLy8gbm8gdHJhbnNmb3JtIGlzIGF2YWlsYWJsZVxuICAgICAgICBwb2ludFJlc29sdXRpb24gPSByZXNvbHV0aW9uICogcHJvamVjdGlvbi5nZXRNZXRlcnNQZXJVbml0KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgdmVydGljZXMgPSBbXG4gICAgICAgICAgcG9pbnRbMF0gLSByZXNvbHV0aW9uIC8gMixcbiAgICAgICAgICBwb2ludFsxXSxcbiAgICAgICAgICBwb2ludFswXSArIHJlc29sdXRpb24gLyAyLFxuICAgICAgICAgIHBvaW50WzFdLFxuICAgICAgICAgIHBvaW50WzBdLFxuICAgICAgICAgIHBvaW50WzFdIC0gcmVzb2x1dGlvbiAvIDIsXG4gICAgICAgICAgcG9pbnRbMF0sXG4gICAgICAgICAgcG9pbnRbMV0gKyByZXNvbHV0aW9uIC8gMixcbiAgICAgICAgXTtcbiAgICAgICAgdmVydGljZXMgPSB0b0VQU0c0MzI2KHZlcnRpY2VzLCB2ZXJ0aWNlcywgMik7XG4gICAgICAgIGNvbnN0IHdpZHRoID0gZ2V0RGlzdGFuY2UodmVydGljZXMuc2xpY2UoMCwgMiksIHZlcnRpY2VzLnNsaWNlKDIsIDQpKTtcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gZ2V0RGlzdGFuY2UodmVydGljZXMuc2xpY2UoNCwgNiksIHZlcnRpY2VzLnNsaWNlKDYsIDgpKTtcbiAgICAgICAgcG9pbnRSZXNvbHV0aW9uID0gKHdpZHRoICsgaGVpZ2h0KSAvIDI7XG4gICAgICB9XG4gICAgICBjb25zdCBtZXRlcnNQZXJVbml0ID0gdW5pdHNcbiAgICAgICAgPyBNRVRFUlNfUEVSX1VOSVRbdW5pdHNdXG4gICAgICAgIDogcHJvamVjdGlvbi5nZXRNZXRlcnNQZXJVbml0KCk7XG4gICAgICBpZiAobWV0ZXJzUGVyVW5pdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHBvaW50UmVzb2x1dGlvbiAvPSBtZXRlcnNQZXJVbml0O1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcG9pbnRSZXNvbHV0aW9uO1xufVxuXG4vKipcbiAqIFJlZ2lzdGVycyB0cmFuc2Zvcm1hdGlvbiBmdW5jdGlvbnMgdGhhdCBkb24ndCBhbHRlciBjb29yZGluYXRlcy4gVGhvc2UgYWxsb3dcbiAqIHRvIHRyYW5zZm9ybSBiZXR3ZWVuIHByb2plY3Rpb25zIHdpdGggZXF1YWwgbWVhbmluZy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PFByb2plY3Rpb24+fSBwcm9qZWN0aW9ucyBQcm9qZWN0aW9ucy5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZEVxdWl2YWxlbnRQcm9qZWN0aW9ucyhwcm9qZWN0aW9ucykge1xuICBhZGRQcm9qZWN0aW9ucyhwcm9qZWN0aW9ucyk7XG4gIHByb2plY3Rpb25zLmZvckVhY2goZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgIHByb2plY3Rpb25zLmZvckVhY2goZnVuY3Rpb24gKGRlc3RpbmF0aW9uKSB7XG4gICAgICBpZiAoc291cmNlICE9PSBkZXN0aW5hdGlvbikge1xuICAgICAgICBhZGRUcmFuc2Zvcm1GdW5jKHNvdXJjZSwgZGVzdGluYXRpb24sIGNsb25lVHJhbnNmb3JtKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59XG5cbi8qKlxuICogUmVnaXN0ZXJzIHRyYW5zZm9ybWF0aW9uIGZ1bmN0aW9ucyB0byBjb252ZXJ0IGNvb3JkaW5hdGVzIGluIGFueSBwcm9qZWN0aW9uXG4gKiBpbiBwcm9qZWN0aW9uMSB0byBhbnkgcHJvamVjdGlvbiBpbiBwcm9qZWN0aW9uMi5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PFByb2plY3Rpb24+fSBwcm9qZWN0aW9uczEgUHJvamVjdGlvbnMgd2l0aCBlcXVhbFxuICogICAgIG1lYW5pbmcuXG4gKiBAcGFyYW0ge0FycmF5PFByb2plY3Rpb24+fSBwcm9qZWN0aW9uczIgUHJvamVjdGlvbnMgd2l0aCBlcXVhbFxuICogICAgIG1lYW5pbmcuXG4gKiBAcGFyYW0ge1RyYW5zZm9ybUZ1bmN0aW9ufSBmb3J3YXJkVHJhbnNmb3JtIFRyYW5zZm9ybWF0aW9uIGZyb20gYW55XG4gKiAgIHByb2plY3Rpb24gaW4gcHJvamVjdGlvbjEgdG8gYW55IHByb2plY3Rpb24gaW4gcHJvamVjdGlvbjIuXG4gKiBAcGFyYW0ge1RyYW5zZm9ybUZ1bmN0aW9ufSBpbnZlcnNlVHJhbnNmb3JtIFRyYW5zZm9ybSBmcm9tIGFueSBwcm9qZWN0aW9uXG4gKiAgIGluIHByb2plY3Rpb24yIHRvIGFueSBwcm9qZWN0aW9uIGluIHByb2plY3Rpb24xLi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZEVxdWl2YWxlbnRUcmFuc2Zvcm1zKFxuICBwcm9qZWN0aW9uczEsXG4gIHByb2plY3Rpb25zMixcbiAgZm9yd2FyZFRyYW5zZm9ybSxcbiAgaW52ZXJzZVRyYW5zZm9ybVxuKSB7XG4gIHByb2plY3Rpb25zMS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9qZWN0aW9uMSkge1xuICAgIHByb2plY3Rpb25zMi5mb3JFYWNoKGZ1bmN0aW9uIChwcm9qZWN0aW9uMikge1xuICAgICAgYWRkVHJhbnNmb3JtRnVuYyhwcm9qZWN0aW9uMSwgcHJvamVjdGlvbjIsIGZvcndhcmRUcmFuc2Zvcm0pO1xuICAgICAgYWRkVHJhbnNmb3JtRnVuYyhwcm9qZWN0aW9uMiwgcHJvamVjdGlvbjEsIGludmVyc2VUcmFuc2Zvcm0pO1xuICAgIH0pO1xuICB9KTtcbn1cblxuLyoqXG4gKiBDbGVhciBhbGwgY2FjaGVkIHByb2plY3Rpb25zIGFuZCB0cmFuc2Zvcm1zLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xlYXJBbGxQcm9qZWN0aW9ucygpIHtcbiAgY2xlYXJQcm9qKCk7XG4gIGNsZWFyVHJhbnNmb3JtRnVuY3MoKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1Byb2plY3Rpb258c3RyaW5nfHVuZGVmaW5lZH0gcHJvamVjdGlvbiBQcm9qZWN0aW9uLlxuICogQHBhcmFtIHtzdHJpbmd9IGRlZmF1bHRDb2RlIERlZmF1bHQgY29kZS5cbiAqIEByZXR1cm4ge1Byb2plY3Rpb259IFByb2plY3Rpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVQcm9qZWN0aW9uKHByb2plY3Rpb24sIGRlZmF1bHRDb2RlKSB7XG4gIGlmICghcHJvamVjdGlvbikge1xuICAgIHJldHVybiBnZXQoZGVmYXVsdENvZGUpO1xuICB9XG4gIGlmICh0eXBlb2YgcHJvamVjdGlvbiA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZ2V0KHByb2plY3Rpb24pO1xuICB9XG4gIHJldHVybiAvKiogQHR5cGUge1Byb2plY3Rpb259ICovIChwcm9qZWN0aW9uKTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEge0BsaW5rIG1vZHVsZTpvbC9wcm9qflRyYW5zZm9ybUZ1bmN0aW9ufSBmcm9tIGEgc2ltcGxlIDJEIGNvb3JkaW5hdGUgdHJhbnNmb3JtXG4gKiBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oaW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGUpOiBpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gY29vcmRUcmFuc2Zvcm0gQ29vcmRpbmF0ZVxuICogICAgIHRyYW5zZm9ybS5cbiAqIEByZXR1cm4ge1RyYW5zZm9ybUZ1bmN0aW9ufSBUcmFuc2Zvcm0gZnVuY3Rpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVUcmFuc2Zvcm1Gcm9tQ29vcmRpbmF0ZVRyYW5zZm9ybShjb29yZFRyYW5zZm9ybSkge1xuICByZXR1cm4gKFxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gaW5wdXQgSW5wdXQuXG4gICAgICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBbb3V0cHV0XSBPdXRwdXQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtkaW1lbnNpb25dIERpbWVuc2lvbi5cbiAgICAgKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBPdXRwdXQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gKGlucHV0LCBvdXRwdXQsIGRpbWVuc2lvbikge1xuICAgICAgY29uc3QgbGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xuICAgICAgZGltZW5zaW9uID0gZGltZW5zaW9uICE9PSB1bmRlZmluZWQgPyBkaW1lbnNpb24gOiAyO1xuICAgICAgb3V0cHV0ID0gb3V0cHV0ICE9PSB1bmRlZmluZWQgPyBvdXRwdXQgOiBuZXcgQXJyYXkobGVuZ3RoKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IGRpbWVuc2lvbikge1xuICAgICAgICBjb25zdCBwb2ludCA9IGNvb3JkVHJhbnNmb3JtKGlucHV0LnNsaWNlKGksIGkgKyBkaW1lbnNpb24pKTtcbiAgICAgICAgY29uc3QgcG9pbnRMZW5ndGggPSBwb2ludC5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IGogPSAwLCBqaiA9IGRpbWVuc2lvbjsgaiA8IGpqOyArK2opIHtcbiAgICAgICAgICBvdXRwdXRbaSArIGpdID0gaiA+PSBwb2ludExlbmd0aCA/IGlucHV0W2kgKyBqXSA6IHBvaW50W2pdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH1cbiAgKTtcbn1cblxuLyoqXG4gKiBSZWdpc3RlcnMgY29vcmRpbmF0ZSB0cmFuc2Zvcm0gZnVuY3Rpb25zIHRvIGNvbnZlcnQgY29vcmRpbmF0ZXMgYmV0d2VlbiB0aGVcbiAqIHNvdXJjZSBwcm9qZWN0aW9uIGFuZCB0aGUgZGVzdGluYXRpb24gcHJvamVjdGlvbi5cbiAqIFRoZSBmb3J3YXJkIGFuZCBpbnZlcnNlIGZ1bmN0aW9ucyBjb252ZXJ0IGNvb3JkaW5hdGUgcGFpcnM7IHRoaXMgZnVuY3Rpb25cbiAqIGNvbnZlcnRzIHRoZXNlIGludG8gdGhlIGZ1bmN0aW9ucyB1c2VkIGludGVybmFsbHkgd2hpY2ggYWxzbyBoYW5kbGVcbiAqIGV4dGVudHMgYW5kIGNvb3JkaW5hdGUgYXJyYXlzLlxuICpcbiAqIEBwYXJhbSB7UHJvamVjdGlvbkxpa2V9IHNvdXJjZSBTb3VyY2UgcHJvamVjdGlvbi5cbiAqIEBwYXJhbSB7UHJvamVjdGlvbkxpa2V9IGRlc3RpbmF0aW9uIERlc3RpbmF0aW9uIHByb2plY3Rpb24uXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKGltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlKTogaW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGZvcndhcmQgVGhlIGZvcndhcmQgdHJhbnNmb3JtXG4gKiAgICAgZnVuY3Rpb24gKHRoYXQgaXMsIGZyb20gdGhlIHNvdXJjZSBwcm9qZWN0aW9uIHRvIHRoZSBkZXN0aW5hdGlvblxuICogICAgIHByb2plY3Rpb24pIHRoYXQgdGFrZXMgYSB7QGxpbmsgbW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZX0gYXMgYXJndW1lbnQgYW5kIHJldHVybnNcbiAqICAgICB0aGUgdHJhbnNmb3JtZWQge0BsaW5rIG1vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGV9LlxuICogQHBhcmFtIHtmdW5jdGlvbihpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZSk6IGltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBpbnZlcnNlIFRoZSBpbnZlcnNlIHRyYW5zZm9ybVxuICogICAgIGZ1bmN0aW9uICh0aGF0IGlzLCBmcm9tIHRoZSBkZXN0aW5hdGlvbiBwcm9qZWN0aW9uIHRvIHRoZSBzb3VyY2VcbiAqICAgICBwcm9qZWN0aW9uKSB0aGF0IHRha2VzIGEge0BsaW5rIG1vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGV9IGFzIGFyZ3VtZW50IGFuZCByZXR1cm5zXG4gKiAgICAgdGhlIHRyYW5zZm9ybWVkIHtAbGluayBtb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlfS4gSWYgdGhlIHRyYW5zZm9ybSBmdW5jdGlvbiBjYW4gb25seVxuICogICAgIHRyYW5zZm9ybSBsZXNzIGRpbWVuc2lvbnMgdGhhbiB0aGUgaW5wdXQgY29vcmRpbmF0ZSwgaXQgaXMgc3VwcG9zZWVkIHRvIHJldHVybiBhIGNvb3JkaW5hdGVcbiAqICAgICB3aXRoIG9ubHkgdGhlIGxlbmd0aCBpdCBjYW4gdHJhbnNmb3JtLiBUaGUgb3RoZXIgZGltZW5zaW9ucyB3aWxsIGJlIHRha2VuIHVuY2hhbmdlZCBmcm9tIHRoZVxuICogICAgIHNvdXJjZS5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZENvb3JkaW5hdGVUcmFuc2Zvcm1zKHNvdXJjZSwgZGVzdGluYXRpb24sIGZvcndhcmQsIGludmVyc2UpIHtcbiAgY29uc3Qgc291cmNlUHJvaiA9IGdldChzb3VyY2UpO1xuICBjb25zdCBkZXN0UHJvaiA9IGdldChkZXN0aW5hdGlvbik7XG4gIGFkZFRyYW5zZm9ybUZ1bmMoXG4gICAgc291cmNlUHJvaixcbiAgICBkZXN0UHJvaixcbiAgICBjcmVhdGVUcmFuc2Zvcm1Gcm9tQ29vcmRpbmF0ZVRyYW5zZm9ybShmb3J3YXJkKVxuICApO1xuICBhZGRUcmFuc2Zvcm1GdW5jKFxuICAgIGRlc3RQcm9qLFxuICAgIHNvdXJjZVByb2osXG4gICAgY3JlYXRlVHJhbnNmb3JtRnJvbUNvb3JkaW5hdGVUcmFuc2Zvcm0oaW52ZXJzZSlcbiAgKTtcbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm1zIGEgY29vcmRpbmF0ZSBmcm9tIGxvbmdpdHVkZS9sYXRpdHVkZSB0byBhIGRpZmZlcmVudCBwcm9qZWN0aW9uLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gY29vcmRpbmF0ZSBDb29yZGluYXRlIGFzIGxvbmdpdHVkZSBhbmQgbGF0aXR1ZGUsIGkuZS5cbiAqICAgICBhbiBhcnJheSB3aXRoIGxvbmdpdHVkZSBhcyAxc3QgYW5kIGxhdGl0dWRlIGFzIDJuZCBlbGVtZW50LlxuICogQHBhcmFtIHtQcm9qZWN0aW9uTGlrZX0gW3Byb2plY3Rpb25dIFRhcmdldCBwcm9qZWN0aW9uLiBUaGVcbiAqICAgICBkZWZhdWx0IGlzIFdlYiBNZXJjYXRvciwgaS5lLiAnRVBTRzozODU3Jy5cbiAqIEByZXR1cm4ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBDb29yZGluYXRlIHByb2plY3RlZCB0byB0aGUgdGFyZ2V0IHByb2plY3Rpb24uXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tTG9uTGF0KGNvb3JkaW5hdGUsIHByb2plY3Rpb24pIHtcbiAgZGlzYWJsZUNvb3JkaW5hdGVXYXJuaW5nKCk7XG4gIHJldHVybiB0cmFuc2Zvcm0oXG4gICAgY29vcmRpbmF0ZSxcbiAgICAnRVBTRzo0MzI2JyxcbiAgICBwcm9qZWN0aW9uICE9PSB1bmRlZmluZWQgPyBwcm9qZWN0aW9uIDogJ0VQU0c6Mzg1NydcbiAgKTtcbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm1zIGEgY29vcmRpbmF0ZSB0byBsb25naXR1ZGUvbGF0aXR1ZGUuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBjb29yZGluYXRlIFByb2plY3RlZCBjb29yZGluYXRlLlxuICogQHBhcmFtIHtQcm9qZWN0aW9uTGlrZX0gW3Byb2plY3Rpb25dIFByb2plY3Rpb24gb2YgdGhlIGNvb3JkaW5hdGUuXG4gKiAgICAgVGhlIGRlZmF1bHQgaXMgV2ViIE1lcmNhdG9yLCBpLmUuICdFUFNHOjM4NTcnLlxuICogQHJldHVybiB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IENvb3JkaW5hdGUgYXMgbG9uZ2l0dWRlIGFuZCBsYXRpdHVkZSwgaS5lLiBhbiBhcnJheVxuICogICAgIHdpdGggbG9uZ2l0dWRlIGFzIDFzdCBhbmQgbGF0aXR1ZGUgYXMgMm5kIGVsZW1lbnQuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0xvbkxhdChjb29yZGluYXRlLCBwcm9qZWN0aW9uKSB7XG4gIGNvbnN0IGxvbkxhdCA9IHRyYW5zZm9ybShcbiAgICBjb29yZGluYXRlLFxuICAgIHByb2plY3Rpb24gIT09IHVuZGVmaW5lZCA/IHByb2plY3Rpb24gOiAnRVBTRzozODU3JyxcbiAgICAnRVBTRzo0MzI2J1xuICApO1xuICBjb25zdCBsb24gPSBsb25MYXRbMF07XG4gIGlmIChsb24gPCAtMTgwIHx8IGxvbiA+IDE4MCkge1xuICAgIGxvbkxhdFswXSA9IG1vZHVsbyhsb24gKyAxODAsIDM2MCkgLSAxODA7XG4gIH1cbiAgcmV0dXJuIGxvbkxhdDtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgdHdvIHByb2plY3Rpb25zIGFyZSB0aGUgc2FtZSwgdGhhdCBpcyBldmVyeSBjb29yZGluYXRlIGluIG9uZVxuICogcHJvamVjdGlvbiBkb2VzIHJlcHJlc2VudCB0aGUgc2FtZSBnZW9ncmFwaGljIHBvaW50IGFzIHRoZSBzYW1lIGNvb3JkaW5hdGUgaW5cbiAqIHRoZSBvdGhlciBwcm9qZWN0aW9uLlxuICpcbiAqIEBwYXJhbSB7UHJvamVjdGlvbn0gcHJvamVjdGlvbjEgUHJvamVjdGlvbiAxLlxuICogQHBhcmFtIHtQcm9qZWN0aW9ufSBwcm9qZWN0aW9uMiBQcm9qZWN0aW9uIDIuXG4gKiBAcmV0dXJuIHtib29sZWFufSBFcXVpdmFsZW50LlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gZXF1aXZhbGVudChwcm9qZWN0aW9uMSwgcHJvamVjdGlvbjIpIHtcbiAgaWYgKHByb2plY3Rpb24xID09PSBwcm9qZWN0aW9uMikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGNvbnN0IGVxdWFsVW5pdHMgPSBwcm9qZWN0aW9uMS5nZXRVbml0cygpID09PSBwcm9qZWN0aW9uMi5nZXRVbml0cygpO1xuICBpZiAocHJvamVjdGlvbjEuZ2V0Q29kZSgpID09PSBwcm9qZWN0aW9uMi5nZXRDb2RlKCkpIHtcbiAgICByZXR1cm4gZXF1YWxVbml0cztcbiAgfVxuICBjb25zdCB0cmFuc2Zvcm1GdW5jID0gZ2V0VHJhbnNmb3JtRnJvbVByb2plY3Rpb25zKHByb2plY3Rpb24xLCBwcm9qZWN0aW9uMik7XG4gIHJldHVybiB0cmFuc2Zvcm1GdW5jID09PSBjbG9uZVRyYW5zZm9ybSAmJiBlcXVhbFVuaXRzO1xufVxuXG4vKipcbiAqIFNlYXJjaGVzIGluIHRoZSBsaXN0IG9mIHRyYW5zZm9ybSBmdW5jdGlvbnMgZm9yIHRoZSBmdW5jdGlvbiBmb3IgY29udmVydGluZ1xuICogY29vcmRpbmF0ZXMgZnJvbSB0aGUgc291cmNlIHByb2plY3Rpb24gdG8gdGhlIGRlc3RpbmF0aW9uIHByb2plY3Rpb24uXG4gKlxuICogQHBhcmFtIHtQcm9qZWN0aW9ufSBzb3VyY2VQcm9qZWN0aW9uIFNvdXJjZSBQcm9qZWN0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7UHJvamVjdGlvbn0gZGVzdGluYXRpb25Qcm9qZWN0aW9uIERlc3RpbmF0aW9uIFByb2plY3Rpb25cbiAqICAgICBvYmplY3QuXG4gKiBAcmV0dXJuIHtUcmFuc2Zvcm1GdW5jdGlvbn0gVHJhbnNmb3JtIGZ1bmN0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0VHJhbnNmb3JtRnJvbVByb2plY3Rpb25zKFxuICBzb3VyY2VQcm9qZWN0aW9uLFxuICBkZXN0aW5hdGlvblByb2plY3Rpb25cbikge1xuICBjb25zdCBzb3VyY2VDb2RlID0gc291cmNlUHJvamVjdGlvbi5nZXRDb2RlKCk7XG4gIGNvbnN0IGRlc3RpbmF0aW9uQ29kZSA9IGRlc3RpbmF0aW9uUHJvamVjdGlvbi5nZXRDb2RlKCk7XG4gIGxldCB0cmFuc2Zvcm1GdW5jID0gZ2V0VHJhbnNmb3JtRnVuYyhzb3VyY2VDb2RlLCBkZXN0aW5hdGlvbkNvZGUpO1xuICBpZiAoIXRyYW5zZm9ybUZ1bmMpIHtcbiAgICB0cmFuc2Zvcm1GdW5jID0gaWRlbnRpdHlUcmFuc2Zvcm07XG4gIH1cbiAgcmV0dXJuIHRyYW5zZm9ybUZ1bmM7XG59XG5cbi8qKlxuICogR2l2ZW4gdGhlIHByb2plY3Rpb24tbGlrZSBvYmplY3RzLCBzZWFyY2hlcyBmb3IgYSB0cmFuc2Zvcm1hdGlvblxuICogZnVuY3Rpb24gdG8gY29udmVydCBhIGNvb3JkaW5hdGVzIGFycmF5IGZyb20gdGhlIHNvdXJjZSBwcm9qZWN0aW9uIHRvIHRoZVxuICogZGVzdGluYXRpb24gcHJvamVjdGlvbi5cbiAqXG4gKiBAcGFyYW0ge1Byb2plY3Rpb25MaWtlfSBzb3VyY2UgU291cmNlLlxuICogQHBhcmFtIHtQcm9qZWN0aW9uTGlrZX0gZGVzdGluYXRpb24gRGVzdGluYXRpb24uXG4gKiBAcmV0dXJuIHtUcmFuc2Zvcm1GdW5jdGlvbn0gVHJhbnNmb3JtIGZ1bmN0aW9uLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0VHJhbnNmb3JtKHNvdXJjZSwgZGVzdGluYXRpb24pIHtcbiAgY29uc3Qgc291cmNlUHJvamVjdGlvbiA9IGdldChzb3VyY2UpO1xuICBjb25zdCBkZXN0aW5hdGlvblByb2plY3Rpb24gPSBnZXQoZGVzdGluYXRpb24pO1xuICByZXR1cm4gZ2V0VHJhbnNmb3JtRnJvbVByb2plY3Rpb25zKHNvdXJjZVByb2plY3Rpb24sIGRlc3RpbmF0aW9uUHJvamVjdGlvbik7XG59XG5cbi8qKlxuICogVHJhbnNmb3JtcyBhIGNvb3JkaW5hdGUgZnJvbSBzb3VyY2UgcHJvamVjdGlvbiB0byBkZXN0aW5hdGlvbiBwcm9qZWN0aW9uLlxuICogVGhpcyByZXR1cm5zIGEgbmV3IGNvb3JkaW5hdGUgKGFuZCBkb2VzIG5vdCBtb2RpZnkgdGhlIG9yaWdpbmFsKS5cbiAqXG4gKiBTZWUge0BsaW5rIG1vZHVsZTpvbC9wcm9qLnRyYW5zZm9ybUV4dGVudH0gZm9yIGV4dGVudCB0cmFuc2Zvcm1hdGlvbi5cbiAqIFNlZSB0aGUgdHJhbnNmb3JtIG1ldGhvZCBvZiB7QGxpbmsgbW9kdWxlOm9sL2dlb20vR2VvbWV0cnl+R2VvbWV0cnl9IGFuZCBpdHNcbiAqIHN1YmNsYXNzZXMgZm9yIGdlb21ldHJ5IHRyYW5zZm9ybXMuXG4gKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gY29vcmRpbmF0ZSBDb29yZGluYXRlLlxuICogQHBhcmFtIHtQcm9qZWN0aW9uTGlrZX0gc291cmNlIFNvdXJjZSBwcm9qZWN0aW9uLWxpa2UuXG4gKiBAcGFyYW0ge1Byb2plY3Rpb25MaWtlfSBkZXN0aW5hdGlvbiBEZXN0aW5hdGlvbiBwcm9qZWN0aW9uLWxpa2UuXG4gKiBAcmV0dXJuIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gQ29vcmRpbmF0ZS5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZm9ybShjb29yZGluYXRlLCBzb3VyY2UsIGRlc3RpbmF0aW9uKSB7XG4gIGNvbnN0IHRyYW5zZm9ybUZ1bmMgPSBnZXRUcmFuc2Zvcm0oc291cmNlLCBkZXN0aW5hdGlvbik7XG4gIHJldHVybiB0cmFuc2Zvcm1GdW5jKGNvb3JkaW5hdGUsIHVuZGVmaW5lZCwgY29vcmRpbmF0ZS5sZW5ndGgpO1xufVxuXG4vKipcbiAqIFRyYW5zZm9ybXMgYW4gZXh0ZW50IGZyb20gc291cmNlIHByb2plY3Rpb24gdG8gZGVzdGluYXRpb24gcHJvamVjdGlvbi4gIFRoaXNcbiAqIHJldHVybnMgYSBuZXcgZXh0ZW50IChhbmQgZG9lcyBub3QgbW9kaWZ5IHRoZSBvcmlnaW5hbCkuXG4gKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL2V4dGVudC5qc1wiKS5FeHRlbnR9IGV4dGVudCBUaGUgZXh0ZW50IHRvIHRyYW5zZm9ybS5cbiAqIEBwYXJhbSB7UHJvamVjdGlvbkxpa2V9IHNvdXJjZSBTb3VyY2UgcHJvamVjdGlvbi1saWtlLlxuICogQHBhcmFtIHtQcm9qZWN0aW9uTGlrZX0gZGVzdGluYXRpb24gRGVzdGluYXRpb24gcHJvamVjdGlvbi1saWtlLlxuICogQHBhcmFtIHtudW1iZXJ9IFtzdG9wc10gTnVtYmVyIG9mIHN0b3BzIHBlciBzaWRlIHVzZWQgZm9yIHRoZSB0cmFuc2Zvcm0uXG4gKiBCeSBkZWZhdWx0IG9ubHkgdGhlIGNvcm5lcnMgYXJlIHVzZWQuXG4gKiBAcmV0dXJuIHtpbXBvcnQoXCIuL2V4dGVudC5qc1wiKS5FeHRlbnR9IFRoZSB0cmFuc2Zvcm1lZCBleHRlbnQuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1FeHRlbnQoZXh0ZW50LCBzb3VyY2UsIGRlc3RpbmF0aW9uLCBzdG9wcykge1xuICBjb25zdCB0cmFuc2Zvcm1GdW5jID0gZ2V0VHJhbnNmb3JtKHNvdXJjZSwgZGVzdGluYXRpb24pO1xuICByZXR1cm4gYXBwbHlUcmFuc2Zvcm0oZXh0ZW50LCB0cmFuc2Zvcm1GdW5jLCB1bmRlZmluZWQsIHN0b3BzKTtcbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSBnaXZlbiBwb2ludCB0byB0aGUgZGVzdGluYXRpb24gcHJvamVjdGlvbi5cbiAqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBwb2ludCBQb2ludC5cbiAqIEBwYXJhbSB7UHJvamVjdGlvbn0gc291cmNlUHJvamVjdGlvbiBTb3VyY2UgcHJvamVjdGlvbi5cbiAqIEBwYXJhbSB7UHJvamVjdGlvbn0gZGVzdGluYXRpb25Qcm9qZWN0aW9uIERlc3RpbmF0aW9uIHByb2plY3Rpb24uXG4gKiBAcmV0dXJuIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gUG9pbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1XaXRoUHJvamVjdGlvbnMoXG4gIHBvaW50LFxuICBzb3VyY2VQcm9qZWN0aW9uLFxuICBkZXN0aW5hdGlvblByb2plY3Rpb25cbikge1xuICBjb25zdCB0cmFuc2Zvcm1GdW5jID0gZ2V0VHJhbnNmb3JtRnJvbVByb2plY3Rpb25zKFxuICAgIHNvdXJjZVByb2plY3Rpb24sXG4gICAgZGVzdGluYXRpb25Qcm9qZWN0aW9uXG4gICk7XG4gIHJldHVybiB0cmFuc2Zvcm1GdW5jKHBvaW50KTtcbn1cblxuLyoqXG4gKiBAdHlwZSB7UHJvamVjdGlvbnxudWxsfVxuICovXG5sZXQgdXNlclByb2plY3Rpb24gPSBudWxsO1xuXG4vKipcbiAqIFNldCB0aGUgcHJvamVjdGlvbiBmb3IgY29vcmRpbmF0ZXMgc3VwcGxpZWQgZnJvbSBhbmQgcmV0dXJuZWQgYnkgQVBJIG1ldGhvZHMuXG4gKiBUaGlzIGluY2x1ZGVzIGFsbCBBUEkgbWV0aG9kcyBleGNlcHQgZm9yIHRob3NlIGludGVyYWN0aW5nIHdpdGggdGlsZSBncmlkcyxcbiAqIHBsdXMge0BsaW5rIGltcG9ydChcIi4vTWFwLmpzXCIpLkZyYW1lU3RhdGV9IGFuZCB7QGxpbmsgaW1wb3J0KFwiLi9WaWV3LmpzXCIpLlN0YXRlfS5cbiAqIEBwYXJhbSB7UHJvamVjdGlvbkxpa2V9IHByb2plY3Rpb24gVGhlIHVzZXIgcHJvamVjdGlvbi5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldFVzZXJQcm9qZWN0aW9uKHByb2plY3Rpb24pIHtcbiAgdXNlclByb2plY3Rpb24gPSBnZXQocHJvamVjdGlvbik7XG59XG5cbi8qKlxuICogQ2xlYXIgdGhlIHVzZXIgcHJvamVjdGlvbiBpZiBzZXQuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbGVhclVzZXJQcm9qZWN0aW9uKCkge1xuICB1c2VyUHJvamVjdGlvbiA9IG51bGw7XG59XG5cbi8qKlxuICogR2V0IHRoZSBwcm9qZWN0aW9uIGZvciBjb29yZGluYXRlcyBzdXBwbGllZCBmcm9tIGFuZCByZXR1cm5lZCBieSBBUEkgbWV0aG9kcy5cbiAqIEByZXR1cm4ge1Byb2plY3Rpb258bnVsbH0gVGhlIHVzZXIgcHJvamVjdGlvbiAob3IgbnVsbCBpZiBub3Qgc2V0KS5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFVzZXJQcm9qZWN0aW9uKCkge1xuICByZXR1cm4gdXNlclByb2plY3Rpb247XG59XG5cbi8qKlxuICogVXNlIGdlb2dyYXBoaWMgY29vcmRpbmF0ZXMgKFdHUy04NCBkYXR1bSkgaW4gQVBJIG1ldGhvZHMuXG4gKiBUaGlzIGluY2x1ZGVzIGFsbCBBUEkgbWV0aG9kcyBleGNlcHQgZm9yIHRob3NlIGludGVyYWN0aW5nIHdpdGggdGlsZSBncmlkcyxcbiAqIHBsdXMge0BsaW5rIGltcG9ydChcIi4vTWFwLmpzXCIpLkZyYW1lU3RhdGV9IGFuZCB7QGxpbmsgaW1wb3J0KFwiLi9WaWV3LmpzXCIpLlN0YXRlfS5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUdlb2dyYXBoaWMoKSB7XG4gIHNldFVzZXJQcm9qZWN0aW9uKCdFUFNHOjQzMjYnKTtcbn1cblxuLyoqXG4gKiBSZXR1cm4gYSBjb29yZGluYXRlIHRyYW5zZm9ybWVkIGludG8gdGhlIHVzZXIgcHJvamVjdGlvbi4gIElmIG5vIHVzZXIgcHJvamVjdGlvblxuICogaXMgc2V0LCB0aGUgb3JpZ2luYWwgY29vcmRpbmF0ZSBpcyByZXR1cm5lZC5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gY29vcmRpbmF0ZSBJbnB1dCBjb29yZGluYXRlLlxuICogQHBhcmFtIHtQcm9qZWN0aW9uTGlrZX0gc291cmNlUHJvamVjdGlvbiBUaGUgaW5wdXQgY29vcmRpbmF0ZSBwcm9qZWN0aW9uLlxuICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gVGhlIGlucHV0IGNvb3JkaW5hdGUgaW4gdGhlIHVzZXIgcHJvamVjdGlvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvVXNlckNvb3JkaW5hdGUoY29vcmRpbmF0ZSwgc291cmNlUHJvamVjdGlvbikge1xuICBpZiAoIXVzZXJQcm9qZWN0aW9uKSB7XG4gICAgcmV0dXJuIGNvb3JkaW5hdGU7XG4gIH1cbiAgcmV0dXJuIHRyYW5zZm9ybShjb29yZGluYXRlLCBzb3VyY2VQcm9qZWN0aW9uLCB1c2VyUHJvamVjdGlvbik7XG59XG5cbi8qKlxuICogUmV0dXJuIGEgY29vcmRpbmF0ZSB0cmFuc2Zvcm1lZCBmcm9tIHRoZSB1c2VyIHByb2plY3Rpb24uICBJZiBubyB1c2VyIHByb2plY3Rpb25cbiAqIGlzIHNldCwgdGhlIG9yaWdpbmFsIGNvb3JkaW5hdGUgaXMgcmV0dXJuZWQuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGNvb3JkaW5hdGUgSW5wdXQgY29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7UHJvamVjdGlvbkxpa2V9IGRlc3RQcm9qZWN0aW9uIFRoZSBkZXN0aW5hdGlvbiBwcm9qZWN0aW9uLlxuICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gVGhlIGlucHV0IGNvb3JkaW5hdGUgdHJhbnNmb3JtZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tVXNlckNvb3JkaW5hdGUoY29vcmRpbmF0ZSwgZGVzdFByb2plY3Rpb24pIHtcbiAgaWYgKCF1c2VyUHJvamVjdGlvbikge1xuICAgIGlmIChcbiAgICAgIHNob3dDb29yZGluYXRlV2FybmluZyAmJlxuICAgICAgIWVxdWFscyhjb29yZGluYXRlLCBbMCwgMF0pICYmXG4gICAgICBjb29yZGluYXRlWzBdID49IC0xODAgJiZcbiAgICAgIGNvb3JkaW5hdGVbMF0gPD0gMTgwICYmXG4gICAgICBjb29yZGluYXRlWzFdID49IC05MCAmJlxuICAgICAgY29vcmRpbmF0ZVsxXSA8PSA5MFxuICAgICkge1xuICAgICAgc2hvd0Nvb3JkaW5hdGVXYXJuaW5nID0gZmFsc2U7XG4gICAgICB3YXJuKFxuICAgICAgICAnQ2FsbCB1c2VHZW9ncmFwaGljKCkgZnJvbSBvbC9wcm9qIG9uY2UgdG8gd29yayB3aXRoIFtsb25naXR1ZGUsIGxhdGl0dWRlXSBjb29yZGluYXRlcy4nXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gY29vcmRpbmF0ZTtcbiAgfVxuICByZXR1cm4gdHJhbnNmb3JtKGNvb3JkaW5hdGUsIHVzZXJQcm9qZWN0aW9uLCBkZXN0UHJvamVjdGlvbik7XG59XG5cbi8qKlxuICogUmV0dXJuIGFuIGV4dGVudCB0cmFuc2Zvcm1lZCBpbnRvIHRoZSB1c2VyIHByb2plY3Rpb24uICBJZiBubyB1c2VyIHByb2plY3Rpb25cbiAqIGlzIHNldCwgdGhlIG9yaWdpbmFsIGV4dGVudCBpcyByZXR1cm5lZC5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9leHRlbnQuanNcIikuRXh0ZW50fSBleHRlbnQgSW5wdXQgZXh0ZW50LlxuICogQHBhcmFtIHtQcm9qZWN0aW9uTGlrZX0gc291cmNlUHJvamVjdGlvbiBUaGUgaW5wdXQgZXh0ZW50IHByb2plY3Rpb24uXG4gKiBAcmV0dXJuIHtpbXBvcnQoXCIuL2V4dGVudC5qc1wiKS5FeHRlbnR9IFRoZSBpbnB1dCBleHRlbnQgaW4gdGhlIHVzZXIgcHJvamVjdGlvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvVXNlckV4dGVudChleHRlbnQsIHNvdXJjZVByb2plY3Rpb24pIHtcbiAgaWYgKCF1c2VyUHJvamVjdGlvbikge1xuICAgIHJldHVybiBleHRlbnQ7XG4gIH1cbiAgcmV0dXJuIHRyYW5zZm9ybUV4dGVudChleHRlbnQsIHNvdXJjZVByb2plY3Rpb24sIHVzZXJQcm9qZWN0aW9uKTtcbn1cblxuLyoqXG4gKiBSZXR1cm4gYW4gZXh0ZW50IHRyYW5zZm9ybWVkIGZyb20gdGhlIHVzZXIgcHJvamVjdGlvbi4gIElmIG5vIHVzZXIgcHJvamVjdGlvblxuICogaXMgc2V0LCB0aGUgb3JpZ2luYWwgZXh0ZW50IGlzIHJldHVybmVkLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL2V4dGVudC5qc1wiKS5FeHRlbnR9IGV4dGVudCBJbnB1dCBleHRlbnQuXG4gKiBAcGFyYW0ge1Byb2plY3Rpb25MaWtlfSBkZXN0UHJvamVjdGlvbiBUaGUgZGVzdGluYXRpb24gcHJvamVjdGlvbi5cbiAqIEByZXR1cm4ge2ltcG9ydChcIi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gVGhlIGlucHV0IGV4dGVudCB0cmFuc2Zvcm1lZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21Vc2VyRXh0ZW50KGV4dGVudCwgZGVzdFByb2plY3Rpb24pIHtcbiAgaWYgKCF1c2VyUHJvamVjdGlvbikge1xuICAgIHJldHVybiBleHRlbnQ7XG4gIH1cbiAgcmV0dXJuIHRyYW5zZm9ybUV4dGVudChleHRlbnQsIHVzZXJQcm9qZWN0aW9uLCBkZXN0UHJvamVjdGlvbik7XG59XG5cbi8qKlxuICogUmV0dXJuIHRoZSByZXNvbHV0aW9uIGluIHVzZXIgcHJvamVjdGlvbiB1bml0cyBwZXIgcGl4ZWwuIElmIG5vIHVzZXIgcHJvamVjdGlvblxuICogaXMgc2V0LCBvciBzb3VyY2Ugb3IgdXNlciBwcm9qZWN0aW9uIGFyZSBtaXNzaW5nIHVuaXRzLCB0aGUgb3JpZ2luYWwgcmVzb2x1dGlvblxuICogaXMgcmV0dXJuZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gcmVzb2x1dGlvbiBSZXNvbHV0aW9uIGluIGlucHV0IHByb2plY3Rpb24gdW5pdHMgcGVyIHBpeGVsLlxuICogQHBhcmFtIHtQcm9qZWN0aW9uTGlrZX0gc291cmNlUHJvamVjdGlvbiBUaGUgaW5wdXQgcHJvamVjdGlvbi5cbiAqIEByZXR1cm4ge251bWJlcn0gUmVzb2x1dGlvbiBpbiB1c2VyIHByb2plY3Rpb24gdW5pdHMgcGVyIHBpeGVsLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9Vc2VyUmVzb2x1dGlvbihyZXNvbHV0aW9uLCBzb3VyY2VQcm9qZWN0aW9uKSB7XG4gIGlmICghdXNlclByb2plY3Rpb24pIHtcbiAgICByZXR1cm4gcmVzb2x1dGlvbjtcbiAgfVxuICBjb25zdCBzb3VyY2VVbml0cyA9IGdldChzb3VyY2VQcm9qZWN0aW9uKS5nZXRVbml0cygpO1xuICBjb25zdCB1c2VyVW5pdHMgPSB1c2VyUHJvamVjdGlvbi5nZXRVbml0cygpO1xuICByZXR1cm4gc291cmNlVW5pdHMgJiYgdXNlclVuaXRzXG4gICAgPyAocmVzb2x1dGlvbiAqIE1FVEVSU19QRVJfVU5JVFtzb3VyY2VVbml0c10pIC8gTUVURVJTX1BFUl9VTklUW3VzZXJVbml0c11cbiAgICA6IHJlc29sdXRpb247XG59XG5cbi8qKlxuICogUmV0dXJuIHRoZSByZXNvbHV0aW9uIGluIHVzZXIgcHJvamVjdGlvbiB1bml0cyBwZXIgcGl4ZWwuIElmIG5vIHVzZXIgcHJvamVjdGlvblxuICogaXMgc2V0LCBvciBzb3VyY2Ugb3IgdXNlciBwcm9qZWN0aW9uIGFyZSBtaXNzaW5nIHVuaXRzLCB0aGUgb3JpZ2luYWwgcmVzb2x1dGlvblxuICogaXMgcmV0dXJuZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gcmVzb2x1dGlvbiBSZXNvbHV0aW9uIGluIHVzZXIgcHJvamVjdGlvbiB1bml0cyBwZXIgcGl4ZWwuXG4gKiBAcGFyYW0ge1Byb2plY3Rpb25MaWtlfSBkZXN0UHJvamVjdGlvbiBUaGUgZGVzdGluYXRpb24gcHJvamVjdGlvbi5cbiAqIEByZXR1cm4ge251bWJlcn0gUmVzb2x1dGlvbiBpbiBkZXN0aW5hdGlvbiBwcm9qZWN0aW9uIHVuaXRzIHBlciBwaXhlbC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21Vc2VyUmVzb2x1dGlvbihyZXNvbHV0aW9uLCBkZXN0UHJvamVjdGlvbikge1xuICBpZiAoIXVzZXJQcm9qZWN0aW9uKSB7XG4gICAgcmV0dXJuIHJlc29sdXRpb247XG4gIH1cbiAgY29uc3Qgc291cmNlVW5pdHMgPSBnZXQoZGVzdFByb2plY3Rpb24pLmdldFVuaXRzKCk7XG4gIGNvbnN0IHVzZXJVbml0cyA9IHVzZXJQcm9qZWN0aW9uLmdldFVuaXRzKCk7XG4gIHJldHVybiBzb3VyY2VVbml0cyAmJiB1c2VyVW5pdHNcbiAgICA/IChyZXNvbHV0aW9uICogTUVURVJTX1BFUl9VTklUW3VzZXJVbml0c10pIC8gTUVURVJTX1BFUl9VTklUW3NvdXJjZVVuaXRzXVxuICAgIDogcmVzb2x1dGlvbjtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgc2FmZSBjb29yZGluYXRlIHRyYW5zZm9ybSBmdW5jdGlvbiBmcm9tIGEgY29vcmRpbmF0ZSB0cmFuc2Zvcm0gZnVuY3Rpb24uXG4gKiBcIlNhZmVcIiBtZWFucyB0aGF0IGl0IGNhbiBoYW5kbGUgd3JhcHBpbmcgb2YgeC1jb29yZGluYXRlcyBmb3IgZ2xvYmFsIHByb2plY3Rpb25zLFxuICogYW5kIHRoYXQgY29vcmRpbmF0ZXMgZXhjZWVkaW5nIHRoZSBzb3VyY2UgcHJvamVjdGlvbiB2YWxpZGl0eSBleHRlbnQncyByYW5nZSB3aWxsIGJlXG4gKiBjbGFtcGVkIHRvIHRoZSB2YWxpZGl0eSByYW5nZS5cbiAqIEBwYXJhbSB7UHJvamVjdGlvbn0gc291cmNlUHJvaiBTb3VyY2UgcHJvamVjdGlvbi5cbiAqIEBwYXJhbSB7UHJvamVjdGlvbn0gZGVzdFByb2ogRGVzdGluYXRpb24gcHJvamVjdGlvbi5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oaW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGUpOiBpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gdHJhbnNmb3JtIFRyYW5zZm9ybSBmdW5jdGlvbiAoc291cmNlIHRvIGRlc3RpbmF0aW9uKS5cbiAqIEByZXR1cm4ge2Z1bmN0aW9uKGltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlKTogaW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IFNhZmUgdHJhbnNmb3JtIGZ1bmN0aW9uIChzb3VyY2UgdG8gZGVzdGluYXRpb24pLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU2FmZUNvb3JkaW5hdGVUcmFuc2Zvcm0oc291cmNlUHJvaiwgZGVzdFByb2osIHRyYW5zZm9ybSkge1xuICByZXR1cm4gZnVuY3Rpb24gKGNvb3JkKSB7XG4gICAgbGV0IHRyYW5zZm9ybWVkLCB3b3JsZHNBd2F5O1xuICAgIGlmIChzb3VyY2VQcm9qLmNhbldyYXBYKCkpIHtcbiAgICAgIGNvbnN0IHNvdXJjZUV4dGVudCA9IHNvdXJjZVByb2ouZ2V0RXh0ZW50KCk7XG4gICAgICBjb25zdCBzb3VyY2VFeHRlbnRXaWR0aCA9IGdldFdpZHRoKHNvdXJjZUV4dGVudCk7XG4gICAgICBjb29yZCA9IGNvb3JkLnNsaWNlKDApO1xuICAgICAgd29ybGRzQXdheSA9IGdldFdvcmxkc0F3YXkoY29vcmQsIHNvdXJjZVByb2osIHNvdXJjZUV4dGVudFdpZHRoKTtcbiAgICAgIGlmICh3b3JsZHNBd2F5KSB7XG4gICAgICAgIC8vIE1vdmUgeCB0byB0aGUgcmVhbCB3b3JsZFxuICAgICAgICBjb29yZFswXSA9IGNvb3JkWzBdIC0gd29ybGRzQXdheSAqIHNvdXJjZUV4dGVudFdpZHRoO1xuICAgICAgfVxuICAgICAgY29vcmRbMF0gPSBjbGFtcChjb29yZFswXSwgc291cmNlRXh0ZW50WzBdLCBzb3VyY2VFeHRlbnRbMl0pO1xuICAgICAgY29vcmRbMV0gPSBjbGFtcChjb29yZFsxXSwgc291cmNlRXh0ZW50WzFdLCBzb3VyY2VFeHRlbnRbM10pO1xuICAgICAgdHJhbnNmb3JtZWQgPSB0cmFuc2Zvcm0oY29vcmQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0cmFuc2Zvcm1lZCA9IHRyYW5zZm9ybShjb29yZCk7XG4gICAgfVxuICAgIGlmICh3b3JsZHNBd2F5ICYmIGRlc3RQcm9qLmNhbldyYXBYKCkpIHtcbiAgICAgIC8vIE1vdmUgdHJhbnNmb3JtZWQgY29vcmRpbmF0ZSBiYWNrIHRvIHRoZSBvZmZzZXQgd29ybGRcbiAgICAgIHRyYW5zZm9ybWVkWzBdICs9IHdvcmxkc0F3YXkgKiBnZXRXaWR0aChkZXN0UHJvai5nZXRFeHRlbnQoKSk7XG4gICAgfVxuICAgIHJldHVybiB0cmFuc2Zvcm1lZDtcbiAgfTtcbn1cblxuLyoqXG4gKiBBZGQgdHJhbnNmb3JtcyB0byBhbmQgZnJvbSBFUFNHOjQzMjYgYW5kIEVQU0c6Mzg1Ny4gIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkXG4gKiBieSB3aGVuIHRoaXMgbW9kdWxlIGlzIGV4ZWN1dGVkIGFuZCBzaG91bGQgb25seSBuZWVkIHRvIGJlIGNhbGxlZCBhZ2FpbiBhZnRlclxuICogYGNsZWFyQWxsUHJvamVjdGlvbnMoKWAgaXMgY2FsbGVkIChlLmcuIGluIHRlc3RzKS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZENvbW1vbigpIHtcbiAgLy8gQWRkIHRyYW5zZm9ybWF0aW9ucyB0aGF0IGRvbid0IGFsdGVyIGNvb3JkaW5hdGVzIHRvIGNvbnZlcnQgd2l0aGluIHNldCBvZlxuICAvLyBwcm9qZWN0aW9ucyB3aXRoIGVxdWFsIG1lYW5pbmcuXG4gIGFkZEVxdWl2YWxlbnRQcm9qZWN0aW9ucyhFUFNHMzg1N19QUk9KRUNUSU9OUyk7XG4gIGFkZEVxdWl2YWxlbnRQcm9qZWN0aW9ucyhFUFNHNDMyNl9QUk9KRUNUSU9OUyk7XG4gIC8vIEFkZCB0cmFuc2Zvcm1hdGlvbnMgdG8gY29udmVydCBFUFNHOjQzMjYgbGlrZSBjb29yZGluYXRlcyB0byBFUFNHOjM4NTcgbGlrZVxuICAvLyBjb29yZGluYXRlcyBhbmQgYmFjay5cbiAgYWRkRXF1aXZhbGVudFRyYW5zZm9ybXMoXG4gICAgRVBTRzQzMjZfUFJPSkVDVElPTlMsXG4gICAgRVBTRzM4NTdfUFJPSkVDVElPTlMsXG4gICAgZnJvbUVQU0c0MzI2LFxuICAgIHRvRVBTRzQzMjZcbiAgKTtcbn1cblxuYWRkQ29tbW9uKCk7XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvcHJvai9Qcm9qZWN0aW9uXG4gKi9cbmltcG9ydCB7TUVURVJTX1BFUl9VTklUfSBmcm9tICcuL1VuaXRzLmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge3N0cmluZ30gY29kZSBUaGUgU1JTIGlkZW50aWZpZXIgY29kZSwgZS5nLiBgRVBTRzo0MzI2YC5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi9Vbml0cy5qc1wiKS5Vbml0c30gW3VuaXRzXSBVbml0cy4gUmVxdWlyZWQgdW5sZXNzIGFcbiAqIHByb2o0IHByb2plY3Rpb24gaXMgZGVmaW5lZCBmb3IgYGNvZGVgLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fSBbZXh0ZW50XSBUaGUgdmFsaWRpdHkgZXh0ZW50IGZvciB0aGUgU1JTLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtheGlzT3JpZW50YXRpb249J2VudSddIFRoZSBheGlzIG9yaWVudGF0aW9uIGFzIHNwZWNpZmllZCBpbiBQcm9qNC5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2dsb2JhbD1mYWxzZV0gV2hldGhlciB0aGUgcHJvamVjdGlvbiBpcyB2YWxpZCBmb3IgdGhlIHdob2xlIGdsb2JlLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFttZXRlcnNQZXJVbml0XSBUaGUgbWV0ZXJzIHBlciB1bml0IGZvciB0aGUgU1JTLlxuICogSWYgbm90IHByb3ZpZGVkLCB0aGUgYHVuaXRzYCBhcmUgdXNlZCB0byBnZXQgdGhlIG1ldGVycyBwZXIgdW5pdCBmcm9tIHRoZSB7QGxpbmsgTUVURVJTX1BFUl9VTklUfVxuICogbG9va3VwIHRhYmxlLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fSBbd29ybGRFeHRlbnRdIFRoZSB3b3JsZCBleHRlbnQgZm9yIHRoZSBTUlMuXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9uKG51bWJlciwgaW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlKTpudW1iZXJ9IFtnZXRQb2ludFJlc29sdXRpb25dXG4gKiBGdW5jdGlvbiB0byBkZXRlcm1pbmUgcmVzb2x1dGlvbiBhdCBhIHBvaW50LiBUaGUgZnVuY3Rpb24gaXMgY2FsbGVkIHdpdGggYVxuICogYG51bWJlcmAgdmlldyByZXNvbHV0aW9uIGFuZCBhIHtAbGluayBtb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlfSBhcyBhcmd1bWVudHMsIGFuZCByZXR1cm5zXG4gKiB0aGUgYG51bWJlcmAgcmVzb2x1dGlvbiBpbiBwcm9qZWN0aW9uIHVuaXRzIGF0IHRoZSBwYXNzZWQgY29vcmRpbmF0ZS4gSWYgdGhpcyBpcyBgdW5kZWZpbmVkYCxcbiAqIHRoZSBkZWZhdWx0IHtAbGluayBtb2R1bGU6b2wvcHJvai5nZXRQb2ludFJlc29sdXRpb259IGZ1bmN0aW9uIHdpbGwgYmUgdXNlZC5cbiAqL1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIFByb2plY3Rpb24gZGVmaW5pdGlvbiBjbGFzcy4gT25lIG9mIHRoZXNlIGlzIGNyZWF0ZWQgZm9yIGVhY2ggcHJvamVjdGlvblxuICogc3VwcG9ydGVkIGluIHRoZSBhcHBsaWNhdGlvbiBhbmQgc3RvcmVkIGluIHRoZSB7QGxpbmsgbW9kdWxlOm9sL3Byb2p9IG5hbWVzcGFjZS5cbiAqIFlvdSBjYW4gdXNlIHRoZXNlIGluIGFwcGxpY2F0aW9ucywgYnV0IHRoaXMgaXMgbm90IHJlcXVpcmVkLCBhcyBBUEkgcGFyYW1zXG4gKiBhbmQgb3B0aW9ucyB1c2Uge0BsaW5rIG1vZHVsZTpvbC9wcm9qflByb2plY3Rpb25MaWtlfSB3aGljaCBtZWFucyB0aGUgc2ltcGxlIHN0cmluZ1xuICogY29kZSB3aWxsIHN1ZmZpY2UuXG4gKlxuICogWW91IGNhbiB1c2Uge0BsaW5rIG1vZHVsZTpvbC9wcm9qLmdldH0gdG8gcmV0cmlldmUgdGhlIG9iamVjdCBmb3IgYSBwYXJ0aWN1bGFyXG4gKiBwcm9qZWN0aW9uLlxuICpcbiAqIFRoZSBsaWJyYXJ5IGluY2x1ZGVzIGRlZmluaXRpb25zIGZvciBgRVBTRzo0MzI2YCBhbmQgYEVQU0c6Mzg1N2AsIHRvZ2V0aGVyXG4gKiB3aXRoIHRoZSBmb2xsb3dpbmcgYWxpYXNlczpcbiAqICogYEVQU0c6NDMyNmA6IENSUzo4NCwgdXJuOm9nYzpkZWY6Y3JzOkVQU0c6Ni42OjQzMjYsXG4gKiAgICAgdXJuOm9nYzpkZWY6Y3JzOk9HQzoxLjM6Q1JTODQsIHVybjpvZ2M6ZGVmOmNyczpPR0M6Mjo4NCxcbiAqICAgICBodHRwOi8vd3d3Lm9wZW5naXMubmV0L2dtbC9zcnMvZXBzZy54bWwjNDMyNixcbiAqICAgICB1cm46eC1vZ2M6ZGVmOmNyczpFUFNHOjQzMjZcbiAqICogYEVQU0c6Mzg1N2A6IEVQU0c6MTAyMTAwLCBFUFNHOjEwMjExMywgRVBTRzo5MDA5MTMsXG4gKiAgICAgdXJuOm9nYzpkZWY6Y3JzOkVQU0c6Ni4xODozOjM4NTcsXG4gKiAgICAgaHR0cDovL3d3dy5vcGVuZ2lzLm5ldC9nbWwvc3JzL2Vwc2cueG1sIzM4NTdcbiAqXG4gKiBJZiB5b3UgdXNlIFtwcm9qNGpzXShodHRwczovL2dpdGh1Yi5jb20vcHJvajRqcy9wcm9qNGpzKSwgYWxpYXNlcyBjYW5cbiAqIGJlIGFkZGVkIHVzaW5nIGBwcm9qNC5kZWZzKClgLiBBZnRlciBhbGwgcmVxdWlyZWQgcHJvamVjdGlvbiBkZWZpbml0aW9ucyBhcmVcbiAqIGFkZGVkLCBjYWxsIHRoZSB7QGxpbmsgbW9kdWxlOm9sL3Byb2ovcHJvajQucmVnaXN0ZXJ9IGZ1bmN0aW9uLlxuICpcbiAqIEBhcGlcbiAqL1xuY2xhc3MgUHJvamVjdGlvbiB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge09wdGlvbnN9IG9wdGlvbnMgUHJvamVjdGlvbiBvcHRpb25zLlxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLmNvZGVfID0gb3B0aW9ucy5jb2RlO1xuXG4gICAgLyoqXG4gICAgICogVW5pdHMgb2YgcHJvamVjdGVkIGNvb3JkaW5hdGVzLiBXaGVuIHNldCB0byBgVElMRV9QSVhFTFNgLCBhXG4gICAgICogYHRoaXMuZXh0ZW50X2AgYW5kIGB0aGlzLndvcmxkRXh0ZW50X2AgbXVzdCBiZSBjb25maWd1cmVkIHByb3Blcmx5IGZvciBlYWNoXG4gICAgICogdGlsZS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuL1VuaXRzLmpzXCIpLlVuaXRzfVxuICAgICAqL1xuICAgIHRoaXMudW5pdHNfID0gLyoqIEB0eXBlIHtpbXBvcnQoXCIuL1VuaXRzLmpzXCIpLlVuaXRzfSAqLyAob3B0aW9ucy51bml0cyk7XG5cbiAgICAvKipcbiAgICAgKiBWYWxpZGl0eSBleHRlbnQgb2YgdGhlIHByb2plY3Rpb24gaW4gcHJvamVjdGVkIGNvb3JkaW5hdGVzLiBGb3IgcHJvamVjdGlvbnNcbiAgICAgKiB3aXRoIGBUSUxFX1BJWEVMU2AgdW5pdHMsIHRoaXMgaXMgdGhlIGV4dGVudCBvZiB0aGUgdGlsZSBpblxuICAgICAqIHRpbGUgcGl4ZWwgc3BhY2UuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH1cbiAgICAgKi9cbiAgICB0aGlzLmV4dGVudF8gPSBvcHRpb25zLmV4dGVudCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5leHRlbnQgOiBudWxsO1xuXG4gICAgLyoqXG4gICAgICogRXh0ZW50IG9mIHRoZSB3b3JsZCBpbiBFUFNHOjQzMjYuIEZvciBwcm9qZWN0aW9ucyB3aXRoXG4gICAgICogYFRJTEVfUElYRUxTYCB1bml0cywgdGhpcyBpcyB0aGUgZXh0ZW50IG9mIHRoZSB0aWxlIGluXG4gICAgICogcHJvamVjdGVkIGNvb3JkaW5hdGUgc3BhY2UuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH1cbiAgICAgKi9cbiAgICB0aGlzLndvcmxkRXh0ZW50XyA9XG4gICAgICBvcHRpb25zLndvcmxkRXh0ZW50ICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLndvcmxkRXh0ZW50IDogbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLmF4aXNPcmllbnRhdGlvbl8gPVxuICAgICAgb3B0aW9ucy5heGlzT3JpZW50YXRpb24gIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuYXhpc09yaWVudGF0aW9uIDogJ2VudSc7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuZ2xvYmFsXyA9IG9wdGlvbnMuZ2xvYmFsICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmdsb2JhbCA6IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmNhbldyYXBYXyA9ICEhKHRoaXMuZ2xvYmFsXyAmJiB0aGlzLmV4dGVudF8pO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7ZnVuY3Rpb24obnVtYmVyLCBpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGUpOm51bWJlcnx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5nZXRQb2ludFJlc29sdXRpb25GdW5jXyA9IG9wdGlvbnMuZ2V0UG9pbnRSZXNvbHV0aW9uO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vdGlsZWdyaWQvVGlsZUdyaWQuanNcIikuZGVmYXVsdH1cbiAgICAgKi9cbiAgICB0aGlzLmRlZmF1bHRUaWxlR3JpZF8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLm1ldGVyc1BlclVuaXRfID0gb3B0aW9ucy5tZXRlcnNQZXJVbml0O1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSBwcm9qZWN0aW9uIGlzIHN1aXRhYmxlIGZvciB3cmFwcGluZyB0aGUgeC1heGlzXG4gICAqL1xuICBjYW5XcmFwWCgpIHtcbiAgICByZXR1cm4gdGhpcy5jYW5XcmFwWF87XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBjb2RlIGZvciB0aGlzIHByb2plY3Rpb24sIGUuZy4gJ0VQU0c6NDMyNicuXG4gICAqIEByZXR1cm4ge3N0cmluZ30gQ29kZS5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0Q29kZSgpIHtcbiAgICByZXR1cm4gdGhpcy5jb2RlXztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHZhbGlkaXR5IGV4dGVudCBmb3IgdGhpcyBwcm9qZWN0aW9uLlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fSBFeHRlbnQuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldEV4dGVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5leHRlbnRfO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdW5pdHMgb2YgdGhpcyBwcm9qZWN0aW9uLlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuL1VuaXRzLmpzXCIpLlVuaXRzfSBVbml0cy5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0VW5pdHMoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pdHNfO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgYW1vdW50IG9mIG1ldGVycyBwZXIgdW5pdCBvZiB0aGlzIHByb2plY3Rpb24uICBJZiB0aGUgcHJvamVjdGlvbiBpc1xuICAgKiBub3QgY29uZmlndXJlZCB3aXRoIGBtZXRlcnNQZXJVbml0YCBvciBhIHVuaXRzIGlkZW50aWZpZXIsIHRoZSByZXR1cm4gaXNcbiAgICogYHVuZGVmaW5lZGAuXG4gICAqIEByZXR1cm4ge251bWJlcnx1bmRlZmluZWR9IE1ldGVycy5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0TWV0ZXJzUGVyVW5pdCgpIHtcbiAgICByZXR1cm4gdGhpcy5tZXRlcnNQZXJVbml0XyB8fCBNRVRFUlNfUEVSX1VOSVRbdGhpcy51bml0c19dO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgd29ybGQgZXh0ZW50IGZvciB0aGlzIHByb2plY3Rpb24uXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IEV4dGVudC5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0V29ybGRFeHRlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMud29ybGRFeHRlbnRfO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgYXhpcyBvcmllbnRhdGlvbiBvZiB0aGlzIHByb2plY3Rpb24uXG4gICAqIEV4YW1wbGUgdmFsdWVzIGFyZTpcbiAgICogZW51IC0gdGhlIGRlZmF1bHQgZWFzdGluZywgbm9ydGhpbmcsIGVsZXZhdGlvbi5cbiAgICogbmV1IC0gbm9ydGhpbmcsIGVhc3RpbmcsIHVwIC0gdXNlZnVsIGZvciBcImxhdC9sb25nXCIgZ2VvZ3JhcGhpYyBjb29yZGluYXRlcyxcbiAgICogICAgIG9yIHNvdXRoIG9yaWVudGF0ZWQgdHJhbnN2ZXJzZSBtZXJjYXRvci5cbiAgICogd251IC0gd2VzdGluZywgbm9ydGhpbmcsIHVwIC0gc29tZSBwbGFuZXRhcnkgY29vcmRpbmF0ZSBzeXN0ZW1zIGhhdmVcbiAgICogICAgIFwid2VzdCBwb3NpdGl2ZVwiIGNvb3JkaW5hdGUgc3lzdGVtc1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9IEF4aXMgb3JpZW50YXRpb24uXG4gICAqIEBhcGlcbiAgICovXG4gIGdldEF4aXNPcmllbnRhdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5heGlzT3JpZW50YXRpb25fO1xuICB9XG5cbiAgLyoqXG4gICAqIElzIHRoaXMgcHJvamVjdGlvbiBhIGdsb2JhbCBwcm9qZWN0aW9uIHdoaWNoIHNwYW5zIHRoZSB3aG9sZSB3b3JsZD9cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgcHJvamVjdGlvbiBpcyBnbG9iYWwuXG4gICAqIEBhcGlcbiAgICovXG4gIGlzR2xvYmFsKCkge1xuICAgIHJldHVybiB0aGlzLmdsb2JhbF87XG4gIH1cblxuICAvKipcbiAgICogU2V0IGlmIHRoZSBwcm9qZWN0aW9uIGlzIGEgZ2xvYmFsIHByb2plY3Rpb24gd2hpY2ggc3BhbnMgdGhlIHdob2xlIHdvcmxkXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gZ2xvYmFsIFdoZXRoZXIgdGhlIHByb2plY3Rpb24gaXMgZ2xvYmFsLlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRHbG9iYWwoZ2xvYmFsKSB7XG4gICAgdGhpcy5nbG9iYWxfID0gZ2xvYmFsO1xuICAgIHRoaXMuY2FuV3JhcFhfID0gISEoZ2xvYmFsICYmIHRoaXMuZXh0ZW50Xyk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vdGlsZWdyaWQvVGlsZUdyaWQuanNcIikuZGVmYXVsdH0gVGhlIGRlZmF1bHQgdGlsZSBncmlkLlxuICAgKi9cbiAgZ2V0RGVmYXVsdFRpbGVHcmlkKCkge1xuICAgIHJldHVybiB0aGlzLmRlZmF1bHRUaWxlR3JpZF87XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi90aWxlZ3JpZC9UaWxlR3JpZC5qc1wiKS5kZWZhdWx0fSB0aWxlR3JpZCBUaGUgZGVmYXVsdCB0aWxlIGdyaWQuXG4gICAqL1xuICBzZXREZWZhdWx0VGlsZUdyaWQodGlsZUdyaWQpIHtcbiAgICB0aGlzLmRlZmF1bHRUaWxlR3JpZF8gPSB0aWxlR3JpZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHZhbGlkaXR5IGV4dGVudCBmb3IgdGhpcyBwcm9qZWN0aW9uLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gICAqIEBhcGlcbiAgICovXG4gIHNldEV4dGVudChleHRlbnQpIHtcbiAgICB0aGlzLmV4dGVudF8gPSBleHRlbnQ7XG4gICAgdGhpcy5jYW5XcmFwWF8gPSAhISh0aGlzLmdsb2JhbF8gJiYgZXh0ZW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHdvcmxkIGV4dGVudCBmb3IgdGhpcyBwcm9qZWN0aW9uLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IHdvcmxkRXh0ZW50IFdvcmxkIGV4dGVudFxuICAgKiAgICAgW21pbmxvbiwgbWlubGF0LCBtYXhsb24sIG1heGxhdF0uXG4gICAqIEBhcGlcbiAgICovXG4gIHNldFdvcmxkRXh0ZW50KHdvcmxkRXh0ZW50KSB7XG4gICAgdGhpcy53b3JsZEV4dGVudF8gPSB3b3JsZEV4dGVudDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGdldFBvaW50UmVzb2x1dGlvbiBmdW5jdGlvbiAoc2VlIHtAbGluayBtb2R1bGU6b2wvcHJvai5nZXRQb2ludFJlc29sdXRpb259XG4gICAqIGZvciB0aGlzIHByb2plY3Rpb24uXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24obnVtYmVyLCBpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGUpOm51bWJlcn0gZnVuYyBGdW5jdGlvblxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRHZXRQb2ludFJlc29sdXRpb24oZnVuYykge1xuICAgIHRoaXMuZ2V0UG9pbnRSZXNvbHV0aW9uRnVuY18gPSBmdW5jO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgY3VzdG9tIHBvaW50IHJlc29sdXRpb24gZnVuY3Rpb24gZm9yIHRoaXMgcHJvamVjdGlvbiAoaWYgc2V0KS5cbiAgICogQHJldHVybiB7ZnVuY3Rpb24obnVtYmVyLCBpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGUpOm51bWJlcnx1bmRlZmluZWR9IFRoZSBjdXN0b20gcG9pbnRcbiAgICogcmVzb2x1dGlvbiBmdW5jdGlvbiAoaWYgc2V0KS5cbiAgICovXG4gIGdldFBvaW50UmVzb2x1dGlvbkZ1bmMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UG9pbnRSZXNvbHV0aW9uRnVuY187XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgUHJvamVjdGlvbjtcbiIsIi8qKlxuICogQG1vZHVsZSBvbC9wcm9qL1VuaXRzXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7J3JhZGlhbnMnIHwgJ2RlZ3JlZXMnIHwgJ2Z0JyB8ICdtJyB8ICdwaXhlbHMnIHwgJ3RpbGUtcGl4ZWxzJyB8ICd1cy1mdCd9IFVuaXRzXG4gKiBQcm9qZWN0aW9uIHVuaXRzLlxuICovXG5cbi8qKlxuICogU2VlIGh0dHA6Ly9kdWZmLmVzcy53YXNoaW5ndG9uLmVkdS9kYXRhL3Jhc3Rlci9kcmcvZG9jcy9nZW90aWZmLnR4dFxuICogQHR5cGUge09iamVjdDxudW1iZXIsIFVuaXRzPn1cbiAqL1xuY29uc3QgdW5pdEJ5Q29kZSA9IHtcbiAgJzkwMDEnOiAnbScsXG4gICc5MDAyJzogJ2Z0JyxcbiAgJzkwMDMnOiAndXMtZnQnLFxuICAnOTEwMSc6ICdyYWRpYW5zJyxcbiAgJzkxMDInOiAnZGVncmVlcycsXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBjb2RlIFVuaXQgY29kZS5cbiAqIEByZXR1cm4ge1VuaXRzfSBVbml0cy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21Db2RlKGNvZGUpIHtcbiAgcmV0dXJuIHVuaXRCeUNvZGVbY29kZV07XG59XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gTWV0ZXJzUGVyVW5pdExvb2t1cFxuICogQHByb3BlcnR5IHtudW1iZXJ9IHJhZGlhbnMgUmFkaWFuc1xuICogQHByb3BlcnR5IHtudW1iZXJ9IGRlZ3JlZXMgRGVncmVlc1xuICogQHByb3BlcnR5IHtudW1iZXJ9IGZ0ICBGZWV0XG4gKiBAcHJvcGVydHkge251bWJlcn0gbSBNZXRlcnNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB1cy1mdCBVUyBmZWV0XG4gKi9cblxuLyoqXG4gKiBNZXRlcnMgcGVyIHVuaXQgbG9va3VwIHRhYmxlLlxuICogQGNvbnN0XG4gKiBAdHlwZSB7TWV0ZXJzUGVyVW5pdExvb2t1cH1cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGNvbnN0IE1FVEVSU19QRVJfVU5JVCA9IHtcbiAgLy8gdXNlIHRoZSByYWRpdXMgb2YgdGhlIE5vcm1hbCBzcGhlcmVcbiAgJ3JhZGlhbnMnOiA2MzcwOTk3IC8gKDIgKiBNYXRoLlBJKSxcbiAgJ2RlZ3JlZXMnOiAoMiAqIE1hdGguUEkgKiA2MzcwOTk3KSAvIDM2MCxcbiAgJ2Z0JzogMC4zMDQ4LFxuICAnbSc6IDEsXG4gICd1cy1mdCc6IDEyMDAgLyAzOTM3LFxufTtcbiIsIi8qKlxuICogQG1vZHVsZSBvbC9wcm9qL2Vwc2czODU3XG4gKi9cbmltcG9ydCBQcm9qZWN0aW9uIGZyb20gJy4vUHJvamVjdGlvbi5qcyc7XG5cbi8qKlxuICogUmFkaXVzIG9mIFdHUzg0IHNwaGVyZVxuICpcbiAqIEBjb25zdFxuICogQHR5cGUge251bWJlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IFJBRElVUyA9IDYzNzgxMzc7XG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5leHBvcnQgY29uc3QgSEFMRl9TSVpFID0gTWF0aC5QSSAqIFJBRElVUztcblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fVxuICovXG5leHBvcnQgY29uc3QgRVhURU5UID0gWy1IQUxGX1NJWkUsIC1IQUxGX1NJWkUsIEhBTEZfU0laRSwgSEFMRl9TSVpFXTtcblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fVxuICovXG5leHBvcnQgY29uc3QgV09STERfRVhURU5UID0gWy0xODAsIC04NSwgMTgwLCA4NV07XG5cbi8qKlxuICogTWF4aW11bSBzYWZlIHZhbHVlIGluIHkgZGlyZWN0aW9uXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCBNQVhfU0FGRV9ZID0gUkFESVVTICogTWF0aC5sb2coTWF0aC50YW4oTWF0aC5QSSAvIDIpKTtcblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBQcm9qZWN0aW9uIG9iamVjdCBmb3Igd2ViL3NwaGVyaWNhbCBNZXJjYXRvciAoRVBTRzozODU3KS5cbiAqL1xuY2xhc3MgRVBTRzM4NTdQcm9qZWN0aW9uIGV4dGVuZHMgUHJvamVjdGlvbiB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY29kZSBDb2RlLlxuICAgKi9cbiAgY29uc3RydWN0b3IoY29kZSkge1xuICAgIHN1cGVyKHtcbiAgICAgIGNvZGU6IGNvZGUsXG4gICAgICB1bml0czogJ20nLFxuICAgICAgZXh0ZW50OiBFWFRFTlQsXG4gICAgICBnbG9iYWw6IHRydWUsXG4gICAgICB3b3JsZEV4dGVudDogV09STERfRVhURU5ULFxuICAgICAgZ2V0UG9pbnRSZXNvbHV0aW9uOiBmdW5jdGlvbiAocmVzb2x1dGlvbiwgcG9pbnQpIHtcbiAgICAgICAgcmV0dXJuIHJlc29sdXRpb24gLyBNYXRoLmNvc2gocG9pbnRbMV0gLyBSQURJVVMpO1xuICAgICAgfSxcbiAgICB9KTtcbiAgfVxufVxuXG4vKipcbiAqIFByb2plY3Rpb25zIGVxdWFsIHRvIEVQU0c6Mzg1Ny5cbiAqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtBcnJheTxpbXBvcnQoXCIuL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdD59XG4gKi9cbmV4cG9ydCBjb25zdCBQUk9KRUNUSU9OUyA9IFtcbiAgbmV3IEVQU0czODU3UHJvamVjdGlvbignRVBTRzozODU3JyksXG4gIG5ldyBFUFNHMzg1N1Byb2plY3Rpb24oJ0VQU0c6MTAyMTAwJyksXG4gIG5ldyBFUFNHMzg1N1Byb2plY3Rpb24oJ0VQU0c6MTAyMTEzJyksXG4gIG5ldyBFUFNHMzg1N1Byb2plY3Rpb24oJ0VQU0c6OTAwOTEzJyksXG4gIG5ldyBFUFNHMzg1N1Byb2plY3Rpb24oJ2h0dHA6Ly93d3cub3Blbmdpcy5uZXQvZGVmL2Nycy9FUFNHLzAvMzg1NycpLFxuICBuZXcgRVBTRzM4NTdQcm9qZWN0aW9uKCdodHRwOi8vd3d3Lm9wZW5naXMubmV0L2dtbC9zcnMvZXBzZy54bWwjMzg1NycpLFxuXTtcblxuLyoqXG4gKiBUcmFuc2Zvcm1hdGlvbiBmcm9tIEVQU0c6NDMyNiB0byBFUFNHOjM4NTcuXG4gKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBpbnB1dCBJbnB1dCBhcnJheSBvZiBjb29yZGluYXRlIHZhbHVlcy5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gW291dHB1dF0gT3V0cHV0IGFycmF5IG9mIGNvb3JkaW5hdGUgdmFsdWVzLlxuICogQHBhcmFtIHtudW1iZXJ9IFtkaW1lbnNpb25dIERpbWVuc2lvbiAoZGVmYXVsdCBpcyBgMmApLlxuICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gT3V0cHV0IGFycmF5IG9mIGNvb3JkaW5hdGUgdmFsdWVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbUVQU0c0MzI2KGlucHV0LCBvdXRwdXQsIGRpbWVuc2lvbikge1xuICBjb25zdCBsZW5ndGggPSBpbnB1dC5sZW5ndGg7XG4gIGRpbWVuc2lvbiA9IGRpbWVuc2lvbiA+IDEgPyBkaW1lbnNpb24gOiAyO1xuICBpZiAob3V0cHV0ID09PSB1bmRlZmluZWQpIHtcbiAgICBpZiAoZGltZW5zaW9uID4gMikge1xuICAgICAgLy8gcHJlc2VydmUgdmFsdWVzIGJleW9uZCBzZWNvbmQgZGltZW5zaW9uXG4gICAgICBvdXRwdXQgPSBpbnB1dC5zbGljZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXRwdXQgPSBuZXcgQXJyYXkobGVuZ3RoKTtcbiAgICB9XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gZGltZW5zaW9uKSB7XG4gICAgb3V0cHV0W2ldID0gKEhBTEZfU0laRSAqIGlucHV0W2ldKSAvIDE4MDtcbiAgICBsZXQgeSA9IFJBRElVUyAqIE1hdGgubG9nKE1hdGgudGFuKChNYXRoLlBJICogKCtpbnB1dFtpICsgMV0gKyA5MCkpIC8gMzYwKSk7XG4gICAgaWYgKHkgPiBNQVhfU0FGRV9ZKSB7XG4gICAgICB5ID0gTUFYX1NBRkVfWTtcbiAgICB9IGVsc2UgaWYgKHkgPCAtTUFYX1NBRkVfWSkge1xuICAgICAgeSA9IC1NQVhfU0FGRV9ZO1xuICAgIH1cbiAgICBvdXRwdXRbaSArIDFdID0geTtcbiAgfVxuICByZXR1cm4gb3V0cHV0O1xufVxuXG4vKipcbiAqIFRyYW5zZm9ybWF0aW9uIGZyb20gRVBTRzozODU3IHRvIEVQU0c6NDMyNi5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGlucHV0IElucHV0IGFycmF5IG9mIGNvb3JkaW5hdGUgdmFsdWVzLlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBbb3V0cHV0XSBPdXRwdXQgYXJyYXkgb2YgY29vcmRpbmF0ZSB2YWx1ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gW2RpbWVuc2lvbl0gRGltZW5zaW9uIChkZWZhdWx0IGlzIGAyYCkuXG4gKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBPdXRwdXQgYXJyYXkgb2YgY29vcmRpbmF0ZSB2YWx1ZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0VQU0c0MzI2KGlucHV0LCBvdXRwdXQsIGRpbWVuc2lvbikge1xuICBjb25zdCBsZW5ndGggPSBpbnB1dC5sZW5ndGg7XG4gIGRpbWVuc2lvbiA9IGRpbWVuc2lvbiA+IDEgPyBkaW1lbnNpb24gOiAyO1xuICBpZiAob3V0cHV0ID09PSB1bmRlZmluZWQpIHtcbiAgICBpZiAoZGltZW5zaW9uID4gMikge1xuICAgICAgLy8gcHJlc2VydmUgdmFsdWVzIGJleW9uZCBzZWNvbmQgZGltZW5zaW9uXG4gICAgICBvdXRwdXQgPSBpbnB1dC5zbGljZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXRwdXQgPSBuZXcgQXJyYXkobGVuZ3RoKTtcbiAgICB9XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gZGltZW5zaW9uKSB7XG4gICAgb3V0cHV0W2ldID0gKDE4MCAqIGlucHV0W2ldKSAvIEhBTEZfU0laRTtcbiAgICBvdXRwdXRbaSArIDFdID1cbiAgICAgICgzNjAgKiBNYXRoLmF0YW4oTWF0aC5leHAoaW5wdXRbaSArIDFdIC8gUkFESVVTKSkpIC8gTWF0aC5QSSAtIDkwO1xuICB9XG4gIHJldHVybiBvdXRwdXQ7XG59XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvcHJvai9lcHNnNDMyNlxuICovXG5pbXBvcnQgUHJvamVjdGlvbiBmcm9tICcuL1Byb2plY3Rpb24uanMnO1xuXG4vKipcbiAqIFNlbWktbWFqb3IgcmFkaXVzIG9mIHRoZSBXR1M4NCBlbGxpcHNvaWQuXG4gKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5leHBvcnQgY29uc3QgUkFESVVTID0gNjM3ODEzNztcblxuLyoqXG4gKiBFeHRlbnQgb2YgdGhlIEVQU0c6NDMyNiBwcm9qZWN0aW9uIHdoaWNoIGlzIHRoZSB3aG9sZSB3b3JsZC5cbiAqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fVxuICovXG5leHBvcnQgY29uc3QgRVhURU5UID0gWy0xODAsIC05MCwgMTgwLCA5MF07XG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5leHBvcnQgY29uc3QgTUVURVJTX1BFUl9VTklUID0gKE1hdGguUEkgKiBSQURJVVMpIC8gMTgwO1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIFByb2plY3Rpb24gb2JqZWN0IGZvciBXR1M4NCBnZW9ncmFwaGljIGNvb3JkaW5hdGVzIChFUFNHOjQzMjYpLlxuICpcbiAqIE5vdGUgdGhhdCBPcGVuTGF5ZXJzIGRvZXMgbm90IHN0cmljdGx5IGNvbXBseSB3aXRoIHRoZSBFUFNHIGRlZmluaXRpb24uXG4gKiBUaGUgRVBTRyByZWdpc3RyeSBkZWZpbmVzIDQzMjYgYXMgYSBDUlMgZm9yIExhdGl0dWRlLExvbmdpdHVkZSAoeSx4KS5cbiAqIE9wZW5MYXllcnMgdHJlYXRzIEVQU0c6NDMyNiBhcyBhIHBzZXVkby1wcm9qZWN0aW9uLCB3aXRoIHgseSBjb29yZGluYXRlcy5cbiAqL1xuY2xhc3MgRVBTRzQzMjZQcm9qZWN0aW9uIGV4dGVuZHMgUHJvamVjdGlvbiB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY29kZSBDb2RlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2F4aXNPcmllbnRhdGlvbl0gQXhpcyBvcmllbnRhdGlvbi5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGNvZGUsIGF4aXNPcmllbnRhdGlvbikge1xuICAgIHN1cGVyKHtcbiAgICAgIGNvZGU6IGNvZGUsXG4gICAgICB1bml0czogJ2RlZ3JlZXMnLFxuICAgICAgZXh0ZW50OiBFWFRFTlQsXG4gICAgICBheGlzT3JpZW50YXRpb246IGF4aXNPcmllbnRhdGlvbixcbiAgICAgIGdsb2JhbDogdHJ1ZSxcbiAgICAgIG1ldGVyc1BlclVuaXQ6IE1FVEVSU19QRVJfVU5JVCxcbiAgICAgIHdvcmxkRXh0ZW50OiBFWFRFTlQsXG4gICAgfSk7XG4gIH1cbn1cblxuLyoqXG4gKiBQcm9qZWN0aW9ucyBlcXVhbCB0byBFUFNHOjQzMjYuXG4gKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7QXJyYXk8aW1wb3J0KFwiLi9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHQ+fVxuICovXG5leHBvcnQgY29uc3QgUFJPSkVDVElPTlMgPSBbXG4gIG5ldyBFUFNHNDMyNlByb2plY3Rpb24oJ0NSUzo4NCcpLFxuICBuZXcgRVBTRzQzMjZQcm9qZWN0aW9uKCdFUFNHOjQzMjYnLCAnbmV1JyksXG4gIG5ldyBFUFNHNDMyNlByb2plY3Rpb24oJ3VybjpvZ2M6ZGVmOmNyczpPR0M6MS4zOkNSUzg0JyksXG4gIG5ldyBFUFNHNDMyNlByb2plY3Rpb24oJ3VybjpvZ2M6ZGVmOmNyczpPR0M6Mjo4NCcpLFxuICBuZXcgRVBTRzQzMjZQcm9qZWN0aW9uKCdodHRwOi8vd3d3Lm9wZW5naXMubmV0L2RlZi9jcnMvT0dDLzEuMy9DUlM4NCcpLFxuICBuZXcgRVBTRzQzMjZQcm9qZWN0aW9uKCdodHRwOi8vd3d3Lm9wZW5naXMubmV0L2dtbC9zcnMvZXBzZy54bWwjNDMyNicsICduZXUnKSxcbiAgbmV3IEVQU0c0MzI2UHJvamVjdGlvbignaHR0cDovL3d3dy5vcGVuZ2lzLm5ldC9kZWYvY3JzL0VQU0cvMC80MzI2JywgJ25ldScpLFxuXTtcbiIsIi8qKlxuICogQG1vZHVsZSBvbC9wcm9qL3Byb2plY3Rpb25zXG4gKi9cblxuLyoqXG4gKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgaW1wb3J0KFwiLi9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHQ+fVxuICovXG5sZXQgY2FjaGUgPSB7fTtcblxuLyoqXG4gKiBDbGVhciB0aGUgcHJvamVjdGlvbnMgY2FjaGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbGVhcigpIHtcbiAgY2FjaGUgPSB7fTtcbn1cblxuLyoqXG4gKiBHZXQgYSBjYWNoZWQgcHJvamVjdGlvbiBieSBjb2RlLlxuICogQHBhcmFtIHtzdHJpbmd9IGNvZGUgVGhlIGNvZGUgZm9yIHRoZSBwcm9qZWN0aW9uLlxuICogQHJldHVybiB7aW1wb3J0KFwiLi9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR9IFRoZSBwcm9qZWN0aW9uIChpZiBjYWNoZWQpLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0KGNvZGUpIHtcbiAgcmV0dXJuIChcbiAgICBjYWNoZVtjb2RlXSB8fFxuICAgIGNhY2hlW2NvZGUucmVwbGFjZSgvdXJuOih4LSk/b2djOmRlZjpjcnM6RVBTRzooLio6KT8oXFx3KykkLywgJ0VQU0c6JDMnKV0gfHxcbiAgICBudWxsXG4gICk7XG59XG5cbi8qKlxuICogQWRkIGEgcHJvamVjdGlvbiB0byB0aGUgY2FjaGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gY29kZSBUaGUgcHJvamVjdGlvbiBjb2RlLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdH0gcHJvamVjdGlvbiBUaGUgcHJvamVjdGlvbiB0byBjYWNoZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZChjb2RlLCBwcm9qZWN0aW9uKSB7XG4gIGNhY2hlW2NvZGVdID0gcHJvamVjdGlvbjtcbn1cbiIsIi8qKlxuICogQG1vZHVsZSBvbC9wcm9qL3RyYW5zZm9ybXNcbiAqL1xuaW1wb3J0IHtpc0VtcHR5fSBmcm9tICcuLi9vYmouanMnO1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBAdHlwZSB7IU9iamVjdDxzdHJpbmcsIE9iamVjdDxzdHJpbmcsIGltcG9ydChcIi4uL3Byb2ouanNcIikuVHJhbnNmb3JtRnVuY3Rpb24+Pn1cbiAqL1xubGV0IHRyYW5zZm9ybXMgPSB7fTtcblxuLyoqXG4gKiBDbGVhciB0aGUgdHJhbnNmb3JtIGNhY2hlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xlYXIoKSB7XG4gIHRyYW5zZm9ybXMgPSB7fTtcbn1cblxuLyoqXG4gKiBSZWdpc3RlcnMgYSBjb252ZXJzaW9uIGZ1bmN0aW9uIHRvIGNvbnZlcnQgY29vcmRpbmF0ZXMgZnJvbSB0aGUgc291cmNlXG4gKiBwcm9qZWN0aW9uIHRvIHRoZSBkZXN0aW5hdGlvbiBwcm9qZWN0aW9uLlxuICpcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR9IHNvdXJjZSBTb3VyY2UuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0fSBkZXN0aW5hdGlvbiBEZXN0aW5hdGlvbi5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcHJvai5qc1wiKS5UcmFuc2Zvcm1GdW5jdGlvbn0gdHJhbnNmb3JtRm4gVHJhbnNmb3JtLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkKHNvdXJjZSwgZGVzdGluYXRpb24sIHRyYW5zZm9ybUZuKSB7XG4gIGNvbnN0IHNvdXJjZUNvZGUgPSBzb3VyY2UuZ2V0Q29kZSgpO1xuICBjb25zdCBkZXN0aW5hdGlvbkNvZGUgPSBkZXN0aW5hdGlvbi5nZXRDb2RlKCk7XG4gIGlmICghKHNvdXJjZUNvZGUgaW4gdHJhbnNmb3JtcykpIHtcbiAgICB0cmFuc2Zvcm1zW3NvdXJjZUNvZGVdID0ge307XG4gIH1cbiAgdHJhbnNmb3Jtc1tzb3VyY2VDb2RlXVtkZXN0aW5hdGlvbkNvZGVdID0gdHJhbnNmb3JtRm47XG59XG5cbi8qKlxuICogVW5yZWdpc3RlcnMgdGhlIGNvbnZlcnNpb24gZnVuY3Rpb24gdG8gY29udmVydCBjb29yZGluYXRlcyBmcm9tIHRoZSBzb3VyY2VcbiAqIHByb2plY3Rpb24gdG8gdGhlIGRlc3RpbmF0aW9uIHByb2plY3Rpb24uICBUaGlzIG1ldGhvZCBpcyB1c2VkIHRvIGNsZWFuIHVwXG4gKiBjYWNoZWQgdHJhbnNmb3JtcyBkdXJpbmcgdGVzdGluZy5cbiAqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0fSBzb3VyY2UgU291cmNlIHByb2plY3Rpb24uXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0fSBkZXN0aW5hdGlvbiBEZXN0aW5hdGlvbiBwcm9qZWN0aW9uLlxuICogQHJldHVybiB7aW1wb3J0KFwiLi4vcHJvai5qc1wiKS5UcmFuc2Zvcm1GdW5jdGlvbn0gdHJhbnNmb3JtRm4gVGhlIHVucmVnaXN0ZXJlZCB0cmFuc2Zvcm0uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmUoc291cmNlLCBkZXN0aW5hdGlvbikge1xuICBjb25zdCBzb3VyY2VDb2RlID0gc291cmNlLmdldENvZGUoKTtcbiAgY29uc3QgZGVzdGluYXRpb25Db2RlID0gZGVzdGluYXRpb24uZ2V0Q29kZSgpO1xuICBjb25zdCB0cmFuc2Zvcm0gPSB0cmFuc2Zvcm1zW3NvdXJjZUNvZGVdW2Rlc3RpbmF0aW9uQ29kZV07XG4gIGRlbGV0ZSB0cmFuc2Zvcm1zW3NvdXJjZUNvZGVdW2Rlc3RpbmF0aW9uQ29kZV07XG4gIGlmIChpc0VtcHR5KHRyYW5zZm9ybXNbc291cmNlQ29kZV0pKSB7XG4gICAgZGVsZXRlIHRyYW5zZm9ybXNbc291cmNlQ29kZV07XG4gIH1cbiAgcmV0dXJuIHRyYW5zZm9ybTtcbn1cblxuLyoqXG4gKiBHZXQgYSB0cmFuc2Zvcm0gZ2l2ZW4gYSBzb3VyY2UgY29kZSBhbmQgYSBkZXN0aW5hdGlvbiBjb2RlLlxuICogQHBhcmFtIHtzdHJpbmd9IHNvdXJjZUNvZGUgVGhlIGNvZGUgZm9yIHRoZSBzb3VyY2UgcHJvamVjdGlvbi5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkZXN0aW5hdGlvbkNvZGUgVGhlIGNvZGUgZm9yIHRoZSBkZXN0aW5hdGlvbiBwcm9qZWN0aW9uLlxuICogQHJldHVybiB7aW1wb3J0KFwiLi4vcHJvai5qc1wiKS5UcmFuc2Zvcm1GdW5jdGlvbnx1bmRlZmluZWR9IFRoZSB0cmFuc2Zvcm0gZnVuY3Rpb24gKGlmIGZvdW5kKS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldChzb3VyY2VDb2RlLCBkZXN0aW5hdGlvbkNvZGUpIHtcbiAgbGV0IHRyYW5zZm9ybTtcbiAgaWYgKHNvdXJjZUNvZGUgaW4gdHJhbnNmb3JtcyAmJiBkZXN0aW5hdGlvbkNvZGUgaW4gdHJhbnNmb3Jtc1tzb3VyY2VDb2RlXSkge1xuICAgIHRyYW5zZm9ybSA9IHRyYW5zZm9ybXNbc291cmNlQ29kZV1bZGVzdGluYXRpb25Db2RlXTtcbiAgfVxuICByZXR1cm4gdHJhbnNmb3JtO1xufVxuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3JlbmRlci9Cb3hcbiAqL1xuXG5pbXBvcnQgRGlzcG9zYWJsZSBmcm9tICcuLi9EaXNwb3NhYmxlLmpzJztcbmltcG9ydCBQb2x5Z29uIGZyb20gJy4uL2dlb20vUG9seWdvbi5qcyc7XG5cbmNsYXNzIFJlbmRlckJveCBleHRlbmRzIERpc3Bvc2FibGUge1xuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZSBDU1MgY2xhc3MgbmFtZS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGNsYXNzTmFtZSkge1xuICAgIHN1cGVyKCk7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vZ2VvbS9Qb2x5Z29uLmpzXCIpLmRlZmF1bHR9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmdlb21ldHJ5XyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7SFRNTERpdkVsZW1lbnR9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmVsZW1lbnRfID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGhpcy5lbGVtZW50Xy5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgdGhpcy5lbGVtZW50Xy5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ2F1dG8nO1xuICAgIHRoaXMuZWxlbWVudF8uY2xhc3NOYW1lID0gJ29sLWJveCAnICsgY2xhc3NOYW1lO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vTWFwLmpzXCIpLmRlZmF1bHR8bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLm1hcF8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vcGl4ZWwuanNcIikuUGl4ZWx9XG4gICAgICovXG4gICAgdGhpcy5zdGFydFBpeGVsXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9waXhlbC5qc1wiKS5QaXhlbH1cbiAgICAgKi9cbiAgICB0aGlzLmVuZFBpeGVsXyA9IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogQ2xlYW4gdXAuXG4gICAqL1xuICBkaXNwb3NlSW50ZXJuYWwoKSB7XG4gICAgdGhpcy5zZXRNYXAobnVsbCk7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHJlbmRlcl8oKSB7XG4gICAgY29uc3Qgc3RhcnRQaXhlbCA9IHRoaXMuc3RhcnRQaXhlbF87XG4gICAgY29uc3QgZW5kUGl4ZWwgPSB0aGlzLmVuZFBpeGVsXztcbiAgICBjb25zdCBweCA9ICdweCc7XG4gICAgY29uc3Qgc3R5bGUgPSB0aGlzLmVsZW1lbnRfLnN0eWxlO1xuICAgIHN0eWxlLmxlZnQgPSBNYXRoLm1pbihzdGFydFBpeGVsWzBdLCBlbmRQaXhlbFswXSkgKyBweDtcbiAgICBzdHlsZS50b3AgPSBNYXRoLm1pbihzdGFydFBpeGVsWzFdLCBlbmRQaXhlbFsxXSkgKyBweDtcbiAgICBzdHlsZS53aWR0aCA9IE1hdGguYWJzKGVuZFBpeGVsWzBdIC0gc3RhcnRQaXhlbFswXSkgKyBweDtcbiAgICBzdHlsZS5oZWlnaHQgPSBNYXRoLmFicyhlbmRQaXhlbFsxXSAtIHN0YXJ0UGl4ZWxbMV0pICsgcHg7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXAuanNcIikuZGVmYXVsdHxudWxsfSBtYXAgTWFwLlxuICAgKi9cbiAgc2V0TWFwKG1hcCkge1xuICAgIGlmICh0aGlzLm1hcF8pIHtcbiAgICAgIHRoaXMubWFwXy5nZXRPdmVybGF5Q29udGFpbmVyKCkucmVtb3ZlQ2hpbGQodGhpcy5lbGVtZW50Xyk7XG4gICAgICBjb25zdCBzdHlsZSA9IHRoaXMuZWxlbWVudF8uc3R5bGU7XG4gICAgICBzdHlsZS5sZWZ0ID0gJ2luaGVyaXQnO1xuICAgICAgc3R5bGUudG9wID0gJ2luaGVyaXQnO1xuICAgICAgc3R5bGUud2lkdGggPSAnaW5oZXJpdCc7XG4gICAgICBzdHlsZS5oZWlnaHQgPSAnaW5oZXJpdCc7XG4gICAgfVxuICAgIHRoaXMubWFwXyA9IG1hcDtcbiAgICBpZiAodGhpcy5tYXBfKSB7XG4gICAgICB0aGlzLm1hcF8uZ2V0T3ZlcmxheUNvbnRhaW5lcigpLmFwcGVuZENoaWxkKHRoaXMuZWxlbWVudF8pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3BpeGVsLmpzXCIpLlBpeGVsfSBzdGFydFBpeGVsIFN0YXJ0IHBpeGVsLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3BpeGVsLmpzXCIpLlBpeGVsfSBlbmRQaXhlbCBFbmQgcGl4ZWwuXG4gICAqL1xuICBzZXRQaXhlbHMoc3RhcnRQaXhlbCwgZW5kUGl4ZWwpIHtcbiAgICB0aGlzLnN0YXJ0UGl4ZWxfID0gc3RhcnRQaXhlbDtcbiAgICB0aGlzLmVuZFBpeGVsXyA9IGVuZFBpeGVsO1xuICAgIHRoaXMuY3JlYXRlT3JVcGRhdGVHZW9tZXRyeSgpO1xuICAgIHRoaXMucmVuZGVyXygpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgb3IgdXBkYXRlcyB0aGUgY2FjaGVkIGdlb21ldHJ5LlxuICAgKi9cbiAgY3JlYXRlT3JVcGRhdGVHZW9tZXRyeSgpIHtcbiAgICBjb25zdCBzdGFydFBpeGVsID0gdGhpcy5zdGFydFBpeGVsXztcbiAgICBjb25zdCBlbmRQaXhlbCA9IHRoaXMuZW5kUGl4ZWxfO1xuICAgIGNvbnN0IHBpeGVscyA9IFtcbiAgICAgIHN0YXJ0UGl4ZWwsXG4gICAgICBbc3RhcnRQaXhlbFswXSwgZW5kUGl4ZWxbMV1dLFxuICAgICAgZW5kUGl4ZWwsXG4gICAgICBbZW5kUGl4ZWxbMF0sIHN0YXJ0UGl4ZWxbMV1dLFxuICAgIF07XG4gICAgY29uc3QgY29vcmRpbmF0ZXMgPSBwaXhlbHMubWFwKFxuICAgICAgdGhpcy5tYXBfLmdldENvb3JkaW5hdGVGcm9tUGl4ZWxJbnRlcm5hbCxcbiAgICAgIHRoaXMubWFwX1xuICAgICk7XG4gICAgLy8gY2xvc2UgdGhlIHBvbHlnb25cbiAgICBjb29yZGluYXRlc1s0XSA9IGNvb3JkaW5hdGVzWzBdLnNsaWNlKCk7XG4gICAgaWYgKCF0aGlzLmdlb21ldHJ5Xykge1xuICAgICAgdGhpcy5nZW9tZXRyeV8gPSBuZXcgUG9seWdvbihbY29vcmRpbmF0ZXNdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5nZW9tZXRyeV8uc2V0Q29vcmRpbmF0ZXMoW2Nvb3JkaW5hdGVzXSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL2dlb20vUG9seWdvbi5qc1wiKS5kZWZhdWx0fSBHZW9tZXRyeS5cbiAgICovXG4gIGdldEdlb21ldHJ5KCkge1xuICAgIHJldHVybiB0aGlzLmdlb21ldHJ5XztcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBSZW5kZXJCb3g7XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvcmVuZGVyL0V2ZW50XG4gKi9cblxuaW1wb3J0IEV2ZW50IGZyb20gJy4uL2V2ZW50cy9FdmVudC5qcyc7XG5cbmNsYXNzIFJlbmRlckV2ZW50IGV4dGVuZHMgRXZlbnQge1xuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL0V2ZW50VHlwZS5qc1wiKS5kZWZhdWx0fSB0eXBlIFR5cGUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vdHJhbnNmb3JtLmpzXCIpLlRyYW5zZm9ybX0gW2ludmVyc2VQaXhlbFRyYW5zZm9ybV0gVHJhbnNmb3JtIGZvclxuICAgKiAgICAgQ1NTIHBpeGVscyB0byByZW5kZXJlZCBwaXhlbHMuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwLmpzXCIpLkZyYW1lU3RhdGV9IFtmcmFtZVN0YXRlXSBGcmFtZSBzdGF0ZS5cbiAgICogQHBhcmFtIHs/KENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRHxXZWJHTFJlbmRlcmluZ0NvbnRleHQpfSBbY29udGV4dF0gQ29udGV4dC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHR5cGUsIGludmVyc2VQaXhlbFRyYW5zZm9ybSwgZnJhbWVTdGF0ZSwgY29udGV4dCkge1xuICAgIHN1cGVyKHR5cGUpO1xuXG4gICAgLyoqXG4gICAgICogVHJhbnNmb3JtIGZyb20gQ1NTIHBpeGVscyAocmVsYXRpdmUgdG8gdGhlIHRvcC1sZWZ0IGNvcm5lciBvZiB0aGUgbWFwIHZpZXdwb3J0KVxuICAgICAqIHRvIHJlbmRlcmVkIHBpeGVscyBvbiB0aGlzIGV2ZW50J3MgYGNvbnRleHRgLiBPbmx5IGF2YWlsYWJsZSB3aGVuIGEgQ2FudmFzIHJlbmRlcmVyIGlzIHVzZWQsIG51bGwgb3RoZXJ3aXNlLlxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi90cmFuc2Zvcm0uanNcIikuVHJhbnNmb3JtfHVuZGVmaW5lZH1cbiAgICAgKiBAYXBpXG4gICAgICovXG4gICAgdGhpcy5pbnZlcnNlUGl4ZWxUcmFuc2Zvcm0gPSBpbnZlcnNlUGl4ZWxUcmFuc2Zvcm07XG5cbiAgICAvKipcbiAgICAgKiBBbiBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBjdXJyZW50IHJlbmRlciBmcmFtZSBzdGF0ZS5cbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vTWFwLmpzXCIpLkZyYW1lU3RhdGV8dW5kZWZpbmVkfVxuICAgICAqIEBhcGlcbiAgICAgKi9cbiAgICB0aGlzLmZyYW1lU3RhdGUgPSBmcmFtZVN0YXRlO1xuXG4gICAgLyoqXG4gICAgICogQ2FudmFzIGNvbnRleHQuIE5vdCBhdmFpbGFibGUgd2hlbiB0aGUgZXZlbnQgaXMgZGlzcGF0Y2hlZCBieSB0aGUgbWFwLiBGb3IgQ2FudmFzIDJEIGxheWVycyxcbiAgICAgKiB0aGUgY29udGV4dCB3aWxsIGJlIHRoZSAyRCByZW5kZXJpbmcgY29udGV4dC4gIEZvciBXZWJHTCBsYXllcnMsIHRoZSBjb250ZXh0IHdpbGwgYmUgdGhlIFdlYkdMXG4gICAgICogY29udGV4dC5cbiAgICAgKiBAdHlwZSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfFdlYkdMUmVuZGVyaW5nQ29udGV4dHx1bmRlZmluZWR9XG4gICAgICogQGFwaVxuICAgICAqL1xuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgUmVuZGVyRXZlbnQ7XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvcmVuZGVyL0V2ZW50VHlwZVxuICovXG5cbi8qKlxuICogQGVudW0ge3N0cmluZ31cbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICAvKipcbiAgICogVHJpZ2dlcmVkIGJlZm9yZSBhIGxheWVyIGlzIHJlbmRlcmVkLlxuICAgKiBAZXZlbnQgbW9kdWxlOm9sL3JlbmRlci9FdmVudH5SZW5kZXJFdmVudCNwcmVyZW5kZXJcbiAgICogQGFwaVxuICAgKi9cbiAgUFJFUkVOREVSOiAncHJlcmVuZGVyJyxcblxuICAvKipcbiAgICogVHJpZ2dlcmVkIGFmdGVyIGEgbGF5ZXIgaXMgcmVuZGVyZWQuXG4gICAqIEBldmVudCBtb2R1bGU6b2wvcmVuZGVyL0V2ZW50flJlbmRlckV2ZW50I3Bvc3RyZW5kZXJcbiAgICogQGFwaVxuICAgKi9cbiAgUE9TVFJFTkRFUjogJ3Bvc3RyZW5kZXInLFxuXG4gIC8qKlxuICAgKiBUcmlnZ2VyZWQgYmVmb3JlIGxheWVycyBhcmUgY29tcG9zZWQuICBXaGVuIGRpc3BhdGNoZWQgYnkgdGhlIG1hcCwgdGhlIGV2ZW50IG9iamVjdCB3aWxsIG5vdCBoYXZlXG4gICAqIGEgYGNvbnRleHRgIHNldC4gIFdoZW4gZGlzcGF0Y2hlZCBieSBhIGxheWVyLCB0aGUgZXZlbnQgb2JqZWN0IHdpbGwgaGF2ZSBhIGBjb250ZXh0YCBzZXQuICBPbmx5XG4gICAqIFdlYkdMIGxheWVycyBjdXJyZW50bHkgZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAgICogQGV2ZW50IG1vZHVsZTpvbC9yZW5kZXIvRXZlbnR+UmVuZGVyRXZlbnQjcHJlY29tcG9zZVxuICAgKiBAYXBpXG4gICAqL1xuICBQUkVDT01QT1NFOiAncHJlY29tcG9zZScsXG5cbiAgLyoqXG4gICAqIFRyaWdnZXJlZCBhZnRlciBsYXllcnMgYXJlIGNvbXBvc2VkLiAgV2hlbiBkaXNwYXRjaGVkIGJ5IHRoZSBtYXAsIHRoZSBldmVudCBvYmplY3Qgd2lsbCBub3QgaGF2ZVxuICAgKiBhIGBjb250ZXh0YCBzZXQuICBXaGVuIGRpc3BhdGNoZWQgYnkgYSBsYXllciwgdGhlIGV2ZW50IG9iamVjdCB3aWxsIGhhdmUgYSBgY29udGV4dGAgc2V0LiAgT25seVxuICAgKiBXZWJHTCBsYXllcnMgY3VycmVudGx5IGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gICAqIEBldmVudCBtb2R1bGU6b2wvcmVuZGVyL0V2ZW50flJlbmRlckV2ZW50I3Bvc3Rjb21wb3NlXG4gICAqIEBhcGlcbiAgICovXG4gIFBPU1RDT01QT1NFOiAncG9zdGNvbXBvc2UnLFxuXG4gIC8qKlxuICAgKiBUcmlnZ2VyZWQgd2hlbiByZW5kZXJpbmcgaXMgY29tcGxldGUsIGkuZS4gYWxsIHNvdXJjZXMgYW5kIHRpbGVzIGhhdmVcbiAgICogZmluaXNoZWQgbG9hZGluZyBmb3IgdGhlIGN1cnJlbnQgdmlld3BvcnQsIGFuZCBhbGwgdGlsZXMgYXJlIGZhZGVkIGluLlxuICAgKiBUaGUgZXZlbnQgb2JqZWN0IHdpbGwgbm90IGhhdmUgYSBgY29udGV4dGAgc2V0LlxuICAgKiBAZXZlbnQgbW9kdWxlOm9sL3JlbmRlci9FdmVudH5SZW5kZXJFdmVudCNyZW5kZXJjb21wbGV0ZVxuICAgKiBAYXBpXG4gICAqL1xuICBSRU5ERVJDT01QTEVURTogJ3JlbmRlcmNvbXBsZXRlJyxcbn07XG5cbi8qKlxuICogQHR5cGVkZWYgeydwb3N0cmVuZGVyJ3wncHJlY29tcG9zZSd8J3Bvc3Rjb21wb3NlJ3wncmVuZGVyY29tcGxldGUnfSBNYXBSZW5kZXJFdmVudFR5cGVzXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7J3Bvc3RyZW5kZXInfCdwcmVyZW5kZXInfSBMYXllclJlbmRlckV2ZW50VHlwZXNcbiAqL1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3JlbmRlci9WZWN0b3JDb250ZXh0XG4gKi9cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBDb250ZXh0IGZvciBkcmF3aW5nIGdlb21ldHJpZXMuICBBIHZlY3RvciBjb250ZXh0IGlzIGF2YWlsYWJsZSBvbiByZW5kZXJcbiAqIGV2ZW50cyBhbmQgZG9lcyBub3QgbmVlZCB0byBiZSBjb25zdHJ1Y3RlZCBkaXJlY3RseS5cbiAqIEBhcGlcbiAqL1xuY2xhc3MgVmVjdG9yQ29udGV4dCB7XG4gIC8qKlxuICAgKiBSZW5kZXIgYSBnZW9tZXRyeSB3aXRoIGEgY3VzdG9tIHJlbmRlcmVyLlxuICAgKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2dlb20vU2ltcGxlR2VvbWV0cnkuanNcIikuZGVmYXVsdH0gZ2VvbWV0cnkgR2VvbWV0cnkuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5GZWF0dXJlTGlrZX0gZmVhdHVyZSBGZWF0dXJlLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSByZW5kZXJlciBSZW5kZXJlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGl0RGV0ZWN0aW9uUmVuZGVyZXIgUmVuZGVyZXIuXG4gICAqL1xuICBkcmF3Q3VzdG9tKGdlb21ldHJ5LCBmZWF0dXJlLCByZW5kZXJlciwgaGl0RGV0ZWN0aW9uUmVuZGVyZXIpIHt9XG5cbiAgLyoqXG4gICAqIFJlbmRlciBhIGdlb21ldHJ5LlxuICAgKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2dlb20vR2VvbWV0cnkuanNcIikuZGVmYXVsdH0gZ2VvbWV0cnkgVGhlIGdlb21ldHJ5IHRvIHJlbmRlci5cbiAgICovXG4gIGRyYXdHZW9tZXRyeShnZW9tZXRyeSkge31cblxuICAvKipcbiAgICogU2V0IHRoZSByZW5kZXJpbmcgc3R5bGUuXG4gICAqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vc3R5bGUvU3R5bGUuanNcIikuZGVmYXVsdH0gc3R5bGUgVGhlIHJlbmRlcmluZyBzdHlsZS5cbiAgICovXG4gIHNldFN0eWxlKHN0eWxlKSB7fVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2dlb20vQ2lyY2xlLmpzXCIpLmRlZmF1bHR9IGNpcmNsZUdlb21ldHJ5IENpcmNsZSBnZW9tZXRyeS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9IGZlYXR1cmUgRmVhdHVyZS5cbiAgICovXG4gIGRyYXdDaXJjbGUoY2lyY2xlR2VvbWV0cnksIGZlYXR1cmUpIHt9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0fSBmZWF0dXJlIEZlYXR1cmUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vc3R5bGUvU3R5bGUuanNcIikuZGVmYXVsdH0gc3R5bGUgU3R5bGUuXG4gICAqL1xuICBkcmF3RmVhdHVyZShmZWF0dXJlLCBzdHlsZSkge31cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9nZW9tL0dlb21ldHJ5Q29sbGVjdGlvbi5qc1wiKS5kZWZhdWx0fSBnZW9tZXRyeUNvbGxlY3Rpb25HZW9tZXRyeSBHZW9tZXRyeSBjb2xsZWN0aW9uLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdH0gZmVhdHVyZSBGZWF0dXJlLlxuICAgKi9cbiAgZHJhd0dlb21ldHJ5Q29sbGVjdGlvbihnZW9tZXRyeUNvbGxlY3Rpb25HZW9tZXRyeSwgZmVhdHVyZSkge31cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9nZW9tL0xpbmVTdHJpbmcuanNcIikuZGVmYXVsdHxpbXBvcnQoXCIuL0ZlYXR1cmUuanNcIikuZGVmYXVsdH0gbGluZVN0cmluZ0dlb21ldHJ5IExpbmUgc3RyaW5nIGdlb21ldHJ5LlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuRmVhdHVyZUxpa2V9IGZlYXR1cmUgRmVhdHVyZS5cbiAgICovXG4gIGRyYXdMaW5lU3RyaW5nKGxpbmVTdHJpbmdHZW9tZXRyeSwgZmVhdHVyZSkge31cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9nZW9tL011bHRpTGluZVN0cmluZy5qc1wiKS5kZWZhdWx0fGltcG9ydChcIi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0fSBtdWx0aUxpbmVTdHJpbmdHZW9tZXRyeSBNdWx0aUxpbmVTdHJpbmcgZ2VvbWV0cnkuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5GZWF0dXJlTGlrZX0gZmVhdHVyZSBGZWF0dXJlLlxuICAgKi9cbiAgZHJhd011bHRpTGluZVN0cmluZyhtdWx0aUxpbmVTdHJpbmdHZW9tZXRyeSwgZmVhdHVyZSkge31cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9nZW9tL011bHRpUG9pbnQuanNcIikuZGVmYXVsdHxpbXBvcnQoXCIuL0ZlYXR1cmUuanNcIikuZGVmYXVsdH0gbXVsdGlQb2ludEdlb21ldHJ5IE11bHRpUG9pbnQgZ2VvbWV0cnkuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5GZWF0dXJlTGlrZX0gZmVhdHVyZSBGZWF0dXJlLlxuICAgKi9cbiAgZHJhd011bHRpUG9pbnQobXVsdGlQb2ludEdlb21ldHJ5LCBmZWF0dXJlKSB7fVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2dlb20vTXVsdGlQb2x5Z29uLmpzXCIpLmRlZmF1bHR9IG11bHRpUG9seWdvbkdlb21ldHJ5IE11bHRpUG9seWdvbiBnZW9tZXRyeS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLkZlYXR1cmVMaWtlfSBmZWF0dXJlIEZlYXR1cmUuXG4gICAqL1xuICBkcmF3TXVsdGlQb2x5Z29uKG11bHRpUG9seWdvbkdlb21ldHJ5LCBmZWF0dXJlKSB7fVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2dlb20vUG9pbnQuanNcIikuZGVmYXVsdHxpbXBvcnQoXCIuL0ZlYXR1cmUuanNcIikuZGVmYXVsdH0gcG9pbnRHZW9tZXRyeSBQb2ludCBnZW9tZXRyeS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLkZlYXR1cmVMaWtlfSBmZWF0dXJlIEZlYXR1cmUuXG4gICAqL1xuICBkcmF3UG9pbnQocG9pbnRHZW9tZXRyeSwgZmVhdHVyZSkge31cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9nZW9tL1BvbHlnb24uanNcIikuZGVmYXVsdHxpbXBvcnQoXCIuL0ZlYXR1cmUuanNcIikuZGVmYXVsdH0gcG9seWdvbkdlb21ldHJ5IFBvbHlnb24gZ2VvbWV0cnkuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5GZWF0dXJlTGlrZX0gZmVhdHVyZSBGZWF0dXJlLlxuICAgKi9cbiAgZHJhd1BvbHlnb24ocG9seWdvbkdlb21ldHJ5LCBmZWF0dXJlKSB7fVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2dlb20vU2ltcGxlR2VvbWV0cnkuanNcIikuZGVmYXVsdHxpbXBvcnQoXCIuL0ZlYXR1cmUuanNcIikuZGVmYXVsdH0gZ2VvbWV0cnkgR2VvbWV0cnkuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5GZWF0dXJlTGlrZX0gZmVhdHVyZSBGZWF0dXJlLlxuICAgKi9cbiAgZHJhd1RleHQoZ2VvbWV0cnksIGZlYXR1cmUpIHt9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vc3R5bGUvRmlsbC5qc1wiKS5kZWZhdWx0fSBmaWxsU3R5bGUgRmlsbCBzdHlsZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9zdHlsZS9TdHJva2UuanNcIikuZGVmYXVsdH0gc3Ryb2tlU3R5bGUgU3Ryb2tlIHN0eWxlLlxuICAgKi9cbiAgc2V0RmlsbFN0cm9rZVN0eWxlKGZpbGxTdHlsZSwgc3Ryb2tlU3R5bGUpIHt9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vc3R5bGUvSW1hZ2UuanNcIikuZGVmYXVsdH0gaW1hZ2VTdHlsZSBJbWFnZSBzdHlsZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9yZW5kZXIvY2FudmFzLmpzXCIpLkRlY2x1dHRlckltYWdlV2l0aFRleHR9IFtkZWNsdXR0ZXJJbWFnZVdpdGhUZXh0XSBTaGFyZWQgZGF0YSBmb3IgY29tYmluZWQgZGVjbHV0dGVyaW5nIHdpdGggYSB0ZXh0IHN0eWxlLlxuICAgKi9cbiAgc2V0SW1hZ2VTdHlsZShpbWFnZVN0eWxlLCBkZWNsdXR0ZXJJbWFnZVdpdGhUZXh0KSB7fVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3N0eWxlL1RleHQuanNcIikuZGVmYXVsdH0gdGV4dFN0eWxlIFRleHQgc3R5bGUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcmVuZGVyL2NhbnZhcy5qc1wiKS5EZWNsdXR0ZXJJbWFnZVdpdGhUZXh0fSBbZGVjbHV0dGVySW1hZ2VXaXRoVGV4dF0gU2hhcmVkIGRhdGEgZm9yIGNvbWJpbmVkIGRlY2x1dHRlcmluZyB3aXRoIGFuIGltYWdlIHN0eWxlLlxuICAgKi9cbiAgc2V0VGV4dFN0eWxlKHRleHRTdHlsZSwgZGVjbHV0dGVySW1hZ2VXaXRoVGV4dCkge31cbn1cblxuZXhwb3J0IGRlZmF1bHQgVmVjdG9yQ29udGV4dDtcbiIsIi8qKlxuICogQG1vZHVsZSBvbC9yZW5kZXIvY2FudmFzXG4gKi9cbmltcG9ydCBCYXNlT2JqZWN0IGZyb20gJy4uL09iamVjdC5qcyc7XG5pbXBvcnQge1dPUktFUl9PRkZTQ1JFRU5fQ0FOVkFTfSBmcm9tICcuLi9oYXMuanMnO1xuaW1wb3J0IHtjbGVhcn0gZnJvbSAnLi4vb2JqLmpzJztcbmltcG9ydCB7Y3JlYXRlQ2FudmFzQ29udGV4dDJEfSBmcm9tICcuLi9kb20uanMnO1xuaW1wb3J0IHtnZXRGb250UGFyYW1ldGVyc30gZnJvbSAnLi4vY3NzLmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7J0NpcmNsZScgfCAnSW1hZ2UnIHwgJ0xpbmVTdHJpbmcnIHwgJ1BvbHlnb24nIHwgJ1RleHQnIHwgJ0RlZmF1bHQnfSBCdWlsZGVyVHlwZVxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gRmlsbFN0YXRlXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL2NvbG9ybGlrZS5qc1wiKS5Db2xvckxpa2V9IGZpbGxTdHlsZSBGaWxsU3R5bGUuXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiBMYWJlbFxuICogQHByb3BlcnR5IHtudW1iZXJ9IHdpZHRoIFdpZHRoLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IGhlaWdodCBIZWlnaHQuXG4gKiBAcHJvcGVydHkge0FycmF5PHN0cmluZ3xudW1iZXI+fSBjb250ZXh0SW5zdHJ1Y3Rpb25zIENvbnRleHRJbnN0cnVjdGlvbnMuXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBGaWxsU3Ryb2tlU3RhdGVcbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vY29sb3JsaWtlLmpzXCIpLkNvbG9yTGlrZX0gW2N1cnJlbnRGaWxsU3R5bGVdIEN1cnJlbnQgRmlsbFN0eWxlLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9jb2xvcmxpa2UuanNcIikuQ29sb3JMaWtlfSBbY3VycmVudFN0cm9rZVN0eWxlXSBDdXJyZW50IFN0cm9rZVN0eWxlLlxuICogQHByb3BlcnR5IHtDYW52YXNMaW5lQ2FwfSBbY3VycmVudExpbmVDYXBdIEN1cnJlbnQgTGluZUNhcC5cbiAqIEBwcm9wZXJ0eSB7QXJyYXk8bnVtYmVyPn0gY3VycmVudExpbmVEYXNoIEN1cnJlbnQgTGluZURhc2guXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2N1cnJlbnRMaW5lRGFzaE9mZnNldF0gQ3VycmVudCBMaW5lRGFzaE9mZnNldC5cbiAqIEBwcm9wZXJ0eSB7Q2FudmFzTGluZUpvaW59IFtjdXJyZW50TGluZUpvaW5dIEN1cnJlbnQgTGluZUpvaW4uXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2N1cnJlbnRMaW5lV2lkdGhdIEN1cnJlbnQgTGluZVdpZHRoLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtjdXJyZW50TWl0ZXJMaW1pdF0gQ3VycmVudCBNaXRlckxpbWl0LlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtsYXN0U3Ryb2tlXSBMYXN0IHN0cm9rZS5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vY29sb3JsaWtlLmpzXCIpLkNvbG9yTGlrZX0gW2ZpbGxTdHlsZV0gRmlsbFN0eWxlLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9jb2xvcmxpa2UuanNcIikuQ29sb3JMaWtlfSBbc3Ryb2tlU3R5bGVdIFN0cm9rZVN0eWxlLlxuICogQHByb3BlcnR5IHtDYW52YXNMaW5lQ2FwfSBbbGluZUNhcF0gTGluZUNhcC5cbiAqIEBwcm9wZXJ0eSB7QXJyYXk8bnVtYmVyPn0gbGluZURhc2ggTGluZURhc2guXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2xpbmVEYXNoT2Zmc2V0XSBMaW5lRGFzaE9mZnNldC5cbiAqIEBwcm9wZXJ0eSB7Q2FudmFzTGluZUpvaW59IFtsaW5lSm9pbl0gTGluZUpvaW4uXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2xpbmVXaWR0aF0gTGluZVdpZHRoLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFttaXRlckxpbWl0XSBNaXRlckxpbWl0LlxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gU3Ryb2tlU3RhdGVcbiAqIEBwcm9wZXJ0eSB7Q2FudmFzTGluZUNhcH0gbGluZUNhcCBMaW5lQ2FwLlxuICogQHByb3BlcnR5IHtBcnJheTxudW1iZXI+fSBsaW5lRGFzaCBMaW5lRGFzaC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBsaW5lRGFzaE9mZnNldCBMaW5lRGFzaE9mZnNldC5cbiAqIEBwcm9wZXJ0eSB7Q2FudmFzTGluZUpvaW59IGxpbmVKb2luIExpbmVKb2luLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IGxpbmVXaWR0aCBMaW5lV2lkdGguXG4gKiBAcHJvcGVydHkge251bWJlcn0gbWl0ZXJMaW1pdCBNaXRlckxpbWl0LlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9jb2xvcmxpa2UuanNcIikuQ29sb3JMaWtlfSBzdHJva2VTdHlsZSBTdHJva2VTdHlsZS5cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFRleHRTdGF0ZVxuICogQHByb3BlcnR5IHtzdHJpbmd9IGZvbnQgRm9udC5cbiAqIEBwcm9wZXJ0eSB7Q2FudmFzVGV4dEFsaWdufSBbdGV4dEFsaWduXSBUZXh0QWxpZ24uXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3JlcGVhdF0gUmVwZWF0LlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9zdHlsZS9UZXh0LmpzXCIpLlRleHRKdXN0aWZ5fSBbanVzdGlmeV0gSnVzdGlmeS5cbiAqIEBwcm9wZXJ0eSB7Q2FudmFzVGV4dEJhc2VsaW5lfSB0ZXh0QmFzZWxpbmUgVGV4dEJhc2VsaW5lLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9zdHlsZS9UZXh0LmpzXCIpLlRleHRQbGFjZW1lbnR9IFtwbGFjZW1lbnRdIFBsYWNlbWVudC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbWF4QW5nbGVdIE1heEFuZ2xlLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbb3ZlcmZsb3ddIE92ZXJmbG93LlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9zdHlsZS9GaWxsLmpzXCIpLmRlZmF1bHR9IFtiYWNrZ3JvdW5kRmlsbF0gQmFja2dyb3VuZEZpbGwuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL3N0eWxlL1N0cm9rZS5qc1wiKS5kZWZhdWx0fSBbYmFja2dyb3VuZFN0cm9rZV0gQmFja2dyb3VuZFN0cm9rZS5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vc2l6ZS5qc1wiKS5TaXplfSBbc2NhbGVdIFNjYWxlLlxuICogQHByb3BlcnR5IHtBcnJheTxudW1iZXI+fSBbcGFkZGluZ10gUGFkZGluZy5cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFNlcmlhbGl6YWJsZUluc3RydWN0aW9uc1xuICogQHByb3BlcnR5IHtBcnJheTwqPn0gaW5zdHJ1Y3Rpb25zIFRoZSByZW5kZXJpbmcgaW5zdHJ1Y3Rpb25zLlxuICogQHByb3BlcnR5IHtBcnJheTwqPn0gaGl0RGV0ZWN0aW9uSW5zdHJ1Y3Rpb25zIFRoZSByZW5kZXJpbmcgaGl0IGRldGVjdGlvbiBpbnN0cnVjdGlvbnMuXG4gKiBAcHJvcGVydHkge0FycmF5PG51bWJlcj59IGNvb3JkaW5hdGVzIFRoZSBhcnJheSBvZiBhbGwgY29vcmRpbmF0ZXMuXG4gKiBAcHJvcGVydHkgeyFPYmplY3Q8c3RyaW5nLCBUZXh0U3RhdGU+fSBbdGV4dFN0YXRlc10gVGhlIHRleHQgc3RhdGVzIChkZWNsdXR0ZXJpbmcpLlxuICogQHByb3BlcnR5IHshT2JqZWN0PHN0cmluZywgRmlsbFN0YXRlPn0gW2ZpbGxTdGF0ZXNdIFRoZSBmaWxsIHN0YXRlcyAoZGVjbHV0dGVyaW5nKS5cbiAqIEBwcm9wZXJ0eSB7IU9iamVjdDxzdHJpbmcsIFN0cm9rZVN0YXRlPn0gW3N0cm9rZVN0YXRlc10gVGhlIHN0cm9rZSBzdGF0ZXMgKGRlY2x1dHRlcmluZykuXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0PG51bWJlciwgaW1wb3J0KFwiLi9jYW52YXMvRXhlY3V0b3IuanNcIikuUmVwbGF5SW1hZ2VPckxhYmVsQXJncz59IERlY2x1dHRlckltYWdlV2l0aFRleHRcbiAqL1xuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge3N0cmluZ31cbiAqL1xuZXhwb3J0IGNvbnN0IGRlZmF1bHRGb250ID0gJzEwcHggc2Fucy1zZXJpZic7XG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG5leHBvcnQgY29uc3QgZGVmYXVsdEZpbGxTdHlsZSA9ICcjMDAwJztcblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtDYW52YXNMaW5lQ2FwfVxuICovXG5leHBvcnQgY29uc3QgZGVmYXVsdExpbmVDYXAgPSAncm91bmQnO1xuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge0FycmF5PG51bWJlcj59XG4gKi9cbmV4cG9ydCBjb25zdCBkZWZhdWx0TGluZURhc2ggPSBbXTtcblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCBkZWZhdWx0TGluZURhc2hPZmZzZXQgPSAwO1xuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge0NhbnZhc0xpbmVKb2lufVxuICovXG5leHBvcnQgY29uc3QgZGVmYXVsdExpbmVKb2luID0gJ3JvdW5kJztcblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCBkZWZhdWx0TWl0ZXJMaW1pdCA9IDEwO1xuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge2ltcG9ydChcIi4uL2NvbG9ybGlrZS5qc1wiKS5Db2xvckxpa2V9XG4gKi9cbmV4cG9ydCBjb25zdCBkZWZhdWx0U3Ryb2tlU3R5bGUgPSAnIzAwMCc7XG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7Q2FudmFzVGV4dEFsaWdufVxuICovXG5leHBvcnQgY29uc3QgZGVmYXVsdFRleHRBbGlnbiA9ICdjZW50ZXInO1xuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge0NhbnZhc1RleHRCYXNlbGluZX1cbiAqL1xuZXhwb3J0IGNvbnN0IGRlZmF1bHRUZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtBcnJheTxudW1iZXI+fVxuICovXG5leHBvcnQgY29uc3QgZGVmYXVsdFBhZGRpbmcgPSBbMCwgMCwgMCwgMF07XG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5leHBvcnQgY29uc3QgZGVmYXVsdExpbmVXaWR0aCA9IDE7XG5cbi8qKlxuICogQHR5cGUge0Jhc2VPYmplY3R9XG4gKi9cbmV4cG9ydCBjb25zdCBjaGVja2VkRm9udHMgPSBuZXcgQmFzZU9iamVjdCgpO1xuXG4vKipcbiAqIEB0eXBlIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9XG4gKi9cbmxldCBtZWFzdXJlQ29udGV4dCA9IG51bGw7XG5cbi8qKlxuICogQHR5cGUge3N0cmluZ31cbiAqL1xubGV0IG1lYXN1cmVGb250O1xuXG4vKipcbiAqIEB0eXBlIHshT2JqZWN0PHN0cmluZywgbnVtYmVyPn1cbiAqL1xuZXhwb3J0IGNvbnN0IHRleHRIZWlnaHRzID0ge307XG5cbi8qKlxuICogQ2xlYXJzIHRoZSBsYWJlbCBjYWNoZSB3aGVuIGEgZm9udCBiZWNvbWVzIGF2YWlsYWJsZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBmb250U3BlYyBDU1MgZm9udCBzcGVjLlxuICovXG5leHBvcnQgY29uc3QgcmVnaXN0ZXJGb250ID0gKGZ1bmN0aW9uICgpIHtcbiAgY29uc3QgcmV0cmllcyA9IDEwMDtcbiAgY29uc3Qgc2l6ZSA9ICczMnB4ICc7XG4gIGNvbnN0IHJlZmVyZW5jZUZvbnRzID0gWydtb25vc3BhY2UnLCAnc2VyaWYnXTtcbiAgY29uc3QgbGVuID0gcmVmZXJlbmNlRm9udHMubGVuZ3RoO1xuICBjb25zdCB0ZXh0ID0gJ3dteXR6aWxXTVlUWklMQCMvJj8kJTEwXFx1RjAxMyc7XG4gIGxldCBpbnRlcnZhbCwgcmVmZXJlbmNlV2lkdGg7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmb250U3R5bGUgQ3NzIGZvbnQtc3R5bGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZvbnRXZWlnaHQgQ3NzIGZvbnQtd2VpZ2h0XG4gICAqIEBwYXJhbSB7Kn0gZm9udEZhbWlseSBDc3MgZm9udC1mYW1pbHlcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gRm9udCB3aXRoIHN0eWxlIGFuZCB3ZWlnaHQgaXMgYXZhaWxhYmxlXG4gICAqL1xuICBmdW5jdGlvbiBpc0F2YWlsYWJsZShmb250U3R5bGUsIGZvbnRXZWlnaHQsIGZvbnRGYW1pbHkpIHtcbiAgICBsZXQgYXZhaWxhYmxlID0gdHJ1ZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICBjb25zdCByZWZlcmVuY2VGb250ID0gcmVmZXJlbmNlRm9udHNbaV07XG4gICAgICByZWZlcmVuY2VXaWR0aCA9IG1lYXN1cmVUZXh0V2lkdGgoXG4gICAgICAgIGZvbnRTdHlsZSArICcgJyArIGZvbnRXZWlnaHQgKyAnICcgKyBzaXplICsgcmVmZXJlbmNlRm9udCxcbiAgICAgICAgdGV4dFxuICAgICAgKTtcbiAgICAgIGlmIChmb250RmFtaWx5ICE9IHJlZmVyZW5jZUZvbnQpIHtcbiAgICAgICAgY29uc3Qgd2lkdGggPSBtZWFzdXJlVGV4dFdpZHRoKFxuICAgICAgICAgIGZvbnRTdHlsZSArXG4gICAgICAgICAgICAnICcgK1xuICAgICAgICAgICAgZm9udFdlaWdodCArXG4gICAgICAgICAgICAnICcgK1xuICAgICAgICAgICAgc2l6ZSArXG4gICAgICAgICAgICBmb250RmFtaWx5ICtcbiAgICAgICAgICAgICcsJyArXG4gICAgICAgICAgICByZWZlcmVuY2VGb250LFxuICAgICAgICAgIHRleHRcbiAgICAgICAgKTtcbiAgICAgICAgLy8gSWYgd2lkdGggYW5kIHJlZmVyZW5jZVdpZHRoIGFyZSB0aGUgc2FtZSwgdGhlbiB0aGUgZmFsbGJhY2sgd2FzIHVzZWRcbiAgICAgICAgLy8gaW5zdGVhZCBvZiB0aGUgZm9udCB3ZSB3YW50ZWQsIHNvIHRoZSBmb250IGlzIG5vdCBhdmFpbGFibGUuXG4gICAgICAgIGF2YWlsYWJsZSA9IGF2YWlsYWJsZSAmJiB3aWR0aCAhPSByZWZlcmVuY2VXaWR0aDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGF2YWlsYWJsZSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNoZWNrKCkge1xuICAgIGxldCBkb25lID0gdHJ1ZTtcbiAgICBjb25zdCBmb250cyA9IGNoZWNrZWRGb250cy5nZXRLZXlzKCk7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gZm9udHMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgY29uc3QgZm9udCA9IGZvbnRzW2ldO1xuICAgICAgaWYgKGNoZWNrZWRGb250cy5nZXQoZm9udCkgPCByZXRyaWVzKSB7XG4gICAgICAgIGlmIChpc0F2YWlsYWJsZS5hcHBseSh0aGlzLCBmb250LnNwbGl0KCdcXG4nKSkpIHtcbiAgICAgICAgICBjbGVhcih0ZXh0SGVpZ2h0cyk7XG4gICAgICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgbG9hZGVkIGZvbnRzIGFyZSBwaWNrZWQgdXAgYnkgU2FmYXJpXG4gICAgICAgICAgbWVhc3VyZUNvbnRleHQgPSBudWxsO1xuICAgICAgICAgIG1lYXN1cmVGb250ID0gdW5kZWZpbmVkO1xuICAgICAgICAgIGNoZWNrZWRGb250cy5zZXQoZm9udCwgcmV0cmllcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2hlY2tlZEZvbnRzLnNldChmb250LCBjaGVja2VkRm9udHMuZ2V0KGZvbnQpICsgMSwgdHJ1ZSk7XG4gICAgICAgICAgZG9uZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChkb25lKSB7XG4gICAgICBjbGVhckludGVydmFsKGludGVydmFsKTtcbiAgICAgIGludGVydmFsID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoZm9udFNwZWMpIHtcbiAgICBjb25zdCBmb250ID0gZ2V0Rm9udFBhcmFtZXRlcnMoZm9udFNwZWMpO1xuICAgIGlmICghZm9udCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBmYW1pbGllcyA9IGZvbnQuZmFtaWxpZXM7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gZmFtaWxpZXMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgY29uc3QgZmFtaWx5ID0gZmFtaWxpZXNbaV07XG4gICAgICBjb25zdCBrZXkgPSBmb250LnN0eWxlICsgJ1xcbicgKyBmb250LndlaWdodCArICdcXG4nICsgZmFtaWx5O1xuICAgICAgaWYgKGNoZWNrZWRGb250cy5nZXQoa2V5KSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNoZWNrZWRGb250cy5zZXQoa2V5LCByZXRyaWVzLCB0cnVlKTtcbiAgICAgICAgaWYgKCFpc0F2YWlsYWJsZShmb250LnN0eWxlLCBmb250LndlaWdodCwgZmFtaWx5KSkge1xuICAgICAgICAgIGNoZWNrZWRGb250cy5zZXQoa2V5LCAwLCB0cnVlKTtcbiAgICAgICAgICBpZiAoaW50ZXJ2YWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChjaGVjaywgMzIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcbn0pKCk7XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGZvbnQgRm9udCB0byB1c2UgZm9yIG1lYXN1cmluZy5cbiAqIEByZXR1cm4ge2ltcG9ydChcIi4uL3NpemUuanNcIikuU2l6ZX0gTWVhc3VyZW1lbnQuXG4gKi9cbmV4cG9ydCBjb25zdCBtZWFzdXJlVGV4dEhlaWdodCA9IChmdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAdHlwZSB7SFRNTERpdkVsZW1lbnR9XG4gICAqL1xuICBsZXQgbWVhc3VyZUVsZW1lbnQ7XG4gIHJldHVybiBmdW5jdGlvbiAoZm9udFNwZWMpIHtcbiAgICBsZXQgaGVpZ2h0ID0gdGV4dEhlaWdodHNbZm9udFNwZWNdO1xuICAgIGlmIChoZWlnaHQgPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoV09SS0VSX09GRlNDUkVFTl9DQU5WQVMpIHtcbiAgICAgICAgY29uc3QgZm9udCA9IGdldEZvbnRQYXJhbWV0ZXJzKGZvbnRTcGVjKTtcbiAgICAgICAgY29uc3QgbWV0cmljcyA9IG1lYXN1cmVUZXh0KGZvbnRTcGVjLCAnxb1nJyk7XG4gICAgICAgIGNvbnN0IGxpbmVIZWlnaHQgPSBpc05hTihOdW1iZXIoZm9udC5saW5lSGVpZ2h0KSlcbiAgICAgICAgICA/IDEuMlxuICAgICAgICAgIDogTnVtYmVyKGZvbnQubGluZUhlaWdodCk7XG4gICAgICAgIGhlaWdodCA9XG4gICAgICAgICAgbGluZUhlaWdodCAqXG4gICAgICAgICAgKG1ldHJpY3MuYWN0dWFsQm91bmRpbmdCb3hBc2NlbnQgKyBtZXRyaWNzLmFjdHVhbEJvdW5kaW5nQm94RGVzY2VudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIW1lYXN1cmVFbGVtZW50KSB7XG4gICAgICAgICAgbWVhc3VyZUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICBtZWFzdXJlRWxlbWVudC5pbm5lckhUTUwgPSAnTSc7XG4gICAgICAgICAgbWVhc3VyZUVsZW1lbnQuc3R5bGUubWluSGVpZ2h0ID0gJzAnO1xuICAgICAgICAgIG1lYXN1cmVFbGVtZW50LnN0eWxlLm1heEhlaWdodCA9ICdub25lJztcbiAgICAgICAgICBtZWFzdXJlRWxlbWVudC5zdHlsZS5oZWlnaHQgPSAnYXV0byc7XG4gICAgICAgICAgbWVhc3VyZUVsZW1lbnQuc3R5bGUucGFkZGluZyA9ICcwJztcbiAgICAgICAgICBtZWFzdXJlRWxlbWVudC5zdHlsZS5ib3JkZXIgPSAnbm9uZSc7XG4gICAgICAgICAgbWVhc3VyZUVsZW1lbnQuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgICAgIG1lYXN1cmVFbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgICAgIG1lYXN1cmVFbGVtZW50LnN0eWxlLmxlZnQgPSAnLTk5OTk5cHgnO1xuICAgICAgICB9XG4gICAgICAgIG1lYXN1cmVFbGVtZW50LnN0eWxlLmZvbnQgPSBmb250U3BlYztcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChtZWFzdXJlRWxlbWVudCk7XG4gICAgICAgIGhlaWdodCA9IG1lYXN1cmVFbGVtZW50Lm9mZnNldEhlaWdodDtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChtZWFzdXJlRWxlbWVudCk7XG4gICAgICB9XG4gICAgICB0ZXh0SGVpZ2h0c1tmb250U3BlY10gPSBoZWlnaHQ7XG4gICAgfVxuICAgIHJldHVybiBoZWlnaHQ7XG4gIH07XG59KSgpO1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBmb250IEZvbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBUZXh0LlxuICogQHJldHVybiB7VGV4dE1ldHJpY3N9IFRleHQgbWV0cmljcy5cbiAqL1xuZnVuY3Rpb24gbWVhc3VyZVRleHQoZm9udCwgdGV4dCkge1xuICBpZiAoIW1lYXN1cmVDb250ZXh0KSB7XG4gICAgbWVhc3VyZUNvbnRleHQgPSBjcmVhdGVDYW52YXNDb250ZXh0MkQoMSwgMSk7XG4gIH1cbiAgaWYgKGZvbnQgIT0gbWVhc3VyZUZvbnQpIHtcbiAgICBtZWFzdXJlQ29udGV4dC5mb250ID0gZm9udDtcbiAgICBtZWFzdXJlRm9udCA9IG1lYXN1cmVDb250ZXh0LmZvbnQ7XG4gIH1cbiAgcmV0dXJuIG1lYXN1cmVDb250ZXh0Lm1lYXN1cmVUZXh0KHRleHQpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBmb250IEZvbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBUZXh0LlxuICogQHJldHVybiB7bnVtYmVyfSBXaWR0aC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1lYXN1cmVUZXh0V2lkdGgoZm9udCwgdGV4dCkge1xuICByZXR1cm4gbWVhc3VyZVRleHQoZm9udCwgdGV4dCkud2lkdGg7XG59XG5cbi8qKlxuICogTWVhc3VyZSB0ZXh0IHdpZHRoIHVzaW5nIGEgY2FjaGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gZm9udCBUaGUgZm9udC5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IFRoZSB0ZXh0IHRvIG1lYXN1cmUuXG4gKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsIG51bWJlcj59IGNhY2hlIEEgbG9va3VwIG9mIGNhY2hlZCB3aWR0aHMgYnkgdGV4dC5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIHRleHQgd2lkdGguXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtZWFzdXJlQW5kQ2FjaGVUZXh0V2lkdGgoZm9udCwgdGV4dCwgY2FjaGUpIHtcbiAgaWYgKHRleHQgaW4gY2FjaGUpIHtcbiAgICByZXR1cm4gY2FjaGVbdGV4dF07XG4gIH1cbiAgY29uc3Qgd2lkdGggPSB0ZXh0XG4gICAgLnNwbGl0KCdcXG4nKVxuICAgIC5yZWR1Y2UoKHByZXYsIGN1cnIpID0+IE1hdGgubWF4KHByZXYsIG1lYXN1cmVUZXh0V2lkdGgoZm9udCwgY3VycikpLCAwKTtcbiAgY2FjaGVbdGV4dF0gPSB3aWR0aDtcbiAgcmV0dXJuIHdpZHRoO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7VGV4dFN0YXRlfSBiYXNlU3R5bGUgQmFzZSBzdHlsZS5cbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gY2h1bmtzIFRleHQgY2h1bmtzIHRvIG1lYXN1cmUuXG4gKiBAcmV0dXJuIHt7d2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXIsIHdpZHRoczogQXJyYXk8bnVtYmVyPiwgaGVpZ2h0czogQXJyYXk8bnVtYmVyPiwgbGluZVdpZHRoczogQXJyYXk8bnVtYmVyPn19fSBUZXh0IG1ldHJpY3MuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRUZXh0RGltZW5zaW9ucyhiYXNlU3R5bGUsIGNodW5rcykge1xuICBjb25zdCB3aWR0aHMgPSBbXTtcbiAgY29uc3QgaGVpZ2h0cyA9IFtdO1xuICBjb25zdCBsaW5lV2lkdGhzID0gW107XG4gIGxldCB3aWR0aCA9IDA7XG4gIGxldCBsaW5lV2lkdGggPSAwO1xuICBsZXQgaGVpZ2h0ID0gMDtcbiAgbGV0IGxpbmVIZWlnaHQgPSAwO1xuICBmb3IgKGxldCBpID0gMCwgaWkgPSBjaHVua3MubGVuZ3RoOyBpIDw9IGlpOyBpICs9IDIpIHtcbiAgICBjb25zdCB0ZXh0ID0gY2h1bmtzW2ldO1xuICAgIGlmICh0ZXh0ID09PSAnXFxuJyB8fCBpID09PSBpaSkge1xuICAgICAgd2lkdGggPSBNYXRoLm1heCh3aWR0aCwgbGluZVdpZHRoKTtcbiAgICAgIGxpbmVXaWR0aHMucHVzaChsaW5lV2lkdGgpO1xuICAgICAgbGluZVdpZHRoID0gMDtcbiAgICAgIGhlaWdodCArPSBsaW5lSGVpZ2h0O1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IGZvbnQgPSBjaHVua3NbaSArIDFdIHx8IGJhc2VTdHlsZS5mb250O1xuICAgIGNvbnN0IGN1cnJlbnRXaWR0aCA9IG1lYXN1cmVUZXh0V2lkdGgoZm9udCwgdGV4dCk7XG4gICAgd2lkdGhzLnB1c2goY3VycmVudFdpZHRoKTtcbiAgICBsaW5lV2lkdGggKz0gY3VycmVudFdpZHRoO1xuICAgIGNvbnN0IGN1cnJlbnRIZWlnaHQgPSBtZWFzdXJlVGV4dEhlaWdodChmb250KTtcbiAgICBoZWlnaHRzLnB1c2goY3VycmVudEhlaWdodCk7XG4gICAgbGluZUhlaWdodCA9IE1hdGgubWF4KGxpbmVIZWlnaHQsIGN1cnJlbnRIZWlnaHQpO1xuICB9XG4gIHJldHVybiB7d2lkdGgsIGhlaWdodCwgd2lkdGhzLCBoZWlnaHRzLCBsaW5lV2lkdGhzfTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY29udGV4dCBDb250ZXh0LlxuICogQHBhcmFtIHtudW1iZXJ9IHJvdGF0aW9uIFJvdGF0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFggWCBvZmZzZXQuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0WSBZIG9mZnNldC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJvdGF0ZUF0T2Zmc2V0KGNvbnRleHQsIHJvdGF0aW9uLCBvZmZzZXRYLCBvZmZzZXRZKSB7XG4gIGlmIChyb3RhdGlvbiAhPT0gMCkge1xuICAgIGNvbnRleHQudHJhbnNsYXRlKG9mZnNldFgsIG9mZnNldFkpO1xuICAgIGNvbnRleHQucm90YXRlKHJvdGF0aW9uKTtcbiAgICBjb250ZXh0LnRyYW5zbGF0ZSgtb2Zmc2V0WCwgLW9mZnNldFkpO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHQgQ29udGV4dC5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vdHJhbnNmb3JtLmpzXCIpLlRyYW5zZm9ybXxudWxsfSB0cmFuc2Zvcm0gVHJhbnNmb3JtLlxuICogQHBhcmFtIHtudW1iZXJ9IG9wYWNpdHkgT3BhY2l0eS5cbiAqIEBwYXJhbSB7TGFiZWx8SFRNTENhbnZhc0VsZW1lbnR8SFRNTEltYWdlRWxlbWVudHxIVE1MVmlkZW9FbGVtZW50fSBsYWJlbE9ySW1hZ2UgTGFiZWwuXG4gKiBAcGFyYW0ge251bWJlcn0gb3JpZ2luWCBPcmlnaW4gWC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvcmlnaW5ZIE9yaWdpbiBZLlxuICogQHBhcmFtIHtudW1iZXJ9IHcgV2lkdGguXG4gKiBAcGFyYW0ge251bWJlcn0gaCBIZWlnaHQuXG4gKiBAcGFyYW0ge251bWJlcn0geCBYLlxuICogQHBhcmFtIHtudW1iZXJ9IHkgWS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vc2l6ZS5qc1wiKS5TaXplfSBzY2FsZSBTY2FsZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRyYXdJbWFnZU9yTGFiZWwoXG4gIGNvbnRleHQsXG4gIHRyYW5zZm9ybSxcbiAgb3BhY2l0eSxcbiAgbGFiZWxPckltYWdlLFxuICBvcmlnaW5YLFxuICBvcmlnaW5ZLFxuICB3LFxuICBoLFxuICB4LFxuICB5LFxuICBzY2FsZVxuKSB7XG4gIGNvbnRleHQuc2F2ZSgpO1xuXG4gIGlmIChvcGFjaXR5ICE9PSAxKSB7XG4gICAgY29udGV4dC5nbG9iYWxBbHBoYSAqPSBvcGFjaXR5O1xuICB9XG4gIGlmICh0cmFuc2Zvcm0pIHtcbiAgICBjb250ZXh0LnRyYW5zZm9ybS5hcHBseShjb250ZXh0LCB0cmFuc2Zvcm0pO1xuICB9XG5cbiAgaWYgKC8qKiBAdHlwZSB7Kn0gKi8gKGxhYmVsT3JJbWFnZSkuY29udGV4dEluc3RydWN0aW9ucykge1xuICAgIC8vIGxhYmVsXG4gICAgY29udGV4dC50cmFuc2xhdGUoeCwgeSk7XG4gICAgY29udGV4dC5zY2FsZShzY2FsZVswXSwgc2NhbGVbMV0pO1xuICAgIGV4ZWN1dGVMYWJlbEluc3RydWN0aW9ucygvKiogQHR5cGUge0xhYmVsfSAqLyAobGFiZWxPckltYWdlKSwgY29udGV4dCk7XG4gIH0gZWxzZSBpZiAoc2NhbGVbMF0gPCAwIHx8IHNjYWxlWzFdIDwgMCkge1xuICAgIC8vIGZsaXBwZWQgaW1hZ2VcbiAgICBjb250ZXh0LnRyYW5zbGF0ZSh4LCB5KTtcbiAgICBjb250ZXh0LnNjYWxlKHNjYWxlWzBdLCBzY2FsZVsxXSk7XG4gICAgY29udGV4dC5kcmF3SW1hZ2UoXG4gICAgICAvKiogQHR5cGUge0hUTUxDYW52YXNFbGVtZW50fEhUTUxJbWFnZUVsZW1lbnR8SFRNTFZpZGVvRWxlbWVudH0gKi8gKFxuICAgICAgICBsYWJlbE9ySW1hZ2VcbiAgICAgICksXG4gICAgICBvcmlnaW5YLFxuICAgICAgb3JpZ2luWSxcbiAgICAgIHcsXG4gICAgICBoLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICB3LFxuICAgICAgaFxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgLy8gaWYgaW1hZ2Ugbm90IGZsaXBwZWQgdHJhbnNsYXRlIGFuZCBzY2FsZSBjYW4gYmUgYXZvaWRlZFxuICAgIGNvbnRleHQuZHJhd0ltYWdlKFxuICAgICAgLyoqIEB0eXBlIHtIVE1MQ2FudmFzRWxlbWVudHxIVE1MSW1hZ2VFbGVtZW50fEhUTUxWaWRlb0VsZW1lbnR9ICovIChcbiAgICAgICAgbGFiZWxPckltYWdlXG4gICAgICApLFxuICAgICAgb3JpZ2luWCxcbiAgICAgIG9yaWdpblksXG4gICAgICB3LFxuICAgICAgaCxcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgdyAqIHNjYWxlWzBdLFxuICAgICAgaCAqIHNjYWxlWzFdXG4gICAgKTtcbiAgfVxuXG4gIGNvbnRleHQucmVzdG9yZSgpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7TGFiZWx9IGxhYmVsIExhYmVsLlxuICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHQgQ29udGV4dC5cbiAqL1xuZnVuY3Rpb24gZXhlY3V0ZUxhYmVsSW5zdHJ1Y3Rpb25zKGxhYmVsLCBjb250ZXh0KSB7XG4gIGNvbnN0IGNvbnRleHRJbnN0cnVjdGlvbnMgPSBsYWJlbC5jb250ZXh0SW5zdHJ1Y3Rpb25zO1xuICBmb3IgKGxldCBpID0gMCwgaWkgPSBjb250ZXh0SW5zdHJ1Y3Rpb25zLmxlbmd0aDsgaSA8IGlpOyBpICs9IDIpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShjb250ZXh0SW5zdHJ1Y3Rpb25zW2kgKyAxXSkpIHtcbiAgICAgIGNvbnRleHRbY29udGV4dEluc3RydWN0aW9uc1tpXV0uYXBwbHkoXG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIGNvbnRleHRJbnN0cnVjdGlvbnNbaSArIDFdXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb250ZXh0W2NvbnRleHRJbnN0cnVjdGlvbnNbaV1dID0gY29udGV4dEluc3RydWN0aW9uc1tpICsgMV07XG4gICAgfVxuICB9XG59XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvcmVuZGVyL2NhbnZhcy9CdWlsZGVyXG4gKi9cbmltcG9ydCBDYW52YXNJbnN0cnVjdGlvbiBmcm9tICcuL0luc3RydWN0aW9uLmpzJztcbmltcG9ydCBSZWxhdGlvbnNoaXAgZnJvbSAnLi4vLi4vZXh0ZW50L1JlbGF0aW9uc2hpcC5qcyc7XG5pbXBvcnQgVmVjdG9yQ29udGV4dCBmcm9tICcuLi9WZWN0b3JDb250ZXh0LmpzJztcbmltcG9ydCB7YXNDb2xvckxpa2V9IGZyb20gJy4uLy4uL2NvbG9ybGlrZS5qcyc7XG5pbXBvcnQge1xuICBidWZmZXIsXG4gIGNsb25lLFxuICBjb250YWluc0Nvb3JkaW5hdGUsXG4gIGNvb3JkaW5hdGVSZWxhdGlvbnNoaXAsXG59IGZyb20gJy4uLy4uL2V4dGVudC5qcyc7XG5pbXBvcnQge1xuICBkZWZhdWx0RmlsbFN0eWxlLFxuICBkZWZhdWx0TGluZUNhcCxcbiAgZGVmYXVsdExpbmVEYXNoLFxuICBkZWZhdWx0TGluZURhc2hPZmZzZXQsXG4gIGRlZmF1bHRMaW5lSm9pbixcbiAgZGVmYXVsdExpbmVXaWR0aCxcbiAgZGVmYXVsdE1pdGVyTGltaXQsXG4gIGRlZmF1bHRTdHJva2VTdHlsZSxcbn0gZnJvbSAnLi4vY2FudmFzLmpzJztcbmltcG9ydCB7ZXF1YWxzLCByZXZlcnNlU3ViQXJyYXl9IGZyb20gJy4uLy4uL2FycmF5LmpzJztcbmltcG9ydCB7XG4gIGluZmxhdGVDb29yZGluYXRlcyxcbiAgaW5mbGF0ZUNvb3JkaW5hdGVzQXJyYXksXG4gIGluZmxhdGVNdWx0aUNvb3JkaW5hdGVzQXJyYXksXG59IGZyb20gJy4uLy4uL2dlb20vZmxhdC9pbmZsYXRlLmpzJztcblxuY2xhc3MgQ2FudmFzQnVpbGRlciBleHRlbmRzIFZlY3RvckNvbnRleHQge1xuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHRvbGVyYW5jZSBUb2xlcmFuY2UuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gbWF4RXh0ZW50IE1heGltdW0gZXh0ZW50LlxuICAgKiBAcGFyYW0ge251bWJlcn0gcmVzb2x1dGlvbiBSZXNvbHV0aW9uLlxuICAgKiBAcGFyYW0ge251bWJlcn0gcGl4ZWxSYXRpbyBQaXhlbCByYXRpby5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHRvbGVyYW5jZSwgbWF4RXh0ZW50LCByZXNvbHV0aW9uLCBwaXhlbFJhdGlvKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMudG9sZXJhbmNlID0gdG9sZXJhbmNlO1xuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBjb25zdFxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi9leHRlbnQuanNcIikuRXh0ZW50fVxuICAgICAqL1xuICAgIHRoaXMubWF4RXh0ZW50ID0gbWF4RXh0ZW50O1xuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5waXhlbFJhdGlvID0gcGl4ZWxSYXRpbztcblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubWF4TGluZVdpZHRoID0gMDtcblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAY29uc3RcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucmVzb2x1dGlvbiA9IHJlc29sdXRpb247XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtBcnJheTwqPn1cbiAgICAgKi9cbiAgICB0aGlzLmJlZ2luR2VvbWV0cnlJbnN0cnVjdGlvbjFfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0FycmF5PCo+fVxuICAgICAqL1xuICAgIHRoaXMuYmVnaW5HZW9tZXRyeUluc3RydWN0aW9uMl8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vZXh0ZW50LmpzXCIpLkV4dGVudH1cbiAgICAgKi9cbiAgICB0aGlzLmJ1ZmZlcmVkTWF4RXh0ZW50XyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHR5cGUge0FycmF5PCo+fVxuICAgICAqL1xuICAgIHRoaXMuaW5zdHJ1Y3Rpb25zID0gW107XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHR5cGUge0FycmF5PG51bWJlcj59XG4gICAgICovXG4gICAgdGhpcy5jb29yZGluYXRlcyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfVxuICAgICAqL1xuICAgIHRoaXMudG1wQ29vcmRpbmF0ZV8gPSBbXTtcblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAdHlwZSB7QXJyYXk8Kj59XG4gICAgICovXG4gICAgdGhpcy5oaXREZXRlY3Rpb25JbnN0cnVjdGlvbnMgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vY2FudmFzLmpzXCIpLkZpbGxTdHJva2VTdGF0ZX1cbiAgICAgKi9cbiAgICB0aGlzLnN0YXRlID0gLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi9jYW52YXMuanNcIikuRmlsbFN0cm9rZVN0YXRlfSAqLyAoe30pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBkYXNoQXJyYXkgRGFzaCBhcnJheS5cbiAgICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gRGFzaCBhcnJheSB3aXRoIHBpeGVsIHJhdGlvIGFwcGxpZWRcbiAgICovXG4gIGFwcGx5UGl4ZWxSYXRpbyhkYXNoQXJyYXkpIHtcbiAgICBjb25zdCBwaXhlbFJhdGlvID0gdGhpcy5waXhlbFJhdGlvO1xuICAgIHJldHVybiBwaXhlbFJhdGlvID09IDFcbiAgICAgID8gZGFzaEFycmF5XG4gICAgICA6IGRhc2hBcnJheS5tYXAoZnVuY3Rpb24gKGRhc2gpIHtcbiAgICAgICAgICByZXR1cm4gZGFzaCAqIHBpeGVsUmF0aW87XG4gICAgICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEByZXR1cm4ge251bWJlcn0gTXkgZW5kXG4gICAqL1xuICBhcHBlbmRGbGF0UG9pbnRDb29yZGluYXRlcyhmbGF0Q29vcmRpbmF0ZXMsIHN0cmlkZSkge1xuICAgIGNvbnN0IGV4dGVudCA9IHRoaXMuZ2V0QnVmZmVyZWRNYXhFeHRlbnQoKTtcbiAgICBjb25zdCB0bXBDb29yZCA9IHRoaXMudG1wQ29vcmRpbmF0ZV87XG4gICAgY29uc3QgY29vcmRpbmF0ZXMgPSB0aGlzLmNvb3JkaW5hdGVzO1xuICAgIGxldCBteUVuZCA9IGNvb3JkaW5hdGVzLmxlbmd0aDtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBmbGF0Q29vcmRpbmF0ZXMubGVuZ3RoOyBpIDwgaWk7IGkgKz0gc3RyaWRlKSB7XG4gICAgICB0bXBDb29yZFswXSA9IGZsYXRDb29yZGluYXRlc1tpXTtcbiAgICAgIHRtcENvb3JkWzFdID0gZmxhdENvb3JkaW5hdGVzW2kgKyAxXTtcbiAgICAgIGlmIChjb250YWluc0Nvb3JkaW5hdGUoZXh0ZW50LCB0bXBDb29yZCkpIHtcbiAgICAgICAgY29vcmRpbmF0ZXNbbXlFbmQrK10gPSB0bXBDb29yZFswXTtcbiAgICAgICAgY29vcmRpbmF0ZXNbbXlFbmQrK10gPSB0bXBDb29yZFsxXTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG15RW5kO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICAgKiBAcGFyYW0ge251bWJlcn0gZW5kIEVuZC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gY2xvc2VkIExhc3QgaW5wdXQgY29vcmRpbmF0ZSBlcXVhbHMgZmlyc3QuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2tpcEZpcnN0IFNraXAgZmlyc3QgY29vcmRpbmF0ZS5cbiAgICogQHByb3RlY3RlZFxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IE15IGVuZC5cbiAgICovXG4gIGFwcGVuZEZsYXRMaW5lQ29vcmRpbmF0ZXMoXG4gICAgZmxhdENvb3JkaW5hdGVzLFxuICAgIG9mZnNldCxcbiAgICBlbmQsXG4gICAgc3RyaWRlLFxuICAgIGNsb3NlZCxcbiAgICBza2lwRmlyc3RcbiAgKSB7XG4gICAgY29uc3QgY29vcmRpbmF0ZXMgPSB0aGlzLmNvb3JkaW5hdGVzO1xuICAgIGxldCBteUVuZCA9IGNvb3JkaW5hdGVzLmxlbmd0aDtcbiAgICBjb25zdCBleHRlbnQgPSB0aGlzLmdldEJ1ZmZlcmVkTWF4RXh0ZW50KCk7XG4gICAgaWYgKHNraXBGaXJzdCkge1xuICAgICAgb2Zmc2V0ICs9IHN0cmlkZTtcbiAgICB9XG4gICAgbGV0IGxhc3RYQ29vcmQgPSBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0XTtcbiAgICBsZXQgbGFzdFlDb29yZCA9IGZsYXRDb29yZGluYXRlc1tvZmZzZXQgKyAxXTtcbiAgICBjb25zdCBuZXh0Q29vcmQgPSB0aGlzLnRtcENvb3JkaW5hdGVfO1xuICAgIGxldCBza2lwcGVkID0gdHJ1ZTtcblxuICAgIGxldCBpLCBsYXN0UmVsLCBuZXh0UmVsO1xuICAgIGZvciAoaSA9IG9mZnNldCArIHN0cmlkZTsgaSA8IGVuZDsgaSArPSBzdHJpZGUpIHtcbiAgICAgIG5leHRDb29yZFswXSA9IGZsYXRDb29yZGluYXRlc1tpXTtcbiAgICAgIG5leHRDb29yZFsxXSA9IGZsYXRDb29yZGluYXRlc1tpICsgMV07XG4gICAgICBuZXh0UmVsID0gY29vcmRpbmF0ZVJlbGF0aW9uc2hpcChleHRlbnQsIG5leHRDb29yZCk7XG4gICAgICBpZiAobmV4dFJlbCAhPT0gbGFzdFJlbCkge1xuICAgICAgICBpZiAoc2tpcHBlZCkge1xuICAgICAgICAgIGNvb3JkaW5hdGVzW215RW5kKytdID0gbGFzdFhDb29yZDtcbiAgICAgICAgICBjb29yZGluYXRlc1tteUVuZCsrXSA9IGxhc3RZQ29vcmQ7XG4gICAgICAgICAgc2tpcHBlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvb3JkaW5hdGVzW215RW5kKytdID0gbmV4dENvb3JkWzBdO1xuICAgICAgICBjb29yZGluYXRlc1tteUVuZCsrXSA9IG5leHRDb29yZFsxXTtcbiAgICAgIH0gZWxzZSBpZiAobmV4dFJlbCA9PT0gUmVsYXRpb25zaGlwLklOVEVSU0VDVElORykge1xuICAgICAgICBjb29yZGluYXRlc1tteUVuZCsrXSA9IG5leHRDb29yZFswXTtcbiAgICAgICAgY29vcmRpbmF0ZXNbbXlFbmQrK10gPSBuZXh0Q29vcmRbMV07XG4gICAgICAgIHNraXBwZWQgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNraXBwZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgbGFzdFhDb29yZCA9IG5leHRDb29yZFswXTtcbiAgICAgIGxhc3RZQ29vcmQgPSBuZXh0Q29vcmRbMV07XG4gICAgICBsYXN0UmVsID0gbmV4dFJlbDtcbiAgICB9XG5cbiAgICAvLyBMYXN0IGNvb3JkaW5hdGUgZXF1YWxzIGZpcnN0IG9yIG9ubHkgb25lIHBvaW50IHRvIGFwcGVuZDpcbiAgICBpZiAoKGNsb3NlZCAmJiBza2lwcGVkKSB8fCBpID09PSBvZmZzZXQgKyBzdHJpZGUpIHtcbiAgICAgIGNvb3JkaW5hdGVzW215RW5kKytdID0gbGFzdFhDb29yZDtcbiAgICAgIGNvb3JkaW5hdGVzW215RW5kKytdID0gbGFzdFlDb29yZDtcbiAgICB9XG4gICAgcmV0dXJuIG15RW5kO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICAgKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGVuZHMgRW5kcy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gICAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gYnVpbGRlckVuZHMgQnVpbGRlciBlbmRzLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IE9mZnNldC5cbiAgICovXG4gIGRyYXdDdXN0b21Db29yZGluYXRlc18oZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZHMsIHN0cmlkZSwgYnVpbGRlckVuZHMpIHtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBlbmRzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgIGNvbnN0IGVuZCA9IGVuZHNbaV07XG4gICAgICBjb25zdCBidWlsZGVyRW5kID0gdGhpcy5hcHBlbmRGbGF0TGluZUNvb3JkaW5hdGVzKFxuICAgICAgICBmbGF0Q29vcmRpbmF0ZXMsXG4gICAgICAgIG9mZnNldCxcbiAgICAgICAgZW5kLFxuICAgICAgICBzdHJpZGUsXG4gICAgICAgIGZhbHNlLFxuICAgICAgICBmYWxzZVxuICAgICAgKTtcbiAgICAgIGJ1aWxkZXJFbmRzLnB1c2goYnVpbGRlckVuZCk7XG4gICAgICBvZmZzZXQgPSBlbmQ7XG4gICAgfVxuICAgIHJldHVybiBvZmZzZXQ7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9nZW9tL1NpbXBsZUdlb21ldHJ5LmpzXCIpLmRlZmF1bHR9IGdlb21ldHJ5IEdlb21ldHJ5LlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL0ZlYXR1cmUuanNcIikuRmVhdHVyZUxpa2V9IGZlYXR1cmUgRmVhdHVyZS5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gcmVuZGVyZXIgUmVuZGVyZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGhpdERldGVjdGlvblJlbmRlcmVyIFJlbmRlcmVyLlxuICAgKi9cbiAgZHJhd0N1c3RvbShnZW9tZXRyeSwgZmVhdHVyZSwgcmVuZGVyZXIsIGhpdERldGVjdGlvblJlbmRlcmVyKSB7XG4gICAgdGhpcy5iZWdpbkdlb21ldHJ5KGdlb21ldHJ5LCBmZWF0dXJlKTtcblxuICAgIGNvbnN0IHR5cGUgPSBnZW9tZXRyeS5nZXRUeXBlKCk7XG4gICAgY29uc3Qgc3RyaWRlID0gZ2VvbWV0cnkuZ2V0U3RyaWRlKCk7XG4gICAgY29uc3QgYnVpbGRlckJlZ2luID0gdGhpcy5jb29yZGluYXRlcy5sZW5ndGg7XG5cbiAgICBsZXQgZmxhdENvb3JkaW5hdGVzLCBidWlsZGVyRW5kLCBidWlsZGVyRW5kcywgYnVpbGRlckVuZHNzO1xuICAgIGxldCBvZmZzZXQ7XG5cbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgJ011bHRpUG9seWdvbic6XG4gICAgICAgIGZsYXRDb29yZGluYXRlcyA9XG4gICAgICAgICAgLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi9nZW9tL011bHRpUG9seWdvbi5qc1wiKS5kZWZhdWx0fSAqLyAoXG4gICAgICAgICAgICBnZW9tZXRyeVxuICAgICAgICAgICkuZ2V0T3JpZW50ZWRGbGF0Q29vcmRpbmF0ZXMoKTtcbiAgICAgICAgYnVpbGRlckVuZHNzID0gW107XG4gICAgICAgIGNvbnN0IGVuZHNzID1cbiAgICAgICAgICAvKiogQHR5cGUge2ltcG9ydChcIi4uLy4uL2dlb20vTXVsdGlQb2x5Z29uLmpzXCIpLmRlZmF1bHR9ICovIChcbiAgICAgICAgICAgIGdlb21ldHJ5XG4gICAgICAgICAgKS5nZXRFbmRzcygpO1xuICAgICAgICBvZmZzZXQgPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBlbmRzcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgICAgY29uc3QgbXlFbmRzID0gW107XG4gICAgICAgICAgb2Zmc2V0ID0gdGhpcy5kcmF3Q3VzdG9tQ29vcmRpbmF0ZXNfKFxuICAgICAgICAgICAgZmxhdENvb3JkaW5hdGVzLFxuICAgICAgICAgICAgb2Zmc2V0LFxuICAgICAgICAgICAgZW5kc3NbaV0sXG4gICAgICAgICAgICBzdHJpZGUsXG4gICAgICAgICAgICBteUVuZHNcbiAgICAgICAgICApO1xuICAgICAgICAgIGJ1aWxkZXJFbmRzcy5wdXNoKG15RW5kcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbnN0cnVjdGlvbnMucHVzaChbXG4gICAgICAgICAgQ2FudmFzSW5zdHJ1Y3Rpb24uQ1VTVE9NLFxuICAgICAgICAgIGJ1aWxkZXJCZWdpbixcbiAgICAgICAgICBidWlsZGVyRW5kc3MsXG4gICAgICAgICAgZ2VvbWV0cnksXG4gICAgICAgICAgcmVuZGVyZXIsXG4gICAgICAgICAgaW5mbGF0ZU11bHRpQ29vcmRpbmF0ZXNBcnJheSxcbiAgICAgICAgXSk7XG4gICAgICAgIHRoaXMuaGl0RGV0ZWN0aW9uSW5zdHJ1Y3Rpb25zLnB1c2goW1xuICAgICAgICAgIENhbnZhc0luc3RydWN0aW9uLkNVU1RPTSxcbiAgICAgICAgICBidWlsZGVyQmVnaW4sXG4gICAgICAgICAgYnVpbGRlckVuZHNzLFxuICAgICAgICAgIGdlb21ldHJ5LFxuICAgICAgICAgIGhpdERldGVjdGlvblJlbmRlcmVyIHx8IHJlbmRlcmVyLFxuICAgICAgICAgIGluZmxhdGVNdWx0aUNvb3JkaW5hdGVzQXJyYXksXG4gICAgICAgIF0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ1BvbHlnb24nOlxuICAgICAgY2FzZSAnTXVsdGlMaW5lU3RyaW5nJzpcbiAgICAgICAgYnVpbGRlckVuZHMgPSBbXTtcbiAgICAgICAgZmxhdENvb3JkaW5hdGVzID1cbiAgICAgICAgICB0eXBlID09ICdQb2x5Z29uJ1xuICAgICAgICAgICAgPyAvKiogQHR5cGUge2ltcG9ydChcIi4uLy4uL2dlb20vUG9seWdvbi5qc1wiKS5kZWZhdWx0fSAqLyAoXG4gICAgICAgICAgICAgICAgZ2VvbWV0cnlcbiAgICAgICAgICAgICAgKS5nZXRPcmllbnRlZEZsYXRDb29yZGluYXRlcygpXG4gICAgICAgICAgICA6IGdlb21ldHJ5LmdldEZsYXRDb29yZGluYXRlcygpO1xuICAgICAgICBvZmZzZXQgPSB0aGlzLmRyYXdDdXN0b21Db29yZGluYXRlc18oXG4gICAgICAgICAgZmxhdENvb3JkaW5hdGVzLFxuICAgICAgICAgIDAsXG4gICAgICAgICAgLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi9nZW9tL1BvbHlnb24uanNcIikuZGVmYXVsdHxpbXBvcnQoXCIuLi8uLi9nZW9tL011bHRpTGluZVN0cmluZy5qc1wiKS5kZWZhdWx0fSAqLyAoXG4gICAgICAgICAgICBnZW9tZXRyeVxuICAgICAgICAgICkuZ2V0RW5kcygpLFxuICAgICAgICAgIHN0cmlkZSxcbiAgICAgICAgICBidWlsZGVyRW5kc1xuICAgICAgICApO1xuICAgICAgICB0aGlzLmluc3RydWN0aW9ucy5wdXNoKFtcbiAgICAgICAgICBDYW52YXNJbnN0cnVjdGlvbi5DVVNUT00sXG4gICAgICAgICAgYnVpbGRlckJlZ2luLFxuICAgICAgICAgIGJ1aWxkZXJFbmRzLFxuICAgICAgICAgIGdlb21ldHJ5LFxuICAgICAgICAgIHJlbmRlcmVyLFxuICAgICAgICAgIGluZmxhdGVDb29yZGluYXRlc0FycmF5LFxuICAgICAgICBdKTtcbiAgICAgICAgdGhpcy5oaXREZXRlY3Rpb25JbnN0cnVjdGlvbnMucHVzaChbXG4gICAgICAgICAgQ2FudmFzSW5zdHJ1Y3Rpb24uQ1VTVE9NLFxuICAgICAgICAgIGJ1aWxkZXJCZWdpbixcbiAgICAgICAgICBidWlsZGVyRW5kcyxcbiAgICAgICAgICBnZW9tZXRyeSxcbiAgICAgICAgICBoaXREZXRlY3Rpb25SZW5kZXJlciB8fCByZW5kZXJlcixcbiAgICAgICAgICBpbmZsYXRlQ29vcmRpbmF0ZXNBcnJheSxcbiAgICAgICAgXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnTGluZVN0cmluZyc6XG4gICAgICBjYXNlICdDaXJjbGUnOlxuICAgICAgICBmbGF0Q29vcmRpbmF0ZXMgPSBnZW9tZXRyeS5nZXRGbGF0Q29vcmRpbmF0ZXMoKTtcbiAgICAgICAgYnVpbGRlckVuZCA9IHRoaXMuYXBwZW5kRmxhdExpbmVDb29yZGluYXRlcyhcbiAgICAgICAgICBmbGF0Q29vcmRpbmF0ZXMsXG4gICAgICAgICAgMCxcbiAgICAgICAgICBmbGF0Q29vcmRpbmF0ZXMubGVuZ3RoLFxuICAgICAgICAgIHN0cmlkZSxcbiAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICBmYWxzZVxuICAgICAgICApO1xuICAgICAgICB0aGlzLmluc3RydWN0aW9ucy5wdXNoKFtcbiAgICAgICAgICBDYW52YXNJbnN0cnVjdGlvbi5DVVNUT00sXG4gICAgICAgICAgYnVpbGRlckJlZ2luLFxuICAgICAgICAgIGJ1aWxkZXJFbmQsXG4gICAgICAgICAgZ2VvbWV0cnksXG4gICAgICAgICAgcmVuZGVyZXIsXG4gICAgICAgICAgaW5mbGF0ZUNvb3JkaW5hdGVzLFxuICAgICAgICBdKTtcbiAgICAgICAgdGhpcy5oaXREZXRlY3Rpb25JbnN0cnVjdGlvbnMucHVzaChbXG4gICAgICAgICAgQ2FudmFzSW5zdHJ1Y3Rpb24uQ1VTVE9NLFxuICAgICAgICAgIGJ1aWxkZXJCZWdpbixcbiAgICAgICAgICBidWlsZGVyRW5kLFxuICAgICAgICAgIGdlb21ldHJ5LFxuICAgICAgICAgIGhpdERldGVjdGlvblJlbmRlcmVyIHx8IHJlbmRlcmVyLFxuICAgICAgICAgIGluZmxhdGVDb29yZGluYXRlcyxcbiAgICAgICAgXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnTXVsdGlQb2ludCc6XG4gICAgICAgIGZsYXRDb29yZGluYXRlcyA9IGdlb21ldHJ5LmdldEZsYXRDb29yZGluYXRlcygpO1xuICAgICAgICBidWlsZGVyRW5kID0gdGhpcy5hcHBlbmRGbGF0UG9pbnRDb29yZGluYXRlcyhmbGF0Q29vcmRpbmF0ZXMsIHN0cmlkZSk7XG5cbiAgICAgICAgaWYgKGJ1aWxkZXJFbmQgPiBidWlsZGVyQmVnaW4pIHtcbiAgICAgICAgICB0aGlzLmluc3RydWN0aW9ucy5wdXNoKFtcbiAgICAgICAgICAgIENhbnZhc0luc3RydWN0aW9uLkNVU1RPTSxcbiAgICAgICAgICAgIGJ1aWxkZXJCZWdpbixcbiAgICAgICAgICAgIGJ1aWxkZXJFbmQsXG4gICAgICAgICAgICBnZW9tZXRyeSxcbiAgICAgICAgICAgIHJlbmRlcmVyLFxuICAgICAgICAgICAgaW5mbGF0ZUNvb3JkaW5hdGVzLFxuICAgICAgICAgIF0pO1xuICAgICAgICAgIHRoaXMuaGl0RGV0ZWN0aW9uSW5zdHJ1Y3Rpb25zLnB1c2goW1xuICAgICAgICAgICAgQ2FudmFzSW5zdHJ1Y3Rpb24uQ1VTVE9NLFxuICAgICAgICAgICAgYnVpbGRlckJlZ2luLFxuICAgICAgICAgICAgYnVpbGRlckVuZCxcbiAgICAgICAgICAgIGdlb21ldHJ5LFxuICAgICAgICAgICAgaGl0RGV0ZWN0aW9uUmVuZGVyZXIgfHwgcmVuZGVyZXIsXG4gICAgICAgICAgICBpbmZsYXRlQ29vcmRpbmF0ZXMsXG4gICAgICAgICAgXSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdQb2ludCc6XG4gICAgICAgIGZsYXRDb29yZGluYXRlcyA9IGdlb21ldHJ5LmdldEZsYXRDb29yZGluYXRlcygpO1xuICAgICAgICB0aGlzLmNvb3JkaW5hdGVzLnB1c2goZmxhdENvb3JkaW5hdGVzWzBdLCBmbGF0Q29vcmRpbmF0ZXNbMV0pO1xuICAgICAgICBidWlsZGVyRW5kID0gdGhpcy5jb29yZGluYXRlcy5sZW5ndGg7XG5cbiAgICAgICAgdGhpcy5pbnN0cnVjdGlvbnMucHVzaChbXG4gICAgICAgICAgQ2FudmFzSW5zdHJ1Y3Rpb24uQ1VTVE9NLFxuICAgICAgICAgIGJ1aWxkZXJCZWdpbixcbiAgICAgICAgICBidWlsZGVyRW5kLFxuICAgICAgICAgIGdlb21ldHJ5LFxuICAgICAgICAgIHJlbmRlcmVyLFxuICAgICAgICBdKTtcbiAgICAgICAgdGhpcy5oaXREZXRlY3Rpb25JbnN0cnVjdGlvbnMucHVzaChbXG4gICAgICAgICAgQ2FudmFzSW5zdHJ1Y3Rpb24uQ1VTVE9NLFxuICAgICAgICAgIGJ1aWxkZXJCZWdpbixcbiAgICAgICAgICBidWlsZGVyRW5kLFxuICAgICAgICAgIGdlb21ldHJ5LFxuICAgICAgICAgIGhpdERldGVjdGlvblJlbmRlcmVyIHx8IHJlbmRlcmVyLFxuICAgICAgICBdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgIH1cbiAgICB0aGlzLmVuZEdlb21ldHJ5KGZlYXR1cmUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9nZW9tL0dlb21ldHJ5XCIpLmRlZmF1bHR8aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0fSBnZW9tZXRyeSBUaGUgZ2VvbWV0cnkuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vRmVhdHVyZS5qc1wiKS5GZWF0dXJlTGlrZX0gZmVhdHVyZSBGZWF0dXJlLlxuICAgKi9cbiAgYmVnaW5HZW9tZXRyeShnZW9tZXRyeSwgZmVhdHVyZSkge1xuICAgIHRoaXMuYmVnaW5HZW9tZXRyeUluc3RydWN0aW9uMV8gPSBbXG4gICAgICBDYW52YXNJbnN0cnVjdGlvbi5CRUdJTl9HRU9NRVRSWSxcbiAgICAgIGZlYXR1cmUsXG4gICAgICAwLFxuICAgICAgZ2VvbWV0cnksXG4gICAgXTtcbiAgICB0aGlzLmluc3RydWN0aW9ucy5wdXNoKHRoaXMuYmVnaW5HZW9tZXRyeUluc3RydWN0aW9uMV8pO1xuICAgIHRoaXMuYmVnaW5HZW9tZXRyeUluc3RydWN0aW9uMl8gPSBbXG4gICAgICBDYW52YXNJbnN0cnVjdGlvbi5CRUdJTl9HRU9NRVRSWSxcbiAgICAgIGZlYXR1cmUsXG4gICAgICAwLFxuICAgICAgZ2VvbWV0cnksXG4gICAgXTtcbiAgICB0aGlzLmhpdERldGVjdGlvbkluc3RydWN0aW9ucy5wdXNoKHRoaXMuYmVnaW5HZW9tZXRyeUluc3RydWN0aW9uMl8pO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL2NhbnZhcy5qc1wiKS5TZXJpYWxpemFibGVJbnN0cnVjdGlvbnN9IHRoZSBzZXJpYWxpemFibGUgaW5zdHJ1Y3Rpb25zLlxuICAgKi9cbiAgZmluaXNoKCkge1xuICAgIHJldHVybiB7XG4gICAgICBpbnN0cnVjdGlvbnM6IHRoaXMuaW5zdHJ1Y3Rpb25zLFxuICAgICAgaGl0RGV0ZWN0aW9uSW5zdHJ1Y3Rpb25zOiB0aGlzLmhpdERldGVjdGlvbkluc3RydWN0aW9ucyxcbiAgICAgIGNvb3JkaW5hdGVzOiB0aGlzLmNvb3JkaW5hdGVzLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogUmV2ZXJzZSB0aGUgaGl0IGRldGVjdGlvbiBpbnN0cnVjdGlvbnMuXG4gICAqL1xuICByZXZlcnNlSGl0RGV0ZWN0aW9uSW5zdHJ1Y3Rpb25zKCkge1xuICAgIGNvbnN0IGhpdERldGVjdGlvbkluc3RydWN0aW9ucyA9IHRoaXMuaGl0RGV0ZWN0aW9uSW5zdHJ1Y3Rpb25zO1xuICAgIC8vIHN0ZXAgMSAtIHJldmVyc2UgYXJyYXlcbiAgICBoaXREZXRlY3Rpb25JbnN0cnVjdGlvbnMucmV2ZXJzZSgpO1xuICAgIC8vIHN0ZXAgMiAtIHJldmVyc2UgaW5zdHJ1Y3Rpb25zIHdpdGhpbiBnZW9tZXRyeSBibG9ja3NcbiAgICBsZXQgaTtcbiAgICBjb25zdCBuID0gaGl0RGV0ZWN0aW9uSW5zdHJ1Y3Rpb25zLmxlbmd0aDtcbiAgICBsZXQgaW5zdHJ1Y3Rpb247XG4gICAgbGV0IHR5cGU7XG4gICAgbGV0IGJlZ2luID0gLTE7XG4gICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgaW5zdHJ1Y3Rpb24gPSBoaXREZXRlY3Rpb25JbnN0cnVjdGlvbnNbaV07XG4gICAgICB0eXBlID0gLyoqIEB0eXBlIHtpbXBvcnQoXCIuL0luc3RydWN0aW9uLmpzXCIpLmRlZmF1bHR9ICovIChpbnN0cnVjdGlvblswXSk7XG4gICAgICBpZiAodHlwZSA9PSBDYW52YXNJbnN0cnVjdGlvbi5FTkRfR0VPTUVUUlkpIHtcbiAgICAgICAgYmVnaW4gPSBpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09IENhbnZhc0luc3RydWN0aW9uLkJFR0lOX0dFT01FVFJZKSB7XG4gICAgICAgIGluc3RydWN0aW9uWzJdID0gaTtcbiAgICAgICAgcmV2ZXJzZVN1YkFycmF5KHRoaXMuaGl0RGV0ZWN0aW9uSW5zdHJ1Y3Rpb25zLCBiZWdpbiwgaSk7XG4gICAgICAgIGJlZ2luID0gLTE7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vc3R5bGUvRmlsbC5qc1wiKS5kZWZhdWx0fSBmaWxsU3R5bGUgRmlsbCBzdHlsZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9zdHlsZS9TdHJva2UuanNcIikuZGVmYXVsdH0gc3Ryb2tlU3R5bGUgU3Ryb2tlIHN0eWxlLlxuICAgKi9cbiAgc2V0RmlsbFN0cm9rZVN0eWxlKGZpbGxTdHlsZSwgc3Ryb2tlU3R5bGUpIHtcbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgaWYgKGZpbGxTdHlsZSkge1xuICAgICAgY29uc3QgZmlsbFN0eWxlQ29sb3IgPSBmaWxsU3R5bGUuZ2V0Q29sb3IoKTtcbiAgICAgIHN0YXRlLmZpbGxTdHlsZSA9IGFzQ29sb3JMaWtlKFxuICAgICAgICBmaWxsU3R5bGVDb2xvciA/IGZpbGxTdHlsZUNvbG9yIDogZGVmYXVsdEZpbGxTdHlsZVxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUuZmlsbFN0eWxlID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAoc3Ryb2tlU3R5bGUpIHtcbiAgICAgIGNvbnN0IHN0cm9rZVN0eWxlQ29sb3IgPSBzdHJva2VTdHlsZS5nZXRDb2xvcigpO1xuICAgICAgc3RhdGUuc3Ryb2tlU3R5bGUgPSBhc0NvbG9yTGlrZShcbiAgICAgICAgc3Ryb2tlU3R5bGVDb2xvciA/IHN0cm9rZVN0eWxlQ29sb3IgOiBkZWZhdWx0U3Ryb2tlU3R5bGVcbiAgICAgICk7XG4gICAgICBjb25zdCBzdHJva2VTdHlsZUxpbmVDYXAgPSBzdHJva2VTdHlsZS5nZXRMaW5lQ2FwKCk7XG4gICAgICBzdGF0ZS5saW5lQ2FwID1cbiAgICAgICAgc3Ryb2tlU3R5bGVMaW5lQ2FwICE9PSB1bmRlZmluZWQgPyBzdHJva2VTdHlsZUxpbmVDYXAgOiBkZWZhdWx0TGluZUNhcDtcbiAgICAgIGNvbnN0IHN0cm9rZVN0eWxlTGluZURhc2ggPSBzdHJva2VTdHlsZS5nZXRMaW5lRGFzaCgpO1xuICAgICAgc3RhdGUubGluZURhc2ggPSBzdHJva2VTdHlsZUxpbmVEYXNoXG4gICAgICAgID8gc3Ryb2tlU3R5bGVMaW5lRGFzaC5zbGljZSgpXG4gICAgICAgIDogZGVmYXVsdExpbmVEYXNoO1xuICAgICAgY29uc3Qgc3Ryb2tlU3R5bGVMaW5lRGFzaE9mZnNldCA9IHN0cm9rZVN0eWxlLmdldExpbmVEYXNoT2Zmc2V0KCk7XG4gICAgICBzdGF0ZS5saW5lRGFzaE9mZnNldCA9IHN0cm9rZVN0eWxlTGluZURhc2hPZmZzZXRcbiAgICAgICAgPyBzdHJva2VTdHlsZUxpbmVEYXNoT2Zmc2V0XG4gICAgICAgIDogZGVmYXVsdExpbmVEYXNoT2Zmc2V0O1xuICAgICAgY29uc3Qgc3Ryb2tlU3R5bGVMaW5lSm9pbiA9IHN0cm9rZVN0eWxlLmdldExpbmVKb2luKCk7XG4gICAgICBzdGF0ZS5saW5lSm9pbiA9XG4gICAgICAgIHN0cm9rZVN0eWxlTGluZUpvaW4gIT09IHVuZGVmaW5lZFxuICAgICAgICAgID8gc3Ryb2tlU3R5bGVMaW5lSm9pblxuICAgICAgICAgIDogZGVmYXVsdExpbmVKb2luO1xuICAgICAgY29uc3Qgc3Ryb2tlU3R5bGVXaWR0aCA9IHN0cm9rZVN0eWxlLmdldFdpZHRoKCk7XG4gICAgICBzdGF0ZS5saW5lV2lkdGggPVxuICAgICAgICBzdHJva2VTdHlsZVdpZHRoICE9PSB1bmRlZmluZWQgPyBzdHJva2VTdHlsZVdpZHRoIDogZGVmYXVsdExpbmVXaWR0aDtcbiAgICAgIGNvbnN0IHN0cm9rZVN0eWxlTWl0ZXJMaW1pdCA9IHN0cm9rZVN0eWxlLmdldE1pdGVyTGltaXQoKTtcbiAgICAgIHN0YXRlLm1pdGVyTGltaXQgPVxuICAgICAgICBzdHJva2VTdHlsZU1pdGVyTGltaXQgIT09IHVuZGVmaW5lZFxuICAgICAgICAgID8gc3Ryb2tlU3R5bGVNaXRlckxpbWl0XG4gICAgICAgICAgOiBkZWZhdWx0TWl0ZXJMaW1pdDtcblxuICAgICAgaWYgKHN0YXRlLmxpbmVXaWR0aCA+IHRoaXMubWF4TGluZVdpZHRoKSB7XG4gICAgICAgIHRoaXMubWF4TGluZVdpZHRoID0gc3RhdGUubGluZVdpZHRoO1xuICAgICAgICAvLyBpbnZhbGlkYXRlIHRoZSBidWZmZXJlZCBtYXggZXh0ZW50IGNhY2hlXG4gICAgICAgIHRoaXMuYnVmZmVyZWRNYXhFeHRlbnRfID0gbnVsbDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUuc3Ryb2tlU3R5bGUgPSB1bmRlZmluZWQ7XG4gICAgICBzdGF0ZS5saW5lQ2FwID0gdW5kZWZpbmVkO1xuICAgICAgc3RhdGUubGluZURhc2ggPSBudWxsO1xuICAgICAgc3RhdGUubGluZURhc2hPZmZzZXQgPSB1bmRlZmluZWQ7XG4gICAgICBzdGF0ZS5saW5lSm9pbiA9IHVuZGVmaW5lZDtcbiAgICAgIHN0YXRlLmxpbmVXaWR0aCA9IHVuZGVmaW5lZDtcbiAgICAgIHN0YXRlLm1pdGVyTGltaXQgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY2FudmFzLmpzXCIpLkZpbGxTdHJva2VTdGF0ZX0gc3RhdGUgU3RhdGUuXG4gICAqIEByZXR1cm4ge0FycmF5PCo+fSBGaWxsIGluc3RydWN0aW9uLlxuICAgKi9cbiAgY3JlYXRlRmlsbChzdGF0ZSkge1xuICAgIGNvbnN0IGZpbGxTdHlsZSA9IHN0YXRlLmZpbGxTdHlsZTtcbiAgICAvKiogQHR5cGUge0FycmF5PCo+fSAqL1xuICAgIGNvbnN0IGZpbGxJbnN0cnVjdGlvbiA9IFtDYW52YXNJbnN0cnVjdGlvbi5TRVRfRklMTF9TVFlMRSwgZmlsbFN0eWxlXTtcbiAgICBpZiAodHlwZW9mIGZpbGxTdHlsZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIEZpbGwgaXMgYSBwYXR0ZXJuIG9yIGdyYWRpZW50IC0gYWxpZ24gaXQhXG4gICAgICBmaWxsSW5zdHJ1Y3Rpb24ucHVzaCh0cnVlKTtcbiAgICB9XG4gICAgcmV0dXJuIGZpbGxJbnN0cnVjdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2NhbnZhcy5qc1wiKS5GaWxsU3Ryb2tlU3RhdGV9IHN0YXRlIFN0YXRlLlxuICAgKi9cbiAgYXBwbHlTdHJva2Uoc3RhdGUpIHtcbiAgICB0aGlzLmluc3RydWN0aW9ucy5wdXNoKHRoaXMuY3JlYXRlU3Ryb2tlKHN0YXRlKSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jYW52YXMuanNcIikuRmlsbFN0cm9rZVN0YXRlfSBzdGF0ZSBTdGF0ZS5cbiAgICogQHJldHVybiB7QXJyYXk8Kj59IFN0cm9rZSBpbnN0cnVjdGlvbi5cbiAgICovXG4gIGNyZWF0ZVN0cm9rZShzdGF0ZSkge1xuICAgIHJldHVybiBbXG4gICAgICBDYW52YXNJbnN0cnVjdGlvbi5TRVRfU1RST0tFX1NUWUxFLFxuICAgICAgc3RhdGUuc3Ryb2tlU3R5bGUsXG4gICAgICBzdGF0ZS5saW5lV2lkdGggKiB0aGlzLnBpeGVsUmF0aW8sXG4gICAgICBzdGF0ZS5saW5lQ2FwLFxuICAgICAgc3RhdGUubGluZUpvaW4sXG4gICAgICBzdGF0ZS5taXRlckxpbWl0LFxuICAgICAgdGhpcy5hcHBseVBpeGVsUmF0aW8oc3RhdGUubGluZURhc2gpLFxuICAgICAgc3RhdGUubGluZURhc2hPZmZzZXQgKiB0aGlzLnBpeGVsUmF0aW8sXG4gICAgXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2NhbnZhcy5qc1wiKS5GaWxsU3Ryb2tlU3RhdGV9IHN0YXRlIFN0YXRlLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKHRoaXM6Q2FudmFzQnVpbGRlciwgaW1wb3J0KFwiLi4vY2FudmFzLmpzXCIpLkZpbGxTdHJva2VTdGF0ZSk6QXJyYXk8Kj59IGNyZWF0ZUZpbGwgQ3JlYXRlIGZpbGwuXG4gICAqL1xuICB1cGRhdGVGaWxsU3R5bGUoc3RhdGUsIGNyZWF0ZUZpbGwpIHtcbiAgICBjb25zdCBmaWxsU3R5bGUgPSBzdGF0ZS5maWxsU3R5bGU7XG4gICAgaWYgKHR5cGVvZiBmaWxsU3R5bGUgIT09ICdzdHJpbmcnIHx8IHN0YXRlLmN1cnJlbnRGaWxsU3R5bGUgIT0gZmlsbFN0eWxlKSB7XG4gICAgICBpZiAoZmlsbFN0eWxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5pbnN0cnVjdGlvbnMucHVzaChjcmVhdGVGaWxsLmNhbGwodGhpcywgc3RhdGUpKTtcbiAgICAgIH1cbiAgICAgIHN0YXRlLmN1cnJlbnRGaWxsU3R5bGUgPSBmaWxsU3R5bGU7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY2FudmFzLmpzXCIpLkZpbGxTdHJva2VTdGF0ZX0gc3RhdGUgU3RhdGUuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24odGhpczpDYW52YXNCdWlsZGVyLCBpbXBvcnQoXCIuLi9jYW52YXMuanNcIikuRmlsbFN0cm9rZVN0YXRlKTogdm9pZH0gYXBwbHlTdHJva2UgQXBwbHkgc3Ryb2tlLlxuICAgKi9cbiAgdXBkYXRlU3Ryb2tlU3R5bGUoc3RhdGUsIGFwcGx5U3Ryb2tlKSB7XG4gICAgY29uc3Qgc3Ryb2tlU3R5bGUgPSBzdGF0ZS5zdHJva2VTdHlsZTtcbiAgICBjb25zdCBsaW5lQ2FwID0gc3RhdGUubGluZUNhcDtcbiAgICBjb25zdCBsaW5lRGFzaCA9IHN0YXRlLmxpbmVEYXNoO1xuICAgIGNvbnN0IGxpbmVEYXNoT2Zmc2V0ID0gc3RhdGUubGluZURhc2hPZmZzZXQ7XG4gICAgY29uc3QgbGluZUpvaW4gPSBzdGF0ZS5saW5lSm9pbjtcbiAgICBjb25zdCBsaW5lV2lkdGggPSBzdGF0ZS5saW5lV2lkdGg7XG4gICAgY29uc3QgbWl0ZXJMaW1pdCA9IHN0YXRlLm1pdGVyTGltaXQ7XG4gICAgaWYgKFxuICAgICAgc3RhdGUuY3VycmVudFN0cm9rZVN0eWxlICE9IHN0cm9rZVN0eWxlIHx8XG4gICAgICBzdGF0ZS5jdXJyZW50TGluZUNhcCAhPSBsaW5lQ2FwIHx8XG4gICAgICAobGluZURhc2ggIT0gc3RhdGUuY3VycmVudExpbmVEYXNoICYmXG4gICAgICAgICFlcXVhbHMoc3RhdGUuY3VycmVudExpbmVEYXNoLCBsaW5lRGFzaCkpIHx8XG4gICAgICBzdGF0ZS5jdXJyZW50TGluZURhc2hPZmZzZXQgIT0gbGluZURhc2hPZmZzZXQgfHxcbiAgICAgIHN0YXRlLmN1cnJlbnRMaW5lSm9pbiAhPSBsaW5lSm9pbiB8fFxuICAgICAgc3RhdGUuY3VycmVudExpbmVXaWR0aCAhPSBsaW5lV2lkdGggfHxcbiAgICAgIHN0YXRlLmN1cnJlbnRNaXRlckxpbWl0ICE9IG1pdGVyTGltaXRcbiAgICApIHtcbiAgICAgIGlmIChzdHJva2VTdHlsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGFwcGx5U3Ryb2tlLmNhbGwodGhpcywgc3RhdGUpO1xuICAgICAgfVxuICAgICAgc3RhdGUuY3VycmVudFN0cm9rZVN0eWxlID0gc3Ryb2tlU3R5bGU7XG4gICAgICBzdGF0ZS5jdXJyZW50TGluZUNhcCA9IGxpbmVDYXA7XG4gICAgICBzdGF0ZS5jdXJyZW50TGluZURhc2ggPSBsaW5lRGFzaDtcbiAgICAgIHN0YXRlLmN1cnJlbnRMaW5lRGFzaE9mZnNldCA9IGxpbmVEYXNoT2Zmc2V0O1xuICAgICAgc3RhdGUuY3VycmVudExpbmVKb2luID0gbGluZUpvaW47XG4gICAgICBzdGF0ZS5jdXJyZW50TGluZVdpZHRoID0gbGluZVdpZHRoO1xuICAgICAgc3RhdGUuY3VycmVudE1pdGVyTGltaXQgPSBtaXRlckxpbWl0O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL0ZlYXR1cmUuanNcIikuRmVhdHVyZUxpa2V9IGZlYXR1cmUgRmVhdHVyZS5cbiAgICovXG4gIGVuZEdlb21ldHJ5KGZlYXR1cmUpIHtcbiAgICB0aGlzLmJlZ2luR2VvbWV0cnlJbnN0cnVjdGlvbjFfWzJdID0gdGhpcy5pbnN0cnVjdGlvbnMubGVuZ3RoO1xuICAgIHRoaXMuYmVnaW5HZW9tZXRyeUluc3RydWN0aW9uMV8gPSBudWxsO1xuICAgIHRoaXMuYmVnaW5HZW9tZXRyeUluc3RydWN0aW9uMl9bMl0gPSB0aGlzLmhpdERldGVjdGlvbkluc3RydWN0aW9ucy5sZW5ndGg7XG4gICAgdGhpcy5iZWdpbkdlb21ldHJ5SW5zdHJ1Y3Rpb24yXyA9IG51bGw7XG4gICAgY29uc3QgZW5kR2VvbWV0cnlJbnN0cnVjdGlvbiA9IFtDYW52YXNJbnN0cnVjdGlvbi5FTkRfR0VPTUVUUlksIGZlYXR1cmVdO1xuICAgIHRoaXMuaW5zdHJ1Y3Rpb25zLnB1c2goZW5kR2VvbWV0cnlJbnN0cnVjdGlvbik7XG4gICAgdGhpcy5oaXREZXRlY3Rpb25JbnN0cnVjdGlvbnMucHVzaChlbmRHZW9tZXRyeUluc3RydWN0aW9uKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGJ1ZmZlcmVkIHJlbmRlcmluZyBleHRlbnQuICBSZW5kZXJpbmcgd2lsbCBiZSBjbGlwcGVkIHRvIHRoZSBleHRlbnRcbiAgICogcHJvdmlkZWQgdG8gdGhlIGNvbnN0cnVjdG9yLiAgVG8gYWNjb3VudCBmb3Igc3ltYm9saXplcnMgdGhhdCBtYXkgaW50ZXJzZWN0XG4gICAqIHRoaXMgZXh0ZW50LCB3ZSBjYWxjdWxhdGUgYSBidWZmZXJlZCBleHRlbnQgKGUuZy4gYmFzZWQgb24gc3Ryb2tlIHdpZHRoKS5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gVGhlIGJ1ZmZlcmVkIHJlbmRlcmluZyBleHRlbnQuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIGdldEJ1ZmZlcmVkTWF4RXh0ZW50KCkge1xuICAgIGlmICghdGhpcy5idWZmZXJlZE1heEV4dGVudF8pIHtcbiAgICAgIHRoaXMuYnVmZmVyZWRNYXhFeHRlbnRfID0gY2xvbmUodGhpcy5tYXhFeHRlbnQpO1xuICAgICAgaWYgKHRoaXMubWF4TGluZVdpZHRoID4gMCkge1xuICAgICAgICBjb25zdCB3aWR0aCA9ICh0aGlzLnJlc29sdXRpb24gKiAodGhpcy5tYXhMaW5lV2lkdGggKyAxKSkgLyAyO1xuICAgICAgICBidWZmZXIodGhpcy5idWZmZXJlZE1heEV4dGVudF8sIHdpZHRoLCB0aGlzLmJ1ZmZlcmVkTWF4RXh0ZW50Xyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmJ1ZmZlcmVkTWF4RXh0ZW50XztcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBDYW52YXNCdWlsZGVyO1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3JlbmRlci9jYW52YXMvQnVpbGRlckdyb3VwXG4gKi9cblxuaW1wb3J0IEJ1aWxkZXIgZnJvbSAnLi9CdWlsZGVyLmpzJztcbmltcG9ydCBJbWFnZUJ1aWxkZXIgZnJvbSAnLi9JbWFnZUJ1aWxkZXIuanMnO1xuaW1wb3J0IExpbmVTdHJpbmdCdWlsZGVyIGZyb20gJy4vTGluZVN0cmluZ0J1aWxkZXIuanMnO1xuaW1wb3J0IFBvbHlnb25CdWlsZGVyIGZyb20gJy4vUG9seWdvbkJ1aWxkZXIuanMnO1xuaW1wb3J0IFRleHRCdWlsZGVyIGZyb20gJy4vVGV4dEJ1aWxkZXIuanMnO1xuXG4vKipcbiAqIEB0eXBlIHtPYmplY3Q8aW1wb3J0KFwiLi4vY2FudmFzLmpzXCIpLkJ1aWxkZXJUeXBlLCB0eXBlb2YgQnVpbGRlcj59XG4gKi9cbmNvbnN0IEJBVENIX0NPTlNUUlVDVE9SUyA9IHtcbiAgJ0NpcmNsZSc6IFBvbHlnb25CdWlsZGVyLFxuICAnRGVmYXVsdCc6IEJ1aWxkZXIsXG4gICdJbWFnZSc6IEltYWdlQnVpbGRlcixcbiAgJ0xpbmVTdHJpbmcnOiBMaW5lU3RyaW5nQnVpbGRlcixcbiAgJ1BvbHlnb24nOiBQb2x5Z29uQnVpbGRlcixcbiAgJ1RleHQnOiBUZXh0QnVpbGRlcixcbn07XG5cbmNsYXNzIEJ1aWxkZXJHcm91cCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gdG9sZXJhbmNlIFRvbGVyYW5jZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9leHRlbnQuanNcIikuRXh0ZW50fSBtYXhFeHRlbnQgTWF4IGV4dGVudC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHJlc29sdXRpb24gUmVzb2x1dGlvbi5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHBpeGVsUmF0aW8gUGl4ZWwgcmF0aW8uXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih0b2xlcmFuY2UsIG1heEV4dGVudCwgcmVzb2x1dGlvbiwgcGl4ZWxSYXRpbykge1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnRvbGVyYW5jZV8gPSB0b2xlcmFuY2U7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi9leHRlbnQuanNcIikuRXh0ZW50fVxuICAgICAqL1xuICAgIHRoaXMubWF4RXh0ZW50XyA9IG1heEV4dGVudDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnBpeGVsUmF0aW9fID0gcGl4ZWxSYXRpbztcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnJlc29sdXRpb25fID0gcmVzb2x1dGlvbjtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgeyFPYmplY3Q8c3RyaW5nLCAhT2JqZWN0PGltcG9ydChcIi4uL2NhbnZhcy5qc1wiKS5CdWlsZGVyVHlwZSwgQnVpbGRlcj4+fVxuICAgICAqL1xuICAgIHRoaXMuYnVpbGRlcnNCeVpJbmRleF8gPSB7fTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHshT2JqZWN0PHN0cmluZywgIU9iamVjdDxpbXBvcnQoXCIuLi9jYW52YXMuanNcIikuQnVpbGRlclR5cGUsIGltcG9ydChcIi4vQnVpbGRlci5qc1wiKS5TZXJpYWxpemFibGVJbnN0cnVjdGlvbnM+Pn0gVGhlIHNlcmlhbGl6YWJsZSBpbnN0cnVjdGlvbnNcbiAgICovXG4gIGZpbmlzaCgpIHtcbiAgICBjb25zdCBidWlsZGVySW5zdHJ1Y3Rpb25zID0ge307XG4gICAgZm9yIChjb25zdCB6S2V5IGluIHRoaXMuYnVpbGRlcnNCeVpJbmRleF8pIHtcbiAgICAgIGJ1aWxkZXJJbnN0cnVjdGlvbnNbektleV0gPSBidWlsZGVySW5zdHJ1Y3Rpb25zW3pLZXldIHx8IHt9O1xuICAgICAgY29uc3QgYnVpbGRlcnMgPSB0aGlzLmJ1aWxkZXJzQnlaSW5kZXhfW3pLZXldO1xuICAgICAgZm9yIChjb25zdCBidWlsZGVyS2V5IGluIGJ1aWxkZXJzKSB7XG4gICAgICAgIGNvbnN0IGJ1aWxkZXJJbnN0cnVjdGlvbiA9IGJ1aWxkZXJzW2J1aWxkZXJLZXldLmZpbmlzaCgpO1xuICAgICAgICBidWlsZGVySW5zdHJ1Y3Rpb25zW3pLZXldW2J1aWxkZXJLZXldID0gYnVpbGRlckluc3RydWN0aW9uO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYnVpbGRlckluc3RydWN0aW9ucztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcnx1bmRlZmluZWR9IHpJbmRleCBaIGluZGV4LlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2NhbnZhcy5qc1wiKS5CdWlsZGVyVHlwZX0gYnVpbGRlclR5cGUgUmVwbGF5IHR5cGUuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL1ZlY3RvckNvbnRleHQuanNcIikuZGVmYXVsdH0gUmVwbGF5LlxuICAgKi9cbiAgZ2V0QnVpbGRlcih6SW5kZXgsIGJ1aWxkZXJUeXBlKSB7XG4gICAgY29uc3QgekluZGV4S2V5ID0gekluZGV4ICE9PSB1bmRlZmluZWQgPyB6SW5kZXgudG9TdHJpbmcoKSA6ICcwJztcbiAgICBsZXQgcmVwbGF5cyA9IHRoaXMuYnVpbGRlcnNCeVpJbmRleF9bekluZGV4S2V5XTtcbiAgICBpZiAocmVwbGF5cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXBsYXlzID0ge307XG4gICAgICB0aGlzLmJ1aWxkZXJzQnlaSW5kZXhfW3pJbmRleEtleV0gPSByZXBsYXlzO1xuICAgIH1cbiAgICBsZXQgcmVwbGF5ID0gcmVwbGF5c1tidWlsZGVyVHlwZV07XG4gICAgaWYgKHJlcGxheSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zdCBDb25zdHJ1Y3RvciA9IEJBVENIX0NPTlNUUlVDVE9SU1tidWlsZGVyVHlwZV07XG4gICAgICByZXBsYXkgPSBuZXcgQ29uc3RydWN0b3IoXG4gICAgICAgIHRoaXMudG9sZXJhbmNlXyxcbiAgICAgICAgdGhpcy5tYXhFeHRlbnRfLFxuICAgICAgICB0aGlzLnJlc29sdXRpb25fLFxuICAgICAgICB0aGlzLnBpeGVsUmF0aW9fXG4gICAgICApO1xuICAgICAgcmVwbGF5c1tidWlsZGVyVHlwZV0gPSByZXBsYXk7XG4gICAgfVxuICAgIHJldHVybiByZXBsYXk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQnVpbGRlckdyb3VwO1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3JlbmRlci9jYW52YXMvRXhlY3V0b3JcbiAqL1xuaW1wb3J0IENhbnZhc0luc3RydWN0aW9uIGZyb20gJy4vSW5zdHJ1Y3Rpb24uanMnO1xuaW1wb3J0IHtURVhUX0FMSUdOfSBmcm9tICcuL1RleHRCdWlsZGVyLmpzJztcbmltcG9ydCB7XG4gIGFwcGx5IGFzIGFwcGx5VHJhbnNmb3JtLFxuICBjb21wb3NlIGFzIGNvbXBvc2VUcmFuc2Zvcm0sXG4gIGNyZWF0ZSBhcyBjcmVhdGVUcmFuc2Zvcm0sXG4gIHNldEZyb21BcnJheSBhcyB0cmFuc2Zvcm1TZXRGcm9tQXJyYXksXG59IGZyb20gJy4uLy4uL3RyYW5zZm9ybS5qcyc7XG5pbXBvcnQge2NyZWF0ZUVtcHR5LCBjcmVhdGVPclVwZGF0ZSwgaW50ZXJzZWN0c30gZnJvbSAnLi4vLi4vZXh0ZW50LmpzJztcbmltcG9ydCB7XG4gIGRlZmF1bHRQYWRkaW5nLFxuICBkZWZhdWx0VGV4dEFsaWduLFxuICBkZWZhdWx0VGV4dEJhc2VsaW5lLFxuICBkcmF3SW1hZ2VPckxhYmVsLFxuICBnZXRUZXh0RGltZW5zaW9ucyxcbiAgbWVhc3VyZUFuZENhY2hlVGV4dFdpZHRoLFxufSBmcm9tICcuLi9jYW52YXMuanMnO1xuaW1wb3J0IHtkcmF3VGV4dE9uUGF0aH0gZnJvbSAnLi4vLi4vZ2VvbS9mbGF0L3RleHRwYXRoLmpzJztcbmltcG9ydCB7ZXF1YWxzfSBmcm9tICcuLi8uLi9hcnJheS5qcyc7XG5pbXBvcnQge2xpbmVTdHJpbmdMZW5ndGh9IGZyb20gJy4uLy4uL2dlb20vZmxhdC9sZW5ndGguanMnO1xuaW1wb3J0IHt0cmFuc2Zvcm0yRH0gZnJvbSAnLi4vLi4vZ2VvbS9mbGF0L3RyYW5zZm9ybS5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gQkJveFxuICogQHByb3BlcnR5IHtudW1iZXJ9IG1pblggTWluaW1hbCB4LlxuICogQHByb3BlcnR5IHtudW1iZXJ9IG1pblkgTWluaW1hbCB5LlxuICogQHByb3BlcnR5IHtudW1iZXJ9IG1heFggTWF4aW1hbCB4LlxuICogQHByb3BlcnR5IHtudW1iZXJ9IG1heFkgTWF4aW1hbCB5XG4gKiBAcHJvcGVydHkgeyp9IHZhbHVlIFZhbHVlLlxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gSW1hZ2VPckxhYmVsRGltZW5zaW9uc1xuICogQHByb3BlcnR5IHtudW1iZXJ9IGRyYXdJbWFnZVggRHJhd0ltYWdlWC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkcmF3SW1hZ2VZIERyYXdJbWFnZVkuXG4gKiBAcHJvcGVydHkge251bWJlcn0gZHJhd0ltYWdlVyBEcmF3SW1hZ2VXLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IGRyYXdJbWFnZUggRHJhd0ltYWdlSC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBvcmlnaW5YIE9yaWdpblguXG4gKiBAcHJvcGVydHkge251bWJlcn0gb3JpZ2luWSBPcmlnaW5ZLlxuICogQHByb3BlcnR5IHtBcnJheTxudW1iZXI+fSBzY2FsZSBTY2FsZS5cbiAqIEBwcm9wZXJ0eSB7QkJveH0gZGVjbHV0dGVyQm94IERlY2x1dHRlckJveC5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vLi4vdHJhbnNmb3JtLmpzXCIpLlRyYW5zZm9ybX0gY2FudmFzVHJhbnNmb3JtIENhbnZhc1RyYW5zZm9ybS5cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHt7MDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELCAxOiBudW1iZXIsIDI6IGltcG9ydChcIi4uL2NhbnZhcy5qc1wiKS5MYWJlbHxIVE1MSW1hZ2VFbGVtZW50fEhUTUxDYW52YXNFbGVtZW50fEhUTUxWaWRlb0VsZW1lbnQsIDM6IEltYWdlT3JMYWJlbERpbWVuc2lvbnMsIDQ6IG51bWJlciwgNTogQXJyYXk8Kj4sIDY6IEFycmF5PCo+fX0gUmVwbGF5SW1hZ2VPckxhYmVsQXJnc1xuICovXG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEB0eXBlZGVmIHtmdW5jdGlvbihpbXBvcnQoXCIuLi8uLi9GZWF0dXJlLmpzXCIpLkZlYXR1cmVMaWtlLCBpbXBvcnQoXCIuLi8uLi9nZW9tL1NpbXBsZUdlb21ldHJ5LmpzXCIpLmRlZmF1bHQpOiBUfSBGZWF0dXJlQ2FsbGJhY2tcbiAqL1xuXG4vKipcbiAqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi9leHRlbnQuanNcIikuRXh0ZW50fVxuICovXG5jb25zdCB0bXBFeHRlbnQgPSBjcmVhdGVFbXB0eSgpO1xuXG4vKiogQHR5cGUge2ltcG9ydChcIi4uLy4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gKi9cbmNvbnN0IHAxID0gW107XG4vKiogQHR5cGUge2ltcG9ydChcIi4uLy4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gKi9cbmNvbnN0IHAyID0gW107XG4vKiogQHR5cGUge2ltcG9ydChcIi4uLy4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gKi9cbmNvbnN0IHAzID0gW107XG4vKiogQHR5cGUge2ltcG9ydChcIi4uLy4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gKi9cbmNvbnN0IHA0ID0gW107XG5cbi8qKlxuICogQHBhcmFtIHtSZXBsYXlJbWFnZU9yTGFiZWxBcmdzfSByZXBsYXlJbWFnZU9yTGFiZWxBcmdzIEFyZ3VtZW50cyB0byByZXBsYXlJbWFnZU9yTGFiZWxcbiAqIEByZXR1cm4ge0JCb3h9IERlY2x1dHRlciBiYm94LlxuICovXG5mdW5jdGlvbiBnZXREZWNsdXR0ZXJCb3gocmVwbGF5SW1hZ2VPckxhYmVsQXJncykge1xuICByZXR1cm4gcmVwbGF5SW1hZ2VPckxhYmVsQXJnc1szXS5kZWNsdXR0ZXJCb3g7XG59XG5cbmNvbnN0IHJ0bFJlZ0V4ID0gbmV3IFJlZ0V4cChcbiAgLyogZXNsaW50LWRpc2FibGUgcHJldHRpZXIvcHJldHRpZXIgKi9cbiAgJ1snICtcbiAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4MDA1OTEpICsgJy0nICsgU3RyaW5nLmZyb21DaGFyQ29kZSgweDAwOGZmKSArXG4gICAgU3RyaW5nLmZyb21DaGFyQ29kZSgweDBmYjFkKSArICctJyArIFN0cmluZy5mcm9tQ2hhckNvZGUoMHgwZmRmZikgK1xuICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoMHgwZmU3MCkgKyAnLScgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4MGZlZmMpICtcbiAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4MTA4MDApICsgJy0nICsgU3RyaW5nLmZyb21DaGFyQ29kZSgweDEwZmZmKSArXG4gICAgU3RyaW5nLmZyb21DaGFyQ29kZSgweDFlODAwKSArICctJyArIFN0cmluZy5mcm9tQ2hhckNvZGUoMHgxZWZmZikgK1xuICAnXSdcbiAgLyogZXNsaW50LWVuYWJsZSBwcmV0dGllci9wcmV0dGllciAqL1xuKTtcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBUZXh0LlxuICogQHBhcmFtIHtDYW52YXNUZXh0QWxpZ259IGFsaWduIEFsaWdubWVudC5cbiAqIEByZXR1cm4ge251bWJlcn0gVGV4dCBhbGlnbm1lbnQuXG4gKi9cbmZ1bmN0aW9uIGhvcml6b250YWxUZXh0QWxpZ24odGV4dCwgYWxpZ24pIHtcbiAgaWYgKGFsaWduID09PSAnc3RhcnQnKSB7XG4gICAgYWxpZ24gPSBydGxSZWdFeC50ZXN0KHRleHQpID8gJ3JpZ2h0JyA6ICdsZWZ0JztcbiAgfSBlbHNlIGlmIChhbGlnbiA9PT0gJ2VuZCcpIHtcbiAgICBhbGlnbiA9IHJ0bFJlZ0V4LnRlc3QodGV4dCkgPyAnbGVmdCcgOiAncmlnaHQnO1xuICB9XG4gIHJldHVybiBURVhUX0FMSUdOW2FsaWduXTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IGFjYyBBY2N1bXVsYXRvci5cbiAqIEBwYXJhbSB7c3RyaW5nfSBsaW5lIExpbmUgb2YgdGV4dC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBpIEluZGV4XG4gKiBAcmV0dXJuIHtBcnJheTxzdHJpbmc+fSBBY2N1bXVsYXRvci5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlVGV4dENodW5rcyhhY2MsIGxpbmUsIGkpIHtcbiAgaWYgKGkgPiAwKSB7XG4gICAgYWNjLnB1c2goJ1xcbicsICcnKTtcbiAgfVxuICBhY2MucHVzaChsaW5lLCAnJyk7XG4gIHJldHVybiBhY2M7XG59XG5cbmNsYXNzIEV4ZWN1dG9yIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSByZXNvbHV0aW9uIFJlc29sdXRpb24uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwaXhlbFJhdGlvIFBpeGVsIHJhdGlvLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IG92ZXJsYXBzIFRoZSByZXBsYXkgY2FuIGhhdmUgb3ZlcmxhcHBpbmcgZ2VvbWV0cmllcy5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jYW52YXMuanNcIikuU2VyaWFsaXphYmxlSW5zdHJ1Y3Rpb25zfSBpbnN0cnVjdGlvbnMgVGhlIHNlcmlhbGl6YWJsZSBpbnN0cnVjdGlvbnNcbiAgICovXG4gIGNvbnN0cnVjdG9yKHJlc29sdXRpb24sIHBpeGVsUmF0aW8sIG92ZXJsYXBzLCBpbnN0cnVjdGlvbnMpIHtcbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5vdmVybGFwcyA9IG92ZXJsYXBzO1xuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5waXhlbFJhdGlvID0gcGl4ZWxSYXRpbztcblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAY29uc3RcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucmVzb2x1dGlvbiA9IHJlc29sdXRpb247XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuYWxpZ25GaWxsXztcblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAdHlwZSB7QXJyYXk8Kj59XG4gICAgICovXG4gICAgdGhpcy5pbnN0cnVjdGlvbnMgPSBpbnN0cnVjdGlvbnMuaW5zdHJ1Y3Rpb25zO1xuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEB0eXBlIHtBcnJheTxudW1iZXI+fVxuICAgICAqL1xuICAgIHRoaXMuY29vcmRpbmF0ZXMgPSBpbnN0cnVjdGlvbnMuY29vcmRpbmF0ZXM7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHshT2JqZWN0PG51bWJlcixpbXBvcnQoXCIuLi8uLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV8QXJyYXk8aW1wb3J0KFwiLi4vLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlPnxBcnJheTxBcnJheTxpbXBvcnQoXCIuLi8uLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGU+Pj59XG4gICAgICovXG4gICAgdGhpcy5jb29yZGluYXRlQ2FjaGVfID0ge307XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHshaW1wb3J0KFwiLi4vLi4vdHJhbnNmb3JtLmpzXCIpLlRyYW5zZm9ybX1cbiAgICAgKi9cbiAgICB0aGlzLnJlbmRlcmVkVHJhbnNmb3JtXyA9IGNyZWF0ZVRyYW5zZm9ybSgpO1xuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEB0eXBlIHtBcnJheTwqPn1cbiAgICAgKi9cbiAgICB0aGlzLmhpdERldGVjdGlvbkluc3RydWN0aW9ucyA9IGluc3RydWN0aW9ucy5oaXREZXRlY3Rpb25JbnN0cnVjdGlvbnM7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtBcnJheTxudW1iZXI+fVxuICAgICAqL1xuICAgIHRoaXMucGl4ZWxDb29yZGluYXRlc18gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMudmlld1JvdGF0aW9uXyA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7IU9iamVjdDxzdHJpbmcsIGltcG9ydChcIi4uL2NhbnZhcy5qc1wiKS5GaWxsU3RhdGU+fVxuICAgICAqL1xuICAgIHRoaXMuZmlsbFN0YXRlcyA9IGluc3RydWN0aW9ucy5maWxsU3RhdGVzIHx8IHt9O1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUgeyFPYmplY3Q8c3RyaW5nLCBpbXBvcnQoXCIuLi9jYW52YXMuanNcIikuU3Ryb2tlU3RhdGU+fVxuICAgICAqL1xuICAgIHRoaXMuc3Ryb2tlU3RhdGVzID0gaW5zdHJ1Y3Rpb25zLnN0cm9rZVN0YXRlcyB8fCB7fTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHshT2JqZWN0PHN0cmluZywgaW1wb3J0KFwiLi4vY2FudmFzLmpzXCIpLlRleHRTdGF0ZT59XG4gICAgICovXG4gICAgdGhpcy50ZXh0U3RhdGVzID0gaW5zdHJ1Y3Rpb25zLnRleHRTdGF0ZXMgfHwge307XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBPYmplY3Q8c3RyaW5nLCBudW1iZXI+Pn1cbiAgICAgKi9cbiAgICB0aGlzLndpZHRoc18gPSB7fTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge09iamVjdDxzdHJpbmcsIGltcG9ydChcIi4uL2NhbnZhcy5qc1wiKS5MYWJlbD59XG4gICAgICovXG4gICAgdGhpcy5sYWJlbHNfID0ge307XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd8QXJyYXk8c3RyaW5nPn0gdGV4dCBUZXh0LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dEtleSBUZXh0IHN0eWxlIGtleS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGZpbGxLZXkgRmlsbCBzdHlsZSBrZXkuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJva2VLZXkgU3Ryb2tlIHN0eWxlIGtleS5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vY2FudmFzLmpzXCIpLkxhYmVsfSBMYWJlbC5cbiAgICovXG4gIGNyZWF0ZUxhYmVsKHRleHQsIHRleHRLZXksIGZpbGxLZXksIHN0cm9rZUtleSkge1xuICAgIGNvbnN0IGtleSA9IHRleHQgKyB0ZXh0S2V5ICsgZmlsbEtleSArIHN0cm9rZUtleTtcbiAgICBpZiAodGhpcy5sYWJlbHNfW2tleV0pIHtcbiAgICAgIHJldHVybiB0aGlzLmxhYmVsc19ba2V5XTtcbiAgICB9XG4gICAgY29uc3Qgc3Ryb2tlU3RhdGUgPSBzdHJva2VLZXkgPyB0aGlzLnN0cm9rZVN0YXRlc1tzdHJva2VLZXldIDogbnVsbDtcbiAgICBjb25zdCBmaWxsU3RhdGUgPSBmaWxsS2V5ID8gdGhpcy5maWxsU3RhdGVzW2ZpbGxLZXldIDogbnVsbDtcbiAgICBjb25zdCB0ZXh0U3RhdGUgPSB0aGlzLnRleHRTdGF0ZXNbdGV4dEtleV07XG4gICAgY29uc3QgcGl4ZWxSYXRpbyA9IHRoaXMucGl4ZWxSYXRpbztcbiAgICBjb25zdCBzY2FsZSA9IFtcbiAgICAgIHRleHRTdGF0ZS5zY2FsZVswXSAqIHBpeGVsUmF0aW8sXG4gICAgICB0ZXh0U3RhdGUuc2NhbGVbMV0gKiBwaXhlbFJhdGlvLFxuICAgIF07XG4gICAgY29uc3QgdGV4dElzQXJyYXkgPSBBcnJheS5pc0FycmF5KHRleHQpO1xuICAgIGNvbnN0IGFsaWduID0gdGV4dFN0YXRlLmp1c3RpZnlcbiAgICAgID8gVEVYVF9BTElHTlt0ZXh0U3RhdGUuanVzdGlmeV1cbiAgICAgIDogaG9yaXpvbnRhbFRleHRBbGlnbihcbiAgICAgICAgICBBcnJheS5pc0FycmF5KHRleHQpID8gdGV4dFswXSA6IHRleHQsXG4gICAgICAgICAgdGV4dFN0YXRlLnRleHRBbGlnbiB8fCBkZWZhdWx0VGV4dEFsaWduXG4gICAgICAgICk7XG4gICAgY29uc3Qgc3Ryb2tlV2lkdGggPVxuICAgICAgc3Ryb2tlS2V5ICYmIHN0cm9rZVN0YXRlLmxpbmVXaWR0aCA/IHN0cm9rZVN0YXRlLmxpbmVXaWR0aCA6IDA7XG5cbiAgICBjb25zdCBjaHVua3MgPSB0ZXh0SXNBcnJheVxuICAgICAgPyB0ZXh0XG4gICAgICA6IHRleHQuc3BsaXQoJ1xcbicpLnJlZHVjZShjcmVhdGVUZXh0Q2h1bmtzLCBbXSk7XG5cbiAgICBjb25zdCB7d2lkdGgsIGhlaWdodCwgd2lkdGhzLCBoZWlnaHRzLCBsaW5lV2lkdGhzfSA9IGdldFRleHREaW1lbnNpb25zKFxuICAgICAgdGV4dFN0YXRlLFxuICAgICAgY2h1bmtzXG4gICAgKTtcbiAgICBjb25zdCByZW5kZXJXaWR0aCA9IHdpZHRoICsgc3Ryb2tlV2lkdGg7XG4gICAgY29uc3QgY29udGV4dEluc3RydWN0aW9ucyA9IFtdO1xuICAgIC8vIG1ha2UgY2FudmFzIDIgcGl4ZWxzIHdpZGVyIHRvIGFjY291bnQgZm9yIGl0YWxpYyB0ZXh0IHdpZHRoIG1lYXN1cmVtZW50IGVycm9yc1xuICAgIGNvbnN0IHcgPSAocmVuZGVyV2lkdGggKyAyKSAqIHNjYWxlWzBdO1xuICAgIGNvbnN0IGggPSAoaGVpZ2h0ICsgc3Ryb2tlV2lkdGgpICogc2NhbGVbMV07XG4gICAgLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi9jYW52YXMuanNcIikuTGFiZWx9ICovXG4gICAgY29uc3QgbGFiZWwgPSB7XG4gICAgICB3aWR0aDogdyA8IDAgPyBNYXRoLmZsb29yKHcpIDogTWF0aC5jZWlsKHcpLFxuICAgICAgaGVpZ2h0OiBoIDwgMCA/IE1hdGguZmxvb3IoaCkgOiBNYXRoLmNlaWwoaCksXG4gICAgICBjb250ZXh0SW5zdHJ1Y3Rpb25zOiBjb250ZXh0SW5zdHJ1Y3Rpb25zLFxuICAgIH07XG4gICAgaWYgKHNjYWxlWzBdICE9IDEgfHwgc2NhbGVbMV0gIT0gMSkge1xuICAgICAgY29udGV4dEluc3RydWN0aW9ucy5wdXNoKCdzY2FsZScsIHNjYWxlKTtcbiAgICB9XG4gICAgaWYgKHN0cm9rZUtleSkge1xuICAgICAgY29udGV4dEluc3RydWN0aW9ucy5wdXNoKCdzdHJva2VTdHlsZScsIHN0cm9rZVN0YXRlLnN0cm9rZVN0eWxlKTtcbiAgICAgIGNvbnRleHRJbnN0cnVjdGlvbnMucHVzaCgnbGluZVdpZHRoJywgc3Ryb2tlV2lkdGgpO1xuICAgICAgY29udGV4dEluc3RydWN0aW9ucy5wdXNoKCdsaW5lQ2FwJywgc3Ryb2tlU3RhdGUubGluZUNhcCk7XG4gICAgICBjb250ZXh0SW5zdHJ1Y3Rpb25zLnB1c2goJ2xpbmVKb2luJywgc3Ryb2tlU3RhdGUubGluZUpvaW4pO1xuICAgICAgY29udGV4dEluc3RydWN0aW9ucy5wdXNoKCdtaXRlckxpbWl0Jywgc3Ryb2tlU3RhdGUubWl0ZXJMaW1pdCk7XG4gICAgICBjb250ZXh0SW5zdHJ1Y3Rpb25zLnB1c2goJ3NldExpbmVEYXNoJywgW3N0cm9rZVN0YXRlLmxpbmVEYXNoXSk7XG4gICAgICBjb250ZXh0SW5zdHJ1Y3Rpb25zLnB1c2goJ2xpbmVEYXNoT2Zmc2V0Jywgc3Ryb2tlU3RhdGUubGluZURhc2hPZmZzZXQpO1xuICAgIH1cbiAgICBpZiAoZmlsbEtleSkge1xuICAgICAgY29udGV4dEluc3RydWN0aW9ucy5wdXNoKCdmaWxsU3R5bGUnLCBmaWxsU3RhdGUuZmlsbFN0eWxlKTtcbiAgICB9XG4gICAgY29udGV4dEluc3RydWN0aW9ucy5wdXNoKCd0ZXh0QmFzZWxpbmUnLCAnbWlkZGxlJyk7XG4gICAgY29udGV4dEluc3RydWN0aW9ucy5wdXNoKCd0ZXh0QWxpZ24nLCAnY2VudGVyJyk7XG4gICAgY29uc3QgbGVmdFJpZ2h0ID0gMC41IC0gYWxpZ247XG4gICAgbGV0IHggPSBhbGlnbiAqIHJlbmRlcldpZHRoICsgbGVmdFJpZ2h0ICogc3Ryb2tlV2lkdGg7XG4gICAgY29uc3Qgc3Ryb2tlSW5zdHJ1Y3Rpb25zID0gW107XG4gICAgY29uc3QgZmlsbEluc3RydWN0aW9ucyA9IFtdO1xuICAgIGxldCBsaW5lSGVpZ2h0ID0gMDtcbiAgICBsZXQgbGluZU9mZnNldCA9IDA7XG4gICAgbGV0IHdpZHRoSGVpZ2h0SW5kZXggPSAwO1xuICAgIGxldCBsaW5lV2lkdGhJbmRleCA9IDA7XG4gICAgbGV0IHByZXZpb3VzRm9udDtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBjaHVua3MubGVuZ3RoOyBpIDwgaWk7IGkgKz0gMikge1xuICAgICAgY29uc3QgdGV4dCA9IGNodW5rc1tpXTtcbiAgICAgIGlmICh0ZXh0ID09PSAnXFxuJykge1xuICAgICAgICBsaW5lT2Zmc2V0ICs9IGxpbmVIZWlnaHQ7XG4gICAgICAgIGxpbmVIZWlnaHQgPSAwO1xuICAgICAgICB4ID0gYWxpZ24gKiByZW5kZXJXaWR0aCArIGxlZnRSaWdodCAqIHN0cm9rZVdpZHRoO1xuICAgICAgICArK2xpbmVXaWR0aEluZGV4O1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGZvbnQgPSBjaHVua3NbaSArIDFdIHx8IHRleHRTdGF0ZS5mb250O1xuICAgICAgaWYgKGZvbnQgIT09IHByZXZpb3VzRm9udCkge1xuICAgICAgICBpZiAoc3Ryb2tlS2V5KSB7XG4gICAgICAgICAgc3Ryb2tlSW5zdHJ1Y3Rpb25zLnB1c2goJ2ZvbnQnLCBmb250KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmlsbEtleSkge1xuICAgICAgICAgIGZpbGxJbnN0cnVjdGlvbnMucHVzaCgnZm9udCcsIGZvbnQpO1xuICAgICAgICB9XG4gICAgICAgIHByZXZpb3VzRm9udCA9IGZvbnQ7XG4gICAgICB9XG4gICAgICBsaW5lSGVpZ2h0ID0gTWF0aC5tYXgobGluZUhlaWdodCwgaGVpZ2h0c1t3aWR0aEhlaWdodEluZGV4XSk7XG4gICAgICBjb25zdCBmaWxsU3Ryb2tlQXJncyA9IFtcbiAgICAgICAgdGV4dCxcbiAgICAgICAgeCArXG4gICAgICAgICAgbGVmdFJpZ2h0ICogd2lkdGhzW3dpZHRoSGVpZ2h0SW5kZXhdICtcbiAgICAgICAgICBhbGlnbiAqICh3aWR0aHNbd2lkdGhIZWlnaHRJbmRleF0gLSBsaW5lV2lkdGhzW2xpbmVXaWR0aEluZGV4XSksXG4gICAgICAgIDAuNSAqIChzdHJva2VXaWR0aCArIGxpbmVIZWlnaHQpICsgbGluZU9mZnNldCxcbiAgICAgIF07XG4gICAgICB4ICs9IHdpZHRoc1t3aWR0aEhlaWdodEluZGV4XTtcbiAgICAgIGlmIChzdHJva2VLZXkpIHtcbiAgICAgICAgc3Ryb2tlSW5zdHJ1Y3Rpb25zLnB1c2goJ3N0cm9rZVRleHQnLCBmaWxsU3Ryb2tlQXJncyk7XG4gICAgICB9XG4gICAgICBpZiAoZmlsbEtleSkge1xuICAgICAgICBmaWxsSW5zdHJ1Y3Rpb25zLnB1c2goJ2ZpbGxUZXh0JywgZmlsbFN0cm9rZUFyZ3MpO1xuICAgICAgfVxuICAgICAgKyt3aWR0aEhlaWdodEluZGV4O1xuICAgIH1cbiAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShjb250ZXh0SW5zdHJ1Y3Rpb25zLCBzdHJva2VJbnN0cnVjdGlvbnMpO1xuICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGNvbnRleHRJbnN0cnVjdGlvbnMsIGZpbGxJbnN0cnVjdGlvbnMpO1xuICAgIHRoaXMubGFiZWxzX1trZXldID0gbGFiZWw7XG4gICAgcmV0dXJuIGxhYmVsO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjb250ZXh0IENvbnRleHQuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBwMSAxc3QgcG9pbnQgb2YgdGhlIGJhY2tncm91bmQgYm94LlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gcDIgMm5kIHBvaW50IG9mIHRoZSBiYWNrZ3JvdW5kIGJveC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IHAzIDNyZCBwb2ludCBvZiB0aGUgYmFja2dyb3VuZCBib3guXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBwNCA0dGggcG9pbnQgb2YgdGhlIGJhY2tncm91bmQgYm94LlxuICAgKiBAcGFyYW0ge0FycmF5PCo+fSBmaWxsSW5zdHJ1Y3Rpb24gRmlsbCBpbnN0cnVjdGlvbi5cbiAgICogQHBhcmFtIHtBcnJheTwqPn0gc3Ryb2tlSW5zdHJ1Y3Rpb24gU3Ryb2tlIGluc3RydWN0aW9uLlxuICAgKi9cbiAgcmVwbGF5VGV4dEJhY2tncm91bmRfKFxuICAgIGNvbnRleHQsXG4gICAgcDEsXG4gICAgcDIsXG4gICAgcDMsXG4gICAgcDQsXG4gICAgZmlsbEluc3RydWN0aW9uLFxuICAgIHN0cm9rZUluc3RydWN0aW9uXG4gICkge1xuICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgY29udGV4dC5tb3ZlVG8uYXBwbHkoY29udGV4dCwgcDEpO1xuICAgIGNvbnRleHQubGluZVRvLmFwcGx5KGNvbnRleHQsIHAyKTtcbiAgICBjb250ZXh0LmxpbmVUby5hcHBseShjb250ZXh0LCBwMyk7XG4gICAgY29udGV4dC5saW5lVG8uYXBwbHkoY29udGV4dCwgcDQpO1xuICAgIGNvbnRleHQubGluZVRvLmFwcGx5KGNvbnRleHQsIHAxKTtcbiAgICBpZiAoZmlsbEluc3RydWN0aW9uKSB7XG4gICAgICB0aGlzLmFsaWduRmlsbF8gPSAvKiogQHR5cGUge2Jvb2xlYW59ICovIChmaWxsSW5zdHJ1Y3Rpb25bMl0pO1xuICAgICAgdGhpcy5maWxsXyhjb250ZXh0KTtcbiAgICB9XG4gICAgaWYgKHN0cm9rZUluc3RydWN0aW9uKSB7XG4gICAgICB0aGlzLnNldFN0cm9rZVN0eWxlXyhcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgLyoqIEB0eXBlIHtBcnJheTwqPn0gKi8gKHN0cm9rZUluc3RydWN0aW9uKVxuICAgICAgKTtcbiAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzaGVldFdpZHRoIFdpZHRoIG9mIHRoZSBzcHJpdGUgc2hlZXQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzaGVldEhlaWdodCBIZWlnaHQgb2YgdGhlIHNwcml0ZSBzaGVldC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGNlbnRlclggWC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGNlbnRlclkgWS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIFdpZHRoLlxuICAgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IEhlaWdodC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGFuY2hvclggQW5jaG9yIFguXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBhbmNob3JZIEFuY2hvciBZLlxuICAgKiBAcGFyYW0ge251bWJlcn0gb3JpZ2luWCBPcmlnaW4gWC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG9yaWdpblkgT3JpZ2luIFkuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSByb3RhdGlvbiBSb3RhdGlvbi5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9zaXplLmpzXCIpLlNpemV9IHNjYWxlIFNjYWxlLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNuYXBUb1BpeGVsIFNuYXAgdG8gcGl4ZWwuXG4gICAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gcGFkZGluZyBQYWRkaW5nLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGZpbGxTdHJva2UgQmFja2dyb3VuZCBmaWxsIG9yIHN0cm9rZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9GZWF0dXJlLmpzXCIpLkZlYXR1cmVMaWtlfSBmZWF0dXJlIEZlYXR1cmUuXG4gICAqIEByZXR1cm4ge0ltYWdlT3JMYWJlbERpbWVuc2lvbnN9IERpbWVuc2lvbnMgZm9yIHBvc2l0aW9uaW5nIGFuZCBkZWNsdXR0ZXJpbmcgdGhlIGltYWdlIG9yIGxhYmVsLlxuICAgKi9cbiAgY2FsY3VsYXRlSW1hZ2VPckxhYmVsRGltZW5zaW9uc18oXG4gICAgc2hlZXRXaWR0aCxcbiAgICBzaGVldEhlaWdodCxcbiAgICBjZW50ZXJYLFxuICAgIGNlbnRlclksXG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgIGFuY2hvclgsXG4gICAgYW5jaG9yWSxcbiAgICBvcmlnaW5YLFxuICAgIG9yaWdpblksXG4gICAgcm90YXRpb24sXG4gICAgc2NhbGUsXG4gICAgc25hcFRvUGl4ZWwsXG4gICAgcGFkZGluZyxcbiAgICBmaWxsU3Ryb2tlLFxuICAgIGZlYXR1cmVcbiAgKSB7XG4gICAgYW5jaG9yWCAqPSBzY2FsZVswXTtcbiAgICBhbmNob3JZICo9IHNjYWxlWzFdO1xuICAgIGxldCB4ID0gY2VudGVyWCAtIGFuY2hvclg7XG4gICAgbGV0IHkgPSBjZW50ZXJZIC0gYW5jaG9yWTtcblxuICAgIGNvbnN0IHcgPSB3aWR0aCArIG9yaWdpblggPiBzaGVldFdpZHRoID8gc2hlZXRXaWR0aCAtIG9yaWdpblggOiB3aWR0aDtcbiAgICBjb25zdCBoID0gaGVpZ2h0ICsgb3JpZ2luWSA+IHNoZWV0SGVpZ2h0ID8gc2hlZXRIZWlnaHQgLSBvcmlnaW5ZIDogaGVpZ2h0O1xuICAgIGNvbnN0IGJveFcgPSBwYWRkaW5nWzNdICsgdyAqIHNjYWxlWzBdICsgcGFkZGluZ1sxXTtcbiAgICBjb25zdCBib3hIID0gcGFkZGluZ1swXSArIGggKiBzY2FsZVsxXSArIHBhZGRpbmdbMl07XG4gICAgY29uc3QgYm94WCA9IHggLSBwYWRkaW5nWzNdO1xuICAgIGNvbnN0IGJveFkgPSB5IC0gcGFkZGluZ1swXTtcblxuICAgIGlmIChmaWxsU3Ryb2tlIHx8IHJvdGF0aW9uICE9PSAwKSB7XG4gICAgICBwMVswXSA9IGJveFg7XG4gICAgICBwNFswXSA9IGJveFg7XG4gICAgICBwMVsxXSA9IGJveFk7XG4gICAgICBwMlsxXSA9IGJveFk7XG4gICAgICBwMlswXSA9IGJveFggKyBib3hXO1xuICAgICAgcDNbMF0gPSBwMlswXTtcbiAgICAgIHAzWzFdID0gYm94WSArIGJveEg7XG4gICAgICBwNFsxXSA9IHAzWzFdO1xuICAgIH1cblxuICAgIGxldCB0cmFuc2Zvcm07XG4gICAgaWYgKHJvdGF0aW9uICE9PSAwKSB7XG4gICAgICB0cmFuc2Zvcm0gPSBjb21wb3NlVHJhbnNmb3JtKFxuICAgICAgICBjcmVhdGVUcmFuc2Zvcm0oKSxcbiAgICAgICAgY2VudGVyWCxcbiAgICAgICAgY2VudGVyWSxcbiAgICAgICAgMSxcbiAgICAgICAgMSxcbiAgICAgICAgcm90YXRpb24sXG4gICAgICAgIC1jZW50ZXJYLFxuICAgICAgICAtY2VudGVyWVxuICAgICAgKTtcblxuICAgICAgYXBwbHlUcmFuc2Zvcm0odHJhbnNmb3JtLCBwMSk7XG4gICAgICBhcHBseVRyYW5zZm9ybSh0cmFuc2Zvcm0sIHAyKTtcbiAgICAgIGFwcGx5VHJhbnNmb3JtKHRyYW5zZm9ybSwgcDMpO1xuICAgICAgYXBwbHlUcmFuc2Zvcm0odHJhbnNmb3JtLCBwNCk7XG4gICAgICBjcmVhdGVPclVwZGF0ZShcbiAgICAgICAgTWF0aC5taW4ocDFbMF0sIHAyWzBdLCBwM1swXSwgcDRbMF0pLFxuICAgICAgICBNYXRoLm1pbihwMVsxXSwgcDJbMV0sIHAzWzFdLCBwNFsxXSksXG4gICAgICAgIE1hdGgubWF4KHAxWzBdLCBwMlswXSwgcDNbMF0sIHA0WzBdKSxcbiAgICAgICAgTWF0aC5tYXgocDFbMV0sIHAyWzFdLCBwM1sxXSwgcDRbMV0pLFxuICAgICAgICB0bXBFeHRlbnRcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNyZWF0ZU9yVXBkYXRlKFxuICAgICAgICBNYXRoLm1pbihib3hYLCBib3hYICsgYm94VyksXG4gICAgICAgIE1hdGgubWluKGJveFksIGJveFkgKyBib3hIKSxcbiAgICAgICAgTWF0aC5tYXgoYm94WCwgYm94WCArIGJveFcpLFxuICAgICAgICBNYXRoLm1heChib3hZLCBib3hZICsgYm94SCksXG4gICAgICAgIHRtcEV4dGVudFxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKHNuYXBUb1BpeGVsKSB7XG4gICAgICB4ID0gTWF0aC5yb3VuZCh4KTtcbiAgICAgIHkgPSBNYXRoLnJvdW5kKHkpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgZHJhd0ltYWdlWDogeCxcbiAgICAgIGRyYXdJbWFnZVk6IHksXG4gICAgICBkcmF3SW1hZ2VXOiB3LFxuICAgICAgZHJhd0ltYWdlSDogaCxcbiAgICAgIG9yaWdpblg6IG9yaWdpblgsXG4gICAgICBvcmlnaW5ZOiBvcmlnaW5ZLFxuICAgICAgZGVjbHV0dGVyQm94OiB7XG4gICAgICAgIG1pblg6IHRtcEV4dGVudFswXSxcbiAgICAgICAgbWluWTogdG1wRXh0ZW50WzFdLFxuICAgICAgICBtYXhYOiB0bXBFeHRlbnRbMl0sXG4gICAgICAgIG1heFk6IHRtcEV4dGVudFszXSxcbiAgICAgICAgdmFsdWU6IGZlYXR1cmUsXG4gICAgICB9LFxuICAgICAgY2FudmFzVHJhbnNmb3JtOiB0cmFuc2Zvcm0sXG4gICAgICBzY2FsZTogc2NhbGUsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY29udGV4dCBDb250ZXh0LlxuICAgKiBAcGFyYW0ge251bWJlcn0gY29udGV4dFNjYWxlIFNjYWxlIG9mIHRoZSBjb250ZXh0LlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2NhbnZhcy5qc1wiKS5MYWJlbHxIVE1MSW1hZ2VFbGVtZW50fEhUTUxDYW52YXNFbGVtZW50fEhUTUxWaWRlb0VsZW1lbnR9IGltYWdlT3JMYWJlbCBJbWFnZS5cbiAgICogQHBhcmFtIHtJbWFnZU9yTGFiZWxEaW1lbnNpb25zfSBkaW1lbnNpb25zIERpbWVuc2lvbnMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvcGFjaXR5IE9wYWNpdHkuXG4gICAqIEBwYXJhbSB7QXJyYXk8Kj59IGZpbGxJbnN0cnVjdGlvbiBGaWxsIGluc3RydWN0aW9uLlxuICAgKiBAcGFyYW0ge0FycmF5PCo+fSBzdHJva2VJbnN0cnVjdGlvbiBTdHJva2UgaW5zdHJ1Y3Rpb24uXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSBpbWFnZSBvciBsYWJlbCB3YXMgcmVuZGVyZWQuXG4gICAqL1xuICByZXBsYXlJbWFnZU9yTGFiZWxfKFxuICAgIGNvbnRleHQsXG4gICAgY29udGV4dFNjYWxlLFxuICAgIGltYWdlT3JMYWJlbCxcbiAgICBkaW1lbnNpb25zLFxuICAgIG9wYWNpdHksXG4gICAgZmlsbEluc3RydWN0aW9uLFxuICAgIHN0cm9rZUluc3RydWN0aW9uXG4gICkge1xuICAgIGNvbnN0IGZpbGxTdHJva2UgPSAhIShmaWxsSW5zdHJ1Y3Rpb24gfHwgc3Ryb2tlSW5zdHJ1Y3Rpb24pO1xuXG4gICAgY29uc3QgYm94ID0gZGltZW5zaW9ucy5kZWNsdXR0ZXJCb3g7XG4gICAgY29uc3QgY2FudmFzID0gY29udGV4dC5jYW52YXM7XG4gICAgY29uc3Qgc3Ryb2tlUGFkZGluZyA9IHN0cm9rZUluc3RydWN0aW9uXG4gICAgICA/IChzdHJva2VJbnN0cnVjdGlvblsyXSAqIGRpbWVuc2lvbnMuc2NhbGVbMF0pIC8gMlxuICAgICAgOiAwO1xuICAgIGNvbnN0IGludGVyc2VjdHMgPVxuICAgICAgYm94Lm1pblggLSBzdHJva2VQYWRkaW5nIDw9IGNhbnZhcy53aWR0aCAvIGNvbnRleHRTY2FsZSAmJlxuICAgICAgYm94Lm1heFggKyBzdHJva2VQYWRkaW5nID49IDAgJiZcbiAgICAgIGJveC5taW5ZIC0gc3Ryb2tlUGFkZGluZyA8PSBjYW52YXMuaGVpZ2h0IC8gY29udGV4dFNjYWxlICYmXG4gICAgICBib3gubWF4WSArIHN0cm9rZVBhZGRpbmcgPj0gMDtcblxuICAgIGlmIChpbnRlcnNlY3RzKSB7XG4gICAgICBpZiAoZmlsbFN0cm9rZSkge1xuICAgICAgICB0aGlzLnJlcGxheVRleHRCYWNrZ3JvdW5kXyhcbiAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgIHAxLFxuICAgICAgICAgIHAyLFxuICAgICAgICAgIHAzLFxuICAgICAgICAgIHA0LFxuICAgICAgICAgIC8qKiBAdHlwZSB7QXJyYXk8Kj59ICovIChmaWxsSW5zdHJ1Y3Rpb24pLFxuICAgICAgICAgIC8qKiBAdHlwZSB7QXJyYXk8Kj59ICovIChzdHJva2VJbnN0cnVjdGlvbilcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGRyYXdJbWFnZU9yTGFiZWwoXG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIGRpbWVuc2lvbnMuY2FudmFzVHJhbnNmb3JtLFxuICAgICAgICBvcGFjaXR5LFxuICAgICAgICBpbWFnZU9yTGFiZWwsXG4gICAgICAgIGRpbWVuc2lvbnMub3JpZ2luWCxcbiAgICAgICAgZGltZW5zaW9ucy5vcmlnaW5ZLFxuICAgICAgICBkaW1lbnNpb25zLmRyYXdJbWFnZVcsXG4gICAgICAgIGRpbWVuc2lvbnMuZHJhd0ltYWdlSCxcbiAgICAgICAgZGltZW5zaW9ucy5kcmF3SW1hZ2VYLFxuICAgICAgICBkaW1lbnNpb25zLmRyYXdJbWFnZVksXG4gICAgICAgIGRpbWVuc2lvbnMuc2NhbGVcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjb250ZXh0IENvbnRleHQuXG4gICAqL1xuICBmaWxsXyhjb250ZXh0KSB7XG4gICAgaWYgKHRoaXMuYWxpZ25GaWxsXykge1xuICAgICAgY29uc3Qgb3JpZ2luID0gYXBwbHlUcmFuc2Zvcm0odGhpcy5yZW5kZXJlZFRyYW5zZm9ybV8sIFswLCAwXSk7XG4gICAgICBjb25zdCByZXBlYXRTaXplID0gNTEyICogdGhpcy5waXhlbFJhdGlvO1xuICAgICAgY29udGV4dC5zYXZlKCk7XG4gICAgICBjb250ZXh0LnRyYW5zbGF0ZShvcmlnaW5bMF0gJSByZXBlYXRTaXplLCBvcmlnaW5bMV0gJSByZXBlYXRTaXplKTtcbiAgICAgIGNvbnRleHQucm90YXRlKHRoaXMudmlld1JvdGF0aW9uXyk7XG4gICAgfVxuICAgIGNvbnRleHQuZmlsbCgpO1xuICAgIGlmICh0aGlzLmFsaWduRmlsbF8pIHtcbiAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY29udGV4dCBDb250ZXh0LlxuICAgKiBAcGFyYW0ge0FycmF5PCo+fSBpbnN0cnVjdGlvbiBJbnN0cnVjdGlvbi5cbiAgICovXG4gIHNldFN0cm9rZVN0eWxlXyhjb250ZXh0LCBpbnN0cnVjdGlvbikge1xuICAgIGNvbnRleHRbJ3N0cm9rZVN0eWxlJ10gPVxuICAgICAgLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi9jb2xvcmxpa2UuanNcIikuQ29sb3JMaWtlfSAqLyAoaW5zdHJ1Y3Rpb25bMV0pO1xuICAgIGNvbnRleHQubGluZVdpZHRoID0gLyoqIEB0eXBlIHtudW1iZXJ9ICovIChpbnN0cnVjdGlvblsyXSk7XG4gICAgY29udGV4dC5saW5lQ2FwID0gLyoqIEB0eXBlIHtDYW52YXNMaW5lQ2FwfSAqLyAoaW5zdHJ1Y3Rpb25bM10pO1xuICAgIGNvbnRleHQubGluZUpvaW4gPSAvKiogQHR5cGUge0NhbnZhc0xpbmVKb2lufSAqLyAoaW5zdHJ1Y3Rpb25bNF0pO1xuICAgIGNvbnRleHQubWl0ZXJMaW1pdCA9IC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAoaW5zdHJ1Y3Rpb25bNV0pO1xuICAgIGNvbnRleHQubGluZURhc2hPZmZzZXQgPSAvKiogQHR5cGUge251bWJlcn0gKi8gKGluc3RydWN0aW9uWzddKTtcbiAgICBjb250ZXh0LnNldExpbmVEYXNoKC8qKiBAdHlwZSB7QXJyYXk8bnVtYmVyPn0gKi8gKGluc3RydWN0aW9uWzZdKSk7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd8QXJyYXk8c3RyaW5nPn0gdGV4dCBUaGUgdGV4dCB0byBkcmF3LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dEtleSBUaGUga2V5IG9mIHRoZSB0ZXh0IHN0YXRlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3Ryb2tlS2V5IFRoZSBrZXkgZm9yIHRoZSBzdHJva2Ugc3RhdGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmaWxsS2V5IFRoZSBrZXkgZm9yIHRoZSBmaWxsIHN0YXRlLlxuICAgKiBAcmV0dXJuIHt7bGFiZWw6IGltcG9ydChcIi4uL2NhbnZhcy5qc1wiKS5MYWJlbCwgYW5jaG9yWDogbnVtYmVyLCBhbmNob3JZOiBudW1iZXJ9fSBUaGUgdGV4dCBpbWFnZSBhbmQgaXRzIGFuY2hvci5cbiAgICovXG4gIGRyYXdMYWJlbFdpdGhQb2ludFBsYWNlbWVudF8odGV4dCwgdGV4dEtleSwgc3Ryb2tlS2V5LCBmaWxsS2V5KSB7XG4gICAgY29uc3QgdGV4dFN0YXRlID0gdGhpcy50ZXh0U3RhdGVzW3RleHRLZXldO1xuXG4gICAgY29uc3QgbGFiZWwgPSB0aGlzLmNyZWF0ZUxhYmVsKHRleHQsIHRleHRLZXksIGZpbGxLZXksIHN0cm9rZUtleSk7XG5cbiAgICBjb25zdCBzdHJva2VTdGF0ZSA9IHRoaXMuc3Ryb2tlU3RhdGVzW3N0cm9rZUtleV07XG4gICAgY29uc3QgcGl4ZWxSYXRpbyA9IHRoaXMucGl4ZWxSYXRpbztcbiAgICBjb25zdCBhbGlnbiA9IGhvcml6b250YWxUZXh0QWxpZ24oXG4gICAgICBBcnJheS5pc0FycmF5KHRleHQpID8gdGV4dFswXSA6IHRleHQsXG4gICAgICB0ZXh0U3RhdGUudGV4dEFsaWduIHx8IGRlZmF1bHRUZXh0QWxpZ25cbiAgICApO1xuICAgIGNvbnN0IGJhc2VsaW5lID0gVEVYVF9BTElHTlt0ZXh0U3RhdGUudGV4dEJhc2VsaW5lIHx8IGRlZmF1bHRUZXh0QmFzZWxpbmVdO1xuICAgIGNvbnN0IHN0cm9rZVdpZHRoID1cbiAgICAgIHN0cm9rZVN0YXRlICYmIHN0cm9rZVN0YXRlLmxpbmVXaWR0aCA/IHN0cm9rZVN0YXRlLmxpbmVXaWR0aCA6IDA7XG5cbiAgICAvLyBSZW1vdmUgdGhlIDIgcGl4ZWxzIHdlIGFkZGVkIGluIGNyZWF0ZUxhYmVsKCkgZm9yIHRoZSBhbmNob3JcbiAgICBjb25zdCB3aWR0aCA9IGxhYmVsLndpZHRoIC8gcGl4ZWxSYXRpbyAtIDIgKiB0ZXh0U3RhdGUuc2NhbGVbMF07XG4gICAgY29uc3QgYW5jaG9yWCA9IGFsaWduICogd2lkdGggKyAyICogKDAuNSAtIGFsaWduKSAqIHN0cm9rZVdpZHRoO1xuICAgIGNvbnN0IGFuY2hvclkgPVxuICAgICAgKGJhc2VsaW5lICogbGFiZWwuaGVpZ2h0KSAvIHBpeGVsUmF0aW8gK1xuICAgICAgMiAqICgwLjUgLSBiYXNlbGluZSkgKiBzdHJva2VXaWR0aDtcblxuICAgIHJldHVybiB7XG4gICAgICBsYWJlbDogbGFiZWwsXG4gICAgICBhbmNob3JYOiBhbmNob3JYLFxuICAgICAgYW5jaG9yWTogYW5jaG9yWSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjb250ZXh0IENvbnRleHQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjb250ZXh0U2NhbGUgU2NhbGUgb2YgdGhlIGNvbnRleHQuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vdHJhbnNmb3JtLmpzXCIpLlRyYW5zZm9ybX0gdHJhbnNmb3JtIFRyYW5zZm9ybS5cbiAgICogQHBhcmFtIHtBcnJheTwqPn0gaW5zdHJ1Y3Rpb25zIEluc3RydWN0aW9ucyBhcnJheS5cbiAgICogQHBhcmFtIHtib29sZWFufSBzbmFwVG9QaXhlbCBTbmFwIHBvaW50IHN5bWJvbHMgYW5kIHRleHQgdG8gaW50ZWdlciBwaXhlbHMuXG4gICAqIEBwYXJhbSB7RmVhdHVyZUNhbGxiYWNrPFQ+fSBbZmVhdHVyZUNhbGxiYWNrXSBGZWF0dXJlIGNhbGxiYWNrLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IFtoaXRFeHRlbnRdIE9ubHkgY2hlY2tcbiAgICogICAgIGZlYXR1cmVzIHRoYXQgaW50ZXJzZWN0IHRoaXMgZXh0ZW50LlxuICAgKiBAcGFyYW0ge2ltcG9ydChcInJidXNoXCIpLmRlZmF1bHR9IFtkZWNsdXR0ZXJUcmVlXSBEZWNsdXR0ZXIgdHJlZS5cbiAgICogQHJldHVybiB7VHx1bmRlZmluZWR9IENhbGxiYWNrIHJlc3VsdC5cbiAgICogQHRlbXBsYXRlIFRcbiAgICovXG4gIGV4ZWN1dGVfKFxuICAgIGNvbnRleHQsXG4gICAgY29udGV4dFNjYWxlLFxuICAgIHRyYW5zZm9ybSxcbiAgICBpbnN0cnVjdGlvbnMsXG4gICAgc25hcFRvUGl4ZWwsXG4gICAgZmVhdHVyZUNhbGxiYWNrLFxuICAgIGhpdEV4dGVudCxcbiAgICBkZWNsdXR0ZXJUcmVlXG4gICkge1xuICAgIC8qKiBAdHlwZSB7QXJyYXk8bnVtYmVyPn0gKi9cbiAgICBsZXQgcGl4ZWxDb29yZGluYXRlcztcbiAgICBpZiAodGhpcy5waXhlbENvb3JkaW5hdGVzXyAmJiBlcXVhbHModHJhbnNmb3JtLCB0aGlzLnJlbmRlcmVkVHJhbnNmb3JtXykpIHtcbiAgICAgIHBpeGVsQ29vcmRpbmF0ZXMgPSB0aGlzLnBpeGVsQ29vcmRpbmF0ZXNfO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIXRoaXMucGl4ZWxDb29yZGluYXRlc18pIHtcbiAgICAgICAgdGhpcy5waXhlbENvb3JkaW5hdGVzXyA9IFtdO1xuICAgICAgfVxuICAgICAgcGl4ZWxDb29yZGluYXRlcyA9IHRyYW5zZm9ybTJEKFxuICAgICAgICB0aGlzLmNvb3JkaW5hdGVzLFxuICAgICAgICAwLFxuICAgICAgICB0aGlzLmNvb3JkaW5hdGVzLmxlbmd0aCxcbiAgICAgICAgMixcbiAgICAgICAgdHJhbnNmb3JtLFxuICAgICAgICB0aGlzLnBpeGVsQ29vcmRpbmF0ZXNfXG4gICAgICApO1xuICAgICAgdHJhbnNmb3JtU2V0RnJvbUFycmF5KHRoaXMucmVuZGVyZWRUcmFuc2Zvcm1fLCB0cmFuc2Zvcm0pO1xuICAgIH1cbiAgICBsZXQgaSA9IDA7IC8vIGluc3RydWN0aW9uIGluZGV4XG4gICAgY29uc3QgaWkgPSBpbnN0cnVjdGlvbnMubGVuZ3RoOyAvLyBlbmQgb2YgaW5zdHJ1Y3Rpb25zXG4gICAgbGV0IGQgPSAwOyAvLyBkYXRhIGluZGV4XG4gICAgbGV0IGRkOyAvLyBlbmQgb2YgcGVyLWluc3RydWN0aW9uIGRhdGFcbiAgICBsZXQgYW5jaG9yWCxcbiAgICAgIGFuY2hvclksXG4gICAgICBwcmV2WCxcbiAgICAgIHByZXZZLFxuICAgICAgcm91bmRYLFxuICAgICAgcm91bmRZLFxuICAgICAgaW1hZ2UsXG4gICAgICB0ZXh0LFxuICAgICAgdGV4dEtleSxcbiAgICAgIHN0cm9rZUtleSxcbiAgICAgIGZpbGxLZXk7XG4gICAgbGV0IHBlbmRpbmdGaWxsID0gMDtcbiAgICBsZXQgcGVuZGluZ1N0cm9rZSA9IDA7XG4gICAgbGV0IGxhc3RGaWxsSW5zdHJ1Y3Rpb24gPSBudWxsO1xuICAgIGxldCBsYXN0U3Ryb2tlSW5zdHJ1Y3Rpb24gPSBudWxsO1xuICAgIGNvbnN0IGNvb3JkaW5hdGVDYWNoZSA9IHRoaXMuY29vcmRpbmF0ZUNhY2hlXztcbiAgICBjb25zdCB2aWV3Um90YXRpb24gPSB0aGlzLnZpZXdSb3RhdGlvbl87XG4gICAgY29uc3Qgdmlld1JvdGF0aW9uRnJvbVRyYW5zZm9ybSA9XG4gICAgICBNYXRoLnJvdW5kKE1hdGguYXRhbjIoLXRyYW5zZm9ybVsxXSwgdHJhbnNmb3JtWzBdKSAqIDFlMTIpIC8gMWUxMjtcblxuICAgIGNvbnN0IHN0YXRlID0gLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi9yZW5kZXIuanNcIikuU3RhdGV9ICovICh7XG4gICAgICBjb250ZXh0OiBjb250ZXh0LFxuICAgICAgcGl4ZWxSYXRpbzogdGhpcy5waXhlbFJhdGlvLFxuICAgICAgcmVzb2x1dGlvbjogdGhpcy5yZXNvbHV0aW9uLFxuICAgICAgcm90YXRpb246IHZpZXdSb3RhdGlvbixcbiAgICB9KTtcblxuICAgIC8vIFdoZW4gdGhlIGJhdGNoIHNpemUgZ2V0cyB0b28gYmlnLCBwZXJmb3JtYW5jZSBkZWNyZWFzZXMuIDIwMCBpcyBhIGdvb2RcbiAgICAvLyBiYWxhbmNlIGJldHdlZW4gYmF0Y2ggc2l6ZSBhbmQgbnVtYmVyIG9mIGZpbGwvc3Ryb2tlIGluc3RydWN0aW9ucy5cbiAgICBjb25zdCBiYXRjaFNpemUgPVxuICAgICAgdGhpcy5pbnN0cnVjdGlvbnMgIT0gaW5zdHJ1Y3Rpb25zIHx8IHRoaXMub3ZlcmxhcHMgPyAwIDogMjAwO1xuICAgIGxldCAvKiogQHR5cGUge2ltcG9ydChcIi4uLy4uL0ZlYXR1cmUuanNcIikuRmVhdHVyZUxpa2V9ICovIGZlYXR1cmU7XG4gICAgbGV0IHgsIHksIGN1cnJlbnRHZW9tZXRyeTtcbiAgICB3aGlsZSAoaSA8IGlpKSB7XG4gICAgICBjb25zdCBpbnN0cnVjdGlvbiA9IGluc3RydWN0aW9uc1tpXTtcbiAgICAgIGNvbnN0IHR5cGUgPSAvKiogQHR5cGUge2ltcG9ydChcIi4vSW5zdHJ1Y3Rpb24uanNcIikuZGVmYXVsdH0gKi8gKFxuICAgICAgICBpbnN0cnVjdGlvblswXVxuICAgICAgKTtcbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIENhbnZhc0luc3RydWN0aW9uLkJFR0lOX0dFT01FVFJZOlxuICAgICAgICAgIGZlYXR1cmUgPSAvKiogQHR5cGUge2ltcG9ydChcIi4uLy4uL0ZlYXR1cmUuanNcIikuRmVhdHVyZUxpa2V9ICovIChcbiAgICAgICAgICAgIGluc3RydWN0aW9uWzFdXG4gICAgICAgICAgKTtcbiAgICAgICAgICBjdXJyZW50R2VvbWV0cnkgPSBpbnN0cnVjdGlvblszXTtcbiAgICAgICAgICBpZiAoIWZlYXR1cmUuZ2V0R2VvbWV0cnkoKSkge1xuICAgICAgICAgICAgaSA9IC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAoaW5zdHJ1Y3Rpb25bMl0pO1xuICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICBoaXRFeHRlbnQgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgIWludGVyc2VjdHMoaGl0RXh0ZW50LCBjdXJyZW50R2VvbWV0cnkuZ2V0RXh0ZW50KCkpXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBpID0gLyoqIEB0eXBlIHtudW1iZXJ9ICovIChpbnN0cnVjdGlvblsyXSkgKyAxO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICArK2k7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIENhbnZhc0luc3RydWN0aW9uLkJFR0lOX1BBVEg6XG4gICAgICAgICAgaWYgKHBlbmRpbmdGaWxsID4gYmF0Y2hTaXplKSB7XG4gICAgICAgICAgICB0aGlzLmZpbGxfKGNvbnRleHQpO1xuICAgICAgICAgICAgcGVuZGluZ0ZpbGwgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocGVuZGluZ1N0cm9rZSA+IGJhdGNoU2l6ZSkge1xuICAgICAgICAgICAgY29udGV4dC5zdHJva2UoKTtcbiAgICAgICAgICAgIHBlbmRpbmdTdHJva2UgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXBlbmRpbmdGaWxsICYmICFwZW5kaW5nU3Ryb2tlKSB7XG4gICAgICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgcHJldlggPSBOYU47XG4gICAgICAgICAgICBwcmV2WSA9IE5hTjtcbiAgICAgICAgICB9XG4gICAgICAgICAgKytpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIENhbnZhc0luc3RydWN0aW9uLkNJUkNMRTpcbiAgICAgICAgICBkID0gLyoqIEB0eXBlIHtudW1iZXJ9ICovIChpbnN0cnVjdGlvblsxXSk7XG4gICAgICAgICAgY29uc3QgeDEgPSBwaXhlbENvb3JkaW5hdGVzW2RdO1xuICAgICAgICAgIGNvbnN0IHkxID0gcGl4ZWxDb29yZGluYXRlc1tkICsgMV07XG4gICAgICAgICAgY29uc3QgeDIgPSBwaXhlbENvb3JkaW5hdGVzW2QgKyAyXTtcbiAgICAgICAgICBjb25zdCB5MiA9IHBpeGVsQ29vcmRpbmF0ZXNbZCArIDNdO1xuICAgICAgICAgIGNvbnN0IGR4ID0geDIgLSB4MTtcbiAgICAgICAgICBjb25zdCBkeSA9IHkyIC0geTE7XG4gICAgICAgICAgY29uc3QgciA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgICAgICAgY29udGV4dC5tb3ZlVG8oeDEgKyByLCB5MSk7XG4gICAgICAgICAgY29udGV4dC5hcmMoeDEsIHkxLCByLCAwLCAyICogTWF0aC5QSSwgdHJ1ZSk7XG4gICAgICAgICAgKytpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIENhbnZhc0luc3RydWN0aW9uLkNMT1NFX1BBVEg6XG4gICAgICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICArK2k7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgQ2FudmFzSW5zdHJ1Y3Rpb24uQ1VTVE9NOlxuICAgICAgICAgIGQgPSAvKiogQHR5cGUge251bWJlcn0gKi8gKGluc3RydWN0aW9uWzFdKTtcbiAgICAgICAgICBkZCA9IGluc3RydWN0aW9uWzJdO1xuICAgICAgICAgIGNvbnN0IGdlb21ldHJ5ID1cbiAgICAgICAgICAgIC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vZ2VvbS9TaW1wbGVHZW9tZXRyeS5qc1wiKS5kZWZhdWx0fSAqLyAoXG4gICAgICAgICAgICAgIGluc3RydWN0aW9uWzNdXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGNvbnN0IHJlbmRlcmVyID0gaW5zdHJ1Y3Rpb25bNF07XG4gICAgICAgICAgY29uc3QgZm4gPSBpbnN0cnVjdGlvbi5sZW5ndGggPT0gNiA/IGluc3RydWN0aW9uWzVdIDogdW5kZWZpbmVkO1xuICAgICAgICAgIHN0YXRlLmdlb21ldHJ5ID0gZ2VvbWV0cnk7XG4gICAgICAgICAgc3RhdGUuZmVhdHVyZSA9IGZlYXR1cmU7XG4gICAgICAgICAgaWYgKCEoaSBpbiBjb29yZGluYXRlQ2FjaGUpKSB7XG4gICAgICAgICAgICBjb29yZGluYXRlQ2FjaGVbaV0gPSBbXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgY29vcmRzID0gY29vcmRpbmF0ZUNhY2hlW2ldO1xuICAgICAgICAgIGlmIChmbikge1xuICAgICAgICAgICAgZm4ocGl4ZWxDb29yZGluYXRlcywgZCwgZGQsIDIsIGNvb3Jkcyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvb3Jkc1swXSA9IHBpeGVsQ29vcmRpbmF0ZXNbZF07XG4gICAgICAgICAgICBjb29yZHNbMV0gPSBwaXhlbENvb3JkaW5hdGVzW2QgKyAxXTtcbiAgICAgICAgICAgIGNvb3Jkcy5sZW5ndGggPSAyO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZW5kZXJlcihjb29yZHMsIHN0YXRlKTtcbiAgICAgICAgICArK2k7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgQ2FudmFzSW5zdHJ1Y3Rpb24uRFJBV19JTUFHRTpcbiAgICAgICAgICBkID0gLyoqIEB0eXBlIHtudW1iZXJ9ICovIChpbnN0cnVjdGlvblsxXSk7XG4gICAgICAgICAgZGQgPSAvKiogQHR5cGUge251bWJlcn0gKi8gKGluc3RydWN0aW9uWzJdKTtcbiAgICAgICAgICBpbWFnZSA9XG4gICAgICAgICAgICAvKiogQHR5cGUge0hUTUxDYW52YXNFbGVtZW50fEhUTUxWaWRlb0VsZW1lbnR8SFRNTEltYWdlRWxlbWVudH0gKi8gKFxuICAgICAgICAgICAgICBpbnN0cnVjdGlvblszXVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgIC8vIFJlbWFpbmluZyBhcmd1bWVudHMgaW4gRFJBV19JTUFHRSBhcmUgaW4gYWxwaGFiZXRpY2FsIG9yZGVyXG4gICAgICAgICAgYW5jaG9yWCA9IC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAoaW5zdHJ1Y3Rpb25bNF0pO1xuICAgICAgICAgIGFuY2hvclkgPSAvKiogQHR5cGUge251bWJlcn0gKi8gKGluc3RydWN0aW9uWzVdKTtcbiAgICAgICAgICBsZXQgaGVpZ2h0ID0gLyoqIEB0eXBlIHtudW1iZXJ9ICovIChpbnN0cnVjdGlvbls2XSk7XG4gICAgICAgICAgY29uc3Qgb3BhY2l0eSA9IC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAoaW5zdHJ1Y3Rpb25bN10pO1xuICAgICAgICAgIGNvbnN0IG9yaWdpblggPSAvKiogQHR5cGUge251bWJlcn0gKi8gKGluc3RydWN0aW9uWzhdKTtcbiAgICAgICAgICBjb25zdCBvcmlnaW5ZID0gLyoqIEB0eXBlIHtudW1iZXJ9ICovIChpbnN0cnVjdGlvbls5XSk7XG4gICAgICAgICAgY29uc3Qgcm90YXRlV2l0aFZpZXcgPSAvKiogQHR5cGUge2Jvb2xlYW59ICovIChpbnN0cnVjdGlvblsxMF0pO1xuICAgICAgICAgIGxldCByb3RhdGlvbiA9IC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAoaW5zdHJ1Y3Rpb25bMTFdKTtcbiAgICAgICAgICBjb25zdCBzY2FsZSA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vc2l6ZS5qc1wiKS5TaXplfSAqLyAoXG4gICAgICAgICAgICBpbnN0cnVjdGlvblsxMl1cbiAgICAgICAgICApO1xuICAgICAgICAgIGxldCB3aWR0aCA9IC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAoaW5zdHJ1Y3Rpb25bMTNdKTtcbiAgICAgICAgICBjb25zdCBkZWNsdXR0ZXJNb2RlID1cbiAgICAgICAgICAgIC8qKiBAdHlwZSB7XCJkZWNsdXR0ZXJcInxcIm9ic3RhY2xlXCJ8XCJub25lXCJ8dW5kZWZpbmVkfSAqLyAoXG4gICAgICAgICAgICAgIGluc3RydWN0aW9uWzE0XVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBjb25zdCBkZWNsdXR0ZXJJbWFnZVdpdGhUZXh0ID1cbiAgICAgICAgICAgIC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vY2FudmFzLmpzXCIpLkRlY2x1dHRlckltYWdlV2l0aFRleHR9ICovIChcbiAgICAgICAgICAgICAgaW5zdHJ1Y3Rpb25bMTVdXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgaWYgKCFpbWFnZSAmJiBpbnN0cnVjdGlvbi5sZW5ndGggPj0gMjApIHtcbiAgICAgICAgICAgIC8vIGNyZWF0ZSBsYWJlbCBpbWFnZXNcbiAgICAgICAgICAgIHRleHQgPSAvKiogQHR5cGUge3N0cmluZ30gKi8gKGluc3RydWN0aW9uWzE5XSk7XG4gICAgICAgICAgICB0ZXh0S2V5ID0gLyoqIEB0eXBlIHtzdHJpbmd9ICovIChpbnN0cnVjdGlvblsyMF0pO1xuICAgICAgICAgICAgc3Ryb2tlS2V5ID0gLyoqIEB0eXBlIHtzdHJpbmd9ICovIChpbnN0cnVjdGlvblsyMV0pO1xuICAgICAgICAgICAgZmlsbEtleSA9IC8qKiBAdHlwZSB7c3RyaW5nfSAqLyAoaW5zdHJ1Y3Rpb25bMjJdKTtcbiAgICAgICAgICAgIGNvbnN0IGxhYmVsV2l0aEFuY2hvciA9IHRoaXMuZHJhd0xhYmVsV2l0aFBvaW50UGxhY2VtZW50XyhcbiAgICAgICAgICAgICAgdGV4dCxcbiAgICAgICAgICAgICAgdGV4dEtleSxcbiAgICAgICAgICAgICAgc3Ryb2tlS2V5LFxuICAgICAgICAgICAgICBmaWxsS2V5XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaW1hZ2UgPSBsYWJlbFdpdGhBbmNob3IubGFiZWw7XG4gICAgICAgICAgICBpbnN0cnVjdGlvblszXSA9IGltYWdlO1xuICAgICAgICAgICAgY29uc3QgdGV4dE9mZnNldFggPSAvKiogQHR5cGUge251bWJlcn0gKi8gKGluc3RydWN0aW9uWzIzXSk7XG4gICAgICAgICAgICBhbmNob3JYID0gKGxhYmVsV2l0aEFuY2hvci5hbmNob3JYIC0gdGV4dE9mZnNldFgpICogdGhpcy5waXhlbFJhdGlvO1xuICAgICAgICAgICAgaW5zdHJ1Y3Rpb25bNF0gPSBhbmNob3JYO1xuICAgICAgICAgICAgY29uc3QgdGV4dE9mZnNldFkgPSAvKiogQHR5cGUge251bWJlcn0gKi8gKGluc3RydWN0aW9uWzI0XSk7XG4gICAgICAgICAgICBhbmNob3JZID0gKGxhYmVsV2l0aEFuY2hvci5hbmNob3JZIC0gdGV4dE9mZnNldFkpICogdGhpcy5waXhlbFJhdGlvO1xuICAgICAgICAgICAgaW5zdHJ1Y3Rpb25bNV0gPSBhbmNob3JZO1xuICAgICAgICAgICAgaGVpZ2h0ID0gaW1hZ2UuaGVpZ2h0O1xuICAgICAgICAgICAgaW5zdHJ1Y3Rpb25bNl0gPSBoZWlnaHQ7XG4gICAgICAgICAgICB3aWR0aCA9IGltYWdlLndpZHRoO1xuICAgICAgICAgICAgaW5zdHJ1Y3Rpb25bMTNdID0gd2lkdGg7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGV0IGdlb21ldHJ5V2lkdGhzO1xuICAgICAgICAgIGlmIChpbnN0cnVjdGlvbi5sZW5ndGggPiAyNSkge1xuICAgICAgICAgICAgZ2VvbWV0cnlXaWR0aHMgPSAvKiogQHR5cGUge251bWJlcn0gKi8gKGluc3RydWN0aW9uWzI1XSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGV0IHBhZGRpbmcsIGJhY2tncm91bmRGaWxsLCBiYWNrZ3JvdW5kU3Ryb2tlO1xuICAgICAgICAgIGlmIChpbnN0cnVjdGlvbi5sZW5ndGggPiAxNykge1xuICAgICAgICAgICAgcGFkZGluZyA9IC8qKiBAdHlwZSB7QXJyYXk8bnVtYmVyPn0gKi8gKGluc3RydWN0aW9uWzE2XSk7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kRmlsbCA9IC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi8gKGluc3RydWN0aW9uWzE3XSk7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kU3Ryb2tlID0gLyoqIEB0eXBlIHtib29sZWFufSAqLyAoaW5zdHJ1Y3Rpb25bMThdKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGFkZGluZyA9IGRlZmF1bHRQYWRkaW5nO1xuICAgICAgICAgICAgYmFja2dyb3VuZEZpbGwgPSBmYWxzZTtcbiAgICAgICAgICAgIGJhY2tncm91bmRTdHJva2UgPSBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocm90YXRlV2l0aFZpZXcgJiYgdmlld1JvdGF0aW9uRnJvbVRyYW5zZm9ybSkge1xuICAgICAgICAgICAgLy8gQ2FudmFzIGlzIGV4cGVjdGVkIHRvIGJlIHJvdGF0ZWQgdG8gcmV2ZXJzZSB2aWV3IHJvdGF0aW9uLlxuICAgICAgICAgICAgcm90YXRpb24gKz0gdmlld1JvdGF0aW9uO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIXJvdGF0ZVdpdGhWaWV3ICYmICF2aWV3Um90YXRpb25Gcm9tVHJhbnNmb3JtKSB7XG4gICAgICAgICAgICAvLyBDYW52YXMgaXMgbm90IHJvdGF0ZWQsIGltYWdlcyBuZWVkIHRvIGJlIHJvdGF0ZWQgYmFjayB0byBiZSBub3J0aC11cC5cbiAgICAgICAgICAgIHJvdGF0aW9uIC09IHZpZXdSb3RhdGlvbjtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGV0IHdpZHRoSW5kZXggPSAwO1xuICAgICAgICAgIGZvciAoOyBkIDwgZGQ7IGQgKz0gMikge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBnZW9tZXRyeVdpZHRocyAmJlxuICAgICAgICAgICAgICBnZW9tZXRyeVdpZHRoc1t3aWR0aEluZGV4KytdIDwgd2lkdGggLyB0aGlzLnBpeGVsUmF0aW9cbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGRpbWVuc2lvbnMgPSB0aGlzLmNhbGN1bGF0ZUltYWdlT3JMYWJlbERpbWVuc2lvbnNfKFxuICAgICAgICAgICAgICBpbWFnZS53aWR0aCxcbiAgICAgICAgICAgICAgaW1hZ2UuaGVpZ2h0LFxuICAgICAgICAgICAgICBwaXhlbENvb3JkaW5hdGVzW2RdLFxuICAgICAgICAgICAgICBwaXhlbENvb3JkaW5hdGVzW2QgKyAxXSxcbiAgICAgICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgICAgIGhlaWdodCxcbiAgICAgICAgICAgICAgYW5jaG9yWCxcbiAgICAgICAgICAgICAgYW5jaG9yWSxcbiAgICAgICAgICAgICAgb3JpZ2luWCxcbiAgICAgICAgICAgICAgb3JpZ2luWSxcbiAgICAgICAgICAgICAgcm90YXRpb24sXG4gICAgICAgICAgICAgIHNjYWxlLFxuICAgICAgICAgICAgICBzbmFwVG9QaXhlbCxcbiAgICAgICAgICAgICAgcGFkZGluZyxcbiAgICAgICAgICAgICAgYmFja2dyb3VuZEZpbGwgfHwgYmFja2dyb3VuZFN0cm9rZSxcbiAgICAgICAgICAgICAgZmVhdHVyZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7UmVwbGF5SW1hZ2VPckxhYmVsQXJnc30gKi9cbiAgICAgICAgICAgIGNvbnN0IGFyZ3MgPSBbXG4gICAgICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgICAgIGNvbnRleHRTY2FsZSxcbiAgICAgICAgICAgICAgaW1hZ2UsXG4gICAgICAgICAgICAgIGRpbWVuc2lvbnMsXG4gICAgICAgICAgICAgIG9wYWNpdHksXG4gICAgICAgICAgICAgIGJhY2tncm91bmRGaWxsXG4gICAgICAgICAgICAgICAgPyAvKiogQHR5cGUge0FycmF5PCo+fSAqLyAobGFzdEZpbGxJbnN0cnVjdGlvbilcbiAgICAgICAgICAgICAgICA6IG51bGwsXG4gICAgICAgICAgICAgIGJhY2tncm91bmRTdHJva2VcbiAgICAgICAgICAgICAgICA/IC8qKiBAdHlwZSB7QXJyYXk8Kj59ICovIChsYXN0U3Ryb2tlSW5zdHJ1Y3Rpb24pXG4gICAgICAgICAgICAgICAgOiBudWxsLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIGlmIChkZWNsdXR0ZXJUcmVlKSB7XG4gICAgICAgICAgICAgIGlmIChkZWNsdXR0ZXJNb2RlID09PSAnbm9uZScpIHtcbiAgICAgICAgICAgICAgICAvLyBub3QgcmVuZGVyZWQgaW4gZGVjbHV0dGVyIGdyb3VwXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoZGVjbHV0dGVyTW9kZSA9PT0gJ29ic3RhY2xlJykge1xuICAgICAgICAgICAgICAgIC8vIHdpbGwgYWx3YXlzIGJlIGRyYXduLCB0aHVzIG5vIGNvbGxpc2lvbiBkZXRlY3Rpb24sIGJ1dCBpbnNlcnQgYXMgb2JzdGFjbGVcbiAgICAgICAgICAgICAgICBkZWNsdXR0ZXJUcmVlLmluc2VydChkaW1lbnNpb25zLmRlY2x1dHRlckJveCk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IGltYWdlQXJncztcbiAgICAgICAgICAgICAgICBsZXQgaW1hZ2VEZWNsdXR0ZXJCb3g7XG4gICAgICAgICAgICAgICAgaWYgKGRlY2x1dHRlckltYWdlV2l0aFRleHQpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gZGQgLSBkO1xuICAgICAgICAgICAgICAgICAgaWYgKCFkZWNsdXR0ZXJJbWFnZVdpdGhUZXh0W2luZGV4XSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSBub3cgaGF2ZSB0aGUgaW1hZ2UgZm9yIGFuIGltYWdlK3RleHQgY29tYmluYXRpb24uXG4gICAgICAgICAgICAgICAgICAgIGRlY2x1dHRlckltYWdlV2l0aFRleHRbaW5kZXhdID0gYXJncztcbiAgICAgICAgICAgICAgICAgICAgLy8gRG9uJ3QgcmVuZGVyIGFueXRoaW5nIGZvciBub3csIHdhaXQgZm9yIHRoZSB0ZXh0LlxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGltYWdlQXJncyA9IGRlY2x1dHRlckltYWdlV2l0aFRleHRbaW5kZXhdO1xuICAgICAgICAgICAgICAgICAgZGVsZXRlIGRlY2x1dHRlckltYWdlV2l0aFRleHRbaW5kZXhdO1xuICAgICAgICAgICAgICAgICAgaW1hZ2VEZWNsdXR0ZXJCb3ggPSBnZXREZWNsdXR0ZXJCb3goaW1hZ2VBcmdzKTtcbiAgICAgICAgICAgICAgICAgIGlmIChkZWNsdXR0ZXJUcmVlLmNvbGxpZGVzKGltYWdlRGVjbHV0dGVyQm94KSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGRlY2x1dHRlclRyZWUuY29sbGlkZXMoZGltZW5zaW9ucy5kZWNsdXR0ZXJCb3gpKSB7XG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGltYWdlQXJncykge1xuICAgICAgICAgICAgICAgICAgLy8gV2Ugbm93IGhhdmUgaW1hZ2UgYW5kIHRleHQgZm9yIGFuIGltYWdlK3RleHQgY29tYmluYXRpb24uXG4gICAgICAgICAgICAgICAgICBkZWNsdXR0ZXJUcmVlLmluc2VydChpbWFnZURlY2x1dHRlckJveCk7XG4gICAgICAgICAgICAgICAgICAvLyBSZW5kZXIgdGhlIGltYWdlIGJlZm9yZSB3ZSByZW5kZXIgdGhlIHRleHQuXG4gICAgICAgICAgICAgICAgICB0aGlzLnJlcGxheUltYWdlT3JMYWJlbF8uYXBwbHkodGhpcywgaW1hZ2VBcmdzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVjbHV0dGVyVHJlZS5pbnNlcnQoZGltZW5zaW9ucy5kZWNsdXR0ZXJCb3gpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnJlcGxheUltYWdlT3JMYWJlbF8uYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgICAgfVxuICAgICAgICAgICsraTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBDYW52YXNJbnN0cnVjdGlvbi5EUkFXX0NIQVJTOlxuICAgICAgICAgIGNvbnN0IGJlZ2luID0gLyoqIEB0eXBlIHtudW1iZXJ9ICovIChpbnN0cnVjdGlvblsxXSk7XG4gICAgICAgICAgY29uc3QgZW5kID0gLyoqIEB0eXBlIHtudW1iZXJ9ICovIChpbnN0cnVjdGlvblsyXSk7XG4gICAgICAgICAgY29uc3QgYmFzZWxpbmUgPSAvKiogQHR5cGUge251bWJlcn0gKi8gKGluc3RydWN0aW9uWzNdKTtcbiAgICAgICAgICBjb25zdCBvdmVyZmxvdyA9IC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAoaW5zdHJ1Y3Rpb25bNF0pO1xuICAgICAgICAgIGZpbGxLZXkgPSAvKiogQHR5cGUge3N0cmluZ30gKi8gKGluc3RydWN0aW9uWzVdKTtcbiAgICAgICAgICBjb25zdCBtYXhBbmdsZSA9IC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAoaW5zdHJ1Y3Rpb25bNl0pO1xuICAgICAgICAgIGNvbnN0IG1lYXN1cmVQaXhlbFJhdGlvID0gLyoqIEB0eXBlIHtudW1iZXJ9ICovIChpbnN0cnVjdGlvbls3XSk7XG4gICAgICAgICAgY29uc3Qgb2Zmc2V0WSA9IC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAoaW5zdHJ1Y3Rpb25bOF0pO1xuICAgICAgICAgIHN0cm9rZUtleSA9IC8qKiBAdHlwZSB7c3RyaW5nfSAqLyAoaW5zdHJ1Y3Rpb25bOV0pO1xuICAgICAgICAgIGNvbnN0IHN0cm9rZVdpZHRoID0gLyoqIEB0eXBlIHtudW1iZXJ9ICovIChpbnN0cnVjdGlvblsxMF0pO1xuICAgICAgICAgIHRleHQgPSAvKiogQHR5cGUge3N0cmluZ30gKi8gKGluc3RydWN0aW9uWzExXSk7XG4gICAgICAgICAgdGV4dEtleSA9IC8qKiBAdHlwZSB7c3RyaW5nfSAqLyAoaW5zdHJ1Y3Rpb25bMTJdKTtcbiAgICAgICAgICBjb25zdCBwaXhlbFJhdGlvU2NhbGUgPSBbXG4gICAgICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi8gKGluc3RydWN0aW9uWzEzXSksXG4gICAgICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi8gKGluc3RydWN0aW9uWzEzXSksXG4gICAgICAgICAgXTtcblxuICAgICAgICAgIGNvbnN0IHRleHRTdGF0ZSA9IHRoaXMudGV4dFN0YXRlc1t0ZXh0S2V5XTtcbiAgICAgICAgICBjb25zdCBmb250ID0gdGV4dFN0YXRlLmZvbnQ7XG4gICAgICAgICAgY29uc3QgdGV4dFNjYWxlID0gW1xuICAgICAgICAgICAgdGV4dFN0YXRlLnNjYWxlWzBdICogbWVhc3VyZVBpeGVsUmF0aW8sXG4gICAgICAgICAgICB0ZXh0U3RhdGUuc2NhbGVbMV0gKiBtZWFzdXJlUGl4ZWxSYXRpbyxcbiAgICAgICAgICBdO1xuXG4gICAgICAgICAgbGV0IGNhY2hlZFdpZHRocztcbiAgICAgICAgICBpZiAoZm9udCBpbiB0aGlzLndpZHRoc18pIHtcbiAgICAgICAgICAgIGNhY2hlZFdpZHRocyA9IHRoaXMud2lkdGhzX1tmb250XTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkV2lkdGhzID0ge307XG4gICAgICAgICAgICB0aGlzLndpZHRoc19bZm9udF0gPSBjYWNoZWRXaWR0aHM7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgcGF0aExlbmd0aCA9IGxpbmVTdHJpbmdMZW5ndGgocGl4ZWxDb29yZGluYXRlcywgYmVnaW4sIGVuZCwgMik7XG4gICAgICAgICAgY29uc3QgdGV4dExlbmd0aCA9XG4gICAgICAgICAgICBNYXRoLmFicyh0ZXh0U2NhbGVbMF0pICpcbiAgICAgICAgICAgIG1lYXN1cmVBbmRDYWNoZVRleHRXaWR0aChmb250LCB0ZXh0LCBjYWNoZWRXaWR0aHMpO1xuICAgICAgICAgIGlmIChvdmVyZmxvdyB8fCB0ZXh0TGVuZ3RoIDw9IHBhdGhMZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IHRleHRBbGlnbiA9IHRoaXMudGV4dFN0YXRlc1t0ZXh0S2V5XS50ZXh0QWxpZ247XG4gICAgICAgICAgICBjb25zdCBzdGFydE0gPVxuICAgICAgICAgICAgICAocGF0aExlbmd0aCAtIHRleHRMZW5ndGgpICogaG9yaXpvbnRhbFRleHRBbGlnbih0ZXh0LCB0ZXh0QWxpZ24pO1xuICAgICAgICAgICAgY29uc3QgcGFydHMgPSBkcmF3VGV4dE9uUGF0aChcbiAgICAgICAgICAgICAgcGl4ZWxDb29yZGluYXRlcyxcbiAgICAgICAgICAgICAgYmVnaW4sXG4gICAgICAgICAgICAgIGVuZCxcbiAgICAgICAgICAgICAgMixcbiAgICAgICAgICAgICAgdGV4dCxcbiAgICAgICAgICAgICAgc3RhcnRNLFxuICAgICAgICAgICAgICBtYXhBbmdsZSxcbiAgICAgICAgICAgICAgTWF0aC5hYnModGV4dFNjYWxlWzBdKSxcbiAgICAgICAgICAgICAgbWVhc3VyZUFuZENhY2hlVGV4dFdpZHRoLFxuICAgICAgICAgICAgICBmb250LFxuICAgICAgICAgICAgICBjYWNoZWRXaWR0aHMsXG4gICAgICAgICAgICAgIHZpZXdSb3RhdGlvbkZyb21UcmFuc2Zvcm0gPyAwIDogdGhpcy52aWV3Um90YXRpb25fXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgZHJhd0NoYXJzOiBpZiAocGFydHMpIHtcbiAgICAgICAgICAgICAgLyoqIEB0eXBlIHtBcnJheTxSZXBsYXlJbWFnZU9yTGFiZWxBcmdzPn0gKi9cbiAgICAgICAgICAgICAgY29uc3QgcmVwbGF5SW1hZ2VPckxhYmVsQXJncyA9IFtdO1xuICAgICAgICAgICAgICBsZXQgYywgY2MsIGNoYXJzLCBsYWJlbCwgcGFydDtcbiAgICAgICAgICAgICAgaWYgKHN0cm9rZUtleSkge1xuICAgICAgICAgICAgICAgIGZvciAoYyA9IDAsIGNjID0gcGFydHMubGVuZ3RoOyBjIDwgY2M7ICsrYykge1xuICAgICAgICAgICAgICAgICAgcGFydCA9IHBhcnRzW2NdOyAvLyB4LCB5LCBhbmNob3JYLCByb3RhdGlvbiwgY2h1bmtcbiAgICAgICAgICAgICAgICAgIGNoYXJzID0gLyoqIEB0eXBlIHtzdHJpbmd9ICovIChwYXJ0WzRdKTtcbiAgICAgICAgICAgICAgICAgIGxhYmVsID0gdGhpcy5jcmVhdGVMYWJlbChjaGFycywgdGV4dEtleSwgJycsIHN0cm9rZUtleSk7XG4gICAgICAgICAgICAgICAgICBhbmNob3JYID1cbiAgICAgICAgICAgICAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovIChwYXJ0WzJdKSArXG4gICAgICAgICAgICAgICAgICAgICh0ZXh0U2NhbGVbMF0gPCAwID8gLXN0cm9rZVdpZHRoIDogc3Ryb2tlV2lkdGgpO1xuICAgICAgICAgICAgICAgICAgYW5jaG9yWSA9XG4gICAgICAgICAgICAgICAgICAgIGJhc2VsaW5lICogbGFiZWwuaGVpZ2h0ICtcbiAgICAgICAgICAgICAgICAgICAgKCgwLjUgLSBiYXNlbGluZSkgKiAyICogc3Ryb2tlV2lkdGggKiB0ZXh0U2NhbGVbMV0pIC9cbiAgICAgICAgICAgICAgICAgICAgICB0ZXh0U2NhbGVbMF0gLVxuICAgICAgICAgICAgICAgICAgICBvZmZzZXRZO1xuICAgICAgICAgICAgICAgICAgY29uc3QgZGltZW5zaW9ucyA9IHRoaXMuY2FsY3VsYXRlSW1hZ2VPckxhYmVsRGltZW5zaW9uc18oXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsLndpZHRoLFxuICAgICAgICAgICAgICAgICAgICBsYWJlbC5oZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgIHBhcnRbMF0sXG4gICAgICAgICAgICAgICAgICAgIHBhcnRbMV0sXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsLndpZHRoLFxuICAgICAgICAgICAgICAgICAgICBsYWJlbC5oZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgIGFuY2hvclgsXG4gICAgICAgICAgICAgICAgICAgIGFuY2hvclksXG4gICAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICAgIHBhcnRbM10sXG4gICAgICAgICAgICAgICAgICAgIHBpeGVsUmF0aW9TY2FsZSxcbiAgICAgICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHRQYWRkaW5nLFxuICAgICAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgZmVhdHVyZVxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgZGVjbHV0dGVyVHJlZSAmJlxuICAgICAgICAgICAgICAgICAgICBkZWNsdXR0ZXJUcmVlLmNvbGxpZGVzKGRpbWVuc2lvbnMuZGVjbHV0dGVyQm94KVxuICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrIGRyYXdDaGFycztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHJlcGxheUltYWdlT3JMYWJlbEFyZ3MucHVzaChbXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHRTY2FsZSxcbiAgICAgICAgICAgICAgICAgICAgbGFiZWwsXG4gICAgICAgICAgICAgICAgICAgIGRpbWVuc2lvbnMsXG4gICAgICAgICAgICAgICAgICAgIDEsXG4gICAgICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGZpbGxLZXkpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGMgPSAwLCBjYyA9IHBhcnRzLmxlbmd0aDsgYyA8IGNjOyArK2MpIHtcbiAgICAgICAgICAgICAgICAgIHBhcnQgPSBwYXJ0c1tjXTsgLy8geCwgeSwgYW5jaG9yWCwgcm90YXRpb24sIGNodW5rXG4gICAgICAgICAgICAgICAgICBjaGFycyA9IC8qKiBAdHlwZSB7c3RyaW5nfSAqLyAocGFydFs0XSk7XG4gICAgICAgICAgICAgICAgICBsYWJlbCA9IHRoaXMuY3JlYXRlTGFiZWwoY2hhcnMsIHRleHRLZXksIGZpbGxLZXksICcnKTtcbiAgICAgICAgICAgICAgICAgIGFuY2hvclggPSAvKiogQHR5cGUge251bWJlcn0gKi8gKHBhcnRbMl0pO1xuICAgICAgICAgICAgICAgICAgYW5jaG9yWSA9IGJhc2VsaW5lICogbGFiZWwuaGVpZ2h0IC0gb2Zmc2V0WTtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGRpbWVuc2lvbnMgPSB0aGlzLmNhbGN1bGF0ZUltYWdlT3JMYWJlbERpbWVuc2lvbnNfKFxuICAgICAgICAgICAgICAgICAgICBsYWJlbC53aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgbGFiZWwuaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICBwYXJ0WzBdLFxuICAgICAgICAgICAgICAgICAgICBwYXJ0WzFdLFxuICAgICAgICAgICAgICAgICAgICBsYWJlbC53aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgbGFiZWwuaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICBhbmNob3JYLFxuICAgICAgICAgICAgICAgICAgICBhbmNob3JZLFxuICAgICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgICBwYXJ0WzNdLFxuICAgICAgICAgICAgICAgICAgICBwaXhlbFJhdGlvU2NhbGUsXG4gICAgICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0UGFkZGluZyxcbiAgICAgICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGZlYXR1cmVcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgIGRlY2x1dHRlclRyZWUgJiZcbiAgICAgICAgICAgICAgICAgICAgZGVjbHV0dGVyVHJlZS5jb2xsaWRlcyhkaW1lbnNpb25zLmRlY2x1dHRlckJveClcbiAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICBicmVhayBkcmF3Q2hhcnM7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICByZXBsYXlJbWFnZU9yTGFiZWxBcmdzLnB1c2goW1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0U2NhbGUsXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsLFxuICAgICAgICAgICAgICAgICAgICBkaW1lbnNpb25zLFxuICAgICAgICAgICAgICAgICAgICAxLFxuICAgICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChkZWNsdXR0ZXJUcmVlKSB7XG4gICAgICAgICAgICAgICAgZGVjbHV0dGVyVHJlZS5sb2FkKHJlcGxheUltYWdlT3JMYWJlbEFyZ3MubWFwKGdldERlY2x1dHRlckJveCkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IHJlcGxheUltYWdlT3JMYWJlbEFyZ3MubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVwbGF5SW1hZ2VPckxhYmVsXy5hcHBseSh0aGlzLCByZXBsYXlJbWFnZU9yTGFiZWxBcmdzW2ldKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICArK2k7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgQ2FudmFzSW5zdHJ1Y3Rpb24uRU5EX0dFT01FVFJZOlxuICAgICAgICAgIGlmIChmZWF0dXJlQ2FsbGJhY2sgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZmVhdHVyZSA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vRmVhdHVyZS5qc1wiKS5GZWF0dXJlTGlrZX0gKi8gKFxuICAgICAgICAgICAgICBpbnN0cnVjdGlvblsxXVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGZlYXR1cmVDYWxsYmFjayhmZWF0dXJlLCBjdXJyZW50R2VvbWV0cnkpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICArK2k7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgQ2FudmFzSW5zdHJ1Y3Rpb24uRklMTDpcbiAgICAgICAgICBpZiAoYmF0Y2hTaXplKSB7XG4gICAgICAgICAgICBwZW5kaW5nRmlsbCsrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmZpbGxfKGNvbnRleHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICArK2k7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgQ2FudmFzSW5zdHJ1Y3Rpb24uTU9WRV9UT19MSU5FX1RPOlxuICAgICAgICAgIGQgPSAvKiogQHR5cGUge251bWJlcn0gKi8gKGluc3RydWN0aW9uWzFdKTtcbiAgICAgICAgICBkZCA9IC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAoaW5zdHJ1Y3Rpb25bMl0pO1xuICAgICAgICAgIHggPSBwaXhlbENvb3JkaW5hdGVzW2RdO1xuICAgICAgICAgIHkgPSBwaXhlbENvb3JkaW5hdGVzW2QgKyAxXTtcbiAgICAgICAgICByb3VuZFggPSAoeCArIDAuNSkgfCAwO1xuICAgICAgICAgIHJvdW5kWSA9ICh5ICsgMC41KSB8IDA7XG4gICAgICAgICAgaWYgKHJvdW5kWCAhPT0gcHJldlggfHwgcm91bmRZICE9PSBwcmV2WSkge1xuICAgICAgICAgICAgY29udGV4dC5tb3ZlVG8oeCwgeSk7XG4gICAgICAgICAgICBwcmV2WCA9IHJvdW5kWDtcbiAgICAgICAgICAgIHByZXZZID0gcm91bmRZO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKGQgKz0gMjsgZCA8IGRkOyBkICs9IDIpIHtcbiAgICAgICAgICAgIHggPSBwaXhlbENvb3JkaW5hdGVzW2RdO1xuICAgICAgICAgICAgeSA9IHBpeGVsQ29vcmRpbmF0ZXNbZCArIDFdO1xuICAgICAgICAgICAgcm91bmRYID0gKHggKyAwLjUpIHwgMDtcbiAgICAgICAgICAgIHJvdW5kWSA9ICh5ICsgMC41KSB8IDA7XG4gICAgICAgICAgICBpZiAoZCA9PSBkZCAtIDIgfHwgcm91bmRYICE9PSBwcmV2WCB8fCByb3VuZFkgIT09IHByZXZZKSB7XG4gICAgICAgICAgICAgIGNvbnRleHQubGluZVRvKHgsIHkpO1xuICAgICAgICAgICAgICBwcmV2WCA9IHJvdW5kWDtcbiAgICAgICAgICAgICAgcHJldlkgPSByb3VuZFk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgICsraTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBDYW52YXNJbnN0cnVjdGlvbi5TRVRfRklMTF9TVFlMRTpcbiAgICAgICAgICBsYXN0RmlsbEluc3RydWN0aW9uID0gaW5zdHJ1Y3Rpb247XG4gICAgICAgICAgdGhpcy5hbGlnbkZpbGxfID0gaW5zdHJ1Y3Rpb25bMl07XG5cbiAgICAgICAgICBpZiAocGVuZGluZ0ZpbGwpIHtcbiAgICAgICAgICAgIHRoaXMuZmlsbF8oY29udGV4dCk7XG4gICAgICAgICAgICBwZW5kaW5nRmlsbCA9IDA7XG4gICAgICAgICAgICBpZiAocGVuZGluZ1N0cm9rZSkge1xuICAgICAgICAgICAgICBjb250ZXh0LnN0cm9rZSgpO1xuICAgICAgICAgICAgICBwZW5kaW5nU3Ryb2tlID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9XG4gICAgICAgICAgICAvKiogQHR5cGUge2ltcG9ydChcIi4uLy4uL2NvbG9ybGlrZS5qc1wiKS5Db2xvckxpa2V9ICovIChcbiAgICAgICAgICAgICAgaW5zdHJ1Y3Rpb25bMV1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgKytpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIENhbnZhc0luc3RydWN0aW9uLlNFVF9TVFJPS0VfU1RZTEU6XG4gICAgICAgICAgbGFzdFN0cm9rZUluc3RydWN0aW9uID0gaW5zdHJ1Y3Rpb247XG4gICAgICAgICAgaWYgKHBlbmRpbmdTdHJva2UpIHtcbiAgICAgICAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gICAgICAgICAgICBwZW5kaW5nU3Ryb2tlID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5zZXRTdHJva2VTdHlsZV8oY29udGV4dCwgLyoqIEB0eXBlIHtBcnJheTwqPn0gKi8gKGluc3RydWN0aW9uKSk7XG4gICAgICAgICAgKytpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIENhbnZhc0luc3RydWN0aW9uLlNUUk9LRTpcbiAgICAgICAgICBpZiAoYmF0Y2hTaXplKSB7XG4gICAgICAgICAgICBwZW5kaW5nU3Ryb2tlKys7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgICsraTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDogLy8gY29uc3VtZSB0aGUgaW5zdHJ1Y3Rpb24gYW55d2F5LCB0byBhdm9pZCBhbiBpbmZpbml0ZSBsb29wXG4gICAgICAgICAgKytpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocGVuZGluZ0ZpbGwpIHtcbiAgICAgIHRoaXMuZmlsbF8oY29udGV4dCk7XG4gICAgfVxuICAgIGlmIChwZW5kaW5nU3Ryb2tlKSB7XG4gICAgICBjb250ZXh0LnN0cm9rZSgpO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjb250ZXh0IENvbnRleHQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjb250ZXh0U2NhbGUgU2NhbGUgb2YgdGhlIGNvbnRleHQuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vdHJhbnNmb3JtLmpzXCIpLlRyYW5zZm9ybX0gdHJhbnNmb3JtIFRyYW5zZm9ybS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHZpZXdSb3RhdGlvbiBWaWV3IHJvdGF0aW9uLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNuYXBUb1BpeGVsIFNuYXAgcG9pbnQgc3ltYm9scyBhbmQgdGV4dCB0byBpbnRlZ2VyIHBpeGVscy5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCJyYnVzaFwiKS5kZWZhdWx0fSBbZGVjbHV0dGVyVHJlZV0gRGVjbHV0dGVyIHRyZWUuXG4gICAqL1xuICBleGVjdXRlKFxuICAgIGNvbnRleHQsXG4gICAgY29udGV4dFNjYWxlLFxuICAgIHRyYW5zZm9ybSxcbiAgICB2aWV3Um90YXRpb24sXG4gICAgc25hcFRvUGl4ZWwsXG4gICAgZGVjbHV0dGVyVHJlZVxuICApIHtcbiAgICB0aGlzLnZpZXdSb3RhdGlvbl8gPSB2aWV3Um90YXRpb247XG4gICAgdGhpcy5leGVjdXRlXyhcbiAgICAgIGNvbnRleHQsXG4gICAgICBjb250ZXh0U2NhbGUsXG4gICAgICB0cmFuc2Zvcm0sXG4gICAgICB0aGlzLmluc3RydWN0aW9ucyxcbiAgICAgIHNuYXBUb1BpeGVsLFxuICAgICAgdW5kZWZpbmVkLFxuICAgICAgdW5kZWZpbmVkLFxuICAgICAgZGVjbHV0dGVyVHJlZVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHQgQ29udGV4dC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi90cmFuc2Zvcm0uanNcIikuVHJhbnNmb3JtfSB0cmFuc2Zvcm0gVHJhbnNmb3JtLlxuICAgKiBAcGFyYW0ge251bWJlcn0gdmlld1JvdGF0aW9uIFZpZXcgcm90YXRpb24uXG4gICAqIEBwYXJhbSB7RmVhdHVyZUNhbGxiYWNrPFQ+fSBbZmVhdHVyZUNhbGxiYWNrXSBGZWF0dXJlIGNhbGxiYWNrLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IFtoaXRFeHRlbnRdIE9ubHkgY2hlY2tcbiAgICogICAgIGZlYXR1cmVzIHRoYXQgaW50ZXJzZWN0IHRoaXMgZXh0ZW50LlxuICAgKiBAcmV0dXJuIHtUfHVuZGVmaW5lZH0gQ2FsbGJhY2sgcmVzdWx0LlxuICAgKiBAdGVtcGxhdGUgVFxuICAgKi9cbiAgZXhlY3V0ZUhpdERldGVjdGlvbihcbiAgICBjb250ZXh0LFxuICAgIHRyYW5zZm9ybSxcbiAgICB2aWV3Um90YXRpb24sXG4gICAgZmVhdHVyZUNhbGxiYWNrLFxuICAgIGhpdEV4dGVudFxuICApIHtcbiAgICB0aGlzLnZpZXdSb3RhdGlvbl8gPSB2aWV3Um90YXRpb247XG4gICAgcmV0dXJuIHRoaXMuZXhlY3V0ZV8oXG4gICAgICBjb250ZXh0LFxuICAgICAgMSxcbiAgICAgIHRyYW5zZm9ybSxcbiAgICAgIHRoaXMuaGl0RGV0ZWN0aW9uSW5zdHJ1Y3Rpb25zLFxuICAgICAgdHJ1ZSxcbiAgICAgIGZlYXR1cmVDYWxsYmFjayxcbiAgICAgIGhpdEV4dGVudFxuICAgICk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgRXhlY3V0b3I7XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvcmVuZGVyL2NhbnZhcy9FeGVjdXRvckdyb3VwXG4gKi9cblxuaW1wb3J0IEV4ZWN1dG9yIGZyb20gJy4vRXhlY3V0b3IuanMnO1xuaW1wb3J0IHthc2NlbmRpbmd9IGZyb20gJy4uLy4uL2FycmF5LmpzJztcbmltcG9ydCB7YnVmZmVyLCBjcmVhdGVFbXB0eSwgZXh0ZW5kQ29vcmRpbmF0ZX0gZnJvbSAnLi4vLi4vZXh0ZW50LmpzJztcbmltcG9ydCB7XG4gIGNvbXBvc2UgYXMgY29tcG9zZVRyYW5zZm9ybSxcbiAgY3JlYXRlIGFzIGNyZWF0ZVRyYW5zZm9ybSxcbn0gZnJvbSAnLi4vLi4vdHJhbnNmb3JtLmpzJztcbmltcG9ydCB7Y3JlYXRlQ2FudmFzQ29udGV4dDJEfSBmcm9tICcuLi8uLi9kb20uanMnO1xuaW1wb3J0IHtpc0VtcHR5fSBmcm9tICcuLi8uLi9vYmouanMnO1xuaW1wb3J0IHt0cmFuc2Zvcm0yRH0gZnJvbSAnLi4vLi4vZ2VvbS9mbGF0L3RyYW5zZm9ybS5qcyc7XG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7QXJyYXk8aW1wb3J0KFwiLi4vY2FudmFzLmpzXCIpLkJ1aWxkZXJUeXBlPn1cbiAqL1xuY29uc3QgT1JERVIgPSBbJ1BvbHlnb24nLCAnQ2lyY2xlJywgJ0xpbmVTdHJpbmcnLCAnSW1hZ2UnLCAnVGV4dCcsICdEZWZhdWx0J107XG5cbmNsYXNzIEV4ZWN1dG9yR3JvdXAge1xuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9leHRlbnQuanNcIikuRXh0ZW50fSBtYXhFeHRlbnQgTWF4IGV4dGVudCBmb3IgY2xpcHBpbmcuIFdoZW4gYVxuICAgKiBgbWF4RXh0ZW50YCB3YXMgc2V0IG9uIHRoZSBCdWlsZGVyIGZvciB0aGlzIGV4ZWN1dG9yIGdyb3VwLCB0aGUgc2FtZSBgbWF4RXh0ZW50YFxuICAgKiBzaG91bGQgYmUgc2V0IGhlcmUsIHVubGVzcyB0aGUgdGFyZ2V0IGNvbnRleHQgZG9lcyBub3QgZXhjZWVkIHRoYXQgZXh0ZW50ICh3aGljaFxuICAgKiBjYW4gYmUgdGhlIGNhc2Ugd2hlbiByZW5kZXJpbmcgdG8gdGlsZXMpLlxuICAgKiBAcGFyYW0ge251bWJlcn0gcmVzb2x1dGlvbiBSZXNvbHV0aW9uLlxuICAgKiBAcGFyYW0ge251bWJlcn0gcGl4ZWxSYXRpbyBQaXhlbCByYXRpby5cbiAgICogQHBhcmFtIHtib29sZWFufSBvdmVybGFwcyBUaGUgZXhlY3V0b3IgZ3JvdXAgY2FuIGhhdmUgb3ZlcmxhcHBpbmcgZ2VvbWV0cmllcy5cbiAgICogQHBhcmFtIHshT2JqZWN0PHN0cmluZywgIU9iamVjdDxpbXBvcnQoXCIuLi9jYW52YXMuanNcIikuQnVpbGRlclR5cGUsIGltcG9ydChcIi4uL2NhbnZhcy5qc1wiKS5TZXJpYWxpemFibGVJbnN0cnVjdGlvbnM+Pn0gYWxsSW5zdHJ1Y3Rpb25zXG4gICAqIFRoZSBzZXJpYWxpemFibGUgaW5zdHJ1Y3Rpb25zLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW3JlbmRlckJ1ZmZlcl0gT3B0aW9uYWwgcmVuZGVyaW5nIGJ1ZmZlci5cbiAgICovXG4gIGNvbnN0cnVjdG9yKFxuICAgIG1heEV4dGVudCxcbiAgICByZXNvbHV0aW9uLFxuICAgIHBpeGVsUmF0aW8sXG4gICAgb3ZlcmxhcHMsXG4gICAgYWxsSW5zdHJ1Y3Rpb25zLFxuICAgIHJlbmRlckJ1ZmZlclxuICApIHtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi9leHRlbnQuanNcIikuRXh0ZW50fVxuICAgICAqL1xuICAgIHRoaXMubWF4RXh0ZW50XyA9IG1heEV4dGVudDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5vdmVybGFwc18gPSBvdmVybGFwcztcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnBpeGVsUmF0aW9fID0gcGl4ZWxSYXRpbztcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnJlc29sdXRpb25fID0gcmVzb2x1dGlvbjtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcnx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5yZW5kZXJCdWZmZXJfID0gcmVuZGVyQnVmZmVyO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7IU9iamVjdDxzdHJpbmcsICFPYmplY3Q8aW1wb3J0KFwiLi4vY2FudmFzLmpzXCIpLkJ1aWxkZXJUeXBlLCBpbXBvcnQoXCIuL0V4ZWN1dG9yXCIpLmRlZmF1bHQ+Pn1cbiAgICAgKi9cbiAgICB0aGlzLmV4ZWN1dG9yc0J5WkluZGV4XyA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfVxuICAgICAqL1xuICAgIHRoaXMuaGl0RGV0ZWN0aW9uQ29udGV4dF8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vdHJhbnNmb3JtLmpzXCIpLlRyYW5zZm9ybX1cbiAgICAgKi9cbiAgICB0aGlzLmhpdERldGVjdGlvblRyYW5zZm9ybV8gPSBjcmVhdGVUcmFuc2Zvcm0oKTtcblxuICAgIHRoaXMuY3JlYXRlRXhlY3V0b3JzXyhhbGxJbnN0cnVjdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjb250ZXh0IENvbnRleHQuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vdHJhbnNmb3JtLmpzXCIpLlRyYW5zZm9ybX0gdHJhbnNmb3JtIFRyYW5zZm9ybS5cbiAgICovXG4gIGNsaXAoY29udGV4dCwgdHJhbnNmb3JtKSB7XG4gICAgY29uc3QgZmxhdENsaXBDb29yZHMgPSB0aGlzLmdldENsaXBDb29yZHModHJhbnNmb3JtKTtcbiAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgIGNvbnRleHQubW92ZVRvKGZsYXRDbGlwQ29vcmRzWzBdLCBmbGF0Q2xpcENvb3Jkc1sxXSk7XG4gICAgY29udGV4dC5saW5lVG8oZmxhdENsaXBDb29yZHNbMl0sIGZsYXRDbGlwQ29vcmRzWzNdKTtcbiAgICBjb250ZXh0LmxpbmVUbyhmbGF0Q2xpcENvb3Jkc1s0XSwgZmxhdENsaXBDb29yZHNbNV0pO1xuICAgIGNvbnRleHQubGluZVRvKGZsYXRDbGlwQ29vcmRzWzZdLCBmbGF0Q2xpcENvb3Jkc1s3XSk7XG4gICAgY29udGV4dC5jbGlwKCk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGV4ZWN1dG9ycyBhbmQgcG9wdWxhdGUgdGhlbSB1c2luZyB0aGUgcHJvdmlkZWQgaW5zdHJ1Y3Rpb25zLlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0geyFPYmplY3Q8c3RyaW5nLCAhT2JqZWN0PGltcG9ydChcIi4uL2NhbnZhcy5qc1wiKS5CdWlsZGVyVHlwZSwgaW1wb3J0KFwiLi4vY2FudmFzLmpzXCIpLlNlcmlhbGl6YWJsZUluc3RydWN0aW9ucz4+fSBhbGxJbnN0cnVjdGlvbnMgVGhlIHNlcmlhbGl6YWJsZSBpbnN0cnVjdGlvbnNcbiAgICovXG4gIGNyZWF0ZUV4ZWN1dG9yc18oYWxsSW5zdHJ1Y3Rpb25zKSB7XG4gICAgZm9yIChjb25zdCB6SW5kZXggaW4gYWxsSW5zdHJ1Y3Rpb25zKSB7XG4gICAgICBsZXQgZXhlY3V0b3JzID0gdGhpcy5leGVjdXRvcnNCeVpJbmRleF9bekluZGV4XTtcbiAgICAgIGlmIChleGVjdXRvcnMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBleGVjdXRvcnMgPSB7fTtcbiAgICAgICAgdGhpcy5leGVjdXRvcnNCeVpJbmRleF9bekluZGV4XSA9IGV4ZWN1dG9ycztcbiAgICAgIH1cbiAgICAgIGNvbnN0IGluc3RydWN0aW9uQnlaaW5kZXggPSBhbGxJbnN0cnVjdGlvbnNbekluZGV4XTtcbiAgICAgIGZvciAoY29uc3QgYnVpbGRlclR5cGUgaW4gaW5zdHJ1Y3Rpb25CeVppbmRleCkge1xuICAgICAgICBjb25zdCBpbnN0cnVjdGlvbnMgPSBpbnN0cnVjdGlvbkJ5WmluZGV4W2J1aWxkZXJUeXBlXTtcbiAgICAgICAgZXhlY3V0b3JzW2J1aWxkZXJUeXBlXSA9IG5ldyBFeGVjdXRvcihcbiAgICAgICAgICB0aGlzLnJlc29sdXRpb25fLFxuICAgICAgICAgIHRoaXMucGl4ZWxSYXRpb18sXG4gICAgICAgICAgdGhpcy5vdmVybGFwc18sXG4gICAgICAgICAgaW5zdHJ1Y3Rpb25zXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7QXJyYXk8aW1wb3J0KFwiLi4vY2FudmFzLmpzXCIpLkJ1aWxkZXJUeXBlPn0gZXhlY3V0b3JzIEV4ZWN1dG9ycy5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gSGFzIGV4ZWN1dG9ycyBvZiB0aGUgcHJvdmlkZWQgdHlwZXMuXG4gICAqL1xuICBoYXNFeGVjdXRvcnMoZXhlY3V0b3JzKSB7XG4gICAgZm9yIChjb25zdCB6SW5kZXggaW4gdGhpcy5leGVjdXRvcnNCeVpJbmRleF8pIHtcbiAgICAgIGNvbnN0IGNhbmRpZGF0ZXMgPSB0aGlzLmV4ZWN1dG9yc0J5WkluZGV4X1t6SW5kZXhdO1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gZXhlY3V0b3JzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgaWYgKGV4ZWN1dG9yc1tpXSBpbiBjYW5kaWRhdGVzKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBjb29yZGluYXRlIENvb3JkaW5hdGUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSByZXNvbHV0aW9uIFJlc29sdXRpb24uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSByb3RhdGlvbiBSb3RhdGlvbi5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGhpdFRvbGVyYW5jZSBIaXQgdG9sZXJhbmNlIGluIHBpeGVscy5cbiAgICogQHBhcmFtIHtmdW5jdGlvbihpbXBvcnQoXCIuLi8uLi9GZWF0dXJlLmpzXCIpLkZlYXR1cmVMaWtlLCBpbXBvcnQoXCIuLi8uLi9nZW9tL1NpbXBsZUdlb21ldHJ5LmpzXCIpLmRlZmF1bHQsIG51bWJlcik6IFR9IGNhbGxiYWNrIEZlYXR1cmUgY2FsbGJhY2suXG4gICAqIEBwYXJhbSB7QXJyYXk8aW1wb3J0KFwiLi4vLi4vRmVhdHVyZS5qc1wiKS5GZWF0dXJlTGlrZT59IGRlY2x1dHRlcmVkRmVhdHVyZXMgRGVjbHV0dGVyZWQgZmVhdHVyZXMuXG4gICAqIEByZXR1cm4ge1R8dW5kZWZpbmVkfSBDYWxsYmFjayByZXN1bHQuXG4gICAqIEB0ZW1wbGF0ZSBUXG4gICAqL1xuICBmb3JFYWNoRmVhdHVyZUF0Q29vcmRpbmF0ZShcbiAgICBjb29yZGluYXRlLFxuICAgIHJlc29sdXRpb24sXG4gICAgcm90YXRpb24sXG4gICAgaGl0VG9sZXJhbmNlLFxuICAgIGNhbGxiYWNrLFxuICAgIGRlY2x1dHRlcmVkRmVhdHVyZXNcbiAgKSB7XG4gICAgaGl0VG9sZXJhbmNlID0gTWF0aC5yb3VuZChoaXRUb2xlcmFuY2UpO1xuICAgIGNvbnN0IGNvbnRleHRTaXplID0gaGl0VG9sZXJhbmNlICogMiArIDE7XG4gICAgY29uc3QgdHJhbnNmb3JtID0gY29tcG9zZVRyYW5zZm9ybShcbiAgICAgIHRoaXMuaGl0RGV0ZWN0aW9uVHJhbnNmb3JtXyxcbiAgICAgIGhpdFRvbGVyYW5jZSArIDAuNSxcbiAgICAgIGhpdFRvbGVyYW5jZSArIDAuNSxcbiAgICAgIDEgLyByZXNvbHV0aW9uLFxuICAgICAgLTEgLyByZXNvbHV0aW9uLFxuICAgICAgLXJvdGF0aW9uLFxuICAgICAgLWNvb3JkaW5hdGVbMF0sXG4gICAgICAtY29vcmRpbmF0ZVsxXVxuICAgICk7XG5cbiAgICBjb25zdCBuZXdDb250ZXh0ID0gIXRoaXMuaGl0RGV0ZWN0aW9uQ29udGV4dF87XG4gICAgaWYgKG5ld0NvbnRleHQpIHtcbiAgICAgIHRoaXMuaGl0RGV0ZWN0aW9uQ29udGV4dF8gPSBjcmVhdGVDYW52YXNDb250ZXh0MkQoXG4gICAgICAgIGNvbnRleHRTaXplLFxuICAgICAgICBjb250ZXh0U2l6ZSxcbiAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICB7d2lsbFJlYWRGcmVxdWVudGx5OiB0cnVlfVxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3QgY29udGV4dCA9IHRoaXMuaGl0RGV0ZWN0aW9uQ29udGV4dF87XG5cbiAgICBpZiAoXG4gICAgICBjb250ZXh0LmNhbnZhcy53aWR0aCAhPT0gY29udGV4dFNpemUgfHxcbiAgICAgIGNvbnRleHQuY2FudmFzLmhlaWdodCAhPT0gY29udGV4dFNpemVcbiAgICApIHtcbiAgICAgIGNvbnRleHQuY2FudmFzLndpZHRoID0gY29udGV4dFNpemU7XG4gICAgICBjb250ZXh0LmNhbnZhcy5oZWlnaHQgPSBjb250ZXh0U2l6ZTtcbiAgICB9IGVsc2UgaWYgKCFuZXdDb250ZXh0KSB7XG4gICAgICBjb250ZXh0LmNsZWFyUmVjdCgwLCAwLCBjb250ZXh0U2l6ZSwgY29udGV4dFNpemUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi9leHRlbnQuanNcIikuRXh0ZW50fVxuICAgICAqL1xuICAgIGxldCBoaXRFeHRlbnQ7XG4gICAgaWYgKHRoaXMucmVuZGVyQnVmZmVyXyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBoaXRFeHRlbnQgPSBjcmVhdGVFbXB0eSgpO1xuICAgICAgZXh0ZW5kQ29vcmRpbmF0ZShoaXRFeHRlbnQsIGNvb3JkaW5hdGUpO1xuICAgICAgYnVmZmVyKFxuICAgICAgICBoaXRFeHRlbnQsXG4gICAgICAgIHJlc29sdXRpb24gKiAodGhpcy5yZW5kZXJCdWZmZXJfICsgaGl0VG9sZXJhbmNlKSxcbiAgICAgICAgaGl0RXh0ZW50XG4gICAgICApO1xuICAgIH1cblxuICAgIGNvbnN0IGluZGV4ZXMgPSBnZXRQaXhlbEluZGV4QXJyYXkoaGl0VG9sZXJhbmNlKTtcblxuICAgIGxldCBidWlsZGVyVHlwZTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vRmVhdHVyZS5qc1wiKS5GZWF0dXJlTGlrZX0gZmVhdHVyZSBGZWF0dXJlLlxuICAgICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vZ2VvbS9TaW1wbGVHZW9tZXRyeS5qc1wiKS5kZWZhdWx0fSBnZW9tZXRyeSBHZW9tZXRyeS5cbiAgICAgKiBAcmV0dXJuIHtUfHVuZGVmaW5lZH0gQ2FsbGJhY2sgcmVzdWx0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZlYXR1cmVDYWxsYmFjayhmZWF0dXJlLCBnZW9tZXRyeSkge1xuICAgICAgY29uc3QgaW1hZ2VEYXRhID0gY29udGV4dC5nZXRJbWFnZURhdGEoXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIGNvbnRleHRTaXplLFxuICAgICAgICBjb250ZXh0U2l6ZVxuICAgICAgKS5kYXRhO1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gaW5kZXhlcy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgIGlmIChpbWFnZURhdGFbaW5kZXhlc1tpXV0gPiAwKSB7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgIWRlY2x1dHRlcmVkRmVhdHVyZXMgfHxcbiAgICAgICAgICAgIChidWlsZGVyVHlwZSAhPT0gJ0ltYWdlJyAmJiBidWlsZGVyVHlwZSAhPT0gJ1RleHQnKSB8fFxuICAgICAgICAgICAgZGVjbHV0dGVyZWRGZWF0dXJlcy5pbmNsdWRlcyhmZWF0dXJlKVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgY29uc3QgaWR4ID0gKGluZGV4ZXNbaV0gLSAzKSAvIDQ7XG4gICAgICAgICAgICBjb25zdCB4ID0gaGl0VG9sZXJhbmNlIC0gKGlkeCAlIGNvbnRleHRTaXplKTtcbiAgICAgICAgICAgIGNvbnN0IHkgPSBoaXRUb2xlcmFuY2UgLSAoKGlkeCAvIGNvbnRleHRTaXplKSB8IDApO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gY2FsbGJhY2soZmVhdHVyZSwgZ2VvbWV0cnksIHggKiB4ICsgeSAqIHkpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb250ZXh0LmNsZWFyUmVjdCgwLCAwLCBjb250ZXh0U2l6ZSwgY29udGV4dFNpemUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKiBAdHlwZSB7QXJyYXk8bnVtYmVyPn0gKi9cbiAgICBjb25zdCB6cyA9IE9iamVjdC5rZXlzKHRoaXMuZXhlY3V0b3JzQnlaSW5kZXhfKS5tYXAoTnVtYmVyKTtcbiAgICB6cy5zb3J0KGFzY2VuZGluZyk7XG5cbiAgICBsZXQgaSwgaiwgZXhlY3V0b3JzLCBleGVjdXRvciwgcmVzdWx0O1xuICAgIGZvciAoaSA9IHpzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICBjb25zdCB6SW5kZXhLZXkgPSB6c1tpXS50b1N0cmluZygpO1xuICAgICAgZXhlY3V0b3JzID0gdGhpcy5leGVjdXRvcnNCeVpJbmRleF9bekluZGV4S2V5XTtcbiAgICAgIGZvciAoaiA9IE9SREVSLmxlbmd0aCAtIDE7IGogPj0gMDsgLS1qKSB7XG4gICAgICAgIGJ1aWxkZXJUeXBlID0gT1JERVJbal07XG4gICAgICAgIGV4ZWN1dG9yID0gZXhlY3V0b3JzW2J1aWxkZXJUeXBlXTtcbiAgICAgICAgaWYgKGV4ZWN1dG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXN1bHQgPSBleGVjdXRvci5leGVjdXRlSGl0RGV0ZWN0aW9uKFxuICAgICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICAgIHRyYW5zZm9ybSxcbiAgICAgICAgICAgIHJvdGF0aW9uLFxuICAgICAgICAgICAgZmVhdHVyZUNhbGxiYWNrLFxuICAgICAgICAgICAgaGl0RXh0ZW50XG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vdHJhbnNmb3JtLmpzXCIpLlRyYW5zZm9ybX0gdHJhbnNmb3JtIFRyYW5zZm9ybS5cbiAgICogQHJldHVybiB7QXJyYXk8bnVtYmVyPnxudWxsfSBDbGlwIGNvb3JkaW5hdGVzLlxuICAgKi9cbiAgZ2V0Q2xpcENvb3Jkcyh0cmFuc2Zvcm0pIHtcbiAgICBjb25zdCBtYXhFeHRlbnQgPSB0aGlzLm1heEV4dGVudF87XG4gICAgaWYgKCFtYXhFeHRlbnQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBtaW5YID0gbWF4RXh0ZW50WzBdO1xuICAgIGNvbnN0IG1pblkgPSBtYXhFeHRlbnRbMV07XG4gICAgY29uc3QgbWF4WCA9IG1heEV4dGVudFsyXTtcbiAgICBjb25zdCBtYXhZID0gbWF4RXh0ZW50WzNdO1xuICAgIGNvbnN0IGZsYXRDbGlwQ29vcmRzID0gW21pblgsIG1pblksIG1pblgsIG1heFksIG1heFgsIG1heFksIG1heFgsIG1pblldO1xuICAgIHRyYW5zZm9ybTJEKGZsYXRDbGlwQ29vcmRzLCAwLCA4LCAyLCB0cmFuc2Zvcm0sIGZsYXRDbGlwQ29vcmRzKTtcbiAgICByZXR1cm4gZmxhdENsaXBDb29yZHM7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gSXMgZW1wdHkuXG4gICAqL1xuICBpc0VtcHR5KCkge1xuICAgIHJldHVybiBpc0VtcHR5KHRoaXMuZXhlY3V0b3JzQnlaSW5kZXhfKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY29udGV4dCBDb250ZXh0LlxuICAgKiBAcGFyYW0ge251bWJlcn0gY29udGV4dFNjYWxlIFNjYWxlIG9mIHRoZSBjb250ZXh0LlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL3RyYW5zZm9ybS5qc1wiKS5UcmFuc2Zvcm19IHRyYW5zZm9ybSBUcmFuc2Zvcm0uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2aWV3Um90YXRpb24gVmlldyByb3RhdGlvbi5cbiAgICogQHBhcmFtIHtib29sZWFufSBzbmFwVG9QaXhlbCBTbmFwIHBvaW50IHN5bWJvbHMgYW5kIHRlc3QgdG8gaW50ZWdlciBwaXhlbC5cbiAgICogQHBhcmFtIHtBcnJheTxpbXBvcnQoXCIuLi9jYW52YXMuanNcIikuQnVpbGRlclR5cGU+fSBbYnVpbGRlclR5cGVzXSBPcmRlcmVkIHJlcGxheSB0eXBlcyB0byByZXBsYXkuXG4gICAqICAgICBEZWZhdWx0IGlzIHtAbGluayBtb2R1bGU6b2wvcmVuZGVyL3JlcGxheX5PUkRFUn1cbiAgICogQHBhcmFtIHtpbXBvcnQoXCJyYnVzaFwiKS5kZWZhdWx0fSBbZGVjbHV0dGVyVHJlZV0gRGVjbHV0dGVyIHRyZWUuXG4gICAqL1xuICBleGVjdXRlKFxuICAgIGNvbnRleHQsXG4gICAgY29udGV4dFNjYWxlLFxuICAgIHRyYW5zZm9ybSxcbiAgICB2aWV3Um90YXRpb24sXG4gICAgc25hcFRvUGl4ZWwsXG4gICAgYnVpbGRlclR5cGVzLFxuICAgIGRlY2x1dHRlclRyZWVcbiAgKSB7XG4gICAgLyoqIEB0eXBlIHtBcnJheTxudW1iZXI+fSAqL1xuICAgIGNvbnN0IHpzID0gT2JqZWN0LmtleXModGhpcy5leGVjdXRvcnNCeVpJbmRleF8pLm1hcChOdW1iZXIpO1xuICAgIHpzLnNvcnQoYXNjZW5kaW5nKTtcblxuICAgIC8vIHNldHVwIGNsaXBwaW5nIHNvIHRoYXQgdGhlIHBhcnRzIG9mIG92ZXItc2ltcGxpZmllZCBnZW9tZXRyaWVzIGFyZSBub3RcbiAgICAvLyB2aXNpYmxlIG91dHNpZGUgdGhlIGN1cnJlbnQgZXh0ZW50IHdoZW4gcGFubmluZ1xuICAgIGlmICh0aGlzLm1heEV4dGVudF8pIHtcbiAgICAgIGNvbnRleHQuc2F2ZSgpO1xuICAgICAgdGhpcy5jbGlwKGNvbnRleHQsIHRyYW5zZm9ybSk7XG4gICAgfVxuXG4gICAgYnVpbGRlclR5cGVzID0gYnVpbGRlclR5cGVzID8gYnVpbGRlclR5cGVzIDogT1JERVI7XG4gICAgbGV0IGksIGlpLCBqLCBqaiwgcmVwbGF5cywgcmVwbGF5O1xuICAgIGlmIChkZWNsdXR0ZXJUcmVlKSB7XG4gICAgICB6cy5yZXZlcnNlKCk7XG4gICAgfVxuICAgIGZvciAoaSA9IDAsIGlpID0genMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgY29uc3QgekluZGV4S2V5ID0genNbaV0udG9TdHJpbmcoKTtcbiAgICAgIHJlcGxheXMgPSB0aGlzLmV4ZWN1dG9yc0J5WkluZGV4X1t6SW5kZXhLZXldO1xuICAgICAgZm9yIChqID0gMCwgamogPSBidWlsZGVyVHlwZXMubGVuZ3RoOyBqIDwgamo7ICsraikge1xuICAgICAgICBjb25zdCBidWlsZGVyVHlwZSA9IGJ1aWxkZXJUeXBlc1tqXTtcbiAgICAgICAgcmVwbGF5ID0gcmVwbGF5c1tidWlsZGVyVHlwZV07XG4gICAgICAgIGlmIChyZXBsYXkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJlcGxheS5leGVjdXRlKFxuICAgICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICAgIGNvbnRleHRTY2FsZSxcbiAgICAgICAgICAgIHRyYW5zZm9ybSxcbiAgICAgICAgICAgIHZpZXdSb3RhdGlvbixcbiAgICAgICAgICAgIHNuYXBUb1BpeGVsLFxuICAgICAgICAgICAgZGVjbHV0dGVyVHJlZVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5tYXhFeHRlbnRfKSB7XG4gICAgICBjb250ZXh0LnJlc3RvcmUoKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBUaGlzIGNhY2hlIGlzIHVzZWQgdG8gc3RvcmUgYXJyYXlzIG9mIGluZGV4ZXMgZm9yIGNhbGN1bGF0ZWQgcGl4ZWwgY2lyY2xlc1xuICogdG8gaW5jcmVhc2UgcGVyZm9ybWFuY2UuXG4gKiBJdCBpcyBhIHN0YXRpYyBwcm9wZXJ0eSB0byBhbGxvdyBlYWNoIFJlcGxheWdyb3VwIHRvIGFjY2VzcyBpdC5cbiAqIEB0eXBlIHtPYmplY3Q8bnVtYmVyLCBBcnJheTxudW1iZXI+Pn1cbiAqL1xuY29uc3QgY2lyY2xlUGl4ZWxJbmRleEFycmF5Q2FjaGUgPSB7fTtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZHMgY3JlYXRlcyBhbiBhcnJheSB3aXRoIGluZGV4ZXMgb2YgYWxsIHBpeGVscyB3aXRoaW4gYSBjaXJjbGUsXG4gKiBvcmRlcmVkIGJ5IGhvdyBjbG9zZSB0aGV5IGFyZSB0byB0aGUgY2VudGVyLlxuICogQSBjYWNoZSBpcyB1c2VkIHRvIGluY3JlYXNlIHBlcmZvcm1hbmNlLlxuICogQHBhcmFtIHtudW1iZXJ9IHJhZGl1cyBSYWRpdXMuXG4gKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBBbiBhcnJheSB3aXRoIGluZGV4ZXMgd2l0aGluIGEgY2lyY2xlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0UGl4ZWxJbmRleEFycmF5KHJhZGl1cykge1xuICBpZiAoY2lyY2xlUGl4ZWxJbmRleEFycmF5Q2FjaGVbcmFkaXVzXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGNpcmNsZVBpeGVsSW5kZXhBcnJheUNhY2hlW3JhZGl1c107XG4gIH1cblxuICBjb25zdCBzaXplID0gcmFkaXVzICogMiArIDE7XG4gIGNvbnN0IG1heERpc3RhbmNlU3EgPSByYWRpdXMgKiByYWRpdXM7XG4gIGNvbnN0IGRpc3RhbmNlcyA9IG5ldyBBcnJheShtYXhEaXN0YW5jZVNxICsgMSk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDw9IHJhZGl1czsgKytpKSB7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPD0gcmFkaXVzOyArK2opIHtcbiAgICAgIGNvbnN0IGRpc3RhbmNlU3EgPSBpICogaSArIGogKiBqO1xuICAgICAgaWYgKGRpc3RhbmNlU3EgPiBtYXhEaXN0YW5jZVNxKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgbGV0IGRpc3RhbmNlID0gZGlzdGFuY2VzW2Rpc3RhbmNlU3FdO1xuICAgICAgaWYgKCFkaXN0YW5jZSkge1xuICAgICAgICBkaXN0YW5jZSA9IFtdO1xuICAgICAgICBkaXN0YW5jZXNbZGlzdGFuY2VTcV0gPSBkaXN0YW5jZTtcbiAgICAgIH1cbiAgICAgIGRpc3RhbmNlLnB1c2goKChyYWRpdXMgKyBpKSAqIHNpemUgKyAocmFkaXVzICsgaikpICogNCArIDMpO1xuICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgIGRpc3RhbmNlLnB1c2goKChyYWRpdXMgLSBpKSAqIHNpemUgKyAocmFkaXVzICsgaikpICogNCArIDMpO1xuICAgICAgfVxuICAgICAgaWYgKGogPiAwKSB7XG4gICAgICAgIGRpc3RhbmNlLnB1c2goKChyYWRpdXMgKyBpKSAqIHNpemUgKyAocmFkaXVzIC0gaikpICogNCArIDMpO1xuICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICBkaXN0YW5jZS5wdXNoKCgocmFkaXVzIC0gaSkgKiBzaXplICsgKHJhZGl1cyAtIGopKSAqIDQgKyAzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHBpeGVsSW5kZXggPSBbXTtcbiAgZm9yIChsZXQgaSA9IDAsIGlpID0gZGlzdGFuY2VzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICBpZiAoZGlzdGFuY2VzW2ldKSB7XG4gICAgICBwaXhlbEluZGV4LnB1c2goLi4uZGlzdGFuY2VzW2ldKTtcbiAgICB9XG4gIH1cblxuICBjaXJjbGVQaXhlbEluZGV4QXJyYXlDYWNoZVtyYWRpdXNdID0gcGl4ZWxJbmRleDtcbiAgcmV0dXJuIHBpeGVsSW5kZXg7XG59XG5cbmV4cG9ydCBkZWZhdWx0IEV4ZWN1dG9yR3JvdXA7XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvcmVuZGVyL2NhbnZhcy9JbWFnZUJ1aWxkZXJcbiAqL1xuaW1wb3J0IENhbnZhc0J1aWxkZXIgZnJvbSAnLi9CdWlsZGVyLmpzJztcbmltcG9ydCBDYW52YXNJbnN0cnVjdGlvbiBmcm9tICcuL0luc3RydWN0aW9uLmpzJztcblxuY2xhc3MgQ2FudmFzSW1hZ2VCdWlsZGVyIGV4dGVuZHMgQ2FudmFzQnVpbGRlciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gdG9sZXJhbmNlIFRvbGVyYW5jZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9leHRlbnQuanNcIikuRXh0ZW50fSBtYXhFeHRlbnQgTWF4aW11bSBleHRlbnQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSByZXNvbHV0aW9uIFJlc29sdXRpb24uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwaXhlbFJhdGlvIFBpeGVsIHJhdGlvLlxuICAgKi9cbiAgY29uc3RydWN0b3IodG9sZXJhbmNlLCBtYXhFeHRlbnQsIHJlc29sdXRpb24sIHBpeGVsUmF0aW8pIHtcbiAgICBzdXBlcih0b2xlcmFuY2UsIG1heEV4dGVudCwgcmVzb2x1dGlvbiwgcGl4ZWxSYXRpbyk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoJy4uLy4uL0RhdGFUaWxlLmpzJykuSW1hZ2VMaWtlfVxuICAgICAqL1xuICAgIHRoaXMuaGl0RGV0ZWN0aW9uSW1hZ2VfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydCgnLi4vLi4vRGF0YVRpbGUuanMnKS5JbWFnZUxpa2V9XG4gICAgICovXG4gICAgdGhpcy5pbWFnZV8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLmltYWdlUGl4ZWxSYXRpb18gPSB1bmRlZmluZWQ7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ8dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMuYW5jaG9yWF8gPSB1bmRlZmluZWQ7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ8dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMuYW5jaG9yWV8gPSB1bmRlZmluZWQ7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ8dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMuaGVpZ2h0XyA9IHVuZGVmaW5lZDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcnx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5vcGFjaXR5XyA9IHVuZGVmaW5lZDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcnx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5vcmlnaW5YXyA9IHVuZGVmaW5lZDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcnx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5vcmlnaW5ZXyA9IHVuZGVmaW5lZDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2Jvb2xlYW58dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMucm90YXRlV2l0aFZpZXdfID0gdW5kZWZpbmVkO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLnJvdGF0aW9uXyA9IHVuZGVmaW5lZDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uLy4uL3NpemUuanNcIikuU2l6ZXx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5zY2FsZV8gPSB1bmRlZmluZWQ7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ8dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMud2lkdGhfID0gdW5kZWZpbmVkO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7XCJkZWNsdXR0ZXJcInxcIm9ic3RhY2xlXCJ8XCJub25lXCJ8dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMuZGVjbHV0dGVyTW9kZV8gPSB1bmRlZmluZWQ7XG5cbiAgICAvKipcbiAgICAgKiBEYXRhIHNoYXJlZCB3aXRoIGEgdGV4dCBidWlsZGVyIGZvciBjb21iaW5lZCBkZWNsdXR0ZXJpbmcuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vY2FudmFzLmpzXCIpLkRlY2x1dHRlckltYWdlV2l0aFRleHR9XG4gICAgICovXG4gICAgdGhpcy5kZWNsdXR0ZXJJbWFnZVdpdGhUZXh0XyA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL2dlb20vUG9pbnQuanNcIikuZGVmYXVsdHxpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9IHBvaW50R2VvbWV0cnkgUG9pbnQgZ2VvbWV0cnkuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vRmVhdHVyZS5qc1wiKS5GZWF0dXJlTGlrZX0gZmVhdHVyZSBGZWF0dXJlLlxuICAgKi9cbiAgZHJhd1BvaW50KHBvaW50R2VvbWV0cnksIGZlYXR1cmUpIHtcbiAgICBpZiAoIXRoaXMuaW1hZ2VfKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuYmVnaW5HZW9tZXRyeShwb2ludEdlb21ldHJ5LCBmZWF0dXJlKTtcbiAgICBjb25zdCBmbGF0Q29vcmRpbmF0ZXMgPSBwb2ludEdlb21ldHJ5LmdldEZsYXRDb29yZGluYXRlcygpO1xuICAgIGNvbnN0IHN0cmlkZSA9IHBvaW50R2VvbWV0cnkuZ2V0U3RyaWRlKCk7XG4gICAgY29uc3QgbXlCZWdpbiA9IHRoaXMuY29vcmRpbmF0ZXMubGVuZ3RoO1xuICAgIGNvbnN0IG15RW5kID0gdGhpcy5hcHBlbmRGbGF0UG9pbnRDb29yZGluYXRlcyhmbGF0Q29vcmRpbmF0ZXMsIHN0cmlkZSk7XG4gICAgdGhpcy5pbnN0cnVjdGlvbnMucHVzaChbXG4gICAgICBDYW52YXNJbnN0cnVjdGlvbi5EUkFXX0lNQUdFLFxuICAgICAgbXlCZWdpbixcbiAgICAgIG15RW5kLFxuICAgICAgdGhpcy5pbWFnZV8sXG4gICAgICAvLyBSZW1haW5pbmcgYXJndW1lbnRzIHRvIERSQVdfSU1BR0UgYXJlIGluIGFscGhhYmV0aWNhbCBvcmRlclxuICAgICAgdGhpcy5hbmNob3JYXyAqIHRoaXMuaW1hZ2VQaXhlbFJhdGlvXyxcbiAgICAgIHRoaXMuYW5jaG9yWV8gKiB0aGlzLmltYWdlUGl4ZWxSYXRpb18sXG4gICAgICBNYXRoLmNlaWwodGhpcy5oZWlnaHRfICogdGhpcy5pbWFnZVBpeGVsUmF0aW9fKSxcbiAgICAgIHRoaXMub3BhY2l0eV8sXG4gICAgICB0aGlzLm9yaWdpblhfICogdGhpcy5pbWFnZVBpeGVsUmF0aW9fLFxuICAgICAgdGhpcy5vcmlnaW5ZXyAqIHRoaXMuaW1hZ2VQaXhlbFJhdGlvXyxcbiAgICAgIHRoaXMucm90YXRlV2l0aFZpZXdfLFxuICAgICAgdGhpcy5yb3RhdGlvbl8sXG4gICAgICBbXG4gICAgICAgICh0aGlzLnNjYWxlX1swXSAqIHRoaXMucGl4ZWxSYXRpbykgLyB0aGlzLmltYWdlUGl4ZWxSYXRpb18sXG4gICAgICAgICh0aGlzLnNjYWxlX1sxXSAqIHRoaXMucGl4ZWxSYXRpbykgLyB0aGlzLmltYWdlUGl4ZWxSYXRpb18sXG4gICAgICBdLFxuICAgICAgTWF0aC5jZWlsKHRoaXMud2lkdGhfICogdGhpcy5pbWFnZVBpeGVsUmF0aW9fKSxcbiAgICAgIHRoaXMuZGVjbHV0dGVyTW9kZV8sXG4gICAgICB0aGlzLmRlY2x1dHRlckltYWdlV2l0aFRleHRfLFxuICAgIF0pO1xuICAgIHRoaXMuaGl0RGV0ZWN0aW9uSW5zdHJ1Y3Rpb25zLnB1c2goW1xuICAgICAgQ2FudmFzSW5zdHJ1Y3Rpb24uRFJBV19JTUFHRSxcbiAgICAgIG15QmVnaW4sXG4gICAgICBteUVuZCxcbiAgICAgIHRoaXMuaGl0RGV0ZWN0aW9uSW1hZ2VfLFxuICAgICAgLy8gUmVtYWluaW5nIGFyZ3VtZW50cyB0byBEUkFXX0lNQUdFIGFyZSBpbiBhbHBoYWJldGljYWwgb3JkZXJcbiAgICAgIHRoaXMuYW5jaG9yWF8sXG4gICAgICB0aGlzLmFuY2hvcllfLFxuICAgICAgdGhpcy5oZWlnaHRfLFxuICAgICAgMSxcbiAgICAgIHRoaXMub3JpZ2luWF8sXG4gICAgICB0aGlzLm9yaWdpbllfLFxuICAgICAgdGhpcy5yb3RhdGVXaXRoVmlld18sXG4gICAgICB0aGlzLnJvdGF0aW9uXyxcbiAgICAgIHRoaXMuc2NhbGVfLFxuICAgICAgdGhpcy53aWR0aF8sXG4gICAgICB0aGlzLmRlY2x1dHRlck1vZGVfLFxuICAgICAgdGhpcy5kZWNsdXR0ZXJJbWFnZVdpdGhUZXh0XyxcbiAgICBdKTtcbiAgICB0aGlzLmVuZEdlb21ldHJ5KGZlYXR1cmUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vZ2VvbS9NdWx0aVBvaW50LmpzXCIpLmRlZmF1bHR8aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0fSBtdWx0aVBvaW50R2VvbWV0cnkgTXVsdGlQb2ludCBnZW9tZXRyeS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9GZWF0dXJlLmpzXCIpLkZlYXR1cmVMaWtlfSBmZWF0dXJlIEZlYXR1cmUuXG4gICAqL1xuICBkcmF3TXVsdGlQb2ludChtdWx0aVBvaW50R2VvbWV0cnksIGZlYXR1cmUpIHtcbiAgICBpZiAoIXRoaXMuaW1hZ2VfKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuYmVnaW5HZW9tZXRyeShtdWx0aVBvaW50R2VvbWV0cnksIGZlYXR1cmUpO1xuICAgIGNvbnN0IGZsYXRDb29yZGluYXRlcyA9IG11bHRpUG9pbnRHZW9tZXRyeS5nZXRGbGF0Q29vcmRpbmF0ZXMoKTtcbiAgICBjb25zdCBzdHJpZGUgPSBtdWx0aVBvaW50R2VvbWV0cnkuZ2V0U3RyaWRlKCk7XG4gICAgY29uc3QgbXlCZWdpbiA9IHRoaXMuY29vcmRpbmF0ZXMubGVuZ3RoO1xuICAgIGNvbnN0IG15RW5kID0gdGhpcy5hcHBlbmRGbGF0UG9pbnRDb29yZGluYXRlcyhmbGF0Q29vcmRpbmF0ZXMsIHN0cmlkZSk7XG4gICAgdGhpcy5pbnN0cnVjdGlvbnMucHVzaChbXG4gICAgICBDYW52YXNJbnN0cnVjdGlvbi5EUkFXX0lNQUdFLFxuICAgICAgbXlCZWdpbixcbiAgICAgIG15RW5kLFxuICAgICAgdGhpcy5pbWFnZV8sXG4gICAgICAvLyBSZW1haW5pbmcgYXJndW1lbnRzIHRvIERSQVdfSU1BR0UgYXJlIGluIGFscGhhYmV0aWNhbCBvcmRlclxuICAgICAgdGhpcy5hbmNob3JYXyAqIHRoaXMuaW1hZ2VQaXhlbFJhdGlvXyxcbiAgICAgIHRoaXMuYW5jaG9yWV8gKiB0aGlzLmltYWdlUGl4ZWxSYXRpb18sXG4gICAgICBNYXRoLmNlaWwodGhpcy5oZWlnaHRfICogdGhpcy5pbWFnZVBpeGVsUmF0aW9fKSxcbiAgICAgIHRoaXMub3BhY2l0eV8sXG4gICAgICB0aGlzLm9yaWdpblhfICogdGhpcy5pbWFnZVBpeGVsUmF0aW9fLFxuICAgICAgdGhpcy5vcmlnaW5ZXyAqIHRoaXMuaW1hZ2VQaXhlbFJhdGlvXyxcbiAgICAgIHRoaXMucm90YXRlV2l0aFZpZXdfLFxuICAgICAgdGhpcy5yb3RhdGlvbl8sXG4gICAgICBbXG4gICAgICAgICh0aGlzLnNjYWxlX1swXSAqIHRoaXMucGl4ZWxSYXRpbykgLyB0aGlzLmltYWdlUGl4ZWxSYXRpb18sXG4gICAgICAgICh0aGlzLnNjYWxlX1sxXSAqIHRoaXMucGl4ZWxSYXRpbykgLyB0aGlzLmltYWdlUGl4ZWxSYXRpb18sXG4gICAgICBdLFxuICAgICAgTWF0aC5jZWlsKHRoaXMud2lkdGhfICogdGhpcy5pbWFnZVBpeGVsUmF0aW9fKSxcbiAgICAgIHRoaXMuZGVjbHV0dGVyTW9kZV8sXG4gICAgICB0aGlzLmRlY2x1dHRlckltYWdlV2l0aFRleHRfLFxuICAgIF0pO1xuICAgIHRoaXMuaGl0RGV0ZWN0aW9uSW5zdHJ1Y3Rpb25zLnB1c2goW1xuICAgICAgQ2FudmFzSW5zdHJ1Y3Rpb24uRFJBV19JTUFHRSxcbiAgICAgIG15QmVnaW4sXG4gICAgICBteUVuZCxcbiAgICAgIHRoaXMuaGl0RGV0ZWN0aW9uSW1hZ2VfLFxuICAgICAgLy8gUmVtYWluaW5nIGFyZ3VtZW50cyB0byBEUkFXX0lNQUdFIGFyZSBpbiBhbHBoYWJldGljYWwgb3JkZXJcbiAgICAgIHRoaXMuYW5jaG9yWF8sXG4gICAgICB0aGlzLmFuY2hvcllfLFxuICAgICAgdGhpcy5oZWlnaHRfLFxuICAgICAgMSxcbiAgICAgIHRoaXMub3JpZ2luWF8sXG4gICAgICB0aGlzLm9yaWdpbllfLFxuICAgICAgdGhpcy5yb3RhdGVXaXRoVmlld18sXG4gICAgICB0aGlzLnJvdGF0aW9uXyxcbiAgICAgIHRoaXMuc2NhbGVfLFxuICAgICAgdGhpcy53aWR0aF8sXG4gICAgICB0aGlzLmRlY2x1dHRlck1vZGVfLFxuICAgICAgdGhpcy5kZWNsdXR0ZXJJbWFnZVdpdGhUZXh0XyxcbiAgICBdKTtcbiAgICB0aGlzLmVuZEdlb21ldHJ5KGZlYXR1cmUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL2NhbnZhcy5qc1wiKS5TZXJpYWxpemFibGVJbnN0cnVjdGlvbnN9IHRoZSBzZXJpYWxpemFibGUgaW5zdHJ1Y3Rpb25zLlxuICAgKi9cbiAgZmluaXNoKCkge1xuICAgIHRoaXMucmV2ZXJzZUhpdERldGVjdGlvbkluc3RydWN0aW9ucygpO1xuICAgIC8vIEZJWE1FIHRoaXMgZG9lc24ndCByZWFsbHkgcHJvdGVjdCB1cyBhZ2FpbnN0IGZ1cnRoZXIgY2FsbHMgdG8gZHJhdypHZW9tZXRyeVxuICAgIHRoaXMuYW5jaG9yWF8gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5hbmNob3JZXyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmhpdERldGVjdGlvbkltYWdlXyA9IG51bGw7XG4gICAgdGhpcy5pbWFnZV8gPSBudWxsO1xuICAgIHRoaXMuaW1hZ2VQaXhlbFJhdGlvXyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmhlaWdodF8gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5zY2FsZV8gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5vcGFjaXR5XyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm9yaWdpblhfID0gdW5kZWZpbmVkO1xuICAgIHRoaXMub3JpZ2luWV8gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5yb3RhdGVXaXRoVmlld18gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5yb3RhdGlvbl8gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy53aWR0aF8gPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHN1cGVyLmZpbmlzaCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vc3R5bGUvSW1hZ2UuanNcIikuZGVmYXVsdH0gaW1hZ2VTdHlsZSBJbWFnZSBzdHlsZS5cbiAgICogQHBhcmFtIHtPYmplY3R9IFtzaGFyZWREYXRhXSBTaGFyZWQgZGF0YS5cbiAgICovXG4gIHNldEltYWdlU3R5bGUoaW1hZ2VTdHlsZSwgc2hhcmVkRGF0YSkge1xuICAgIGNvbnN0IGFuY2hvciA9IGltYWdlU3R5bGUuZ2V0QW5jaG9yKCk7XG4gICAgY29uc3Qgc2l6ZSA9IGltYWdlU3R5bGUuZ2V0U2l6ZSgpO1xuICAgIGNvbnN0IG9yaWdpbiA9IGltYWdlU3R5bGUuZ2V0T3JpZ2luKCk7XG4gICAgdGhpcy5pbWFnZVBpeGVsUmF0aW9fID0gaW1hZ2VTdHlsZS5nZXRQaXhlbFJhdGlvKHRoaXMucGl4ZWxSYXRpbyk7XG4gICAgdGhpcy5hbmNob3JYXyA9IGFuY2hvclswXTtcbiAgICB0aGlzLmFuY2hvcllfID0gYW5jaG9yWzFdO1xuICAgIHRoaXMuaGl0RGV0ZWN0aW9uSW1hZ2VfID0gaW1hZ2VTdHlsZS5nZXRIaXREZXRlY3Rpb25JbWFnZSgpO1xuICAgIHRoaXMuaW1hZ2VfID0gaW1hZ2VTdHlsZS5nZXRJbWFnZSh0aGlzLnBpeGVsUmF0aW8pO1xuICAgIHRoaXMuaGVpZ2h0XyA9IHNpemVbMV07XG4gICAgdGhpcy5vcGFjaXR5XyA9IGltYWdlU3R5bGUuZ2V0T3BhY2l0eSgpO1xuICAgIHRoaXMub3JpZ2luWF8gPSBvcmlnaW5bMF07XG4gICAgdGhpcy5vcmlnaW5ZXyA9IG9yaWdpblsxXTtcbiAgICB0aGlzLnJvdGF0ZVdpdGhWaWV3XyA9IGltYWdlU3R5bGUuZ2V0Um90YXRlV2l0aFZpZXcoKTtcbiAgICB0aGlzLnJvdGF0aW9uXyA9IGltYWdlU3R5bGUuZ2V0Um90YXRpb24oKTtcbiAgICB0aGlzLnNjYWxlXyA9IGltYWdlU3R5bGUuZ2V0U2NhbGVBcnJheSgpO1xuICAgIHRoaXMud2lkdGhfID0gc2l6ZVswXTtcbiAgICB0aGlzLmRlY2x1dHRlck1vZGVfID0gaW1hZ2VTdHlsZS5nZXREZWNsdXR0ZXJNb2RlKCk7XG4gICAgdGhpcy5kZWNsdXR0ZXJJbWFnZVdpdGhUZXh0XyA9IHNoYXJlZERhdGE7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQ2FudmFzSW1hZ2VCdWlsZGVyO1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3JlbmRlci9jYW52YXMvSW1tZWRpYXRlXG4gKi9cbi8vIEZJWE1FIHRlc3QsIGVzcGVjaWFsbHkgcG9seWdvbnMgd2l0aCBob2xlcyBhbmQgbXVsdGlwb2x5Z29uc1xuLy8gRklYTUUgbmVlZCB0byBoYW5kbGUgbGFyZ2UgdGhpY2sgZmVhdHVyZXMgKHdoZXJlIHBpeGVsIHNpemUgbWF0dGVycylcbi8vIEZJWE1FIGFkZCBvZmZzZXQgYW5kIGVuZCB0byBvbC9nZW9tL2ZsYXQvdHJhbnNmb3JtfnRyYW5zZm9ybTJEP1xuXG5pbXBvcnQgVmVjdG9yQ29udGV4dCBmcm9tICcuLi9WZWN0b3JDb250ZXh0LmpzJztcbmltcG9ydCB7YXNDb2xvckxpa2V9IGZyb20gJy4uLy4uL2NvbG9ybGlrZS5qcyc7XG5pbXBvcnQge1xuICBjb21wb3NlIGFzIGNvbXBvc2VUcmFuc2Zvcm0sXG4gIGNyZWF0ZSBhcyBjcmVhdGVUcmFuc2Zvcm0sXG59IGZyb20gJy4uLy4uL3RyYW5zZm9ybS5qcyc7XG5pbXBvcnQge1xuICBkZWZhdWx0RmlsbFN0eWxlLFxuICBkZWZhdWx0Rm9udCxcbiAgZGVmYXVsdExpbmVDYXAsXG4gIGRlZmF1bHRMaW5lRGFzaCxcbiAgZGVmYXVsdExpbmVEYXNoT2Zmc2V0LFxuICBkZWZhdWx0TGluZUpvaW4sXG4gIGRlZmF1bHRMaW5lV2lkdGgsXG4gIGRlZmF1bHRNaXRlckxpbWl0LFxuICBkZWZhdWx0U3Ryb2tlU3R5bGUsXG4gIGRlZmF1bHRUZXh0QWxpZ24sXG4gIGRlZmF1bHRUZXh0QmFzZWxpbmUsXG59IGZyb20gJy4uL2NhbnZhcy5qcyc7XG5pbXBvcnQge2VxdWFsc30gZnJvbSAnLi4vLi4vYXJyYXkuanMnO1xuaW1wb3J0IHtpbnRlcnNlY3RzfSBmcm9tICcuLi8uLi9leHRlbnQuanMnO1xuaW1wb3J0IHt0b0ZpeGVkfSBmcm9tICcuLi8uLi9tYXRoLmpzJztcbmltcG9ydCB7dHJhbnNmb3JtMkR9IGZyb20gJy4uLy4uL2dlb20vZmxhdC90cmFuc2Zvcm0uanMnO1xuaW1wb3J0IHt0cmFuc2Zvcm1HZW9tMkR9IGZyb20gJy4uLy4uL2dlb20vU2ltcGxlR2VvbWV0cnkuanMnO1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEEgY29uY3JldGUgc3ViY2xhc3Mgb2Yge0BsaW5rIG1vZHVsZTpvbC9yZW5kZXIvVmVjdG9yQ29udGV4dH5WZWN0b3JDb250ZXh0fSB0aGF0IGltcGxlbWVudHNcbiAqIGRpcmVjdCByZW5kZXJpbmcgb2YgZmVhdHVyZXMgYW5kIGdlb21ldHJpZXMgdG8gYW4gSFRNTDUgQ2FudmFzIGNvbnRleHQuXG4gKiBJbnN0YW5jZXMgb2YgdGhpcyBjbGFzcyBhcmUgY3JlYXRlZCBpbnRlcm5hbGx5IGJ5IHRoZSBsaWJyYXJ5IGFuZFxuICogcHJvdmlkZWQgdG8gYXBwbGljYXRpb24gY29kZSBhcyB2ZWN0b3JDb250ZXh0IG1lbWJlciBvZiB0aGVcbiAqIHtAbGluayBtb2R1bGU6b2wvcmVuZGVyL0V2ZW50flJlbmRlckV2ZW50fSBvYmplY3QgYXNzb2NpYXRlZCB3aXRoIHBvc3Rjb21wb3NlLCBwcmVjb21wb3NlIGFuZFxuICogcmVuZGVyIGV2ZW50cyBlbWl0dGVkIGJ5IGxheWVycyBhbmQgbWFwcy5cbiAqL1xuY2xhc3MgQ2FudmFzSW1tZWRpYXRlUmVuZGVyZXIgZXh0ZW5kcyBWZWN0b3JDb250ZXh0IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjb250ZXh0IENvbnRleHQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwaXhlbFJhdGlvIFBpeGVsIHJhdGlvLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vdHJhbnNmb3JtLmpzXCIpLlRyYW5zZm9ybX0gdHJhbnNmb3JtIFRyYW5zZm9ybS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHZpZXdSb3RhdGlvbiBWaWV3IHJvdGF0aW9uLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW3NxdWFyZWRUb2xlcmFuY2VdIE9wdGlvbmFsIHNxdWFyZWQgdG9sZXJhbmNlIGZvciBzaW1wbGlmaWNhdGlvbi5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9wcm9qLmpzXCIpLlRyYW5zZm9ybUZ1bmN0aW9ufSBbdXNlclRyYW5zZm9ybV0gVHJhbnNmb3JtIGZyb20gdXNlciB0byB2aWV3IHByb2plY3Rpb24uXG4gICAqL1xuICBjb25zdHJ1Y3RvcihcbiAgICBjb250ZXh0LFxuICAgIHBpeGVsUmF0aW8sXG4gICAgZXh0ZW50LFxuICAgIHRyYW5zZm9ybSxcbiAgICB2aWV3Um90YXRpb24sXG4gICAgc3F1YXJlZFRvbGVyYW5jZSxcbiAgICB1c2VyVHJhbnNmb3JtXG4gICkge1xuICAgIHN1cGVyKCk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9XG4gICAgICovXG4gICAgdGhpcy5jb250ZXh0XyA9IGNvbnRleHQ7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5waXhlbFJhdGlvXyA9IHBpeGVsUmF0aW87XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi9leHRlbnQuanNcIikuRXh0ZW50fVxuICAgICAqL1xuICAgIHRoaXMuZXh0ZW50XyA9IGV4dGVudDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uLy4uL3RyYW5zZm9ybS5qc1wiKS5UcmFuc2Zvcm19XG4gICAgICovXG4gICAgdGhpcy50cmFuc2Zvcm1fID0gdHJhbnNmb3JtO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMudHJhbnNmb3JtUm90YXRpb25fID0gdHJhbnNmb3JtXG4gICAgICA/IHRvRml4ZWQoTWF0aC5hdGFuMih0cmFuc2Zvcm1bMV0sIHRyYW5zZm9ybVswXSksIDEwKVxuICAgICAgOiAwO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMudmlld1JvdGF0aW9uXyA9IHZpZXdSb3RhdGlvbjtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnNxdWFyZWRUb2xlcmFuY2VfID0gc3F1YXJlZFRvbGVyYW5jZTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uLy4uL3Byb2ouanNcIikuVHJhbnNmb3JtRnVuY3Rpb259XG4gICAgICovXG4gICAgdGhpcy51c2VyVHJhbnNmb3JtXyA9IHVzZXJUcmFuc2Zvcm07XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHs/aW1wb3J0KFwiLi4vY2FudmFzLmpzXCIpLkZpbGxTdGF0ZX1cbiAgICAgKi9cbiAgICB0aGlzLmNvbnRleHRGaWxsU3RhdGVfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgez9pbXBvcnQoXCIuLi9jYW52YXMuanNcIikuU3Ryb2tlU3RhdGV9XG4gICAgICovXG4gICAgdGhpcy5jb250ZXh0U3Ryb2tlU3RhdGVfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgez9pbXBvcnQoXCIuLi9jYW52YXMuanNcIikuVGV4dFN0YXRlfVxuICAgICAqL1xuICAgIHRoaXMuY29udGV4dFRleHRTdGF0ZV8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7P2ltcG9ydChcIi4uL2NhbnZhcy5qc1wiKS5GaWxsU3RhdGV9XG4gICAgICovXG4gICAgdGhpcy5maWxsU3RhdGVfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgez9pbXBvcnQoXCIuLi9jYW52YXMuanNcIikuU3Ryb2tlU3RhdGV9XG4gICAgICovXG4gICAgdGhpcy5zdHJva2VTdGF0ZV8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KCcuLi8uLi9EYXRhVGlsZS5qcycpLkltYWdlTGlrZX1cbiAgICAgKi9cbiAgICB0aGlzLmltYWdlXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5pbWFnZUFuY2hvclhfID0gMDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmltYWdlQW5jaG9yWV8gPSAwO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuaW1hZ2VIZWlnaHRfID0gMDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmltYWdlT3BhY2l0eV8gPSAwO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuaW1hZ2VPcmlnaW5YXyA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5pbWFnZU9yaWdpbllfID0gMDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5pbWFnZVJvdGF0ZVdpdGhWaWV3XyA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuaW1hZ2VSb3RhdGlvbl8gPSAwO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vc2l6ZS5qc1wiKS5TaXplfVxuICAgICAqL1xuICAgIHRoaXMuaW1hZ2VTY2FsZV8gPSBbMCwgMF07XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5pbWFnZVdpZHRoXyA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy50ZXh0XyA9ICcnO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMudGV4dE9mZnNldFhfID0gMDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnRleHRPZmZzZXRZXyA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMudGV4dFJvdGF0ZVdpdGhWaWV3XyA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMudGV4dFJvdGF0aW9uXyA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi9zaXplLmpzXCIpLlNpemV9XG4gICAgICovXG4gICAgdGhpcy50ZXh0U2NhbGVfID0gWzAsIDBdO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7P2ltcG9ydChcIi4uL2NhbnZhcy5qc1wiKS5GaWxsU3RhdGV9XG4gICAgICovXG4gICAgdGhpcy50ZXh0RmlsbFN0YXRlXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHs/aW1wb3J0KFwiLi4vY2FudmFzLmpzXCIpLlN0cm9rZVN0YXRlfVxuICAgICAqL1xuICAgIHRoaXMudGV4dFN0cm9rZVN0YXRlXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHs/aW1wb3J0KFwiLi4vY2FudmFzLmpzXCIpLlRleHRTdGF0ZX1cbiAgICAgKi9cbiAgICB0aGlzLnRleHRTdGF0ZV8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7QXJyYXk8bnVtYmVyPn1cbiAgICAgKi9cbiAgICB0aGlzLnBpeGVsQ29vcmRpbmF0ZXNfID0gW107XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi90cmFuc2Zvcm0uanNcIikuVHJhbnNmb3JtfVxuICAgICAqL1xuICAgIHRoaXMudG1wTG9jYWxUcmFuc2Zvcm1fID0gY3JlYXRlVHJhbnNmb3JtKCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgRW5kLlxuICAgKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGRyYXdJbWFnZXNfKGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmQsIHN0cmlkZSkge1xuICAgIGlmICghdGhpcy5pbWFnZV8pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcGl4ZWxDb29yZGluYXRlcyA9IHRyYW5zZm9ybTJEKFxuICAgICAgZmxhdENvb3JkaW5hdGVzLFxuICAgICAgb2Zmc2V0LFxuICAgICAgZW5kLFxuICAgICAgc3RyaWRlLFxuICAgICAgdGhpcy50cmFuc2Zvcm1fLFxuICAgICAgdGhpcy5waXhlbENvb3JkaW5hdGVzX1xuICAgICk7XG4gICAgY29uc3QgY29udGV4dCA9IHRoaXMuY29udGV4dF87XG4gICAgY29uc3QgbG9jYWxUcmFuc2Zvcm0gPSB0aGlzLnRtcExvY2FsVHJhbnNmb3JtXztcbiAgICBjb25zdCBhbHBoYSA9IGNvbnRleHQuZ2xvYmFsQWxwaGE7XG4gICAgaWYgKHRoaXMuaW1hZ2VPcGFjaXR5XyAhPSAxKSB7XG4gICAgICBjb250ZXh0Lmdsb2JhbEFscGhhID0gYWxwaGEgKiB0aGlzLmltYWdlT3BhY2l0eV87XG4gICAgfVxuICAgIGxldCByb3RhdGlvbiA9IHRoaXMuaW1hZ2VSb3RhdGlvbl87XG4gICAgaWYgKHRoaXMudHJhbnNmb3JtUm90YXRpb25fID09PSAwKSB7XG4gICAgICByb3RhdGlvbiAtPSB0aGlzLnZpZXdSb3RhdGlvbl87XG4gICAgfVxuICAgIGlmICh0aGlzLmltYWdlUm90YXRlV2l0aFZpZXdfKSB7XG4gICAgICByb3RhdGlvbiArPSB0aGlzLnZpZXdSb3RhdGlvbl87XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IHBpeGVsQ29vcmRpbmF0ZXMubGVuZ3RoOyBpIDwgaWk7IGkgKz0gMikge1xuICAgICAgY29uc3QgeCA9IHBpeGVsQ29vcmRpbmF0ZXNbaV0gLSB0aGlzLmltYWdlQW5jaG9yWF87XG4gICAgICBjb25zdCB5ID0gcGl4ZWxDb29yZGluYXRlc1tpICsgMV0gLSB0aGlzLmltYWdlQW5jaG9yWV87XG4gICAgICBpZiAoXG4gICAgICAgIHJvdGF0aW9uICE9PSAwIHx8XG4gICAgICAgIHRoaXMuaW1hZ2VTY2FsZV9bMF0gIT0gMSB8fFxuICAgICAgICB0aGlzLmltYWdlU2NhbGVfWzFdICE9IDFcbiAgICAgICkge1xuICAgICAgICBjb25zdCBjZW50ZXJYID0geCArIHRoaXMuaW1hZ2VBbmNob3JYXztcbiAgICAgICAgY29uc3QgY2VudGVyWSA9IHkgKyB0aGlzLmltYWdlQW5jaG9yWV87XG4gICAgICAgIGNvbXBvc2VUcmFuc2Zvcm0oXG4gICAgICAgICAgbG9jYWxUcmFuc2Zvcm0sXG4gICAgICAgICAgY2VudGVyWCxcbiAgICAgICAgICBjZW50ZXJZLFxuICAgICAgICAgIDEsXG4gICAgICAgICAgMSxcbiAgICAgICAgICByb3RhdGlvbixcbiAgICAgICAgICAtY2VudGVyWCxcbiAgICAgICAgICAtY2VudGVyWVxuICAgICAgICApO1xuICAgICAgICBjb250ZXh0LnNhdmUoKTtcbiAgICAgICAgY29udGV4dC50cmFuc2Zvcm0uYXBwbHkoY29udGV4dCwgbG9jYWxUcmFuc2Zvcm0pO1xuICAgICAgICBjb250ZXh0LnRyYW5zbGF0ZShjZW50ZXJYLCBjZW50ZXJZKTtcbiAgICAgICAgY29udGV4dC5zY2FsZSh0aGlzLmltYWdlU2NhbGVfWzBdLCB0aGlzLmltYWdlU2NhbGVfWzFdKTtcbiAgICAgICAgY29udGV4dC5kcmF3SW1hZ2UoXG4gICAgICAgICAgdGhpcy5pbWFnZV8sXG4gICAgICAgICAgdGhpcy5pbWFnZU9yaWdpblhfLFxuICAgICAgICAgIHRoaXMuaW1hZ2VPcmlnaW5ZXyxcbiAgICAgICAgICB0aGlzLmltYWdlV2lkdGhfLFxuICAgICAgICAgIHRoaXMuaW1hZ2VIZWlnaHRfLFxuICAgICAgICAgIC10aGlzLmltYWdlQW5jaG9yWF8sXG4gICAgICAgICAgLXRoaXMuaW1hZ2VBbmNob3JZXyxcbiAgICAgICAgICB0aGlzLmltYWdlV2lkdGhfLFxuICAgICAgICAgIHRoaXMuaW1hZ2VIZWlnaHRfXG4gICAgICAgICk7XG4gICAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGV4dC5kcmF3SW1hZ2UoXG4gICAgICAgICAgdGhpcy5pbWFnZV8sXG4gICAgICAgICAgdGhpcy5pbWFnZU9yaWdpblhfLFxuICAgICAgICAgIHRoaXMuaW1hZ2VPcmlnaW5ZXyxcbiAgICAgICAgICB0aGlzLmltYWdlV2lkdGhfLFxuICAgICAgICAgIHRoaXMuaW1hZ2VIZWlnaHRfLFxuICAgICAgICAgIHgsXG4gICAgICAgICAgeSxcbiAgICAgICAgICB0aGlzLmltYWdlV2lkdGhfLFxuICAgICAgICAgIHRoaXMuaW1hZ2VIZWlnaHRfXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLmltYWdlT3BhY2l0eV8gIT0gMSkge1xuICAgICAgY29udGV4dC5nbG9iYWxBbHBoYSA9IGFscGhhO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGVuZCBFbmQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZHJhd1RleHRfKGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmQsIHN0cmlkZSkge1xuICAgIGlmICghdGhpcy50ZXh0U3RhdGVfIHx8IHRoaXMudGV4dF8gPT09ICcnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLnRleHRGaWxsU3RhdGVfKSB7XG4gICAgICB0aGlzLnNldENvbnRleHRGaWxsU3RhdGVfKHRoaXMudGV4dEZpbGxTdGF0ZV8pO1xuICAgIH1cbiAgICBpZiAodGhpcy50ZXh0U3Ryb2tlU3RhdGVfKSB7XG4gICAgICB0aGlzLnNldENvbnRleHRTdHJva2VTdGF0ZV8odGhpcy50ZXh0U3Ryb2tlU3RhdGVfKTtcbiAgICB9XG4gICAgdGhpcy5zZXRDb250ZXh0VGV4dFN0YXRlXyh0aGlzLnRleHRTdGF0ZV8pO1xuICAgIGNvbnN0IHBpeGVsQ29vcmRpbmF0ZXMgPSB0cmFuc2Zvcm0yRChcbiAgICAgIGZsYXRDb29yZGluYXRlcyxcbiAgICAgIG9mZnNldCxcbiAgICAgIGVuZCxcbiAgICAgIHN0cmlkZSxcbiAgICAgIHRoaXMudHJhbnNmb3JtXyxcbiAgICAgIHRoaXMucGl4ZWxDb29yZGluYXRlc19cbiAgICApO1xuICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLmNvbnRleHRfO1xuICAgIGxldCByb3RhdGlvbiA9IHRoaXMudGV4dFJvdGF0aW9uXztcbiAgICBpZiAodGhpcy50cmFuc2Zvcm1Sb3RhdGlvbl8gPT09IDApIHtcbiAgICAgIHJvdGF0aW9uIC09IHRoaXMudmlld1JvdGF0aW9uXztcbiAgICB9XG4gICAgaWYgKHRoaXMudGV4dFJvdGF0ZVdpdGhWaWV3Xykge1xuICAgICAgcm90YXRpb24gKz0gdGhpcy52aWV3Um90YXRpb25fO1xuICAgIH1cbiAgICBmb3IgKDsgb2Zmc2V0IDwgZW5kOyBvZmZzZXQgKz0gc3RyaWRlKSB7XG4gICAgICBjb25zdCB4ID0gcGl4ZWxDb29yZGluYXRlc1tvZmZzZXRdICsgdGhpcy50ZXh0T2Zmc2V0WF87XG4gICAgICBjb25zdCB5ID0gcGl4ZWxDb29yZGluYXRlc1tvZmZzZXQgKyAxXSArIHRoaXMudGV4dE9mZnNldFlfO1xuICAgICAgaWYgKFxuICAgICAgICByb3RhdGlvbiAhPT0gMCB8fFxuICAgICAgICB0aGlzLnRleHRTY2FsZV9bMF0gIT0gMSB8fFxuICAgICAgICB0aGlzLnRleHRTY2FsZV9bMV0gIT0gMVxuICAgICAgKSB7XG4gICAgICAgIGNvbnRleHQuc2F2ZSgpO1xuICAgICAgICBjb250ZXh0LnRyYW5zbGF0ZSh4IC0gdGhpcy50ZXh0T2Zmc2V0WF8sIHkgLSB0aGlzLnRleHRPZmZzZXRZXyk7XG4gICAgICAgIGNvbnRleHQucm90YXRlKHJvdGF0aW9uKTtcbiAgICAgICAgY29udGV4dC50cmFuc2xhdGUodGhpcy50ZXh0T2Zmc2V0WF8sIHRoaXMudGV4dE9mZnNldFlfKTtcbiAgICAgICAgY29udGV4dC5zY2FsZSh0aGlzLnRleHRTY2FsZV9bMF0sIHRoaXMudGV4dFNjYWxlX1sxXSk7XG4gICAgICAgIGlmICh0aGlzLnRleHRTdHJva2VTdGF0ZV8pIHtcbiAgICAgICAgICBjb250ZXh0LnN0cm9rZVRleHQodGhpcy50ZXh0XywgMCwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudGV4dEZpbGxTdGF0ZV8pIHtcbiAgICAgICAgICBjb250ZXh0LmZpbGxUZXh0KHRoaXMudGV4dF8sIDAsIDApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMudGV4dFN0cm9rZVN0YXRlXykge1xuICAgICAgICAgIGNvbnRleHQuc3Ryb2tlVGV4dCh0aGlzLnRleHRfLCB4LCB5KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy50ZXh0RmlsbFN0YXRlXykge1xuICAgICAgICAgIGNvbnRleHQuZmlsbFRleHQodGhpcy50ZXh0XywgeCwgeSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgRW5kLlxuICAgKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAgICogQHBhcmFtIHtib29sZWFufSBjbG9zZSBDbG9zZS5cbiAgICogQHByaXZhdGVcbiAgICogQHJldHVybiB7bnVtYmVyfSBlbmQgRW5kLlxuICAgKi9cbiAgbW92ZVRvTGluZVRvXyhmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kLCBzdHJpZGUsIGNsb3NlKSB7XG4gICAgY29uc3QgY29udGV4dCA9IHRoaXMuY29udGV4dF87XG4gICAgY29uc3QgcGl4ZWxDb29yZGluYXRlcyA9IHRyYW5zZm9ybTJEKFxuICAgICAgZmxhdENvb3JkaW5hdGVzLFxuICAgICAgb2Zmc2V0LFxuICAgICAgZW5kLFxuICAgICAgc3RyaWRlLFxuICAgICAgdGhpcy50cmFuc2Zvcm1fLFxuICAgICAgdGhpcy5waXhlbENvb3JkaW5hdGVzX1xuICAgICk7XG4gICAgY29udGV4dC5tb3ZlVG8ocGl4ZWxDb29yZGluYXRlc1swXSwgcGl4ZWxDb29yZGluYXRlc1sxXSk7XG4gICAgbGV0IGxlbmd0aCA9IHBpeGVsQ29vcmRpbmF0ZXMubGVuZ3RoO1xuICAgIGlmIChjbG9zZSkge1xuICAgICAgbGVuZ3RoIC09IDI7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAyOyBpIDwgbGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgIGNvbnRleHQubGluZVRvKHBpeGVsQ29vcmRpbmF0ZXNbaV0sIHBpeGVsQ29vcmRpbmF0ZXNbaSArIDFdKTtcbiAgICB9XG4gICAgaWYgKGNsb3NlKSB7XG4gICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgIH1cbiAgICByZXR1cm4gZW5kO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICAgKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGVuZHMgRW5kcy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gICAqIEBwcml2YXRlXG4gICAqIEByZXR1cm4ge251bWJlcn0gRW5kLlxuICAgKi9cbiAgZHJhd1JpbmdzXyhmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kcywgc3RyaWRlKSB7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gZW5kcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICBvZmZzZXQgPSB0aGlzLm1vdmVUb0xpbmVUb18oXG4gICAgICAgIGZsYXRDb29yZGluYXRlcyxcbiAgICAgICAgb2Zmc2V0LFxuICAgICAgICBlbmRzW2ldLFxuICAgICAgICBzdHJpZGUsXG4gICAgICAgIHRydWVcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBvZmZzZXQ7XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVyIGEgY2lyY2xlIGdlb21ldHJ5IGludG8gdGhlIGNhbnZhcy4gIFJlbmRlcmluZyBpcyBpbW1lZGlhdGUgYW5kIHVzZXNcbiAgICogdGhlIGN1cnJlbnQgZmlsbCBhbmQgc3Ryb2tlIHN0eWxlcy5cbiAgICpcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9nZW9tL0NpcmNsZS5qc1wiKS5kZWZhdWx0fSBnZW9tZXRyeSBDaXJjbGUgZ2VvbWV0cnkuXG4gICAqIEBhcGlcbiAgICovXG4gIGRyYXdDaXJjbGUoZ2VvbWV0cnkpIHtcbiAgICBpZiAodGhpcy5zcXVhcmVkVG9sZXJhbmNlXykge1xuICAgICAgZ2VvbWV0cnkgPSAvKiogQHR5cGUge2ltcG9ydChcIi4uLy4uL2dlb20vQ2lyY2xlLmpzXCIpLmRlZmF1bHR9ICovIChcbiAgICAgICAgZ2VvbWV0cnkuc2ltcGxpZnlUcmFuc2Zvcm1lZChcbiAgICAgICAgICB0aGlzLnNxdWFyZWRUb2xlcmFuY2VfLFxuICAgICAgICAgIHRoaXMudXNlclRyYW5zZm9ybV9cbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKCFpbnRlcnNlY3RzKHRoaXMuZXh0ZW50XywgZ2VvbWV0cnkuZ2V0RXh0ZW50KCkpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLmZpbGxTdGF0ZV8gfHwgdGhpcy5zdHJva2VTdGF0ZV8pIHtcbiAgICAgIGlmICh0aGlzLmZpbGxTdGF0ZV8pIHtcbiAgICAgICAgdGhpcy5zZXRDb250ZXh0RmlsbFN0YXRlXyh0aGlzLmZpbGxTdGF0ZV8pO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuc3Ryb2tlU3RhdGVfKSB7XG4gICAgICAgIHRoaXMuc2V0Q29udGV4dFN0cm9rZVN0YXRlXyh0aGlzLnN0cm9rZVN0YXRlXyk7XG4gICAgICB9XG4gICAgICBjb25zdCBwaXhlbENvb3JkaW5hdGVzID0gdHJhbnNmb3JtR2VvbTJEKFxuICAgICAgICBnZW9tZXRyeSxcbiAgICAgICAgdGhpcy50cmFuc2Zvcm1fLFxuICAgICAgICB0aGlzLnBpeGVsQ29vcmRpbmF0ZXNfXG4gICAgICApO1xuICAgICAgY29uc3QgZHggPSBwaXhlbENvb3JkaW5hdGVzWzJdIC0gcGl4ZWxDb29yZGluYXRlc1swXTtcbiAgICAgIGNvbnN0IGR5ID0gcGl4ZWxDb29yZGluYXRlc1szXSAtIHBpeGVsQ29vcmRpbmF0ZXNbMV07XG4gICAgICBjb25zdCByYWRpdXMgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICAgICAgY29uc3QgY29udGV4dCA9IHRoaXMuY29udGV4dF87XG4gICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgY29udGV4dC5hcmMoXG4gICAgICAgIHBpeGVsQ29vcmRpbmF0ZXNbMF0sXG4gICAgICAgIHBpeGVsQ29vcmRpbmF0ZXNbMV0sXG4gICAgICAgIHJhZGl1cyxcbiAgICAgICAgMCxcbiAgICAgICAgMiAqIE1hdGguUElcbiAgICAgICk7XG4gICAgICBpZiAodGhpcy5maWxsU3RhdGVfKSB7XG4gICAgICAgIGNvbnRleHQuZmlsbCgpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuc3Ryb2tlU3RhdGVfKSB7XG4gICAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLnRleHRfICE9PSAnJykge1xuICAgICAgdGhpcy5kcmF3VGV4dF8oZ2VvbWV0cnkuZ2V0Q2VudGVyKCksIDAsIDIsIDIpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHJlbmRlcmluZyBzdHlsZS4gIE5vdGUgdGhhdCBzaW5jZSB0aGlzIGlzIGFuIGltbWVkaWF0ZSByZW5kZXJpbmcgQVBJLFxuICAgKiBhbnkgYHpJbmRleGAgb24gdGhlIHByb3ZpZGVkIHN0eWxlIHdpbGwgYmUgaWdub3JlZC5cbiAgICpcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9zdHlsZS9TdHlsZS5qc1wiKS5kZWZhdWx0fSBzdHlsZSBUaGUgcmVuZGVyaW5nIHN0eWxlLlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRTdHlsZShzdHlsZSkge1xuICAgIHRoaXMuc2V0RmlsbFN0cm9rZVN0eWxlKHN0eWxlLmdldEZpbGwoKSwgc3R5bGUuZ2V0U3Ryb2tlKCkpO1xuICAgIHRoaXMuc2V0SW1hZ2VTdHlsZShzdHlsZS5nZXRJbWFnZSgpKTtcbiAgICB0aGlzLnNldFRleHRTdHlsZShzdHlsZS5nZXRUZXh0KCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vdHJhbnNmb3JtLmpzXCIpLlRyYW5zZm9ybX0gdHJhbnNmb3JtIFRyYW5zZm9ybS5cbiAgICovXG4gIHNldFRyYW5zZm9ybSh0cmFuc2Zvcm0pIHtcbiAgICB0aGlzLnRyYW5zZm9ybV8gPSB0cmFuc2Zvcm07XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVyIGEgZ2VvbWV0cnkgaW50byB0aGUgY2FudmFzLiAgQ2FsbFxuICAgKiB7QGxpbmsgbW9kdWxlOm9sL3JlbmRlci9jYW52YXMvSW1tZWRpYXRlfkNhbnZhc0ltbWVkaWF0ZVJlbmRlcmVyI3NldFN0eWxlIHJlbmRlcmVyLnNldFN0eWxlKCl9IGZpcnN0IHRvIHNldCB0aGUgcmVuZGVyaW5nIHN0eWxlLlxuICAgKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL2dlb20vR2VvbWV0cnkuanNcIikuZGVmYXVsdHxpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9IGdlb21ldHJ5IFRoZSBnZW9tZXRyeSB0byByZW5kZXIuXG4gICAqIEBhcGlcbiAgICovXG4gIGRyYXdHZW9tZXRyeShnZW9tZXRyeSkge1xuICAgIGNvbnN0IHR5cGUgPSBnZW9tZXRyeS5nZXRUeXBlKCk7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlICdQb2ludCc6XG4gICAgICAgIHRoaXMuZHJhd1BvaW50KFxuICAgICAgICAgIC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vZ2VvbS9Qb2ludC5qc1wiKS5kZWZhdWx0fSAqLyAoZ2VvbWV0cnkpXG4gICAgICAgICk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnTGluZVN0cmluZyc6XG4gICAgICAgIHRoaXMuZHJhd0xpbmVTdHJpbmcoXG4gICAgICAgICAgLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi9nZW9tL0xpbmVTdHJpbmcuanNcIikuZGVmYXVsdH0gKi8gKGdlb21ldHJ5KVxuICAgICAgICApO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ1BvbHlnb24nOlxuICAgICAgICB0aGlzLmRyYXdQb2x5Z29uKFxuICAgICAgICAgIC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vZ2VvbS9Qb2x5Z29uLmpzXCIpLmRlZmF1bHR9ICovIChnZW9tZXRyeSlcbiAgICAgICAgKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdNdWx0aVBvaW50JzpcbiAgICAgICAgdGhpcy5kcmF3TXVsdGlQb2ludChcbiAgICAgICAgICAvKiogQHR5cGUge2ltcG9ydChcIi4uLy4uL2dlb20vTXVsdGlQb2ludC5qc1wiKS5kZWZhdWx0fSAqLyAoZ2VvbWV0cnkpXG4gICAgICAgICk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnTXVsdGlMaW5lU3RyaW5nJzpcbiAgICAgICAgdGhpcy5kcmF3TXVsdGlMaW5lU3RyaW5nKFxuICAgICAgICAgIC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vZ2VvbS9NdWx0aUxpbmVTdHJpbmcuanNcIikuZGVmYXVsdH0gKi8gKFxuICAgICAgICAgICAgZ2VvbWV0cnlcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnTXVsdGlQb2x5Z29uJzpcbiAgICAgICAgdGhpcy5kcmF3TXVsdGlQb2x5Z29uKFxuICAgICAgICAgIC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vZ2VvbS9NdWx0aVBvbHlnb24uanNcIikuZGVmYXVsdH0gKi8gKGdlb21ldHJ5KVxuICAgICAgICApO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ0dlb21ldHJ5Q29sbGVjdGlvbic6XG4gICAgICAgIHRoaXMuZHJhd0dlb21ldHJ5Q29sbGVjdGlvbihcbiAgICAgICAgICAvKiogQHR5cGUge2ltcG9ydChcIi4uLy4uL2dlb20vR2VvbWV0cnlDb2xsZWN0aW9uLmpzXCIpLmRlZmF1bHR9ICovIChcbiAgICAgICAgICAgIGdlb21ldHJ5XG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ0NpcmNsZSc6XG4gICAgICAgIHRoaXMuZHJhd0NpcmNsZShcbiAgICAgICAgICAvKiogQHR5cGUge2ltcG9ydChcIi4uLy4uL2dlb20vQ2lyY2xlLmpzXCIpLmRlZmF1bHR9ICovIChnZW9tZXRyeSlcbiAgICAgICAgKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXIgYSBmZWF0dXJlIGludG8gdGhlIGNhbnZhcy4gIE5vdGUgdGhhdCBhbnkgYHpJbmRleGAgb24gdGhlIHByb3ZpZGVkXG4gICAqIHN0eWxlIHdpbGwgYmUgaWdub3JlZCAtIGZlYXR1cmVzIGFyZSByZW5kZXJlZCBpbW1lZGlhdGVseSBpbiB0aGUgb3JkZXIgdGhhdFxuICAgKiB0aGlzIG1ldGhvZCBpcyBjYWxsZWQuICBJZiB5b3UgbmVlZCBgekluZGV4YCBzdXBwb3J0LCB5b3Ugc2hvdWxkIGJlIHVzaW5nIGFuXG4gICAqIHtAbGluayBtb2R1bGU6b2wvbGF5ZXIvVmVjdG9yflZlY3RvckxheWVyfSBpbnN0ZWFkLlxuICAgKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdH0gZmVhdHVyZSBGZWF0dXJlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL3N0eWxlL1N0eWxlLmpzXCIpLmRlZmF1bHR9IHN0eWxlIFN0eWxlLlxuICAgKiBAYXBpXG4gICAqL1xuICBkcmF3RmVhdHVyZShmZWF0dXJlLCBzdHlsZSkge1xuICAgIGNvbnN0IGdlb21ldHJ5ID0gc3R5bGUuZ2V0R2VvbWV0cnlGdW5jdGlvbigpKGZlYXR1cmUpO1xuICAgIGlmICghZ2VvbWV0cnkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5zZXRTdHlsZShzdHlsZSk7XG4gICAgdGhpcy5kcmF3R2VvbWV0cnkoZ2VvbWV0cnkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlciBhIEdlb21ldHJ5Q29sbGVjdGlvbiB0byB0aGUgY2FudmFzLiAgUmVuZGVyaW5nIGlzIGltbWVkaWF0ZSBhbmRcbiAgICogdXNlcyB0aGUgY3VycmVudCBzdHlsZXMgYXBwcm9wcmlhdGUgZm9yIGVhY2ggZ2VvbWV0cnkgaW4gdGhlIGNvbGxlY3Rpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vZ2VvbS9HZW9tZXRyeUNvbGxlY3Rpb24uanNcIikuZGVmYXVsdH0gZ2VvbWV0cnkgR2VvbWV0cnkgY29sbGVjdGlvbi5cbiAgICovXG4gIGRyYXdHZW9tZXRyeUNvbGxlY3Rpb24oZ2VvbWV0cnkpIHtcbiAgICBjb25zdCBnZW9tZXRyaWVzID0gZ2VvbWV0cnkuZ2V0R2VvbWV0cmllc0FycmF5KCk7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gZ2VvbWV0cmllcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICB0aGlzLmRyYXdHZW9tZXRyeShnZW9tZXRyaWVzW2ldKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVyIGEgUG9pbnQgZ2VvbWV0cnkgaW50byB0aGUgY2FudmFzLiAgUmVuZGVyaW5nIGlzIGltbWVkaWF0ZSBhbmQgdXNlc1xuICAgKiB0aGUgY3VycmVudCBzdHlsZS5cbiAgICpcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9nZW9tL1BvaW50LmpzXCIpLmRlZmF1bHR8aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0fSBnZW9tZXRyeSBQb2ludCBnZW9tZXRyeS5cbiAgICovXG4gIGRyYXdQb2ludChnZW9tZXRyeSkge1xuICAgIGlmICh0aGlzLnNxdWFyZWRUb2xlcmFuY2VfKSB7XG4gICAgICBnZW9tZXRyeSA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vZ2VvbS9Qb2ludC5qc1wiKS5kZWZhdWx0fSAqLyAoXG4gICAgICAgIGdlb21ldHJ5LnNpbXBsaWZ5VHJhbnNmb3JtZWQoXG4gICAgICAgICAgdGhpcy5zcXVhcmVkVG9sZXJhbmNlXyxcbiAgICAgICAgICB0aGlzLnVzZXJUcmFuc2Zvcm1fXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IGZsYXRDb29yZGluYXRlcyA9IGdlb21ldHJ5LmdldEZsYXRDb29yZGluYXRlcygpO1xuICAgIGNvbnN0IHN0cmlkZSA9IGdlb21ldHJ5LmdldFN0cmlkZSgpO1xuICAgIGlmICh0aGlzLmltYWdlXykge1xuICAgICAgdGhpcy5kcmF3SW1hZ2VzXyhmbGF0Q29vcmRpbmF0ZXMsIDAsIGZsYXRDb29yZGluYXRlcy5sZW5ndGgsIHN0cmlkZSk7XG4gICAgfVxuICAgIGlmICh0aGlzLnRleHRfICE9PSAnJykge1xuICAgICAgdGhpcy5kcmF3VGV4dF8oZmxhdENvb3JkaW5hdGVzLCAwLCBmbGF0Q29vcmRpbmF0ZXMubGVuZ3RoLCBzdHJpZGUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXIgYSBNdWx0aVBvaW50IGdlb21ldHJ5ICBpbnRvIHRoZSBjYW52YXMuICBSZW5kZXJpbmcgaXMgaW1tZWRpYXRlIGFuZFxuICAgKiB1c2VzIHRoZSBjdXJyZW50IHN0eWxlLlxuICAgKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL2dlb20vTXVsdGlQb2ludC5qc1wiKS5kZWZhdWx0fGltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdH0gZ2VvbWV0cnkgTXVsdGlQb2ludCBnZW9tZXRyeS5cbiAgICovXG4gIGRyYXdNdWx0aVBvaW50KGdlb21ldHJ5KSB7XG4gICAgaWYgKHRoaXMuc3F1YXJlZFRvbGVyYW5jZV8pIHtcbiAgICAgIGdlb21ldHJ5ID0gLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi9nZW9tL011bHRpUG9pbnQuanNcIikuZGVmYXVsdH0gKi8gKFxuICAgICAgICBnZW9tZXRyeS5zaW1wbGlmeVRyYW5zZm9ybWVkKFxuICAgICAgICAgIHRoaXMuc3F1YXJlZFRvbGVyYW5jZV8sXG4gICAgICAgICAgdGhpcy51c2VyVHJhbnNmb3JtX1xuICAgICAgICApXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCBmbGF0Q29vcmRpbmF0ZXMgPSBnZW9tZXRyeS5nZXRGbGF0Q29vcmRpbmF0ZXMoKTtcbiAgICBjb25zdCBzdHJpZGUgPSBnZW9tZXRyeS5nZXRTdHJpZGUoKTtcbiAgICBpZiAodGhpcy5pbWFnZV8pIHtcbiAgICAgIHRoaXMuZHJhd0ltYWdlc18oZmxhdENvb3JkaW5hdGVzLCAwLCBmbGF0Q29vcmRpbmF0ZXMubGVuZ3RoLCBzdHJpZGUpO1xuICAgIH1cbiAgICBpZiAodGhpcy50ZXh0XyAhPT0gJycpIHtcbiAgICAgIHRoaXMuZHJhd1RleHRfKGZsYXRDb29yZGluYXRlcywgMCwgZmxhdENvb3JkaW5hdGVzLmxlbmd0aCwgc3RyaWRlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVyIGEgTGluZVN0cmluZyBpbnRvIHRoZSBjYW52YXMuICBSZW5kZXJpbmcgaXMgaW1tZWRpYXRlIGFuZCB1c2VzXG4gICAqIHRoZSBjdXJyZW50IHN0eWxlLlxuICAgKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL2dlb20vTGluZVN0cmluZy5qc1wiKS5kZWZhdWx0fGltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdH0gZ2VvbWV0cnkgTGluZVN0cmluZyBnZW9tZXRyeS5cbiAgICovXG4gIGRyYXdMaW5lU3RyaW5nKGdlb21ldHJ5KSB7XG4gICAgaWYgKHRoaXMuc3F1YXJlZFRvbGVyYW5jZV8pIHtcbiAgICAgIGdlb21ldHJ5ID0gLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi9nZW9tL0xpbmVTdHJpbmcuanNcIikuZGVmYXVsdH0gKi8gKFxuICAgICAgICBnZW9tZXRyeS5zaW1wbGlmeVRyYW5zZm9ybWVkKFxuICAgICAgICAgIHRoaXMuc3F1YXJlZFRvbGVyYW5jZV8sXG4gICAgICAgICAgdGhpcy51c2VyVHJhbnNmb3JtX1xuICAgICAgICApXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoIWludGVyc2VjdHModGhpcy5leHRlbnRfLCBnZW9tZXRyeS5nZXRFeHRlbnQoKSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuc3Ryb2tlU3RhdGVfKSB7XG4gICAgICB0aGlzLnNldENvbnRleHRTdHJva2VTdGF0ZV8odGhpcy5zdHJva2VTdGF0ZV8pO1xuICAgICAgY29uc3QgY29udGV4dCA9IHRoaXMuY29udGV4dF87XG4gICAgICBjb25zdCBmbGF0Q29vcmRpbmF0ZXMgPSBnZW9tZXRyeS5nZXRGbGF0Q29vcmRpbmF0ZXMoKTtcbiAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICB0aGlzLm1vdmVUb0xpbmVUb18oXG4gICAgICAgIGZsYXRDb29yZGluYXRlcyxcbiAgICAgICAgMCxcbiAgICAgICAgZmxhdENvb3JkaW5hdGVzLmxlbmd0aCxcbiAgICAgICAgZ2VvbWV0cnkuZ2V0U3RyaWRlKCksXG4gICAgICAgIGZhbHNlXG4gICAgICApO1xuICAgICAgY29udGV4dC5zdHJva2UoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMudGV4dF8gIT09ICcnKSB7XG4gICAgICBjb25zdCBmbGF0TWlkcG9pbnQgPSBnZW9tZXRyeS5nZXRGbGF0TWlkcG9pbnQoKTtcbiAgICAgIHRoaXMuZHJhd1RleHRfKGZsYXRNaWRwb2ludCwgMCwgMiwgMik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlciBhIE11bHRpTGluZVN0cmluZyBnZW9tZXRyeSBpbnRvIHRoZSBjYW52YXMuICBSZW5kZXJpbmcgaXMgaW1tZWRpYXRlXG4gICAqIGFuZCB1c2VzIHRoZSBjdXJyZW50IHN0eWxlLlxuICAgKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL2dlb20vTXVsdGlMaW5lU3RyaW5nLmpzXCIpLmRlZmF1bHR8aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0fSBnZW9tZXRyeSBNdWx0aUxpbmVTdHJpbmcgZ2VvbWV0cnkuXG4gICAqL1xuICBkcmF3TXVsdGlMaW5lU3RyaW5nKGdlb21ldHJ5KSB7XG4gICAgaWYgKHRoaXMuc3F1YXJlZFRvbGVyYW5jZV8pIHtcbiAgICAgIGdlb21ldHJ5ID1cbiAgICAgICAgLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi9nZW9tL011bHRpTGluZVN0cmluZy5qc1wiKS5kZWZhdWx0fSAqLyAoXG4gICAgICAgICAgZ2VvbWV0cnkuc2ltcGxpZnlUcmFuc2Zvcm1lZChcbiAgICAgICAgICAgIHRoaXMuc3F1YXJlZFRvbGVyYW5jZV8sXG4gICAgICAgICAgICB0aGlzLnVzZXJUcmFuc2Zvcm1fXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgIH1cbiAgICBjb25zdCBnZW9tZXRyeUV4dGVudCA9IGdlb21ldHJ5LmdldEV4dGVudCgpO1xuICAgIGlmICghaW50ZXJzZWN0cyh0aGlzLmV4dGVudF8sIGdlb21ldHJ5RXh0ZW50KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5zdHJva2VTdGF0ZV8pIHtcbiAgICAgIHRoaXMuc2V0Q29udGV4dFN0cm9rZVN0YXRlXyh0aGlzLnN0cm9rZVN0YXRlXyk7XG4gICAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5jb250ZXh0XztcbiAgICAgIGNvbnN0IGZsYXRDb29yZGluYXRlcyA9IGdlb21ldHJ5LmdldEZsYXRDb29yZGluYXRlcygpO1xuICAgICAgbGV0IG9mZnNldCA9IDA7XG4gICAgICBjb25zdCBlbmRzID0gLyoqIEB0eXBlIHtBcnJheTxudW1iZXI+fSAqLyAoZ2VvbWV0cnkuZ2V0RW5kcygpKTtcbiAgICAgIGNvbnN0IHN0cmlkZSA9IGdlb21ldHJ5LmdldFN0cmlkZSgpO1xuICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IGVuZHMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICBvZmZzZXQgPSB0aGlzLm1vdmVUb0xpbmVUb18oXG4gICAgICAgICAgZmxhdENvb3JkaW5hdGVzLFxuICAgICAgICAgIG9mZnNldCxcbiAgICAgICAgICBlbmRzW2ldLFxuICAgICAgICAgIHN0cmlkZSxcbiAgICAgICAgICBmYWxzZVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY29udGV4dC5zdHJva2UoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMudGV4dF8gIT09ICcnKSB7XG4gICAgICBjb25zdCBmbGF0TWlkcG9pbnRzID0gZ2VvbWV0cnkuZ2V0RmxhdE1pZHBvaW50cygpO1xuICAgICAgdGhpcy5kcmF3VGV4dF8oZmxhdE1pZHBvaW50cywgMCwgZmxhdE1pZHBvaW50cy5sZW5ndGgsIDIpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXIgYSBQb2x5Z29uIGdlb21ldHJ5IGludG8gdGhlIGNhbnZhcy4gIFJlbmRlcmluZyBpcyBpbW1lZGlhdGUgYW5kIHVzZXNcbiAgICogdGhlIGN1cnJlbnQgc3R5bGUuXG4gICAqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vZ2VvbS9Qb2x5Z29uLmpzXCIpLmRlZmF1bHR8aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0fSBnZW9tZXRyeSBQb2x5Z29uIGdlb21ldHJ5LlxuICAgKi9cbiAgZHJhd1BvbHlnb24oZ2VvbWV0cnkpIHtcbiAgICBpZiAodGhpcy5zcXVhcmVkVG9sZXJhbmNlXykge1xuICAgICAgZ2VvbWV0cnkgPSAvKiogQHR5cGUge2ltcG9ydChcIi4uLy4uL2dlb20vUG9seWdvbi5qc1wiKS5kZWZhdWx0fSAqLyAoXG4gICAgICAgIGdlb21ldHJ5LnNpbXBsaWZ5VHJhbnNmb3JtZWQoXG4gICAgICAgICAgdGhpcy5zcXVhcmVkVG9sZXJhbmNlXyxcbiAgICAgICAgICB0aGlzLnVzZXJUcmFuc2Zvcm1fXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfVxuICAgIGlmICghaW50ZXJzZWN0cyh0aGlzLmV4dGVudF8sIGdlb21ldHJ5LmdldEV4dGVudCgpKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5zdHJva2VTdGF0ZV8gfHwgdGhpcy5maWxsU3RhdGVfKSB7XG4gICAgICBpZiAodGhpcy5maWxsU3RhdGVfKSB7XG4gICAgICAgIHRoaXMuc2V0Q29udGV4dEZpbGxTdGF0ZV8odGhpcy5maWxsU3RhdGVfKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnN0cm9rZVN0YXRlXykge1xuICAgICAgICB0aGlzLnNldENvbnRleHRTdHJva2VTdGF0ZV8odGhpcy5zdHJva2VTdGF0ZV8pO1xuICAgICAgfVxuICAgICAgY29uc3QgY29udGV4dCA9IHRoaXMuY29udGV4dF87XG4gICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgdGhpcy5kcmF3UmluZ3NfKFxuICAgICAgICBnZW9tZXRyeS5nZXRPcmllbnRlZEZsYXRDb29yZGluYXRlcygpLFxuICAgICAgICAwLFxuICAgICAgICAvKiogQHR5cGUge0FycmF5PG51bWJlcj59ICovIChnZW9tZXRyeS5nZXRFbmRzKCkpLFxuICAgICAgICBnZW9tZXRyeS5nZXRTdHJpZGUoKVxuICAgICAgKTtcbiAgICAgIGlmICh0aGlzLmZpbGxTdGF0ZV8pIHtcbiAgICAgICAgY29udGV4dC5maWxsKCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5zdHJva2VTdGF0ZV8pIHtcbiAgICAgICAgY29udGV4dC5zdHJva2UoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMudGV4dF8gIT09ICcnKSB7XG4gICAgICBjb25zdCBmbGF0SW50ZXJpb3JQb2ludCA9IGdlb21ldHJ5LmdldEZsYXRJbnRlcmlvclBvaW50KCk7XG4gICAgICB0aGlzLmRyYXdUZXh0XyhmbGF0SW50ZXJpb3JQb2ludCwgMCwgMiwgMik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlciBNdWx0aVBvbHlnb24gZ2VvbWV0cnkgaW50byB0aGUgY2FudmFzLiAgUmVuZGVyaW5nIGlzIGltbWVkaWF0ZSBhbmRcbiAgICogdXNlcyB0aGUgY3VycmVudCBzdHlsZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9nZW9tL011bHRpUG9seWdvbi5qc1wiKS5kZWZhdWx0fSBnZW9tZXRyeSBNdWx0aVBvbHlnb24gZ2VvbWV0cnkuXG4gICAqL1xuICBkcmF3TXVsdGlQb2x5Z29uKGdlb21ldHJ5KSB7XG4gICAgaWYgKHRoaXMuc3F1YXJlZFRvbGVyYW5jZV8pIHtcbiAgICAgIGdlb21ldHJ5ID0gLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi9nZW9tL011bHRpUG9seWdvbi5qc1wiKS5kZWZhdWx0fSAqLyAoXG4gICAgICAgIGdlb21ldHJ5LnNpbXBsaWZ5VHJhbnNmb3JtZWQoXG4gICAgICAgICAgdGhpcy5zcXVhcmVkVG9sZXJhbmNlXyxcbiAgICAgICAgICB0aGlzLnVzZXJUcmFuc2Zvcm1fXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfVxuICAgIGlmICghaW50ZXJzZWN0cyh0aGlzLmV4dGVudF8sIGdlb21ldHJ5LmdldEV4dGVudCgpKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5zdHJva2VTdGF0ZV8gfHwgdGhpcy5maWxsU3RhdGVfKSB7XG4gICAgICBpZiAodGhpcy5maWxsU3RhdGVfKSB7XG4gICAgICAgIHRoaXMuc2V0Q29udGV4dEZpbGxTdGF0ZV8odGhpcy5maWxsU3RhdGVfKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnN0cm9rZVN0YXRlXykge1xuICAgICAgICB0aGlzLnNldENvbnRleHRTdHJva2VTdGF0ZV8odGhpcy5zdHJva2VTdGF0ZV8pO1xuICAgICAgfVxuICAgICAgY29uc3QgY29udGV4dCA9IHRoaXMuY29udGV4dF87XG4gICAgICBjb25zdCBmbGF0Q29vcmRpbmF0ZXMgPSBnZW9tZXRyeS5nZXRPcmllbnRlZEZsYXRDb29yZGluYXRlcygpO1xuICAgICAgbGV0IG9mZnNldCA9IDA7XG4gICAgICBjb25zdCBlbmRzcyA9IGdlb21ldHJ5LmdldEVuZHNzKCk7XG4gICAgICBjb25zdCBzdHJpZGUgPSBnZW9tZXRyeS5nZXRTdHJpZGUoKTtcbiAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBlbmRzcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgIGNvbnN0IGVuZHMgPSBlbmRzc1tpXTtcbiAgICAgICAgb2Zmc2V0ID0gdGhpcy5kcmF3UmluZ3NfKGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmRzLCBzdHJpZGUpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuZmlsbFN0YXRlXykge1xuICAgICAgICBjb250ZXh0LmZpbGwoKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnN0cm9rZVN0YXRlXykge1xuICAgICAgICBjb250ZXh0LnN0cm9rZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy50ZXh0XyAhPT0gJycpIHtcbiAgICAgIGNvbnN0IGZsYXRJbnRlcmlvclBvaW50cyA9IGdlb21ldHJ5LmdldEZsYXRJbnRlcmlvclBvaW50cygpO1xuICAgICAgdGhpcy5kcmF3VGV4dF8oZmxhdEludGVyaW9yUG9pbnRzLCAwLCBmbGF0SW50ZXJpb3JQb2ludHMubGVuZ3RoLCAyKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jYW52YXMuanNcIikuRmlsbFN0YXRlfSBmaWxsU3RhdGUgRmlsbCBzdGF0ZS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHNldENvbnRleHRGaWxsU3RhdGVfKGZpbGxTdGF0ZSkge1xuICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLmNvbnRleHRfO1xuICAgIGNvbnN0IGNvbnRleHRGaWxsU3RhdGUgPSB0aGlzLmNvbnRleHRGaWxsU3RhdGVfO1xuICAgIGlmICghY29udGV4dEZpbGxTdGF0ZSkge1xuICAgICAgY29udGV4dC5maWxsU3R5bGUgPSBmaWxsU3RhdGUuZmlsbFN0eWxlO1xuICAgICAgdGhpcy5jb250ZXh0RmlsbFN0YXRlXyA9IHtcbiAgICAgICAgZmlsbFN0eWxlOiBmaWxsU3RhdGUuZmlsbFN0eWxlLFxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGNvbnRleHRGaWxsU3RhdGUuZmlsbFN0eWxlICE9IGZpbGxTdGF0ZS5maWxsU3R5bGUpIHtcbiAgICAgICAgY29udGV4dEZpbGxTdGF0ZS5maWxsU3R5bGUgPSBmaWxsU3RhdGUuZmlsbFN0eWxlO1xuICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IGZpbGxTdGF0ZS5maWxsU3R5bGU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY2FudmFzLmpzXCIpLlN0cm9rZVN0YXRlfSBzdHJva2VTdGF0ZSBTdHJva2Ugc3RhdGUuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzZXRDb250ZXh0U3Ryb2tlU3RhdGVfKHN0cm9rZVN0YXRlKSB7XG4gICAgY29uc3QgY29udGV4dCA9IHRoaXMuY29udGV4dF87XG4gICAgY29uc3QgY29udGV4dFN0cm9rZVN0YXRlID0gdGhpcy5jb250ZXh0U3Ryb2tlU3RhdGVfO1xuICAgIGlmICghY29udGV4dFN0cm9rZVN0YXRlKSB7XG4gICAgICBjb250ZXh0LmxpbmVDYXAgPSBzdHJva2VTdGF0ZS5saW5lQ2FwO1xuICAgICAgY29udGV4dC5zZXRMaW5lRGFzaChzdHJva2VTdGF0ZS5saW5lRGFzaCk7XG4gICAgICBjb250ZXh0LmxpbmVEYXNoT2Zmc2V0ID0gc3Ryb2tlU3RhdGUubGluZURhc2hPZmZzZXQ7XG4gICAgICBjb250ZXh0LmxpbmVKb2luID0gc3Ryb2tlU3RhdGUubGluZUpvaW47XG4gICAgICBjb250ZXh0LmxpbmVXaWR0aCA9IHN0cm9rZVN0YXRlLmxpbmVXaWR0aDtcbiAgICAgIGNvbnRleHQubWl0ZXJMaW1pdCA9IHN0cm9rZVN0YXRlLm1pdGVyTGltaXQ7XG4gICAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gc3Ryb2tlU3RhdGUuc3Ryb2tlU3R5bGU7XG4gICAgICB0aGlzLmNvbnRleHRTdHJva2VTdGF0ZV8gPSB7XG4gICAgICAgIGxpbmVDYXA6IHN0cm9rZVN0YXRlLmxpbmVDYXAsXG4gICAgICAgIGxpbmVEYXNoOiBzdHJva2VTdGF0ZS5saW5lRGFzaCxcbiAgICAgICAgbGluZURhc2hPZmZzZXQ6IHN0cm9rZVN0YXRlLmxpbmVEYXNoT2Zmc2V0LFxuICAgICAgICBsaW5lSm9pbjogc3Ryb2tlU3RhdGUubGluZUpvaW4sXG4gICAgICAgIGxpbmVXaWR0aDogc3Ryb2tlU3RhdGUubGluZVdpZHRoLFxuICAgICAgICBtaXRlckxpbWl0OiBzdHJva2VTdGF0ZS5taXRlckxpbWl0LFxuICAgICAgICBzdHJva2VTdHlsZTogc3Ryb2tlU3RhdGUuc3Ryb2tlU3R5bGUsXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoY29udGV4dFN0cm9rZVN0YXRlLmxpbmVDYXAgIT0gc3Ryb2tlU3RhdGUubGluZUNhcCkge1xuICAgICAgICBjb250ZXh0U3Ryb2tlU3RhdGUubGluZUNhcCA9IHN0cm9rZVN0YXRlLmxpbmVDYXA7XG4gICAgICAgIGNvbnRleHQubGluZUNhcCA9IHN0cm9rZVN0YXRlLmxpbmVDYXA7XG4gICAgICB9XG4gICAgICBpZiAoIWVxdWFscyhjb250ZXh0U3Ryb2tlU3RhdGUubGluZURhc2gsIHN0cm9rZVN0YXRlLmxpbmVEYXNoKSkge1xuICAgICAgICBjb250ZXh0LnNldExpbmVEYXNoKFxuICAgICAgICAgIChjb250ZXh0U3Ryb2tlU3RhdGUubGluZURhc2ggPSBzdHJva2VTdGF0ZS5saW5lRGFzaClcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChjb250ZXh0U3Ryb2tlU3RhdGUubGluZURhc2hPZmZzZXQgIT0gc3Ryb2tlU3RhdGUubGluZURhc2hPZmZzZXQpIHtcbiAgICAgICAgY29udGV4dFN0cm9rZVN0YXRlLmxpbmVEYXNoT2Zmc2V0ID0gc3Ryb2tlU3RhdGUubGluZURhc2hPZmZzZXQ7XG4gICAgICAgIGNvbnRleHQubGluZURhc2hPZmZzZXQgPSBzdHJva2VTdGF0ZS5saW5lRGFzaE9mZnNldDtcbiAgICAgIH1cbiAgICAgIGlmIChjb250ZXh0U3Ryb2tlU3RhdGUubGluZUpvaW4gIT0gc3Ryb2tlU3RhdGUubGluZUpvaW4pIHtcbiAgICAgICAgY29udGV4dFN0cm9rZVN0YXRlLmxpbmVKb2luID0gc3Ryb2tlU3RhdGUubGluZUpvaW47XG4gICAgICAgIGNvbnRleHQubGluZUpvaW4gPSBzdHJva2VTdGF0ZS5saW5lSm9pbjtcbiAgICAgIH1cbiAgICAgIGlmIChjb250ZXh0U3Ryb2tlU3RhdGUubGluZVdpZHRoICE9IHN0cm9rZVN0YXRlLmxpbmVXaWR0aCkge1xuICAgICAgICBjb250ZXh0U3Ryb2tlU3RhdGUubGluZVdpZHRoID0gc3Ryb2tlU3RhdGUubGluZVdpZHRoO1xuICAgICAgICBjb250ZXh0LmxpbmVXaWR0aCA9IHN0cm9rZVN0YXRlLmxpbmVXaWR0aDtcbiAgICAgIH1cbiAgICAgIGlmIChjb250ZXh0U3Ryb2tlU3RhdGUubWl0ZXJMaW1pdCAhPSBzdHJva2VTdGF0ZS5taXRlckxpbWl0KSB7XG4gICAgICAgIGNvbnRleHRTdHJva2VTdGF0ZS5taXRlckxpbWl0ID0gc3Ryb2tlU3RhdGUubWl0ZXJMaW1pdDtcbiAgICAgICAgY29udGV4dC5taXRlckxpbWl0ID0gc3Ryb2tlU3RhdGUubWl0ZXJMaW1pdDtcbiAgICAgIH1cbiAgICAgIGlmIChjb250ZXh0U3Ryb2tlU3RhdGUuc3Ryb2tlU3R5bGUgIT0gc3Ryb2tlU3RhdGUuc3Ryb2tlU3R5bGUpIHtcbiAgICAgICAgY29udGV4dFN0cm9rZVN0YXRlLnN0cm9rZVN0eWxlID0gc3Ryb2tlU3RhdGUuc3Ryb2tlU3R5bGU7XG4gICAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBzdHJva2VTdGF0ZS5zdHJva2VTdHlsZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jYW52YXMuanNcIikuVGV4dFN0YXRlfSB0ZXh0U3RhdGUgVGV4dCBzdGF0ZS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHNldENvbnRleHRUZXh0U3RhdGVfKHRleHRTdGF0ZSkge1xuICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLmNvbnRleHRfO1xuICAgIGNvbnN0IGNvbnRleHRUZXh0U3RhdGUgPSB0aGlzLmNvbnRleHRUZXh0U3RhdGVfO1xuICAgIGNvbnN0IHRleHRBbGlnbiA9IHRleHRTdGF0ZS50ZXh0QWxpZ25cbiAgICAgID8gdGV4dFN0YXRlLnRleHRBbGlnblxuICAgICAgOiBkZWZhdWx0VGV4dEFsaWduO1xuICAgIGlmICghY29udGV4dFRleHRTdGF0ZSkge1xuICAgICAgY29udGV4dC5mb250ID0gdGV4dFN0YXRlLmZvbnQ7XG4gICAgICBjb250ZXh0LnRleHRBbGlnbiA9IHRleHRBbGlnbjtcbiAgICAgIGNvbnRleHQudGV4dEJhc2VsaW5lID0gdGV4dFN0YXRlLnRleHRCYXNlbGluZTtcbiAgICAgIHRoaXMuY29udGV4dFRleHRTdGF0ZV8gPSB7XG4gICAgICAgIGZvbnQ6IHRleHRTdGF0ZS5mb250LFxuICAgICAgICB0ZXh0QWxpZ246IHRleHRBbGlnbixcbiAgICAgICAgdGV4dEJhc2VsaW5lOiB0ZXh0U3RhdGUudGV4dEJhc2VsaW5lLFxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGNvbnRleHRUZXh0U3RhdGUuZm9udCAhPSB0ZXh0U3RhdGUuZm9udCkge1xuICAgICAgICBjb250ZXh0VGV4dFN0YXRlLmZvbnQgPSB0ZXh0U3RhdGUuZm9udDtcbiAgICAgICAgY29udGV4dC5mb250ID0gdGV4dFN0YXRlLmZvbnQ7XG4gICAgICB9XG4gICAgICBpZiAoY29udGV4dFRleHRTdGF0ZS50ZXh0QWxpZ24gIT0gdGV4dEFsaWduKSB7XG4gICAgICAgIGNvbnRleHRUZXh0U3RhdGUudGV4dEFsaWduID0gdGV4dEFsaWduO1xuICAgICAgICBjb250ZXh0LnRleHRBbGlnbiA9IHRleHRBbGlnbjtcbiAgICAgIH1cbiAgICAgIGlmIChjb250ZXh0VGV4dFN0YXRlLnRleHRCYXNlbGluZSAhPSB0ZXh0U3RhdGUudGV4dEJhc2VsaW5lKSB7XG4gICAgICAgIGNvbnRleHRUZXh0U3RhdGUudGV4dEJhc2VsaW5lID0gdGV4dFN0YXRlLnRleHRCYXNlbGluZTtcbiAgICAgICAgY29udGV4dC50ZXh0QmFzZWxpbmUgPSB0ZXh0U3RhdGUudGV4dEJhc2VsaW5lO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGZpbGwgYW5kIHN0cm9rZSBzdHlsZSBmb3Igc3Vic2VxdWVudCBkcmF3IG9wZXJhdGlvbnMuICBUbyBjbGVhclxuICAgKiBlaXRoZXIgZmlsbCBvciBzdHJva2Ugc3R5bGVzLCBwYXNzIG51bGwgZm9yIHRoZSBhcHByb3ByaWF0ZSBwYXJhbWV0ZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vc3R5bGUvRmlsbC5qc1wiKS5kZWZhdWx0fSBmaWxsU3R5bGUgRmlsbCBzdHlsZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9zdHlsZS9TdHJva2UuanNcIikuZGVmYXVsdH0gc3Ryb2tlU3R5bGUgU3Ryb2tlIHN0eWxlLlxuICAgKi9cbiAgc2V0RmlsbFN0cm9rZVN0eWxlKGZpbGxTdHlsZSwgc3Ryb2tlU3R5bGUpIHtcbiAgICBpZiAoIWZpbGxTdHlsZSkge1xuICAgICAgdGhpcy5maWxsU3RhdGVfID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgZmlsbFN0eWxlQ29sb3IgPSBmaWxsU3R5bGUuZ2V0Q29sb3IoKTtcbiAgICAgIHRoaXMuZmlsbFN0YXRlXyA9IHtcbiAgICAgICAgZmlsbFN0eWxlOiBhc0NvbG9yTGlrZShcbiAgICAgICAgICBmaWxsU3R5bGVDb2xvciA/IGZpbGxTdHlsZUNvbG9yIDogZGVmYXVsdEZpbGxTdHlsZVxuICAgICAgICApLFxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKCFzdHJva2VTdHlsZSkge1xuICAgICAgdGhpcy5zdHJva2VTdGF0ZV8gPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBzdHJva2VTdHlsZUNvbG9yID0gc3Ryb2tlU3R5bGUuZ2V0Q29sb3IoKTtcbiAgICAgIGNvbnN0IHN0cm9rZVN0eWxlTGluZUNhcCA9IHN0cm9rZVN0eWxlLmdldExpbmVDYXAoKTtcbiAgICAgIGNvbnN0IHN0cm9rZVN0eWxlTGluZURhc2ggPSBzdHJva2VTdHlsZS5nZXRMaW5lRGFzaCgpO1xuICAgICAgY29uc3Qgc3Ryb2tlU3R5bGVMaW5lRGFzaE9mZnNldCA9IHN0cm9rZVN0eWxlLmdldExpbmVEYXNoT2Zmc2V0KCk7XG4gICAgICBjb25zdCBzdHJva2VTdHlsZUxpbmVKb2luID0gc3Ryb2tlU3R5bGUuZ2V0TGluZUpvaW4oKTtcbiAgICAgIGNvbnN0IHN0cm9rZVN0eWxlV2lkdGggPSBzdHJva2VTdHlsZS5nZXRXaWR0aCgpO1xuICAgICAgY29uc3Qgc3Ryb2tlU3R5bGVNaXRlckxpbWl0ID0gc3Ryb2tlU3R5bGUuZ2V0TWl0ZXJMaW1pdCgpO1xuICAgICAgY29uc3QgbGluZURhc2ggPSBzdHJva2VTdHlsZUxpbmVEYXNoXG4gICAgICAgID8gc3Ryb2tlU3R5bGVMaW5lRGFzaFxuICAgICAgICA6IGRlZmF1bHRMaW5lRGFzaDtcbiAgICAgIHRoaXMuc3Ryb2tlU3RhdGVfID0ge1xuICAgICAgICBsaW5lQ2FwOlxuICAgICAgICAgIHN0cm9rZVN0eWxlTGluZUNhcCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IHN0cm9rZVN0eWxlTGluZUNhcFxuICAgICAgICAgICAgOiBkZWZhdWx0TGluZUNhcCxcbiAgICAgICAgbGluZURhc2g6XG4gICAgICAgICAgdGhpcy5waXhlbFJhdGlvXyA9PT0gMVxuICAgICAgICAgICAgPyBsaW5lRGFzaFxuICAgICAgICAgICAgOiBsaW5lRGFzaC5tYXAoKG4pID0+IG4gKiB0aGlzLnBpeGVsUmF0aW9fKSxcbiAgICAgICAgbGluZURhc2hPZmZzZXQ6XG4gICAgICAgICAgKHN0cm9rZVN0eWxlTGluZURhc2hPZmZzZXRcbiAgICAgICAgICAgID8gc3Ryb2tlU3R5bGVMaW5lRGFzaE9mZnNldFxuICAgICAgICAgICAgOiBkZWZhdWx0TGluZURhc2hPZmZzZXQpICogdGhpcy5waXhlbFJhdGlvXyxcbiAgICAgICAgbGluZUpvaW46XG4gICAgICAgICAgc3Ryb2tlU3R5bGVMaW5lSm9pbiAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IHN0cm9rZVN0eWxlTGluZUpvaW5cbiAgICAgICAgICAgIDogZGVmYXVsdExpbmVKb2luLFxuICAgICAgICBsaW5lV2lkdGg6XG4gICAgICAgICAgKHN0cm9rZVN0eWxlV2lkdGggIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyBzdHJva2VTdHlsZVdpZHRoXG4gICAgICAgICAgICA6IGRlZmF1bHRMaW5lV2lkdGgpICogdGhpcy5waXhlbFJhdGlvXyxcbiAgICAgICAgbWl0ZXJMaW1pdDpcbiAgICAgICAgICBzdHJva2VTdHlsZU1pdGVyTGltaXQgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyBzdHJva2VTdHlsZU1pdGVyTGltaXRcbiAgICAgICAgICAgIDogZGVmYXVsdE1pdGVyTGltaXQsXG4gICAgICAgIHN0cm9rZVN0eWxlOiBhc0NvbG9yTGlrZShcbiAgICAgICAgICBzdHJva2VTdHlsZUNvbG9yID8gc3Ryb2tlU3R5bGVDb2xvciA6IGRlZmF1bHRTdHJva2VTdHlsZVxuICAgICAgICApLFxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBpbWFnZSBzdHlsZSBmb3Igc3Vic2VxdWVudCBkcmF3IG9wZXJhdGlvbnMuICBQYXNzIG51bGwgdG8gcmVtb3ZlXG4gICAqIHRoZSBpbWFnZSBzdHlsZS5cbiAgICpcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9zdHlsZS9JbWFnZS5qc1wiKS5kZWZhdWx0fSBpbWFnZVN0eWxlIEltYWdlIHN0eWxlLlxuICAgKi9cbiAgc2V0SW1hZ2VTdHlsZShpbWFnZVN0eWxlKSB7XG4gICAgbGV0IGltYWdlU2l6ZTtcbiAgICBpZiAoIWltYWdlU3R5bGUgfHwgIShpbWFnZVNpemUgPSBpbWFnZVN0eWxlLmdldFNpemUoKSkpIHtcbiAgICAgIHRoaXMuaW1hZ2VfID0gbnVsbDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaW1hZ2VQaXhlbFJhdGlvID0gaW1hZ2VTdHlsZS5nZXRQaXhlbFJhdGlvKHRoaXMucGl4ZWxSYXRpb18pO1xuICAgIGNvbnN0IGltYWdlQW5jaG9yID0gaW1hZ2VTdHlsZS5nZXRBbmNob3IoKTtcbiAgICBjb25zdCBpbWFnZU9yaWdpbiA9IGltYWdlU3R5bGUuZ2V0T3JpZ2luKCk7XG4gICAgdGhpcy5pbWFnZV8gPSBpbWFnZVN0eWxlLmdldEltYWdlKHRoaXMucGl4ZWxSYXRpb18pO1xuICAgIHRoaXMuaW1hZ2VBbmNob3JYXyA9IGltYWdlQW5jaG9yWzBdICogaW1hZ2VQaXhlbFJhdGlvO1xuICAgIHRoaXMuaW1hZ2VBbmNob3JZXyA9IGltYWdlQW5jaG9yWzFdICogaW1hZ2VQaXhlbFJhdGlvO1xuICAgIHRoaXMuaW1hZ2VIZWlnaHRfID0gaW1hZ2VTaXplWzFdICogaW1hZ2VQaXhlbFJhdGlvO1xuICAgIHRoaXMuaW1hZ2VPcGFjaXR5XyA9IGltYWdlU3R5bGUuZ2V0T3BhY2l0eSgpO1xuICAgIHRoaXMuaW1hZ2VPcmlnaW5YXyA9IGltYWdlT3JpZ2luWzBdO1xuICAgIHRoaXMuaW1hZ2VPcmlnaW5ZXyA9IGltYWdlT3JpZ2luWzFdO1xuICAgIHRoaXMuaW1hZ2VSb3RhdGVXaXRoVmlld18gPSBpbWFnZVN0eWxlLmdldFJvdGF0ZVdpdGhWaWV3KCk7XG4gICAgdGhpcy5pbWFnZVJvdGF0aW9uXyA9IGltYWdlU3R5bGUuZ2V0Um90YXRpb24oKTtcbiAgICBjb25zdCBpbWFnZVNjYWxlID0gaW1hZ2VTdHlsZS5nZXRTY2FsZUFycmF5KCk7XG4gICAgdGhpcy5pbWFnZVNjYWxlXyA9IFtcbiAgICAgIChpbWFnZVNjYWxlWzBdICogdGhpcy5waXhlbFJhdGlvXykgLyBpbWFnZVBpeGVsUmF0aW8sXG4gICAgICAoaW1hZ2VTY2FsZVsxXSAqIHRoaXMucGl4ZWxSYXRpb18pIC8gaW1hZ2VQaXhlbFJhdGlvLFxuICAgIF07XG4gICAgdGhpcy5pbWFnZVdpZHRoXyA9IGltYWdlU2l6ZVswXSAqIGltYWdlUGl4ZWxSYXRpbztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHRleHQgc3R5bGUgZm9yIHN1YnNlcXVlbnQgZHJhdyBvcGVyYXRpb25zLiAgUGFzcyBudWxsIHRvXG4gICAqIHJlbW92ZSB0aGUgdGV4dCBzdHlsZS5cbiAgICpcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9zdHlsZS9UZXh0LmpzXCIpLmRlZmF1bHR9IHRleHRTdHlsZSBUZXh0IHN0eWxlLlxuICAgKi9cbiAgc2V0VGV4dFN0eWxlKHRleHRTdHlsZSkge1xuICAgIGlmICghdGV4dFN0eWxlKSB7XG4gICAgICB0aGlzLnRleHRfID0gJyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHRleHRGaWxsU3R5bGUgPSB0ZXh0U3R5bGUuZ2V0RmlsbCgpO1xuICAgICAgaWYgKCF0ZXh0RmlsbFN0eWxlKSB7XG4gICAgICAgIHRoaXMudGV4dEZpbGxTdGF0ZV8gPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgdGV4dEZpbGxTdHlsZUNvbG9yID0gdGV4dEZpbGxTdHlsZS5nZXRDb2xvcigpO1xuICAgICAgICB0aGlzLnRleHRGaWxsU3RhdGVfID0ge1xuICAgICAgICAgIGZpbGxTdHlsZTogYXNDb2xvckxpa2UoXG4gICAgICAgICAgICB0ZXh0RmlsbFN0eWxlQ29sb3IgPyB0ZXh0RmlsbFN0eWxlQ29sb3IgOiBkZWZhdWx0RmlsbFN0eWxlXG4gICAgICAgICAgKSxcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRleHRTdHJva2VTdHlsZSA9IHRleHRTdHlsZS5nZXRTdHJva2UoKTtcbiAgICAgIGlmICghdGV4dFN0cm9rZVN0eWxlKSB7XG4gICAgICAgIHRoaXMudGV4dFN0cm9rZVN0YXRlXyA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB0ZXh0U3Ryb2tlU3R5bGVDb2xvciA9IHRleHRTdHJva2VTdHlsZS5nZXRDb2xvcigpO1xuICAgICAgICBjb25zdCB0ZXh0U3Ryb2tlU3R5bGVMaW5lQ2FwID0gdGV4dFN0cm9rZVN0eWxlLmdldExpbmVDYXAoKTtcbiAgICAgICAgY29uc3QgdGV4dFN0cm9rZVN0eWxlTGluZURhc2ggPSB0ZXh0U3Ryb2tlU3R5bGUuZ2V0TGluZURhc2goKTtcbiAgICAgICAgY29uc3QgdGV4dFN0cm9rZVN0eWxlTGluZURhc2hPZmZzZXQgPVxuICAgICAgICAgIHRleHRTdHJva2VTdHlsZS5nZXRMaW5lRGFzaE9mZnNldCgpO1xuICAgICAgICBjb25zdCB0ZXh0U3Ryb2tlU3R5bGVMaW5lSm9pbiA9IHRleHRTdHJva2VTdHlsZS5nZXRMaW5lSm9pbigpO1xuICAgICAgICBjb25zdCB0ZXh0U3Ryb2tlU3R5bGVXaWR0aCA9IHRleHRTdHJva2VTdHlsZS5nZXRXaWR0aCgpO1xuICAgICAgICBjb25zdCB0ZXh0U3Ryb2tlU3R5bGVNaXRlckxpbWl0ID0gdGV4dFN0cm9rZVN0eWxlLmdldE1pdGVyTGltaXQoKTtcbiAgICAgICAgdGhpcy50ZXh0U3Ryb2tlU3RhdGVfID0ge1xuICAgICAgICAgIGxpbmVDYXA6XG4gICAgICAgICAgICB0ZXh0U3Ryb2tlU3R5bGVMaW5lQ2FwICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgPyB0ZXh0U3Ryb2tlU3R5bGVMaW5lQ2FwXG4gICAgICAgICAgICAgIDogZGVmYXVsdExpbmVDYXAsXG4gICAgICAgICAgbGluZURhc2g6IHRleHRTdHJva2VTdHlsZUxpbmVEYXNoXG4gICAgICAgICAgICA/IHRleHRTdHJva2VTdHlsZUxpbmVEYXNoXG4gICAgICAgICAgICA6IGRlZmF1bHRMaW5lRGFzaCxcbiAgICAgICAgICBsaW5lRGFzaE9mZnNldDogdGV4dFN0cm9rZVN0eWxlTGluZURhc2hPZmZzZXRcbiAgICAgICAgICAgID8gdGV4dFN0cm9rZVN0eWxlTGluZURhc2hPZmZzZXRcbiAgICAgICAgICAgIDogZGVmYXVsdExpbmVEYXNoT2Zmc2V0LFxuICAgICAgICAgIGxpbmVKb2luOlxuICAgICAgICAgICAgdGV4dFN0cm9rZVN0eWxlTGluZUpvaW4gIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICA/IHRleHRTdHJva2VTdHlsZUxpbmVKb2luXG4gICAgICAgICAgICAgIDogZGVmYXVsdExpbmVKb2luLFxuICAgICAgICAgIGxpbmVXaWR0aDpcbiAgICAgICAgICAgIHRleHRTdHJva2VTdHlsZVdpZHRoICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgPyB0ZXh0U3Ryb2tlU3R5bGVXaWR0aFxuICAgICAgICAgICAgICA6IGRlZmF1bHRMaW5lV2lkdGgsXG4gICAgICAgICAgbWl0ZXJMaW1pdDpcbiAgICAgICAgICAgIHRleHRTdHJva2VTdHlsZU1pdGVyTGltaXQgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICA/IHRleHRTdHJva2VTdHlsZU1pdGVyTGltaXRcbiAgICAgICAgICAgICAgOiBkZWZhdWx0TWl0ZXJMaW1pdCxcbiAgICAgICAgICBzdHJva2VTdHlsZTogYXNDb2xvckxpa2UoXG4gICAgICAgICAgICB0ZXh0U3Ryb2tlU3R5bGVDb2xvciA/IHRleHRTdHJva2VTdHlsZUNvbG9yIDogZGVmYXVsdFN0cm9rZVN0eWxlXG4gICAgICAgICAgKSxcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRleHRGb250ID0gdGV4dFN0eWxlLmdldEZvbnQoKTtcbiAgICAgIGNvbnN0IHRleHRPZmZzZXRYID0gdGV4dFN0eWxlLmdldE9mZnNldFgoKTtcbiAgICAgIGNvbnN0IHRleHRPZmZzZXRZID0gdGV4dFN0eWxlLmdldE9mZnNldFkoKTtcbiAgICAgIGNvbnN0IHRleHRSb3RhdGVXaXRoVmlldyA9IHRleHRTdHlsZS5nZXRSb3RhdGVXaXRoVmlldygpO1xuICAgICAgY29uc3QgdGV4dFJvdGF0aW9uID0gdGV4dFN0eWxlLmdldFJvdGF0aW9uKCk7XG4gICAgICBjb25zdCB0ZXh0U2NhbGUgPSB0ZXh0U3R5bGUuZ2V0U2NhbGVBcnJheSgpO1xuICAgICAgY29uc3QgdGV4dFRleHQgPSB0ZXh0U3R5bGUuZ2V0VGV4dCgpO1xuICAgICAgY29uc3QgdGV4dFRleHRBbGlnbiA9IHRleHRTdHlsZS5nZXRUZXh0QWxpZ24oKTtcbiAgICAgIGNvbnN0IHRleHRUZXh0QmFzZWxpbmUgPSB0ZXh0U3R5bGUuZ2V0VGV4dEJhc2VsaW5lKCk7XG4gICAgICB0aGlzLnRleHRTdGF0ZV8gPSB7XG4gICAgICAgIGZvbnQ6IHRleHRGb250ICE9PSB1bmRlZmluZWQgPyB0ZXh0Rm9udCA6IGRlZmF1bHRGb250LFxuICAgICAgICB0ZXh0QWxpZ246XG4gICAgICAgICAgdGV4dFRleHRBbGlnbiAhPT0gdW5kZWZpbmVkID8gdGV4dFRleHRBbGlnbiA6IGRlZmF1bHRUZXh0QWxpZ24sXG4gICAgICAgIHRleHRCYXNlbGluZTpcbiAgICAgICAgICB0ZXh0VGV4dEJhc2VsaW5lICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gdGV4dFRleHRCYXNlbGluZVxuICAgICAgICAgICAgOiBkZWZhdWx0VGV4dEJhc2VsaW5lLFxuICAgICAgfTtcbiAgICAgIHRoaXMudGV4dF8gPVxuICAgICAgICB0ZXh0VGV4dCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgPyBBcnJheS5pc0FycmF5KHRleHRUZXh0KVxuICAgICAgICAgICAgPyB0ZXh0VGV4dC5yZWR1Y2UoKGFjYywgdCwgaSkgPT4gKGFjYyArPSBpICUgMiA/ICcgJyA6IHQpLCAnJylcbiAgICAgICAgICAgIDogdGV4dFRleHRcbiAgICAgICAgICA6ICcnO1xuICAgICAgdGhpcy50ZXh0T2Zmc2V0WF8gPVxuICAgICAgICB0ZXh0T2Zmc2V0WCAhPT0gdW5kZWZpbmVkID8gdGhpcy5waXhlbFJhdGlvXyAqIHRleHRPZmZzZXRYIDogMDtcbiAgICAgIHRoaXMudGV4dE9mZnNldFlfID1cbiAgICAgICAgdGV4dE9mZnNldFkgIT09IHVuZGVmaW5lZCA/IHRoaXMucGl4ZWxSYXRpb18gKiB0ZXh0T2Zmc2V0WSA6IDA7XG4gICAgICB0aGlzLnRleHRSb3RhdGVXaXRoVmlld18gPVxuICAgICAgICB0ZXh0Um90YXRlV2l0aFZpZXcgIT09IHVuZGVmaW5lZCA/IHRleHRSb3RhdGVXaXRoVmlldyA6IGZhbHNlO1xuICAgICAgdGhpcy50ZXh0Um90YXRpb25fID0gdGV4dFJvdGF0aW9uICE9PSB1bmRlZmluZWQgPyB0ZXh0Um90YXRpb24gOiAwO1xuICAgICAgdGhpcy50ZXh0U2NhbGVfID0gW1xuICAgICAgICB0aGlzLnBpeGVsUmF0aW9fICogdGV4dFNjYWxlWzBdLFxuICAgICAgICB0aGlzLnBpeGVsUmF0aW9fICogdGV4dFNjYWxlWzFdLFxuICAgICAgXTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQ2FudmFzSW1tZWRpYXRlUmVuZGVyZXI7XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvcmVuZGVyL2NhbnZhcy9JbnN0cnVjdGlvblxuICovXG5cbi8qKlxuICogQGVudW0ge251bWJlcn1cbiAqL1xuY29uc3QgSW5zdHJ1Y3Rpb24gPSB7XG4gIEJFR0lOX0dFT01FVFJZOiAwLFxuICBCRUdJTl9QQVRIOiAxLFxuICBDSVJDTEU6IDIsXG4gIENMT1NFX1BBVEg6IDMsXG4gIENVU1RPTTogNCxcbiAgRFJBV19DSEFSUzogNSxcbiAgRFJBV19JTUFHRTogNixcbiAgRU5EX0dFT01FVFJZOiA3LFxuICBGSUxMOiA4LFxuICBNT1ZFX1RPX0xJTkVfVE86IDksXG4gIFNFVF9GSUxMX1NUWUxFOiAxMCxcbiAgU0VUX1NUUk9LRV9TVFlMRTogMTEsXG4gIFNUUk9LRTogMTIsXG59O1xuXG4vKipcbiAqIEB0eXBlIHtBcnJheTxJbnN0cnVjdGlvbj59XG4gKi9cbmV4cG9ydCBjb25zdCBmaWxsSW5zdHJ1Y3Rpb24gPSBbSW5zdHJ1Y3Rpb24uRklMTF07XG5cbi8qKlxuICogQHR5cGUge0FycmF5PEluc3RydWN0aW9uPn1cbiAqL1xuZXhwb3J0IGNvbnN0IHN0cm9rZUluc3RydWN0aW9uID0gW0luc3RydWN0aW9uLlNUUk9LRV07XG5cbi8qKlxuICogQHR5cGUge0FycmF5PEluc3RydWN0aW9uPn1cbiAqL1xuZXhwb3J0IGNvbnN0IGJlZ2luUGF0aEluc3RydWN0aW9uID0gW0luc3RydWN0aW9uLkJFR0lOX1BBVEhdO1xuXG4vKipcbiAqIEB0eXBlIHtBcnJheTxJbnN0cnVjdGlvbj59XG4gKi9cbmV4cG9ydCBjb25zdCBjbG9zZVBhdGhJbnN0cnVjdGlvbiA9IFtJbnN0cnVjdGlvbi5DTE9TRV9QQVRIXTtcblxuZXhwb3J0IGRlZmF1bHQgSW5zdHJ1Y3Rpb247XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvcmVuZGVyL2NhbnZhcy9MaW5lU3RyaW5nQnVpbGRlclxuICovXG5pbXBvcnQgQ2FudmFzQnVpbGRlciBmcm9tICcuL0J1aWxkZXIuanMnO1xuaW1wb3J0IENhbnZhc0luc3RydWN0aW9uLCB7XG4gIGJlZ2luUGF0aEluc3RydWN0aW9uLFxuICBzdHJva2VJbnN0cnVjdGlvbixcbn0gZnJvbSAnLi9JbnN0cnVjdGlvbi5qcyc7XG5pbXBvcnQge2RlZmF1bHRMaW5lRGFzaCwgZGVmYXVsdExpbmVEYXNoT2Zmc2V0fSBmcm9tICcuLi9jYW52YXMuanMnO1xuXG5jbGFzcyBDYW52YXNMaW5lU3RyaW5nQnVpbGRlciBleHRlbmRzIENhbnZhc0J1aWxkZXIge1xuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHRvbGVyYW5jZSBUb2xlcmFuY2UuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gbWF4RXh0ZW50IE1heGltdW0gZXh0ZW50LlxuICAgKiBAcGFyYW0ge251bWJlcn0gcmVzb2x1dGlvbiBSZXNvbHV0aW9uLlxuICAgKiBAcGFyYW0ge251bWJlcn0gcGl4ZWxSYXRpbyBQaXhlbCByYXRpby5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHRvbGVyYW5jZSwgbWF4RXh0ZW50LCByZXNvbHV0aW9uLCBwaXhlbFJhdGlvKSB7XG4gICAgc3VwZXIodG9sZXJhbmNlLCBtYXhFeHRlbnQsIHJlc29sdXRpb24sIHBpeGVsUmF0aW8pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICAgKiBAcGFyYW0ge251bWJlcn0gZW5kIEVuZC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gICAqIEBwcml2YXRlXG4gICAqIEByZXR1cm4ge251bWJlcn0gZW5kLlxuICAgKi9cbiAgZHJhd0ZsYXRDb29yZGluYXRlc18oZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZCwgc3RyaWRlKSB7XG4gICAgY29uc3QgbXlCZWdpbiA9IHRoaXMuY29vcmRpbmF0ZXMubGVuZ3RoO1xuICAgIGNvbnN0IG15RW5kID0gdGhpcy5hcHBlbmRGbGF0TGluZUNvb3JkaW5hdGVzKFxuICAgICAgZmxhdENvb3JkaW5hdGVzLFxuICAgICAgb2Zmc2V0LFxuICAgICAgZW5kLFxuICAgICAgc3RyaWRlLFxuICAgICAgZmFsc2UsXG4gICAgICBmYWxzZVxuICAgICk7XG4gICAgY29uc3QgbW92ZVRvTGluZVRvSW5zdHJ1Y3Rpb24gPSBbXG4gICAgICBDYW52YXNJbnN0cnVjdGlvbi5NT1ZFX1RPX0xJTkVfVE8sXG4gICAgICBteUJlZ2luLFxuICAgICAgbXlFbmQsXG4gICAgXTtcbiAgICB0aGlzLmluc3RydWN0aW9ucy5wdXNoKG1vdmVUb0xpbmVUb0luc3RydWN0aW9uKTtcbiAgICB0aGlzLmhpdERldGVjdGlvbkluc3RydWN0aW9ucy5wdXNoKG1vdmVUb0xpbmVUb0luc3RydWN0aW9uKTtcbiAgICByZXR1cm4gZW5kO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vZ2VvbS9MaW5lU3RyaW5nLmpzXCIpLmRlZmF1bHR8aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0fSBsaW5lU3RyaW5nR2VvbWV0cnkgTGluZSBzdHJpbmcgZ2VvbWV0cnkuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vRmVhdHVyZS5qc1wiKS5GZWF0dXJlTGlrZX0gZmVhdHVyZSBGZWF0dXJlLlxuICAgKi9cbiAgZHJhd0xpbmVTdHJpbmcobGluZVN0cmluZ0dlb21ldHJ5LCBmZWF0dXJlKSB7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgIGNvbnN0IHN0cm9rZVN0eWxlID0gc3RhdGUuc3Ryb2tlU3R5bGU7XG4gICAgY29uc3QgbGluZVdpZHRoID0gc3RhdGUubGluZVdpZHRoO1xuICAgIGlmIChzdHJva2VTdHlsZSA9PT0gdW5kZWZpbmVkIHx8IGxpbmVXaWR0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMudXBkYXRlU3Ryb2tlU3R5bGUoc3RhdGUsIHRoaXMuYXBwbHlTdHJva2UpO1xuICAgIHRoaXMuYmVnaW5HZW9tZXRyeShsaW5lU3RyaW5nR2VvbWV0cnksIGZlYXR1cmUpO1xuICAgIHRoaXMuaGl0RGV0ZWN0aW9uSW5zdHJ1Y3Rpb25zLnB1c2goXG4gICAgICBbXG4gICAgICAgIENhbnZhc0luc3RydWN0aW9uLlNFVF9TVFJPS0VfU1RZTEUsXG4gICAgICAgIHN0YXRlLnN0cm9rZVN0eWxlLFxuICAgICAgICBzdGF0ZS5saW5lV2lkdGgsXG4gICAgICAgIHN0YXRlLmxpbmVDYXAsXG4gICAgICAgIHN0YXRlLmxpbmVKb2luLFxuICAgICAgICBzdGF0ZS5taXRlckxpbWl0LFxuICAgICAgICBkZWZhdWx0TGluZURhc2gsXG4gICAgICAgIGRlZmF1bHRMaW5lRGFzaE9mZnNldCxcbiAgICAgIF0sXG4gICAgICBiZWdpblBhdGhJbnN0cnVjdGlvblxuICAgICk7XG4gICAgY29uc3QgZmxhdENvb3JkaW5hdGVzID0gbGluZVN0cmluZ0dlb21ldHJ5LmdldEZsYXRDb29yZGluYXRlcygpO1xuICAgIGNvbnN0IHN0cmlkZSA9IGxpbmVTdHJpbmdHZW9tZXRyeS5nZXRTdHJpZGUoKTtcbiAgICB0aGlzLmRyYXdGbGF0Q29vcmRpbmF0ZXNfKFxuICAgICAgZmxhdENvb3JkaW5hdGVzLFxuICAgICAgMCxcbiAgICAgIGZsYXRDb29yZGluYXRlcy5sZW5ndGgsXG4gICAgICBzdHJpZGVcbiAgICApO1xuICAgIHRoaXMuaGl0RGV0ZWN0aW9uSW5zdHJ1Y3Rpb25zLnB1c2goc3Ryb2tlSW5zdHJ1Y3Rpb24pO1xuICAgIHRoaXMuZW5kR2VvbWV0cnkoZmVhdHVyZSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9nZW9tL011bHRpTGluZVN0cmluZy5qc1wiKS5kZWZhdWx0fGltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdH0gbXVsdGlMaW5lU3RyaW5nR2VvbWV0cnkgTXVsdGlMaW5lU3RyaW5nIGdlb21ldHJ5LlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL0ZlYXR1cmUuanNcIikuRmVhdHVyZUxpa2V9IGZlYXR1cmUgRmVhdHVyZS5cbiAgICovXG4gIGRyYXdNdWx0aUxpbmVTdHJpbmcobXVsdGlMaW5lU3RyaW5nR2VvbWV0cnksIGZlYXR1cmUpIHtcbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3Qgc3Ryb2tlU3R5bGUgPSBzdGF0ZS5zdHJva2VTdHlsZTtcbiAgICBjb25zdCBsaW5lV2lkdGggPSBzdGF0ZS5saW5lV2lkdGg7XG4gICAgaWYgKHN0cm9rZVN0eWxlID09PSB1bmRlZmluZWQgfHwgbGluZVdpZHRoID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy51cGRhdGVTdHJva2VTdHlsZShzdGF0ZSwgdGhpcy5hcHBseVN0cm9rZSk7XG4gICAgdGhpcy5iZWdpbkdlb21ldHJ5KG11bHRpTGluZVN0cmluZ0dlb21ldHJ5LCBmZWF0dXJlKTtcbiAgICB0aGlzLmhpdERldGVjdGlvbkluc3RydWN0aW9ucy5wdXNoKFxuICAgICAgW1xuICAgICAgICBDYW52YXNJbnN0cnVjdGlvbi5TRVRfU1RST0tFX1NUWUxFLFxuICAgICAgICBzdGF0ZS5zdHJva2VTdHlsZSxcbiAgICAgICAgc3RhdGUubGluZVdpZHRoLFxuICAgICAgICBzdGF0ZS5saW5lQ2FwLFxuICAgICAgICBzdGF0ZS5saW5lSm9pbixcbiAgICAgICAgc3RhdGUubWl0ZXJMaW1pdCxcbiAgICAgICAgZGVmYXVsdExpbmVEYXNoLFxuICAgICAgICBkZWZhdWx0TGluZURhc2hPZmZzZXQsXG4gICAgICBdLFxuICAgICAgYmVnaW5QYXRoSW5zdHJ1Y3Rpb25cbiAgICApO1xuICAgIGNvbnN0IGVuZHMgPSBtdWx0aUxpbmVTdHJpbmdHZW9tZXRyeS5nZXRFbmRzKCk7XG4gICAgY29uc3QgZmxhdENvb3JkaW5hdGVzID0gbXVsdGlMaW5lU3RyaW5nR2VvbWV0cnkuZ2V0RmxhdENvb3JkaW5hdGVzKCk7XG4gICAgY29uc3Qgc3RyaWRlID0gbXVsdGlMaW5lU3RyaW5nR2VvbWV0cnkuZ2V0U3RyaWRlKCk7XG4gICAgbGV0IG9mZnNldCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gZW5kcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICBvZmZzZXQgPSB0aGlzLmRyYXdGbGF0Q29vcmRpbmF0ZXNfKFxuICAgICAgICBmbGF0Q29vcmRpbmF0ZXMsXG4gICAgICAgIG9mZnNldCxcbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovIChlbmRzW2ldKSxcbiAgICAgICAgc3RyaWRlXG4gICAgICApO1xuICAgIH1cbiAgICB0aGlzLmhpdERldGVjdGlvbkluc3RydWN0aW9ucy5wdXNoKHN0cm9rZUluc3RydWN0aW9uKTtcbiAgICB0aGlzLmVuZEdlb21ldHJ5KGZlYXR1cmUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL2NhbnZhcy5qc1wiKS5TZXJpYWxpemFibGVJbnN0cnVjdGlvbnN9IHRoZSBzZXJpYWxpemFibGUgaW5zdHJ1Y3Rpb25zLlxuICAgKi9cbiAgZmluaXNoKCkge1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICBpZiAoXG4gICAgICBzdGF0ZS5sYXN0U3Ryb2tlICE9IHVuZGVmaW5lZCAmJlxuICAgICAgc3RhdGUubGFzdFN0cm9rZSAhPSB0aGlzLmNvb3JkaW5hdGVzLmxlbmd0aFxuICAgICkge1xuICAgICAgdGhpcy5pbnN0cnVjdGlvbnMucHVzaChzdHJva2VJbnN0cnVjdGlvbik7XG4gICAgfVxuICAgIHRoaXMucmV2ZXJzZUhpdERldGVjdGlvbkluc3RydWN0aW9ucygpO1xuICAgIHRoaXMuc3RhdGUgPSBudWxsO1xuICAgIHJldHVybiBzdXBlci5maW5pc2goKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2NhbnZhcy5qc1wiKS5GaWxsU3Ryb2tlU3RhdGV9IHN0YXRlIFN0YXRlLlxuICAgKi9cbiAgYXBwbHlTdHJva2Uoc3RhdGUpIHtcbiAgICBpZiAoXG4gICAgICBzdGF0ZS5sYXN0U3Ryb2tlICE9IHVuZGVmaW5lZCAmJlxuICAgICAgc3RhdGUubGFzdFN0cm9rZSAhPSB0aGlzLmNvb3JkaW5hdGVzLmxlbmd0aFxuICAgICkge1xuICAgICAgdGhpcy5pbnN0cnVjdGlvbnMucHVzaChzdHJva2VJbnN0cnVjdGlvbik7XG4gICAgICBzdGF0ZS5sYXN0U3Ryb2tlID0gdGhpcy5jb29yZGluYXRlcy5sZW5ndGg7XG4gICAgfVxuICAgIHN0YXRlLmxhc3RTdHJva2UgPSAwO1xuICAgIHN1cGVyLmFwcGx5U3Ryb2tlKHN0YXRlKTtcbiAgICB0aGlzLmluc3RydWN0aW9ucy5wdXNoKGJlZ2luUGF0aEluc3RydWN0aW9uKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBDYW52YXNMaW5lU3RyaW5nQnVpbGRlcjtcbiIsIi8qKlxuICogQG1vZHVsZSBvbC9yZW5kZXIvY2FudmFzL1BvbHlnb25CdWlsZGVyXG4gKi9cbmltcG9ydCBDYW52YXNCdWlsZGVyIGZyb20gJy4vQnVpbGRlci5qcyc7XG5pbXBvcnQgQ2FudmFzSW5zdHJ1Y3Rpb24sIHtcbiAgYmVnaW5QYXRoSW5zdHJ1Y3Rpb24sXG4gIGNsb3NlUGF0aEluc3RydWN0aW9uLFxuICBmaWxsSW5zdHJ1Y3Rpb24sXG4gIHN0cm9rZUluc3RydWN0aW9uLFxufSBmcm9tICcuL0luc3RydWN0aW9uLmpzJztcbmltcG9ydCB7XG4gIGRlZmF1bHRGaWxsU3R5bGUsXG4gIGRlZmF1bHRMaW5lRGFzaCxcbiAgZGVmYXVsdExpbmVEYXNoT2Zmc2V0LFxufSBmcm9tICcuLi9jYW52YXMuanMnO1xuaW1wb3J0IHtzbmFwfSBmcm9tICcuLi8uLi9nZW9tL2ZsYXQvc2ltcGxpZnkuanMnO1xuXG5jbGFzcyBDYW52YXNQb2x5Z29uQnVpbGRlciBleHRlbmRzIENhbnZhc0J1aWxkZXIge1xuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHRvbGVyYW5jZSBUb2xlcmFuY2UuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gbWF4RXh0ZW50IE1heGltdW0gZXh0ZW50LlxuICAgKiBAcGFyYW0ge251bWJlcn0gcmVzb2x1dGlvbiBSZXNvbHV0aW9uLlxuICAgKiBAcGFyYW0ge251bWJlcn0gcGl4ZWxSYXRpbyBQaXhlbCByYXRpby5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHRvbGVyYW5jZSwgbWF4RXh0ZW50LCByZXNvbHV0aW9uLCBwaXhlbFJhdGlvKSB7XG4gICAgc3VwZXIodG9sZXJhbmNlLCBtYXhFeHRlbnQsIHJlc29sdXRpb24sIHBpeGVsUmF0aW8pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICAgKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGVuZHMgRW5kcy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gICAqIEBwcml2YXRlXG4gICAqIEByZXR1cm4ge251bWJlcn0gRW5kLlxuICAgKi9cbiAgZHJhd0ZsYXRDb29yZGluYXRlc3NfKGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmRzLCBzdHJpZGUpIHtcbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3QgZmlsbCA9IHN0YXRlLmZpbGxTdHlsZSAhPT0gdW5kZWZpbmVkO1xuICAgIGNvbnN0IHN0cm9rZSA9IHN0YXRlLnN0cm9rZVN0eWxlICE9PSB1bmRlZmluZWQ7XG4gICAgY29uc3QgbnVtRW5kcyA9IGVuZHMubGVuZ3RoO1xuICAgIHRoaXMuaW5zdHJ1Y3Rpb25zLnB1c2goYmVnaW5QYXRoSW5zdHJ1Y3Rpb24pO1xuICAgIHRoaXMuaGl0RGV0ZWN0aW9uSW5zdHJ1Y3Rpb25zLnB1c2goYmVnaW5QYXRoSW5zdHJ1Y3Rpb24pO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtRW5kczsgKytpKSB7XG4gICAgICBjb25zdCBlbmQgPSBlbmRzW2ldO1xuICAgICAgY29uc3QgbXlCZWdpbiA9IHRoaXMuY29vcmRpbmF0ZXMubGVuZ3RoO1xuICAgICAgY29uc3QgbXlFbmQgPSB0aGlzLmFwcGVuZEZsYXRMaW5lQ29vcmRpbmF0ZXMoXG4gICAgICAgIGZsYXRDb29yZGluYXRlcyxcbiAgICAgICAgb2Zmc2V0LFxuICAgICAgICBlbmQsXG4gICAgICAgIHN0cmlkZSxcbiAgICAgICAgdHJ1ZSxcbiAgICAgICAgIXN0cm9rZVxuICAgICAgKTtcbiAgICAgIGNvbnN0IG1vdmVUb0xpbmVUb0luc3RydWN0aW9uID0gW1xuICAgICAgICBDYW52YXNJbnN0cnVjdGlvbi5NT1ZFX1RPX0xJTkVfVE8sXG4gICAgICAgIG15QmVnaW4sXG4gICAgICAgIG15RW5kLFxuICAgICAgXTtcbiAgICAgIHRoaXMuaW5zdHJ1Y3Rpb25zLnB1c2gobW92ZVRvTGluZVRvSW5zdHJ1Y3Rpb24pO1xuICAgICAgdGhpcy5oaXREZXRlY3Rpb25JbnN0cnVjdGlvbnMucHVzaChtb3ZlVG9MaW5lVG9JbnN0cnVjdGlvbik7XG4gICAgICBpZiAoc3Ryb2tlKSB7XG4gICAgICAgIC8vIFBlcmZvcm1hbmNlIG9wdGltaXphdGlvbjogb25seSBjYWxsIGNsb3NlUGF0aCgpIHdoZW4gd2UgaGF2ZSBhIHN0cm9rZS5cbiAgICAgICAgLy8gT3RoZXJ3aXNlIHRoZSByaW5nIGlzIGNsb3NlZCBhbHJlYWR5IChzZWUgYXBwZW5kRmxhdExpbmVDb29yZGluYXRlcyBhYm92ZSkuXG4gICAgICAgIHRoaXMuaW5zdHJ1Y3Rpb25zLnB1c2goY2xvc2VQYXRoSW5zdHJ1Y3Rpb24pO1xuICAgICAgICB0aGlzLmhpdERldGVjdGlvbkluc3RydWN0aW9ucy5wdXNoKGNsb3NlUGF0aEluc3RydWN0aW9uKTtcbiAgICAgIH1cbiAgICAgIG9mZnNldCA9IGVuZDtcbiAgICB9XG4gICAgaWYgKGZpbGwpIHtcbiAgICAgIHRoaXMuaW5zdHJ1Y3Rpb25zLnB1c2goZmlsbEluc3RydWN0aW9uKTtcbiAgICAgIHRoaXMuaGl0RGV0ZWN0aW9uSW5zdHJ1Y3Rpb25zLnB1c2goZmlsbEluc3RydWN0aW9uKTtcbiAgICB9XG4gICAgaWYgKHN0cm9rZSkge1xuICAgICAgdGhpcy5pbnN0cnVjdGlvbnMucHVzaChzdHJva2VJbnN0cnVjdGlvbik7XG4gICAgICB0aGlzLmhpdERldGVjdGlvbkluc3RydWN0aW9ucy5wdXNoKHN0cm9rZUluc3RydWN0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIG9mZnNldDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL2dlb20vQ2lyY2xlLmpzXCIpLmRlZmF1bHR9IGNpcmNsZUdlb21ldHJ5IENpcmNsZSBnZW9tZXRyeS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9IGZlYXR1cmUgRmVhdHVyZS5cbiAgICovXG4gIGRyYXdDaXJjbGUoY2lyY2xlR2VvbWV0cnksIGZlYXR1cmUpIHtcbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3QgZmlsbFN0eWxlID0gc3RhdGUuZmlsbFN0eWxlO1xuICAgIGNvbnN0IHN0cm9rZVN0eWxlID0gc3RhdGUuc3Ryb2tlU3R5bGU7XG4gICAgaWYgKGZpbGxTdHlsZSA9PT0gdW5kZWZpbmVkICYmIHN0cm9rZVN0eWxlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5zZXRGaWxsU3Ryb2tlU3R5bGVzXygpO1xuICAgIHRoaXMuYmVnaW5HZW9tZXRyeShjaXJjbGVHZW9tZXRyeSwgZmVhdHVyZSk7XG4gICAgaWYgKHN0YXRlLmZpbGxTdHlsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLmhpdERldGVjdGlvbkluc3RydWN0aW9ucy5wdXNoKFtcbiAgICAgICAgQ2FudmFzSW5zdHJ1Y3Rpb24uU0VUX0ZJTExfU1RZTEUsXG4gICAgICAgIGRlZmF1bHRGaWxsU3R5bGUsXG4gICAgICBdKTtcbiAgICB9XG4gICAgaWYgKHN0YXRlLnN0cm9rZVN0eWxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuaGl0RGV0ZWN0aW9uSW5zdHJ1Y3Rpb25zLnB1c2goW1xuICAgICAgICBDYW52YXNJbnN0cnVjdGlvbi5TRVRfU1RST0tFX1NUWUxFLFxuICAgICAgICBzdGF0ZS5zdHJva2VTdHlsZSxcbiAgICAgICAgc3RhdGUubGluZVdpZHRoLFxuICAgICAgICBzdGF0ZS5saW5lQ2FwLFxuICAgICAgICBzdGF0ZS5saW5lSm9pbixcbiAgICAgICAgc3RhdGUubWl0ZXJMaW1pdCxcbiAgICAgICAgZGVmYXVsdExpbmVEYXNoLFxuICAgICAgICBkZWZhdWx0TGluZURhc2hPZmZzZXQsXG4gICAgICBdKTtcbiAgICB9XG4gICAgY29uc3QgZmxhdENvb3JkaW5hdGVzID0gY2lyY2xlR2VvbWV0cnkuZ2V0RmxhdENvb3JkaW5hdGVzKCk7XG4gICAgY29uc3Qgc3RyaWRlID0gY2lyY2xlR2VvbWV0cnkuZ2V0U3RyaWRlKCk7XG4gICAgY29uc3QgbXlCZWdpbiA9IHRoaXMuY29vcmRpbmF0ZXMubGVuZ3RoO1xuICAgIHRoaXMuYXBwZW5kRmxhdExpbmVDb29yZGluYXRlcyhcbiAgICAgIGZsYXRDb29yZGluYXRlcyxcbiAgICAgIDAsXG4gICAgICBmbGF0Q29vcmRpbmF0ZXMubGVuZ3RoLFxuICAgICAgc3RyaWRlLFxuICAgICAgZmFsc2UsXG4gICAgICBmYWxzZVxuICAgICk7XG4gICAgY29uc3QgY2lyY2xlSW5zdHJ1Y3Rpb24gPSBbQ2FudmFzSW5zdHJ1Y3Rpb24uQ0lSQ0xFLCBteUJlZ2luXTtcbiAgICB0aGlzLmluc3RydWN0aW9ucy5wdXNoKGJlZ2luUGF0aEluc3RydWN0aW9uLCBjaXJjbGVJbnN0cnVjdGlvbik7XG4gICAgdGhpcy5oaXREZXRlY3Rpb25JbnN0cnVjdGlvbnMucHVzaChiZWdpblBhdGhJbnN0cnVjdGlvbiwgY2lyY2xlSW5zdHJ1Y3Rpb24pO1xuICAgIGlmIChzdGF0ZS5maWxsU3R5bGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5pbnN0cnVjdGlvbnMucHVzaChmaWxsSW5zdHJ1Y3Rpb24pO1xuICAgICAgdGhpcy5oaXREZXRlY3Rpb25JbnN0cnVjdGlvbnMucHVzaChmaWxsSW5zdHJ1Y3Rpb24pO1xuICAgIH1cbiAgICBpZiAoc3RhdGUuc3Ryb2tlU3R5bGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5pbnN0cnVjdGlvbnMucHVzaChzdHJva2VJbnN0cnVjdGlvbik7XG4gICAgICB0aGlzLmhpdERldGVjdGlvbkluc3RydWN0aW9ucy5wdXNoKHN0cm9rZUluc3RydWN0aW9uKTtcbiAgICB9XG4gICAgdGhpcy5lbmRHZW9tZXRyeShmZWF0dXJlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL2dlb20vUG9seWdvbi5qc1wiKS5kZWZhdWx0fGltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdH0gcG9seWdvbkdlb21ldHJ5IFBvbHlnb24gZ2VvbWV0cnkuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vRmVhdHVyZS5qc1wiKS5GZWF0dXJlTGlrZX0gZmVhdHVyZSBGZWF0dXJlLlxuICAgKi9cbiAgZHJhd1BvbHlnb24ocG9seWdvbkdlb21ldHJ5LCBmZWF0dXJlKSB7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgIGNvbnN0IGZpbGxTdHlsZSA9IHN0YXRlLmZpbGxTdHlsZTtcbiAgICBjb25zdCBzdHJva2VTdHlsZSA9IHN0YXRlLnN0cm9rZVN0eWxlO1xuICAgIGlmIChmaWxsU3R5bGUgPT09IHVuZGVmaW5lZCAmJiBzdHJva2VTdHlsZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuc2V0RmlsbFN0cm9rZVN0eWxlc18oKTtcbiAgICB0aGlzLmJlZ2luR2VvbWV0cnkocG9seWdvbkdlb21ldHJ5LCBmZWF0dXJlKTtcbiAgICBpZiAoc3RhdGUuZmlsbFN0eWxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuaGl0RGV0ZWN0aW9uSW5zdHJ1Y3Rpb25zLnB1c2goW1xuICAgICAgICBDYW52YXNJbnN0cnVjdGlvbi5TRVRfRklMTF9TVFlMRSxcbiAgICAgICAgZGVmYXVsdEZpbGxTdHlsZSxcbiAgICAgIF0pO1xuICAgIH1cbiAgICBpZiAoc3RhdGUuc3Ryb2tlU3R5bGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5oaXREZXRlY3Rpb25JbnN0cnVjdGlvbnMucHVzaChbXG4gICAgICAgIENhbnZhc0luc3RydWN0aW9uLlNFVF9TVFJPS0VfU1RZTEUsXG4gICAgICAgIHN0YXRlLnN0cm9rZVN0eWxlLFxuICAgICAgICBzdGF0ZS5saW5lV2lkdGgsXG4gICAgICAgIHN0YXRlLmxpbmVDYXAsXG4gICAgICAgIHN0YXRlLmxpbmVKb2luLFxuICAgICAgICBzdGF0ZS5taXRlckxpbWl0LFxuICAgICAgICBkZWZhdWx0TGluZURhc2gsXG4gICAgICAgIGRlZmF1bHRMaW5lRGFzaE9mZnNldCxcbiAgICAgIF0pO1xuICAgIH1cbiAgICBjb25zdCBlbmRzID0gcG9seWdvbkdlb21ldHJ5LmdldEVuZHMoKTtcbiAgICBjb25zdCBmbGF0Q29vcmRpbmF0ZXMgPSBwb2x5Z29uR2VvbWV0cnkuZ2V0T3JpZW50ZWRGbGF0Q29vcmRpbmF0ZXMoKTtcbiAgICBjb25zdCBzdHJpZGUgPSBwb2x5Z29uR2VvbWV0cnkuZ2V0U3RyaWRlKCk7XG4gICAgdGhpcy5kcmF3RmxhdENvb3JkaW5hdGVzc18oXG4gICAgICBmbGF0Q29vcmRpbmF0ZXMsXG4gICAgICAwLFxuICAgICAgLyoqIEB0eXBlIHtBcnJheTxudW1iZXI+fSAqLyAoZW5kcyksXG4gICAgICBzdHJpZGVcbiAgICApO1xuICAgIHRoaXMuZW5kR2VvbWV0cnkoZmVhdHVyZSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9nZW9tL011bHRpUG9seWdvbi5qc1wiKS5kZWZhdWx0fSBtdWx0aVBvbHlnb25HZW9tZXRyeSBNdWx0aVBvbHlnb24gZ2VvbWV0cnkuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vRmVhdHVyZS5qc1wiKS5GZWF0dXJlTGlrZX0gZmVhdHVyZSBGZWF0dXJlLlxuICAgKi9cbiAgZHJhd011bHRpUG9seWdvbihtdWx0aVBvbHlnb25HZW9tZXRyeSwgZmVhdHVyZSkge1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCBmaWxsU3R5bGUgPSBzdGF0ZS5maWxsU3R5bGU7XG4gICAgY29uc3Qgc3Ryb2tlU3R5bGUgPSBzdGF0ZS5zdHJva2VTdHlsZTtcbiAgICBpZiAoZmlsbFN0eWxlID09PSB1bmRlZmluZWQgJiYgc3Ryb2tlU3R5bGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnNldEZpbGxTdHJva2VTdHlsZXNfKCk7XG4gICAgdGhpcy5iZWdpbkdlb21ldHJ5KG11bHRpUG9seWdvbkdlb21ldHJ5LCBmZWF0dXJlKTtcbiAgICBpZiAoc3RhdGUuZmlsbFN0eWxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuaGl0RGV0ZWN0aW9uSW5zdHJ1Y3Rpb25zLnB1c2goW1xuICAgICAgICBDYW52YXNJbnN0cnVjdGlvbi5TRVRfRklMTF9TVFlMRSxcbiAgICAgICAgZGVmYXVsdEZpbGxTdHlsZSxcbiAgICAgIF0pO1xuICAgIH1cbiAgICBpZiAoc3RhdGUuc3Ryb2tlU3R5bGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5oaXREZXRlY3Rpb25JbnN0cnVjdGlvbnMucHVzaChbXG4gICAgICAgIENhbnZhc0luc3RydWN0aW9uLlNFVF9TVFJPS0VfU1RZTEUsXG4gICAgICAgIHN0YXRlLnN0cm9rZVN0eWxlLFxuICAgICAgICBzdGF0ZS5saW5lV2lkdGgsXG4gICAgICAgIHN0YXRlLmxpbmVDYXAsXG4gICAgICAgIHN0YXRlLmxpbmVKb2luLFxuICAgICAgICBzdGF0ZS5taXRlckxpbWl0LFxuICAgICAgICBkZWZhdWx0TGluZURhc2gsXG4gICAgICAgIGRlZmF1bHRMaW5lRGFzaE9mZnNldCxcbiAgICAgIF0pO1xuICAgIH1cbiAgICBjb25zdCBlbmRzcyA9IG11bHRpUG9seWdvbkdlb21ldHJ5LmdldEVuZHNzKCk7XG4gICAgY29uc3QgZmxhdENvb3JkaW5hdGVzID0gbXVsdGlQb2x5Z29uR2VvbWV0cnkuZ2V0T3JpZW50ZWRGbGF0Q29vcmRpbmF0ZXMoKTtcbiAgICBjb25zdCBzdHJpZGUgPSBtdWx0aVBvbHlnb25HZW9tZXRyeS5nZXRTdHJpZGUoKTtcbiAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBlbmRzcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICBvZmZzZXQgPSB0aGlzLmRyYXdGbGF0Q29vcmRpbmF0ZXNzXyhcbiAgICAgICAgZmxhdENvb3JkaW5hdGVzLFxuICAgICAgICBvZmZzZXQsXG4gICAgICAgIGVuZHNzW2ldLFxuICAgICAgICBzdHJpZGVcbiAgICAgICk7XG4gICAgfVxuICAgIHRoaXMuZW5kR2VvbWV0cnkoZmVhdHVyZSk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vY2FudmFzLmpzXCIpLlNlcmlhbGl6YWJsZUluc3RydWN0aW9uc30gdGhlIHNlcmlhbGl6YWJsZSBpbnN0cnVjdGlvbnMuXG4gICAqL1xuICBmaW5pc2goKSB7XG4gICAgdGhpcy5yZXZlcnNlSGl0RGV0ZWN0aW9uSW5zdHJ1Y3Rpb25zKCk7XG4gICAgdGhpcy5zdGF0ZSA9IG51bGw7XG4gICAgLy8gV2Ugd2FudCB0byBwcmVzZXJ2ZSB0b3BvbG9neSB3aGVuIGRyYXdpbmcgcG9seWdvbnMuICBQb2x5Z29ucyBhcmVcbiAgICAvLyBzaW1wbGlmaWVkIHVzaW5nIHF1YW50aXphdGlvbiBhbmQgcG9pbnQgZWxpbWluYXRpb24uIEhvd2V2ZXIsIHdlIG1pZ2h0XG4gICAgLy8gaGF2ZSByZWNlaXZlZCBhIG1peCBvZiBxdWFudGl6ZWQgYW5kIG5vbi1xdWFudGl6ZWQgZ2VvbWV0cmllcywgc28gZW5zdXJlXG4gICAgLy8gdGhhdCBhbGwgYXJlIHF1YW50aXplZCBieSBxdWFudGl6aW5nIGFsbCBjb29yZGluYXRlcyBpbiB0aGUgYmF0Y2guXG4gICAgY29uc3QgdG9sZXJhbmNlID0gdGhpcy50b2xlcmFuY2U7XG4gICAgaWYgKHRvbGVyYW5jZSAhPT0gMCkge1xuICAgICAgY29uc3QgY29vcmRpbmF0ZXMgPSB0aGlzLmNvb3JkaW5hdGVzO1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gY29vcmRpbmF0ZXMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICBjb29yZGluYXRlc1tpXSA9IHNuYXAoY29vcmRpbmF0ZXNbaV0sIHRvbGVyYW5jZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdXBlci5maW5pc2goKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc2V0RmlsbFN0cm9rZVN0eWxlc18oKSB7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgIGNvbnN0IGZpbGxTdHlsZSA9IHN0YXRlLmZpbGxTdHlsZTtcbiAgICBpZiAoZmlsbFN0eWxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMudXBkYXRlRmlsbFN0eWxlKHN0YXRlLCB0aGlzLmNyZWF0ZUZpbGwpO1xuICAgIH1cbiAgICBpZiAoc3RhdGUuc3Ryb2tlU3R5bGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy51cGRhdGVTdHJva2VTdHlsZShzdGF0ZSwgdGhpcy5hcHBseVN0cm9rZSk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IENhbnZhc1BvbHlnb25CdWlsZGVyO1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3JlbmRlci9jYW52YXMvVGV4dEJ1aWxkZXJcbiAqL1xuaW1wb3J0IENhbnZhc0J1aWxkZXIgZnJvbSAnLi9CdWlsZGVyLmpzJztcbmltcG9ydCBDYW52YXNJbnN0cnVjdGlvbiBmcm9tICcuL0luc3RydWN0aW9uLmpzJztcbmltcG9ydCB7YXNDb2xvckxpa2V9IGZyb20gJy4uLy4uL2NvbG9ybGlrZS5qcyc7XG5pbXBvcnQge1xuICBkZWZhdWx0RmlsbFN0eWxlLFxuICBkZWZhdWx0Rm9udCxcbiAgZGVmYXVsdExpbmVDYXAsXG4gIGRlZmF1bHRMaW5lRGFzaCxcbiAgZGVmYXVsdExpbmVEYXNoT2Zmc2V0LFxuICBkZWZhdWx0TGluZUpvaW4sXG4gIGRlZmF1bHRMaW5lV2lkdGgsXG4gIGRlZmF1bHRNaXRlckxpbWl0LFxuICBkZWZhdWx0UGFkZGluZyxcbiAgZGVmYXVsdFN0cm9rZVN0eWxlLFxuICBkZWZhdWx0VGV4dEFsaWduLFxuICBkZWZhdWx0VGV4dEJhc2VsaW5lLFxuICByZWdpc3RlckZvbnQsXG59IGZyb20gJy4uL2NhbnZhcy5qcyc7XG5pbXBvcnQge2dldFVpZH0gZnJvbSAnLi4vLi4vdXRpbC5qcyc7XG5pbXBvcnQge2ludGVyc2VjdHN9IGZyb20gJy4uLy4uL2V4dGVudC5qcyc7XG5pbXBvcnQge2xpbmVDaHVua30gZnJvbSAnLi4vLi4vZ2VvbS9mbGF0L2xpbmVjaHVuay5qcyc7XG5pbXBvcnQge21hdGNoaW5nQ2h1bmt9IGZyb20gJy4uLy4uL2dlb20vZmxhdC9zdHJhaWdodGNodW5rLmpzJztcbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7e2xlZnQ6IDAsIGNlbnRlcjogMC41LCByaWdodDogMSwgdG9wOiAwLCBtaWRkbGU6IDAuNSwgaGFuZ2luZzogMC4yLCBhbHBoYWJldGljOiAwLjgsIGlkZW9ncmFwaGljOiAwLjgsIGJvdHRvbTogMX19XG4gKi9cbmV4cG9ydCBjb25zdCBURVhUX0FMSUdOID0ge1xuICAnbGVmdCc6IDAsXG4gICdjZW50ZXInOiAwLjUsXG4gICdyaWdodCc6IDEsXG4gICd0b3AnOiAwLFxuICAnbWlkZGxlJzogMC41LFxuICAnaGFuZ2luZyc6IDAuMixcbiAgJ2FscGhhYmV0aWMnOiAwLjgsXG4gICdpZGVvZ3JhcGhpYyc6IDAuOCxcbiAgJ2JvdHRvbSc6IDEsXG59O1xuXG5jbGFzcyBDYW52YXNUZXh0QnVpbGRlciBleHRlbmRzIENhbnZhc0J1aWxkZXIge1xuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHRvbGVyYW5jZSBUb2xlcmFuY2UuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gbWF4RXh0ZW50IE1heGltdW0gZXh0ZW50LlxuICAgKiBAcGFyYW0ge251bWJlcn0gcmVzb2x1dGlvbiBSZXNvbHV0aW9uLlxuICAgKiBAcGFyYW0ge251bWJlcn0gcGl4ZWxSYXRpbyBQaXhlbCByYXRpby5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHRvbGVyYW5jZSwgbWF4RXh0ZW50LCByZXNvbHV0aW9uLCBwaXhlbFJhdGlvKSB7XG4gICAgc3VwZXIodG9sZXJhbmNlLCBtYXhFeHRlbnQsIHJlc29sdXRpb24sIHBpeGVsUmF0aW8pO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7QXJyYXk8SFRNTENhbnZhc0VsZW1lbnQ+fVxuICAgICAqL1xuICAgIHRoaXMubGFiZWxzXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtzdHJpbmd8QXJyYXk8c3RyaW5nPn1cbiAgICAgKi9cbiAgICB0aGlzLnRleHRfID0gJyc7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy50ZXh0T2Zmc2V0WF8gPSAwO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMudGV4dE9mZnNldFlfID0gMDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2Jvb2xlYW58dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMudGV4dFJvdGF0ZVdpdGhWaWV3XyA9IHVuZGVmaW5lZDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnRleHRSb3RhdGlvbl8gPSAwO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7P2ltcG9ydChcIi4uL2NhbnZhcy5qc1wiKS5GaWxsU3RhdGV9XG4gICAgICovXG4gICAgdGhpcy50ZXh0RmlsbFN0YXRlXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7IU9iamVjdDxzdHJpbmcsIGltcG9ydChcIi4uL2NhbnZhcy5qc1wiKS5GaWxsU3RhdGU+fVxuICAgICAqL1xuICAgIHRoaXMuZmlsbFN0YXRlcyA9IHt9O1xuICAgIHRoaXMuZmlsbFN0YXRlc1tkZWZhdWx0RmlsbFN0eWxlXSA9IHtmaWxsU3R5bGU6IGRlZmF1bHRGaWxsU3R5bGV9O1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7P2ltcG9ydChcIi4uL2NhbnZhcy5qc1wiKS5TdHJva2VTdGF0ZX1cbiAgICAgKi9cbiAgICB0aGlzLnRleHRTdHJva2VTdGF0ZV8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUgeyFPYmplY3Q8c3RyaW5nLCBpbXBvcnQoXCIuLi9jYW52YXMuanNcIikuU3Ryb2tlU3RhdGU+fVxuICAgICAqL1xuICAgIHRoaXMuc3Ryb2tlU3RhdGVzID0ge307XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9jYW52YXMuanNcIikuVGV4dFN0YXRlfVxuICAgICAqL1xuICAgIHRoaXMudGV4dFN0YXRlXyA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vY2FudmFzLmpzXCIpLlRleHRTdGF0ZX0gKi8gKHt9KTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHshT2JqZWN0PHN0cmluZywgaW1wb3J0KFwiLi4vY2FudmFzLmpzXCIpLlRleHRTdGF0ZT59XG4gICAgICovXG4gICAgdGhpcy50ZXh0U3RhdGVzID0ge307XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy50ZXh0S2V5XyA9ICcnO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuZmlsbEtleV8gPSAnJztcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLnN0cm9rZUtleV8gPSAnJztcblxuICAgIC8qKlxuICAgICAqIERhdGEgc2hhcmVkIHdpdGggYW4gaW1hZ2UgYnVpbGRlciBmb3IgY29tYmluZWQgZGVjbHV0dGVyaW5nLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL2NhbnZhcy5qc1wiKS5EZWNsdXR0ZXJJbWFnZVdpdGhUZXh0fVxuICAgICAqL1xuICAgIHRoaXMuZGVjbHV0dGVySW1hZ2VXaXRoVGV4dF8gPSB1bmRlZmluZWQ7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vY2FudmFzLmpzXCIpLlNlcmlhbGl6YWJsZUluc3RydWN0aW9uc30gdGhlIHNlcmlhbGl6YWJsZSBpbnN0cnVjdGlvbnMuXG4gICAqL1xuICBmaW5pc2goKSB7XG4gICAgY29uc3QgaW5zdHJ1Y3Rpb25zID0gc3VwZXIuZmluaXNoKCk7XG4gICAgaW5zdHJ1Y3Rpb25zLnRleHRTdGF0ZXMgPSB0aGlzLnRleHRTdGF0ZXM7XG4gICAgaW5zdHJ1Y3Rpb25zLmZpbGxTdGF0ZXMgPSB0aGlzLmZpbGxTdGF0ZXM7XG4gICAgaW5zdHJ1Y3Rpb25zLnN0cm9rZVN0YXRlcyA9IHRoaXMuc3Ryb2tlU3RhdGVzO1xuICAgIHJldHVybiBpbnN0cnVjdGlvbnM7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9nZW9tL1NpbXBsZUdlb21ldHJ5LmpzXCIpLmRlZmF1bHR8aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0fSBnZW9tZXRyeSBHZW9tZXRyeS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9GZWF0dXJlLmpzXCIpLkZlYXR1cmVMaWtlfSBmZWF0dXJlIEZlYXR1cmUuXG4gICAqL1xuICBkcmF3VGV4dChnZW9tZXRyeSwgZmVhdHVyZSkge1xuICAgIGNvbnN0IGZpbGxTdGF0ZSA9IHRoaXMudGV4dEZpbGxTdGF0ZV87XG4gICAgY29uc3Qgc3Ryb2tlU3RhdGUgPSB0aGlzLnRleHRTdHJva2VTdGF0ZV87XG4gICAgY29uc3QgdGV4dFN0YXRlID0gdGhpcy50ZXh0U3RhdGVfO1xuICAgIGlmICh0aGlzLnRleHRfID09PSAnJyB8fCAhdGV4dFN0YXRlIHx8ICghZmlsbFN0YXRlICYmICFzdHJva2VTdGF0ZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBjb29yZGluYXRlcyA9IHRoaXMuY29vcmRpbmF0ZXM7XG4gICAgbGV0IGJlZ2luID0gY29vcmRpbmF0ZXMubGVuZ3RoO1xuXG4gICAgY29uc3QgZ2VvbWV0cnlUeXBlID0gZ2VvbWV0cnkuZ2V0VHlwZSgpO1xuICAgIGxldCBmbGF0Q29vcmRpbmF0ZXMgPSBudWxsO1xuICAgIGxldCBzdHJpZGUgPSBnZW9tZXRyeS5nZXRTdHJpZGUoKTtcblxuICAgIGlmIChcbiAgICAgIHRleHRTdGF0ZS5wbGFjZW1lbnQgPT09ICdsaW5lJyAmJlxuICAgICAgKGdlb21ldHJ5VHlwZSA9PSAnTGluZVN0cmluZycgfHxcbiAgICAgICAgZ2VvbWV0cnlUeXBlID09ICdNdWx0aUxpbmVTdHJpbmcnIHx8XG4gICAgICAgIGdlb21ldHJ5VHlwZSA9PSAnUG9seWdvbicgfHxcbiAgICAgICAgZ2VvbWV0cnlUeXBlID09ICdNdWx0aVBvbHlnb24nKVxuICAgICkge1xuICAgICAgaWYgKCFpbnRlcnNlY3RzKHRoaXMuZ2V0QnVmZmVyZWRNYXhFeHRlbnQoKSwgZ2VvbWV0cnkuZ2V0RXh0ZW50KCkpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxldCBlbmRzO1xuICAgICAgZmxhdENvb3JkaW5hdGVzID0gZ2VvbWV0cnkuZ2V0RmxhdENvb3JkaW5hdGVzKCk7XG4gICAgICBpZiAoZ2VvbWV0cnlUeXBlID09ICdMaW5lU3RyaW5nJykge1xuICAgICAgICBlbmRzID0gW2ZsYXRDb29yZGluYXRlcy5sZW5ndGhdO1xuICAgICAgfSBlbHNlIGlmIChnZW9tZXRyeVR5cGUgPT0gJ011bHRpTGluZVN0cmluZycpIHtcbiAgICAgICAgZW5kcyA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vZ2VvbS9NdWx0aUxpbmVTdHJpbmcuanNcIikuZGVmYXVsdH0gKi8gKFxuICAgICAgICAgIGdlb21ldHJ5XG4gICAgICAgICkuZ2V0RW5kcygpO1xuICAgICAgfSBlbHNlIGlmIChnZW9tZXRyeVR5cGUgPT0gJ1BvbHlnb24nKSB7XG4gICAgICAgIGVuZHMgPSAvKiogQHR5cGUge2ltcG9ydChcIi4uLy4uL2dlb20vUG9seWdvbi5qc1wiKS5kZWZhdWx0fSAqLyAoZ2VvbWV0cnkpXG4gICAgICAgICAgLmdldEVuZHMoKVxuICAgICAgICAgIC5zbGljZSgwLCAxKTtcbiAgICAgIH0gZWxzZSBpZiAoZ2VvbWV0cnlUeXBlID09ICdNdWx0aVBvbHlnb24nKSB7XG4gICAgICAgIGNvbnN0IGVuZHNzID1cbiAgICAgICAgICAvKiogQHR5cGUge2ltcG9ydChcIi4uLy4uL2dlb20vTXVsdGlQb2x5Z29uLmpzXCIpLmRlZmF1bHR9ICovIChcbiAgICAgICAgICAgIGdlb21ldHJ5XG4gICAgICAgICAgKS5nZXRFbmRzcygpO1xuICAgICAgICBlbmRzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IGVuZHNzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgICBlbmRzLnB1c2goZW5kc3NbaV1bMF0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLmJlZ2luR2VvbWV0cnkoZ2VvbWV0cnksIGZlYXR1cmUpO1xuICAgICAgY29uc3QgcmVwZWF0ID0gdGV4dFN0YXRlLnJlcGVhdDtcbiAgICAgIGNvbnN0IHRleHRBbGlnbiA9IHJlcGVhdCA/IHVuZGVmaW5lZCA6IHRleHRTdGF0ZS50ZXh0QWxpZ247XG4gICAgICAvLyBObyBganVzdGlmeWAgc3VwcG9ydCBmb3IgbGluZSBwbGFjZW1lbnQuXG4gICAgICBsZXQgZmxhdE9mZnNldCA9IDA7XG4gICAgICBmb3IgKGxldCBvID0gMCwgb28gPSBlbmRzLmxlbmd0aDsgbyA8IG9vOyArK28pIHtcbiAgICAgICAgbGV0IGNodW5rcztcbiAgICAgICAgaWYgKHJlcGVhdCkge1xuICAgICAgICAgIGNodW5rcyA9IGxpbmVDaHVuayhcbiAgICAgICAgICAgIHJlcGVhdCAqIHRoaXMucmVzb2x1dGlvbixcbiAgICAgICAgICAgIGZsYXRDb29yZGluYXRlcyxcbiAgICAgICAgICAgIGZsYXRPZmZzZXQsXG4gICAgICAgICAgICBlbmRzW29dLFxuICAgICAgICAgICAgc3RyaWRlXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjaHVua3MgPSBbZmxhdENvb3JkaW5hdGVzLnNsaWNlKGZsYXRPZmZzZXQsIGVuZHNbb10pXTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBjID0gMCwgY2MgPSBjaHVua3MubGVuZ3RoOyBjIDwgY2M7ICsrYykge1xuICAgICAgICAgIGNvbnN0IGNodW5rID0gY2h1bmtzW2NdO1xuICAgICAgICAgIGxldCBjaHVua0JlZ2luID0gMDtcbiAgICAgICAgICBsZXQgY2h1bmtFbmQgPSBjaHVuay5sZW5ndGg7XG4gICAgICAgICAgaWYgKHRleHRBbGlnbiA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHJhbmdlID0gbWF0Y2hpbmdDaHVuayhcbiAgICAgICAgICAgICAgdGV4dFN0YXRlLm1heEFuZ2xlLFxuICAgICAgICAgICAgICBjaHVuayxcbiAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgY2h1bmsubGVuZ3RoLFxuICAgICAgICAgICAgICAyXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgY2h1bmtCZWdpbiA9IHJhbmdlWzBdO1xuICAgICAgICAgICAgY2h1bmtFbmQgPSByYW5nZVsxXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yIChsZXQgaSA9IGNodW5rQmVnaW47IGkgPCBjaHVua0VuZDsgaSArPSBzdHJpZGUpIHtcbiAgICAgICAgICAgIGNvb3JkaW5hdGVzLnB1c2goY2h1bmtbaV0sIGNodW5rW2kgKyAxXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGVuZCA9IGNvb3JkaW5hdGVzLmxlbmd0aDtcbiAgICAgICAgICBmbGF0T2Zmc2V0ID0gZW5kc1tvXTtcbiAgICAgICAgICB0aGlzLmRyYXdDaGFyc18oYmVnaW4sIGVuZCk7XG4gICAgICAgICAgYmVnaW4gPSBlbmQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuZW5kR2VvbWV0cnkoZmVhdHVyZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBnZW9tZXRyeVdpZHRocyA9IHRleHRTdGF0ZS5vdmVyZmxvdyA/IG51bGwgOiBbXTtcbiAgICAgIHN3aXRjaCAoZ2VvbWV0cnlUeXBlKSB7XG4gICAgICAgIGNhc2UgJ1BvaW50JzpcbiAgICAgICAgY2FzZSAnTXVsdGlQb2ludCc6XG4gICAgICAgICAgZmxhdENvb3JkaW5hdGVzID1cbiAgICAgICAgICAgIC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vZ2VvbS9NdWx0aVBvaW50LmpzXCIpLmRlZmF1bHR9ICovIChcbiAgICAgICAgICAgICAgZ2VvbWV0cnlcbiAgICAgICAgICAgICkuZ2V0RmxhdENvb3JkaW5hdGVzKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ0xpbmVTdHJpbmcnOlxuICAgICAgICAgIGZsYXRDb29yZGluYXRlcyA9XG4gICAgICAgICAgICAvKiogQHR5cGUge2ltcG9ydChcIi4uLy4uL2dlb20vTGluZVN0cmluZy5qc1wiKS5kZWZhdWx0fSAqLyAoXG4gICAgICAgICAgICAgIGdlb21ldHJ5XG4gICAgICAgICAgICApLmdldEZsYXRNaWRwb2ludCgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdDaXJjbGUnOlxuICAgICAgICAgIGZsYXRDb29yZGluYXRlcyA9XG4gICAgICAgICAgICAvKiogQHR5cGUge2ltcG9ydChcIi4uLy4uL2dlb20vQ2lyY2xlLmpzXCIpLmRlZmF1bHR9ICovIChcbiAgICAgICAgICAgICAgZ2VvbWV0cnlcbiAgICAgICAgICAgICkuZ2V0Q2VudGVyKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ011bHRpTGluZVN0cmluZyc6XG4gICAgICAgICAgZmxhdENvb3JkaW5hdGVzID1cbiAgICAgICAgICAgIC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vZ2VvbS9NdWx0aUxpbmVTdHJpbmcuanNcIikuZGVmYXVsdH0gKi8gKFxuICAgICAgICAgICAgICBnZW9tZXRyeVxuICAgICAgICAgICAgKS5nZXRGbGF0TWlkcG9pbnRzKCk7XG4gICAgICAgICAgc3RyaWRlID0gMjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnUG9seWdvbic6XG4gICAgICAgICAgZmxhdENvb3JkaW5hdGVzID1cbiAgICAgICAgICAgIC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vZ2VvbS9Qb2x5Z29uLmpzXCIpLmRlZmF1bHR9ICovIChcbiAgICAgICAgICAgICAgZ2VvbWV0cnlcbiAgICAgICAgICAgICkuZ2V0RmxhdEludGVyaW9yUG9pbnQoKTtcbiAgICAgICAgICBpZiAoIXRleHRTdGF0ZS5vdmVyZmxvdykge1xuICAgICAgICAgICAgZ2VvbWV0cnlXaWR0aHMucHVzaChmbGF0Q29vcmRpbmF0ZXNbMl0gLyB0aGlzLnJlc29sdXRpb24pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzdHJpZGUgPSAzO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdNdWx0aVBvbHlnb24nOlxuICAgICAgICAgIGNvbnN0IGludGVyaW9yUG9pbnRzID1cbiAgICAgICAgICAgIC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vZ2VvbS9NdWx0aVBvbHlnb24uanNcIikuZGVmYXVsdH0gKi8gKFxuICAgICAgICAgICAgICBnZW9tZXRyeVxuICAgICAgICAgICAgKS5nZXRGbGF0SW50ZXJpb3JQb2ludHMoKTtcbiAgICAgICAgICBmbGF0Q29vcmRpbmF0ZXMgPSBbXTtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBpbnRlcmlvclBvaW50cy5sZW5ndGg7IGkgPCBpaTsgaSArPSAzKSB7XG4gICAgICAgICAgICBpZiAoIXRleHRTdGF0ZS5vdmVyZmxvdykge1xuICAgICAgICAgICAgICBnZW9tZXRyeVdpZHRocy5wdXNoKGludGVyaW9yUG9pbnRzW2kgKyAyXSAvIHRoaXMucmVzb2x1dGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmbGF0Q29vcmRpbmF0ZXMucHVzaChpbnRlcmlvclBvaW50c1tpXSwgaW50ZXJpb3JQb2ludHNbaSArIDFdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGZsYXRDb29yZGluYXRlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3RyaWRlID0gMjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgIH1cbiAgICAgIGNvbnN0IGVuZCA9IHRoaXMuYXBwZW5kRmxhdFBvaW50Q29vcmRpbmF0ZXMoZmxhdENvb3JkaW5hdGVzLCBzdHJpZGUpO1xuICAgICAgaWYgKGVuZCA9PT0gYmVnaW4pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKFxuICAgICAgICBnZW9tZXRyeVdpZHRocyAmJlxuICAgICAgICAoZW5kIC0gYmVnaW4pIC8gMiAhPT0gZmxhdENvb3JkaW5hdGVzLmxlbmd0aCAvIHN0cmlkZVxuICAgICAgKSB7XG4gICAgICAgIGxldCBiZWcgPSBiZWdpbiAvIDI7XG4gICAgICAgIGdlb21ldHJ5V2lkdGhzID0gZ2VvbWV0cnlXaWR0aHMuZmlsdGVyKCh3LCBpKSA9PiB7XG4gICAgICAgICAgY29uc3Qga2VlcCA9XG4gICAgICAgICAgICBjb29yZGluYXRlc1soYmVnICsgaSkgKiAyXSA9PT0gZmxhdENvb3JkaW5hdGVzW2kgKiBzdHJpZGVdICYmXG4gICAgICAgICAgICBjb29yZGluYXRlc1soYmVnICsgaSkgKiAyICsgMV0gPT09IGZsYXRDb29yZGluYXRlc1tpICogc3RyaWRlICsgMV07XG4gICAgICAgICAgaWYgKCFrZWVwKSB7XG4gICAgICAgICAgICAtLWJlZztcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGtlZXA7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnNhdmVUZXh0U3RhdGVzXygpO1xuXG4gICAgICBpZiAodGV4dFN0YXRlLmJhY2tncm91bmRGaWxsIHx8IHRleHRTdGF0ZS5iYWNrZ3JvdW5kU3Ryb2tlKSB7XG4gICAgICAgIHRoaXMuc2V0RmlsbFN0cm9rZVN0eWxlKFxuICAgICAgICAgIHRleHRTdGF0ZS5iYWNrZ3JvdW5kRmlsbCxcbiAgICAgICAgICB0ZXh0U3RhdGUuYmFja2dyb3VuZFN0cm9rZVxuICAgICAgICApO1xuICAgICAgICBpZiAodGV4dFN0YXRlLmJhY2tncm91bmRGaWxsKSB7XG4gICAgICAgICAgdGhpcy51cGRhdGVGaWxsU3R5bGUodGhpcy5zdGF0ZSwgdGhpcy5jcmVhdGVGaWxsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGV4dFN0YXRlLmJhY2tncm91bmRTdHJva2UpIHtcbiAgICAgICAgICB0aGlzLnVwZGF0ZVN0cm9rZVN0eWxlKHRoaXMuc3RhdGUsIHRoaXMuYXBwbHlTdHJva2UpO1xuICAgICAgICAgIHRoaXMuaGl0RGV0ZWN0aW9uSW5zdHJ1Y3Rpb25zLnB1c2godGhpcy5jcmVhdGVTdHJva2UodGhpcy5zdGF0ZSkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYmVnaW5HZW9tZXRyeShnZW9tZXRyeSwgZmVhdHVyZSk7XG5cbiAgICAgIC8vIGFkanVzdCBwYWRkaW5nIGZvciBuZWdhdGl2ZSBzY2FsZVxuICAgICAgbGV0IHBhZGRpbmcgPSB0ZXh0U3RhdGUucGFkZGluZztcbiAgICAgIGlmIChcbiAgICAgICAgcGFkZGluZyAhPSBkZWZhdWx0UGFkZGluZyAmJlxuICAgICAgICAodGV4dFN0YXRlLnNjYWxlWzBdIDwgMCB8fCB0ZXh0U3RhdGUuc2NhbGVbMV0gPCAwKVxuICAgICAgKSB7XG4gICAgICAgIGxldCBwMCA9IHRleHRTdGF0ZS5wYWRkaW5nWzBdO1xuICAgICAgICBsZXQgcDEgPSB0ZXh0U3RhdGUucGFkZGluZ1sxXTtcbiAgICAgICAgbGV0IHAyID0gdGV4dFN0YXRlLnBhZGRpbmdbMl07XG4gICAgICAgIGxldCBwMyA9IHRleHRTdGF0ZS5wYWRkaW5nWzNdO1xuICAgICAgICBpZiAodGV4dFN0YXRlLnNjYWxlWzBdIDwgMCkge1xuICAgICAgICAgIHAxID0gLXAxO1xuICAgICAgICAgIHAzID0gLXAzO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0ZXh0U3RhdGUuc2NhbGVbMV0gPCAwKSB7XG4gICAgICAgICAgcDAgPSAtcDA7XG4gICAgICAgICAgcDIgPSAtcDI7XG4gICAgICAgIH1cbiAgICAgICAgcGFkZGluZyA9IFtwMCwgcDEsIHAyLCBwM107XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSBpbWFnZSBpcyB1bmtub3duIGF0IHRoaXMgc3RhZ2Ugc28gd2UgcGFzcyBudWxsOyBpdCB3aWxsIGJlIGNvbXB1dGVkIGF0IHJlbmRlciB0aW1lLlxuICAgICAgLy8gRm9yIGNsYXJpdHksIHdlIHBhc3MgTmFOIGZvciBvZmZzZXRYLCBvZmZzZXRZLCB3aWR0aCBhbmQgaGVpZ2h0LCB3aGljaCB3aWxsIGJlIGNvbXB1dGVkIGF0XG4gICAgICAvLyByZW5kZXIgdGltZS5cbiAgICAgIGNvbnN0IHBpeGVsUmF0aW8gPSB0aGlzLnBpeGVsUmF0aW87XG4gICAgICB0aGlzLmluc3RydWN0aW9ucy5wdXNoKFtcbiAgICAgICAgQ2FudmFzSW5zdHJ1Y3Rpb24uRFJBV19JTUFHRSxcbiAgICAgICAgYmVnaW4sXG4gICAgICAgIGVuZCxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgTmFOLFxuICAgICAgICBOYU4sXG4gICAgICAgIE5hTixcbiAgICAgICAgMSxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgdGhpcy50ZXh0Um90YXRlV2l0aFZpZXdfLFxuICAgICAgICB0aGlzLnRleHRSb3RhdGlvbl8sXG4gICAgICAgIFsxLCAxXSxcbiAgICAgICAgTmFOLFxuICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgIHRoaXMuZGVjbHV0dGVySW1hZ2VXaXRoVGV4dF8sXG4gICAgICAgIHBhZGRpbmcgPT0gZGVmYXVsdFBhZGRpbmdcbiAgICAgICAgICA/IGRlZmF1bHRQYWRkaW5nXG4gICAgICAgICAgOiBwYWRkaW5nLm1hcChmdW5jdGlvbiAocCkge1xuICAgICAgICAgICAgICByZXR1cm4gcCAqIHBpeGVsUmF0aW87XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgISF0ZXh0U3RhdGUuYmFja2dyb3VuZEZpbGwsXG4gICAgICAgICEhdGV4dFN0YXRlLmJhY2tncm91bmRTdHJva2UsXG4gICAgICAgIHRoaXMudGV4dF8sXG4gICAgICAgIHRoaXMudGV4dEtleV8sXG4gICAgICAgIHRoaXMuc3Ryb2tlS2V5XyxcbiAgICAgICAgdGhpcy5maWxsS2V5XyxcbiAgICAgICAgdGhpcy50ZXh0T2Zmc2V0WF8sXG4gICAgICAgIHRoaXMudGV4dE9mZnNldFlfLFxuICAgICAgICBnZW9tZXRyeVdpZHRocyxcbiAgICAgIF0pO1xuICAgICAgY29uc3Qgc2NhbGUgPSAxIC8gcGl4ZWxSYXRpbztcbiAgICAgIC8vIFNldCBkZWZhdWx0IGZpbGwgZm9yIGhpdCBkZXRlY3Rpb24gYmFja2dyb3VuZFxuICAgICAgY29uc3QgY3VycmVudEZpbGxTdHlsZSA9IHRoaXMuc3RhdGUuZmlsbFN0eWxlO1xuICAgICAgaWYgKHRleHRTdGF0ZS5iYWNrZ3JvdW5kRmlsbCkge1xuICAgICAgICB0aGlzLnN0YXRlLmZpbGxTdHlsZSA9IGRlZmF1bHRGaWxsU3R5bGU7XG4gICAgICAgIHRoaXMuaGl0RGV0ZWN0aW9uSW5zdHJ1Y3Rpb25zLnB1c2godGhpcy5jcmVhdGVGaWxsKHRoaXMuc3RhdGUpKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuaGl0RGV0ZWN0aW9uSW5zdHJ1Y3Rpb25zLnB1c2goW1xuICAgICAgICBDYW52YXNJbnN0cnVjdGlvbi5EUkFXX0lNQUdFLFxuICAgICAgICBiZWdpbixcbiAgICAgICAgZW5kLFxuICAgICAgICBudWxsLFxuICAgICAgICBOYU4sXG4gICAgICAgIE5hTixcbiAgICAgICAgTmFOLFxuICAgICAgICAxLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICB0aGlzLnRleHRSb3RhdGVXaXRoVmlld18sXG4gICAgICAgIHRoaXMudGV4dFJvdGF0aW9uXyxcbiAgICAgICAgW3NjYWxlLCBzY2FsZV0sXG4gICAgICAgIE5hTixcbiAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICB0aGlzLmRlY2x1dHRlckltYWdlV2l0aFRleHRfLFxuICAgICAgICBwYWRkaW5nLFxuICAgICAgICAhIXRleHRTdGF0ZS5iYWNrZ3JvdW5kRmlsbCxcbiAgICAgICAgISF0ZXh0U3RhdGUuYmFja2dyb3VuZFN0cm9rZSxcbiAgICAgICAgdGhpcy50ZXh0XyxcbiAgICAgICAgdGhpcy50ZXh0S2V5XyxcbiAgICAgICAgdGhpcy5zdHJva2VLZXlfLFxuICAgICAgICB0aGlzLmZpbGxLZXlfID8gZGVmYXVsdEZpbGxTdHlsZSA6IHRoaXMuZmlsbEtleV8sXG4gICAgICAgIHRoaXMudGV4dE9mZnNldFhfLFxuICAgICAgICB0aGlzLnRleHRPZmZzZXRZXyxcbiAgICAgICAgZ2VvbWV0cnlXaWR0aHMsXG4gICAgICBdKTtcbiAgICAgIC8vIFJlc2V0IHByZXZpb3VzIGZpbGxcbiAgICAgIGlmICh0ZXh0U3RhdGUuYmFja2dyb3VuZEZpbGwpIHtcbiAgICAgICAgdGhpcy5zdGF0ZS5maWxsU3R5bGUgPSBjdXJyZW50RmlsbFN0eWxlO1xuICAgICAgICB0aGlzLmhpdERldGVjdGlvbkluc3RydWN0aW9ucy5wdXNoKHRoaXMuY3JlYXRlRmlsbCh0aGlzLnN0YXRlKSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZW5kR2VvbWV0cnkoZmVhdHVyZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzYXZlVGV4dFN0YXRlc18oKSB7XG4gICAgY29uc3Qgc3Ryb2tlU3RhdGUgPSB0aGlzLnRleHRTdHJva2VTdGF0ZV87XG4gICAgY29uc3QgdGV4dFN0YXRlID0gdGhpcy50ZXh0U3RhdGVfO1xuICAgIGNvbnN0IGZpbGxTdGF0ZSA9IHRoaXMudGV4dEZpbGxTdGF0ZV87XG5cbiAgICBjb25zdCBzdHJva2VLZXkgPSB0aGlzLnN0cm9rZUtleV87XG4gICAgaWYgKHN0cm9rZVN0YXRlKSB7XG4gICAgICBpZiAoIShzdHJva2VLZXkgaW4gdGhpcy5zdHJva2VTdGF0ZXMpKSB7XG4gICAgICAgIHRoaXMuc3Ryb2tlU3RhdGVzW3N0cm9rZUtleV0gPSB7XG4gICAgICAgICAgc3Ryb2tlU3R5bGU6IHN0cm9rZVN0YXRlLnN0cm9rZVN0eWxlLFxuICAgICAgICAgIGxpbmVDYXA6IHN0cm9rZVN0YXRlLmxpbmVDYXAsXG4gICAgICAgICAgbGluZURhc2hPZmZzZXQ6IHN0cm9rZVN0YXRlLmxpbmVEYXNoT2Zmc2V0LFxuICAgICAgICAgIGxpbmVXaWR0aDogc3Ryb2tlU3RhdGUubGluZVdpZHRoLFxuICAgICAgICAgIGxpbmVKb2luOiBzdHJva2VTdGF0ZS5saW5lSm9pbixcbiAgICAgICAgICBtaXRlckxpbWl0OiBzdHJva2VTdGF0ZS5taXRlckxpbWl0LFxuICAgICAgICAgIGxpbmVEYXNoOiBzdHJva2VTdGF0ZS5saW5lRGFzaCxcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgdGV4dEtleSA9IHRoaXMudGV4dEtleV87XG4gICAgaWYgKCEodGV4dEtleSBpbiB0aGlzLnRleHRTdGF0ZXMpKSB7XG4gICAgICB0aGlzLnRleHRTdGF0ZXNbdGV4dEtleV0gPSB7XG4gICAgICAgIGZvbnQ6IHRleHRTdGF0ZS5mb250LFxuICAgICAgICB0ZXh0QWxpZ246IHRleHRTdGF0ZS50ZXh0QWxpZ24gfHwgZGVmYXVsdFRleHRBbGlnbixcbiAgICAgICAganVzdGlmeTogdGV4dFN0YXRlLmp1c3RpZnksXG4gICAgICAgIHRleHRCYXNlbGluZTogdGV4dFN0YXRlLnRleHRCYXNlbGluZSB8fCBkZWZhdWx0VGV4dEJhc2VsaW5lLFxuICAgICAgICBzY2FsZTogdGV4dFN0YXRlLnNjYWxlLFxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgZmlsbEtleSA9IHRoaXMuZmlsbEtleV87XG4gICAgaWYgKGZpbGxTdGF0ZSkge1xuICAgICAgaWYgKCEoZmlsbEtleSBpbiB0aGlzLmZpbGxTdGF0ZXMpKSB7XG4gICAgICAgIHRoaXMuZmlsbFN0YXRlc1tmaWxsS2V5XSA9IHtcbiAgICAgICAgICBmaWxsU3R5bGU6IGZpbGxTdGF0ZS5maWxsU3R5bGUsXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBiZWdpbiBCZWdpbi5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGVuZCBFbmQuXG4gICAqL1xuICBkcmF3Q2hhcnNfKGJlZ2luLCBlbmQpIHtcbiAgICBjb25zdCBzdHJva2VTdGF0ZSA9IHRoaXMudGV4dFN0cm9rZVN0YXRlXztcbiAgICBjb25zdCB0ZXh0U3RhdGUgPSB0aGlzLnRleHRTdGF0ZV87XG5cbiAgICBjb25zdCBzdHJva2VLZXkgPSB0aGlzLnN0cm9rZUtleV87XG4gICAgY29uc3QgdGV4dEtleSA9IHRoaXMudGV4dEtleV87XG4gICAgY29uc3QgZmlsbEtleSA9IHRoaXMuZmlsbEtleV87XG4gICAgdGhpcy5zYXZlVGV4dFN0YXRlc18oKTtcblxuICAgIGNvbnN0IHBpeGVsUmF0aW8gPSB0aGlzLnBpeGVsUmF0aW87XG4gICAgY29uc3QgYmFzZWxpbmUgPSBURVhUX0FMSUdOW3RleHRTdGF0ZS50ZXh0QmFzZWxpbmVdO1xuXG4gICAgY29uc3Qgb2Zmc2V0WSA9IHRoaXMudGV4dE9mZnNldFlfICogcGl4ZWxSYXRpbztcbiAgICBjb25zdCB0ZXh0ID0gdGhpcy50ZXh0XztcbiAgICBjb25zdCBzdHJva2VXaWR0aCA9IHN0cm9rZVN0YXRlXG4gICAgICA/IChzdHJva2VTdGF0ZS5saW5lV2lkdGggKiBNYXRoLmFicyh0ZXh0U3RhdGUuc2NhbGVbMF0pKSAvIDJcbiAgICAgIDogMDtcblxuICAgIHRoaXMuaW5zdHJ1Y3Rpb25zLnB1c2goW1xuICAgICAgQ2FudmFzSW5zdHJ1Y3Rpb24uRFJBV19DSEFSUyxcbiAgICAgIGJlZ2luLFxuICAgICAgZW5kLFxuICAgICAgYmFzZWxpbmUsXG4gICAgICB0ZXh0U3RhdGUub3ZlcmZsb3csXG4gICAgICBmaWxsS2V5LFxuICAgICAgdGV4dFN0YXRlLm1heEFuZ2xlLFxuICAgICAgcGl4ZWxSYXRpbyxcbiAgICAgIG9mZnNldFksXG4gICAgICBzdHJva2VLZXksXG4gICAgICBzdHJva2VXaWR0aCAqIHBpeGVsUmF0aW8sXG4gICAgICB0ZXh0LFxuICAgICAgdGV4dEtleSxcbiAgICAgIDEsXG4gICAgXSk7XG4gICAgdGhpcy5oaXREZXRlY3Rpb25JbnN0cnVjdGlvbnMucHVzaChbXG4gICAgICBDYW52YXNJbnN0cnVjdGlvbi5EUkFXX0NIQVJTLFxuICAgICAgYmVnaW4sXG4gICAgICBlbmQsXG4gICAgICBiYXNlbGluZSxcbiAgICAgIHRleHRTdGF0ZS5vdmVyZmxvdyxcbiAgICAgIGZpbGxLZXkgPyBkZWZhdWx0RmlsbFN0eWxlIDogZmlsbEtleSxcbiAgICAgIHRleHRTdGF0ZS5tYXhBbmdsZSxcbiAgICAgIHBpeGVsUmF0aW8sXG4gICAgICBvZmZzZXRZLFxuICAgICAgc3Ryb2tlS2V5LFxuICAgICAgc3Ryb2tlV2lkdGggKiBwaXhlbFJhdGlvLFxuICAgICAgdGV4dCxcbiAgICAgIHRleHRLZXksXG4gICAgICAxIC8gcGl4ZWxSYXRpbyxcbiAgICBdKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL3N0eWxlL1RleHQuanNcIikuZGVmYXVsdH0gdGV4dFN0eWxlIFRleHQgc3R5bGUuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbc2hhcmVkRGF0YV0gU2hhcmVkIGRhdGEuXG4gICAqL1xuICBzZXRUZXh0U3R5bGUodGV4dFN0eWxlLCBzaGFyZWREYXRhKSB7XG4gICAgbGV0IHRleHRTdGF0ZSwgZmlsbFN0YXRlLCBzdHJva2VTdGF0ZTtcbiAgICBpZiAoIXRleHRTdHlsZSkge1xuICAgICAgdGhpcy50ZXh0XyA9ICcnO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB0ZXh0RmlsbFN0eWxlID0gdGV4dFN0eWxlLmdldEZpbGwoKTtcbiAgICAgIGlmICghdGV4dEZpbGxTdHlsZSkge1xuICAgICAgICBmaWxsU3RhdGUgPSBudWxsO1xuICAgICAgICB0aGlzLnRleHRGaWxsU3RhdGVfID0gZmlsbFN0YXRlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmlsbFN0YXRlID0gdGhpcy50ZXh0RmlsbFN0YXRlXztcbiAgICAgICAgaWYgKCFmaWxsU3RhdGUpIHtcbiAgICAgICAgICBmaWxsU3RhdGUgPSAvKiogQHR5cGUge2ltcG9ydChcIi4uL2NhbnZhcy5qc1wiKS5GaWxsU3RhdGV9ICovICh7fSk7XG4gICAgICAgICAgdGhpcy50ZXh0RmlsbFN0YXRlXyA9IGZpbGxTdGF0ZTtcbiAgICAgICAgfVxuICAgICAgICBmaWxsU3RhdGUuZmlsbFN0eWxlID0gYXNDb2xvckxpa2UoXG4gICAgICAgICAgdGV4dEZpbGxTdHlsZS5nZXRDb2xvcigpIHx8IGRlZmF1bHRGaWxsU3R5bGVcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgdGV4dFN0cm9rZVN0eWxlID0gdGV4dFN0eWxlLmdldFN0cm9rZSgpO1xuICAgICAgaWYgKCF0ZXh0U3Ryb2tlU3R5bGUpIHtcbiAgICAgICAgc3Ryb2tlU3RhdGUgPSBudWxsO1xuICAgICAgICB0aGlzLnRleHRTdHJva2VTdGF0ZV8gPSBzdHJva2VTdGF0ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0cm9rZVN0YXRlID0gdGhpcy50ZXh0U3Ryb2tlU3RhdGVfO1xuICAgICAgICBpZiAoIXN0cm9rZVN0YXRlKSB7XG4gICAgICAgICAgc3Ryb2tlU3RhdGUgPSAvKiogQHR5cGUge2ltcG9ydChcIi4uL2NhbnZhcy5qc1wiKS5TdHJva2VTdGF0ZX0gKi8gKHt9KTtcbiAgICAgICAgICB0aGlzLnRleHRTdHJva2VTdGF0ZV8gPSBzdHJva2VTdGF0ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsaW5lRGFzaCA9IHRleHRTdHJva2VTdHlsZS5nZXRMaW5lRGFzaCgpO1xuICAgICAgICBjb25zdCBsaW5lRGFzaE9mZnNldCA9IHRleHRTdHJva2VTdHlsZS5nZXRMaW5lRGFzaE9mZnNldCgpO1xuICAgICAgICBjb25zdCBsaW5lV2lkdGggPSB0ZXh0U3Ryb2tlU3R5bGUuZ2V0V2lkdGgoKTtcbiAgICAgICAgY29uc3QgbWl0ZXJMaW1pdCA9IHRleHRTdHJva2VTdHlsZS5nZXRNaXRlckxpbWl0KCk7XG4gICAgICAgIHN0cm9rZVN0YXRlLmxpbmVDYXAgPSB0ZXh0U3Ryb2tlU3R5bGUuZ2V0TGluZUNhcCgpIHx8IGRlZmF1bHRMaW5lQ2FwO1xuICAgICAgICBzdHJva2VTdGF0ZS5saW5lRGFzaCA9IGxpbmVEYXNoID8gbGluZURhc2guc2xpY2UoKSA6IGRlZmF1bHRMaW5lRGFzaDtcbiAgICAgICAgc3Ryb2tlU3RhdGUubGluZURhc2hPZmZzZXQgPVxuICAgICAgICAgIGxpbmVEYXNoT2Zmc2V0ID09PSB1bmRlZmluZWQgPyBkZWZhdWx0TGluZURhc2hPZmZzZXQgOiBsaW5lRGFzaE9mZnNldDtcbiAgICAgICAgc3Ryb2tlU3RhdGUubGluZUpvaW4gPSB0ZXh0U3Ryb2tlU3R5bGUuZ2V0TGluZUpvaW4oKSB8fCBkZWZhdWx0TGluZUpvaW47XG4gICAgICAgIHN0cm9rZVN0YXRlLmxpbmVXaWR0aCA9XG4gICAgICAgICAgbGluZVdpZHRoID09PSB1bmRlZmluZWQgPyBkZWZhdWx0TGluZVdpZHRoIDogbGluZVdpZHRoO1xuICAgICAgICBzdHJva2VTdGF0ZS5taXRlckxpbWl0ID1cbiAgICAgICAgICBtaXRlckxpbWl0ID09PSB1bmRlZmluZWQgPyBkZWZhdWx0TWl0ZXJMaW1pdCA6IG1pdGVyTGltaXQ7XG4gICAgICAgIHN0cm9rZVN0YXRlLnN0cm9rZVN0eWxlID0gYXNDb2xvckxpa2UoXG4gICAgICAgICAgdGV4dFN0cm9rZVN0eWxlLmdldENvbG9yKCkgfHwgZGVmYXVsdFN0cm9rZVN0eWxlXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIHRleHRTdGF0ZSA9IHRoaXMudGV4dFN0YXRlXztcbiAgICAgIGNvbnN0IGZvbnQgPSB0ZXh0U3R5bGUuZ2V0Rm9udCgpIHx8IGRlZmF1bHRGb250O1xuICAgICAgcmVnaXN0ZXJGb250KGZvbnQpO1xuICAgICAgY29uc3QgdGV4dFNjYWxlID0gdGV4dFN0eWxlLmdldFNjYWxlQXJyYXkoKTtcbiAgICAgIHRleHRTdGF0ZS5vdmVyZmxvdyA9IHRleHRTdHlsZS5nZXRPdmVyZmxvdygpO1xuICAgICAgdGV4dFN0YXRlLmZvbnQgPSBmb250O1xuICAgICAgdGV4dFN0YXRlLm1heEFuZ2xlID0gdGV4dFN0eWxlLmdldE1heEFuZ2xlKCk7XG4gICAgICB0ZXh0U3RhdGUucGxhY2VtZW50ID0gdGV4dFN0eWxlLmdldFBsYWNlbWVudCgpO1xuICAgICAgdGV4dFN0YXRlLnRleHRBbGlnbiA9IHRleHRTdHlsZS5nZXRUZXh0QWxpZ24oKTtcbiAgICAgIHRleHRTdGF0ZS5yZXBlYXQgPSB0ZXh0U3R5bGUuZ2V0UmVwZWF0KCk7XG4gICAgICB0ZXh0U3RhdGUuanVzdGlmeSA9IHRleHRTdHlsZS5nZXRKdXN0aWZ5KCk7XG4gICAgICB0ZXh0U3RhdGUudGV4dEJhc2VsaW5lID1cbiAgICAgICAgdGV4dFN0eWxlLmdldFRleHRCYXNlbGluZSgpIHx8IGRlZmF1bHRUZXh0QmFzZWxpbmU7XG4gICAgICB0ZXh0U3RhdGUuYmFja2dyb3VuZEZpbGwgPSB0ZXh0U3R5bGUuZ2V0QmFja2dyb3VuZEZpbGwoKTtcbiAgICAgIHRleHRTdGF0ZS5iYWNrZ3JvdW5kU3Ryb2tlID0gdGV4dFN0eWxlLmdldEJhY2tncm91bmRTdHJva2UoKTtcbiAgICAgIHRleHRTdGF0ZS5wYWRkaW5nID0gdGV4dFN0eWxlLmdldFBhZGRpbmcoKSB8fCBkZWZhdWx0UGFkZGluZztcbiAgICAgIHRleHRTdGF0ZS5zY2FsZSA9IHRleHRTY2FsZSA9PT0gdW5kZWZpbmVkID8gWzEsIDFdIDogdGV4dFNjYWxlO1xuXG4gICAgICBjb25zdCB0ZXh0T2Zmc2V0WCA9IHRleHRTdHlsZS5nZXRPZmZzZXRYKCk7XG4gICAgICBjb25zdCB0ZXh0T2Zmc2V0WSA9IHRleHRTdHlsZS5nZXRPZmZzZXRZKCk7XG4gICAgICBjb25zdCB0ZXh0Um90YXRlV2l0aFZpZXcgPSB0ZXh0U3R5bGUuZ2V0Um90YXRlV2l0aFZpZXcoKTtcbiAgICAgIGNvbnN0IHRleHRSb3RhdGlvbiA9IHRleHRTdHlsZS5nZXRSb3RhdGlvbigpO1xuICAgICAgdGhpcy50ZXh0XyA9IHRleHRTdHlsZS5nZXRUZXh0KCkgfHwgJyc7XG4gICAgICB0aGlzLnRleHRPZmZzZXRYXyA9IHRleHRPZmZzZXRYID09PSB1bmRlZmluZWQgPyAwIDogdGV4dE9mZnNldFg7XG4gICAgICB0aGlzLnRleHRPZmZzZXRZXyA9IHRleHRPZmZzZXRZID09PSB1bmRlZmluZWQgPyAwIDogdGV4dE9mZnNldFk7XG4gICAgICB0aGlzLnRleHRSb3RhdGVXaXRoVmlld18gPVxuICAgICAgICB0ZXh0Um90YXRlV2l0aFZpZXcgPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogdGV4dFJvdGF0ZVdpdGhWaWV3O1xuICAgICAgdGhpcy50ZXh0Um90YXRpb25fID0gdGV4dFJvdGF0aW9uID09PSB1bmRlZmluZWQgPyAwIDogdGV4dFJvdGF0aW9uO1xuXG4gICAgICB0aGlzLnN0cm9rZUtleV8gPSBzdHJva2VTdGF0ZVxuICAgICAgICA/ICh0eXBlb2Ygc3Ryb2tlU3RhdGUuc3Ryb2tlU3R5bGUgPT0gJ3N0cmluZydcbiAgICAgICAgICAgID8gc3Ryb2tlU3RhdGUuc3Ryb2tlU3R5bGVcbiAgICAgICAgICAgIDogZ2V0VWlkKHN0cm9rZVN0YXRlLnN0cm9rZVN0eWxlKSkgK1xuICAgICAgICAgIHN0cm9rZVN0YXRlLmxpbmVDYXAgK1xuICAgICAgICAgIHN0cm9rZVN0YXRlLmxpbmVEYXNoT2Zmc2V0ICtcbiAgICAgICAgICAnfCcgK1xuICAgICAgICAgIHN0cm9rZVN0YXRlLmxpbmVXaWR0aCArXG4gICAgICAgICAgc3Ryb2tlU3RhdGUubGluZUpvaW4gK1xuICAgICAgICAgIHN0cm9rZVN0YXRlLm1pdGVyTGltaXQgK1xuICAgICAgICAgICdbJyArXG4gICAgICAgICAgc3Ryb2tlU3RhdGUubGluZURhc2guam9pbigpICtcbiAgICAgICAgICAnXSdcbiAgICAgICAgOiAnJztcbiAgICAgIHRoaXMudGV4dEtleV8gPVxuICAgICAgICB0ZXh0U3RhdGUuZm9udCArXG4gICAgICAgIHRleHRTdGF0ZS5zY2FsZSArXG4gICAgICAgICh0ZXh0U3RhdGUudGV4dEFsaWduIHx8ICc/JykgK1xuICAgICAgICAodGV4dFN0YXRlLnJlcGVhdCB8fCAnPycpICtcbiAgICAgICAgKHRleHRTdGF0ZS5qdXN0aWZ5IHx8ICc/JykgK1xuICAgICAgICAodGV4dFN0YXRlLnRleHRCYXNlbGluZSB8fCAnPycpO1xuICAgICAgdGhpcy5maWxsS2V5XyA9IGZpbGxTdGF0ZVxuICAgICAgICA/IHR5cGVvZiBmaWxsU3RhdGUuZmlsbFN0eWxlID09ICdzdHJpbmcnXG4gICAgICAgICAgPyBmaWxsU3RhdGUuZmlsbFN0eWxlXG4gICAgICAgICAgOiAnfCcgKyBnZXRVaWQoZmlsbFN0YXRlLmZpbGxTdHlsZSlcbiAgICAgICAgOiAnJztcbiAgICB9XG4gICAgdGhpcy5kZWNsdXR0ZXJJbWFnZVdpdGhUZXh0XyA9IHNoYXJlZERhdGE7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQ2FudmFzVGV4dEJ1aWxkZXI7XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvcmVuZGVyL2NhbnZhcy9oaXRkZXRlY3RcbiAqL1xuXG5pbXBvcnQgQ2FudmFzSW1tZWRpYXRlUmVuZGVyZXIgZnJvbSAnLi9JbW1lZGlhdGUuanMnO1xuaW1wb3J0IHtJY29ufSBmcm9tICcuLi8uLi9zdHlsZS5qcyc7XG5pbXBvcnQge2FzY2VuZGluZ30gZnJvbSAnLi4vLi4vYXJyYXkuanMnO1xuaW1wb3J0IHtjbGFtcH0gZnJvbSAnLi4vLi4vbWF0aC5qcyc7XG5pbXBvcnQge2NyZWF0ZUNhbnZhc0NvbnRleHQyRH0gZnJvbSAnLi4vLi4vZG9tLmpzJztcbmltcG9ydCB7aW50ZXJzZWN0c30gZnJvbSAnLi4vLi4vZXh0ZW50LmpzJztcblxuZXhwb3J0IGNvbnN0IEhJVF9ERVRFQ1RfUkVTT0xVVElPTiA9IDAuNTtcblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL3NpemUuanNcIikuU2l6ZX0gc2l6ZSBDYW52YXMgc2l6ZSBpbiBjc3MgcGl4ZWxzLlxuICogQHBhcmFtIHtBcnJheTxpbXBvcnQoXCIuLi8uLi90cmFuc2Zvcm0uanNcIikuVHJhbnNmb3JtPn0gdHJhbnNmb3JtcyBUcmFuc2Zvcm1zXG4gKiBmb3IgcmVuZGVyaW5nIGZlYXR1cmVzIHRvIGFsbCB3b3JsZHMgb2YgdGhlIHZpZXdwb3J0LCBmcm9tIGNvb3JkaW5hdGVzIHRvIGNzc1xuICogcGl4ZWxzLlxuICogQHBhcmFtIHtBcnJheTxpbXBvcnQoXCIuLi8uLi9GZWF0dXJlLmpzXCIpLkZlYXR1cmVMaWtlPn0gZmVhdHVyZXNcbiAqIEZlYXR1cmVzIHRvIGNvbnNpZGVyIGZvciBoaXQgZGV0ZWN0aW9uLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9zdHlsZS9TdHlsZS5qc1wiKS5TdHlsZUZ1bmN0aW9ufHVuZGVmaW5lZH0gc3R5bGVGdW5jdGlvblxuICogTGF5ZXIgc3R5bGUgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gcmVzb2x1dGlvbiBSZXNvbHV0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IHJvdGF0aW9uIFJvdGF0aW9uLlxuICogQHJldHVybiB7SW1hZ2VEYXRhfSBIaXQgZGV0ZWN0aW9uIGltYWdlIGRhdGEuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVIaXREZXRlY3Rpb25JbWFnZURhdGEoXG4gIHNpemUsXG4gIHRyYW5zZm9ybXMsXG4gIGZlYXR1cmVzLFxuICBzdHlsZUZ1bmN0aW9uLFxuICBleHRlbnQsXG4gIHJlc29sdXRpb24sXG4gIHJvdGF0aW9uXG4pIHtcbiAgY29uc3Qgd2lkdGggPSBzaXplWzBdICogSElUX0RFVEVDVF9SRVNPTFVUSU9OO1xuICBjb25zdCBoZWlnaHQgPSBzaXplWzFdICogSElUX0RFVEVDVF9SRVNPTFVUSU9OO1xuICBjb25zdCBjb250ZXh0ID0gY3JlYXRlQ2FudmFzQ29udGV4dDJEKHdpZHRoLCBoZWlnaHQpO1xuICBjb250ZXh0LmltYWdlU21vb3RoaW5nRW5hYmxlZCA9IGZhbHNlO1xuICBjb25zdCBjYW52YXMgPSBjb250ZXh0LmNhbnZhcztcbiAgY29uc3QgcmVuZGVyZXIgPSBuZXcgQ2FudmFzSW1tZWRpYXRlUmVuZGVyZXIoXG4gICAgY29udGV4dCxcbiAgICBISVRfREVURUNUX1JFU09MVVRJT04sXG4gICAgZXh0ZW50LFxuICAgIG51bGwsXG4gICAgcm90YXRpb25cbiAgKTtcbiAgY29uc3QgZmVhdHVyZUNvdW50ID0gZmVhdHVyZXMubGVuZ3RoO1xuICAvLyBTdHJldGNoIGhpdCBkZXRlY3Rpb24gaW5kZXggdG8gdXNlIHRoZSB3aG9sZSBhdmFpbGFibGUgY29sb3IgcmFuZ2VcbiAgY29uc3QgaW5kZXhGYWN0b3IgPSBNYXRoLmZsb29yKCgyNTYgKiAyNTYgKiAyNTYgLSAxKSAvIGZlYXR1cmVDb3VudCk7XG4gIGNvbnN0IGZlYXR1cmVzQnlaSW5kZXggPSB7fTtcbiAgZm9yIChsZXQgaSA9IDE7IGkgPD0gZmVhdHVyZUNvdW50OyArK2kpIHtcbiAgICBjb25zdCBmZWF0dXJlID0gZmVhdHVyZXNbaSAtIDFdO1xuICAgIGNvbnN0IGZlYXR1cmVTdHlsZUZ1bmN0aW9uID0gZmVhdHVyZS5nZXRTdHlsZUZ1bmN0aW9uKCkgfHwgc3R5bGVGdW5jdGlvbjtcbiAgICBpZiAoIWZlYXR1cmVTdHlsZUZ1bmN0aW9uKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgbGV0IHN0eWxlcyA9IGZlYXR1cmVTdHlsZUZ1bmN0aW9uKGZlYXR1cmUsIHJlc29sdXRpb24pO1xuICAgIGlmICghc3R5bGVzKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHN0eWxlcykpIHtcbiAgICAgIHN0eWxlcyA9IFtzdHlsZXNdO1xuICAgIH1cbiAgICBjb25zdCBpbmRleCA9IGkgKiBpbmRleEZhY3RvcjtcbiAgICBjb25zdCBjb2xvciA9IGluZGV4LnRvU3RyaW5nKDE2KS5wYWRTdGFydCg3LCAnIzAwMDAwJyk7XG4gICAgZm9yIChsZXQgaiA9IDAsIGpqID0gc3R5bGVzLmxlbmd0aDsgaiA8IGpqOyArK2opIHtcbiAgICAgIGNvbnN0IG9yaWdpbmFsU3R5bGUgPSBzdHlsZXNbal07XG4gICAgICBjb25zdCBnZW9tZXRyeSA9IG9yaWdpbmFsU3R5bGUuZ2V0R2VvbWV0cnlGdW5jdGlvbigpKGZlYXR1cmUpO1xuICAgICAgaWYgKCFnZW9tZXRyeSB8fCAhaW50ZXJzZWN0cyhleHRlbnQsIGdlb21ldHJ5LmdldEV4dGVudCgpKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHN0eWxlID0gb3JpZ2luYWxTdHlsZS5jbG9uZSgpO1xuICAgICAgY29uc3QgZmlsbCA9IHN0eWxlLmdldEZpbGwoKTtcbiAgICAgIGlmIChmaWxsKSB7XG4gICAgICAgIGZpbGwuc2V0Q29sb3IoY29sb3IpO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3Ryb2tlID0gc3R5bGUuZ2V0U3Ryb2tlKCk7XG4gICAgICBpZiAoc3Ryb2tlKSB7XG4gICAgICAgIHN0cm9rZS5zZXRDb2xvcihjb2xvcik7XG4gICAgICAgIHN0cm9rZS5zZXRMaW5lRGFzaChudWxsKTtcbiAgICAgIH1cbiAgICAgIHN0eWxlLnNldFRleHQodW5kZWZpbmVkKTtcbiAgICAgIGNvbnN0IGltYWdlID0gb3JpZ2luYWxTdHlsZS5nZXRJbWFnZSgpO1xuICAgICAgaWYgKGltYWdlKSB7XG4gICAgICAgIGNvbnN0IGltZ1NpemUgPSBpbWFnZS5nZXRJbWFnZVNpemUoKTtcbiAgICAgICAgaWYgKCFpbWdTaXplKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBpbWdDb250ZXh0ID0gY3JlYXRlQ2FudmFzQ29udGV4dDJEKFxuICAgICAgICAgIGltZ1NpemVbMF0sXG4gICAgICAgICAgaW1nU2l6ZVsxXSxcbiAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAge2FscGhhOiBmYWxzZX1cbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgaW1nID0gaW1nQ29udGV4dC5jYW52YXM7XG4gICAgICAgIGltZ0NvbnRleHQuZmlsbFN0eWxlID0gY29sb3I7XG4gICAgICAgIGltZ0NvbnRleHQuZmlsbFJlY3QoMCwgMCwgaW1nLndpZHRoLCBpbWcuaGVpZ2h0KTtcbiAgICAgICAgc3R5bGUuc2V0SW1hZ2UoXG4gICAgICAgICAgbmV3IEljb24oe1xuICAgICAgICAgICAgaW1nOiBpbWcsXG4gICAgICAgICAgICBhbmNob3I6IGltYWdlLmdldEFuY2hvcigpLFxuICAgICAgICAgICAgYW5jaG9yWFVuaXRzOiAncGl4ZWxzJyxcbiAgICAgICAgICAgIGFuY2hvcllVbml0czogJ3BpeGVscycsXG4gICAgICAgICAgICBvZmZzZXQ6IGltYWdlLmdldE9yaWdpbigpLFxuICAgICAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgICAgIHNpemU6IGltYWdlLmdldFNpemUoKSxcbiAgICAgICAgICAgIHNjYWxlOiBpbWFnZS5nZXRTY2FsZSgpLFxuICAgICAgICAgICAgcm90YXRpb246IGltYWdlLmdldFJvdGF0aW9uKCksXG4gICAgICAgICAgICByb3RhdGVXaXRoVmlldzogaW1hZ2UuZ2V0Um90YXRlV2l0aFZpZXcoKSxcbiAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY29uc3QgekluZGV4ID0gc3R5bGUuZ2V0WkluZGV4KCkgfHwgMDtcbiAgICAgIGxldCBieUdlb21ldHJ5VHlwZSA9IGZlYXR1cmVzQnlaSW5kZXhbekluZGV4XTtcbiAgICAgIGlmICghYnlHZW9tZXRyeVR5cGUpIHtcbiAgICAgICAgYnlHZW9tZXRyeVR5cGUgPSB7fTtcbiAgICAgICAgZmVhdHVyZXNCeVpJbmRleFt6SW5kZXhdID0gYnlHZW9tZXRyeVR5cGU7XG4gICAgICAgIGJ5R2VvbWV0cnlUeXBlWydQb2x5Z29uJ10gPSBbXTtcbiAgICAgICAgYnlHZW9tZXRyeVR5cGVbJ0NpcmNsZSddID0gW107XG4gICAgICAgIGJ5R2VvbWV0cnlUeXBlWydMaW5lU3RyaW5nJ10gPSBbXTtcbiAgICAgICAgYnlHZW9tZXRyeVR5cGVbJ1BvaW50J10gPSBbXTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHR5cGUgPSBnZW9tZXRyeS5nZXRUeXBlKCk7XG4gICAgICBpZiAodHlwZSA9PT0gJ0dlb21ldHJ5Q29sbGVjdGlvbicpIHtcbiAgICAgICAgY29uc3QgZ2VvbWV0cmllcyA9XG4gICAgICAgICAgLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi9nZW9tL0dlb21ldHJ5Q29sbGVjdGlvbi5qc1wiKS5kZWZhdWx0fSAqLyAoXG4gICAgICAgICAgICBnZW9tZXRyeVxuICAgICAgICAgICkuZ2V0R2VvbWV0cmllc0FycmF5UmVjdXJzaXZlKCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IGdlb21ldHJpZXMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICAgIGNvbnN0IGdlb21ldHJ5ID0gZ2VvbWV0cmllc1tpXTtcbiAgICAgICAgICBieUdlb21ldHJ5VHlwZVtnZW9tZXRyeS5nZXRUeXBlKCkucmVwbGFjZSgnTXVsdGknLCAnJyldLnB1c2goXG4gICAgICAgICAgICBnZW9tZXRyeSxcbiAgICAgICAgICAgIHN0eWxlXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnlHZW9tZXRyeVR5cGVbdHlwZS5yZXBsYWNlKCdNdWx0aScsICcnKV0ucHVzaChnZW9tZXRyeSwgc3R5bGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHpJbmRleEtleXMgPSBPYmplY3Qua2V5cyhmZWF0dXJlc0J5WkluZGV4KS5tYXAoTnVtYmVyKS5zb3J0KGFzY2VuZGluZyk7XG4gIGZvciAobGV0IGkgPSAwLCBpaSA9IHpJbmRleEtleXMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgIGNvbnN0IGJ5R2VvbWV0cnlUeXBlID0gZmVhdHVyZXNCeVpJbmRleFt6SW5kZXhLZXlzW2ldXTtcbiAgICBmb3IgKGNvbnN0IHR5cGUgaW4gYnlHZW9tZXRyeVR5cGUpIHtcbiAgICAgIGNvbnN0IGdlb21BbmRTdHlsZSA9IGJ5R2VvbWV0cnlUeXBlW3R5cGVdO1xuICAgICAgZm9yIChsZXQgaiA9IDAsIGpqID0gZ2VvbUFuZFN0eWxlLmxlbmd0aDsgaiA8IGpqOyBqICs9IDIpIHtcbiAgICAgICAgcmVuZGVyZXIuc2V0U3R5bGUoZ2VvbUFuZFN0eWxlW2ogKyAxXSk7XG4gICAgICAgIGZvciAobGV0IGsgPSAwLCBrayA9IHRyYW5zZm9ybXMubGVuZ3RoOyBrIDwga2s7ICsraykge1xuICAgICAgICAgIHJlbmRlcmVyLnNldFRyYW5zZm9ybSh0cmFuc2Zvcm1zW2tdKTtcbiAgICAgICAgICByZW5kZXJlci5kcmF3R2VvbWV0cnkoZ2VvbUFuZFN0eWxlW2pdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gY29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL3BpeGVsXCIpLlBpeGVsfSBwaXhlbCBQaXhlbCBjb29yZGluYXRlIG9uIHRoZSBoaXRcbiAqIGRldGVjdGlvbiBjYW52YXMgaW4gY3NzIHBpeGVscy5cbiAqIEBwYXJhbSB7QXJyYXk8Rj59IGZlYXR1cmVzIEZlYXR1cmVzLiBIYXMgdG9cbiAqIG1hdGNoIHRoZSBgZmVhdHVyZXNgIGFycmF5IHRoYXQgd2FzIHBhc3NlZCB0byBgY3JlYXRlSGl0RGV0ZWN0aW9uSW1hZ2VEYXRhKClgLlxuICogQHBhcmFtIHtJbWFnZURhdGF9IGltYWdlRGF0YSBIaXQgZGV0ZWN0aW9uIGltYWdlIGRhdGEgZ2VuZXJhdGVkIGJ5XG4gKiBgY3JlYXRlSGl0RGV0ZWN0aW9uSW1hZ2VEYXRhKClgLlxuICogQHJldHVybiB7QXJyYXk8Rj59IEZlYXR1cmVzLlxuICogQHRlbXBsYXRlIHtpbXBvcnQoXCIuLi8uLi9GZWF0dXJlLmpzXCIpLkZlYXR1cmVMaWtlfSBGXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoaXREZXRlY3QocGl4ZWwsIGZlYXR1cmVzLCBpbWFnZURhdGEpIHtcbiAgY29uc3QgcmVzdWx0RmVhdHVyZXMgPSBbXTtcbiAgaWYgKGltYWdlRGF0YSkge1xuICAgIGNvbnN0IHggPSBNYXRoLmZsb29yKE1hdGgucm91bmQocGl4ZWxbMF0pICogSElUX0RFVEVDVF9SRVNPTFVUSU9OKTtcbiAgICBjb25zdCB5ID0gTWF0aC5mbG9vcihNYXRoLnJvdW5kKHBpeGVsWzFdKSAqIEhJVF9ERVRFQ1RfUkVTT0xVVElPTik7XG4gICAgLy8gVGhlIHBpeGVsIGNvb3JkaW5hdGUgaXMgY2xhbXBlZCBkb3duIHRvIHRoZSBoaXQtZGV0ZWN0IGNhbnZhcycgc2l6ZSB0byBhY2NvdW50XG4gICAgLy8gZm9yIGJyb3dzZXJzIHJldHVybmluZyBjb29yZGluYXRlcyBzbGlnaHRseSBsYXJnZXIgdGhhbiB0aGUgYWN0dWFsIGNhbnZhcyBzaXplXG4gICAgLy8gZHVlIHRvIGEgbm9uLWludGVnZXIgcGl4ZWwgcmF0aW8uXG4gICAgY29uc3QgaW5kZXggPVxuICAgICAgKGNsYW1wKHgsIDAsIGltYWdlRGF0YS53aWR0aCAtIDEpICtcbiAgICAgICAgY2xhbXAoeSwgMCwgaW1hZ2VEYXRhLmhlaWdodCAtIDEpICogaW1hZ2VEYXRhLndpZHRoKSAqXG4gICAgICA0O1xuICAgIGNvbnN0IHIgPSBpbWFnZURhdGEuZGF0YVtpbmRleF07XG4gICAgY29uc3QgZyA9IGltYWdlRGF0YS5kYXRhW2luZGV4ICsgMV07XG4gICAgY29uc3QgYiA9IGltYWdlRGF0YS5kYXRhW2luZGV4ICsgMl07XG4gICAgY29uc3QgaSA9IGIgKyAyNTYgKiAoZyArIDI1NiAqIHIpO1xuICAgIGNvbnN0IGluZGV4RmFjdG9yID0gTWF0aC5mbG9vcigoMjU2ICogMjU2ICogMjU2IC0gMSkgLyBmZWF0dXJlcy5sZW5ndGgpO1xuICAgIGlmIChpICYmIGkgJSBpbmRleEZhY3RvciA9PT0gMCkge1xuICAgICAgcmVzdWx0RmVhdHVyZXMucHVzaChmZWF0dXJlc1tpIC8gaW5kZXhGYWN0b3IgLSAxXSk7XG4gICAgfVxuICB9XG4gIC8vIEB0cy1pZ25vcmUgRmVhdHVyZXMgYXJlIGNvcGllZCBmcm9tIGBmZWF0dXJlc2AgdG8gYHJlc3VsdEZlYXR1cmVzYCBzbyB0aGUgdHlwZSBzaG91bGQgYmUgdGhlIHNhbWVcbiAgcmV0dXJuIHJlc3VsdEZlYXR1cmVzO1xufVxuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3JlbmRlci9jYW52YXMvc3R5bGVcbiAqL1xuXG5pbXBvcnQgQ2lyY2xlIGZyb20gJy4uLy4uL3N0eWxlL0NpcmNsZS5qcyc7XG5pbXBvcnQgRmlsbCBmcm9tICcuLi8uLi9zdHlsZS9GaWxsLmpzJztcbmltcG9ydCBJY29uIGZyb20gJy4uLy4uL3N0eWxlL0ljb24uanMnO1xuaW1wb3J0IFJlZ3VsYXJTaGFwZSBmcm9tICcuLi8uLi9zdHlsZS9SZWd1bGFyU2hhcGUuanMnO1xuaW1wb3J0IFN0cm9rZSBmcm9tICcuLi8uLi9zdHlsZS9TdHJva2UuanMnO1xuaW1wb3J0IFN0eWxlIGZyb20gJy4uLy4uL3N0eWxlL1N0eWxlLmpzJztcbmltcG9ydCBUZXh0IGZyb20gJy4uLy4uL3N0eWxlL1RleHQuanMnO1xuaW1wb3J0IHtcbiAgQm9vbGVhblR5cGUsXG4gIENvbG9yVHlwZSxcbiAgTnVtYmVyQXJyYXlUeXBlLFxuICBOdW1iZXJUeXBlLFxuICBTdHJpbmdUeXBlLFxuICBuZXdQYXJzaW5nQ29udGV4dCxcbn0gZnJvbSAnLi4vLi4vZXhwci9leHByZXNzaW9uLmpzJztcbmltcG9ydCB7YnVpbGRFeHByZXNzaW9uLCBuZXdFdmFsdWF0aW9uQ29udGV4dH0gZnJvbSAnLi4vLi4vZXhwci9jcHUuanMnO1xuaW1wb3J0IHt0b1NpemV9IGZyb20gJy4uLy4uL3NpemUuanMnO1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgVGhpcyBtb2R1bGUgaW5jbHVkZXMgZnVuY3Rpb25zIHRvIGJ1aWxkIHN0eWxlcyBmb3IgdGhlIGNhbnZhcyByZW5kZXJlci4gIEJ1aWxkaW5nXG4gKiBpcyBjb21wb3NlZCBvZiB0d28gc3RlcHM6IHBhcnNpbmcgYW5kIGNvbXBpbGluZy4gIFRoZSBwYXJzaW5nIHN0ZXAgdGFrZXMgYW4gZW5jb2RlZCBleHByZXNzaW9uXG4gKiBhbmQgcmV0dXJucyBhbiBpbnN0YW5jZSBvZiBvbmUgb2YgdGhlIGV4cHJlc3Npb24gY2xhc3Nlcy4gIFRoZSBjb21waWxpbmcgc3RlcCB0YWtlcyB0aGVcbiAqIGV4cHJlc3Npb24gaW5zdGFuY2UgYW5kIHJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGNhbiBiZSBldmFsdWF0ZWQgdG8gcmV0dXJuIGEgbGl0ZXJhbCB2YWx1ZS4gIFRoZVxuICogZXZhbHVhdG9yIGZ1bmN0aW9uIHNob3VsZCBkbyBhcyBsaXR0bGUgYWxsb2NhdGlvbiBhbmQgd29yayBhcyBwb3NzaWJsZS5cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoXCIuLi8uLi9zdHlsZS9mbGF0LmpzXCIpLkZsYXRTdHlsZX0gRmxhdFN0eWxlXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KFwiLi4vLi4vZXhwci9leHByZXNzaW9uLmpzXCIpLkVuY29kZWRFeHByZXNzaW9ufSBFbmNvZGVkRXhwcmVzc2lvblxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge2ltcG9ydChcIi4uLy4uL2V4cHIvZXhwcmVzc2lvbi5qc1wiKS5QYXJzaW5nQ29udGV4dH0gUGFyc2luZ0NvbnRleHRcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoXCIuLi8uLi9leHByL2V4cHJlc3Npb24uanNcIikuQ2FsbEV4cHJlc3Npb259IENhbGxFeHByZXNzaW9uXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KFwiLi4vLi4vZXhwci9jcHUuanNcIikuRXZhbHVhdGlvbkNvbnRleHR9IEV2YWx1YXRpb25Db250ZXh0XG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KFwiLi4vLi4vZXhwci9jcHUuanNcIikuRXhwcmVzc2lvbkV2YWx1YXRvcn0gRXhwcmVzc2lvbkV2YWx1YXRvclxuICovXG5cbi8qKlxuICogQHBhcmFtIHtFdmFsdWF0aW9uQ29udGV4dH0gY29udGV4dCBUaGUgZXZhbHVhdGlvbiBjb250ZXh0LlxuICogQHJldHVybiB7Ym9vbGVhbn0gQWx3YXlzIHRydWUuXG4gKi9cbmZ1bmN0aW9uIGFsd2F5cyhjb250ZXh0KSB7XG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gYWRhcHRzIGEgcnVsZSBldmFsdWF0b3IgdG8gdGhlIGV4aXN0aW5nIHN0eWxlIGZ1bmN0aW9uIGludGVyZmFjZS5cbiAqIEFmdGVyIHdlIGhhdmUgZGVwcmVjYXRlZCB0aGUgc3R5bGUgZnVuY3Rpb24sIHdlIGNhbiB1c2UgdGhlIGNvbXBpbGVkIHJ1bGVzIGRpcmVjdGx5XG4gKiBhbmQgcGFzcyBhIG1vcmUgY29tcGxldGUgZXZhbHVhdGlvbiBjb250ZXh0ICh2YXJpYWJsZXMsIHpvb20sIHRpbWUsIGV0Yy4pLlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8aW1wb3J0KCcuLi8uLi9zdHlsZS9mbGF0LmpzJykuUnVsZT59IHJ1bGVzIFRoZSBydWxlcy5cbiAqIEByZXR1cm4ge2ltcG9ydCgnLi4vLi4vc3R5bGUvU3R5bGUuanMnKS5TdHlsZUZ1bmN0aW9ufSBBIHN0eWxlIGZ1bmN0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcnVsZXNUb1N0eWxlRnVuY3Rpb24ocnVsZXMpIHtcbiAgY29uc3QgcGFyc2luZ0NvbnRleHQgPSBuZXdQYXJzaW5nQ29udGV4dCgpO1xuICBjb25zdCBldmFsdWF0b3IgPSBidWlsZFJ1bGVTZXQocnVsZXMsIHBhcnNpbmdDb250ZXh0KTtcbiAgY29uc3QgZXZhbHVhdGlvbkNvbnRleHQgPSBuZXdFdmFsdWF0aW9uQ29udGV4dCgpO1xuICByZXR1cm4gZnVuY3Rpb24gKGZlYXR1cmUsIHJlc29sdXRpb24pIHtcbiAgICBldmFsdWF0aW9uQ29udGV4dC5wcm9wZXJ0aWVzID0gZmVhdHVyZS5nZXRQcm9wZXJ0aWVzSW50ZXJuYWwoKTtcbiAgICBldmFsdWF0aW9uQ29udGV4dC5yZXNvbHV0aW9uID0gcmVzb2x1dGlvbjtcbiAgICByZXR1cm4gZXZhbHVhdG9yKGV2YWx1YXRpb25Db250ZXh0KTtcbiAgfTtcbn1cblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGFkYXB0cyBhIHN0eWxlIGV2YWx1YXRvciB0byB0aGUgZXhpc3Rpbmcgc3R5bGUgZnVuY3Rpb24gaW50ZXJmYWNlLlxuICogQWZ0ZXIgd2UgaGF2ZSBkZXByZWNhdGVkIHRoZSBzdHlsZSBmdW5jdGlvbiwgd2UgY2FuIHVzZSB0aGUgY29tcGlsZWQgcnVsZXMgZGlyZWN0bHlcbiAqIGFuZCBwYXNzIGEgbW9yZSBjb21wbGV0ZSBldmFsdWF0aW9uIGNvbnRleHQgKHZhcmlhYmxlcywgem9vbSwgdGltZSwgZXRjLikuXG4gKlxuICogQHBhcmFtIHtBcnJheTxpbXBvcnQoJy4uLy4uL3N0eWxlL2ZsYXQuanMnKS5GbGF0U3R5bGU+fSBmbGF0U3R5bGVzIFRoZSBmbGF0IHN0eWxlcy5cbiAqIEByZXR1cm4ge2ltcG9ydCgnLi4vLi4vc3R5bGUvU3R5bGUuanMnKS5TdHlsZUZ1bmN0aW9ufSBBIHN0eWxlIGZ1bmN0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZmxhdFN0eWxlc1RvU3R5bGVGdW5jdGlvbihmbGF0U3R5bGVzKSB7XG4gIGNvbnN0IHBhcnNpbmdDb250ZXh0ID0gbmV3UGFyc2luZ0NvbnRleHQoKTtcbiAgY29uc3QgbGVuZ3RoID0gZmxhdFN0eWxlcy5sZW5ndGg7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtBcnJheTxTdHlsZUV2YWx1YXRvcj59XG4gICAqL1xuICBjb25zdCBldmFsdWF0b3JzID0gbmV3IEFycmF5KGxlbmd0aCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBldmFsdWF0b3JzW2ldID0gYnVpbGRTdHlsZShmbGF0U3R5bGVzW2ldLCBwYXJzaW5nQ29udGV4dCk7XG4gIH1cbiAgY29uc3QgZXZhbHVhdGlvbkNvbnRleHQgPSBuZXdFdmFsdWF0aW9uQ29udGV4dCgpO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7QXJyYXk8U3R5bGU+fVxuICAgKi9cbiAgY29uc3Qgc3R5bGVzID0gbmV3IEFycmF5KGxlbmd0aCk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChmZWF0dXJlLCByZXNvbHV0aW9uKSB7XG4gICAgZXZhbHVhdGlvbkNvbnRleHQucHJvcGVydGllcyA9IGZlYXR1cmUuZ2V0UHJvcGVydGllc0ludGVybmFsKCk7XG4gICAgZXZhbHVhdGlvbkNvbnRleHQucmVzb2x1dGlvbiA9IHJlc29sdXRpb247XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgICAgc3R5bGVzW2ldID0gZXZhbHVhdG9yc1tpXShldmFsdWF0aW9uQ29udGV4dCk7XG4gICAgfVxuICAgIHJldHVybiBzdHlsZXM7XG4gIH07XG59XG5cbi8qKlxuICogQHR5cGVkZWYge2Z1bmN0aW9uKEV2YWx1YXRpb25Db250ZXh0KTpBcnJheTxTdHlsZT59IFJ1bGVTZXRFdmFsdWF0b3JcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IENvbXBpbGVkUnVsZVxuICogQHByb3BlcnR5IHtFeHByZXNzaW9uRXZhbHVhdG9yfSBmaWx0ZXIgVGhlIGNvbXBpbGVkIGZpbHRlciBldmFsdWF0b3IuXG4gKiBAcHJvcGVydHkge0FycmF5PFN0eWxlRXZhbHVhdG9yPn0gc3R5bGVzIFRoZSBsaXN0IG9mIGNvbXBpbGVkIHN0eWxlIGV2YWx1YXRvcnMuXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PGltcG9ydCgnLi4vLi4vc3R5bGUvZmxhdC5qcycpLlJ1bGU+fSBydWxlcyBUaGUgcnVsZXMuXG4gKiBAcGFyYW0ge1BhcnNpbmdDb250ZXh0fSBjb250ZXh0IFRoZSBwYXJzaW5nIGNvbnRleHQuXG4gKiBAcmV0dXJuIHtSdWxlU2V0RXZhbHVhdG9yfSBUaGUgZXZhbHVhdG9yIGZ1bmN0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYnVpbGRSdWxlU2V0KHJ1bGVzLCBjb250ZXh0KSB7XG4gIGNvbnN0IGxlbmd0aCA9IHJ1bGVzLmxlbmd0aDtcblxuICAvKipcbiAgICogQHR5cGUge0FycmF5PENvbXBpbGVkUnVsZT59XG4gICAqL1xuICBjb25zdCBjb21waWxlZFJ1bGVzID0gbmV3IEFycmF5KGxlbmd0aCk7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGNvbnN0IHJ1bGUgPSBydWxlc1tpXTtcbiAgICBjb25zdCBmaWx0ZXIgPVxuICAgICAgJ2ZpbHRlcicgaW4gcnVsZVxuICAgICAgICA/IGJ1aWxkRXhwcmVzc2lvbihydWxlLmZpbHRlciwgQm9vbGVhblR5cGUsIGNvbnRleHQpXG4gICAgICAgIDogYWx3YXlzO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge0FycmF5PFN0eWxlRXZhbHVhdG9yPn1cbiAgICAgKi9cbiAgICBsZXQgc3R5bGVzO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHJ1bGUuc3R5bGUpKSB7XG4gICAgICBjb25zdCBzdHlsZUxlbmd0aCA9IHJ1bGUuc3R5bGUubGVuZ3RoO1xuICAgICAgc3R5bGVzID0gbmV3IEFycmF5KHN0eWxlTGVuZ3RoKTtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgc3R5bGVMZW5ndGg7ICsraikge1xuICAgICAgICBzdHlsZXNbal0gPSBidWlsZFN0eWxlKHJ1bGUuc3R5bGVbal0sIGNvbnRleHQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdHlsZXMgPSBbYnVpbGRTdHlsZShydWxlLnN0eWxlLCBjb250ZXh0KV07XG4gICAgfVxuXG4gICAgY29tcGlsZWRSdWxlc1tpXSA9IHtmaWx0ZXIsIHN0eWxlc307XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QXJyYXk8U3R5bGU+fVxuICAgICAqL1xuICAgIGNvbnN0IHN0eWxlcyA9IFtdO1xuXG4gICAgbGV0IHNvbWVNYXRjaGVkID0gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgICAgY29uc3QgZmlsdGVyRXZhbHVhdG9yID0gY29tcGlsZWRSdWxlc1tpXS5maWx0ZXI7XG4gICAgICBpZiAoIWZpbHRlckV2YWx1YXRvcihjb250ZXh0KSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChydWxlc1tpXS5lbHNlICYmIHNvbWVNYXRjaGVkKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgc29tZU1hdGNoZWQgPSB0cnVlO1xuICAgICAgZm9yIChjb25zdCBzdHlsZUV2YWx1YXRvciBvZiBjb21waWxlZFJ1bGVzW2ldLnN0eWxlcykge1xuICAgICAgICBjb25zdCBzdHlsZSA9IHN0eWxlRXZhbHVhdG9yKGNvbnRleHQpO1xuICAgICAgICBpZiAoIXN0eWxlKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgc3R5bGVzLnB1c2goc3R5bGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzdHlsZXM7XG4gIH07XG59XG5cbi8qKlxuICogQHR5cGVkZWYge2Z1bmN0aW9uKEV2YWx1YXRpb25Db250ZXh0KTpTdHlsZX0gU3R5bGVFdmFsdWF0b3JcbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7RmxhdFN0eWxlfSBmbGF0U3R5bGUgQSBmbGF0IHN0eWxlIGxpdGVyYWwuXG4gKiBAcGFyYW0ge1BhcnNpbmdDb250ZXh0fSBjb250ZXh0IFRoZSBwYXJzaW5nIGNvbnRleHQuXG4gKiBAcmV0dXJuIHtTdHlsZUV2YWx1YXRvcn0gQSBmdW5jdGlvbiB0aGF0IGV2YWx1YXRlcyB0byBhIHN0eWxlLiAgVGhlIHN0eWxlIHJldHVybmVkIGJ5XG4gKiB0aGlzIGZ1bmN0aW9uIHdpbGwgYmUgcmV1c2VkIGJldHdlZW4gaW52b2NhdGlvbnMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBidWlsZFN0eWxlKGZsYXRTdHlsZSwgY29udGV4dCkge1xuICBjb25zdCBldmFsdWF0ZUZpbGwgPSBidWlsZEZpbGwoZmxhdFN0eWxlLCAnJywgY29udGV4dCk7XG4gIGNvbnN0IGV2YWx1YXRlU3Ryb2tlID0gYnVpbGRTdHJva2UoZmxhdFN0eWxlLCAnJywgY29udGV4dCk7XG4gIGNvbnN0IGV2YWx1YXRlVGV4dCA9IGJ1aWxkVGV4dChmbGF0U3R5bGUsIGNvbnRleHQpO1xuICBjb25zdCBldmFsdWF0ZUltYWdlID0gYnVpbGRJbWFnZShmbGF0U3R5bGUsIGNvbnRleHQpO1xuICBjb25zdCBldmFsdWF0ZVpJbmRleCA9IG51bWJlckV2YWx1YXRvcihmbGF0U3R5bGUsICd6LWluZGV4JywgY29udGV4dCk7XG5cbiAgY29uc3Qgc3R5bGUgPSBuZXcgU3R5bGUoKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgbGV0IGVtcHR5ID0gdHJ1ZTtcbiAgICBpZiAoZXZhbHVhdGVGaWxsKSB7XG4gICAgICBjb25zdCBmaWxsID0gZXZhbHVhdGVGaWxsKGNvbnRleHQpO1xuICAgICAgaWYgKGZpbGwpIHtcbiAgICAgICAgZW1wdHkgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHN0eWxlLnNldEZpbGwoZmlsbCk7XG4gICAgfVxuICAgIGlmIChldmFsdWF0ZVN0cm9rZSkge1xuICAgICAgY29uc3Qgc3Ryb2tlID0gZXZhbHVhdGVTdHJva2UoY29udGV4dCk7XG4gICAgICBpZiAoc3Ryb2tlKSB7XG4gICAgICAgIGVtcHR5ID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBzdHlsZS5zZXRTdHJva2Uoc3Ryb2tlKTtcbiAgICB9XG4gICAgaWYgKGV2YWx1YXRlVGV4dCkge1xuICAgICAgY29uc3QgdGV4dCA9IGV2YWx1YXRlVGV4dChjb250ZXh0KTtcbiAgICAgIGlmICh0ZXh0KSB7XG4gICAgICAgIGVtcHR5ID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBzdHlsZS5zZXRUZXh0KHRleHQpO1xuICAgIH1cbiAgICBpZiAoZXZhbHVhdGVJbWFnZSkge1xuICAgICAgY29uc3QgaW1hZ2UgPSBldmFsdWF0ZUltYWdlKGNvbnRleHQpO1xuICAgICAgaWYgKGltYWdlKSB7XG4gICAgICAgIGVtcHR5ID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBzdHlsZS5zZXRJbWFnZShpbWFnZSk7XG4gICAgfVxuICAgIGlmIChldmFsdWF0ZVpJbmRleCkge1xuICAgICAgc3R5bGUuc2V0WkluZGV4KGV2YWx1YXRlWkluZGV4KGNvbnRleHQpKTtcbiAgICB9XG4gICAgaWYgKGVtcHR5KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHN0eWxlO1xuICB9O1xufVxuXG4vKipcbiAqIEB0eXBlZGVmIHtmdW5jdGlvbihFdmFsdWF0aW9uQ29udGV4dCk6RmlsbH0gRmlsbEV2YWx1YXRvclxuICovXG5cbi8qKlxuICogQHBhcmFtIHtGbGF0U3R5bGV9IGZsYXRTdHlsZSBUaGUgZmxhdCBzdHlsZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBwcmVmaXggVGhlIHByb3BlcnR5IHByZWZpeC5cbiAqIEBwYXJhbSB7UGFyc2luZ0NvbnRleHR9IGNvbnRleHQgVGhlIHBhcnNpbmcgY29udGV4dC5cbiAqIEByZXR1cm4ge0ZpbGxFdmFsdWF0b3I/fSBBIGZ1bmN0aW9uIHRoYXQgZXZhbHVhdGVzIHRvIGEgZmlsbC5cbiAqL1xuZnVuY3Rpb24gYnVpbGRGaWxsKGZsYXRTdHlsZSwgcHJlZml4LCBjb250ZXh0KSB7XG4gIGNvbnN0IGV2YWx1YXRlQ29sb3IgPSBjb2xvckxpa2VFdmFsdWF0b3IoXG4gICAgZmxhdFN0eWxlLFxuICAgIHByZWZpeCArICdmaWxsLWNvbG9yJyxcbiAgICBjb250ZXh0XG4gICk7XG4gIGlmICghZXZhbHVhdGVDb2xvcikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgY29uc3QgZmlsbCA9IG5ldyBGaWxsKCk7XG4gIHJldHVybiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgIGNvbnN0IGNvbG9yID0gZXZhbHVhdGVDb2xvcihjb250ZXh0KTtcbiAgICBpZiAoY29sb3IgPT09ICdub25lJykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGZpbGwuc2V0Q29sb3IoY29sb3IpO1xuICAgIHJldHVybiBmaWxsO1xuICB9O1xufVxuXG4vKipcbiAqIEB0eXBlZGVmIHtmdW5jdGlvbihFdmFsdWF0aW9uQ29udGV4dCk6U3Ryb2tlfSBTdHJva2VFdmFsdWF0b3JcbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7RmxhdFN0eWxlfSBmbGF0U3R5bGUgVGhlIGZsYXQgc3R5bGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJlZml4IFRoZSBwcm9wZXJ0eSBwcmVmaXguXG4gKiBAcGFyYW0ge1BhcnNpbmdDb250ZXh0fSBjb250ZXh0IFRoZSBwYXJzaW5nIGNvbnRleHQuXG4gKiBAcmV0dXJuIHtTdHJva2VFdmFsdWF0b3I/fSBBIGZ1bmN0aW9uIHRoZSBldmFsdWF0ZXMgdG8gYSBzdHJva2UuXG4gKi9cbmZ1bmN0aW9uIGJ1aWxkU3Ryb2tlKGZsYXRTdHlsZSwgcHJlZml4LCBjb250ZXh0KSB7XG4gIGNvbnN0IGV2YWx1YXRlV2lkdGggPSBudW1iZXJFdmFsdWF0b3IoXG4gICAgZmxhdFN0eWxlLFxuICAgIHByZWZpeCArICdzdHJva2Utd2lkdGgnLFxuICAgIGNvbnRleHRcbiAgKTtcblxuICBjb25zdCBldmFsdWF0ZUNvbG9yID0gY29sb3JMaWtlRXZhbHVhdG9yKFxuICAgIGZsYXRTdHlsZSxcbiAgICBwcmVmaXggKyAnc3Ryb2tlLWNvbG9yJyxcbiAgICBjb250ZXh0XG4gICk7XG5cbiAgaWYgKCFldmFsdWF0ZVdpZHRoICYmICFldmFsdWF0ZUNvbG9yKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBjb25zdCBldmFsdWF0ZUxpbmVDYXAgPSBzdHJpbmdFdmFsdWF0b3IoXG4gICAgZmxhdFN0eWxlLFxuICAgIHByZWZpeCArICdzdHJva2UtbGluZS1jYXAnLFxuICAgIGNvbnRleHRcbiAgKTtcblxuICBjb25zdCBldmFsdWF0ZUxpbmVKb2luID0gc3RyaW5nRXZhbHVhdG9yKFxuICAgIGZsYXRTdHlsZSxcbiAgICBwcmVmaXggKyAnc3Ryb2tlLWxpbmUtam9pbicsXG4gICAgY29udGV4dFxuICApO1xuXG4gIGNvbnN0IGV2YWx1YXRlTGluZURhc2ggPSBudW1iZXJBcnJheUV2YWx1YXRvcihcbiAgICBmbGF0U3R5bGUsXG4gICAgcHJlZml4ICsgJ3N0cm9rZS1saW5lLWRhc2gnLFxuICAgIGNvbnRleHRcbiAgKTtcblxuICBjb25zdCBldmFsdWF0ZUxpbmVEYXNoT2Zmc2V0ID0gbnVtYmVyRXZhbHVhdG9yKFxuICAgIGZsYXRTdHlsZSxcbiAgICBwcmVmaXggKyAnc3Ryb2tlLWxpbmUtZGFzaC1vZmZzZXQnLFxuICAgIGNvbnRleHRcbiAgKTtcblxuICBjb25zdCBldmFsdWF0ZU1pdGVyTGltaXQgPSBudW1iZXJFdmFsdWF0b3IoXG4gICAgZmxhdFN0eWxlLFxuICAgIHByZWZpeCArICdzdHJva2UtbWl0ZXItbGltaXQnLFxuICAgIGNvbnRleHRcbiAgKTtcblxuICBjb25zdCBzdHJva2UgPSBuZXcgU3Ryb2tlKCk7XG4gIHJldHVybiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgIGlmIChldmFsdWF0ZUNvbG9yKSB7XG4gICAgICBjb25zdCBjb2xvciA9IGV2YWx1YXRlQ29sb3IoY29udGV4dCk7XG4gICAgICBpZiAoY29sb3IgPT09ICdub25lJykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHN0cm9rZS5zZXRDb2xvcihjb2xvcik7XG4gICAgfVxuXG4gICAgaWYgKGV2YWx1YXRlV2lkdGgpIHtcbiAgICAgIHN0cm9rZS5zZXRXaWR0aChldmFsdWF0ZVdpZHRoKGNvbnRleHQpKTtcbiAgICB9XG5cbiAgICBpZiAoZXZhbHVhdGVMaW5lQ2FwKSB7XG4gICAgICBjb25zdCBsaW5lQ2FwID0gZXZhbHVhdGVMaW5lQ2FwKGNvbnRleHQpO1xuICAgICAgaWYgKGxpbmVDYXAgIT09ICdidXR0JyAmJiBsaW5lQ2FwICE9PSAncm91bmQnICYmIGxpbmVDYXAgIT09ICdzcXVhcmUnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgYnV0dCwgcm91bmQsIG9yIHNxdWFyZSBsaW5lIGNhcCcpO1xuICAgICAgfVxuICAgICAgc3Ryb2tlLnNldExpbmVDYXAobGluZUNhcCk7XG4gICAgfVxuXG4gICAgaWYgKGV2YWx1YXRlTGluZUpvaW4pIHtcbiAgICAgIGNvbnN0IGxpbmVKb2luID0gZXZhbHVhdGVMaW5lSm9pbihjb250ZXh0KTtcbiAgICAgIGlmIChcbiAgICAgICAgbGluZUpvaW4gIT09ICdiZXZlbCcgJiZcbiAgICAgICAgbGluZUpvaW4gIT09ICdyb3VuZCcgJiZcbiAgICAgICAgbGluZUpvaW4gIT09ICdtaXRlcidcbiAgICAgICkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGJldmVsLCByb3VuZCwgb3IgbWl0ZXIgbGluZSBqb2luJyk7XG4gICAgICB9XG4gICAgICBzdHJva2Uuc2V0TGluZUpvaW4obGluZUpvaW4pO1xuICAgIH1cblxuICAgIGlmIChldmFsdWF0ZUxpbmVEYXNoKSB7XG4gICAgICBzdHJva2Uuc2V0TGluZURhc2goZXZhbHVhdGVMaW5lRGFzaChjb250ZXh0KSk7XG4gICAgfVxuXG4gICAgaWYgKGV2YWx1YXRlTGluZURhc2hPZmZzZXQpIHtcbiAgICAgIHN0cm9rZS5zZXRMaW5lRGFzaE9mZnNldChldmFsdWF0ZUxpbmVEYXNoT2Zmc2V0KGNvbnRleHQpKTtcbiAgICB9XG5cbiAgICBpZiAoZXZhbHVhdGVNaXRlckxpbWl0KSB7XG4gICAgICBzdHJva2Uuc2V0TWl0ZXJMaW1pdChldmFsdWF0ZU1pdGVyTGltaXQoY29udGV4dCkpO1xuICAgIH1cblxuICAgIHJldHVybiBzdHJva2U7XG4gIH07XG59XG5cbi8qKlxuICogQHR5cGVkZWYge2Z1bmN0aW9uKEV2YWx1YXRpb25Db250ZXh0KTpUZXh0fSBUZXh0RXZhbHVhdG9yXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge0ZsYXRTdHlsZX0gZmxhdFN0eWxlIFRoZSBmbGF0IHN0eWxlLlxuICogQHBhcmFtIHtQYXJzaW5nQ29udGV4dH0gY29udGV4dCBUaGUgcGFyc2luZyBjb250ZXh0LlxuICogQHJldHVybiB7VGV4dEV2YWx1YXRvcj99IEEgZnVuY3Rpb24gdGhhdCBldmFsdWF0ZXMgdG8gYSB0ZXh0IHN5bWJvbGl6ZXIuXG4gKi9cbmZ1bmN0aW9uIGJ1aWxkVGV4dChmbGF0U3R5bGUsIGNvbnRleHQpIHtcbiAgY29uc3QgcHJlZml4ID0gJ3RleHQtJztcblxuICAvLyBDdXJyZW50bHksIGFuIEFycmF5PHN0cmluZz4gbWF5IGJlIHVzZWQgZm9yIHJpY2ggdGV4dCBzdXBwb3J0LiAgVGhpcyBkb2Vzbid0XG4gIC8vIHdvcmsgd2l0aCBvdXIgZXhwcmVzc2lvbiBzeW50YXggd2hlcmUgYXJyYXlzIG9mIHN0cmluZ3MgYXJlIGludGVycHJldGVkIGFzXG4gIC8vIGNhbGwgZXhwcmVzc2lvbnMuICBUbyBzdXBwb3J0IHJpY2ggdGV4dCwgd2UgY291bGQgYWRkIGEgJ3N0cmluZ3MnIG9wZXJhdG9yXG4gIC8vIHdoZXJlIGFsbCB0aGUgZm9sbG93aW5nIGFyZ3VtZW50cyB3b3VsZCBiZSBzdHJpbmcgdmFsdWVzLlxuICBjb25zdCBldmFsdWF0ZVZhbHVlID0gc3RyaW5nRXZhbHVhdG9yKGZsYXRTdHlsZSwgcHJlZml4ICsgJ3ZhbHVlJywgY29udGV4dCk7XG4gIGlmICghZXZhbHVhdGVWYWx1ZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgY29uc3QgZXZhbHVhdGVGaWxsID0gYnVpbGRGaWxsKGZsYXRTdHlsZSwgcHJlZml4LCBjb250ZXh0KTtcblxuICBjb25zdCBldmFsdWF0ZUJhY2tncm91bmRGaWxsID0gYnVpbGRGaWxsKFxuICAgIGZsYXRTdHlsZSxcbiAgICBwcmVmaXggKyAnYmFja2dyb3VuZC0nLFxuICAgIGNvbnRleHRcbiAgKTtcblxuICBjb25zdCBldmFsdWF0ZVN0cm9rZSA9IGJ1aWxkU3Ryb2tlKGZsYXRTdHlsZSwgcHJlZml4LCBjb250ZXh0KTtcblxuICBjb25zdCBldmFsdWF0ZUJhY2tncm91bmRTdHJva2UgPSBidWlsZFN0cm9rZShcbiAgICBmbGF0U3R5bGUsXG4gICAgcHJlZml4ICsgJ2JhY2tncm91bmQtJyxcbiAgICBjb250ZXh0XG4gICk7XG5cbiAgY29uc3QgZXZhbHVhdGVGb250ID0gc3RyaW5nRXZhbHVhdG9yKGZsYXRTdHlsZSwgcHJlZml4ICsgJ2ZvbnQnLCBjb250ZXh0KTtcblxuICBjb25zdCBldmFsdWF0ZU1heEFuZ2xlID0gbnVtYmVyRXZhbHVhdG9yKFxuICAgIGZsYXRTdHlsZSxcbiAgICBwcmVmaXggKyAnbWF4LWFuZ2xlJyxcbiAgICBjb250ZXh0XG4gICk7XG5cbiAgY29uc3QgZXZhbHVhdGVPZmZzZXRYID0gbnVtYmVyRXZhbHVhdG9yKFxuICAgIGZsYXRTdHlsZSxcbiAgICBwcmVmaXggKyAnb2Zmc2V0LXgnLFxuICAgIGNvbnRleHRcbiAgKTtcblxuICBjb25zdCBldmFsdWF0ZU9mZnNldFkgPSBudW1iZXJFdmFsdWF0b3IoXG4gICAgZmxhdFN0eWxlLFxuICAgIHByZWZpeCArICdvZmZzZXQteScsXG4gICAgY29udGV4dFxuICApO1xuXG4gIGNvbnN0IGV2YWx1YXRlT3ZlcmZsb3cgPSBib29sZWFuRXZhbHVhdG9yKFxuICAgIGZsYXRTdHlsZSxcbiAgICBwcmVmaXggKyAnb3ZlcmZsb3cnLFxuICAgIGNvbnRleHRcbiAgKTtcblxuICBjb25zdCBldmFsdWF0ZVBsYWNlbWVudCA9IHN0cmluZ0V2YWx1YXRvcihcbiAgICBmbGF0U3R5bGUsXG4gICAgcHJlZml4ICsgJ3BsYWNlbWVudCcsXG4gICAgY29udGV4dFxuICApO1xuXG4gIGNvbnN0IGV2YWx1YXRlUmVwZWF0ID0gbnVtYmVyRXZhbHVhdG9yKGZsYXRTdHlsZSwgcHJlZml4ICsgJ3JlcGVhdCcsIGNvbnRleHQpO1xuXG4gIGNvbnN0IGV2YWx1YXRlU2NhbGUgPSBzaXplTGlrZUV2YWx1YXRvcihmbGF0U3R5bGUsIHByZWZpeCArICdzY2FsZScsIGNvbnRleHQpO1xuXG4gIGNvbnN0IGV2YWx1YXRlUm90YXRlV2l0aFZpZXcgPSBib29sZWFuRXZhbHVhdG9yKFxuICAgIGZsYXRTdHlsZSxcbiAgICBwcmVmaXggKyAncm90YXRlLXdpdGgtdmlldycsXG4gICAgY29udGV4dFxuICApO1xuXG4gIGNvbnN0IGV2YWx1YXRlUm90YXRpb24gPSBudW1iZXJFdmFsdWF0b3IoXG4gICAgZmxhdFN0eWxlLFxuICAgIHByZWZpeCArICdyb3RhdGlvbicsXG4gICAgY29udGV4dFxuICApO1xuXG4gIGNvbnN0IGV2YWx1YXRlQWxpZ24gPSBzdHJpbmdFdmFsdWF0b3IoZmxhdFN0eWxlLCBwcmVmaXggKyAnYWxpZ24nLCBjb250ZXh0KTtcblxuICBjb25zdCBldmFsdWF0ZUp1c3RpZnkgPSBzdHJpbmdFdmFsdWF0b3IoXG4gICAgZmxhdFN0eWxlLFxuICAgIHByZWZpeCArICdqdXN0aWZ5JyxcbiAgICBjb250ZXh0XG4gICk7XG5cbiAgY29uc3QgZXZhbHVhdGVCYXNlbGluZSA9IHN0cmluZ0V2YWx1YXRvcihcbiAgICBmbGF0U3R5bGUsXG4gICAgcHJlZml4ICsgJ2Jhc2VsaW5lJyxcbiAgICBjb250ZXh0XG4gICk7XG5cbiAgY29uc3QgZXZhbHVhdGVQYWRkaW5nID0gbnVtYmVyQXJyYXlFdmFsdWF0b3IoXG4gICAgZmxhdFN0eWxlLFxuICAgIHByZWZpeCArICdwYWRkaW5nJyxcbiAgICBjb250ZXh0XG4gICk7XG5cbiAgY29uc3QgdGV4dCA9IG5ldyBUZXh0KHt9KTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgdGV4dC5zZXRUZXh0KGV2YWx1YXRlVmFsdWUoY29udGV4dCkpO1xuXG4gICAgaWYgKGV2YWx1YXRlRmlsbCkge1xuICAgICAgdGV4dC5zZXRGaWxsKGV2YWx1YXRlRmlsbChjb250ZXh0KSk7XG4gICAgfVxuXG4gICAgaWYgKGV2YWx1YXRlQmFja2dyb3VuZEZpbGwpIHtcbiAgICAgIHRleHQuc2V0QmFja2dyb3VuZEZpbGwoZXZhbHVhdGVCYWNrZ3JvdW5kRmlsbChjb250ZXh0KSk7XG4gICAgfVxuXG4gICAgaWYgKGV2YWx1YXRlU3Ryb2tlKSB7XG4gICAgICB0ZXh0LnNldFN0cm9rZShldmFsdWF0ZVN0cm9rZShjb250ZXh0KSk7XG4gICAgfVxuXG4gICAgaWYgKGV2YWx1YXRlQmFja2dyb3VuZFN0cm9rZSkge1xuICAgICAgdGV4dC5zZXRCYWNrZ3JvdW5kU3Ryb2tlKGV2YWx1YXRlQmFja2dyb3VuZFN0cm9rZShjb250ZXh0KSk7XG4gICAgfVxuXG4gICAgaWYgKGV2YWx1YXRlRm9udCkge1xuICAgICAgdGV4dC5zZXRGb250KGV2YWx1YXRlRm9udChjb250ZXh0KSk7XG4gICAgfVxuXG4gICAgaWYgKGV2YWx1YXRlTWF4QW5nbGUpIHtcbiAgICAgIHRleHQuc2V0TWF4QW5nbGUoZXZhbHVhdGVNYXhBbmdsZShjb250ZXh0KSk7XG4gICAgfVxuXG4gICAgaWYgKGV2YWx1YXRlT2Zmc2V0WCkge1xuICAgICAgdGV4dC5zZXRPZmZzZXRYKGV2YWx1YXRlT2Zmc2V0WChjb250ZXh0KSk7XG4gICAgfVxuXG4gICAgaWYgKGV2YWx1YXRlT2Zmc2V0WSkge1xuICAgICAgdGV4dC5zZXRPZmZzZXRZKGV2YWx1YXRlT2Zmc2V0WShjb250ZXh0KSk7XG4gICAgfVxuXG4gICAgaWYgKGV2YWx1YXRlT3ZlcmZsb3cpIHtcbiAgICAgIHRleHQuc2V0T3ZlcmZsb3coZXZhbHVhdGVPdmVyZmxvdyhjb250ZXh0KSk7XG4gICAgfVxuXG4gICAgaWYgKGV2YWx1YXRlUGxhY2VtZW50KSB7XG4gICAgICBjb25zdCBwbGFjZW1lbnQgPSBldmFsdWF0ZVBsYWNlbWVudChjb250ZXh0KTtcbiAgICAgIGlmIChwbGFjZW1lbnQgIT09ICdwb2ludCcgJiYgcGxhY2VtZW50ICE9PSAnbGluZScpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBwb2ludCBvciBsaW5lIGZvciB0ZXh0LXBsYWNlbWVudCcpO1xuICAgICAgfVxuICAgICAgdGV4dC5zZXRQbGFjZW1lbnQocGxhY2VtZW50KTtcbiAgICB9XG5cbiAgICBpZiAoZXZhbHVhdGVSZXBlYXQpIHtcbiAgICAgIHRleHQuc2V0UmVwZWF0KGV2YWx1YXRlUmVwZWF0KGNvbnRleHQpKTtcbiAgICB9XG5cbiAgICBpZiAoZXZhbHVhdGVTY2FsZSkge1xuICAgICAgdGV4dC5zZXRTY2FsZShldmFsdWF0ZVNjYWxlKGNvbnRleHQpKTtcbiAgICB9XG5cbiAgICBpZiAoZXZhbHVhdGVSb3RhdGVXaXRoVmlldykge1xuICAgICAgdGV4dC5zZXRSb3RhdGVXaXRoVmlldyhldmFsdWF0ZVJvdGF0ZVdpdGhWaWV3KGNvbnRleHQpKTtcbiAgICB9XG5cbiAgICBpZiAoZXZhbHVhdGVSb3RhdGlvbikge1xuICAgICAgdGV4dC5zZXRSb3RhdGlvbihldmFsdWF0ZVJvdGF0aW9uKGNvbnRleHQpKTtcbiAgICB9XG5cbiAgICBpZiAoZXZhbHVhdGVBbGlnbikge1xuICAgICAgY29uc3QgdGV4dEFsaWduID0gZXZhbHVhdGVBbGlnbihjb250ZXh0KTtcbiAgICAgIGlmIChcbiAgICAgICAgdGV4dEFsaWduICE9PSAnbGVmdCcgJiZcbiAgICAgICAgdGV4dEFsaWduICE9PSAnY2VudGVyJyAmJlxuICAgICAgICB0ZXh0QWxpZ24gIT09ICdyaWdodCcgJiZcbiAgICAgICAgdGV4dEFsaWduICE9PSAnZW5kJyAmJlxuICAgICAgICB0ZXh0QWxpZ24gIT09ICdzdGFydCdcbiAgICAgICkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgJ0V4cGVjdGVkIGxlZnQsIHJpZ2h0LCBjZW50ZXIsIHN0YXJ0LCBvciBlbmQgZm9yIHRleHQtYWxpZ24nXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICB0ZXh0LnNldFRleHRBbGlnbih0ZXh0QWxpZ24pO1xuICAgIH1cblxuICAgIGlmIChldmFsdWF0ZUp1c3RpZnkpIHtcbiAgICAgIGNvbnN0IGp1c3RpZnkgPSBldmFsdWF0ZUp1c3RpZnkoY29udGV4dCk7XG4gICAgICBpZiAoanVzdGlmeSAhPT0gJ2xlZnQnICYmIGp1c3RpZnkgIT09ICdyaWdodCcgJiYganVzdGlmeSAhPT0gJ2NlbnRlcicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBsZWZ0LCByaWdodCwgb3IgY2VudGVyIGZvciB0ZXh0LWp1c3RpZnknKTtcbiAgICAgIH1cbiAgICAgIHRleHQuc2V0SnVzdGlmeShqdXN0aWZ5KTtcbiAgICB9XG5cbiAgICBpZiAoZXZhbHVhdGVCYXNlbGluZSkge1xuICAgICAgY29uc3QgdGV4dEJhc2VsaW5lID0gZXZhbHVhdGVCYXNlbGluZShjb250ZXh0KTtcbiAgICAgIGlmIChcbiAgICAgICAgdGV4dEJhc2VsaW5lICE9PSAnYm90dG9tJyAmJlxuICAgICAgICB0ZXh0QmFzZWxpbmUgIT09ICd0b3AnICYmXG4gICAgICAgIHRleHRCYXNlbGluZSAhPT0gJ21pZGRsZScgJiZcbiAgICAgICAgdGV4dEJhc2VsaW5lICE9PSAnYWxwaGFiZXRpYycgJiZcbiAgICAgICAgdGV4dEJhc2VsaW5lICE9PSAnaGFuZ2luZydcbiAgICAgICkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgJ0V4cGVjdGVkIGJvdHRvbSwgdG9wLCBtaWRkbGUsIGFscGhhYmV0aWMsIG9yIGhhbmdpbmcgZm9yIHRleHQtYmFzZWxpbmUnXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICB0ZXh0LnNldFRleHRCYXNlbGluZSh0ZXh0QmFzZWxpbmUpO1xuICAgIH1cblxuICAgIGlmIChldmFsdWF0ZVBhZGRpbmcpIHtcbiAgICAgIHRleHQuc2V0UGFkZGluZyhldmFsdWF0ZVBhZGRpbmcoY29udGV4dCkpO1xuICAgIH1cblxuICAgIHJldHVybiB0ZXh0O1xuICB9O1xufVxuXG4vKipcbiAqIEB0eXBlZGVmIHtmdW5jdGlvbihFdmFsdWF0aW9uQ29udGV4dCk6aW1wb3J0KFwiLi4vLi4vc3R5bGUvSW1hZ2UuanNcIikuZGVmYXVsdH0gSW1hZ2VFdmFsdWF0b3JcbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7RmxhdFN0eWxlfSBmbGF0U3R5bGUgVGhlIGZsYXQgc3R5bGUuXG4gKiBAcGFyYW0ge1BhcnNpbmdDb250ZXh0fSBjb250ZXh0IFRoZSBwYXJzaW5nIGNvbnRleHQuXG4gKiBAcmV0dXJuIHtJbWFnZUV2YWx1YXRvcj99IEEgZnVuY3Rpb24gdGhhdCBldmFsdWF0ZXMgdG8gYW4gaW1hZ2Ugc3ltYm9saXplci5cbiAqL1xuZnVuY3Rpb24gYnVpbGRJbWFnZShmbGF0U3R5bGUsIGNvbnRleHQpIHtcbiAgaWYgKCdpY29uLXNyYycgaW4gZmxhdFN0eWxlKSB7XG4gICAgcmV0dXJuIGJ1aWxkSWNvbihmbGF0U3R5bGUsIGNvbnRleHQpO1xuICB9XG5cbiAgaWYgKCdzaGFwZS1wb2ludHMnIGluIGZsYXRTdHlsZSkge1xuICAgIHJldHVybiBidWlsZFNoYXBlKGZsYXRTdHlsZSwgY29udGV4dCk7XG4gIH1cblxuICBpZiAoJ2NpcmNsZS1yYWRpdXMnIGluIGZsYXRTdHlsZSkge1xuICAgIHJldHVybiBidWlsZENpcmNsZShmbGF0U3R5bGUsIGNvbnRleHQpO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogQHBhcmFtIHtGbGF0U3R5bGV9IGZsYXRTdHlsZSBUaGUgZmxhdCBzdHlsZS5cbiAqIEBwYXJhbSB7UGFyc2luZ0NvbnRleHR9IGNvbnRleHQgVGhlIHBhcnNpbmcgY29udGV4dC5cbiAqIEByZXR1cm4ge0ltYWdlRXZhbHVhdG9yfSBBIGZ1bmN0aW9uIHRoYXQgZXZhbHVhdGVzIHRvIGFuIGltYWdlIHN5bWJvbGl6ZXIuXG4gKi9cbmZ1bmN0aW9uIGJ1aWxkSWNvbihmbGF0U3R5bGUsIGNvbnRleHQpIHtcbiAgY29uc3QgcHJlZml4ID0gJ2ljb24tJztcblxuICAvLyByZXF1aXJlZCBwcm9wZXJ0eVxuICBjb25zdCBzcmNOYW1lID0gcHJlZml4ICsgJ3NyYyc7XG4gIGNvbnN0IHNyYyA9IHJlcXVpcmVTdHJpbmcoZmxhdFN0eWxlW3NyY05hbWVdLCBzcmNOYW1lKTtcblxuICAvLyBzZXR0YWJsZSBwcm9wZXJ0aWVzXG4gIGNvbnN0IGV2YWx1YXRlQW5jaG9yID0gY29vcmRpbmF0ZUV2YWx1YXRvcihcbiAgICBmbGF0U3R5bGUsXG4gICAgcHJlZml4ICsgJ2FuY2hvcicsXG4gICAgY29udGV4dFxuICApO1xuXG4gIGNvbnN0IGV2YWx1YXRlU2NhbGUgPSBzaXplTGlrZUV2YWx1YXRvcihmbGF0U3R5bGUsIHByZWZpeCArICdzY2FsZScsIGNvbnRleHQpO1xuXG4gIGNvbnN0IGV2YWx1YXRlT3BhY2l0eSA9IG51bWJlckV2YWx1YXRvcihcbiAgICBmbGF0U3R5bGUsXG4gICAgcHJlZml4ICsgJ29wYWNpdHknLFxuICAgIGNvbnRleHRcbiAgKTtcblxuICBjb25zdCBldmFsdWF0ZURpc3BsYWNlbWVudCA9IGNvb3JkaW5hdGVFdmFsdWF0b3IoXG4gICAgZmxhdFN0eWxlLFxuICAgIHByZWZpeCArICdkaXNwbGFjZW1lbnQnLFxuICAgIGNvbnRleHRcbiAgKTtcblxuICBjb25zdCBldmFsdWF0ZVJvdGF0aW9uID0gbnVtYmVyRXZhbHVhdG9yKFxuICAgIGZsYXRTdHlsZSxcbiAgICBwcmVmaXggKyAncm90YXRpb24nLFxuICAgIGNvbnRleHRcbiAgKTtcblxuICBjb25zdCBldmFsdWF0ZVJvdGF0ZVdpdGhWaWV3ID0gYm9vbGVhbkV2YWx1YXRvcihcbiAgICBmbGF0U3R5bGUsXG4gICAgcHJlZml4ICsgJ3JvdGF0ZS13aXRoLXZpZXcnLFxuICAgIGNvbnRleHRcbiAgKTtcblxuICAvLyB0aGUgcmVtYWluaW5nIHN5bWJvbGl6ZXIgcHJvcGVydGllcyBhcmUgbm90IGN1cnJlbnRseSBzZXR0YWJsZVxuICBjb25zdCBhbmNob3JPcmlnaW4gPSBvcHRpb25hbEljb25PcmlnaW4oZmxhdFN0eWxlLCBwcmVmaXggKyAnYW5jaG9yLW9yaWdpbicpO1xuICBjb25zdCBhbmNob3JYVW5pdHMgPSBvcHRpb25hbEljb25BbmNob3JVbml0cyhcbiAgICBmbGF0U3R5bGUsXG4gICAgcHJlZml4ICsgJ2FuY2hvci14LXVuaXRzJ1xuICApO1xuICBjb25zdCBhbmNob3JZVW5pdHMgPSBvcHRpb25hbEljb25BbmNob3JVbml0cyhcbiAgICBmbGF0U3R5bGUsXG4gICAgcHJlZml4ICsgJ2FuY2hvci15LXVuaXRzJ1xuICApO1xuICBjb25zdCBjb2xvciA9IG9wdGlvbmFsQ29sb3JMaWtlKGZsYXRTdHlsZSwgcHJlZml4ICsgJ2NvbG9yJyk7XG4gIGNvbnN0IGNyb3NzT3JpZ2luID0gb3B0aW9uYWxTdHJpbmcoZmxhdFN0eWxlLCBwcmVmaXggKyAnY3Jvc3Mtb3JpZ2luJyk7XG4gIGNvbnN0IG9mZnNldCA9IG9wdGlvbmFsTnVtYmVyQXJyYXkoZmxhdFN0eWxlLCBwcmVmaXggKyAnb2Zmc2V0Jyk7XG4gIGNvbnN0IG9mZnNldE9yaWdpbiA9IG9wdGlvbmFsSWNvbk9yaWdpbihmbGF0U3R5bGUsIHByZWZpeCArICdvZmZzZXQtb3JpZ2luJyk7XG4gIGNvbnN0IHdpZHRoID0gb3B0aW9uYWxOdW1iZXIoZmxhdFN0eWxlLCBwcmVmaXggKyAnd2lkdGgnKTtcbiAgY29uc3QgaGVpZ2h0ID0gb3B0aW9uYWxOdW1iZXIoZmxhdFN0eWxlLCBwcmVmaXggKyAnaGVpZ2h0Jyk7XG4gIGNvbnN0IHNpemUgPSBvcHRpb25hbFNpemUoZmxhdFN0eWxlLCBwcmVmaXggKyAnc2l6ZScpO1xuICBjb25zdCBkZWNsdXR0ZXJNb2RlID0gb3B0aW9uYWxEZWNsdXR0ZXJNb2RlKGZsYXRTdHlsZSwgcHJlZml4ICsgJ2RlY2x1dHRlcicpO1xuXG4gIGNvbnN0IGljb24gPSBuZXcgSWNvbih7XG4gICAgc3JjLFxuICAgIGFuY2hvck9yaWdpbixcbiAgICBhbmNob3JYVW5pdHMsXG4gICAgYW5jaG9yWVVuaXRzLFxuICAgIGNvbG9yLFxuICAgIGNyb3NzT3JpZ2luLFxuICAgIG9mZnNldCxcbiAgICBvZmZzZXRPcmlnaW4sXG4gICAgaGVpZ2h0LFxuICAgIHdpZHRoLFxuICAgIHNpemUsXG4gICAgZGVjbHV0dGVyTW9kZSxcbiAgfSk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgaWYgKGV2YWx1YXRlT3BhY2l0eSkge1xuICAgICAgaWNvbi5zZXRPcGFjaXR5KGV2YWx1YXRlT3BhY2l0eShjb250ZXh0KSk7XG4gICAgfVxuXG4gICAgaWYgKGV2YWx1YXRlRGlzcGxhY2VtZW50KSB7XG4gICAgICBpY29uLnNldERpc3BsYWNlbWVudChldmFsdWF0ZURpc3BsYWNlbWVudChjb250ZXh0KSk7XG4gICAgfVxuXG4gICAgaWYgKGV2YWx1YXRlUm90YXRpb24pIHtcbiAgICAgIGljb24uc2V0Um90YXRpb24oZXZhbHVhdGVSb3RhdGlvbihjb250ZXh0KSk7XG4gICAgfVxuXG4gICAgaWYgKGV2YWx1YXRlUm90YXRlV2l0aFZpZXcpIHtcbiAgICAgIGljb24uc2V0Um90YXRlV2l0aFZpZXcoZXZhbHVhdGVSb3RhdGVXaXRoVmlldyhjb250ZXh0KSk7XG4gICAgfVxuXG4gICAgaWYgKGV2YWx1YXRlU2NhbGUpIHtcbiAgICAgIGljb24uc2V0U2NhbGUoZXZhbHVhdGVTY2FsZShjb250ZXh0KSk7XG4gICAgfVxuXG4gICAgaWYgKGV2YWx1YXRlQW5jaG9yKSB7XG4gICAgICBpY29uLnNldEFuY2hvcihldmFsdWF0ZUFuY2hvcihjb250ZXh0KSk7XG4gICAgfVxuICAgIHJldHVybiBpY29uO1xuICB9O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RmxhdFN0eWxlfSBmbGF0U3R5bGUgVGhlIGZsYXQgc3R5bGUuXG4gKiBAcGFyYW0ge1BhcnNpbmdDb250ZXh0fSBjb250ZXh0IFRoZSBwYXJzaW5nIGNvbnRleHQuXG4gKiBAcmV0dXJuIHtJbWFnZUV2YWx1YXRvcn0gQSBmdW5jdGlvbiB0aGF0IGV2YWx1YXRlcyB0byBhbiBpY29uIHN5bWJvbGl6ZXIuXG4gKi9cbmZ1bmN0aW9uIGJ1aWxkU2hhcGUoZmxhdFN0eWxlLCBjb250ZXh0KSB7XG4gIGNvbnN0IHByZWZpeCA9ICdzaGFwZS0nO1xuXG4gIC8vIHJlcXVpcmVkIHByb3BlcnR5XG4gIGNvbnN0IHBvaW50c05hbWUgPSBwcmVmaXggKyAncG9pbnRzJztcbiAgY29uc3QgcG9pbnRzID0gcmVxdWlyZU51bWJlcihmbGF0U3R5bGVbcG9pbnRzTmFtZV0sIHBvaW50c05hbWUpO1xuXG4gIC8vIHNldHRhYmxlIHByb3BlcnRpZXNcbiAgY29uc3QgZXZhbHVhdGVGaWxsID0gYnVpbGRGaWxsKGZsYXRTdHlsZSwgcHJlZml4LCBjb250ZXh0KTtcbiAgY29uc3QgZXZhbHVhdGVTdHJva2UgPSBidWlsZFN0cm9rZShmbGF0U3R5bGUsIHByZWZpeCwgY29udGV4dCk7XG4gIGNvbnN0IGV2YWx1YXRlU2NhbGUgPSBzaXplTGlrZUV2YWx1YXRvcihmbGF0U3R5bGUsIHByZWZpeCArICdzY2FsZScsIGNvbnRleHQpO1xuICBjb25zdCBldmFsdWF0ZURpc3BsYWNlbWVudCA9IGNvb3JkaW5hdGVFdmFsdWF0b3IoXG4gICAgZmxhdFN0eWxlLFxuICAgIHByZWZpeCArICdkaXNwbGFjZW1lbnQnLFxuICAgIGNvbnRleHRcbiAgKTtcbiAgY29uc3QgZXZhbHVhdGVSb3RhdGlvbiA9IG51bWJlckV2YWx1YXRvcihcbiAgICBmbGF0U3R5bGUsXG4gICAgcHJlZml4ICsgJ3JvdGF0aW9uJyxcbiAgICBjb250ZXh0XG4gICk7XG4gIGNvbnN0IGV2YWx1YXRlUm90YXRlV2l0aFZpZXcgPSBib29sZWFuRXZhbHVhdG9yKFxuICAgIGZsYXRTdHlsZSxcbiAgICBwcmVmaXggKyAncm90YXRlLXdpdGgtdmlldycsXG4gICAgY29udGV4dFxuICApO1xuXG4gIC8vIHRoZSByZW1haW5pbmcgcHJvcGVydGllcyBhcmUgbm90IGN1cnJlbnRseSBzZXR0YWJsZVxuICBjb25zdCByYWRpdXMgPSBvcHRpb25hbE51bWJlcihmbGF0U3R5bGUsIHByZWZpeCArICdyYWRpdXMnKTtcbiAgY29uc3QgcmFkaXVzMSA9IG9wdGlvbmFsTnVtYmVyKGZsYXRTdHlsZSwgcHJlZml4ICsgJ3JhZGl1czEnKTtcbiAgY29uc3QgcmFkaXVzMiA9IG9wdGlvbmFsTnVtYmVyKGZsYXRTdHlsZSwgcHJlZml4ICsgJ3JhZGl1czInKTtcbiAgY29uc3QgYW5nbGUgPSBvcHRpb25hbE51bWJlcihmbGF0U3R5bGUsIHByZWZpeCArICdhbmdsZScpO1xuICBjb25zdCBkZWNsdXR0ZXJNb2RlID0gb3B0aW9uYWxEZWNsdXR0ZXJNb2RlKFxuICAgIGZsYXRTdHlsZSxcbiAgICBwcmVmaXggKyAnZGVjbHV0dGVyLW1vZGUnXG4gICk7XG5cbiAgY29uc3Qgc2hhcGUgPSBuZXcgUmVndWxhclNoYXBlKHtcbiAgICBwb2ludHMsXG4gICAgcmFkaXVzLFxuICAgIHJhZGl1czEsXG4gICAgcmFkaXVzMixcbiAgICBhbmdsZSxcbiAgICBkZWNsdXR0ZXJNb2RlLFxuICB9KTtcblxuICByZXR1cm4gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICBpZiAoZXZhbHVhdGVGaWxsKSB7XG4gICAgICBzaGFwZS5zZXRGaWxsKGV2YWx1YXRlRmlsbChjb250ZXh0KSk7XG4gICAgfVxuICAgIGlmIChldmFsdWF0ZVN0cm9rZSkge1xuICAgICAgc2hhcGUuc2V0U3Ryb2tlKGV2YWx1YXRlU3Ryb2tlKGNvbnRleHQpKTtcbiAgICB9XG4gICAgaWYgKGV2YWx1YXRlRGlzcGxhY2VtZW50KSB7XG4gICAgICBzaGFwZS5zZXREaXNwbGFjZW1lbnQoZXZhbHVhdGVEaXNwbGFjZW1lbnQoY29udGV4dCkpO1xuICAgIH1cbiAgICBpZiAoZXZhbHVhdGVSb3RhdGlvbikge1xuICAgICAgc2hhcGUuc2V0Um90YXRpb24oZXZhbHVhdGVSb3RhdGlvbihjb250ZXh0KSk7XG4gICAgfVxuICAgIGlmIChldmFsdWF0ZVJvdGF0ZVdpdGhWaWV3KSB7XG4gICAgICBzaGFwZS5zZXRSb3RhdGVXaXRoVmlldyhldmFsdWF0ZVJvdGF0ZVdpdGhWaWV3KGNvbnRleHQpKTtcbiAgICB9XG4gICAgaWYgKGV2YWx1YXRlU2NhbGUpIHtcbiAgICAgIHNoYXBlLnNldFNjYWxlKGV2YWx1YXRlU2NhbGUoY29udGV4dCkpO1xuICAgIH1cblxuICAgIHJldHVybiBzaGFwZTtcbiAgfTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0ZsYXRTdHlsZX0gZmxhdFN0eWxlIFRoZSBmbGF0IHN0eWxlLlxuICogQHBhcmFtIHtQYXJzaW5nQ29udGV4dH0gY29udGV4dCBUaGUgcGFyc2luZyBjb250ZXh0LlxuICogQHJldHVybiB7SW1hZ2VFdmFsdWF0b3J9IEEgZnVuY3Rpb24gdGhhdCBldmFsdWF0ZXMgdG8gYSBjaXJjbGUgc3ltYm9saXplci5cbiAqL1xuZnVuY3Rpb24gYnVpbGRDaXJjbGUoZmxhdFN0eWxlLCBjb250ZXh0KSB7XG4gIGNvbnN0IHByZWZpeCA9ICdjaXJjbGUtJztcblxuICAvLyBzZXR0YWJsZSBwcm9wZXJ0aWVzXG4gIGNvbnN0IGV2YWx1YXRlRmlsbCA9IGJ1aWxkRmlsbChmbGF0U3R5bGUsIHByZWZpeCwgY29udGV4dCk7XG4gIGNvbnN0IGV2YWx1YXRlU3Ryb2tlID0gYnVpbGRTdHJva2UoZmxhdFN0eWxlLCBwcmVmaXgsIGNvbnRleHQpO1xuICBjb25zdCBldmFsdWF0ZVJhZGl1cyA9IG51bWJlckV2YWx1YXRvcihmbGF0U3R5bGUsIHByZWZpeCArICdyYWRpdXMnLCBjb250ZXh0KTtcbiAgY29uc3QgZXZhbHVhdGVTY2FsZSA9IHNpemVMaWtlRXZhbHVhdG9yKGZsYXRTdHlsZSwgcHJlZml4ICsgJ3NjYWxlJywgY29udGV4dCk7XG4gIGNvbnN0IGV2YWx1YXRlRGlzcGxhY2VtZW50ID0gY29vcmRpbmF0ZUV2YWx1YXRvcihcbiAgICBmbGF0U3R5bGUsXG4gICAgcHJlZml4ICsgJ2Rpc3BsYWNlbWVudCcsXG4gICAgY29udGV4dFxuICApO1xuICBjb25zdCBldmFsdWF0ZVJvdGF0aW9uID0gbnVtYmVyRXZhbHVhdG9yKFxuICAgIGZsYXRTdHlsZSxcbiAgICBwcmVmaXggKyAncm90YXRpb24nLFxuICAgIGNvbnRleHRcbiAgKTtcbiAgY29uc3QgZXZhbHVhdGVSb3RhdGVXaXRoVmlldyA9IGJvb2xlYW5FdmFsdWF0b3IoXG4gICAgZmxhdFN0eWxlLFxuICAgIHByZWZpeCArICdyb3RhdGUtd2l0aC12aWV3JyxcbiAgICBjb250ZXh0XG4gICk7XG5cbiAgLy8gdGhlIHJlbWFpbmluZyBwcm9wZXJ0aWVzIGFyZSBub3QgY3VycmVudGx5IHNldHRhYmxlXG4gIGNvbnN0IGRlY2x1dHRlck1vZGUgPSBvcHRpb25hbERlY2x1dHRlck1vZGUoXG4gICAgZmxhdFN0eWxlLFxuICAgIHByZWZpeCArICdkZWNsdXR0ZXItbW9kZSdcbiAgKTtcblxuICBjb25zdCBjaXJjbGUgPSBuZXcgQ2lyY2xlKHtcbiAgICByYWRpdXM6IDUsIC8vIHRoaXMgaXMgYXJiaXRyYXJ5LCBidXQgcmVxdWlyZWQgLSB0aGUgZXZhbHVhdGVkIHJhZGl1cyBpcyB1c2VkIGJlbG93XG4gICAgZGVjbHV0dGVyTW9kZSxcbiAgfSk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgaWYgKGV2YWx1YXRlUmFkaXVzKSB7XG4gICAgICBjaXJjbGUuc2V0UmFkaXVzKGV2YWx1YXRlUmFkaXVzKGNvbnRleHQpKTtcbiAgICB9XG4gICAgaWYgKGV2YWx1YXRlRmlsbCkge1xuICAgICAgY2lyY2xlLnNldEZpbGwoZXZhbHVhdGVGaWxsKGNvbnRleHQpKTtcbiAgICB9XG4gICAgaWYgKGV2YWx1YXRlU3Ryb2tlKSB7XG4gICAgICBjaXJjbGUuc2V0U3Ryb2tlKGV2YWx1YXRlU3Ryb2tlKGNvbnRleHQpKTtcbiAgICB9XG4gICAgaWYgKGV2YWx1YXRlRGlzcGxhY2VtZW50KSB7XG4gICAgICBjaXJjbGUuc2V0RGlzcGxhY2VtZW50KGV2YWx1YXRlRGlzcGxhY2VtZW50KGNvbnRleHQpKTtcbiAgICB9XG4gICAgaWYgKGV2YWx1YXRlUm90YXRpb24pIHtcbiAgICAgIGNpcmNsZS5zZXRSb3RhdGlvbihldmFsdWF0ZVJvdGF0aW9uKGNvbnRleHQpKTtcbiAgICB9XG4gICAgaWYgKGV2YWx1YXRlUm90YXRlV2l0aFZpZXcpIHtcbiAgICAgIGNpcmNsZS5zZXRSb3RhdGVXaXRoVmlldyhldmFsdWF0ZVJvdGF0ZVdpdGhWaWV3KGNvbnRleHQpKTtcbiAgICB9XG4gICAgaWYgKGV2YWx1YXRlU2NhbGUpIHtcbiAgICAgIGNpcmNsZS5zZXRTY2FsZShldmFsdWF0ZVNjYWxlKGNvbnRleHQpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2lyY2xlO1xuICB9O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RmxhdFN0eWxlfSBmbGF0U3R5bGUgVGhlIGZsYXQgc3R5bGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgcHJvcGVydHkgbmFtZS5cbiAqIEBwYXJhbSB7UGFyc2luZ0NvbnRleHR9IGNvbnRleHQgVGhlIHBhcnNpbmcgY29udGV4dC5cbiAqIEByZXR1cm4ge2ltcG9ydCgnLi4vLi4vZXhwci9jcHUuanMnKS5OdW1iZXJFdmFsdWF0b3J8dW5kZWZpbmVkfSBUaGUgZXhwcmVzc2lvbiBldmFsdWF0b3Igb3IgdW5kZWZpbmVkLlxuICovXG5mdW5jdGlvbiBudW1iZXJFdmFsdWF0b3IoZmxhdFN0eWxlLCBuYW1lLCBjb250ZXh0KSB7XG4gIGlmICghKG5hbWUgaW4gZmxhdFN0eWxlKSkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgY29uc3QgZXZhbHVhdG9yID0gYnVpbGRFeHByZXNzaW9uKGZsYXRTdHlsZVtuYW1lXSwgTnVtYmVyVHlwZSwgY29udGV4dCk7XG4gIHJldHVybiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgIHJldHVybiByZXF1aXJlTnVtYmVyKGV2YWx1YXRvcihjb250ZXh0KSwgbmFtZSk7XG4gIH07XG59XG5cbi8qKlxuICogQHBhcmFtIHtGbGF0U3R5bGV9IGZsYXRTdHlsZSBUaGUgZmxhdCBzdHlsZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBwcm9wZXJ0eSBuYW1lLlxuICogQHBhcmFtIHtQYXJzaW5nQ29udGV4dH0gY29udGV4dCBUaGUgcGFyc2luZyBjb250ZXh0LlxuICogQHJldHVybiB7aW1wb3J0KCcuLi8uLi9leHByL2NwdS5qcycpLlN0cmluZ0V2YWx1YXRvcj99IFRoZSBleHByZXNzaW9uIGV2YWx1YXRvci5cbiAqL1xuZnVuY3Rpb24gc3RyaW5nRXZhbHVhdG9yKGZsYXRTdHlsZSwgbmFtZSwgY29udGV4dCkge1xuICBpZiAoIShuYW1lIGluIGZsYXRTdHlsZSkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBldmFsdWF0b3IgPSBidWlsZEV4cHJlc3Npb24oZmxhdFN0eWxlW25hbWVdLCBTdHJpbmdUeXBlLCBjb250ZXh0KTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgcmV0dXJuIHJlcXVpcmVTdHJpbmcoZXZhbHVhdG9yKGNvbnRleHQpLCBuYW1lKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0ZsYXRTdHlsZX0gZmxhdFN0eWxlIFRoZSBmbGF0IHN0eWxlLlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIHByb3BlcnR5IG5hbWUuXG4gKiBAcGFyYW0ge1BhcnNpbmdDb250ZXh0fSBjb250ZXh0IFRoZSBwYXJzaW5nIGNvbnRleHQuXG4gKiBAcmV0dXJuIHtpbXBvcnQoJy4uLy4uL2V4cHIvY3B1LmpzJykuQm9vbGVhbkV2YWx1YXRvcj99IFRoZSBleHByZXNzaW9uIGV2YWx1YXRvci5cbiAqL1xuZnVuY3Rpb24gYm9vbGVhbkV2YWx1YXRvcihmbGF0U3R5bGUsIG5hbWUsIGNvbnRleHQpIHtcbiAgaWYgKCEobmFtZSBpbiBmbGF0U3R5bGUpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgZXZhbHVhdG9yID0gYnVpbGRFeHByZXNzaW9uKGZsYXRTdHlsZVtuYW1lXSwgQm9vbGVhblR5cGUsIGNvbnRleHQpO1xuICByZXR1cm4gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICBjb25zdCB2YWx1ZSA9IGV2YWx1YXRvcihjb250ZXh0KTtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnYm9vbGVhbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgYSBib29sZWFuIGZvciAke25hbWV9YCk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0ZsYXRTdHlsZX0gZmxhdFN0eWxlIFRoZSBmbGF0IHN0eWxlLlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIHByb3BlcnR5IG5hbWUuXG4gKiBAcGFyYW0ge1BhcnNpbmdDb250ZXh0fSBjb250ZXh0IFRoZSBwYXJzaW5nIGNvbnRleHQuXG4gKiBAcmV0dXJuIHtpbXBvcnQoJy4uLy4uL2V4cHIvY3B1LmpzJykuQ29sb3JMaWtlRXZhbHVhdG9yP30gVGhlIGV4cHJlc3Npb24gZXZhbHVhdG9yLlxuICovXG5mdW5jdGlvbiBjb2xvckxpa2VFdmFsdWF0b3IoZmxhdFN0eWxlLCBuYW1lLCBjb250ZXh0KSB7XG4gIGlmICghKG5hbWUgaW4gZmxhdFN0eWxlKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IGV2YWx1YXRvciA9IGJ1aWxkRXhwcmVzc2lvbihcbiAgICBmbGF0U3R5bGVbbmFtZV0sXG4gICAgQ29sb3JUeXBlIHwgU3RyaW5nVHlwZSxcbiAgICBjb250ZXh0XG4gICk7XG4gIHJldHVybiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgIHJldHVybiByZXF1aXJlQ29sb3JMaWtlKGV2YWx1YXRvcihjb250ZXh0KSwgbmFtZSk7XG4gIH07XG59XG5cbi8qKlxuICogQHBhcmFtIHtGbGF0U3R5bGV9IGZsYXRTdHlsZSBUaGUgZmxhdCBzdHlsZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBwcm9wZXJ0eSBuYW1lLlxuICogQHBhcmFtIHtQYXJzaW5nQ29udGV4dH0gY29udGV4dCBUaGUgcGFyc2luZyBjb250ZXh0LlxuICogQHJldHVybiB7aW1wb3J0KCcuLi8uLi9leHByL2NwdS5qcycpLk51bWJlckFycmF5RXZhbHVhdG9yP30gVGhlIGV4cHJlc3Npb24gZXZhbHVhdG9yLlxuICovXG5mdW5jdGlvbiBudW1iZXJBcnJheUV2YWx1YXRvcihmbGF0U3R5bGUsIG5hbWUsIGNvbnRleHQpIHtcbiAgaWYgKCEobmFtZSBpbiBmbGF0U3R5bGUpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgZXZhbHVhdG9yID0gYnVpbGRFeHByZXNzaW9uKGZsYXRTdHlsZVtuYW1lXSwgTnVtYmVyQXJyYXlUeXBlLCBjb250ZXh0KTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgcmV0dXJuIHJlcXVpcmVOdW1iZXJBcnJheShldmFsdWF0b3IoY29udGV4dCksIG5hbWUpO1xuICB9O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RmxhdFN0eWxlfSBmbGF0U3R5bGUgVGhlIGZsYXQgc3R5bGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgcHJvcGVydHkgbmFtZS5cbiAqIEBwYXJhbSB7UGFyc2luZ0NvbnRleHR9IGNvbnRleHQgVGhlIHBhcnNpbmcgY29udGV4dC5cbiAqIEByZXR1cm4ge2ltcG9ydCgnLi4vLi4vZXhwci9jcHUuanMnKS5Db29yZGluYXRlRXZhbHVhdG9yP30gVGhlIGV4cHJlc3Npb24gZXZhbHVhdG9yLlxuICovXG5mdW5jdGlvbiBjb29yZGluYXRlRXZhbHVhdG9yKGZsYXRTdHlsZSwgbmFtZSwgY29udGV4dCkge1xuICBpZiAoIShuYW1lIGluIGZsYXRTdHlsZSkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBldmFsdWF0b3IgPSBidWlsZEV4cHJlc3Npb24oZmxhdFN0eWxlW25hbWVdLCBOdW1iZXJBcnJheVR5cGUsIGNvbnRleHQpO1xuICByZXR1cm4gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICBjb25zdCBhcnJheSA9IHJlcXVpcmVOdW1iZXJBcnJheShldmFsdWF0b3IoY29udGV4dCksIG5hbWUpO1xuICAgIGlmIChhcnJheS5sZW5ndGggIT09IDIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgdHdvIG51bWJlcnMgZm9yICR7bmFtZX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xuICB9O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RmxhdFN0eWxlfSBmbGF0U3R5bGUgVGhlIGZsYXQgc3R5bGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgcHJvcGVydHkgbmFtZS5cbiAqIEBwYXJhbSB7UGFyc2luZ0NvbnRleHR9IGNvbnRleHQgVGhlIHBhcnNpbmcgY29udGV4dC5cbiAqIEByZXR1cm4ge2ltcG9ydCgnLi4vLi4vZXhwci9jcHUuanMnKS5TaXplTGlrZUV2YWx1YXRvcj99IFRoZSBleHByZXNzaW9uIGV2YWx1YXRvci5cbiAqL1xuZnVuY3Rpb24gc2l6ZUxpa2VFdmFsdWF0b3IoZmxhdFN0eWxlLCBuYW1lLCBjb250ZXh0KSB7XG4gIGlmICghKG5hbWUgaW4gZmxhdFN0eWxlKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IGV2YWx1YXRvciA9IGJ1aWxkRXhwcmVzc2lvbihmbGF0U3R5bGVbbmFtZV0sIE51bWJlckFycmF5VHlwZSwgY29udGV4dCk7XG4gIHJldHVybiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgIHJldHVybiByZXF1aXJlU2l6ZUxpa2UoZXZhbHVhdG9yKGNvbnRleHQpLCBuYW1lKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0ZsYXRTdHlsZX0gZmxhdFN0eWxlIFRoZSBmbGF0IHN0eWxlLlxuICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFRoZSBzeW1ib2xpemVyIHByb3BlcnR5LlxuICogQHJldHVybiB7bnVtYmVyfHVuZGVmaW5lZH0gQSBudW1iZXIgb3IgdW5kZWZpbmVkLlxuICovXG5mdW5jdGlvbiBvcHRpb25hbE51bWJlcihmbGF0U3R5bGUsIHByb3BlcnR5KSB7XG4gIGNvbnN0IHZhbHVlID0gZmxhdFN0eWxlW3Byb3BlcnR5XTtcbiAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBhIG51bWJlciBmb3IgJHtwcm9wZXJ0eX1gKTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5cbi8qKlxuICogQHBhcmFtIHtGbGF0U3R5bGV9IGZsYXRTdHlsZSBUaGUgZmxhdCBzdHlsZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBUaGUgc3ltYm9saXplciBwcm9wZXJ0eS5cbiAqIEByZXR1cm4ge2ltcG9ydChcIi4uLy4uL3NpemUuanNcIikuU2l6ZXx1bmRlZmluZWR9IEEgc2l6ZSBvciB1bmRlZmluZWQuXG4gKi9cbmZ1bmN0aW9uIG9wdGlvbmFsU2l6ZShmbGF0U3R5bGUsIHByb3BlcnR5KSB7XG4gIGNvbnN0IGVuY29kZWQgPSBmbGF0U3R5bGVbcHJvcGVydHldO1xuICBpZiAoZW5jb2RlZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBpZiAodHlwZW9mIGVuY29kZWQgPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIHRvU2l6ZShlbmNvZGVkKTtcbiAgfVxuICBpZiAoIUFycmF5LmlzQXJyYXkoZW5jb2RlZCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGEgbnVtYmVyIG9yIHNpemUgYXJyYXkgZm9yICR7cHJvcGVydHl9YCk7XG4gIH1cbiAgaWYgKFxuICAgIGVuY29kZWQubGVuZ3RoICE9PSAyIHx8XG4gICAgdHlwZW9mIGVuY29kZWRbMF0gIT09ICdudW1iZXInIHx8XG4gICAgdHlwZW9mIGVuY29kZWRbMV0gIT09ICdudW1iZXInXG4gICkge1xuICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgYSBudW1iZXIgb3Igc2l6ZSBhcnJheSBmb3IgJHtwcm9wZXJ0eX1gKTtcbiAgfVxuICByZXR1cm4gZW5jb2RlZDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0ZsYXRTdHlsZX0gZmxhdFN0eWxlIFRoZSBmbGF0IHN0eWxlLlxuICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFRoZSBzeW1ib2xpemVyIHByb3BlcnR5LlxuICogQHJldHVybiB7c3RyaW5nfHVuZGVmaW5lZH0gQSBzdHJpbmcgb3IgdW5kZWZpbmVkLlxuICovXG5mdW5jdGlvbiBvcHRpb25hbFN0cmluZyhmbGF0U3R5bGUsIHByb3BlcnR5KSB7XG4gIGNvbnN0IGVuY29kZWQgPSBmbGF0U3R5bGVbcHJvcGVydHldO1xuICBpZiAoZW5jb2RlZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBpZiAodHlwZW9mIGVuY29kZWQgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBhIHN0cmluZyBmb3IgJHtwcm9wZXJ0eX1gKTtcbiAgfVxuICByZXR1cm4gZW5jb2RlZDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0ZsYXRTdHlsZX0gZmxhdFN0eWxlIFRoZSBmbGF0IHN0eWxlLlxuICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFRoZSBzeW1ib2xpemVyIHByb3BlcnR5LlxuICogQHJldHVybiB7aW1wb3J0KFwiLi4vLi4vc3R5bGUvSWNvbi5qc1wiKS5JY29uT3JpZ2lufHVuZGVmaW5lZH0gQW4gaWNvbiBvcmlnaW4gb3IgdW5kZWZpbmVkLlxuICovXG5mdW5jdGlvbiBvcHRpb25hbEljb25PcmlnaW4oZmxhdFN0eWxlLCBwcm9wZXJ0eSkge1xuICBjb25zdCBlbmNvZGVkID0gZmxhdFN0eWxlW3Byb3BlcnR5XTtcbiAgaWYgKGVuY29kZWQgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKFxuICAgIGVuY29kZWQgIT09ICdib3R0b20tbGVmdCcgJiZcbiAgICBlbmNvZGVkICE9PSAnYm90dG9tLXJpZ2h0JyAmJlxuICAgIGVuY29kZWQgIT09ICd0b3AtbGVmdCcgJiZcbiAgICBlbmNvZGVkICE9PSAndG9wLXJpZ2h0J1xuICApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgRXhwZWN0ZWQgYm90dG9tLWxlZnQsIGJvdHRvbS1yaWdodCwgdG9wLWxlZnQsIG9yIHRvcC1yaWdodCBmb3IgJHtwcm9wZXJ0eX1gXG4gICAgKTtcbiAgfVxuICByZXR1cm4gZW5jb2RlZDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0ZsYXRTdHlsZX0gZmxhdFN0eWxlIFRoZSBmbGF0IHN0eWxlLlxuICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFRoZSBzeW1ib2xpemVyIHByb3BlcnR5LlxuICogQHJldHVybiB7aW1wb3J0KFwiLi4vLi4vc3R5bGUvSWNvbi5qc1wiKS5JY29uQW5jaG9yVW5pdHN8dW5kZWZpbmVkfSBJY29uIGFuY2hvciB1bml0cyBvciB1bmRlZmluZWQuXG4gKi9cbmZ1bmN0aW9uIG9wdGlvbmFsSWNvbkFuY2hvclVuaXRzKGZsYXRTdHlsZSwgcHJvcGVydHkpIHtcbiAgY29uc3QgZW5jb2RlZCA9IGZsYXRTdHlsZVtwcm9wZXJ0eV07XG4gIGlmIChlbmNvZGVkID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIGlmIChlbmNvZGVkICE9PSAncGl4ZWxzJyAmJiBlbmNvZGVkICE9PSAnZnJhY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBwaXhlbHMgb3IgZnJhY3Rpb24gZm9yICR7cHJvcGVydHl9YCk7XG4gIH1cbiAgcmV0dXJuIGVuY29kZWQ7XG59XG5cbi8qKlxuICogQHBhcmFtIHtGbGF0U3R5bGV9IGZsYXRTdHlsZSBUaGUgZmxhdCBzdHlsZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBUaGUgc3ltYm9saXplciBwcm9wZXJ0eS5cbiAqIEByZXR1cm4ge0FycmF5PG51bWJlcj58dW5kZWZpbmVkfSBBbiBhcnJheSBvZiBudW1iZXJzIG9yIHVuZGVmaW5lZC5cbiAqL1xuZnVuY3Rpb24gb3B0aW9uYWxOdW1iZXJBcnJheShmbGF0U3R5bGUsIHByb3BlcnR5KSB7XG4gIGNvbnN0IGVuY29kZWQgPSBmbGF0U3R5bGVbcHJvcGVydHldO1xuICBpZiAoZW5jb2RlZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICByZXR1cm4gcmVxdWlyZU51bWJlckFycmF5KGVuY29kZWQsIHByb3BlcnR5KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0ZsYXRTdHlsZX0gZmxhdFN0eWxlIFRoZSBmbGF0IHN0eWxlLlxuICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFRoZSBzeW1ib2xpemVyIHByb3BlcnR5LlxuICogQHJldHVybiB7XCJkZWNsdXR0ZXJcInxcIm9ic3RhY2xlXCJ8XCJub25lXCJ8dW5kZWZpbmVkfSBJY29uIGRlY2x1dHRlciBtb2RlLlxuICovXG5mdW5jdGlvbiBvcHRpb25hbERlY2x1dHRlck1vZGUoZmxhdFN0eWxlLCBwcm9wZXJ0eSkge1xuICBjb25zdCBlbmNvZGVkID0gZmxhdFN0eWxlW3Byb3BlcnR5XTtcbiAgaWYgKGVuY29kZWQgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKHR5cGVvZiBlbmNvZGVkICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgYSBzdHJpbmcgZm9yICR7cHJvcGVydHl9YCk7XG4gIH1cbiAgaWYgKGVuY29kZWQgIT09ICdkZWNsdXR0ZXInICYmIGVuY29kZWQgIT09ICdvYnN0YWNsZScgJiYgZW5jb2RlZCAhPT0gJ25vbmUnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBkZWNsdXR0ZXIsIG9ic3RhY2xlLCBvciBub25lIGZvciAke3Byb3BlcnR5fWApO1xuICB9XG4gIHJldHVybiBlbmNvZGVkO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RmxhdFN0eWxlfSBmbGF0U3R5bGUgVGhlIGZsYXQgc3R5bGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgVGhlIHN5bWJvbGl6ZXIgcHJvcGVydHkuXG4gKiBAcmV0dXJuIHtzdHJpbmd8QXJyYXk8bnVtYmVyPnx1bmRlZmluZWR9IEEgc3RyaW5nIG9yIGFuIGFycmF5IG9mIGNvbG9yIHZhbHVlcyBvciB1bmRlZmluZWQuXG4gKi9cbmZ1bmN0aW9uIG9wdGlvbmFsQ29sb3JMaWtlKGZsYXRTdHlsZSwgcHJvcGVydHkpIHtcbiAgY29uc3QgZW5jb2RlZCA9IGZsYXRTdHlsZVtwcm9wZXJ0eV07XG4gIGlmIChlbmNvZGVkID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIHJldHVybiByZXF1aXJlQ29sb3JMaWtlKGVuY29kZWQsIHByb3BlcnR5KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2FueX0gdmFsdWUgVGhlIHZhbHVlLlxuICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFRoZSBwcm9wZXJ0eS5cbiAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IEFuIGFycmF5IG9mIG51bWJlcnMuXG4gKi9cbmZ1bmN0aW9uIHJlcXVpcmVOdW1iZXJBcnJheSh2YWx1ZSwgcHJvcGVydHkpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgYW4gYXJyYXkgZm9yICR7cHJvcGVydHl9YCk7XG4gIH1cbiAgY29uc3QgbGVuZ3RoID0gdmFsdWUubGVuZ3RoO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZVtpXSAhPT0gJ251bWJlcicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgYW4gYXJyYXkgb2YgbnVtYmVycyBmb3IgJHtwcm9wZXJ0eX1gKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7YW55fSB2YWx1ZSBUaGUgdmFsdWUuXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgVGhlIHByb3BlcnR5LlxuICogQHJldHVybiB7c3RyaW5nfSBBIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gcmVxdWlyZVN0cmluZyh2YWx1ZSwgcHJvcGVydHkpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGEgc3RyaW5nIGZvciAke3Byb3BlcnR5fWApO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2FueX0gdmFsdWUgVGhlIHZhbHVlLlxuICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFRoZSBwcm9wZXJ0eS5cbiAqIEByZXR1cm4ge251bWJlcn0gQSBudW1iZXIuXG4gKi9cbmZ1bmN0aW9uIHJlcXVpcmVOdW1iZXIodmFsdWUsIHByb3BlcnR5KSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBhIG51bWJlciBmb3IgJHtwcm9wZXJ0eX1gKTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5cbi8qKlxuICogQHBhcmFtIHthbnl9IHZhbHVlIFRoZSB2YWx1ZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBUaGUgcHJvcGVydHkuXG4gKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fHN0cmluZ30gQSBjb2xvci5cbiAqL1xuZnVuY3Rpb24gcmVxdWlyZUNvbG9yTGlrZSh2YWx1ZSwgcHJvcGVydHkpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgY29uc3QgYXJyYXkgPSByZXF1aXJlTnVtYmVyQXJyYXkodmFsdWUsIHByb3BlcnR5KTtcbiAgY29uc3QgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICBpZiAobGVuZ3RoIDwgMyB8fCBsZW5ndGggPiA0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBhIGNvbG9yIHdpdGggMyBvciA0IHZhbHVlcyBmb3IgJHtwcm9wZXJ0eX1gKTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbi8qKlxuICogQHBhcmFtIHthbnl9IHZhbHVlIFRoZSB2YWx1ZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBUaGUgcHJvcGVydHkuXG4gKiBAcmV0dXJuIHtudW1iZXJ8QXJyYXk8bnVtYmVyPn0gQSBudW1iZXIgb3IgYW4gYXJyYXkgb2YgdHdvIG51bWJlcnMuXG4gKi9cbmZ1bmN0aW9uIHJlcXVpcmVTaXplTGlrZSh2YWx1ZSwgcHJvcGVydHkpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgY29uc3Qgc2l6ZSA9IHJlcXVpcmVOdW1iZXJBcnJheSh2YWx1ZSwgcHJvcGVydHkpO1xuICBpZiAoc2l6ZS5sZW5ndGggIT09IDIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGFuIGFycmF5IG9mIHR3byBudW1iZXJzIGZvciAke3Byb3BlcnR5fWApO1xuICB9XG4gIHJldHVybiBzaXplO1xufVxuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3JlbmRlcmVyL0NvbXBvc2l0ZVxuICovXG5pbXBvcnQgTWFwUmVuZGVyZXIgZnJvbSAnLi9NYXAuanMnO1xuaW1wb3J0IE9iamVjdEV2ZW50VHlwZSBmcm9tICcuLi9PYmplY3RFdmVudFR5cGUuanMnO1xuaW1wb3J0IFJlbmRlckV2ZW50IGZyb20gJy4uL3JlbmRlci9FdmVudC5qcyc7XG5pbXBvcnQgUmVuZGVyRXZlbnRUeXBlIGZyb20gJy4uL3JlbmRlci9FdmVudFR5cGUuanMnO1xuaW1wb3J0IHtDTEFTU19VTlNFTEVDVEFCTEV9IGZyb20gJy4uL2Nzcy5qcyc7XG5pbXBvcnQge2NoZWNrZWRGb250c30gZnJvbSAnLi4vcmVuZGVyL2NhbnZhcy5qcyc7XG5pbXBvcnQge2luVmlld30gZnJvbSAnLi4vbGF5ZXIvTGF5ZXIuanMnO1xuaW1wb3J0IHtsaXN0ZW4sIHVubGlzdGVuQnlLZXl9IGZyb20gJy4uL2V2ZW50cy5qcyc7XG5pbXBvcnQge3JlcGxhY2VDaGlsZHJlbn0gZnJvbSAnLi4vZG9tLmpzJztcblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBDYW52YXMgbWFwIHJlbmRlcmVyLlxuICogQGFwaVxuICovXG5jbGFzcyBDb21wb3NpdGVNYXBSZW5kZXJlciBleHRlbmRzIE1hcFJlbmRlcmVyIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwLmpzXCIpLmRlZmF1bHR9IG1hcCBNYXAuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihtYXApIHtcbiAgICBzdXBlcihtYXApO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL2V2ZW50cy5qc1wiKS5FdmVudHNLZXl9XG4gICAgICovXG4gICAgdGhpcy5mb250Q2hhbmdlTGlzdGVuZXJLZXlfID0gbGlzdGVuKFxuICAgICAgY2hlY2tlZEZvbnRzLFxuICAgICAgT2JqZWN0RXZlbnRUeXBlLlBST1BFUlRZQ0hBTkdFLFxuICAgICAgbWFwLnJlZHJhd1RleHQuYmluZChtYXApXG4gICAgKTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0hUTUxEaXZFbGVtZW50fVxuICAgICAqL1xuICAgIHRoaXMuZWxlbWVudF8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBjb25zdCBzdHlsZSA9IHRoaXMuZWxlbWVudF8uc3R5bGU7XG4gICAgc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgIHN0eWxlLndpZHRoID0gJzEwMCUnO1xuICAgIHN0eWxlLmhlaWdodCA9ICcxMDAlJztcbiAgICBzdHlsZS56SW5kZXggPSAnMCc7XG5cbiAgICB0aGlzLmVsZW1lbnRfLmNsYXNzTmFtZSA9IENMQVNTX1VOU0VMRUNUQUJMRSArICcgb2wtbGF5ZXJzJztcblxuICAgIGNvbnN0IGNvbnRhaW5lciA9IG1hcC5nZXRWaWV3cG9ydCgpO1xuICAgIGNvbnRhaW5lci5pbnNlcnRCZWZvcmUodGhpcy5lbGVtZW50XywgY29udGFpbmVyLmZpcnN0Q2hpbGQgfHwgbnVsbCk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtBcnJheTxIVE1MRWxlbWVudD59XG4gICAgICovXG4gICAgdGhpcy5jaGlsZHJlbl8gPSBbXTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5yZW5kZXJlZFZpc2libGVfID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtBcnJheTxpbXBvcnQoXCIuLi9sYXllci9CYXNlVmVjdG9yLmpzXCIpLmRlZmF1bHQ+fVxuICAgICAqL1xuICAgIHRoaXMuZGVjbHV0dGVyTGF5ZXJzXyA9IFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcmVuZGVyL0V2ZW50VHlwZS5qc1wiKS5kZWZhdWx0fSB0eXBlIEV2ZW50IHR5cGUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwLmpzXCIpLkZyYW1lU3RhdGV9IGZyYW1lU3RhdGUgRnJhbWUgc3RhdGUuXG4gICAqL1xuICBkaXNwYXRjaFJlbmRlckV2ZW50KHR5cGUsIGZyYW1lU3RhdGUpIHtcbiAgICBjb25zdCBtYXAgPSB0aGlzLmdldE1hcCgpO1xuICAgIGlmIChtYXAuaGFzTGlzdGVuZXIodHlwZSkpIHtcbiAgICAgIGNvbnN0IGV2ZW50ID0gbmV3IFJlbmRlckV2ZW50KHR5cGUsIHVuZGVmaW5lZCwgZnJhbWVTdGF0ZSk7XG4gICAgICBtYXAuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgfVxuICB9XG5cbiAgZGlzcG9zZUludGVybmFsKCkge1xuICAgIHVubGlzdGVuQnlLZXkodGhpcy5mb250Q2hhbmdlTGlzdGVuZXJLZXlfKTtcbiAgICB0aGlzLmVsZW1lbnRfLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5lbGVtZW50Xyk7XG4gICAgc3VwZXIuZGlzcG9zZUludGVybmFsKCk7XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVyLlxuICAgKiBAcGFyYW0gez9pbXBvcnQoXCIuLi9NYXAuanNcIikuRnJhbWVTdGF0ZX0gZnJhbWVTdGF0ZSBGcmFtZSBzdGF0ZS5cbiAgICovXG4gIHJlbmRlckZyYW1lKGZyYW1lU3RhdGUpIHtcbiAgICBpZiAoIWZyYW1lU3RhdGUpIHtcbiAgICAgIGlmICh0aGlzLnJlbmRlcmVkVmlzaWJsZV8pIHtcbiAgICAgICAgdGhpcy5lbGVtZW50Xy5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICB0aGlzLnJlbmRlcmVkVmlzaWJsZV8gPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmNhbGN1bGF0ZU1hdHJpY2VzMkQoZnJhbWVTdGF0ZSk7XG4gICAgdGhpcy5kaXNwYXRjaFJlbmRlckV2ZW50KFJlbmRlckV2ZW50VHlwZS5QUkVDT01QT1NFLCBmcmFtZVN0YXRlKTtcblxuICAgIGNvbnN0IGxheWVyU3RhdGVzQXJyYXkgPSBmcmFtZVN0YXRlLmxheWVyU3RhdGVzQXJyYXkuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgcmV0dXJuIGEuekluZGV4IC0gYi56SW5kZXg7XG4gICAgfSk7XG4gICAgY29uc3Qgdmlld1N0YXRlID0gZnJhbWVTdGF0ZS52aWV3U3RhdGU7XG5cbiAgICB0aGlzLmNoaWxkcmVuXy5sZW5ndGggPSAwO1xuXG4gICAgY29uc3QgZGVjbHV0dGVyTGF5ZXJzID0gdGhpcy5kZWNsdXR0ZXJMYXllcnNfO1xuICAgIGRlY2x1dHRlckxheWVycy5sZW5ndGggPSAwO1xuXG4gICAgbGV0IHByZXZpb3VzRWxlbWVudCA9IG51bGw7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gbGF5ZXJTdGF0ZXNBcnJheS5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICBjb25zdCBsYXllclN0YXRlID0gbGF5ZXJTdGF0ZXNBcnJheVtpXTtcbiAgICAgIGZyYW1lU3RhdGUubGF5ZXJJbmRleCA9IGk7XG5cbiAgICAgIGNvbnN0IGxheWVyID0gbGF5ZXJTdGF0ZS5sYXllcjtcbiAgICAgIGNvbnN0IHNvdXJjZVN0YXRlID0gbGF5ZXIuZ2V0U291cmNlU3RhdGUoKTtcbiAgICAgIGlmIChcbiAgICAgICAgIWluVmlldyhsYXllclN0YXRlLCB2aWV3U3RhdGUpIHx8XG4gICAgICAgIChzb3VyY2VTdGF0ZSAhPSAncmVhZHknICYmIHNvdXJjZVN0YXRlICE9ICd1bmRlZmluZWQnKVxuICAgICAgKSB7XG4gICAgICAgIGxheWVyLnVucmVuZGVyKCk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBlbGVtZW50ID0gbGF5ZXIucmVuZGVyKGZyYW1lU3RhdGUsIHByZXZpb3VzRWxlbWVudCk7XG4gICAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoZWxlbWVudCAhPT0gcHJldmlvdXNFbGVtZW50KSB7XG4gICAgICAgIHRoaXMuY2hpbGRyZW5fLnB1c2goZWxlbWVudCk7XG4gICAgICAgIHByZXZpb3VzRWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICB9XG4gICAgICBpZiAoJ2dldERlY2x1dHRlcicgaW4gbGF5ZXIpIHtcbiAgICAgICAgZGVjbHV0dGVyTGF5ZXJzLnB1c2goXG4gICAgICAgICAgLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi9sYXllci9CYXNlVmVjdG9yLmpzXCIpLmRlZmF1bHR9ICovIChsYXllcilcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5mbHVzaERlY2x1dHRlckl0ZW1zKGZyYW1lU3RhdGUpO1xuXG4gICAgcmVwbGFjZUNoaWxkcmVuKHRoaXMuZWxlbWVudF8sIHRoaXMuY2hpbGRyZW5fKTtcblxuICAgIHRoaXMuZGlzcGF0Y2hSZW5kZXJFdmVudChSZW5kZXJFdmVudFR5cGUuUE9TVENPTVBPU0UsIGZyYW1lU3RhdGUpO1xuXG4gICAgaWYgKCF0aGlzLnJlbmRlcmVkVmlzaWJsZV8pIHtcbiAgICAgIHRoaXMuZWxlbWVudF8uc3R5bGUuZGlzcGxheSA9ICcnO1xuICAgICAgdGhpcy5yZW5kZXJlZFZpc2libGVfID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB0aGlzLnNjaGVkdWxlRXhwaXJlSWNvbkNhY2hlKGZyYW1lU3RhdGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwLmpzXCIpLkZyYW1lU3RhdGV9IGZyYW1lU3RhdGUgRnJhbWUgc3RhdGUuXG4gICAqL1xuICBmbHVzaERlY2x1dHRlckl0ZW1zKGZyYW1lU3RhdGUpIHtcbiAgICBjb25zdCBsYXllcnMgPSB0aGlzLmRlY2x1dHRlckxheWVyc187XG4gICAgZm9yIChsZXQgaSA9IGxheWVycy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgbGF5ZXJzW2ldLnJlbmRlckRlY2x1dHRlcihmcmFtZVN0YXRlKTtcbiAgICB9XG4gICAgbGF5ZXJzLmxlbmd0aCA9IDA7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQ29tcG9zaXRlTWFwUmVuZGVyZXI7XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvcmVuZGVyZXIvTGF5ZXJcbiAqL1xuaW1wb3J0IEV2ZW50VHlwZSBmcm9tICcuLi9ldmVudHMvRXZlbnRUeXBlLmpzJztcbmltcG9ydCBJbWFnZVN0YXRlIGZyb20gJy4uL0ltYWdlU3RhdGUuanMnO1xuaW1wb3J0IE9ic2VydmFibGUgZnJvbSAnLi4vT2JzZXJ2YWJsZS5qcyc7XG5pbXBvcnQge2Fic3RyYWN0fSBmcm9tICcuLi91dGlsLmpzJztcblxuLyoqXG4gKiBAdGVtcGxhdGUge2ltcG9ydChcIi4uL2xheWVyL0xheWVyLmpzXCIpLmRlZmF1bHR9IExheWVyVHlwZVxuICovXG5jbGFzcyBMYXllclJlbmRlcmVyIGV4dGVuZHMgT2JzZXJ2YWJsZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0xheWVyVHlwZX0gbGF5ZXIgTGF5ZXIuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihsYXllcikge1xuICAgIHN1cGVyKCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcmVuZGVyZXIgaXMgaW5pdGlhbGl6ZWQgYW5kIHJlYWR5IHRvIHJlbmRlci5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLnJlYWR5ID0gdHJ1ZTtcblxuICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgIHRoaXMuYm91bmRIYW5kbGVJbWFnZUNoYW5nZV8gPSB0aGlzLmhhbmRsZUltYWdlQ2hhbmdlXy5iaW5kKHRoaXMpO1xuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEB0eXBlIHtMYXllclR5cGV9XG4gICAgICovXG4gICAgdGhpcy5sYXllcl8gPSBsYXllcjtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9yZW5kZXIvY2FudmFzL0V4ZWN1dG9yR3JvdXBcIikuZGVmYXVsdH1cbiAgICAgKi9cbiAgICB0aGlzLmRlY2x1dHRlckV4ZWN1dG9yR3JvdXAgPSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEFzeW5jaHJvbm91cyBsYXllciBsZXZlbCBoaXQgZGV0ZWN0aW9uLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3BpeGVsLmpzXCIpLlBpeGVsfSBwaXhlbCBQaXhlbC5cbiAgICogQHJldHVybiB7UHJvbWlzZTxBcnJheTxpbXBvcnQoXCIuLi9GZWF0dXJlXCIpLkZlYXR1cmVMaWtlPj59IFByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoXG4gICAqIGFuIGFycmF5IG9mIGZlYXR1cmVzLlxuICAgKi9cbiAgZ2V0RmVhdHVyZXMocGl4ZWwpIHtcbiAgICByZXR1cm4gYWJzdHJhY3QoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3BpeGVsLmpzXCIpLlBpeGVsfSBwaXhlbCBQaXhlbC5cbiAgICogQHJldHVybiB7VWludDhDbGFtcGVkQXJyYXl8VWludDhBcnJheXxGbG9hdDMyQXJyYXl8RGF0YVZpZXd8bnVsbH0gUGl4ZWwgZGF0YS5cbiAgICovXG4gIGdldERhdGEocGl4ZWwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmUgd2hldGhlciByZW5kZXIgc2hvdWxkIGJlIGNhbGxlZC5cbiAgICogQGFic3RyYWN0XG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwLmpzXCIpLkZyYW1lU3RhdGV9IGZyYW1lU3RhdGUgRnJhbWUgc3RhdGUuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IExheWVyIGlzIHJlYWR5IHRvIGJlIHJlbmRlcmVkLlxuICAgKi9cbiAgcHJlcGFyZUZyYW1lKGZyYW1lU3RhdGUpIHtcbiAgICByZXR1cm4gYWJzdHJhY3QoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXIgdGhlIGxheWVyLlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXAuanNcIikuRnJhbWVTdGF0ZX0gZnJhbWVTdGF0ZSBGcmFtZSBzdGF0ZS5cbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudHxudWxsfSB0YXJnZXQgVGFyZ2V0IHRoYXQgbWF5IGJlIHVzZWQgdG8gcmVuZGVyIGNvbnRlbnQgdG8uXG4gICAqIEByZXR1cm4ge0hUTUxFbGVtZW50fG51bGx9IFRoZSByZW5kZXJlZCBlbGVtZW50LlxuICAgKi9cbiAgcmVuZGVyRnJhbWUoZnJhbWVTdGF0ZSwgdGFyZ2V0KSB7XG4gICAgcmV0dXJuIGFic3RyYWN0KCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3Q8bnVtYmVyLCBPYmplY3Q8c3RyaW5nLCBpbXBvcnQoXCIuLi9UaWxlLmpzXCIpLmRlZmF1bHQ+Pn0gdGlsZXMgTG9va3VwIG9mIGxvYWRlZCB0aWxlcyBieSB6b29tIGxldmVsLlxuICAgKiBAcGFyYW0ge251bWJlcn0gem9vbSBab29tIGxldmVsLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL1RpbGUuanNcIikuZGVmYXVsdH0gdGlsZSBUaWxlLlxuICAgKiBAcmV0dXJuIHtib29sZWFufHZvaWR9IElmIGBmYWxzZWAsIHRoZSB0aWxlIHdpbGwgbm90IGJlIGNvbnNpZGVyZWQgbG9hZGVkLlxuICAgKi9cbiAgbG9hZGVkVGlsZUNhbGxiYWNrKHRpbGVzLCB6b29tLCB0aWxlKSB7XG4gICAgaWYgKCF0aWxlc1t6b29tXSkge1xuICAgICAgdGlsZXNbem9vbV0gPSB7fTtcbiAgICB9XG4gICAgdGlsZXNbem9vbV1bdGlsZS50aWxlQ29vcmQudG9TdHJpbmcoKV0gPSB0aWxlO1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgZnVuY3Rpb24gdGhhdCBhZGRzIGxvYWRlZCB0aWxlcyB0byB0aGUgdGlsZSBsb29rdXAuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vc291cmNlL1RpbGUuanNcIikuZGVmYXVsdH0gc291cmNlIFRpbGUgc291cmNlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3Byb2ovUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0fSBwcm9qZWN0aW9uIFByb2plY3Rpb24gb2YgdGhlIHRpbGVzLlxuICAgKiBAcGFyYW0ge09iamVjdDxudW1iZXIsIE9iamVjdDxzdHJpbmcsIGltcG9ydChcIi4uL1RpbGUuanNcIikuZGVmYXVsdD4+fSB0aWxlcyBMb29rdXAgb2YgbG9hZGVkIHRpbGVzIGJ5IHpvb20gbGV2ZWwuXG4gICAqIEByZXR1cm4ge2Z1bmN0aW9uKG51bWJlciwgaW1wb3J0KFwiLi4vVGlsZVJhbmdlLmpzXCIpLmRlZmF1bHQpOmJvb2xlYW59IEEgZnVuY3Rpb24gdGhhdCBjYW4gYmVcbiAgICogICAgIGNhbGxlZCB3aXRoIGEgem9vbSBsZXZlbCBhbmQgYSB0aWxlIHJhbmdlIHRvIGFkZCBsb2FkZWQgdGlsZXMgdG8gdGhlIGxvb2t1cC5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgY3JlYXRlTG9hZGVkVGlsZUZpbmRlcihzb3VyY2UsIHByb2plY3Rpb24sIHRpbGVzKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIC8qKlxuICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHpvb20gWm9vbSBsZXZlbC5cbiAgICAgICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vVGlsZVJhbmdlLmpzXCIpLmRlZmF1bHR9IHRpbGVSYW5nZSBUaWxlIHJhbmdlLlxuICAgICAgICogQHJldHVybiB7Ym9vbGVhbn0gVGhlIHRpbGUgcmFuZ2UgaXMgZnVsbHkgbG9hZGVkLlxuICAgICAgICovXG4gICAgICAoem9vbSwgdGlsZVJhbmdlKSA9PiB7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrID0gdGhpcy5sb2FkZWRUaWxlQ2FsbGJhY2suYmluZCh0aGlzLCB0aWxlcywgem9vbSk7XG4gICAgICAgIHJldHVybiBzb3VyY2UuZm9yRWFjaExvYWRlZFRpbGUocHJvamVjdGlvbiwgem9vbSwgdGlsZVJhbmdlLCBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogQGFic3RyYWN0XG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBjb29yZGluYXRlIENvb3JkaW5hdGUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwLmpzXCIpLkZyYW1lU3RhdGV9IGZyYW1lU3RhdGUgRnJhbWUgc3RhdGUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBoaXRUb2xlcmFuY2UgSGl0IHRvbGVyYW5jZSBpbiBwaXhlbHMuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi92ZWN0b3IuanNcIikuRmVhdHVyZUNhbGxiYWNrPFQ+fSBjYWxsYmFjayBGZWF0dXJlIGNhbGxiYWNrLlxuICAgKiBAcGFyYW0ge0FycmF5PGltcG9ydChcIi4vTWFwLmpzXCIpLkhpdE1hdGNoPFQ+Pn0gbWF0Y2hlcyBUaGUgaGl0IGRldGVjdGVkIG1hdGNoZXMgd2l0aCB0b2xlcmFuY2UuXG4gICAqIEByZXR1cm4ge1R8dW5kZWZpbmVkfSBDYWxsYmFjayByZXN1bHQuXG4gICAqIEB0ZW1wbGF0ZSBUXG4gICAqL1xuICBmb3JFYWNoRmVhdHVyZUF0Q29vcmRpbmF0ZShcbiAgICBjb29yZGluYXRlLFxuICAgIGZyYW1lU3RhdGUsXG4gICAgaGl0VG9sZXJhbmNlLFxuICAgIGNhbGxiYWNrLFxuICAgIG1hdGNoZXNcbiAgKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtMYXllclR5cGV9IExheWVyLlxuICAgKi9cbiAgZ2V0TGF5ZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMubGF5ZXJfO1xuICB9XG5cbiAgLyoqXG4gICAqIFBlcmZvcm0gYWN0aW9uIG5lY2Vzc2FyeSB0byBnZXQgdGhlIGxheWVyIHJlbmRlcmVkIGFmdGVyIG5ldyBmb250cyBoYXZlIGxvYWRlZFxuICAgKiBAYWJzdHJhY3RcbiAgICovXG4gIGhhbmRsZUZvbnRzQ2hhbmdlZCgpIHt9XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBjaGFuZ2VzIGluIGltYWdlIHN0YXRlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2V2ZW50cy9FdmVudC5qc1wiKS5kZWZhdWx0fSBldmVudCBJbWFnZSBjaGFuZ2UgZXZlbnQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBoYW5kbGVJbWFnZUNoYW5nZV8oZXZlbnQpIHtcbiAgICBjb25zdCBpbWFnZSA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vSW1hZ2UuanNcIikuZGVmYXVsdH0gKi8gKGV2ZW50LnRhcmdldCk7XG4gICAgaWYgKFxuICAgICAgaW1hZ2UuZ2V0U3RhdGUoKSA9PT0gSW1hZ2VTdGF0ZS5MT0FERUQgfHxcbiAgICAgIGltYWdlLmdldFN0YXRlKCkgPT09IEltYWdlU3RhdGUuRVJST1JcbiAgICApIHtcbiAgICAgIHRoaXMucmVuZGVySWZSZWFkeUFuZFZpc2libGUoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTG9hZCB0aGUgaW1hZ2UgaWYgbm90IGFscmVhZHkgbG9hZGVkLCBhbmQgcmVnaXN0ZXIgdGhlIGltYWdlIGNoYW5nZVxuICAgKiBsaXN0ZW5lciBpZiBuZWVkZWQuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vSW1hZ2UuanNcIikuZGVmYXVsdH0gaW1hZ2UgSW1hZ2UuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgaW1hZ2UgaXMgYWxyZWFkeSBsb2FkZWQsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBsb2FkSW1hZ2UoaW1hZ2UpIHtcbiAgICBsZXQgaW1hZ2VTdGF0ZSA9IGltYWdlLmdldFN0YXRlKCk7XG4gICAgaWYgKGltYWdlU3RhdGUgIT0gSW1hZ2VTdGF0ZS5MT0FERUQgJiYgaW1hZ2VTdGF0ZSAhPSBJbWFnZVN0YXRlLkVSUk9SKSB7XG4gICAgICBpbWFnZS5hZGRFdmVudExpc3RlbmVyKEV2ZW50VHlwZS5DSEFOR0UsIHRoaXMuYm91bmRIYW5kbGVJbWFnZUNoYW5nZV8pO1xuICAgIH1cbiAgICBpZiAoaW1hZ2VTdGF0ZSA9PSBJbWFnZVN0YXRlLklETEUpIHtcbiAgICAgIGltYWdlLmxvYWQoKTtcbiAgICAgIGltYWdlU3RhdGUgPSBpbWFnZS5nZXRTdGF0ZSgpO1xuICAgIH1cbiAgICByZXR1cm4gaW1hZ2VTdGF0ZSA9PSBJbWFnZVN0YXRlLkxPQURFRDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICByZW5kZXJJZlJlYWR5QW5kVmlzaWJsZSgpIHtcbiAgICBjb25zdCBsYXllciA9IHRoaXMuZ2V0TGF5ZXIoKTtcbiAgICBpZiAobGF5ZXIgJiYgbGF5ZXIuZ2V0VmlzaWJsZSgpICYmIGxheWVyLmdldFNvdXJjZVN0YXRlKCkgPT09ICdyZWFkeScpIHtcbiAgICAgIGxheWVyLmNoYW5nZWQoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2xlYW4gdXAuXG4gICAqL1xuICBkaXNwb3NlSW50ZXJuYWwoKSB7XG4gICAgZGVsZXRlIHRoaXMubGF5ZXJfO1xuICAgIHN1cGVyLmRpc3Bvc2VJbnRlcm5hbCgpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IExheWVyUmVuZGVyZXI7XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvcmVuZGVyZXIvTWFwXG4gKi9cbmltcG9ydCBEaXNwb3NhYmxlIGZyb20gJy4uL0Rpc3Bvc2FibGUuanMnO1xuaW1wb3J0IHtUUlVFfSBmcm9tICcuLi9mdW5jdGlvbnMuanMnO1xuaW1wb3J0IHthYnN0cmFjdH0gZnJvbSAnLi4vdXRpbC5qcyc7XG5pbXBvcnQge2NvbXBvc2UgYXMgY29tcG9zZVRyYW5zZm9ybSwgbWFrZUludmVyc2V9IGZyb20gJy4uL3RyYW5zZm9ybS5qcyc7XG5pbXBvcnQge2dldFdpZHRofSBmcm9tICcuLi9leHRlbnQuanMnO1xuaW1wb3J0IHtzaGFyZWQgYXMgaWNvbkltYWdlQ2FjaGV9IGZyb20gJy4uL3N0eWxlL0ljb25JbWFnZUNhY2hlLmpzJztcbmltcG9ydCB7aW5WaWV3fSBmcm9tICcuLi9sYXllci9MYXllci5qcyc7XG5pbXBvcnQge3dyYXBYfSBmcm9tICcuLi9jb29yZGluYXRlLmpzJztcblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHR5cGVkZWYgSGl0TWF0Y2hcbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5GZWF0dXJlTGlrZX0gZmVhdHVyZSBGZWF0dXJlLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9sYXllci9MYXllci5qc1wiKS5kZWZhdWx0fSBsYXllciBMYXllci5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vZ2VvbS9TaW1wbGVHZW9tZXRyeS5qc1wiKS5kZWZhdWx0fSBnZW9tZXRyeSBHZW9tZXRyeS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkaXN0YW5jZVNxIFNxdWFyZWQgZGlzdGFuY2UuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4vdmVjdG9yLmpzXCIpLkZlYXR1cmVDYWxsYmFjazxUPn0gY2FsbGJhY2sgQ2FsbGJhY2suXG4gKi9cblxuLyoqXG4gKiBAYWJzdHJhY3RcbiAqL1xuY2xhc3MgTWFwUmVuZGVyZXIgZXh0ZW5kcyBEaXNwb3NhYmxlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwLmpzXCIpLmRlZmF1bHR9IG1hcCBNYXAuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihtYXApIHtcbiAgICBzdXBlcigpO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vTWFwLmpzXCIpLmRlZmF1bHR9XG4gICAgICovXG4gICAgdGhpcy5tYXBfID0gbWFwO1xuICB9XG5cbiAgLyoqXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3JlbmRlci9FdmVudFR5cGUuanNcIikuZGVmYXVsdH0gdHlwZSBFdmVudCB0eXBlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcC5qc1wiKS5GcmFtZVN0YXRlfSBmcmFtZVN0YXRlIEZyYW1lIHN0YXRlLlxuICAgKi9cbiAgZGlzcGF0Y2hSZW5kZXJFdmVudCh0eXBlLCBmcmFtZVN0YXRlKSB7XG4gICAgYWJzdHJhY3QoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcC5qc1wiKS5GcmFtZVN0YXRlfSBmcmFtZVN0YXRlIEZyYW1lU3RhdGUuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIGNhbGN1bGF0ZU1hdHJpY2VzMkQoZnJhbWVTdGF0ZSkge1xuICAgIGNvbnN0IHZpZXdTdGF0ZSA9IGZyYW1lU3RhdGUudmlld1N0YXRlO1xuICAgIGNvbnN0IGNvb3JkaW5hdGVUb1BpeGVsVHJhbnNmb3JtID0gZnJhbWVTdGF0ZS5jb29yZGluYXRlVG9QaXhlbFRyYW5zZm9ybTtcbiAgICBjb25zdCBwaXhlbFRvQ29vcmRpbmF0ZVRyYW5zZm9ybSA9IGZyYW1lU3RhdGUucGl4ZWxUb0Nvb3JkaW5hdGVUcmFuc2Zvcm07XG5cbiAgICBjb21wb3NlVHJhbnNmb3JtKFxuICAgICAgY29vcmRpbmF0ZVRvUGl4ZWxUcmFuc2Zvcm0sXG4gICAgICBmcmFtZVN0YXRlLnNpemVbMF0gLyAyLFxuICAgICAgZnJhbWVTdGF0ZS5zaXplWzFdIC8gMixcbiAgICAgIDEgLyB2aWV3U3RhdGUucmVzb2x1dGlvbixcbiAgICAgIC0xIC8gdmlld1N0YXRlLnJlc29sdXRpb24sXG4gICAgICAtdmlld1N0YXRlLnJvdGF0aW9uLFxuICAgICAgLXZpZXdTdGF0ZS5jZW50ZXJbMF0sXG4gICAgICAtdmlld1N0YXRlLmNlbnRlclsxXVxuICAgICk7XG5cbiAgICBtYWtlSW52ZXJzZShwaXhlbFRvQ29vcmRpbmF0ZVRyYW5zZm9ybSwgY29vcmRpbmF0ZVRvUGl4ZWxUcmFuc2Zvcm0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBjb29yZGluYXRlIENvb3JkaW5hdGUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwLmpzXCIpLkZyYW1lU3RhdGV9IGZyYW1lU3RhdGUgRnJhbWVTdGF0ZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGhpdFRvbGVyYW5jZSBIaXQgdG9sZXJhbmNlIGluIHBpeGVscy5cbiAgICogQHBhcmFtIHtib29sZWFufSBjaGVja1dyYXBwZWQgQ2hlY2sgZm9yIHdyYXBwZWQgZ2VvbWV0cmllcy5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL3ZlY3Rvci5qc1wiKS5GZWF0dXJlQ2FsbGJhY2s8VD59IGNhbGxiYWNrIEZlYXR1cmUgY2FsbGJhY2suXG4gICAqIEBwYXJhbSB7U30gdGhpc0FyZyBWYWx1ZSB0byB1c2UgYXMgYHRoaXNgIHdoZW4gZXhlY3V0aW5nIGBjYWxsYmFja2AuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24odGhpczogVSwgaW1wb3J0KFwiLi4vbGF5ZXIvTGF5ZXIuanNcIikuZGVmYXVsdCk6IGJvb2xlYW59IGxheWVyRmlsdGVyIExheWVyIGZpbHRlclxuICAgKiAgICAgZnVuY3Rpb24sIG9ubHkgbGF5ZXJzIHdoaWNoIGFyZSB2aXNpYmxlIGFuZCBmb3Igd2hpY2ggdGhpcyBmdW5jdGlvblxuICAgKiAgICAgcmV0dXJucyBgdHJ1ZWAgd2lsbCBiZSB0ZXN0ZWQgZm9yIGZlYXR1cmVzLiAgQnkgZGVmYXVsdCwgYWxsIHZpc2libGVcbiAgICogICAgIGxheWVycyB3aWxsIGJlIHRlc3RlZC5cbiAgICogQHBhcmFtIHtVfSB0aGlzQXJnMiBWYWx1ZSB0byB1c2UgYXMgYHRoaXNgIHdoZW4gZXhlY3V0aW5nIGBsYXllckZpbHRlcmAuXG4gICAqIEByZXR1cm4ge1R8dW5kZWZpbmVkfSBDYWxsYmFjayByZXN1bHQuXG4gICAqIEB0ZW1wbGF0ZSBTLFQsVVxuICAgKi9cbiAgZm9yRWFjaEZlYXR1cmVBdENvb3JkaW5hdGUoXG4gICAgY29vcmRpbmF0ZSxcbiAgICBmcmFtZVN0YXRlLFxuICAgIGhpdFRvbGVyYW5jZSxcbiAgICBjaGVja1dyYXBwZWQsXG4gICAgY2FsbGJhY2ssXG4gICAgdGhpc0FyZyxcbiAgICBsYXllckZpbHRlcixcbiAgICB0aGlzQXJnMlxuICApIHtcbiAgICBsZXQgcmVzdWx0O1xuICAgIGNvbnN0IHZpZXdTdGF0ZSA9IGZyYW1lU3RhdGUudmlld1N0YXRlO1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtib29sZWFufSBtYW5hZ2VkIE1hbmFnZWQgbGF5ZXIuXG4gICAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLkZlYXR1cmVMaWtlfSBmZWF0dXJlIEZlYXR1cmUuXG4gICAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9sYXllci9MYXllci5qc1wiKS5kZWZhdWx0fSBsYXllciBMYXllci5cbiAgICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2dlb20vR2VvbWV0cnkuanNcIikuZGVmYXVsdH0gZ2VvbWV0cnkgR2VvbWV0cnkuXG4gICAgICogQHJldHVybiB7VHx1bmRlZmluZWR9IENhbGxiYWNrIHJlc3VsdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmb3JFYWNoRmVhdHVyZUF0Q29vcmRpbmF0ZShtYW5hZ2VkLCBmZWF0dXJlLCBsYXllciwgZ2VvbWV0cnkpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjay5jYWxsKHRoaXNBcmcsIGZlYXR1cmUsIG1hbmFnZWQgPyBsYXllciA6IG51bGwsIGdlb21ldHJ5KTtcbiAgICB9XG5cbiAgICBjb25zdCBwcm9qZWN0aW9uID0gdmlld1N0YXRlLnByb2plY3Rpb247XG5cbiAgICBjb25zdCB0cmFuc2xhdGVkQ29vcmRpbmF0ZSA9IHdyYXBYKGNvb3JkaW5hdGUuc2xpY2UoKSwgcHJvamVjdGlvbik7XG4gICAgY29uc3Qgb2Zmc2V0cyA9IFtbMCwgMF1dO1xuICAgIGlmIChwcm9qZWN0aW9uLmNhbldyYXBYKCkgJiYgY2hlY2tXcmFwcGVkKSB7XG4gICAgICBjb25zdCBwcm9qZWN0aW9uRXh0ZW50ID0gcHJvamVjdGlvbi5nZXRFeHRlbnQoKTtcbiAgICAgIGNvbnN0IHdvcmxkV2lkdGggPSBnZXRXaWR0aChwcm9qZWN0aW9uRXh0ZW50KTtcbiAgICAgIG9mZnNldHMucHVzaChbLXdvcmxkV2lkdGgsIDBdLCBbd29ybGRXaWR0aCwgMF0pO1xuICAgIH1cblxuICAgIGNvbnN0IGxheWVyU3RhdGVzID0gZnJhbWVTdGF0ZS5sYXllclN0YXRlc0FycmF5O1xuICAgIGNvbnN0IG51bUxheWVycyA9IGxheWVyU3RhdGVzLmxlbmd0aDtcblxuICAgIGNvbnN0IG1hdGNoZXMgPSAvKiogQHR5cGUge0FycmF5PEhpdE1hdGNoPFQ+Pn0gKi8gKFtdKTtcbiAgICBjb25zdCB0bXBDb29yZCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb2Zmc2V0cy5sZW5ndGg7IGkrKykge1xuICAgICAgZm9yIChsZXQgaiA9IG51bUxheWVycyAtIDE7IGogPj0gMDsgLS1qKSB7XG4gICAgICAgIGNvbnN0IGxheWVyU3RhdGUgPSBsYXllclN0YXRlc1tqXTtcbiAgICAgICAgY29uc3QgbGF5ZXIgPSBsYXllclN0YXRlLmxheWVyO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgbGF5ZXIuaGFzUmVuZGVyZXIoKSAmJlxuICAgICAgICAgIGluVmlldyhsYXllclN0YXRlLCB2aWV3U3RhdGUpICYmXG4gICAgICAgICAgbGF5ZXJGaWx0ZXIuY2FsbCh0aGlzQXJnMiwgbGF5ZXIpXG4gICAgICAgICkge1xuICAgICAgICAgIGNvbnN0IGxheWVyUmVuZGVyZXIgPSBsYXllci5nZXRSZW5kZXJlcigpO1xuICAgICAgICAgIGNvbnN0IHNvdXJjZSA9IGxheWVyLmdldFNvdXJjZSgpO1xuICAgICAgICAgIGlmIChsYXllclJlbmRlcmVyICYmIHNvdXJjZSkge1xuICAgICAgICAgICAgY29uc3QgY29vcmRpbmF0ZXMgPSBzb3VyY2UuZ2V0V3JhcFgoKVxuICAgICAgICAgICAgICA/IHRyYW5zbGF0ZWRDb29yZGluYXRlXG4gICAgICAgICAgICAgIDogY29vcmRpbmF0ZTtcbiAgICAgICAgICAgIGNvbnN0IGNhbGxiYWNrID0gZm9yRWFjaEZlYXR1cmVBdENvb3JkaW5hdGUuYmluZChcbiAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgbGF5ZXJTdGF0ZS5tYW5hZ2VkXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdG1wQ29vcmRbMF0gPSBjb29yZGluYXRlc1swXSArIG9mZnNldHNbaV1bMF07XG4gICAgICAgICAgICB0bXBDb29yZFsxXSA9IGNvb3JkaW5hdGVzWzFdICsgb2Zmc2V0c1tpXVsxXTtcbiAgICAgICAgICAgIHJlc3VsdCA9IGxheWVyUmVuZGVyZXIuZm9yRWFjaEZlYXR1cmVBdENvb3JkaW5hdGUoXG4gICAgICAgICAgICAgIHRtcENvb3JkLFxuICAgICAgICAgICAgICBmcmFtZVN0YXRlLFxuICAgICAgICAgICAgICBoaXRUb2xlcmFuY2UsXG4gICAgICAgICAgICAgIGNhbGxiYWNrLFxuICAgICAgICAgICAgICBtYXRjaGVzXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAobWF0Y2hlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGNvbnN0IG9yZGVyID0gMSAvIG1hdGNoZXMubGVuZ3RoO1xuICAgIG1hdGNoZXMuZm9yRWFjaCgobSwgaSkgPT4gKG0uZGlzdGFuY2VTcSArPSBpICogb3JkZXIpKTtcbiAgICBtYXRjaGVzLnNvcnQoKGEsIGIpID0+IGEuZGlzdGFuY2VTcSAtIGIuZGlzdGFuY2VTcSk7XG4gICAgbWF0Y2hlcy5zb21lKChtKSA9PiB7XG4gICAgICByZXR1cm4gKHJlc3VsdCA9IG0uY2FsbGJhY2sobS5mZWF0dXJlLCBtLmxheWVyLCBtLmdlb21ldHJ5KSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gY29vcmRpbmF0ZSBDb29yZGluYXRlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcC5qc1wiKS5GcmFtZVN0YXRlfSBmcmFtZVN0YXRlIEZyYW1lU3RhdGUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBoaXRUb2xlcmFuY2UgSGl0IHRvbGVyYW5jZSBpbiBwaXhlbHMuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gY2hlY2tXcmFwcGVkIENoZWNrIGZvciB3cmFwcGVkIGdlb21ldHJpZXMuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24odGhpczogVSwgaW1wb3J0KFwiLi4vbGF5ZXIvTGF5ZXIuanNcIikuZGVmYXVsdCk6IGJvb2xlYW59IGxheWVyRmlsdGVyIExheWVyIGZpbHRlclxuICAgKiAgICAgZnVuY3Rpb24sIG9ubHkgbGF5ZXJzIHdoaWNoIGFyZSB2aXNpYmxlIGFuZCBmb3Igd2hpY2ggdGhpcyBmdW5jdGlvblxuICAgKiAgICAgcmV0dXJucyBgdHJ1ZWAgd2lsbCBiZSB0ZXN0ZWQgZm9yIGZlYXR1cmVzLiAgQnkgZGVmYXVsdCwgYWxsIHZpc2libGVcbiAgICogICAgIGxheWVycyB3aWxsIGJlIHRlc3RlZC5cbiAgICogQHBhcmFtIHtVfSB0aGlzQXJnIFZhbHVlIHRvIHVzZSBhcyBgdGhpc2Agd2hlbiBleGVjdXRpbmcgYGxheWVyRmlsdGVyYC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gSXMgdGhlcmUgYSBmZWF0dXJlIGF0IHRoZSBnaXZlbiBjb29yZGluYXRlP1xuICAgKiBAdGVtcGxhdGUgVVxuICAgKi9cbiAgaGFzRmVhdHVyZUF0Q29vcmRpbmF0ZShcbiAgICBjb29yZGluYXRlLFxuICAgIGZyYW1lU3RhdGUsXG4gICAgaGl0VG9sZXJhbmNlLFxuICAgIGNoZWNrV3JhcHBlZCxcbiAgICBsYXllckZpbHRlcixcbiAgICB0aGlzQXJnXG4gICkge1xuICAgIGNvbnN0IGhhc0ZlYXR1cmUgPSB0aGlzLmZvckVhY2hGZWF0dXJlQXRDb29yZGluYXRlKFxuICAgICAgY29vcmRpbmF0ZSxcbiAgICAgIGZyYW1lU3RhdGUsXG4gICAgICBoaXRUb2xlcmFuY2UsXG4gICAgICBjaGVja1dyYXBwZWQsXG4gICAgICBUUlVFLFxuICAgICAgdGhpcyxcbiAgICAgIGxheWVyRmlsdGVyLFxuICAgICAgdGhpc0FyZ1xuICAgICk7XG5cbiAgICByZXR1cm4gaGFzRmVhdHVyZSAhPT0gdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL01hcC5qc1wiKS5kZWZhdWx0fSBNYXAuXG4gICAqL1xuICBnZXRNYXAoKSB7XG4gICAgcmV0dXJuIHRoaXMubWFwXztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXIuXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcGFyYW0gez9pbXBvcnQoXCIuLi9NYXAuanNcIikuRnJhbWVTdGF0ZX0gZnJhbWVTdGF0ZSBGcmFtZSBzdGF0ZS5cbiAgICovXG4gIHJlbmRlckZyYW1lKGZyYW1lU3RhdGUpIHtcbiAgICBhYnN0cmFjdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwLmpzXCIpLkZyYW1lU3RhdGV9IGZyYW1lU3RhdGUgRnJhbWUgc3RhdGUuXG4gICAqL1xuICBmbHVzaERlY2x1dHRlckl0ZW1zKGZyYW1lU3RhdGUpIHt9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwLmpzXCIpLkZyYW1lU3RhdGV9IGZyYW1lU3RhdGUgRnJhbWUgc3RhdGUuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIHNjaGVkdWxlRXhwaXJlSWNvbkNhY2hlKGZyYW1lU3RhdGUpIHtcbiAgICBpZiAoaWNvbkltYWdlQ2FjaGUuY2FuRXhwaXJlQ2FjaGUoKSkge1xuICAgICAgZnJhbWVTdGF0ZS5wb3N0UmVuZGVyRnVuY3Rpb25zLnB1c2goZXhwaXJlSWNvbkNhY2hlKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcC5qc1wiKS5kZWZhdWx0fSBtYXAgTWFwLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXAuanNcIikuRnJhbWVTdGF0ZX0gZnJhbWVTdGF0ZSBGcmFtZSBzdGF0ZS5cbiAqL1xuZnVuY3Rpb24gZXhwaXJlSWNvbkNhY2hlKG1hcCwgZnJhbWVTdGF0ZSkge1xuICBpY29uSW1hZ2VDYWNoZS5leHBpcmUoKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgTWFwUmVuZGVyZXI7XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvcmVuZGVyZXIvY2FudmFzL0xheWVyXG4gKi9cbmltcG9ydCBMYXllclJlbmRlcmVyIGZyb20gJy4uL0xheWVyLmpzJztcbmltcG9ydCBSZW5kZXJFdmVudCBmcm9tICcuLi8uLi9yZW5kZXIvRXZlbnQuanMnO1xuaW1wb3J0IFJlbmRlckV2ZW50VHlwZSBmcm9tICcuLi8uLi9yZW5kZXIvRXZlbnRUeXBlLmpzJztcbmltcG9ydCB7XG4gIGFwcGx5IGFzIGFwcGx5VHJhbnNmb3JtLFxuICBjb21wb3NlIGFzIGNvbXBvc2VUcmFuc2Zvcm0sXG4gIGNyZWF0ZSBhcyBjcmVhdGVUcmFuc2Zvcm0sXG59IGZyb20gJy4uLy4uL3RyYW5zZm9ybS5qcyc7XG5pbXBvcnQge2FzQXJyYXl9IGZyb20gJy4uLy4uL2NvbG9yLmpzJztcbmltcG9ydCB7Y3JlYXRlQ2FudmFzQ29udGV4dDJEfSBmcm9tICcuLi8uLi9kb20uanMnO1xuaW1wb3J0IHtlcXVhbHN9IGZyb20gJy4uLy4uL2FycmF5LmpzJztcbmltcG9ydCB7XG4gIGdldEJvdHRvbUxlZnQsXG4gIGdldEJvdHRvbVJpZ2h0LFxuICBnZXRUb3BMZWZ0LFxuICBnZXRUb3BSaWdodCxcbn0gZnJvbSAnLi4vLi4vZXh0ZW50LmpzJztcblxuLyoqXG4gKiBAdHlwZSB7QXJyYXk8SFRNTENhbnZhc0VsZW1lbnQ+fVxuICovXG5leHBvcnQgY29uc3QgY2FudmFzUG9vbCA9IFtdO1xuXG4vKipcbiAqIEB0eXBlIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9XG4gKi9cbmxldCBwaXhlbENvbnRleHQgPSBudWxsO1xuXG5mdW5jdGlvbiBjcmVhdGVQaXhlbENvbnRleHQoKSB7XG4gIHBpeGVsQ29udGV4dCA9IGNyZWF0ZUNhbnZhc0NvbnRleHQyRCgxLCAxLCB1bmRlZmluZWQsIHtcbiAgICB3aWxsUmVhZEZyZXF1ZW50bHk6IHRydWUsXG4gIH0pO1xufVxuXG4vKipcbiAqIEBhYnN0cmFjdFxuICogQHRlbXBsYXRlIHtpbXBvcnQoXCIuLi8uLi9sYXllci9MYXllci5qc1wiKS5kZWZhdWx0fSBMYXllclR5cGVcbiAqIEBleHRlbmRzIHtMYXllclJlbmRlcmVyPExheWVyVHlwZT59XG4gKi9cbmNsYXNzIENhbnZhc0xheWVyUmVuZGVyZXIgZXh0ZW5kcyBMYXllclJlbmRlcmVyIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7TGF5ZXJUeXBlfSBsYXllciBMYXllci5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGxheWVyKSB7XG4gICAgc3VwZXIobGF5ZXIpO1xuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cbiAgICAgKi9cbiAgICB0aGlzLmNvbnRhaW5lciA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnJlbmRlcmVkUmVzb2x1dGlvbjtcblxuICAgIC8qKlxuICAgICAqIEEgdGVtcG9yYXJ5IHRyYW5zZm9ybS4gIFRoZSB2YWx1ZXMgaW4gdGhpcyB0cmFuc2Zvcm0gc2hvdWxkIG9ubHkgYmUgdXNlZCBpbiBhXG4gICAgICogZnVuY3Rpb24gdGhhdCBzZXRzIHRoZSB2YWx1ZXMuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi90cmFuc2Zvcm0uanNcIikuVHJhbnNmb3JtfVxuICAgICAqL1xuICAgIHRoaXMudGVtcFRyYW5zZm9ybSA9IGNyZWF0ZVRyYW5zZm9ybSgpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHRyYW5zZm9ybSBmb3IgcmVuZGVyZWQgcGl4ZWxzIHRvIHZpZXdwb3J0IENTUyBwaXhlbHMuICBUaGlzIHRyYW5zZm9ybSBtdXN0XG4gICAgICogYmUgc2V0IHdoZW4gcmVuZGVyaW5nIGEgZnJhbWUgYW5kIG1heSBiZSB1c2VkIGJ5IG90aGVyIGZ1bmN0aW9ucyBhZnRlciByZW5kZXJpbmcuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi90cmFuc2Zvcm0uanNcIikuVHJhbnNmb3JtfVxuICAgICAqL1xuICAgIHRoaXMucGl4ZWxUcmFuc2Zvcm0gPSBjcmVhdGVUcmFuc2Zvcm0oKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSB0cmFuc2Zvcm0gZm9yIHZpZXdwb3J0IENTUyBwaXhlbHMgdG8gcmVuZGVyZWQgcGl4ZWxzLiAgVGhpcyB0cmFuc2Zvcm0gbXVzdFxuICAgICAqIGJlIHNldCB3aGVuIHJlbmRlcmluZyBhIGZyYW1lIGFuZCBtYXkgYmUgdXNlZCBieSBvdGhlciBmdW5jdGlvbnMgYWZ0ZXIgcmVuZGVyaW5nLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vdHJhbnNmb3JtLmpzXCIpLlRyYW5zZm9ybX1cbiAgICAgKi9cbiAgICB0aGlzLmludmVyc2VQaXhlbFRyYW5zZm9ybSA9IGNyZWF0ZVRyYW5zZm9ybSgpO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH1cbiAgICAgKi9cbiAgICB0aGlzLmNvbnRleHQgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5jb250YWluZXJSZXVzZWQgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH1cbiAgICAgKi9cbiAgICB0aGlzLnBpeGVsQ29udGV4dF8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi9NYXAuanNcIikuRnJhbWVTdGF0ZXxudWxsfVxuICAgICAqL1xuICAgIHRoaXMuZnJhbWVTdGF0ZSA9IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoJy4uLy4uL0RhdGFUaWxlLmpzJykuSW1hZ2VMaWtlfSBpbWFnZSBJbWFnZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGNvbCBUaGUgY29sdW1uIGluZGV4LlxuICAgKiBAcGFyYW0ge251bWJlcn0gcm93IFRoZSByb3cgaW5kZXguXG4gICAqIEByZXR1cm4ge1VpbnQ4Q2xhbXBlZEFycmF5fG51bGx9IFRoZSBpbWFnZSBkYXRhLlxuICAgKi9cbiAgZ2V0SW1hZ2VEYXRhKGltYWdlLCBjb2wsIHJvdykge1xuICAgIGlmICghcGl4ZWxDb250ZXh0KSB7XG4gICAgICBjcmVhdGVQaXhlbENvbnRleHQoKTtcbiAgICB9XG4gICAgcGl4ZWxDb250ZXh0LmNsZWFyUmVjdCgwLCAwLCAxLCAxKTtcblxuICAgIGxldCBkYXRhO1xuICAgIHRyeSB7XG4gICAgICBwaXhlbENvbnRleHQuZHJhd0ltYWdlKGltYWdlLCBjb2wsIHJvdywgMSwgMSwgMCwgMCwgMSwgMSk7XG4gICAgICBkYXRhID0gcGl4ZWxDb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCAxLCAxKS5kYXRhO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcGl4ZWxDb250ZXh0ID0gbnVsbDtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydCgnLi4vLi4vTWFwLmpzJykuRnJhbWVTdGF0ZX0gZnJhbWVTdGF0ZSBGcmFtZSBzdGF0ZS5cbiAgICogQHJldHVybiB7c3RyaW5nfSBCYWNrZ3JvdW5kIGNvbG9yLlxuICAgKi9cbiAgZ2V0QmFja2dyb3VuZChmcmFtZVN0YXRlKSB7XG4gICAgY29uc3QgbGF5ZXIgPSB0aGlzLmdldExheWVyKCk7XG4gICAgbGV0IGJhY2tncm91bmQgPSBsYXllci5nZXRCYWNrZ3JvdW5kKCk7XG4gICAgaWYgKHR5cGVvZiBiYWNrZ3JvdW5kID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBiYWNrZ3JvdW5kID0gYmFja2dyb3VuZChmcmFtZVN0YXRlLnZpZXdTdGF0ZS5yZXNvbHV0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIGJhY2tncm91bmQgfHwgdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhIHJlbmRlcmluZyBjb250YWluZXIgZnJvbSBhbiBleGlzdGluZyB0YXJnZXQsIGlmIGNvbXBhdGlibGUuXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHRhcmdldCBQb3RlbnRpYWwgcmVuZGVyIHRhcmdldC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHRyYW5zZm9ybSBDU1MgVHJhbnNmb3JtLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2JhY2tncm91bmRDb2xvcl0gQmFja2dyb3VuZCBjb2xvci5cbiAgICovXG4gIHVzZUNvbnRhaW5lcih0YXJnZXQsIHRyYW5zZm9ybSwgYmFja2dyb3VuZENvbG9yKSB7XG4gICAgY29uc3QgbGF5ZXJDbGFzc05hbWUgPSB0aGlzLmdldExheWVyKCkuZ2V0Q2xhc3NOYW1lKCk7XG4gICAgbGV0IGNvbnRhaW5lciwgY29udGV4dDtcbiAgICBpZiAoXG4gICAgICB0YXJnZXQgJiZcbiAgICAgIHRhcmdldC5jbGFzc05hbWUgPT09IGxheWVyQ2xhc3NOYW1lICYmXG4gICAgICAoIWJhY2tncm91bmRDb2xvciB8fFxuICAgICAgICAodGFyZ2V0ICYmXG4gICAgICAgICAgdGFyZ2V0LnN0eWxlLmJhY2tncm91bmRDb2xvciAmJlxuICAgICAgICAgIGVxdWFscyhcbiAgICAgICAgICAgIGFzQXJyYXkodGFyZ2V0LnN0eWxlLmJhY2tncm91bmRDb2xvciksXG4gICAgICAgICAgICBhc0FycmF5KGJhY2tncm91bmRDb2xvcilcbiAgICAgICAgICApKSlcbiAgICApIHtcbiAgICAgIGNvbnN0IGNhbnZhcyA9IHRhcmdldC5maXJzdEVsZW1lbnRDaGlsZDtcbiAgICAgIGlmIChjYW52YXMgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudCkge1xuICAgICAgICBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjb250ZXh0ICYmIGNvbnRleHQuY2FudmFzLnN0eWxlLnRyYW5zZm9ybSA9PT0gdHJhbnNmb3JtKSB7XG4gICAgICAvLyBDb250YWluZXIgb2YgdGhlIHByZXZpb3VzIGxheWVyIHJlbmRlcmVyIGNhbiBiZSB1c2VkLlxuICAgICAgdGhpcy5jb250YWluZXIgPSB0YXJnZXQ7XG4gICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgdGhpcy5jb250YWluZXJSZXVzZWQgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAodGhpcy5jb250YWluZXJSZXVzZWQpIHtcbiAgICAgIC8vIFByZXZpb3VzbHkgcmV1c2VkIGNvbnRhaW5lciBjYW5ub3QgYmUgdXNlZCBhbnkgbW9yZS5cbiAgICAgIHRoaXMuY29udGFpbmVyID0gbnVsbDtcbiAgICAgIHRoaXMuY29udGV4dCA9IG51bGw7XG4gICAgICB0aGlzLmNvbnRhaW5lclJldXNlZCA9IGZhbHNlO1xuICAgIH0gZWxzZSBpZiAodGhpcy5jb250YWluZXIpIHtcbiAgICAgIHRoaXMuY29udGFpbmVyLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IG51bGw7XG4gICAgfVxuICAgIGlmICghdGhpcy5jb250YWluZXIpIHtcbiAgICAgIGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgY29udGFpbmVyLmNsYXNzTmFtZSA9IGxheWVyQ2xhc3NOYW1lO1xuICAgICAgbGV0IHN0eWxlID0gY29udGFpbmVyLnN0eWxlO1xuICAgICAgc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgc3R5bGUud2lkdGggPSAnMTAwJSc7XG4gICAgICBzdHlsZS5oZWlnaHQgPSAnMTAwJSc7XG4gICAgICBjb250ZXh0ID0gY3JlYXRlQ2FudmFzQ29udGV4dDJEKCk7XG4gICAgICBjb25zdCBjYW52YXMgPSBjb250ZXh0LmNhbnZhcztcbiAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChjYW52YXMpO1xuICAgICAgc3R5bGUgPSBjYW52YXMuc3R5bGU7XG4gICAgICBzdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICBzdHlsZS5sZWZ0ID0gJzAnO1xuICAgICAgc3R5bGUudHJhbnNmb3JtT3JpZ2luID0gJ3RvcCBsZWZ0JztcbiAgICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICB9XG4gICAgaWYgKFxuICAgICAgIXRoaXMuY29udGFpbmVyUmV1c2VkICYmXG4gICAgICBiYWNrZ3JvdW5kQ29sb3IgJiZcbiAgICAgICF0aGlzLmNvbnRhaW5lci5zdHlsZS5iYWNrZ3JvdW5kQ29sb3JcbiAgICApIHtcbiAgICAgIHRoaXMuY29udGFpbmVyLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IGJhY2tncm91bmRDb2xvcjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHQgQ29udGV4dC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9NYXAuanNcIikuRnJhbWVTdGF0ZX0gZnJhbWVTdGF0ZSBGcmFtZSBzdGF0ZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9leHRlbnQuanNcIikuRXh0ZW50fSBleHRlbnQgQ2xpcCBleHRlbnQuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIGNsaXBVbnJvdGF0ZWQoY29udGV4dCwgZnJhbWVTdGF0ZSwgZXh0ZW50KSB7XG4gICAgY29uc3QgdG9wTGVmdCA9IGdldFRvcExlZnQoZXh0ZW50KTtcbiAgICBjb25zdCB0b3BSaWdodCA9IGdldFRvcFJpZ2h0KGV4dGVudCk7XG4gICAgY29uc3QgYm90dG9tUmlnaHQgPSBnZXRCb3R0b21SaWdodChleHRlbnQpO1xuICAgIGNvbnN0IGJvdHRvbUxlZnQgPSBnZXRCb3R0b21MZWZ0KGV4dGVudCk7XG5cbiAgICBhcHBseVRyYW5zZm9ybShmcmFtZVN0YXRlLmNvb3JkaW5hdGVUb1BpeGVsVHJhbnNmb3JtLCB0b3BMZWZ0KTtcbiAgICBhcHBseVRyYW5zZm9ybShmcmFtZVN0YXRlLmNvb3JkaW5hdGVUb1BpeGVsVHJhbnNmb3JtLCB0b3BSaWdodCk7XG4gICAgYXBwbHlUcmFuc2Zvcm0oZnJhbWVTdGF0ZS5jb29yZGluYXRlVG9QaXhlbFRyYW5zZm9ybSwgYm90dG9tUmlnaHQpO1xuICAgIGFwcGx5VHJhbnNmb3JtKGZyYW1lU3RhdGUuY29vcmRpbmF0ZVRvUGl4ZWxUcmFuc2Zvcm0sIGJvdHRvbUxlZnQpO1xuXG4gICAgY29uc3QgaW52ZXJ0ZWQgPSB0aGlzLmludmVyc2VQaXhlbFRyYW5zZm9ybTtcbiAgICBhcHBseVRyYW5zZm9ybShpbnZlcnRlZCwgdG9wTGVmdCk7XG4gICAgYXBwbHlUcmFuc2Zvcm0oaW52ZXJ0ZWQsIHRvcFJpZ2h0KTtcbiAgICBhcHBseVRyYW5zZm9ybShpbnZlcnRlZCwgYm90dG9tUmlnaHQpO1xuICAgIGFwcGx5VHJhbnNmb3JtKGludmVydGVkLCBib3R0b21MZWZ0KTtcblxuICAgIGNvbnRleHQuc2F2ZSgpO1xuICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgY29udGV4dC5tb3ZlVG8oTWF0aC5yb3VuZCh0b3BMZWZ0WzBdKSwgTWF0aC5yb3VuZCh0b3BMZWZ0WzFdKSk7XG4gICAgY29udGV4dC5saW5lVG8oTWF0aC5yb3VuZCh0b3BSaWdodFswXSksIE1hdGgucm91bmQodG9wUmlnaHRbMV0pKTtcbiAgICBjb250ZXh0LmxpbmVUbyhNYXRoLnJvdW5kKGJvdHRvbVJpZ2h0WzBdKSwgTWF0aC5yb3VuZChib3R0b21SaWdodFsxXSkpO1xuICAgIGNvbnRleHQubGluZVRvKE1hdGgucm91bmQoYm90dG9tTGVmdFswXSksIE1hdGgucm91bmQoYm90dG9tTGVmdFsxXSkpO1xuICAgIGNvbnRleHQuY2xpcCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vcmVuZGVyL0V2ZW50VHlwZS5qc1wiKS5kZWZhdWx0fSB0eXBlIEV2ZW50IHR5cGUuXG4gICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjb250ZXh0IENvbnRleHQuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vTWFwLmpzXCIpLkZyYW1lU3RhdGV9IGZyYW1lU3RhdGUgRnJhbWUgc3RhdGUuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBkaXNwYXRjaFJlbmRlckV2ZW50Xyh0eXBlLCBjb250ZXh0LCBmcmFtZVN0YXRlKSB7XG4gICAgY29uc3QgbGF5ZXIgPSB0aGlzLmdldExheWVyKCk7XG4gICAgaWYgKGxheWVyLmhhc0xpc3RlbmVyKHR5cGUpKSB7XG4gICAgICBjb25zdCBldmVudCA9IG5ldyBSZW5kZXJFdmVudChcbiAgICAgICAgdHlwZSxcbiAgICAgICAgdGhpcy5pbnZlcnNlUGl4ZWxUcmFuc2Zvcm0sXG4gICAgICAgIGZyYW1lU3RhdGUsXG4gICAgICAgIGNvbnRleHRcbiAgICAgICk7XG4gICAgICBsYXllci5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHQgQ29udGV4dC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9NYXAuanNcIikuRnJhbWVTdGF0ZX0gZnJhbWVTdGF0ZSBGcmFtZSBzdGF0ZS5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgcHJlUmVuZGVyKGNvbnRleHQsIGZyYW1lU3RhdGUpIHtcbiAgICB0aGlzLmZyYW1lU3RhdGUgPSBmcmFtZVN0YXRlO1xuICAgIHRoaXMuZGlzcGF0Y2hSZW5kZXJFdmVudF8oUmVuZGVyRXZlbnRUeXBlLlBSRVJFTkRFUiwgY29udGV4dCwgZnJhbWVTdGF0ZSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHQgQ29udGV4dC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9NYXAuanNcIikuRnJhbWVTdGF0ZX0gZnJhbWVTdGF0ZSBGcmFtZSBzdGF0ZS5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgcG9zdFJlbmRlcihjb250ZXh0LCBmcmFtZVN0YXRlKSB7XG4gICAgdGhpcy5kaXNwYXRjaFJlbmRlckV2ZW50XyhSZW5kZXJFdmVudFR5cGUuUE9TVFJFTkRFUiwgY29udGV4dCwgZnJhbWVTdGF0ZSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIHRyYW5zZm9ybSBmb3IgcmVuZGVyaW5nIHRvIGFuIGVsZW1lbnQgdGhhdCB3aWxsIGJlIHJvdGF0ZWQgYWZ0ZXIgcmVuZGVyaW5nLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gY2VudGVyIENlbnRlci5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHJlc29sdXRpb24gUmVzb2x1dGlvbi5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHJvdGF0aW9uIFJvdGF0aW9uLlxuICAgKiBAcGFyYW0ge251bWJlcn0gcGl4ZWxSYXRpbyBQaXhlbCByYXRpby5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIFdpZHRoIG9mIHRoZSByZW5kZXJlZCBlbGVtZW50IChpbiBwaXhlbHMpLlxuICAgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IEhlaWdodCBvZiB0aGUgcmVuZGVyZWQgZWxlbWVudCAoaW4gcGl4ZWxzKS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFggT2Zmc2V0IG9uIHRoZSB4LWF4aXMgaW4gdmlldyBjb29yZGluYXRlcy5cbiAgICogQHByb3RlY3RlZFxuICAgKiBAcmV0dXJuIHshaW1wb3J0KFwiLi4vLi4vdHJhbnNmb3JtLmpzXCIpLlRyYW5zZm9ybX0gVHJhbnNmb3JtLlxuICAgKi9cbiAgZ2V0UmVuZGVyVHJhbnNmb3JtKFxuICAgIGNlbnRlcixcbiAgICByZXNvbHV0aW9uLFxuICAgIHJvdGF0aW9uLFxuICAgIHBpeGVsUmF0aW8sXG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgIG9mZnNldFhcbiAgKSB7XG4gICAgY29uc3QgZHgxID0gd2lkdGggLyAyO1xuICAgIGNvbnN0IGR5MSA9IGhlaWdodCAvIDI7XG4gICAgY29uc3Qgc3ggPSBwaXhlbFJhdGlvIC8gcmVzb2x1dGlvbjtcbiAgICBjb25zdCBzeSA9IC1zeDtcbiAgICBjb25zdCBkeDIgPSAtY2VudGVyWzBdICsgb2Zmc2V0WDtcbiAgICBjb25zdCBkeTIgPSAtY2VudGVyWzFdO1xuICAgIHJldHVybiBjb21wb3NlVHJhbnNmb3JtKFxuICAgICAgdGhpcy50ZW1wVHJhbnNmb3JtLFxuICAgICAgZHgxLFxuICAgICAgZHkxLFxuICAgICAgc3gsXG4gICAgICBzeSxcbiAgICAgIC1yb3RhdGlvbixcbiAgICAgIGR4MixcbiAgICAgIGR5MlxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQ2xlYW4gdXAuXG4gICAqL1xuICBkaXNwb3NlSW50ZXJuYWwoKSB7XG4gICAgZGVsZXRlIHRoaXMuZnJhbWVTdGF0ZTtcbiAgICBzdXBlci5kaXNwb3NlSW50ZXJuYWwoKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBDYW52YXNMYXllclJlbmRlcmVyO1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3JlbmRlcmVyL2NhbnZhcy9UaWxlTGF5ZXJcbiAqL1xuaW1wb3J0IENhbnZhc0xheWVyUmVuZGVyZXIgZnJvbSAnLi9MYXllci5qcyc7XG5pbXBvcnQgSW1hZ2VUaWxlIGZyb20gJy4uLy4uL0ltYWdlVGlsZS5qcyc7XG5pbXBvcnQgUmVwcm9qVGlsZSBmcm9tICcuLi8uLi9yZXByb2ovVGlsZS5qcyc7XG5pbXBvcnQgVGlsZVJhbmdlIGZyb20gJy4uLy4uL1RpbGVSYW5nZS5qcyc7XG5pbXBvcnQgVGlsZVN0YXRlIGZyb20gJy4uLy4uL1RpbGVTdGF0ZS5qcyc7XG5pbXBvcnQge1xuICBhcHBseSBhcyBhcHBseVRyYW5zZm9ybSxcbiAgY29tcG9zZSBhcyBjb21wb3NlVHJhbnNmb3JtLFxuICBtYWtlSW52ZXJzZSxcbiAgdG9TdHJpbmcgYXMgdG9UcmFuc2Zvcm1TdHJpbmcsXG59IGZyb20gJy4uLy4uL3RyYW5zZm9ybS5qcyc7XG5pbXBvcnQge2FzY2VuZGluZ30gZnJvbSAnLi4vLi4vYXJyYXkuanMnO1xuaW1wb3J0IHtcbiAgY29udGFpbnNDb29yZGluYXRlLFxuICBjcmVhdGVFbXB0eSxcbiAgZXF1YWxzLFxuICBnZXRIZWlnaHQsXG4gIGdldEludGVyc2VjdGlvbixcbiAgZ2V0Um90YXRlZFZpZXdwb3J0LFxuICBnZXRUb3BMZWZ0LFxuICBnZXRXaWR0aCxcbiAgaW50ZXJzZWN0cyxcbn0gZnJvbSAnLi4vLi4vZXh0ZW50LmpzJztcbmltcG9ydCB7ZnJvbVVzZXJFeHRlbnR9IGZyb20gJy4uLy4uL3Byb2ouanMnO1xuaW1wb3J0IHtnZXRVaWR9IGZyb20gJy4uLy4uL3V0aWwuanMnO1xuaW1wb3J0IHt0b1NpemV9IGZyb20gJy4uLy4uL3NpemUuanMnO1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIENhbnZhcyByZW5kZXJlciBmb3IgdGlsZSBsYXllcnMuXG4gKiBAYXBpXG4gKiBAdGVtcGxhdGUge2ltcG9ydChcIi4uLy4uL2xheWVyL1RpbGUuanNcIikuZGVmYXVsdDxpbXBvcnQoXCIuLi8uLi9zb3VyY2UvVGlsZS5qc1wiKS5kZWZhdWx0PnxpbXBvcnQoXCIuLi8uLi9sYXllci9WZWN0b3JUaWxlLmpzXCIpLmRlZmF1bHR9IFtMYXllclR5cGU9aW1wb3J0KFwiLi4vLi4vbGF5ZXIvVGlsZS5qc1wiKS5kZWZhdWx0PGltcG9ydChcIi4uLy4uL3NvdXJjZS9UaWxlLmpzXCIpLmRlZmF1bHQ+fGltcG9ydChcIi4uLy4uL2xheWVyL1ZlY3RvclRpbGUuanNcIikuZGVmYXVsdF1cbiAqIEBleHRlbmRzIHtDYW52YXNMYXllclJlbmRlcmVyPExheWVyVHlwZT59XG4gKi9cbmNsYXNzIENhbnZhc1RpbGVMYXllclJlbmRlcmVyIGV4dGVuZHMgQ2FudmFzTGF5ZXJSZW5kZXJlciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0xheWVyVHlwZX0gdGlsZUxheWVyIFRpbGUgbGF5ZXIuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih0aWxlTGF5ZXIpIHtcbiAgICBzdXBlcih0aWxlTGF5ZXIpO1xuXG4gICAgLyoqXG4gICAgICogUmVuZGVyZWQgZXh0ZW50IGhhcyBjaGFuZ2VkIHNpbmNlIHRoZSBwcmV2aW91cyBgcmVuZGVyRnJhbWUoKWAgY2FsbFxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuZXh0ZW50Q2hhbmdlZCA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHs/aW1wb3J0KFwiLi4vLi4vZXh0ZW50LmpzXCIpLkV4dGVudH1cbiAgICAgKi9cbiAgICB0aGlzLnJlbmRlcmVkRXh0ZW50XyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnJlbmRlcmVkUGl4ZWxSYXRpbztcblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vcHJvai9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR9XG4gICAgICovXG4gICAgdGhpcy5yZW5kZXJlZFByb2plY3Rpb24gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5yZW5kZXJlZFJldmlzaW9uO1xuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEB0eXBlIHshQXJyYXk8aW1wb3J0KFwiLi4vLi4vVGlsZS5qc1wiKS5kZWZhdWx0Pn1cbiAgICAgKi9cbiAgICB0aGlzLnJlbmRlcmVkVGlsZXMgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5uZXdUaWxlc18gPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vZXh0ZW50LmpzXCIpLkV4dGVudH1cbiAgICAgKi9cbiAgICB0aGlzLnRtcEV4dGVudCA9IGNyZWF0ZUVtcHR5KCk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi9UaWxlUmFuZ2UuanNcIikuZGVmYXVsdH1cbiAgICAgKi9cbiAgICB0aGlzLnRtcFRpbGVSYW5nZV8gPSBuZXcgVGlsZVJhbmdlKDAsIDAsIDAsIDApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9UaWxlLmpzXCIpLmRlZmF1bHR9IHRpbGUgVGlsZS5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVGlsZSBpcyBkcmF3YWJsZS5cbiAgICovXG4gIGlzRHJhd2FibGVUaWxlKHRpbGUpIHtcbiAgICBjb25zdCB0aWxlTGF5ZXIgPSB0aGlzLmdldExheWVyKCk7XG4gICAgY29uc3QgdGlsZVN0YXRlID0gdGlsZS5nZXRTdGF0ZSgpO1xuICAgIGNvbnN0IHVzZUludGVyaW1UaWxlc09uRXJyb3IgPSB0aWxlTGF5ZXIuZ2V0VXNlSW50ZXJpbVRpbGVzT25FcnJvcigpO1xuICAgIHJldHVybiAoXG4gICAgICB0aWxlU3RhdGUgPT0gVGlsZVN0YXRlLkxPQURFRCB8fFxuICAgICAgdGlsZVN0YXRlID09IFRpbGVTdGF0ZS5FTVBUWSB8fFxuICAgICAgKHRpbGVTdGF0ZSA9PSBUaWxlU3RhdGUuRVJST1IgJiYgIXVzZUludGVyaW1UaWxlc09uRXJyb3IpXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0geiBUaWxlIGNvb3JkaW5hdGUgei5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHggVGlsZSBjb29yZGluYXRlIHguXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5IFRpbGUgY29vcmRpbmF0ZSB5LlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL01hcC5qc1wiKS5GcmFtZVN0YXRlfSBmcmFtZVN0YXRlIEZyYW1lIHN0YXRlLlxuICAgKiBAcmV0dXJuIHshaW1wb3J0KFwiLi4vLi4vVGlsZS5qc1wiKS5kZWZhdWx0fSBUaWxlLlxuICAgKi9cbiAgZ2V0VGlsZSh6LCB4LCB5LCBmcmFtZVN0YXRlKSB7XG4gICAgY29uc3QgcGl4ZWxSYXRpbyA9IGZyYW1lU3RhdGUucGl4ZWxSYXRpbztcbiAgICBjb25zdCBwcm9qZWN0aW9uID0gZnJhbWVTdGF0ZS52aWV3U3RhdGUucHJvamVjdGlvbjtcbiAgICBjb25zdCB0aWxlTGF5ZXIgPSB0aGlzLmdldExheWVyKCk7XG4gICAgY29uc3QgdGlsZVNvdXJjZSA9IHRpbGVMYXllci5nZXRTb3VyY2UoKTtcbiAgICBsZXQgdGlsZSA9IHRpbGVTb3VyY2UuZ2V0VGlsZSh6LCB4LCB5LCBwaXhlbFJhdGlvLCBwcm9qZWN0aW9uKTtcbiAgICBpZiAodGlsZS5nZXRTdGF0ZSgpID09IFRpbGVTdGF0ZS5FUlJPUikge1xuICAgICAgaWYgKHRpbGVMYXllci5nZXRVc2VJbnRlcmltVGlsZXNPbkVycm9yKCkgJiYgdGlsZUxheWVyLmdldFByZWxvYWQoKSA+IDApIHtcbiAgICAgICAgLy8gUHJlbG9hZGVkIHRpbGVzIGZvciBsb3dlciByZXNvbHV0aW9ucyBtaWdodCBoYXZlIGZpbmlzaGVkIGxvYWRpbmcuXG4gICAgICAgIHRoaXMubmV3VGlsZXNfID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCF0aGlzLmlzRHJhd2FibGVUaWxlKHRpbGUpKSB7XG4gICAgICB0aWxlID0gdGlsZS5nZXRJbnRlcmltVGlsZSgpO1xuICAgIH1cbiAgICByZXR1cm4gdGlsZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL3BpeGVsLmpzXCIpLlBpeGVsfSBwaXhlbCBQaXhlbC5cbiAgICogQHJldHVybiB7VWludDhDbGFtcGVkQXJyYXl9IERhdGEgYXQgdGhlIHBpeGVsIGxvY2F0aW9uLlxuICAgKi9cbiAgZ2V0RGF0YShwaXhlbCkge1xuICAgIGNvbnN0IGZyYW1lU3RhdGUgPSB0aGlzLmZyYW1lU3RhdGU7XG4gICAgaWYgKCFmcmFtZVN0YXRlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBjb25zdCBsYXllciA9IHRoaXMuZ2V0TGF5ZXIoKTtcbiAgICBjb25zdCBjb29yZGluYXRlID0gYXBwbHlUcmFuc2Zvcm0oXG4gICAgICBmcmFtZVN0YXRlLnBpeGVsVG9Db29yZGluYXRlVHJhbnNmb3JtLFxuICAgICAgcGl4ZWwuc2xpY2UoKVxuICAgICk7XG5cbiAgICBjb25zdCBsYXllckV4dGVudCA9IGxheWVyLmdldEV4dGVudCgpO1xuICAgIGlmIChsYXllckV4dGVudCkge1xuICAgICAgaWYgKCFjb250YWluc0Nvb3JkaW5hdGUobGF5ZXJFeHRlbnQsIGNvb3JkaW5hdGUpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHBpeGVsUmF0aW8gPSBmcmFtZVN0YXRlLnBpeGVsUmF0aW87XG4gICAgY29uc3QgcHJvamVjdGlvbiA9IGZyYW1lU3RhdGUudmlld1N0YXRlLnByb2plY3Rpb247XG4gICAgY29uc3Qgdmlld1N0YXRlID0gZnJhbWVTdGF0ZS52aWV3U3RhdGU7XG4gICAgY29uc3Qgc291cmNlID0gbGF5ZXIuZ2V0UmVuZGVyU291cmNlKCk7XG4gICAgY29uc3QgdGlsZUdyaWQgPSBzb3VyY2UuZ2V0VGlsZUdyaWRGb3JQcm9qZWN0aW9uKHZpZXdTdGF0ZS5wcm9qZWN0aW9uKTtcbiAgICBjb25zdCB0aWxlUGl4ZWxSYXRpbyA9IHNvdXJjZS5nZXRUaWxlUGl4ZWxSYXRpbyhmcmFtZVN0YXRlLnBpeGVsUmF0aW8pO1xuXG4gICAgZm9yIChcbiAgICAgIGxldCB6ID0gdGlsZUdyaWQuZ2V0WkZvclJlc29sdXRpb24odmlld1N0YXRlLnJlc29sdXRpb24pO1xuICAgICAgeiA+PSB0aWxlR3JpZC5nZXRNaW5ab29tKCk7XG4gICAgICAtLXpcbiAgICApIHtcbiAgICAgIGNvbnN0IHRpbGVDb29yZCA9IHRpbGVHcmlkLmdldFRpbGVDb29yZEZvckNvb3JkQW5kWihjb29yZGluYXRlLCB6KTtcbiAgICAgIGNvbnN0IHRpbGUgPSBzb3VyY2UuZ2V0VGlsZShcbiAgICAgICAgeixcbiAgICAgICAgdGlsZUNvb3JkWzFdLFxuICAgICAgICB0aWxlQ29vcmRbMl0sXG4gICAgICAgIHBpeGVsUmF0aW8sXG4gICAgICAgIHByb2plY3Rpb25cbiAgICAgICk7XG4gICAgICBpZiAoXG4gICAgICAgICEodGlsZSBpbnN0YW5jZW9mIEltYWdlVGlsZSB8fCB0aWxlIGluc3RhbmNlb2YgUmVwcm9qVGlsZSkgfHxcbiAgICAgICAgKHRpbGUgaW5zdGFuY2VvZiBSZXByb2pUaWxlICYmIHRpbGUuZ2V0U3RhdGUoKSA9PT0gVGlsZVN0YXRlLkVNUFRZKVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBpZiAodGlsZS5nZXRTdGF0ZSgpICE9PSBUaWxlU3RhdGUuTE9BREVEKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB0aWxlT3JpZ2luID0gdGlsZUdyaWQuZ2V0T3JpZ2luKHopO1xuICAgICAgY29uc3QgdGlsZVNpemUgPSB0b1NpemUodGlsZUdyaWQuZ2V0VGlsZVNpemUoeikpO1xuICAgICAgY29uc3QgdGlsZVJlc29sdXRpb24gPSB0aWxlR3JpZC5nZXRSZXNvbHV0aW9uKHopO1xuXG4gICAgICBjb25zdCBjb2wgPSBNYXRoLmZsb29yKFxuICAgICAgICB0aWxlUGl4ZWxSYXRpbyAqXG4gICAgICAgICAgKChjb29yZGluYXRlWzBdIC0gdGlsZU9yaWdpblswXSkgLyB0aWxlUmVzb2x1dGlvbiAtXG4gICAgICAgICAgICB0aWxlQ29vcmRbMV0gKiB0aWxlU2l6ZVswXSlcbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IHJvdyA9IE1hdGguZmxvb3IoXG4gICAgICAgIHRpbGVQaXhlbFJhdGlvICpcbiAgICAgICAgICAoKHRpbGVPcmlnaW5bMV0gLSBjb29yZGluYXRlWzFdKSAvIHRpbGVSZXNvbHV0aW9uIC1cbiAgICAgICAgICAgIHRpbGVDb29yZFsyXSAqIHRpbGVTaXplWzFdKVxuICAgICAgKTtcblxuICAgICAgY29uc3QgZ3V0dGVyID0gTWF0aC5yb3VuZChcbiAgICAgICAgdGlsZVBpeGVsUmF0aW8gKiBzb3VyY2UuZ2V0R3V0dGVyRm9yUHJvamVjdGlvbih2aWV3U3RhdGUucHJvamVjdGlvbilcbiAgICAgICk7XG5cbiAgICAgIHJldHVybiB0aGlzLmdldEltYWdlRGF0YSh0aWxlLmdldEltYWdlKCksIGNvbCArIGd1dHRlciwgcm93ICsgZ3V0dGVyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdDxudW1iZXIsIE9iamVjdDxzdHJpbmcsIGltcG9ydChcIi4uLy4uL1RpbGUuanNcIikuZGVmYXVsdD4+fSB0aWxlcyBMb29rdXAgb2YgbG9hZGVkIHRpbGVzIGJ5IHpvb20gbGV2ZWwuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB6b29tIFpvb20gbGV2ZWwuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vVGlsZS5qc1wiKS5kZWZhdWx0fSB0aWxlIFRpbGUuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW58dm9pZH0gSWYgYGZhbHNlYCwgdGhlIHRpbGUgd2lsbCBub3QgYmUgY29uc2lkZXJlZCBsb2FkZWQuXG4gICAqL1xuICBsb2FkZWRUaWxlQ2FsbGJhY2sodGlsZXMsIHpvb20sIHRpbGUpIHtcbiAgICBpZiAodGhpcy5pc0RyYXdhYmxlVGlsZSh0aWxlKSkge1xuICAgICAgcmV0dXJuIHN1cGVyLmxvYWRlZFRpbGVDYWxsYmFjayh0aWxlcywgem9vbSwgdGlsZSk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmUgd2hldGhlciByZW5kZXIgc2hvdWxkIGJlIGNhbGxlZC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9NYXAuanNcIikuRnJhbWVTdGF0ZX0gZnJhbWVTdGF0ZSBGcmFtZSBzdGF0ZS5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gTGF5ZXIgaXMgcmVhZHkgdG8gYmUgcmVuZGVyZWQuXG4gICAqL1xuICBwcmVwYXJlRnJhbWUoZnJhbWVTdGF0ZSkge1xuICAgIHJldHVybiAhIXRoaXMuZ2V0TGF5ZXIoKS5nZXRTb3VyY2UoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXIgdGhlIGxheWVyLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL01hcC5qc1wiKS5GcmFtZVN0YXRlfSBmcmFtZVN0YXRlIEZyYW1lIHN0YXRlLlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSB0YXJnZXQgVGFyZ2V0IHRoYXQgbWF5IGJlIHVzZWQgdG8gcmVuZGVyIGNvbnRlbnQgdG8uXG4gICAqIEByZXR1cm4ge0hUTUxFbGVtZW50fSBUaGUgcmVuZGVyZWQgZWxlbWVudC5cbiAgICovXG4gIHJlbmRlckZyYW1lKGZyYW1lU3RhdGUsIHRhcmdldCkge1xuICAgIGNvbnN0IGxheWVyU3RhdGUgPSBmcmFtZVN0YXRlLmxheWVyU3RhdGVzQXJyYXlbZnJhbWVTdGF0ZS5sYXllckluZGV4XTtcbiAgICBjb25zdCB2aWV3U3RhdGUgPSBmcmFtZVN0YXRlLnZpZXdTdGF0ZTtcbiAgICBjb25zdCBwcm9qZWN0aW9uID0gdmlld1N0YXRlLnByb2plY3Rpb247XG4gICAgY29uc3Qgdmlld1Jlc29sdXRpb24gPSB2aWV3U3RhdGUucmVzb2x1dGlvbjtcbiAgICBjb25zdCB2aWV3Q2VudGVyID0gdmlld1N0YXRlLmNlbnRlcjtcbiAgICBjb25zdCByb3RhdGlvbiA9IHZpZXdTdGF0ZS5yb3RhdGlvbjtcbiAgICBjb25zdCBwaXhlbFJhdGlvID0gZnJhbWVTdGF0ZS5waXhlbFJhdGlvO1xuXG4gICAgY29uc3QgdGlsZUxheWVyID0gdGhpcy5nZXRMYXllcigpO1xuICAgIGNvbnN0IHRpbGVTb3VyY2UgPSB0aWxlTGF5ZXIuZ2V0U291cmNlKCk7XG4gICAgY29uc3Qgc291cmNlUmV2aXNpb24gPSB0aWxlU291cmNlLmdldFJldmlzaW9uKCk7XG4gICAgY29uc3QgdGlsZUdyaWQgPSB0aWxlU291cmNlLmdldFRpbGVHcmlkRm9yUHJvamVjdGlvbihwcm9qZWN0aW9uKTtcbiAgICBjb25zdCB6ID0gdGlsZUdyaWQuZ2V0WkZvclJlc29sdXRpb24odmlld1Jlc29sdXRpb24sIHRpbGVTb3VyY2UuekRpcmVjdGlvbik7XG4gICAgY29uc3QgdGlsZVJlc29sdXRpb24gPSB0aWxlR3JpZC5nZXRSZXNvbHV0aW9uKHopO1xuXG4gICAgbGV0IGV4dGVudCA9IGZyYW1lU3RhdGUuZXh0ZW50O1xuICAgIGNvbnN0IHJlc29sdXRpb24gPSBmcmFtZVN0YXRlLnZpZXdTdGF0ZS5yZXNvbHV0aW9uO1xuICAgIGNvbnN0IHRpbGVQaXhlbFJhdGlvID0gdGlsZVNvdXJjZS5nZXRUaWxlUGl4ZWxSYXRpbyhwaXhlbFJhdGlvKTtcbiAgICAvLyBkZXNpcmVkIGRpbWVuc2lvbnMgb2YgdGhlIGNhbnZhcyBpbiBwaXhlbHNcbiAgICBjb25zdCB3aWR0aCA9IE1hdGgucm91bmQoKGdldFdpZHRoKGV4dGVudCkgLyByZXNvbHV0aW9uKSAqIHBpeGVsUmF0aW8pO1xuICAgIGNvbnN0IGhlaWdodCA9IE1hdGgucm91bmQoKGdldEhlaWdodChleHRlbnQpIC8gcmVzb2x1dGlvbikgKiBwaXhlbFJhdGlvKTtcblxuICAgIGNvbnN0IGxheWVyRXh0ZW50ID1cbiAgICAgIGxheWVyU3RhdGUuZXh0ZW50ICYmIGZyb21Vc2VyRXh0ZW50KGxheWVyU3RhdGUuZXh0ZW50LCBwcm9qZWN0aW9uKTtcbiAgICBpZiAobGF5ZXJFeHRlbnQpIHtcbiAgICAgIGV4dGVudCA9IGdldEludGVyc2VjdGlvbihcbiAgICAgICAgZXh0ZW50LFxuICAgICAgICBmcm9tVXNlckV4dGVudChsYXllclN0YXRlLmV4dGVudCwgcHJvamVjdGlvbilcbiAgICAgICk7XG4gICAgfVxuXG4gICAgY29uc3QgZHggPSAodGlsZVJlc29sdXRpb24gKiB3aWR0aCkgLyAyIC8gdGlsZVBpeGVsUmF0aW87XG4gICAgY29uc3QgZHkgPSAodGlsZVJlc29sdXRpb24gKiBoZWlnaHQpIC8gMiAvIHRpbGVQaXhlbFJhdGlvO1xuICAgIGNvbnN0IGNhbnZhc0V4dGVudCA9IFtcbiAgICAgIHZpZXdDZW50ZXJbMF0gLSBkeCxcbiAgICAgIHZpZXdDZW50ZXJbMV0gLSBkeSxcbiAgICAgIHZpZXdDZW50ZXJbMF0gKyBkeCxcbiAgICAgIHZpZXdDZW50ZXJbMV0gKyBkeSxcbiAgICBdO1xuXG4gICAgY29uc3QgdGlsZVJhbmdlID0gdGlsZUdyaWQuZ2V0VGlsZVJhbmdlRm9yRXh0ZW50QW5kWihleHRlbnQsIHopO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge09iamVjdDxudW1iZXIsIE9iamVjdDxzdHJpbmcsIGltcG9ydChcIi4uLy4uL1RpbGUuanNcIikuZGVmYXVsdD4+fVxuICAgICAqL1xuICAgIGNvbnN0IHRpbGVzVG9EcmF3QnlaID0ge307XG4gICAgdGlsZXNUb0RyYXdCeVpbel0gPSB7fTtcblxuICAgIGNvbnN0IGZpbmRMb2FkZWRUaWxlcyA9IHRoaXMuY3JlYXRlTG9hZGVkVGlsZUZpbmRlcihcbiAgICAgIHRpbGVTb3VyY2UsXG4gICAgICBwcm9qZWN0aW9uLFxuICAgICAgdGlsZXNUb0RyYXdCeVpcbiAgICApO1xuXG4gICAgY29uc3QgdG1wRXh0ZW50ID0gdGhpcy50bXBFeHRlbnQ7XG4gICAgY29uc3QgdG1wVGlsZVJhbmdlID0gdGhpcy50bXBUaWxlUmFuZ2VfO1xuICAgIHRoaXMubmV3VGlsZXNfID0gZmFsc2U7XG4gICAgY29uc3Qgdmlld3BvcnQgPSByb3RhdGlvblxuICAgICAgPyBnZXRSb3RhdGVkVmlld3BvcnQoXG4gICAgICAgICAgdmlld1N0YXRlLmNlbnRlcixcbiAgICAgICAgICByZXNvbHV0aW9uLFxuICAgICAgICAgIHJvdGF0aW9uLFxuICAgICAgICAgIGZyYW1lU3RhdGUuc2l6ZVxuICAgICAgICApXG4gICAgICA6IHVuZGVmaW5lZDtcbiAgICBmb3IgKGxldCB4ID0gdGlsZVJhbmdlLm1pblg7IHggPD0gdGlsZVJhbmdlLm1heFg7ICsreCkge1xuICAgICAgZm9yIChsZXQgeSA9IHRpbGVSYW5nZS5taW5ZOyB5IDw9IHRpbGVSYW5nZS5tYXhZOyArK3kpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHJvdGF0aW9uICYmXG4gICAgICAgICAgIXRpbGVHcmlkLnRpbGVDb29yZEludGVyc2VjdHNWaWV3cG9ydChbeiwgeCwgeV0sIHZpZXdwb3J0KVxuICAgICAgICApIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0aWxlID0gdGhpcy5nZXRUaWxlKHosIHgsIHksIGZyYW1lU3RhdGUpO1xuICAgICAgICBpZiAodGhpcy5pc0RyYXdhYmxlVGlsZSh0aWxlKSkge1xuICAgICAgICAgIGNvbnN0IHVpZCA9IGdldFVpZCh0aGlzKTtcbiAgICAgICAgICBpZiAodGlsZS5nZXRTdGF0ZSgpID09IFRpbGVTdGF0ZS5MT0FERUQpIHtcbiAgICAgICAgICAgIHRpbGVzVG9EcmF3QnlaW3pdW3RpbGUudGlsZUNvb3JkLnRvU3RyaW5nKCldID0gdGlsZTtcbiAgICAgICAgICAgIGxldCBpblRyYW5zaXRpb24gPSB0aWxlLmluVHJhbnNpdGlvbih1aWQpO1xuICAgICAgICAgICAgaWYgKGluVHJhbnNpdGlvbiAmJiBsYXllclN0YXRlLm9wYWNpdHkgIT09IDEpIHtcbiAgICAgICAgICAgICAgLy8gU2tpcHBpbmcgdHJhbnNpdGlvbiB3aGVuIGxheWVyIGlzIG5vdCBmdWxseSBvcGFxdWUgYXZvaWRzIHZpc3VhbCBhcnRpZmFjdHMuXG4gICAgICAgICAgICAgIHRpbGUuZW5kVHJhbnNpdGlvbih1aWQpO1xuICAgICAgICAgICAgICBpblRyYW5zaXRpb24gPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgIXRoaXMubmV3VGlsZXNfICYmXG4gICAgICAgICAgICAgIChpblRyYW5zaXRpb24gfHwgIXRoaXMucmVuZGVyZWRUaWxlcy5pbmNsdWRlcyh0aWxlKSlcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICB0aGlzLm5ld1RpbGVzXyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0aWxlLmdldEFscGhhKHVpZCwgZnJhbWVTdGF0ZS50aW1lKSA9PT0gMSkge1xuICAgICAgICAgICAgLy8gZG9uJ3QgbG9vayBmb3IgYWx0IHRpbGVzIGlmIGFscGhhIGlzIDFcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNoaWxkVGlsZVJhbmdlID0gdGlsZUdyaWQuZ2V0VGlsZUNvb3JkQ2hpbGRUaWxlUmFuZ2UoXG4gICAgICAgICAgdGlsZS50aWxlQ29vcmQsXG4gICAgICAgICAgdG1wVGlsZVJhbmdlLFxuICAgICAgICAgIHRtcEV4dGVudFxuICAgICAgICApO1xuXG4gICAgICAgIGxldCBjb3ZlcmVkID0gZmFsc2U7XG4gICAgICAgIGlmIChjaGlsZFRpbGVSYW5nZSkge1xuICAgICAgICAgIGNvdmVyZWQgPSBmaW5kTG9hZGVkVGlsZXMoeiArIDEsIGNoaWxkVGlsZVJhbmdlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNvdmVyZWQpIHtcbiAgICAgICAgICB0aWxlR3JpZC5mb3JFYWNoVGlsZUNvb3JkUGFyZW50VGlsZVJhbmdlKFxuICAgICAgICAgICAgdGlsZS50aWxlQ29vcmQsXG4gICAgICAgICAgICBmaW5kTG9hZGVkVGlsZXMsXG4gICAgICAgICAgICB0bXBUaWxlUmFuZ2UsXG4gICAgICAgICAgICB0bXBFeHRlbnRcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgY2FudmFzU2NhbGUgPVxuICAgICAgKCh0aWxlUmVzb2x1dGlvbiAvIHZpZXdSZXNvbHV0aW9uKSAqIHBpeGVsUmF0aW8pIC8gdGlsZVBpeGVsUmF0aW87XG5cbiAgICAvLyBzZXQgZm9yd2FyZCBhbmQgaW52ZXJzZSBwaXhlbCB0cmFuc2Zvcm1zXG4gICAgY29tcG9zZVRyYW5zZm9ybShcbiAgICAgIHRoaXMucGl4ZWxUcmFuc2Zvcm0sXG4gICAgICBmcmFtZVN0YXRlLnNpemVbMF0gLyAyLFxuICAgICAgZnJhbWVTdGF0ZS5zaXplWzFdIC8gMixcbiAgICAgIDEgLyBwaXhlbFJhdGlvLFxuICAgICAgMSAvIHBpeGVsUmF0aW8sXG4gICAgICByb3RhdGlvbixcbiAgICAgIC13aWR0aCAvIDIsXG4gICAgICAtaGVpZ2h0IC8gMlxuICAgICk7XG5cbiAgICBjb25zdCBjYW52YXNUcmFuc2Zvcm0gPSB0b1RyYW5zZm9ybVN0cmluZyh0aGlzLnBpeGVsVHJhbnNmb3JtKTtcblxuICAgIHRoaXMudXNlQ29udGFpbmVyKHRhcmdldCwgY2FudmFzVHJhbnNmb3JtLCB0aGlzLmdldEJhY2tncm91bmQoZnJhbWVTdGF0ZSkpO1xuICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLmNvbnRleHQ7XG4gICAgY29uc3QgY2FudmFzID0gY29udGV4dC5jYW52YXM7XG5cbiAgICBtYWtlSW52ZXJzZSh0aGlzLmludmVyc2VQaXhlbFRyYW5zZm9ybSwgdGhpcy5waXhlbFRyYW5zZm9ybSk7XG5cbiAgICAvLyBzZXQgc2NhbGUgdHJhbnNmb3JtIGZvciBjYWxjdWxhdGluZyB0aWxlIHBvc2l0aW9ucyBvbiB0aGUgY2FudmFzXG4gICAgY29tcG9zZVRyYW5zZm9ybShcbiAgICAgIHRoaXMudGVtcFRyYW5zZm9ybSxcbiAgICAgIHdpZHRoIC8gMixcbiAgICAgIGhlaWdodCAvIDIsXG4gICAgICBjYW52YXNTY2FsZSxcbiAgICAgIGNhbnZhc1NjYWxlLFxuICAgICAgMCxcbiAgICAgIC13aWR0aCAvIDIsXG4gICAgICAtaGVpZ2h0IC8gMlxuICAgICk7XG5cbiAgICBpZiAoY2FudmFzLndpZHRoICE9IHdpZHRoIHx8IGNhbnZhcy5oZWlnaHQgIT0gaGVpZ2h0KSB7XG4gICAgICBjYW52YXMud2lkdGggPSB3aWR0aDtcbiAgICAgIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgfSBlbHNlIGlmICghdGhpcy5jb250YWluZXJSZXVzZWQpIHtcbiAgICAgIGNvbnRleHQuY2xlYXJSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgIH1cblxuICAgIGlmIChsYXllckV4dGVudCkge1xuICAgICAgdGhpcy5jbGlwVW5yb3RhdGVkKGNvbnRleHQsIGZyYW1lU3RhdGUsIGxheWVyRXh0ZW50KTtcbiAgICB9XG5cbiAgICBpZiAoIXRpbGVTb3VyY2UuZ2V0SW50ZXJwb2xhdGUoKSkge1xuICAgICAgY29udGV4dC5pbWFnZVNtb290aGluZ0VuYWJsZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB0aGlzLnByZVJlbmRlcihjb250ZXh0LCBmcmFtZVN0YXRlKTtcblxuICAgIHRoaXMucmVuZGVyZWRUaWxlcy5sZW5ndGggPSAwO1xuICAgIC8qKiBAdHlwZSB7QXJyYXk8bnVtYmVyPn0gKi9cbiAgICBsZXQgenMgPSBPYmplY3Qua2V5cyh0aWxlc1RvRHJhd0J5WikubWFwKE51bWJlcik7XG4gICAgenMuc29ydChhc2NlbmRpbmcpO1xuXG4gICAgbGV0IGNsaXBzLCBjbGlwWnMsIGN1cnJlbnRDbGlwO1xuICAgIGlmIChcbiAgICAgIGxheWVyU3RhdGUub3BhY2l0eSA9PT0gMSAmJlxuICAgICAgKCF0aGlzLmNvbnRhaW5lclJldXNlZCB8fFxuICAgICAgICB0aWxlU291cmNlLmdldE9wYXF1ZShmcmFtZVN0YXRlLnZpZXdTdGF0ZS5wcm9qZWN0aW9uKSlcbiAgICApIHtcbiAgICAgIHpzID0genMucmV2ZXJzZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjbGlwcyA9IFtdO1xuICAgICAgY2xpcFpzID0gW107XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSB6cy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgY29uc3QgY3VycmVudFogPSB6c1tpXTtcbiAgICAgIGNvbnN0IGN1cnJlbnRUaWxlUGl4ZWxTaXplID0gdGlsZVNvdXJjZS5nZXRUaWxlUGl4ZWxTaXplKFxuICAgICAgICBjdXJyZW50WixcbiAgICAgICAgcGl4ZWxSYXRpbyxcbiAgICAgICAgcHJvamVjdGlvblxuICAgICAgKTtcbiAgICAgIGNvbnN0IGN1cnJlbnRSZXNvbHV0aW9uID0gdGlsZUdyaWQuZ2V0UmVzb2x1dGlvbihjdXJyZW50Wik7XG4gICAgICBjb25zdCBjdXJyZW50U2NhbGUgPSBjdXJyZW50UmVzb2x1dGlvbiAvIHRpbGVSZXNvbHV0aW9uO1xuICAgICAgY29uc3QgZHggPSBjdXJyZW50VGlsZVBpeGVsU2l6ZVswXSAqIGN1cnJlbnRTY2FsZSAqIGNhbnZhc1NjYWxlO1xuICAgICAgY29uc3QgZHkgPSBjdXJyZW50VGlsZVBpeGVsU2l6ZVsxXSAqIGN1cnJlbnRTY2FsZSAqIGNhbnZhc1NjYWxlO1xuICAgICAgY29uc3Qgb3JpZ2luVGlsZUNvb3JkID0gdGlsZUdyaWQuZ2V0VGlsZUNvb3JkRm9yQ29vcmRBbmRaKFxuICAgICAgICBnZXRUb3BMZWZ0KGNhbnZhc0V4dGVudCksXG4gICAgICAgIGN1cnJlbnRaXG4gICAgICApO1xuICAgICAgY29uc3Qgb3JpZ2luVGlsZUV4dGVudCA9IHRpbGVHcmlkLmdldFRpbGVDb29yZEV4dGVudChvcmlnaW5UaWxlQ29vcmQpO1xuICAgICAgY29uc3Qgb3JpZ2luID0gYXBwbHlUcmFuc2Zvcm0odGhpcy50ZW1wVHJhbnNmb3JtLCBbXG4gICAgICAgICh0aWxlUGl4ZWxSYXRpbyAqIChvcmlnaW5UaWxlRXh0ZW50WzBdIC0gY2FudmFzRXh0ZW50WzBdKSkgL1xuICAgICAgICAgIHRpbGVSZXNvbHV0aW9uLFxuICAgICAgICAodGlsZVBpeGVsUmF0aW8gKiAoY2FudmFzRXh0ZW50WzNdIC0gb3JpZ2luVGlsZUV4dGVudFszXSkpIC9cbiAgICAgICAgICB0aWxlUmVzb2x1dGlvbixcbiAgICAgIF0pO1xuICAgICAgY29uc3QgdGlsZUd1dHRlciA9XG4gICAgICAgIHRpbGVQaXhlbFJhdGlvICogdGlsZVNvdXJjZS5nZXRHdXR0ZXJGb3JQcm9qZWN0aW9uKHByb2plY3Rpb24pO1xuICAgICAgY29uc3QgdGlsZXNUb0RyYXcgPSB0aWxlc1RvRHJhd0J5WltjdXJyZW50Wl07XG4gICAgICBmb3IgKGNvbnN0IHRpbGVDb29yZEtleSBpbiB0aWxlc1RvRHJhdykge1xuICAgICAgICBjb25zdCB0aWxlID0gLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi9JbWFnZVRpbGUuanNcIikuZGVmYXVsdH0gKi8gKFxuICAgICAgICAgIHRpbGVzVG9EcmF3W3RpbGVDb29yZEtleV1cbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgdGlsZUNvb3JkID0gdGlsZS50aWxlQ29vcmQ7XG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIGludGVnZXIgcG9zaXRpb25zIGFuZCBzaXplcyBzbyB0aGF0IHRpbGVzIGFsaWduXG4gICAgICAgIGNvbnN0IHhJbmRleCA9IG9yaWdpblRpbGVDb29yZFsxXSAtIHRpbGVDb29yZFsxXTtcbiAgICAgICAgY29uc3QgbmV4dFggPSBNYXRoLnJvdW5kKG9yaWdpblswXSAtICh4SW5kZXggLSAxKSAqIGR4KTtcbiAgICAgICAgY29uc3QgeUluZGV4ID0gb3JpZ2luVGlsZUNvb3JkWzJdIC0gdGlsZUNvb3JkWzJdO1xuICAgICAgICBjb25zdCBuZXh0WSA9IE1hdGgucm91bmQob3JpZ2luWzFdIC0gKHlJbmRleCAtIDEpICogZHkpO1xuICAgICAgICBjb25zdCB4ID0gTWF0aC5yb3VuZChvcmlnaW5bMF0gLSB4SW5kZXggKiBkeCk7XG4gICAgICAgIGNvbnN0IHkgPSBNYXRoLnJvdW5kKG9yaWdpblsxXSAtIHlJbmRleCAqIGR5KTtcbiAgICAgICAgY29uc3QgdyA9IG5leHRYIC0geDtcbiAgICAgICAgY29uc3QgaCA9IG5leHRZIC0geTtcbiAgICAgICAgY29uc3QgdHJhbnNpdGlvbiA9IHogPT09IGN1cnJlbnRaO1xuXG4gICAgICAgIGNvbnN0IGluVHJhbnNpdGlvbiA9XG4gICAgICAgICAgdHJhbnNpdGlvbiAmJiB0aWxlLmdldEFscGhhKGdldFVpZCh0aGlzKSwgZnJhbWVTdGF0ZS50aW1lKSAhPT0gMTtcbiAgICAgICAgbGV0IGNvbnRleHRTYXZlZCA9IGZhbHNlO1xuICAgICAgICBpZiAoIWluVHJhbnNpdGlvbikge1xuICAgICAgICAgIGlmIChjbGlwcykge1xuICAgICAgICAgICAgLy8gQ2xpcCBtYXNrIGZvciByZWdpb25zIGluIHRoaXMgdGlsZSB0aGF0IGFscmVhZHkgZmlsbGVkIGJ5IGEgaGlnaGVyIHogdGlsZVxuICAgICAgICAgICAgY3VycmVudENsaXAgPSBbeCwgeSwgeCArIHcsIHksIHggKyB3LCB5ICsgaCwgeCwgeSArIGhdO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gY2xpcHMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICAgICAgICBpZiAoeiAhPT0gY3VycmVudFogJiYgY3VycmVudFogPCBjbGlwWnNbaV0pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjbGlwID0gY2xpcHNbaV07XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgaW50ZXJzZWN0cyhcbiAgICAgICAgICAgICAgICAgICAgW3gsIHksIHggKyB3LCB5ICsgaF0sXG4gICAgICAgICAgICAgICAgICAgIFtjbGlwWzBdLCBjbGlwWzNdLCBjbGlwWzRdLCBjbGlwWzddXVxuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgaWYgKCFjb250ZXh0U2F2ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5zYXZlKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHRTYXZlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgICAgLy8gY291bnRlci1jbG9ja3dpc2UgKG91dGVyIHJpbmcpIGZvciBjdXJyZW50IHRpbGVcbiAgICAgICAgICAgICAgICAgIGNvbnRleHQubW92ZVRvKGN1cnJlbnRDbGlwWzBdLCBjdXJyZW50Q2xpcFsxXSk7XG4gICAgICAgICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhjdXJyZW50Q2xpcFsyXSwgY3VycmVudENsaXBbM10pO1xuICAgICAgICAgICAgICAgICAgY29udGV4dC5saW5lVG8oY3VycmVudENsaXBbNF0sIGN1cnJlbnRDbGlwWzVdKTtcbiAgICAgICAgICAgICAgICAgIGNvbnRleHQubGluZVRvKGN1cnJlbnRDbGlwWzZdLCBjdXJyZW50Q2xpcFs3XSk7XG4gICAgICAgICAgICAgICAgICAvLyBjbG9ja3dpc2UgKGlubmVyIHJpbmcpIGZvciBoaWdoZXIgeiB0aWxlXG4gICAgICAgICAgICAgICAgICBjb250ZXh0Lm1vdmVUbyhjbGlwWzZdLCBjbGlwWzddKTtcbiAgICAgICAgICAgICAgICAgIGNvbnRleHQubGluZVRvKGNsaXBbNF0sIGNsaXBbNV0pO1xuICAgICAgICAgICAgICAgICAgY29udGV4dC5saW5lVG8oY2xpcFsyXSwgY2xpcFszXSk7XG4gICAgICAgICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhjbGlwWzBdLCBjbGlwWzFdKTtcbiAgICAgICAgICAgICAgICAgIGNvbnRleHQuY2xpcCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2xpcHMucHVzaChjdXJyZW50Q2xpcCk7XG4gICAgICAgICAgICBjbGlwWnMucHVzaChjdXJyZW50Wik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnRleHQuY2xlYXJSZWN0KHgsIHksIHcsIGgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRyYXdUaWxlSW1hZ2UoXG4gICAgICAgICAgdGlsZSxcbiAgICAgICAgICBmcmFtZVN0YXRlLFxuICAgICAgICAgIHgsXG4gICAgICAgICAgeSxcbiAgICAgICAgICB3LFxuICAgICAgICAgIGgsXG4gICAgICAgICAgdGlsZUd1dHRlcixcbiAgICAgICAgICB0cmFuc2l0aW9uXG4gICAgICAgICk7XG4gICAgICAgIGlmIChjbGlwcyAmJiAhaW5UcmFuc2l0aW9uKSB7XG4gICAgICAgICAgaWYgKGNvbnRleHRTYXZlZCkge1xuICAgICAgICAgICAgY29udGV4dC5yZXN0b3JlKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMucmVuZGVyZWRUaWxlcy51bnNoaWZ0KHRpbGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucmVuZGVyZWRUaWxlcy5wdXNoKHRpbGUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXBkYXRlVXNlZFRpbGVzKGZyYW1lU3RhdGUudXNlZFRpbGVzLCB0aWxlU291cmNlLCB0aWxlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnJlbmRlcmVkUmV2aXNpb24gPSBzb3VyY2VSZXZpc2lvbjtcbiAgICB0aGlzLnJlbmRlcmVkUmVzb2x1dGlvbiA9IHRpbGVSZXNvbHV0aW9uO1xuICAgIHRoaXMuZXh0ZW50Q2hhbmdlZCA9XG4gICAgICAhdGhpcy5yZW5kZXJlZEV4dGVudF8gfHwgIWVxdWFscyh0aGlzLnJlbmRlcmVkRXh0ZW50XywgY2FudmFzRXh0ZW50KTtcbiAgICB0aGlzLnJlbmRlcmVkRXh0ZW50XyA9IGNhbnZhc0V4dGVudDtcbiAgICB0aGlzLnJlbmRlcmVkUGl4ZWxSYXRpbyA9IHBpeGVsUmF0aW87XG4gICAgdGhpcy5yZW5kZXJlZFByb2plY3Rpb24gPSBwcm9qZWN0aW9uO1xuXG4gICAgdGhpcy5tYW5hZ2VUaWxlUHlyYW1pZChcbiAgICAgIGZyYW1lU3RhdGUsXG4gICAgICB0aWxlU291cmNlLFxuICAgICAgdGlsZUdyaWQsXG4gICAgICBwaXhlbFJhdGlvLFxuICAgICAgcHJvamVjdGlvbixcbiAgICAgIGV4dGVudCxcbiAgICAgIHosXG4gICAgICB0aWxlTGF5ZXIuZ2V0UHJlbG9hZCgpXG4gICAgKTtcbiAgICB0aGlzLnNjaGVkdWxlRXhwaXJlQ2FjaGUoZnJhbWVTdGF0ZSwgdGlsZVNvdXJjZSk7XG5cbiAgICB0aGlzLnBvc3RSZW5kZXIoY29udGV4dCwgZnJhbWVTdGF0ZSk7XG5cbiAgICBpZiAobGF5ZXJTdGF0ZS5leHRlbnQpIHtcbiAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICAgIH1cbiAgICBjb250ZXh0LmltYWdlU21vb3RoaW5nRW5hYmxlZCA9IHRydWU7XG5cbiAgICBpZiAoY2FudmFzVHJhbnNmb3JtICE9PSBjYW52YXMuc3R5bGUudHJhbnNmb3JtKSB7XG4gICAgICBjYW52YXMuc3R5bGUudHJhbnNmb3JtID0gY2FudmFzVHJhbnNmb3JtO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL0ltYWdlVGlsZS5qc1wiKS5kZWZhdWx0fSB0aWxlIFRpbGUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vTWFwLmpzXCIpLkZyYW1lU3RhdGV9IGZyYW1lU3RhdGUgRnJhbWUgc3RhdGUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4IExlZnQgb2YgdGhlIHRpbGUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5IFRvcCBvZiB0aGUgdGlsZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHcgV2lkdGggb2YgdGhlIHRpbGUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBoIEhlaWdodCBvZiB0aGUgdGlsZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGd1dHRlciBUaWxlIGd1dHRlci5cbiAgICogQHBhcmFtIHtib29sZWFufSB0cmFuc2l0aW9uIEFwcGx5IGFuIGFscGhhIHRyYW5zaXRpb24uXG4gICAqL1xuICBkcmF3VGlsZUltYWdlKHRpbGUsIGZyYW1lU3RhdGUsIHgsIHksIHcsIGgsIGd1dHRlciwgdHJhbnNpdGlvbikge1xuICAgIGNvbnN0IGltYWdlID0gdGhpcy5nZXRUaWxlSW1hZ2UodGlsZSk7XG4gICAgaWYgKCFpbWFnZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB1aWQgPSBnZXRVaWQodGhpcyk7XG4gICAgY29uc3QgbGF5ZXJTdGF0ZSA9IGZyYW1lU3RhdGUubGF5ZXJTdGF0ZXNBcnJheVtmcmFtZVN0YXRlLmxheWVySW5kZXhdO1xuICAgIGNvbnN0IGFscGhhID1cbiAgICAgIGxheWVyU3RhdGUub3BhY2l0eSAqXG4gICAgICAodHJhbnNpdGlvbiA/IHRpbGUuZ2V0QWxwaGEodWlkLCBmcmFtZVN0YXRlLnRpbWUpIDogMSk7XG4gICAgY29uc3QgYWxwaGFDaGFuZ2VkID0gYWxwaGEgIT09IHRoaXMuY29udGV4dC5nbG9iYWxBbHBoYTtcbiAgICBpZiAoYWxwaGFDaGFuZ2VkKSB7XG4gICAgICB0aGlzLmNvbnRleHQuc2F2ZSgpO1xuICAgICAgdGhpcy5jb250ZXh0Lmdsb2JhbEFscGhhID0gYWxwaGE7XG4gICAgfVxuICAgIHRoaXMuY29udGV4dC5kcmF3SW1hZ2UoXG4gICAgICBpbWFnZSxcbiAgICAgIGd1dHRlcixcbiAgICAgIGd1dHRlcixcbiAgICAgIGltYWdlLndpZHRoIC0gMiAqIGd1dHRlcixcbiAgICAgIGltYWdlLmhlaWdodCAtIDIgKiBndXR0ZXIsXG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIHcsXG4gICAgICBoXG4gICAgKTtcblxuICAgIGlmIChhbHBoYUNoYW5nZWQpIHtcbiAgICAgIHRoaXMuY29udGV4dC5yZXN0b3JlKCk7XG4gICAgfVxuICAgIGlmIChhbHBoYSAhPT0gbGF5ZXJTdGF0ZS5vcGFjaXR5KSB7XG4gICAgICBmcmFtZVN0YXRlLmFuaW1hdGUgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAodHJhbnNpdGlvbikge1xuICAgICAgdGlsZS5lbmRUcmFuc2l0aW9uKHVpZCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0hUTUxDYW52YXNFbGVtZW50fSBJbWFnZVxuICAgKi9cbiAgZ2V0SW1hZ2UoKSB7XG4gICAgY29uc3QgY29udGV4dCA9IHRoaXMuY29udGV4dDtcbiAgICByZXR1cm4gY29udGV4dCA/IGNvbnRleHQuY2FudmFzIDogbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGltYWdlIGZyb20gYSB0aWxlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL0ltYWdlVGlsZS5qc1wiKS5kZWZhdWx0fSB0aWxlIFRpbGUuXG4gICAqIEByZXR1cm4ge0hUTUxDYW52YXNFbGVtZW50fEhUTUxJbWFnZUVsZW1lbnR8SFRNTFZpZGVvRWxlbWVudH0gSW1hZ2UuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIGdldFRpbGVJbWFnZSh0aWxlKSB7XG4gICAgcmV0dXJuIHRpbGUuZ2V0SW1hZ2UoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL01hcC5qc1wiKS5GcmFtZVN0YXRlfSBmcmFtZVN0YXRlIEZyYW1lIHN0YXRlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL3NvdXJjZS9UaWxlLmpzXCIpLmRlZmF1bHR9IHRpbGVTb3VyY2UgVGlsZSBzb3VyY2UuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIHNjaGVkdWxlRXhwaXJlQ2FjaGUoZnJhbWVTdGF0ZSwgdGlsZVNvdXJjZSkge1xuICAgIGlmICh0aWxlU291cmNlLmNhbkV4cGlyZUNhY2hlKCkpIHtcbiAgICAgIC8qKlxuICAgICAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9zb3VyY2UvVGlsZS5qc1wiKS5kZWZhdWx0fSB0aWxlU291cmNlIFRpbGUgc291cmNlLlxuICAgICAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9NYXAuanNcIikuZGVmYXVsdH0gbWFwIE1hcC5cbiAgICAgICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vTWFwLmpzXCIpLkZyYW1lU3RhdGV9IGZyYW1lU3RhdGUgRnJhbWUgc3RhdGUuXG4gICAgICAgKi9cbiAgICAgIGNvbnN0IHBvc3RSZW5kZXJGdW5jdGlvbiA9IGZ1bmN0aW9uICh0aWxlU291cmNlLCBtYXAsIGZyYW1lU3RhdGUpIHtcbiAgICAgICAgY29uc3QgdGlsZVNvdXJjZUtleSA9IGdldFVpZCh0aWxlU291cmNlKTtcbiAgICAgICAgaWYgKHRpbGVTb3VyY2VLZXkgaW4gZnJhbWVTdGF0ZS51c2VkVGlsZXMpIHtcbiAgICAgICAgICB0aWxlU291cmNlLmV4cGlyZUNhY2hlKFxuICAgICAgICAgICAgZnJhbWVTdGF0ZS52aWV3U3RhdGUucHJvamVjdGlvbixcbiAgICAgICAgICAgIGZyYW1lU3RhdGUudXNlZFRpbGVzW3RpbGVTb3VyY2VLZXldXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfS5iaW5kKG51bGwsIHRpbGVTb3VyY2UpO1xuXG4gICAgICBmcmFtZVN0YXRlLnBvc3RSZW5kZXJGdW5jdGlvbnMucHVzaChcbiAgICAgICAgLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi9NYXAuanNcIikuUG9zdFJlbmRlckZ1bmN0aW9ufSAqLyAoXG4gICAgICAgICAgcG9zdFJlbmRlckZ1bmN0aW9uXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IU9iamVjdDxzdHJpbmcsICFPYmplY3Q8c3RyaW5nLCBib29sZWFuPj59IHVzZWRUaWxlcyBVc2VkIHRpbGVzLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL3NvdXJjZS9UaWxlLmpzXCIpLmRlZmF1bHR9IHRpbGVTb3VyY2UgVGlsZSBzb3VyY2UuXG4gICAqIEBwYXJhbSB7aW1wb3J0KCcuLi8uLi9UaWxlLmpzJykuZGVmYXVsdH0gdGlsZSBUaWxlLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICB1cGRhdGVVc2VkVGlsZXModXNlZFRpbGVzLCB0aWxlU291cmNlLCB0aWxlKSB7XG4gICAgLy8gRklYTUUgc2hvdWxkIHdlIHVzZSB0aWxlc1RvRHJhd0J5WiBpbnN0ZWFkP1xuICAgIGNvbnN0IHRpbGVTb3VyY2VLZXkgPSBnZXRVaWQodGlsZVNvdXJjZSk7XG4gICAgaWYgKCEodGlsZVNvdXJjZUtleSBpbiB1c2VkVGlsZXMpKSB7XG4gICAgICB1c2VkVGlsZXNbdGlsZVNvdXJjZUtleV0gPSB7fTtcbiAgICB9XG4gICAgdXNlZFRpbGVzW3RpbGVTb3VyY2VLZXldW3RpbGUuZ2V0S2V5KCldID0gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNYW5hZ2UgdGlsZSBweXJhbWlkLlxuICAgKiBUaGlzIGZ1bmN0aW9uIHBlcmZvcm1zIGEgbnVtYmVyIG9mIGZ1bmN0aW9ucyByZWxhdGVkIHRvIHRoZSB0aWxlcyBhdCB0aGVcbiAgICogY3VycmVudCB6b29tIGFuZCBsb3dlciB6b29tIGxldmVsczpcbiAgICogLSByZWdpc3RlcnMgaWRsZSB0aWxlcyBpbiBmcmFtZVN0YXRlLndhbnRlZFRpbGVzIHNvIHRoYXQgdGhleSBhcmUgbm90XG4gICAqICAgZGlzY2FyZGVkIGJ5IHRoZSB0aWxlIHF1ZXVlXG4gICAqIC0gZW5xdWV1ZXMgbWlzc2luZyB0aWxlc1xuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL01hcC5qc1wiKS5GcmFtZVN0YXRlfSBmcmFtZVN0YXRlIEZyYW1lIHN0YXRlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL3NvdXJjZS9UaWxlLmpzXCIpLmRlZmF1bHR9IHRpbGVTb3VyY2UgVGlsZSBzb3VyY2UuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vdGlsZWdyaWQvVGlsZUdyaWQuanNcIikuZGVmYXVsdH0gdGlsZUdyaWQgVGlsZSBncmlkLlxuICAgKiBAcGFyYW0ge251bWJlcn0gcGl4ZWxSYXRpbyBQaXhlbCByYXRpby5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9wcm9qL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdH0gcHJvamVjdGlvbiBQcm9qZWN0aW9uLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjdXJyZW50WiBDdXJyZW50IFouXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwcmVsb2FkIExvYWQgbG93IHJlc29sdXRpb24gdGlsZXMgdXAgdG8gYHByZWxvYWRgIGxldmVscy5cbiAgICogQHBhcmFtIHtmdW5jdGlvbihpbXBvcnQoXCIuLi8uLi9UaWxlLmpzXCIpLmRlZmF1bHQpOnZvaWR9IFt0aWxlQ2FsbGJhY2tdIFRpbGUgY2FsbGJhY2suXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIG1hbmFnZVRpbGVQeXJhbWlkKFxuICAgIGZyYW1lU3RhdGUsXG4gICAgdGlsZVNvdXJjZSxcbiAgICB0aWxlR3JpZCxcbiAgICBwaXhlbFJhdGlvLFxuICAgIHByb2plY3Rpb24sXG4gICAgZXh0ZW50LFxuICAgIGN1cnJlbnRaLFxuICAgIHByZWxvYWQsXG4gICAgdGlsZUNhbGxiYWNrXG4gICkge1xuICAgIGNvbnN0IHRpbGVTb3VyY2VLZXkgPSBnZXRVaWQodGlsZVNvdXJjZSk7XG4gICAgaWYgKCEodGlsZVNvdXJjZUtleSBpbiBmcmFtZVN0YXRlLndhbnRlZFRpbGVzKSkge1xuICAgICAgZnJhbWVTdGF0ZS53YW50ZWRUaWxlc1t0aWxlU291cmNlS2V5XSA9IHt9O1xuICAgIH1cbiAgICBjb25zdCB3YW50ZWRUaWxlcyA9IGZyYW1lU3RhdGUud2FudGVkVGlsZXNbdGlsZVNvdXJjZUtleV07XG4gICAgY29uc3QgdGlsZVF1ZXVlID0gZnJhbWVTdGF0ZS50aWxlUXVldWU7XG4gICAgY29uc3QgbWluWm9vbSA9IHRpbGVHcmlkLmdldE1pblpvb20oKTtcbiAgICBjb25zdCByb3RhdGlvbiA9IGZyYW1lU3RhdGUudmlld1N0YXRlLnJvdGF0aW9uO1xuICAgIGNvbnN0IHZpZXdwb3J0ID0gcm90YXRpb25cbiAgICAgID8gZ2V0Um90YXRlZFZpZXdwb3J0KFxuICAgICAgICAgIGZyYW1lU3RhdGUudmlld1N0YXRlLmNlbnRlcixcbiAgICAgICAgICBmcmFtZVN0YXRlLnZpZXdTdGF0ZS5yZXNvbHV0aW9uLFxuICAgICAgICAgIHJvdGF0aW9uLFxuICAgICAgICAgIGZyYW1lU3RhdGUuc2l6ZVxuICAgICAgICApXG4gICAgICA6IHVuZGVmaW5lZDtcbiAgICBsZXQgdGlsZUNvdW50ID0gMDtcbiAgICBsZXQgdGlsZSwgdGlsZVJhbmdlLCB0aWxlUmVzb2x1dGlvbiwgeCwgeSwgejtcbiAgICBmb3IgKHogPSBtaW5ab29tOyB6IDw9IGN1cnJlbnRaOyArK3opIHtcbiAgICAgIHRpbGVSYW5nZSA9IHRpbGVHcmlkLmdldFRpbGVSYW5nZUZvckV4dGVudEFuZFooZXh0ZW50LCB6LCB0aWxlUmFuZ2UpO1xuICAgICAgdGlsZVJlc29sdXRpb24gPSB0aWxlR3JpZC5nZXRSZXNvbHV0aW9uKHopO1xuICAgICAgZm9yICh4ID0gdGlsZVJhbmdlLm1pblg7IHggPD0gdGlsZVJhbmdlLm1heFg7ICsreCkge1xuICAgICAgICBmb3IgKHkgPSB0aWxlUmFuZ2UubWluWTsgeSA8PSB0aWxlUmFuZ2UubWF4WTsgKyt5KSB7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgcm90YXRpb24gJiZcbiAgICAgICAgICAgICF0aWxlR3JpZC50aWxlQ29vcmRJbnRlcnNlY3RzVmlld3BvcnQoW3osIHgsIHldLCB2aWV3cG9ydClcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY3VycmVudFogLSB6IDw9IHByZWxvYWQpIHtcbiAgICAgICAgICAgICsrdGlsZUNvdW50O1xuICAgICAgICAgICAgdGlsZSA9IHRpbGVTb3VyY2UuZ2V0VGlsZSh6LCB4LCB5LCBwaXhlbFJhdGlvLCBwcm9qZWN0aW9uKTtcbiAgICAgICAgICAgIGlmICh0aWxlLmdldFN0YXRlKCkgPT0gVGlsZVN0YXRlLklETEUpIHtcbiAgICAgICAgICAgICAgd2FudGVkVGlsZXNbdGlsZS5nZXRLZXkoKV0gPSB0cnVlO1xuICAgICAgICAgICAgICBpZiAoIXRpbGVRdWV1ZS5pc0tleVF1ZXVlZCh0aWxlLmdldEtleSgpKSkge1xuICAgICAgICAgICAgICAgIHRpbGVRdWV1ZS5lbnF1ZXVlKFtcbiAgICAgICAgICAgICAgICAgIHRpbGUsXG4gICAgICAgICAgICAgICAgICB0aWxlU291cmNlS2V5LFxuICAgICAgICAgICAgICAgICAgdGlsZUdyaWQuZ2V0VGlsZUNvb3JkQ2VudGVyKHRpbGUudGlsZUNvb3JkKSxcbiAgICAgICAgICAgICAgICAgIHRpbGVSZXNvbHV0aW9uLFxuICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGlsZUNhbGxiYWNrICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgdGlsZUNhbGxiYWNrKHRpbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aWxlU291cmNlLnVzZVRpbGUoeiwgeCwgeSwgcHJvamVjdGlvbik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRpbGVTb3VyY2UudXBkYXRlQ2FjaGVTaXplKHRpbGVDb3VudCwgcHJvamVjdGlvbik7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQ2FudmFzVGlsZUxheWVyUmVuZGVyZXI7XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvcmVuZGVyZXIvY2FudmFzL1ZlY3RvckxheWVyXG4gKi9cbmltcG9ydCBDYW52YXNCdWlsZGVyR3JvdXAgZnJvbSAnLi4vLi4vcmVuZGVyL2NhbnZhcy9CdWlsZGVyR3JvdXAuanMnO1xuaW1wb3J0IENhbnZhc0xheWVyUmVuZGVyZXIsIHtjYW52YXNQb29sfSBmcm9tICcuL0xheWVyLmpzJztcbmltcG9ydCBFeGVjdXRvckdyb3VwIGZyb20gJy4uLy4uL3JlbmRlci9jYW52YXMvRXhlY3V0b3JHcm91cC5qcyc7XG5pbXBvcnQgUmVuZGVyRXZlbnRUeXBlIGZyb20gJy4uLy4uL3JlbmRlci9FdmVudFR5cGUuanMnO1xuaW1wb3J0IFZpZXdIaW50IGZyb20gJy4uLy4uL1ZpZXdIaW50LmpzJztcbmltcG9ydCB7XG4gIEhJVF9ERVRFQ1RfUkVTT0xVVElPTixcbiAgY3JlYXRlSGl0RGV0ZWN0aW9uSW1hZ2VEYXRhLFxuICBoaXREZXRlY3QsXG59IGZyb20gJy4uLy4uL3JlbmRlci9jYW52YXMvaGl0ZGV0ZWN0LmpzJztcbmltcG9ydCB7XG4gIGFwcGx5LFxuICBtYWtlSW52ZXJzZSxcbiAgbWFrZVNjYWxlLFxuICB0b1N0cmluZyBhcyB0cmFuc2Zvcm1Ub1N0cmluZyxcbn0gZnJvbSAnLi4vLi4vdHJhbnNmb3JtLmpzJztcbmltcG9ydCB7XG4gIGJ1ZmZlcixcbiAgY29udGFpbnNFeHRlbnQsXG4gIGNyZWF0ZUVtcHR5LFxuICBnZXRXaWR0aCxcbiAgaW50ZXJzZWN0cyBhcyBpbnRlcnNlY3RzRXh0ZW50LFxuICB3cmFwWCBhcyB3cmFwRXh0ZW50WCxcbn0gZnJvbSAnLi4vLi4vZXh0ZW50LmpzJztcbmltcG9ydCB7Y3JlYXRlQ2FudmFzQ29udGV4dDJELCByZWxlYXNlQ2FudmFzfSBmcm9tICcuLi8uLi9kb20uanMnO1xuaW1wb3J0IHtcbiAgZGVmYXVsdE9yZGVyIGFzIGRlZmF1bHRSZW5kZXJPcmRlcixcbiAgZ2V0VG9sZXJhbmNlIGFzIGdldFJlbmRlclRvbGVyYW5jZSxcbiAgZ2V0U3F1YXJlZFRvbGVyYW5jZSBhcyBnZXRTcXVhcmVkUmVuZGVyVG9sZXJhbmNlLFxuICByZW5kZXJGZWF0dXJlLFxufSBmcm9tICcuLi92ZWN0b3IuanMnO1xuaW1wb3J0IHtlcXVhbHN9IGZyb20gJy4uLy4uL2FycmF5LmpzJztcbmltcG9ydCB7XG4gIGZyb21Vc2VyRXh0ZW50LFxuICBnZXRUcmFuc2Zvcm1Gcm9tUHJvamVjdGlvbnMsXG4gIGdldFVzZXJQcm9qZWN0aW9uLFxuICB0b1VzZXJFeHRlbnQsXG4gIHRvVXNlclJlc29sdXRpb24sXG59IGZyb20gJy4uLy4uL3Byb2ouanMnO1xuaW1wb3J0IHtnZXRVaWR9IGZyb20gJy4uLy4uL3V0aWwuanMnO1xuaW1wb3J0IHt3cmFwWCBhcyB3cmFwQ29vcmRpbmF0ZVh9IGZyb20gJy4uLy4uL2Nvb3JkaW5hdGUuanMnO1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIENhbnZhcyByZW5kZXJlciBmb3IgdmVjdG9yIGxheWVycy5cbiAqIEBhcGlcbiAqL1xuY2xhc3MgQ2FudmFzVmVjdG9yTGF5ZXJSZW5kZXJlciBleHRlbmRzIENhbnZhc0xheWVyUmVuZGVyZXIge1xuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9sYXllci9CYXNlVmVjdG9yLmpzXCIpLmRlZmF1bHR9IHZlY3RvckxheWVyIFZlY3RvciBsYXllci5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHZlY3RvckxheWVyKSB7XG4gICAgc3VwZXIodmVjdG9yTGF5ZXIpO1xuXG4gICAgLyoqIEBwcml2YXRlICovXG4gICAgdGhpcy5ib3VuZEhhbmRsZVN0eWxlSW1hZ2VDaGFuZ2VfID0gdGhpcy5oYW5kbGVTdHlsZUltYWdlQ2hhbmdlXy5iaW5kKHRoaXMpO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5hbmltYXRpbmdPckludGVyYWN0aW5nXztcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtJbWFnZURhdGF8bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLmhpdERldGVjdGlvbkltYWdlRGF0YV8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge0FycmF5PGltcG9ydChcIi4uLy4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdD59XG4gICAgICovXG4gICAgdGhpcy5yZW5kZXJlZEZlYXR1cmVzXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5yZW5kZXJlZFJldmlzaW9uXyA9IC0xO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucmVuZGVyZWRSZXNvbHV0aW9uXyA9IE5hTjtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uLy4uL2V4dGVudC5qc1wiKS5FeHRlbnR9XG4gICAgICovXG4gICAgdGhpcy5yZW5kZXJlZEV4dGVudF8gPSBjcmVhdGVFbXB0eSgpO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vZXh0ZW50LmpzXCIpLkV4dGVudH1cbiAgICAgKi9cbiAgICB0aGlzLndyYXBwZWRSZW5kZXJlZEV4dGVudF8gPSBjcmVhdGVFbXB0eSgpO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucmVuZGVyZWRSb3RhdGlvbl87XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi9jb29yZGluYXRlXCIpLkNvb3JkaW5hdGV9XG4gICAgICovXG4gICAgdGhpcy5yZW5kZXJlZENlbnRlcl8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vcHJvai9Qcm9qZWN0aW9uXCIpLmRlZmF1bHR9XG4gICAgICovXG4gICAgdGhpcy5yZW5kZXJlZFByb2plY3Rpb25fID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2Z1bmN0aW9uKGltcG9ydChcIi4uLy4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdCwgaW1wb3J0KFwiLi4vLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0KTogbnVtYmVyfG51bGx9XG4gICAgICovXG4gICAgdGhpcy5yZW5kZXJlZFJlbmRlck9yZGVyXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi9yZW5kZXIvY2FudmFzL0V4ZWN1dG9yR3JvdXBcIikuZGVmYXVsdH1cbiAgICAgKi9cbiAgICB0aGlzLnJlcGxheUdyb3VwXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBBIG5ldyByZXBsYXkgZ3JvdXAgaGFkIHRvIGJlIGNyZWF0ZWQgYnkgYHByZXBhcmVGcmFtZSgpYFxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMucmVwbGF5R3JvdXBDaGFuZ2VkID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi9yZW5kZXIvY2FudmFzL0V4ZWN1dG9yR3JvdXBcIikuZGVmYXVsdH1cbiAgICAgKi9cbiAgICB0aGlzLmRlY2x1dHRlckV4ZWN1dG9yR3JvdXAgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQ2xpcHBpbmcgdG8gYmUgcGVyZm9ybWVkIGJ5IGByZW5kZXJGcmFtZSgpYFxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuY2xpcHBpbmcgPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfVxuICAgICAqL1xuICAgIHRoaXMuY29tcG9zaXRpb25Db250ZXh0XyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5vcGFjaXR5XyA9IDE7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtFeGVjdXRvckdyb3VwfSBleGVjdXRvckdyb3VwIEV4ZWN1dG9yIGdyb3VwLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL01hcC5qc1wiKS5GcmFtZVN0YXRlfSBmcmFtZVN0YXRlIEZyYW1lIHN0YXRlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcInJidXNoXCIpLmRlZmF1bHR9IFtkZWNsdXR0ZXJUcmVlXSBEZWNsdXR0ZXIgdHJlZS5cbiAgICovXG4gIHJlbmRlcldvcmxkcyhleGVjdXRvckdyb3VwLCBmcmFtZVN0YXRlLCBkZWNsdXR0ZXJUcmVlKSB7XG4gICAgY29uc3QgZXh0ZW50ID0gZnJhbWVTdGF0ZS5leHRlbnQ7XG4gICAgY29uc3Qgdmlld1N0YXRlID0gZnJhbWVTdGF0ZS52aWV3U3RhdGU7XG4gICAgY29uc3QgY2VudGVyID0gdmlld1N0YXRlLmNlbnRlcjtcbiAgICBjb25zdCByZXNvbHV0aW9uID0gdmlld1N0YXRlLnJlc29sdXRpb247XG4gICAgY29uc3QgcHJvamVjdGlvbiA9IHZpZXdTdGF0ZS5wcm9qZWN0aW9uO1xuICAgIGNvbnN0IHJvdGF0aW9uID0gdmlld1N0YXRlLnJvdGF0aW9uO1xuICAgIGNvbnN0IHByb2plY3Rpb25FeHRlbnQgPSBwcm9qZWN0aW9uLmdldEV4dGVudCgpO1xuICAgIGNvbnN0IHZlY3RvclNvdXJjZSA9IHRoaXMuZ2V0TGF5ZXIoKS5nZXRTb3VyY2UoKTtcbiAgICBjb25zdCBwaXhlbFJhdGlvID0gZnJhbWVTdGF0ZS5waXhlbFJhdGlvO1xuICAgIGNvbnN0IHZpZXdIaW50cyA9IGZyYW1lU3RhdGUudmlld0hpbnRzO1xuICAgIGNvbnN0IHNuYXBUb1BpeGVsID0gIShcbiAgICAgIHZpZXdIaW50c1tWaWV3SGludC5BTklNQVRJTkddIHx8IHZpZXdIaW50c1tWaWV3SGludC5JTlRFUkFDVElOR11cbiAgICApO1xuICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLmNvbXBvc2l0aW9uQ29udGV4dF87XG4gICAgY29uc3Qgd2lkdGggPSBNYXRoLnJvdW5kKGZyYW1lU3RhdGUuc2l6ZVswXSAqIHBpeGVsUmF0aW8pO1xuICAgIGNvbnN0IGhlaWdodCA9IE1hdGgucm91bmQoZnJhbWVTdGF0ZS5zaXplWzFdICogcGl4ZWxSYXRpbyk7XG5cbiAgICBjb25zdCBtdWx0aVdvcmxkID0gdmVjdG9yU291cmNlLmdldFdyYXBYKCkgJiYgcHJvamVjdGlvbi5jYW5XcmFwWCgpO1xuICAgIGNvbnN0IHdvcmxkV2lkdGggPSBtdWx0aVdvcmxkID8gZ2V0V2lkdGgocHJvamVjdGlvbkV4dGVudCkgOiBudWxsO1xuICAgIGNvbnN0IGVuZFdvcmxkID0gbXVsdGlXb3JsZFxuICAgICAgPyBNYXRoLmNlaWwoKGV4dGVudFsyXSAtIHByb2plY3Rpb25FeHRlbnRbMl0pIC8gd29ybGRXaWR0aCkgKyAxXG4gICAgICA6IDE7XG4gICAgbGV0IHdvcmxkID0gbXVsdGlXb3JsZFxuICAgICAgPyBNYXRoLmZsb29yKChleHRlbnRbMF0gLSBwcm9qZWN0aW9uRXh0ZW50WzBdKSAvIHdvcmxkV2lkdGgpXG4gICAgICA6IDA7XG4gICAgZG8ge1xuICAgICAgY29uc3QgdHJhbnNmb3JtID0gdGhpcy5nZXRSZW5kZXJUcmFuc2Zvcm0oXG4gICAgICAgIGNlbnRlcixcbiAgICAgICAgcmVzb2x1dGlvbixcbiAgICAgICAgcm90YXRpb24sXG4gICAgICAgIHBpeGVsUmF0aW8sXG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHQsXG4gICAgICAgIHdvcmxkICogd29ybGRXaWR0aFxuICAgICAgKTtcbiAgICAgIGV4ZWN1dG9yR3JvdXAuZXhlY3V0ZShcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgMSxcbiAgICAgICAgdHJhbnNmb3JtLFxuICAgICAgICByb3RhdGlvbixcbiAgICAgICAgc25hcFRvUGl4ZWwsXG4gICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgZGVjbHV0dGVyVHJlZVxuICAgICAgKTtcbiAgICB9IHdoaWxlICgrK3dvcmxkIDwgZW5kV29ybGQpO1xuICB9XG5cbiAgc2V0dXBDb21wb3NpdGlvbkNvbnRleHRfKCkge1xuICAgIGlmICh0aGlzLm9wYWNpdHlfICE9PSAxKSB7XG4gICAgICBjb25zdCBjb21wb3NpdGlvbkNvbnRleHQgPSBjcmVhdGVDYW52YXNDb250ZXh0MkQoXG4gICAgICAgIHRoaXMuY29udGV4dC5jYW52YXMud2lkdGgsXG4gICAgICAgIHRoaXMuY29udGV4dC5jYW52YXMuaGVpZ2h0LFxuICAgICAgICBjYW52YXNQb29sXG4gICAgICApO1xuICAgICAgdGhpcy5jb21wb3NpdGlvbkNvbnRleHRfID0gY29tcG9zaXRpb25Db250ZXh0O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNvbXBvc2l0aW9uQ29udGV4dF8gPSB0aGlzLmNvbnRleHQ7XG4gICAgfVxuICB9XG5cbiAgcmVsZWFzZUNvbXBvc2l0aW9uQ29udGV4dF8oKSB7XG4gICAgaWYgKHRoaXMub3BhY2l0eV8gIT09IDEpIHtcbiAgICAgIGNvbnN0IGFscGhhID0gdGhpcy5jb250ZXh0Lmdsb2JhbEFscGhhO1xuICAgICAgdGhpcy5jb250ZXh0Lmdsb2JhbEFscGhhID0gdGhpcy5vcGFjaXR5XztcbiAgICAgIHRoaXMuY29udGV4dC5kcmF3SW1hZ2UodGhpcy5jb21wb3NpdGlvbkNvbnRleHRfLmNhbnZhcywgMCwgMCk7XG4gICAgICB0aGlzLmNvbnRleHQuZ2xvYmFsQWxwaGEgPSBhbHBoYTtcbiAgICAgIHJlbGVhc2VDYW52YXModGhpcy5jb21wb3NpdGlvbkNvbnRleHRfKTtcbiAgICAgIGNhbnZhc1Bvb2wucHVzaCh0aGlzLmNvbXBvc2l0aW9uQ29udGV4dF8uY2FudmFzKTtcbiAgICAgIHRoaXMuY29tcG9zaXRpb25Db250ZXh0XyA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlciBkZWNsdXR0ZXIgaXRlbXMgZm9yIHRoaXMgbGF5ZXJcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9NYXAuanNcIikuRnJhbWVTdGF0ZX0gZnJhbWVTdGF0ZSBGcmFtZSBzdGF0ZS5cbiAgICovXG4gIHJlbmRlckRlY2x1dHRlcihmcmFtZVN0YXRlKSB7XG4gICAgaWYgKHRoaXMuZGVjbHV0dGVyRXhlY3V0b3JHcm91cCkge1xuICAgICAgdGhpcy5zZXR1cENvbXBvc2l0aW9uQ29udGV4dF8oKTtcbiAgICAgIHRoaXMucmVuZGVyV29ybGRzKFxuICAgICAgICB0aGlzLmRlY2x1dHRlckV4ZWN1dG9yR3JvdXAsXG4gICAgICAgIGZyYW1lU3RhdGUsXG4gICAgICAgIGZyYW1lU3RhdGUuZGVjbHV0dGVyVHJlZVxuICAgICAgKTtcbiAgICAgIHRoaXMucmVsZWFzZUNvbXBvc2l0aW9uQ29udGV4dF8oKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVyIHRoZSBsYXllci5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9NYXAuanNcIikuRnJhbWVTdGF0ZX0gZnJhbWVTdGF0ZSBGcmFtZSBzdGF0ZS5cbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudHxudWxsfSB0YXJnZXQgVGFyZ2V0IHRoYXQgbWF5IGJlIHVzZWQgdG8gcmVuZGVyIGNvbnRlbnQgdG8uXG4gICAqIEByZXR1cm4ge0hUTUxFbGVtZW50fG51bGx9IFRoZSByZW5kZXJlZCBlbGVtZW50LlxuICAgKi9cbiAgcmVuZGVyRnJhbWUoZnJhbWVTdGF0ZSwgdGFyZ2V0KSB7XG4gICAgY29uc3QgcGl4ZWxSYXRpbyA9IGZyYW1lU3RhdGUucGl4ZWxSYXRpbztcbiAgICBjb25zdCBsYXllclN0YXRlID0gZnJhbWVTdGF0ZS5sYXllclN0YXRlc0FycmF5W2ZyYW1lU3RhdGUubGF5ZXJJbmRleF07XG5cbiAgICAvLyBzZXQgZm9yd2FyZCBhbmQgaW52ZXJzZSBwaXhlbCB0cmFuc2Zvcm1zXG4gICAgbWFrZVNjYWxlKHRoaXMucGl4ZWxUcmFuc2Zvcm0sIDEgLyBwaXhlbFJhdGlvLCAxIC8gcGl4ZWxSYXRpbyk7XG4gICAgbWFrZUludmVyc2UodGhpcy5pbnZlcnNlUGl4ZWxUcmFuc2Zvcm0sIHRoaXMucGl4ZWxUcmFuc2Zvcm0pO1xuXG4gICAgY29uc3QgY2FudmFzVHJhbnNmb3JtID0gdHJhbnNmb3JtVG9TdHJpbmcodGhpcy5waXhlbFRyYW5zZm9ybSk7XG5cbiAgICB0aGlzLnVzZUNvbnRhaW5lcih0YXJnZXQsIGNhbnZhc1RyYW5zZm9ybSwgdGhpcy5nZXRCYWNrZ3JvdW5kKGZyYW1lU3RhdGUpKTtcbiAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5jb250ZXh0O1xuICAgIGNvbnN0IGNhbnZhcyA9IGNvbnRleHQuY2FudmFzO1xuXG4gICAgY29uc3QgcmVwbGF5R3JvdXAgPSB0aGlzLnJlcGxheUdyb3VwXztcbiAgICBjb25zdCBkZWNsdXR0ZXJFeGVjdXRvckdyb3VwID0gdGhpcy5kZWNsdXR0ZXJFeGVjdXRvckdyb3VwO1xuICAgIGxldCByZW5kZXIgPVxuICAgICAgKHJlcGxheUdyb3VwICYmICFyZXBsYXlHcm91cC5pc0VtcHR5KCkpIHx8XG4gICAgICAoZGVjbHV0dGVyRXhlY3V0b3JHcm91cCAmJiAhZGVjbHV0dGVyRXhlY3V0b3JHcm91cC5pc0VtcHR5KCkpO1xuICAgIGlmICghcmVuZGVyKSB7XG4gICAgICBjb25zdCBoYXNSZW5kZXJMaXN0ZW5lcnMgPVxuICAgICAgICB0aGlzLmdldExheWVyKCkuaGFzTGlzdGVuZXIoUmVuZGVyRXZlbnRUeXBlLlBSRVJFTkRFUikgfHxcbiAgICAgICAgdGhpcy5nZXRMYXllcigpLmhhc0xpc3RlbmVyKFJlbmRlckV2ZW50VHlwZS5QT1NUUkVOREVSKTtcbiAgICAgIGlmICghaGFzUmVuZGVyTGlzdGVuZXJzKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHJlc2l6ZSBhbmQgY2xlYXJcbiAgICBjb25zdCB3aWR0aCA9IE1hdGgucm91bmQoZnJhbWVTdGF0ZS5zaXplWzBdICogcGl4ZWxSYXRpbyk7XG4gICAgY29uc3QgaGVpZ2h0ID0gTWF0aC5yb3VuZChmcmFtZVN0YXRlLnNpemVbMV0gKiBwaXhlbFJhdGlvKTtcbiAgICBpZiAoY2FudmFzLndpZHRoICE9IHdpZHRoIHx8IGNhbnZhcy5oZWlnaHQgIT0gaGVpZ2h0KSB7XG4gICAgICBjYW52YXMud2lkdGggPSB3aWR0aDtcbiAgICAgIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICBpZiAoY2FudmFzLnN0eWxlLnRyYW5zZm9ybSAhPT0gY2FudmFzVHJhbnNmb3JtKSB7XG4gICAgICAgIGNhbnZhcy5zdHlsZS50cmFuc2Zvcm0gPSBjYW52YXNUcmFuc2Zvcm07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghdGhpcy5jb250YWluZXJSZXVzZWQpIHtcbiAgICAgIGNvbnRleHQuY2xlYXJSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgIH1cblxuICAgIHRoaXMucHJlUmVuZGVyKGNvbnRleHQsIGZyYW1lU3RhdGUpO1xuXG4gICAgY29uc3Qgdmlld1N0YXRlID0gZnJhbWVTdGF0ZS52aWV3U3RhdGU7XG4gICAgY29uc3QgcHJvamVjdGlvbiA9IHZpZXdTdGF0ZS5wcm9qZWN0aW9uO1xuXG4gICAgdGhpcy5vcGFjaXR5XyA9IGxheWVyU3RhdGUub3BhY2l0eTtcbiAgICB0aGlzLnNldHVwQ29tcG9zaXRpb25Db250ZXh0XygpO1xuXG4gICAgLy8gY2xpcHBlZCByZW5kZXJpbmcgaWYgbGF5ZXIgZXh0ZW50IGlzIHNldFxuICAgIGxldCBjbGlwcGVkID0gZmFsc2U7XG4gICAgaWYgKHJlbmRlciAmJiBsYXllclN0YXRlLmV4dGVudCAmJiB0aGlzLmNsaXBwaW5nKSB7XG4gICAgICBjb25zdCBsYXllckV4dGVudCA9IGZyb21Vc2VyRXh0ZW50KGxheWVyU3RhdGUuZXh0ZW50LCBwcm9qZWN0aW9uKTtcbiAgICAgIHJlbmRlciA9IGludGVyc2VjdHNFeHRlbnQobGF5ZXJFeHRlbnQsIGZyYW1lU3RhdGUuZXh0ZW50KTtcbiAgICAgIGNsaXBwZWQgPSByZW5kZXIgJiYgIWNvbnRhaW5zRXh0ZW50KGxheWVyRXh0ZW50LCBmcmFtZVN0YXRlLmV4dGVudCk7XG4gICAgICBpZiAoY2xpcHBlZCkge1xuICAgICAgICB0aGlzLmNsaXBVbnJvdGF0ZWQodGhpcy5jb21wb3NpdGlvbkNvbnRleHRfLCBmcmFtZVN0YXRlLCBsYXllckV4dGVudCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHJlbmRlcikge1xuICAgICAgdGhpcy5yZW5kZXJXb3JsZHMocmVwbGF5R3JvdXAsIGZyYW1lU3RhdGUpO1xuICAgIH1cblxuICAgIGlmIChjbGlwcGVkKSB7XG4gICAgICB0aGlzLmNvbXBvc2l0aW9uQ29udGV4dF8ucmVzdG9yZSgpO1xuICAgIH1cblxuICAgIHRoaXMucmVsZWFzZUNvbXBvc2l0aW9uQ29udGV4dF8oKTtcblxuICAgIHRoaXMucG9zdFJlbmRlcihjb250ZXh0LCBmcmFtZVN0YXRlKTtcblxuICAgIGlmICh0aGlzLnJlbmRlcmVkUm90YXRpb25fICE9PSB2aWV3U3RhdGUucm90YXRpb24pIHtcbiAgICAgIHRoaXMucmVuZGVyZWRSb3RhdGlvbl8gPSB2aWV3U3RhdGUucm90YXRpb247XG4gICAgICB0aGlzLmhpdERldGVjdGlvbkltYWdlRGF0YV8gPSBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cblxuICAvKipcbiAgICogQXN5bmNocm9ub3VzIGxheWVyIGxldmVsIGhpdCBkZXRlY3Rpb24uXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vcGl4ZWwuanNcIikuUGl4ZWx9IHBpeGVsIFBpeGVsLlxuICAgKiBAcmV0dXJuIHtQcm9taXNlPEFycmF5PGltcG9ydChcIi4uLy4uL0ZlYXR1cmVcIikuZGVmYXVsdD4+fSBQcm9taXNlXG4gICAqIHRoYXQgcmVzb2x2ZXMgd2l0aCBhbiBhcnJheSBvZiBmZWF0dXJlcy5cbiAgICovXG4gIGdldEZlYXR1cmVzKHBpeGVsKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICBpZiAoIXRoaXMuaGl0RGV0ZWN0aW9uSW1hZ2VEYXRhXyAmJiAhdGhpcy5hbmltYXRpbmdPckludGVyYWN0aW5nXykge1xuICAgICAgICBjb25zdCBzaXplID0gW3RoaXMuY29udGV4dC5jYW52YXMud2lkdGgsIHRoaXMuY29udGV4dC5jYW52YXMuaGVpZ2h0XTtcbiAgICAgICAgYXBwbHkodGhpcy5waXhlbFRyYW5zZm9ybSwgc2l6ZSk7XG4gICAgICAgIGNvbnN0IGNlbnRlciA9IHRoaXMucmVuZGVyZWRDZW50ZXJfO1xuICAgICAgICBjb25zdCByZXNvbHV0aW9uID0gdGhpcy5yZW5kZXJlZFJlc29sdXRpb25fO1xuICAgICAgICBjb25zdCByb3RhdGlvbiA9IHRoaXMucmVuZGVyZWRSb3RhdGlvbl87XG4gICAgICAgIGNvbnN0IHByb2plY3Rpb24gPSB0aGlzLnJlbmRlcmVkUHJvamVjdGlvbl87XG4gICAgICAgIGNvbnN0IGV4dGVudCA9IHRoaXMud3JhcHBlZFJlbmRlcmVkRXh0ZW50XztcbiAgICAgICAgY29uc3QgbGF5ZXIgPSB0aGlzLmdldExheWVyKCk7XG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybXMgPSBbXTtcbiAgICAgICAgY29uc3Qgd2lkdGggPSBzaXplWzBdICogSElUX0RFVEVDVF9SRVNPTFVUSU9OO1xuICAgICAgICBjb25zdCBoZWlnaHQgPSBzaXplWzFdICogSElUX0RFVEVDVF9SRVNPTFVUSU9OO1xuICAgICAgICB0cmFuc2Zvcm1zLnB1c2goXG4gICAgICAgICAgdGhpcy5nZXRSZW5kZXJUcmFuc2Zvcm0oXG4gICAgICAgICAgICBjZW50ZXIsXG4gICAgICAgICAgICByZXNvbHV0aW9uLFxuICAgICAgICAgICAgcm90YXRpb24sXG4gICAgICAgICAgICBISVRfREVURUNUX1JFU09MVVRJT04sXG4gICAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICAgIGhlaWdodCxcbiAgICAgICAgICAgIDBcbiAgICAgICAgICApLnNsaWNlKClcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3Qgc291cmNlID0gbGF5ZXIuZ2V0U291cmNlKCk7XG4gICAgICAgIGNvbnN0IHByb2plY3Rpb25FeHRlbnQgPSBwcm9qZWN0aW9uLmdldEV4dGVudCgpO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgc291cmNlLmdldFdyYXBYKCkgJiZcbiAgICAgICAgICBwcm9qZWN0aW9uLmNhbldyYXBYKCkgJiZcbiAgICAgICAgICAhY29udGFpbnNFeHRlbnQocHJvamVjdGlvbkV4dGVudCwgZXh0ZW50KVxuICAgICAgICApIHtcbiAgICAgICAgICBsZXQgc3RhcnRYID0gZXh0ZW50WzBdO1xuICAgICAgICAgIGNvbnN0IHdvcmxkV2lkdGggPSBnZXRXaWR0aChwcm9qZWN0aW9uRXh0ZW50KTtcbiAgICAgICAgICBsZXQgd29ybGQgPSAwO1xuICAgICAgICAgIGxldCBvZmZzZXRYO1xuICAgICAgICAgIHdoaWxlIChzdGFydFggPCBwcm9qZWN0aW9uRXh0ZW50WzBdKSB7XG4gICAgICAgICAgICAtLXdvcmxkO1xuICAgICAgICAgICAgb2Zmc2V0WCA9IHdvcmxkV2lkdGggKiB3b3JsZDtcbiAgICAgICAgICAgIHRyYW5zZm9ybXMucHVzaChcbiAgICAgICAgICAgICAgdGhpcy5nZXRSZW5kZXJUcmFuc2Zvcm0oXG4gICAgICAgICAgICAgICAgY2VudGVyLFxuICAgICAgICAgICAgICAgIHJlc29sdXRpb24sXG4gICAgICAgICAgICAgICAgcm90YXRpb24sXG4gICAgICAgICAgICAgICAgSElUX0RFVEVDVF9SRVNPTFVUSU9OLFxuICAgICAgICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgICAgICAgIGhlaWdodCxcbiAgICAgICAgICAgICAgICBvZmZzZXRYXG4gICAgICAgICAgICAgICkuc2xpY2UoKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHN0YXJ0WCArPSB3b3JsZFdpZHRoO1xuICAgICAgICAgIH1cbiAgICAgICAgICB3b3JsZCA9IDA7XG4gICAgICAgICAgc3RhcnRYID0gZXh0ZW50WzJdO1xuICAgICAgICAgIHdoaWxlIChzdGFydFggPiBwcm9qZWN0aW9uRXh0ZW50WzJdKSB7XG4gICAgICAgICAgICArK3dvcmxkO1xuICAgICAgICAgICAgb2Zmc2V0WCA9IHdvcmxkV2lkdGggKiB3b3JsZDtcbiAgICAgICAgICAgIHRyYW5zZm9ybXMucHVzaChcbiAgICAgICAgICAgICAgdGhpcy5nZXRSZW5kZXJUcmFuc2Zvcm0oXG4gICAgICAgICAgICAgICAgY2VudGVyLFxuICAgICAgICAgICAgICAgIHJlc29sdXRpb24sXG4gICAgICAgICAgICAgICAgcm90YXRpb24sXG4gICAgICAgICAgICAgICAgSElUX0RFVEVDVF9SRVNPTFVUSU9OLFxuICAgICAgICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgICAgICAgIGhlaWdodCxcbiAgICAgICAgICAgICAgICBvZmZzZXRYXG4gICAgICAgICAgICAgICkuc2xpY2UoKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHN0YXJ0WCAtPSB3b3JsZFdpZHRoO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaGl0RGV0ZWN0aW9uSW1hZ2VEYXRhXyA9IGNyZWF0ZUhpdERldGVjdGlvbkltYWdlRGF0YShcbiAgICAgICAgICBzaXplLFxuICAgICAgICAgIHRyYW5zZm9ybXMsXG4gICAgICAgICAgdGhpcy5yZW5kZXJlZEZlYXR1cmVzXyxcbiAgICAgICAgICBsYXllci5nZXRTdHlsZUZ1bmN0aW9uKCksXG4gICAgICAgICAgZXh0ZW50LFxuICAgICAgICAgIHJlc29sdXRpb24sXG4gICAgICAgICAgcm90YXRpb25cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJlc29sdmUoXG4gICAgICAgIGhpdERldGVjdChwaXhlbCwgdGhpcy5yZW5kZXJlZEZlYXR1cmVzXywgdGhpcy5oaXREZXRlY3Rpb25JbWFnZURhdGFfKVxuICAgICAgKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gY29vcmRpbmF0ZSBDb29yZGluYXRlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL01hcC5qc1wiKS5GcmFtZVN0YXRlfSBmcmFtZVN0YXRlIEZyYW1lIHN0YXRlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gaGl0VG9sZXJhbmNlIEhpdCB0b2xlcmFuY2UgaW4gcGl4ZWxzLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3ZlY3Rvci5qc1wiKS5GZWF0dXJlQ2FsbGJhY2s8VD59IGNhbGxiYWNrIEZlYXR1cmUgY2FsbGJhY2suXG4gICAqIEBwYXJhbSB7QXJyYXk8aW1wb3J0KFwiLi4vTWFwLmpzXCIpLkhpdE1hdGNoPFQ+Pn0gbWF0Y2hlcyBUaGUgaGl0IGRldGVjdGVkIG1hdGNoZXMgd2l0aCB0b2xlcmFuY2UuXG4gICAqIEByZXR1cm4ge1R8dW5kZWZpbmVkfSBDYWxsYmFjayByZXN1bHQuXG4gICAqIEB0ZW1wbGF0ZSBUXG4gICAqL1xuICBmb3JFYWNoRmVhdHVyZUF0Q29vcmRpbmF0ZShcbiAgICBjb29yZGluYXRlLFxuICAgIGZyYW1lU3RhdGUsXG4gICAgaGl0VG9sZXJhbmNlLFxuICAgIGNhbGxiYWNrLFxuICAgIG1hdGNoZXNcbiAgKSB7XG4gICAgaWYgKCF0aGlzLnJlcGxheUdyb3VwXykge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY29uc3QgcmVzb2x1dGlvbiA9IGZyYW1lU3RhdGUudmlld1N0YXRlLnJlc29sdXRpb247XG4gICAgY29uc3Qgcm90YXRpb24gPSBmcmFtZVN0YXRlLnZpZXdTdGF0ZS5yb3RhdGlvbjtcbiAgICBjb25zdCBsYXllciA9IHRoaXMuZ2V0TGF5ZXIoKTtcblxuICAgIC8qKiBAdHlwZSB7IU9iamVjdDxzdHJpbmcsIGltcG9ydChcIi4uL01hcC5qc1wiKS5IaXRNYXRjaDxUPnx0cnVlPn0gKi9cbiAgICBjb25zdCBmZWF0dXJlcyA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9GZWF0dXJlLmpzXCIpLkZlYXR1cmVMaWtlfSBmZWF0dXJlIEZlYXR1cmUuXG4gICAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9nZW9tL1NpbXBsZUdlb21ldHJ5LmpzXCIpLmRlZmF1bHR9IGdlb21ldHJ5IEdlb21ldHJ5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkaXN0YW5jZVNxIFRoZSBzcXVhcmVkIGRpc3RhbmNlIHRvIHRoZSBjbGljayBwb3NpdGlvblxuICAgICAqIEByZXR1cm4ge1R8dW5kZWZpbmVkfSBDYWxsYmFjayByZXN1bHQuXG4gICAgICovXG4gICAgY29uc3QgZmVhdHVyZUNhbGxiYWNrID0gZnVuY3Rpb24gKGZlYXR1cmUsIGdlb21ldHJ5LCBkaXN0YW5jZVNxKSB7XG4gICAgICBjb25zdCBrZXkgPSBnZXRVaWQoZmVhdHVyZSk7XG4gICAgICBjb25zdCBtYXRjaCA9IGZlYXR1cmVzW2tleV07XG4gICAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgIGlmIChkaXN0YW5jZVNxID09PSAwKSB7XG4gICAgICAgICAgZmVhdHVyZXNba2V5XSA9IHRydWU7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGZlYXR1cmUsIGxheWVyLCBnZW9tZXRyeSk7XG4gICAgICAgIH1cbiAgICAgICAgbWF0Y2hlcy5wdXNoKFxuICAgICAgICAgIChmZWF0dXJlc1trZXldID0ge1xuICAgICAgICAgICAgZmVhdHVyZTogZmVhdHVyZSxcbiAgICAgICAgICAgIGxheWVyOiBsYXllcixcbiAgICAgICAgICAgIGdlb21ldHJ5OiBnZW9tZXRyeSxcbiAgICAgICAgICAgIGRpc3RhbmNlU3E6IGRpc3RhbmNlU3EsXG4gICAgICAgICAgICBjYWxsYmFjazogY2FsbGJhY2ssXG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSBpZiAobWF0Y2ggIT09IHRydWUgJiYgZGlzdGFuY2VTcSA8IG1hdGNoLmRpc3RhbmNlU3EpIHtcbiAgICAgICAgaWYgKGRpc3RhbmNlU3EgPT09IDApIHtcbiAgICAgICAgICBmZWF0dXJlc1trZXldID0gdHJ1ZTtcbiAgICAgICAgICBtYXRjaGVzLnNwbGljZShtYXRjaGVzLmxhc3RJbmRleE9mKG1hdGNoKSwgMSk7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGZlYXR1cmUsIGxheWVyLCBnZW9tZXRyeSk7XG4gICAgICAgIH1cbiAgICAgICAgbWF0Y2guZ2VvbWV0cnkgPSBnZW9tZXRyeTtcbiAgICAgICAgbWF0Y2guZGlzdGFuY2VTcSA9IGRpc3RhbmNlU3E7XG4gICAgICB9XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH07XG5cbiAgICBsZXQgcmVzdWx0O1xuICAgIGNvbnN0IGV4ZWN1dG9yR3JvdXBzID0gW3RoaXMucmVwbGF5R3JvdXBfXTtcbiAgICBpZiAodGhpcy5kZWNsdXR0ZXJFeGVjdXRvckdyb3VwKSB7XG4gICAgICBleGVjdXRvckdyb3Vwcy5wdXNoKHRoaXMuZGVjbHV0dGVyRXhlY3V0b3JHcm91cCk7XG4gICAgfVxuICAgIGV4ZWN1dG9yR3JvdXBzLnNvbWUoKGV4ZWN1dG9yR3JvdXApID0+IHtcbiAgICAgIHJldHVybiAocmVzdWx0ID0gZXhlY3V0b3JHcm91cC5mb3JFYWNoRmVhdHVyZUF0Q29vcmRpbmF0ZShcbiAgICAgICAgY29vcmRpbmF0ZSxcbiAgICAgICAgcmVzb2x1dGlvbixcbiAgICAgICAgcm90YXRpb24sXG4gICAgICAgIGhpdFRvbGVyYW5jZSxcbiAgICAgICAgZmVhdHVyZUNhbGxiYWNrLFxuICAgICAgICBleGVjdXRvckdyb3VwID09PSB0aGlzLmRlY2x1dHRlckV4ZWN1dG9yR3JvdXAgJiZcbiAgICAgICAgICBmcmFtZVN0YXRlLmRlY2x1dHRlclRyZWVcbiAgICAgICAgICA/IGZyYW1lU3RhdGUuZGVjbHV0dGVyVHJlZS5hbGwoKS5tYXAoKGl0ZW0pID0+IGl0ZW0udmFsdWUpXG4gICAgICAgICAgOiBudWxsXG4gICAgICApKTtcbiAgICB9KTtcblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogUGVyZm9ybSBhY3Rpb24gbmVjZXNzYXJ5IHRvIGdldCB0aGUgbGF5ZXIgcmVuZGVyZWQgYWZ0ZXIgbmV3IGZvbnRzIGhhdmUgbG9hZGVkXG4gICAqL1xuICBoYW5kbGVGb250c0NoYW5nZWQoKSB7XG4gICAgY29uc3QgbGF5ZXIgPSB0aGlzLmdldExheWVyKCk7XG4gICAgaWYgKGxheWVyLmdldFZpc2libGUoKSAmJiB0aGlzLnJlcGxheUdyb3VwXykge1xuICAgICAgbGF5ZXIuY2hhbmdlZCgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgY2hhbmdlcyBpbiBpbWFnZSBzdHlsZSBzdGF0ZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9ldmVudHMvRXZlbnQuanNcIikuZGVmYXVsdH0gZXZlbnQgSW1hZ2Ugc3R5bGUgY2hhbmdlIGV2ZW50LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaGFuZGxlU3R5bGVJbWFnZUNoYW5nZV8oZXZlbnQpIHtcbiAgICB0aGlzLnJlbmRlcklmUmVhZHlBbmRWaXNpYmxlKCk7XG4gIH1cblxuICAvKipcbiAgICogRGV0ZXJtaW5lIHdoZXRoZXIgcmVuZGVyIHNob3VsZCBiZSBjYWxsZWQuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vTWFwLmpzXCIpLkZyYW1lU3RhdGV9IGZyYW1lU3RhdGUgRnJhbWUgc3RhdGUuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IExheWVyIGlzIHJlYWR5IHRvIGJlIHJlbmRlcmVkLlxuICAgKi9cbiAgcHJlcGFyZUZyYW1lKGZyYW1lU3RhdGUpIHtcbiAgICBjb25zdCB2ZWN0b3JMYXllciA9IHRoaXMuZ2V0TGF5ZXIoKTtcbiAgICBjb25zdCB2ZWN0b3JTb3VyY2UgPSB2ZWN0b3JMYXllci5nZXRTb3VyY2UoKTtcbiAgICBpZiAoIXZlY3RvclNvdXJjZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IGFuaW1hdGluZyA9IGZyYW1lU3RhdGUudmlld0hpbnRzW1ZpZXdIaW50LkFOSU1BVElOR107XG4gICAgY29uc3QgaW50ZXJhY3RpbmcgPSBmcmFtZVN0YXRlLnZpZXdIaW50c1tWaWV3SGludC5JTlRFUkFDVElOR107XG4gICAgY29uc3QgdXBkYXRlV2hpbGVBbmltYXRpbmcgPSB2ZWN0b3JMYXllci5nZXRVcGRhdGVXaGlsZUFuaW1hdGluZygpO1xuICAgIGNvbnN0IHVwZGF0ZVdoaWxlSW50ZXJhY3RpbmcgPSB2ZWN0b3JMYXllci5nZXRVcGRhdGVXaGlsZUludGVyYWN0aW5nKCk7XG5cbiAgICBpZiAoXG4gICAgICAodGhpcy5yZWFkeSAmJiAhdXBkYXRlV2hpbGVBbmltYXRpbmcgJiYgYW5pbWF0aW5nKSB8fFxuICAgICAgKCF1cGRhdGVXaGlsZUludGVyYWN0aW5nICYmIGludGVyYWN0aW5nKVxuICAgICkge1xuICAgICAgdGhpcy5hbmltYXRpbmdPckludGVyYWN0aW5nXyA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy5hbmltYXRpbmdPckludGVyYWN0aW5nXyA9IGZhbHNlO1xuXG4gICAgY29uc3QgZnJhbWVTdGF0ZUV4dGVudCA9IGZyYW1lU3RhdGUuZXh0ZW50O1xuICAgIGNvbnN0IHZpZXdTdGF0ZSA9IGZyYW1lU3RhdGUudmlld1N0YXRlO1xuICAgIGNvbnN0IHByb2plY3Rpb24gPSB2aWV3U3RhdGUucHJvamVjdGlvbjtcbiAgICBjb25zdCByZXNvbHV0aW9uID0gdmlld1N0YXRlLnJlc29sdXRpb247XG4gICAgY29uc3QgcGl4ZWxSYXRpbyA9IGZyYW1lU3RhdGUucGl4ZWxSYXRpbztcbiAgICBjb25zdCB2ZWN0b3JMYXllclJldmlzaW9uID0gdmVjdG9yTGF5ZXIuZ2V0UmV2aXNpb24oKTtcbiAgICBjb25zdCB2ZWN0b3JMYXllclJlbmRlckJ1ZmZlciA9IHZlY3RvckxheWVyLmdldFJlbmRlckJ1ZmZlcigpO1xuICAgIGxldCB2ZWN0b3JMYXllclJlbmRlck9yZGVyID0gdmVjdG9yTGF5ZXIuZ2V0UmVuZGVyT3JkZXIoKTtcblxuICAgIGlmICh2ZWN0b3JMYXllclJlbmRlck9yZGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHZlY3RvckxheWVyUmVuZGVyT3JkZXIgPSBkZWZhdWx0UmVuZGVyT3JkZXI7XG4gICAgfVxuXG4gICAgY29uc3QgY2VudGVyID0gdmlld1N0YXRlLmNlbnRlci5zbGljZSgpO1xuICAgIGNvbnN0IGV4dGVudCA9IGJ1ZmZlcihcbiAgICAgIGZyYW1lU3RhdGVFeHRlbnQsXG4gICAgICB2ZWN0b3JMYXllclJlbmRlckJ1ZmZlciAqIHJlc29sdXRpb25cbiAgICApO1xuICAgIGNvbnN0IHJlbmRlcmVkRXh0ZW50ID0gZXh0ZW50LnNsaWNlKCk7XG4gICAgY29uc3QgbG9hZEV4dGVudHMgPSBbZXh0ZW50LnNsaWNlKCldO1xuICAgIGNvbnN0IHByb2plY3Rpb25FeHRlbnQgPSBwcm9qZWN0aW9uLmdldEV4dGVudCgpO1xuXG4gICAgaWYgKFxuICAgICAgdmVjdG9yU291cmNlLmdldFdyYXBYKCkgJiZcbiAgICAgIHByb2plY3Rpb24uY2FuV3JhcFgoKSAmJlxuICAgICAgIWNvbnRhaW5zRXh0ZW50KHByb2plY3Rpb25FeHRlbnQsIGZyYW1lU3RhdGUuZXh0ZW50KVxuICAgICkge1xuICAgICAgLy8gRm9yIHRoZSByZXBsYXkgZ3JvdXAsIHdlIG5lZWQgYW4gZXh0ZW50IHRoYXQgaW50ZXJzZWN0cyB0aGUgcmVhbCB3b3JsZFxuICAgICAgLy8gKC0xODDCsCB0byArMTgwwrApLiBUbyBzdXBwb3J0IGdlb21ldHJpZXMgaW4gYSBjb29yZGluYXRlIHJhbmdlIGZyb20gLTU0MMKwXG4gICAgICAvLyB0byArNTQwwrAsIHdlIGFkZCBhdCBsZWFzdCAxIHdvcmxkIHdpZHRoIG9uIGVhY2ggc2lkZSBvZiB0aGUgcHJvamVjdGlvblxuICAgICAgLy8gZXh0ZW50LiBJZiB0aGUgdmlld3BvcnQgaXMgd2lkZXIgdGhhbiB0aGUgd29ybGQsIHdlIG5lZWQgdG8gYWRkIGhhbGYgb2ZcbiAgICAgIC8vIHRoZSB2aWV3cG9ydCB3aWR0aCB0byBtYWtlIHN1cmUgd2UgY292ZXIgdGhlIHdob2xlIHZpZXdwb3J0LlxuICAgICAgY29uc3Qgd29ybGRXaWR0aCA9IGdldFdpZHRoKHByb2plY3Rpb25FeHRlbnQpO1xuICAgICAgY29uc3QgZ3V0dGVyID0gTWF0aC5tYXgoZ2V0V2lkdGgoZXh0ZW50KSAvIDIsIHdvcmxkV2lkdGgpO1xuICAgICAgZXh0ZW50WzBdID0gcHJvamVjdGlvbkV4dGVudFswXSAtIGd1dHRlcjtcbiAgICAgIGV4dGVudFsyXSA9IHByb2plY3Rpb25FeHRlbnRbMl0gKyBndXR0ZXI7XG4gICAgICB3cmFwQ29vcmRpbmF0ZVgoY2VudGVyLCBwcm9qZWN0aW9uKTtcbiAgICAgIGNvbnN0IGxvYWRFeHRlbnQgPSB3cmFwRXh0ZW50WChsb2FkRXh0ZW50c1swXSwgcHJvamVjdGlvbik7XG4gICAgICAvLyBJZiB0aGUgZXh0ZW50IGNyb3NzZXMgdGhlIGRhdGUgbGluZSwgd2UgbG9hZCBkYXRhIGZvciBib3RoIGVkZ2VzIG9mIHRoZSB3b3JsZHNcbiAgICAgIGlmIChcbiAgICAgICAgbG9hZEV4dGVudFswXSA8IHByb2plY3Rpb25FeHRlbnRbMF0gJiZcbiAgICAgICAgbG9hZEV4dGVudFsyXSA8IHByb2plY3Rpb25FeHRlbnRbMl1cbiAgICAgICkge1xuICAgICAgICBsb2FkRXh0ZW50cy5wdXNoKFtcbiAgICAgICAgICBsb2FkRXh0ZW50WzBdICsgd29ybGRXaWR0aCxcbiAgICAgICAgICBsb2FkRXh0ZW50WzFdLFxuICAgICAgICAgIGxvYWRFeHRlbnRbMl0gKyB3b3JsZFdpZHRoLFxuICAgICAgICAgIGxvYWRFeHRlbnRbM10sXG4gICAgICAgIF0pO1xuICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgbG9hZEV4dGVudFswXSA+IHByb2plY3Rpb25FeHRlbnRbMF0gJiZcbiAgICAgICAgbG9hZEV4dGVudFsyXSA+IHByb2plY3Rpb25FeHRlbnRbMl1cbiAgICAgICkge1xuICAgICAgICBsb2FkRXh0ZW50cy5wdXNoKFtcbiAgICAgICAgICBsb2FkRXh0ZW50WzBdIC0gd29ybGRXaWR0aCxcbiAgICAgICAgICBsb2FkRXh0ZW50WzFdLFxuICAgICAgICAgIGxvYWRFeHRlbnRbMl0gLSB3b3JsZFdpZHRoLFxuICAgICAgICAgIGxvYWRFeHRlbnRbM10sXG4gICAgICAgIF0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChcbiAgICAgIHRoaXMucmVhZHkgJiZcbiAgICAgIHRoaXMucmVuZGVyZWRSZXNvbHV0aW9uXyA9PSByZXNvbHV0aW9uICYmXG4gICAgICB0aGlzLnJlbmRlcmVkUmV2aXNpb25fID09IHZlY3RvckxheWVyUmV2aXNpb24gJiZcbiAgICAgIHRoaXMucmVuZGVyZWRSZW5kZXJPcmRlcl8gPT0gdmVjdG9yTGF5ZXJSZW5kZXJPcmRlciAmJlxuICAgICAgY29udGFpbnNFeHRlbnQodGhpcy53cmFwcGVkUmVuZGVyZWRFeHRlbnRfLCBleHRlbnQpXG4gICAgKSB7XG4gICAgICBpZiAoIWVxdWFscyh0aGlzLnJlbmRlcmVkRXh0ZW50XywgcmVuZGVyZWRFeHRlbnQpKSB7XG4gICAgICAgIHRoaXMuaGl0RGV0ZWN0aW9uSW1hZ2VEYXRhXyA9IG51bGw7XG4gICAgICAgIHRoaXMucmVuZGVyZWRFeHRlbnRfID0gcmVuZGVyZWRFeHRlbnQ7XG4gICAgICB9XG4gICAgICB0aGlzLnJlbmRlcmVkQ2VudGVyXyA9IGNlbnRlcjtcbiAgICAgIHRoaXMucmVwbGF5R3JvdXBDaGFuZ2VkID0gZmFsc2U7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB0aGlzLnJlcGxheUdyb3VwXyA9IG51bGw7XG5cbiAgICBjb25zdCByZXBsYXlHcm91cCA9IG5ldyBDYW52YXNCdWlsZGVyR3JvdXAoXG4gICAgICBnZXRSZW5kZXJUb2xlcmFuY2UocmVzb2x1dGlvbiwgcGl4ZWxSYXRpbyksXG4gICAgICBleHRlbnQsXG4gICAgICByZXNvbHV0aW9uLFxuICAgICAgcGl4ZWxSYXRpb1xuICAgICk7XG5cbiAgICBsZXQgZGVjbHV0dGVyQnVpbGRlckdyb3VwO1xuICAgIGlmICh0aGlzLmdldExheWVyKCkuZ2V0RGVjbHV0dGVyKCkpIHtcbiAgICAgIGRlY2x1dHRlckJ1aWxkZXJHcm91cCA9IG5ldyBDYW52YXNCdWlsZGVyR3JvdXAoXG4gICAgICAgIGdldFJlbmRlclRvbGVyYW5jZShyZXNvbHV0aW9uLCBwaXhlbFJhdGlvKSxcbiAgICAgICAgZXh0ZW50LFxuICAgICAgICByZXNvbHV0aW9uLFxuICAgICAgICBwaXhlbFJhdGlvXG4gICAgICApO1xuICAgIH1cblxuICAgIGNvbnN0IHVzZXJQcm9qZWN0aW9uID0gZ2V0VXNlclByb2plY3Rpb24oKTtcbiAgICBsZXQgdXNlclRyYW5zZm9ybTtcbiAgICBpZiAodXNlclByb2plY3Rpb24pIHtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IGxvYWRFeHRlbnRzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgY29uc3QgZXh0ZW50ID0gbG9hZEV4dGVudHNbaV07XG4gICAgICAgIGNvbnN0IHVzZXJFeHRlbnQgPSB0b1VzZXJFeHRlbnQoZXh0ZW50LCBwcm9qZWN0aW9uKTtcbiAgICAgICAgdmVjdG9yU291cmNlLmxvYWRGZWF0dXJlcyhcbiAgICAgICAgICB1c2VyRXh0ZW50LFxuICAgICAgICAgIHRvVXNlclJlc29sdXRpb24ocmVzb2x1dGlvbiwgcHJvamVjdGlvbiksXG4gICAgICAgICAgdXNlclByb2plY3Rpb25cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHVzZXJUcmFuc2Zvcm0gPSBnZXRUcmFuc2Zvcm1Gcm9tUHJvamVjdGlvbnModXNlclByb2plY3Rpb24sIHByb2plY3Rpb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBsb2FkRXh0ZW50cy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgIHZlY3RvclNvdXJjZS5sb2FkRmVhdHVyZXMobG9hZEV4dGVudHNbaV0sIHJlc29sdXRpb24sIHByb2plY3Rpb24pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHNxdWFyZWRUb2xlcmFuY2UgPSBnZXRTcXVhcmVkUmVuZGVyVG9sZXJhbmNlKHJlc29sdXRpb24sIHBpeGVsUmF0aW8pO1xuICAgIGxldCByZWFkeSA9IHRydWU7XG4gICAgY29uc3QgcmVuZGVyID1cbiAgICAgIC8qKlxuICAgICAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9IGZlYXR1cmUgRmVhdHVyZS5cbiAgICAgICAqL1xuICAgICAgKGZlYXR1cmUpID0+IHtcbiAgICAgICAgbGV0IHN0eWxlcztcbiAgICAgICAgY29uc3Qgc3R5bGVGdW5jdGlvbiA9XG4gICAgICAgICAgZmVhdHVyZS5nZXRTdHlsZUZ1bmN0aW9uKCkgfHwgdmVjdG9yTGF5ZXIuZ2V0U3R5bGVGdW5jdGlvbigpO1xuICAgICAgICBpZiAoc3R5bGVGdW5jdGlvbikge1xuICAgICAgICAgIHN0eWxlcyA9IHN0eWxlRnVuY3Rpb24oZmVhdHVyZSwgcmVzb2x1dGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0eWxlcykge1xuICAgICAgICAgIGNvbnN0IGRpcnR5ID0gdGhpcy5yZW5kZXJGZWF0dXJlKFxuICAgICAgICAgICAgZmVhdHVyZSxcbiAgICAgICAgICAgIHNxdWFyZWRUb2xlcmFuY2UsXG4gICAgICAgICAgICBzdHlsZXMsXG4gICAgICAgICAgICByZXBsYXlHcm91cCxcbiAgICAgICAgICAgIHVzZXJUcmFuc2Zvcm0sXG4gICAgICAgICAgICBkZWNsdXR0ZXJCdWlsZGVyR3JvdXBcbiAgICAgICAgICApO1xuICAgICAgICAgIHJlYWR5ID0gcmVhZHkgJiYgIWRpcnR5O1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgY29uc3QgdXNlckV4dGVudCA9IHRvVXNlckV4dGVudChleHRlbnQsIHByb2plY3Rpb24pO1xuICAgIC8qKiBAdHlwZSB7QXJyYXk8aW1wb3J0KFwiLi4vLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0Pn0gKi9cbiAgICBjb25zdCBmZWF0dXJlcyA9IHZlY3RvclNvdXJjZS5nZXRGZWF0dXJlc0luRXh0ZW50KHVzZXJFeHRlbnQpO1xuICAgIGlmICh2ZWN0b3JMYXllclJlbmRlck9yZGVyKSB7XG4gICAgICBmZWF0dXJlcy5zb3J0KHZlY3RvckxheWVyUmVuZGVyT3JkZXIpO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBmZWF0dXJlcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICByZW5kZXIoZmVhdHVyZXNbaV0pO1xuICAgIH1cbiAgICB0aGlzLnJlbmRlcmVkRmVhdHVyZXNfID0gZmVhdHVyZXM7XG4gICAgdGhpcy5yZWFkeSA9IHJlYWR5O1xuXG4gICAgY29uc3QgcmVwbGF5R3JvdXBJbnN0cnVjdGlvbnMgPSByZXBsYXlHcm91cC5maW5pc2goKTtcbiAgICBjb25zdCBleGVjdXRvckdyb3VwID0gbmV3IEV4ZWN1dG9yR3JvdXAoXG4gICAgICBleHRlbnQsXG4gICAgICByZXNvbHV0aW9uLFxuICAgICAgcGl4ZWxSYXRpbyxcbiAgICAgIHZlY3RvclNvdXJjZS5nZXRPdmVybGFwcygpLFxuICAgICAgcmVwbGF5R3JvdXBJbnN0cnVjdGlvbnMsXG4gICAgICB2ZWN0b3JMYXllci5nZXRSZW5kZXJCdWZmZXIoKVxuICAgICk7XG5cbiAgICBpZiAoZGVjbHV0dGVyQnVpbGRlckdyb3VwKSB7XG4gICAgICB0aGlzLmRlY2x1dHRlckV4ZWN1dG9yR3JvdXAgPSBuZXcgRXhlY3V0b3JHcm91cChcbiAgICAgICAgZXh0ZW50LFxuICAgICAgICByZXNvbHV0aW9uLFxuICAgICAgICBwaXhlbFJhdGlvLFxuICAgICAgICB2ZWN0b3JTb3VyY2UuZ2V0T3ZlcmxhcHMoKSxcbiAgICAgICAgZGVjbHV0dGVyQnVpbGRlckdyb3VwLmZpbmlzaCgpLFxuICAgICAgICB2ZWN0b3JMYXllci5nZXRSZW5kZXJCdWZmZXIoKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICB0aGlzLnJlbmRlcmVkUmVzb2x1dGlvbl8gPSByZXNvbHV0aW9uO1xuICAgIHRoaXMucmVuZGVyZWRSZXZpc2lvbl8gPSB2ZWN0b3JMYXllclJldmlzaW9uO1xuICAgIHRoaXMucmVuZGVyZWRSZW5kZXJPcmRlcl8gPSB2ZWN0b3JMYXllclJlbmRlck9yZGVyO1xuICAgIHRoaXMucmVuZGVyZWRFeHRlbnRfID0gcmVuZGVyZWRFeHRlbnQ7XG4gICAgdGhpcy53cmFwcGVkUmVuZGVyZWRFeHRlbnRfID0gZXh0ZW50O1xuICAgIHRoaXMucmVuZGVyZWRDZW50ZXJfID0gY2VudGVyO1xuICAgIHRoaXMucmVuZGVyZWRQcm9qZWN0aW9uXyA9IHByb2plY3Rpb247XG4gICAgdGhpcy5yZXBsYXlHcm91cF8gPSBleGVjdXRvckdyb3VwO1xuICAgIHRoaXMuaGl0RGV0ZWN0aW9uSW1hZ2VEYXRhXyA9IG51bGw7XG5cbiAgICB0aGlzLnJlcGxheUdyb3VwQ2hhbmdlZCA9IHRydWU7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9IGZlYXR1cmUgRmVhdHVyZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHNxdWFyZWRUb2xlcmFuY2UgU3F1YXJlZCByZW5kZXIgdG9sZXJhbmNlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL3N0eWxlL1N0eWxlLmpzXCIpLmRlZmF1bHR8QXJyYXk8aW1wb3J0KFwiLi4vLi4vc3R5bGUvU3R5bGUuanNcIikuZGVmYXVsdD59IHN0eWxlcyBUaGUgc3R5bGUgb3IgYXJyYXkgb2Ygc3R5bGVzLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL3JlbmRlci9jYW52YXMvQnVpbGRlckdyb3VwLmpzXCIpLmRlZmF1bHR9IGJ1aWxkZXJHcm91cCBCdWlsZGVyIGdyb3VwLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL3Byb2ouanNcIikuVHJhbnNmb3JtRnVuY3Rpb259IFt0cmFuc2Zvcm1dIFRyYW5zZm9ybSBmcm9tIHVzZXIgdG8gdmlldyBwcm9qZWN0aW9uLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL3JlbmRlci9jYW52YXMvQnVpbGRlckdyb3VwLmpzXCIpLmRlZmF1bHR9IFtkZWNsdXR0ZXJCdWlsZGVyR3JvdXBdIEJ1aWxkZXIgZm9yIGRlY2x1dHRlcmluZy5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gYHRydWVgIGlmIGFuIGltYWdlIGlzIGxvYWRpbmcuXG4gICAqL1xuICByZW5kZXJGZWF0dXJlKFxuICAgIGZlYXR1cmUsXG4gICAgc3F1YXJlZFRvbGVyYW5jZSxcbiAgICBzdHlsZXMsXG4gICAgYnVpbGRlckdyb3VwLFxuICAgIHRyYW5zZm9ybSxcbiAgICBkZWNsdXR0ZXJCdWlsZGVyR3JvdXBcbiAgKSB7XG4gICAgaWYgKCFzdHlsZXMpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgbGV0IGxvYWRpbmcgPSBmYWxzZTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShzdHlsZXMpKSB7XG4gICAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBzdHlsZXMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICBsb2FkaW5nID1cbiAgICAgICAgICByZW5kZXJGZWF0dXJlKFxuICAgICAgICAgICAgYnVpbGRlckdyb3VwLFxuICAgICAgICAgICAgZmVhdHVyZSxcbiAgICAgICAgICAgIHN0eWxlc1tpXSxcbiAgICAgICAgICAgIHNxdWFyZWRUb2xlcmFuY2UsXG4gICAgICAgICAgICB0aGlzLmJvdW5kSGFuZGxlU3R5bGVJbWFnZUNoYW5nZV8sXG4gICAgICAgICAgICB0cmFuc2Zvcm0sXG4gICAgICAgICAgICBkZWNsdXR0ZXJCdWlsZGVyR3JvdXBcbiAgICAgICAgICApIHx8IGxvYWRpbmc7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvYWRpbmcgPSByZW5kZXJGZWF0dXJlKFxuICAgICAgICBidWlsZGVyR3JvdXAsXG4gICAgICAgIGZlYXR1cmUsXG4gICAgICAgIHN0eWxlcyxcbiAgICAgICAgc3F1YXJlZFRvbGVyYW5jZSxcbiAgICAgICAgdGhpcy5ib3VuZEhhbmRsZVN0eWxlSW1hZ2VDaGFuZ2VfLFxuICAgICAgICB0cmFuc2Zvcm0sXG4gICAgICAgIGRlY2x1dHRlckJ1aWxkZXJHcm91cFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIGxvYWRpbmc7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQ2FudmFzVmVjdG9yTGF5ZXJSZW5kZXJlcjtcbiIsIi8qKlxuICogQG1vZHVsZSBvbC9yZW5kZXJlci92ZWN0b3JcbiAqL1xuaW1wb3J0IEltYWdlU3RhdGUgZnJvbSAnLi4vSW1hZ2VTdGF0ZS5qcyc7XG5pbXBvcnQge2dldFVpZH0gZnJvbSAnLi4vdXRpbC5qcyc7XG5cbi8qKlxuICogRmVhdHVyZSBjYWxsYmFjay4gVGhlIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIHdpdGggdGhyZWUgYXJndW1lbnRzLiBUaGUgZmlyc3RcbiAqIGFyZ3VtZW50IGlzIG9uZSB7QGxpbmsgbW9kdWxlOm9sL0ZlYXR1cmV+RmVhdHVyZSBmZWF0dXJlfSBvciB7QGxpbmsgbW9kdWxlOm9sL3JlbmRlci9GZWF0dXJlflJlbmRlckZlYXR1cmUgcmVuZGVyIGZlYXR1cmV9XG4gKiBhdCB0aGUgcGl4ZWwsIHRoZSBzZWNvbmQgaXMgdGhlIHtAbGluayBtb2R1bGU6b2wvbGF5ZXIvTGF5ZXJ+TGF5ZXIgbGF5ZXJ9IG9mIHRoZSBmZWF0dXJlIGFuZCB3aWxsIGJlIG51bGwgZm9yXG4gKiB1bm1hbmFnZWQgbGF5ZXJzLiBUaGUgdGhpcmQgaXMgdGhlIHtAbGluayBtb2R1bGU6b2wvZ2VvbS9TaW1wbGVHZW9tZXRyeX5TaW1wbGVHZW9tZXRyeX0gb2YgdGhlIGZlYXR1cmUuIEZvciBmZWF0dXJlc1xuICogd2l0aCBhIEdlb21ldHJ5Q29sbGVjdGlvbiBnZW9tZXRyeSwgaXQgd2lsbCBiZSB0aGUgZmlyc3QgZGV0ZWN0ZWQgZ2VvbWV0cnkgZnJvbSB0aGUgY29sbGVjdGlvbi5cbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAdHlwZWRlZiB7ZnVuY3Rpb24oaW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5GZWF0dXJlTGlrZSwgaW1wb3J0KFwiLi4vbGF5ZXIvTGF5ZXIuanNcIikuZGVmYXVsdDxpbXBvcnQoXCIuLi9zb3VyY2UvU291cmNlXCIpLmRlZmF1bHQ+LCBpbXBvcnQoXCIuLi9nZW9tL1NpbXBsZUdlb21ldHJ5LmpzXCIpLmRlZmF1bHQpOiBUfSBGZWF0dXJlQ2FsbGJhY2tcbiAqL1xuXG4vKipcbiAqIFRvbGVyYW5jZSBmb3IgZ2VvbWV0cnkgc2ltcGxpZmljYXRpb24gaW4gZGV2aWNlIHBpeGVscy5cbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmNvbnN0IFNJTVBMSUZZX1RPTEVSQU5DRSA9IDAuNTtcblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtPYmplY3Q8aW1wb3J0KFwiLi4vZ2VvbS9HZW9tZXRyeS5qc1wiKS5UeXBlLFxuICogICAgICAgICAgICAgICAgZnVuY3Rpb24oaW1wb3J0KFwiLi4vcmVuZGVyL2NhbnZhcy9CdWlsZGVyR3JvdXAuanNcIikuZGVmYXVsdCwgaW1wb3J0KFwiLi4vZ2VvbS9HZW9tZXRyeS5qc1wiKS5kZWZhdWx0LFxuICogICAgICAgICAgICAgICAgICAgICAgICAgaW1wb3J0KFwiLi4vc3R5bGUvU3R5bGUuanNcIikuZGVmYXVsdCwgT2JqZWN0KTogdm9pZD59XG4gKi9cbmNvbnN0IEdFT01FVFJZX1JFTkRFUkVSUyA9IHtcbiAgJ1BvaW50JzogcmVuZGVyUG9pbnRHZW9tZXRyeSxcbiAgJ0xpbmVTdHJpbmcnOiByZW5kZXJMaW5lU3RyaW5nR2VvbWV0cnksXG4gICdQb2x5Z29uJzogcmVuZGVyUG9seWdvbkdlb21ldHJ5LFxuICAnTXVsdGlQb2ludCc6IHJlbmRlck11bHRpUG9pbnRHZW9tZXRyeSxcbiAgJ011bHRpTGluZVN0cmluZyc6IHJlbmRlck11bHRpTGluZVN0cmluZ0dlb21ldHJ5LFxuICAnTXVsdGlQb2x5Z29uJzogcmVuZGVyTXVsdGlQb2x5Z29uR2VvbWV0cnksXG4gICdHZW9tZXRyeUNvbGxlY3Rpb24nOiByZW5kZXJHZW9tZXRyeUNvbGxlY3Rpb25HZW9tZXRyeSxcbiAgJ0NpcmNsZSc6IHJlbmRlckNpcmNsZUdlb21ldHJ5LFxufTtcblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuRmVhdHVyZUxpa2V9IGZlYXR1cmUxIEZlYXR1cmUgMS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5GZWF0dXJlTGlrZX0gZmVhdHVyZTIgRmVhdHVyZSAyLlxuICogQHJldHVybiB7bnVtYmVyfSBPcmRlci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRPcmRlcihmZWF0dXJlMSwgZmVhdHVyZTIpIHtcbiAgcmV0dXJuIHBhcnNlSW50KGdldFVpZChmZWF0dXJlMSksIDEwKSAtIHBhcnNlSW50KGdldFVpZChmZWF0dXJlMiksIDEwKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gcmVzb2x1dGlvbiBSZXNvbHV0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IHBpeGVsUmF0aW8gUGl4ZWwgcmF0aW8uXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFNxdWFyZWQgcGl4ZWwgdG9sZXJhbmNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0U3F1YXJlZFRvbGVyYW5jZShyZXNvbHV0aW9uLCBwaXhlbFJhdGlvKSB7XG4gIGNvbnN0IHRvbGVyYW5jZSA9IGdldFRvbGVyYW5jZShyZXNvbHV0aW9uLCBwaXhlbFJhdGlvKTtcbiAgcmV0dXJuIHRvbGVyYW5jZSAqIHRvbGVyYW5jZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gcmVzb2x1dGlvbiBSZXNvbHV0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IHBpeGVsUmF0aW8gUGl4ZWwgcmF0aW8uXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFBpeGVsIHRvbGVyYW5jZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFRvbGVyYW5jZShyZXNvbHV0aW9uLCBwaXhlbFJhdGlvKSB7XG4gIHJldHVybiAoU0lNUExJRllfVE9MRVJBTkNFICogcmVzb2x1dGlvbikgLyBwaXhlbFJhdGlvO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcmVuZGVyL2NhbnZhcy9CdWlsZGVyR3JvdXAuanNcIikuZGVmYXVsdH0gYnVpbGRlckdyb3VwIEJ1aWxkZXIgZ3JvdXAuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL2dlb20vQ2lyY2xlLmpzXCIpLmRlZmF1bHR9IGdlb21ldHJ5IEdlb21ldHJ5LlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9zdHlsZS9TdHlsZS5qc1wiKS5kZWZhdWx0fSBzdHlsZSBTdHlsZS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0fSBmZWF0dXJlIEZlYXR1cmUuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL3JlbmRlci9jYW52YXMvQnVpbGRlckdyb3VwLmpzXCIpLmRlZmF1bHR9IFtkZWNsdXR0ZXJCdWlsZGVyR3JvdXBdIEJ1aWxkZXIgZm9yIGRlY2x1dHRlcmluZy5cbiAqL1xuZnVuY3Rpb24gcmVuZGVyQ2lyY2xlR2VvbWV0cnkoXG4gIGJ1aWxkZXJHcm91cCxcbiAgZ2VvbWV0cnksXG4gIHN0eWxlLFxuICBmZWF0dXJlLFxuICBkZWNsdXR0ZXJCdWlsZGVyR3JvdXBcbikge1xuICBjb25zdCBmaWxsU3R5bGUgPSBzdHlsZS5nZXRGaWxsKCk7XG4gIGNvbnN0IHN0cm9rZVN0eWxlID0gc3R5bGUuZ2V0U3Ryb2tlKCk7XG4gIGlmIChmaWxsU3R5bGUgfHwgc3Ryb2tlU3R5bGUpIHtcbiAgICBjb25zdCBjaXJjbGVSZXBsYXkgPSBidWlsZGVyR3JvdXAuZ2V0QnVpbGRlcihzdHlsZS5nZXRaSW5kZXgoKSwgJ0NpcmNsZScpO1xuICAgIGNpcmNsZVJlcGxheS5zZXRGaWxsU3Ryb2tlU3R5bGUoZmlsbFN0eWxlLCBzdHJva2VTdHlsZSk7XG4gICAgY2lyY2xlUmVwbGF5LmRyYXdDaXJjbGUoZ2VvbWV0cnksIGZlYXR1cmUpO1xuICB9XG4gIGNvbnN0IHRleHRTdHlsZSA9IHN0eWxlLmdldFRleHQoKTtcbiAgaWYgKHRleHRTdHlsZSAmJiB0ZXh0U3R5bGUuZ2V0VGV4dCgpKSB7XG4gICAgY29uc3QgdGV4dFJlcGxheSA9IChkZWNsdXR0ZXJCdWlsZGVyR3JvdXAgfHwgYnVpbGRlckdyb3VwKS5nZXRCdWlsZGVyKFxuICAgICAgc3R5bGUuZ2V0WkluZGV4KCksXG4gICAgICAnVGV4dCdcbiAgICApO1xuICAgIHRleHRSZXBsYXkuc2V0VGV4dFN0eWxlKHRleHRTdHlsZSk7XG4gICAgdGV4dFJlcGxheS5kcmF3VGV4dChnZW9tZXRyeSwgZmVhdHVyZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL3JlbmRlci9jYW52YXMvQnVpbGRlckdyb3VwLmpzXCIpLmRlZmF1bHR9IHJlcGxheUdyb3VwIFJlcGxheSBncm91cC5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5GZWF0dXJlTGlrZX0gZmVhdHVyZSBGZWF0dXJlLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9zdHlsZS9TdHlsZS5qc1wiKS5kZWZhdWx0fSBzdHlsZSBTdHlsZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzcXVhcmVkVG9sZXJhbmNlIFNxdWFyZWQgdG9sZXJhbmNlLlxuICogQHBhcmFtIHtmdW5jdGlvbihpbXBvcnQoXCIuLi9ldmVudHMvRXZlbnQuanNcIikuZGVmYXVsdCk6IHZvaWR9IGxpc3RlbmVyIExpc3RlbmVyIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9wcm9qLmpzXCIpLlRyYW5zZm9ybUZ1bmN0aW9ufSBbdHJhbnNmb3JtXSBUcmFuc2Zvcm0gZnJvbSB1c2VyIHRvIHZpZXcgcHJvamVjdGlvbi5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcmVuZGVyL2NhbnZhcy9CdWlsZGVyR3JvdXAuanNcIikuZGVmYXVsdH0gW2RlY2x1dHRlckJ1aWxkZXJHcm91cF0gQnVpbGRlciBmb3IgZGVjbHV0dGVyaW5nLlxuICogQHJldHVybiB7Ym9vbGVhbn0gYHRydWVgIGlmIHN0eWxlIGlzIGxvYWRpbmcuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW5kZXJGZWF0dXJlKFxuICByZXBsYXlHcm91cCxcbiAgZmVhdHVyZSxcbiAgc3R5bGUsXG4gIHNxdWFyZWRUb2xlcmFuY2UsXG4gIGxpc3RlbmVyLFxuICB0cmFuc2Zvcm0sXG4gIGRlY2x1dHRlckJ1aWxkZXJHcm91cFxuKSB7XG4gIGxldCBsb2FkaW5nID0gZmFsc2U7XG4gIGNvbnN0IGltYWdlU3R5bGUgPSBzdHlsZS5nZXRJbWFnZSgpO1xuICBpZiAoaW1hZ2VTdHlsZSkge1xuICAgIGNvbnN0IGltYWdlU3RhdGUgPSBpbWFnZVN0eWxlLmdldEltYWdlU3RhdGUoKTtcbiAgICBpZiAoaW1hZ2VTdGF0ZSA9PSBJbWFnZVN0YXRlLkxPQURFRCB8fCBpbWFnZVN0YXRlID09IEltYWdlU3RhdGUuRVJST1IpIHtcbiAgICAgIGltYWdlU3R5bGUudW5saXN0ZW5JbWFnZUNoYW5nZShsaXN0ZW5lcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChpbWFnZVN0YXRlID09IEltYWdlU3RhdGUuSURMRSkge1xuICAgICAgICBpbWFnZVN0eWxlLmxvYWQoKTtcbiAgICAgIH1cbiAgICAgIGltYWdlU3R5bGUubGlzdGVuSW1hZ2VDaGFuZ2UobGlzdGVuZXIpO1xuICAgICAgbG9hZGluZyA9IHRydWU7XG4gICAgfVxuICB9XG4gIHJlbmRlckZlYXR1cmVJbnRlcm5hbChcbiAgICByZXBsYXlHcm91cCxcbiAgICBmZWF0dXJlLFxuICAgIHN0eWxlLFxuICAgIHNxdWFyZWRUb2xlcmFuY2UsXG4gICAgdHJhbnNmb3JtLFxuICAgIGRlY2x1dHRlckJ1aWxkZXJHcm91cFxuICApO1xuXG4gIHJldHVybiBsb2FkaW5nO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcmVuZGVyL2NhbnZhcy9CdWlsZGVyR3JvdXAuanNcIikuZGVmYXVsdH0gcmVwbGF5R3JvdXAgUmVwbGF5IGdyb3VwLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLkZlYXR1cmVMaWtlfSBmZWF0dXJlIEZlYXR1cmUuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL3N0eWxlL1N0eWxlLmpzXCIpLmRlZmF1bHR9IHN0eWxlIFN0eWxlLlxuICogQHBhcmFtIHtudW1iZXJ9IHNxdWFyZWRUb2xlcmFuY2UgU3F1YXJlZCB0b2xlcmFuY2UuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL3Byb2ouanNcIikuVHJhbnNmb3JtRnVuY3Rpb259IFt0cmFuc2Zvcm1dIE9wdGlvbmFsIHRyYW5zZm9ybSBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcmVuZGVyL2NhbnZhcy9CdWlsZGVyR3JvdXAuanNcIikuZGVmYXVsdH0gW2RlY2x1dHRlckJ1aWxkZXJHcm91cF0gQnVpbGRlciBmb3IgZGVjbHV0dGVyaW5nLlxuICovXG5mdW5jdGlvbiByZW5kZXJGZWF0dXJlSW50ZXJuYWwoXG4gIHJlcGxheUdyb3VwLFxuICBmZWF0dXJlLFxuICBzdHlsZSxcbiAgc3F1YXJlZFRvbGVyYW5jZSxcbiAgdHJhbnNmb3JtLFxuICBkZWNsdXR0ZXJCdWlsZGVyR3JvdXBcbikge1xuICBjb25zdCBnZW9tZXRyeSA9IHN0eWxlLmdldEdlb21ldHJ5RnVuY3Rpb24oKShmZWF0dXJlKTtcbiAgaWYgKCFnZW9tZXRyeSkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBzaW1wbGlmaWVkR2VvbWV0cnkgPSBnZW9tZXRyeS5zaW1wbGlmeVRyYW5zZm9ybWVkKFxuICAgIHNxdWFyZWRUb2xlcmFuY2UsXG4gICAgdHJhbnNmb3JtXG4gICk7XG4gIGNvbnN0IHJlbmRlcmVyID0gc3R5bGUuZ2V0UmVuZGVyZXIoKTtcbiAgaWYgKHJlbmRlcmVyKSB7XG4gICAgcmVuZGVyR2VvbWV0cnkocmVwbGF5R3JvdXAsIHNpbXBsaWZpZWRHZW9tZXRyeSwgc3R5bGUsIGZlYXR1cmUpO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGdlb21ldHJ5UmVuZGVyZXIgPSBHRU9NRVRSWV9SRU5ERVJFUlNbc2ltcGxpZmllZEdlb21ldHJ5LmdldFR5cGUoKV07XG4gICAgZ2VvbWV0cnlSZW5kZXJlcihcbiAgICAgIHJlcGxheUdyb3VwLFxuICAgICAgc2ltcGxpZmllZEdlb21ldHJ5LFxuICAgICAgc3R5bGUsXG4gICAgICBmZWF0dXJlLFxuICAgICAgZGVjbHV0dGVyQnVpbGRlckdyb3VwXG4gICAgKTtcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcmVuZGVyL2NhbnZhcy9CdWlsZGVyR3JvdXAuanNcIikuZGVmYXVsdH0gcmVwbGF5R3JvdXAgUmVwbGF5IGdyb3VwLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9nZW9tL0dlb21ldHJ5LmpzXCIpLmRlZmF1bHR8aW1wb3J0KFwiLi4vcmVuZGVyL0ZlYXR1cmUuanNcIikuZGVmYXVsdH0gZ2VvbWV0cnkgR2VvbWV0cnkuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL3N0eWxlL1N0eWxlLmpzXCIpLmRlZmF1bHR9IHN0eWxlIFN0eWxlLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLkZlYXR1cmVMaWtlfSBmZWF0dXJlIEZlYXR1cmUuXG4gKi9cbmZ1bmN0aW9uIHJlbmRlckdlb21ldHJ5KHJlcGxheUdyb3VwLCBnZW9tZXRyeSwgc3R5bGUsIGZlYXR1cmUpIHtcbiAgaWYgKGdlb21ldHJ5LmdldFR5cGUoKSA9PSAnR2VvbWV0cnlDb2xsZWN0aW9uJykge1xuICAgIGNvbnN0IGdlb21ldHJpZXMgPVxuICAgICAgLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi9nZW9tL0dlb21ldHJ5Q29sbGVjdGlvbi5qc1wiKS5kZWZhdWx0fSAqLyAoXG4gICAgICAgIGdlb21ldHJ5XG4gICAgICApLmdldEdlb21ldHJpZXMoKTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBnZW9tZXRyaWVzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgIHJlbmRlckdlb21ldHJ5KHJlcGxheUdyb3VwLCBnZW9tZXRyaWVzW2ldLCBzdHlsZSwgZmVhdHVyZSk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCByZXBsYXkgPSByZXBsYXlHcm91cC5nZXRCdWlsZGVyKHN0eWxlLmdldFpJbmRleCgpLCAnRGVmYXVsdCcpO1xuICByZXBsYXkuZHJhd0N1c3RvbShcbiAgICAvKiogQHR5cGUge2ltcG9ydChcIi4uL2dlb20vU2ltcGxlR2VvbWV0cnkuanNcIikuZGVmYXVsdH0gKi8gKGdlb21ldHJ5KSxcbiAgICBmZWF0dXJlLFxuICAgIHN0eWxlLmdldFJlbmRlcmVyKCksXG4gICAgc3R5bGUuZ2V0SGl0RGV0ZWN0aW9uUmVuZGVyZXIoKVxuICApO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcmVuZGVyL2NhbnZhcy9CdWlsZGVyR3JvdXAuanNcIikuZGVmYXVsdH0gcmVwbGF5R3JvdXAgUmVwbGF5IGdyb3VwLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9nZW9tL0dlb21ldHJ5Q29sbGVjdGlvbi5qc1wiKS5kZWZhdWx0fSBnZW9tZXRyeSBHZW9tZXRyeS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vc3R5bGUvU3R5bGUuanNcIikuZGVmYXVsdH0gc3R5bGUgU3R5bGUuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdH0gZmVhdHVyZSBGZWF0dXJlLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9yZW5kZXIvY2FudmFzL0J1aWxkZXJHcm91cC5qc1wiKS5kZWZhdWx0fSBbZGVjbHV0dGVyQnVpbGRlckdyb3VwXSBCdWlsZGVyIGZvciBkZWNsdXR0ZXJpbmcuXG4gKi9cbmZ1bmN0aW9uIHJlbmRlckdlb21ldHJ5Q29sbGVjdGlvbkdlb21ldHJ5KFxuICByZXBsYXlHcm91cCxcbiAgZ2VvbWV0cnksXG4gIHN0eWxlLFxuICBmZWF0dXJlLFxuICBkZWNsdXR0ZXJCdWlsZGVyR3JvdXBcbikge1xuICBjb25zdCBnZW9tZXRyaWVzID0gZ2VvbWV0cnkuZ2V0R2VvbWV0cmllc0FycmF5KCk7XG4gIGxldCBpLCBpaTtcbiAgZm9yIChpID0gMCwgaWkgPSBnZW9tZXRyaWVzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICBjb25zdCBnZW9tZXRyeVJlbmRlcmVyID0gR0VPTUVUUllfUkVOREVSRVJTW2dlb21ldHJpZXNbaV0uZ2V0VHlwZSgpXTtcbiAgICBnZW9tZXRyeVJlbmRlcmVyKFxuICAgICAgcmVwbGF5R3JvdXAsXG4gICAgICBnZW9tZXRyaWVzW2ldLFxuICAgICAgc3R5bGUsXG4gICAgICBmZWF0dXJlLFxuICAgICAgZGVjbHV0dGVyQnVpbGRlckdyb3VwXG4gICAgKTtcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcmVuZGVyL2NhbnZhcy9CdWlsZGVyR3JvdXAuanNcIikuZGVmYXVsdH0gYnVpbGRlckdyb3VwIFJlcGxheSBncm91cC5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZ2VvbS9MaW5lU3RyaW5nLmpzXCIpLmRlZmF1bHR8aW1wb3J0KFwiLi4vcmVuZGVyL0ZlYXR1cmUuanNcIikuZGVmYXVsdH0gZ2VvbWV0cnkgR2VvbWV0cnkuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL3N0eWxlL1N0eWxlLmpzXCIpLmRlZmF1bHR9IHN0eWxlIFN0eWxlLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLkZlYXR1cmVMaWtlfSBmZWF0dXJlIEZlYXR1cmUuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL3JlbmRlci9jYW52YXMvQnVpbGRlckdyb3VwLmpzXCIpLmRlZmF1bHR9IFtkZWNsdXR0ZXJCdWlsZGVyR3JvdXBdIEJ1aWxkZXIgZm9yIGRlY2x1dHRlcmluZy5cbiAqL1xuZnVuY3Rpb24gcmVuZGVyTGluZVN0cmluZ0dlb21ldHJ5KFxuICBidWlsZGVyR3JvdXAsXG4gIGdlb21ldHJ5LFxuICBzdHlsZSxcbiAgZmVhdHVyZSxcbiAgZGVjbHV0dGVyQnVpbGRlckdyb3VwXG4pIHtcbiAgY29uc3Qgc3Ryb2tlU3R5bGUgPSBzdHlsZS5nZXRTdHJva2UoKTtcbiAgaWYgKHN0cm9rZVN0eWxlKSB7XG4gICAgY29uc3QgbGluZVN0cmluZ1JlcGxheSA9IGJ1aWxkZXJHcm91cC5nZXRCdWlsZGVyKFxuICAgICAgc3R5bGUuZ2V0WkluZGV4KCksXG4gICAgICAnTGluZVN0cmluZydcbiAgICApO1xuICAgIGxpbmVTdHJpbmdSZXBsYXkuc2V0RmlsbFN0cm9rZVN0eWxlKG51bGwsIHN0cm9rZVN0eWxlKTtcbiAgICBsaW5lU3RyaW5nUmVwbGF5LmRyYXdMaW5lU3RyaW5nKGdlb21ldHJ5LCBmZWF0dXJlKTtcbiAgfVxuICBjb25zdCB0ZXh0U3R5bGUgPSBzdHlsZS5nZXRUZXh0KCk7XG4gIGlmICh0ZXh0U3R5bGUgJiYgdGV4dFN0eWxlLmdldFRleHQoKSkge1xuICAgIGNvbnN0IHRleHRSZXBsYXkgPSAoZGVjbHV0dGVyQnVpbGRlckdyb3VwIHx8IGJ1aWxkZXJHcm91cCkuZ2V0QnVpbGRlcihcbiAgICAgIHN0eWxlLmdldFpJbmRleCgpLFxuICAgICAgJ1RleHQnXG4gICAgKTtcbiAgICB0ZXh0UmVwbGF5LnNldFRleHRTdHlsZSh0ZXh0U3R5bGUpO1xuICAgIHRleHRSZXBsYXkuZHJhd1RleHQoZ2VvbWV0cnksIGZlYXR1cmUpO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9yZW5kZXIvY2FudmFzL0J1aWxkZXJHcm91cC5qc1wiKS5kZWZhdWx0fSBidWlsZGVyR3JvdXAgUmVwbGF5IGdyb3VwLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9nZW9tL011bHRpTGluZVN0cmluZy5qc1wiKS5kZWZhdWx0fGltcG9ydChcIi4uL3JlbmRlci9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9IGdlb21ldHJ5IEdlb21ldHJ5LlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9zdHlsZS9TdHlsZS5qc1wiKS5kZWZhdWx0fSBzdHlsZSBTdHlsZS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5GZWF0dXJlTGlrZX0gZmVhdHVyZSBGZWF0dXJlLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9yZW5kZXIvY2FudmFzL0J1aWxkZXJHcm91cC5qc1wiKS5kZWZhdWx0fSBbZGVjbHV0dGVyQnVpbGRlckdyb3VwXSBCdWlsZGVyIGZvciBkZWNsdXR0ZXJpbmcuXG4gKi9cbmZ1bmN0aW9uIHJlbmRlck11bHRpTGluZVN0cmluZ0dlb21ldHJ5KFxuICBidWlsZGVyR3JvdXAsXG4gIGdlb21ldHJ5LFxuICBzdHlsZSxcbiAgZmVhdHVyZSxcbiAgZGVjbHV0dGVyQnVpbGRlckdyb3VwXG4pIHtcbiAgY29uc3Qgc3Ryb2tlU3R5bGUgPSBzdHlsZS5nZXRTdHJva2UoKTtcbiAgaWYgKHN0cm9rZVN0eWxlKSB7XG4gICAgY29uc3QgbGluZVN0cmluZ1JlcGxheSA9IGJ1aWxkZXJHcm91cC5nZXRCdWlsZGVyKFxuICAgICAgc3R5bGUuZ2V0WkluZGV4KCksXG4gICAgICAnTGluZVN0cmluZydcbiAgICApO1xuICAgIGxpbmVTdHJpbmdSZXBsYXkuc2V0RmlsbFN0cm9rZVN0eWxlKG51bGwsIHN0cm9rZVN0eWxlKTtcbiAgICBsaW5lU3RyaW5nUmVwbGF5LmRyYXdNdWx0aUxpbmVTdHJpbmcoZ2VvbWV0cnksIGZlYXR1cmUpO1xuICB9XG4gIGNvbnN0IHRleHRTdHlsZSA9IHN0eWxlLmdldFRleHQoKTtcbiAgaWYgKHRleHRTdHlsZSAmJiB0ZXh0U3R5bGUuZ2V0VGV4dCgpKSB7XG4gICAgY29uc3QgdGV4dFJlcGxheSA9IChkZWNsdXR0ZXJCdWlsZGVyR3JvdXAgfHwgYnVpbGRlckdyb3VwKS5nZXRCdWlsZGVyKFxuICAgICAgc3R5bGUuZ2V0WkluZGV4KCksXG4gICAgICAnVGV4dCdcbiAgICApO1xuICAgIHRleHRSZXBsYXkuc2V0VGV4dFN0eWxlKHRleHRTdHlsZSk7XG4gICAgdGV4dFJlcGxheS5kcmF3VGV4dChnZW9tZXRyeSwgZmVhdHVyZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL3JlbmRlci9jYW52YXMvQnVpbGRlckdyb3VwLmpzXCIpLmRlZmF1bHR9IGJ1aWxkZXJHcm91cCBSZXBsYXkgZ3JvdXAuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL2dlb20vTXVsdGlQb2x5Z29uLmpzXCIpLmRlZmF1bHR9IGdlb21ldHJ5IEdlb21ldHJ5LlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9zdHlsZS9TdHlsZS5qc1wiKS5kZWZhdWx0fSBzdHlsZSBTdHlsZS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0fSBmZWF0dXJlIEZlYXR1cmUuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL3JlbmRlci9jYW52YXMvQnVpbGRlckdyb3VwLmpzXCIpLmRlZmF1bHR9IFtkZWNsdXR0ZXJCdWlsZGVyR3JvdXBdIEJ1aWxkZXIgZm9yIGRlY2x1dHRlcmluZy5cbiAqL1xuZnVuY3Rpb24gcmVuZGVyTXVsdGlQb2x5Z29uR2VvbWV0cnkoXG4gIGJ1aWxkZXJHcm91cCxcbiAgZ2VvbWV0cnksXG4gIHN0eWxlLFxuICBmZWF0dXJlLFxuICBkZWNsdXR0ZXJCdWlsZGVyR3JvdXBcbikge1xuICBjb25zdCBmaWxsU3R5bGUgPSBzdHlsZS5nZXRGaWxsKCk7XG4gIGNvbnN0IHN0cm9rZVN0eWxlID0gc3R5bGUuZ2V0U3Ryb2tlKCk7XG4gIGlmIChzdHJva2VTdHlsZSB8fCBmaWxsU3R5bGUpIHtcbiAgICBjb25zdCBwb2x5Z29uUmVwbGF5ID0gYnVpbGRlckdyb3VwLmdldEJ1aWxkZXIoc3R5bGUuZ2V0WkluZGV4KCksICdQb2x5Z29uJyk7XG4gICAgcG9seWdvblJlcGxheS5zZXRGaWxsU3Ryb2tlU3R5bGUoZmlsbFN0eWxlLCBzdHJva2VTdHlsZSk7XG4gICAgcG9seWdvblJlcGxheS5kcmF3TXVsdGlQb2x5Z29uKGdlb21ldHJ5LCBmZWF0dXJlKTtcbiAgfVxuICBjb25zdCB0ZXh0U3R5bGUgPSBzdHlsZS5nZXRUZXh0KCk7XG4gIGlmICh0ZXh0U3R5bGUgJiYgdGV4dFN0eWxlLmdldFRleHQoKSkge1xuICAgIGNvbnN0IHRleHRSZXBsYXkgPSAoZGVjbHV0dGVyQnVpbGRlckdyb3VwIHx8IGJ1aWxkZXJHcm91cCkuZ2V0QnVpbGRlcihcbiAgICAgIHN0eWxlLmdldFpJbmRleCgpLFxuICAgICAgJ1RleHQnXG4gICAgKTtcbiAgICB0ZXh0UmVwbGF5LnNldFRleHRTdHlsZSh0ZXh0U3R5bGUpO1xuICAgIHRleHRSZXBsYXkuZHJhd1RleHQoZ2VvbWV0cnksIGZlYXR1cmUpO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9yZW5kZXIvY2FudmFzL0J1aWxkZXJHcm91cC5qc1wiKS5kZWZhdWx0fSBidWlsZGVyR3JvdXAgUmVwbGF5IGdyb3VwLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9nZW9tL1BvaW50LmpzXCIpLmRlZmF1bHR8aW1wb3J0KFwiLi4vcmVuZGVyL0ZlYXR1cmUuanNcIikuZGVmYXVsdH0gZ2VvbWV0cnkgR2VvbWV0cnkuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL3N0eWxlL1N0eWxlLmpzXCIpLmRlZmF1bHR9IHN0eWxlIFN0eWxlLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLkZlYXR1cmVMaWtlfSBmZWF0dXJlIEZlYXR1cmUuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL3JlbmRlci9jYW52YXMvQnVpbGRlckdyb3VwLmpzXCIpLmRlZmF1bHR9IFtkZWNsdXR0ZXJCdWlsZGVyR3JvdXBdIEJ1aWxkZXIgZm9yIGRlY2x1dHRlcmluZy5cbiAqL1xuZnVuY3Rpb24gcmVuZGVyUG9pbnRHZW9tZXRyeShcbiAgYnVpbGRlckdyb3VwLFxuICBnZW9tZXRyeSxcbiAgc3R5bGUsXG4gIGZlYXR1cmUsXG4gIGRlY2x1dHRlckJ1aWxkZXJHcm91cFxuKSB7XG4gIGNvbnN0IGltYWdlU3R5bGUgPSBzdHlsZS5nZXRJbWFnZSgpO1xuICBjb25zdCB0ZXh0U3R5bGUgPSBzdHlsZS5nZXRUZXh0KCk7XG4gIC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vcmVuZGVyL2NhbnZhcy5qc1wiKS5EZWNsdXR0ZXJJbWFnZVdpdGhUZXh0fSAqL1xuICBsZXQgZGVjbHV0dGVySW1hZ2VXaXRoVGV4dDtcbiAgaWYgKGltYWdlU3R5bGUpIHtcbiAgICBpZiAoaW1hZ2VTdHlsZS5nZXRJbWFnZVN0YXRlKCkgIT0gSW1hZ2VTdGF0ZS5MT0FERUQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IGltYWdlQnVpbGRlckdyb3VwID0gYnVpbGRlckdyb3VwO1xuICAgIGlmIChkZWNsdXR0ZXJCdWlsZGVyR3JvdXApIHtcbiAgICAgIGNvbnN0IGRlY2x1dHRlck1vZGUgPSBpbWFnZVN0eWxlLmdldERlY2x1dHRlck1vZGUoKTtcbiAgICAgIGlmIChkZWNsdXR0ZXJNb2RlICE9PSAnbm9uZScpIHtcbiAgICAgICAgaW1hZ2VCdWlsZGVyR3JvdXAgPSBkZWNsdXR0ZXJCdWlsZGVyR3JvdXA7XG4gICAgICAgIGlmIChkZWNsdXR0ZXJNb2RlID09PSAnb2JzdGFjbGUnKSB7XG4gICAgICAgICAgLy8gZHJhdyBpbiBub24tZGVjbHV0dGVyIGdyb3VwOlxuICAgICAgICAgIGNvbnN0IGltYWdlUmVwbGF5ID0gYnVpbGRlckdyb3VwLmdldEJ1aWxkZXIoXG4gICAgICAgICAgICBzdHlsZS5nZXRaSW5kZXgoKSxcbiAgICAgICAgICAgICdJbWFnZSdcbiAgICAgICAgICApO1xuICAgICAgICAgIGltYWdlUmVwbGF5LnNldEltYWdlU3R5bGUoaW1hZ2VTdHlsZSwgZGVjbHV0dGVySW1hZ2VXaXRoVGV4dCk7XG4gICAgICAgICAgaW1hZ2VSZXBsYXkuZHJhd1BvaW50KGdlb21ldHJ5LCBmZWF0dXJlKTtcbiAgICAgICAgfSBlbHNlIGlmICh0ZXh0U3R5bGUgJiYgdGV4dFN0eWxlLmdldFRleHQoKSkge1xuICAgICAgICAgIGRlY2x1dHRlckltYWdlV2l0aFRleHQgPSB7fTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBpbWFnZVJlcGxheSA9IGltYWdlQnVpbGRlckdyb3VwLmdldEJ1aWxkZXIoXG4gICAgICBzdHlsZS5nZXRaSW5kZXgoKSxcbiAgICAgICdJbWFnZSdcbiAgICApO1xuICAgIGltYWdlUmVwbGF5LnNldEltYWdlU3R5bGUoaW1hZ2VTdHlsZSwgZGVjbHV0dGVySW1hZ2VXaXRoVGV4dCk7XG4gICAgaW1hZ2VSZXBsYXkuZHJhd1BvaW50KGdlb21ldHJ5LCBmZWF0dXJlKTtcbiAgfVxuICBpZiAodGV4dFN0eWxlICYmIHRleHRTdHlsZS5nZXRUZXh0KCkpIHtcbiAgICBsZXQgdGV4dEJ1aWxkZXJHcm91cCA9IGJ1aWxkZXJHcm91cDtcbiAgICBpZiAoZGVjbHV0dGVyQnVpbGRlckdyb3VwKSB7XG4gICAgICB0ZXh0QnVpbGRlckdyb3VwID0gZGVjbHV0dGVyQnVpbGRlckdyb3VwO1xuICAgIH1cbiAgICBjb25zdCB0ZXh0UmVwbGF5ID0gdGV4dEJ1aWxkZXJHcm91cC5nZXRCdWlsZGVyKHN0eWxlLmdldFpJbmRleCgpLCAnVGV4dCcpO1xuICAgIHRleHRSZXBsYXkuc2V0VGV4dFN0eWxlKHRleHRTdHlsZSwgZGVjbHV0dGVySW1hZ2VXaXRoVGV4dCk7XG4gICAgdGV4dFJlcGxheS5kcmF3VGV4dChnZW9tZXRyeSwgZmVhdHVyZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL3JlbmRlci9jYW52YXMvQnVpbGRlckdyb3VwLmpzXCIpLmRlZmF1bHR9IGJ1aWxkZXJHcm91cCBSZXBsYXkgZ3JvdXAuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL2dlb20vTXVsdGlQb2ludC5qc1wiKS5kZWZhdWx0fGltcG9ydChcIi4uL3JlbmRlci9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9IGdlb21ldHJ5IEdlb21ldHJ5LlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9zdHlsZS9TdHlsZS5qc1wiKS5kZWZhdWx0fSBzdHlsZSBTdHlsZS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5GZWF0dXJlTGlrZX0gZmVhdHVyZSBGZWF0dXJlLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9yZW5kZXIvY2FudmFzL0J1aWxkZXJHcm91cC5qc1wiKS5kZWZhdWx0fSBbZGVjbHV0dGVyQnVpbGRlckdyb3VwXSBCdWlsZGVyIGZvciBkZWNsdXR0ZXJpbmcuXG4gKi9cbmZ1bmN0aW9uIHJlbmRlck11bHRpUG9pbnRHZW9tZXRyeShcbiAgYnVpbGRlckdyb3VwLFxuICBnZW9tZXRyeSxcbiAgc3R5bGUsXG4gIGZlYXR1cmUsXG4gIGRlY2x1dHRlckJ1aWxkZXJHcm91cFxuKSB7XG4gIGNvbnN0IGltYWdlU3R5bGUgPSBzdHlsZS5nZXRJbWFnZSgpO1xuICBjb25zdCB0ZXh0U3R5bGUgPSBzdHlsZS5nZXRUZXh0KCk7XG4gIC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vcmVuZGVyL2NhbnZhcy5qc1wiKS5EZWNsdXR0ZXJJbWFnZVdpdGhUZXh0fSAqL1xuICBsZXQgZGVjbHV0dGVySW1hZ2VXaXRoVGV4dDtcbiAgaWYgKGltYWdlU3R5bGUpIHtcbiAgICBpZiAoaW1hZ2VTdHlsZS5nZXRJbWFnZVN0YXRlKCkgIT0gSW1hZ2VTdGF0ZS5MT0FERUQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IGltYWdlQnVpbGRlckdyb3VwID0gYnVpbGRlckdyb3VwO1xuICAgIGlmIChkZWNsdXR0ZXJCdWlsZGVyR3JvdXApIHtcbiAgICAgIGNvbnN0IGRlY2x1dHRlck1vZGUgPSBpbWFnZVN0eWxlLmdldERlY2x1dHRlck1vZGUoKTtcbiAgICAgIGlmIChkZWNsdXR0ZXJNb2RlICE9PSAnbm9uZScpIHtcbiAgICAgICAgaW1hZ2VCdWlsZGVyR3JvdXAgPSBkZWNsdXR0ZXJCdWlsZGVyR3JvdXA7XG4gICAgICAgIGlmIChkZWNsdXR0ZXJNb2RlID09PSAnb2JzdGFjbGUnKSB7XG4gICAgICAgICAgLy8gZHJhdyBpbiBub24tZGVjbHV0dGVyIGdyb3VwOlxuICAgICAgICAgIGNvbnN0IGltYWdlUmVwbGF5ID0gYnVpbGRlckdyb3VwLmdldEJ1aWxkZXIoXG4gICAgICAgICAgICBzdHlsZS5nZXRaSW5kZXgoKSxcbiAgICAgICAgICAgICdJbWFnZSdcbiAgICAgICAgICApO1xuICAgICAgICAgIGltYWdlUmVwbGF5LnNldEltYWdlU3R5bGUoaW1hZ2VTdHlsZSwgZGVjbHV0dGVySW1hZ2VXaXRoVGV4dCk7XG4gICAgICAgICAgaW1hZ2VSZXBsYXkuZHJhd011bHRpUG9pbnQoZ2VvbWV0cnksIGZlYXR1cmUpO1xuICAgICAgICB9IGVsc2UgaWYgKHRleHRTdHlsZSAmJiB0ZXh0U3R5bGUuZ2V0VGV4dCgpKSB7XG4gICAgICAgICAgZGVjbHV0dGVySW1hZ2VXaXRoVGV4dCA9IHt9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGltYWdlUmVwbGF5ID0gaW1hZ2VCdWlsZGVyR3JvdXAuZ2V0QnVpbGRlcihcbiAgICAgIHN0eWxlLmdldFpJbmRleCgpLFxuICAgICAgJ0ltYWdlJ1xuICAgICk7XG4gICAgaW1hZ2VSZXBsYXkuc2V0SW1hZ2VTdHlsZShpbWFnZVN0eWxlLCBkZWNsdXR0ZXJJbWFnZVdpdGhUZXh0KTtcbiAgICBpbWFnZVJlcGxheS5kcmF3TXVsdGlQb2ludChnZW9tZXRyeSwgZmVhdHVyZSk7XG4gIH1cbiAgaWYgKHRleHRTdHlsZSAmJiB0ZXh0U3R5bGUuZ2V0VGV4dCgpKSB7XG4gICAgbGV0IHRleHRCdWlsZGVyR3JvdXAgPSBidWlsZGVyR3JvdXA7XG4gICAgaWYgKGRlY2x1dHRlckJ1aWxkZXJHcm91cCkge1xuICAgICAgdGV4dEJ1aWxkZXJHcm91cCA9IGRlY2x1dHRlckJ1aWxkZXJHcm91cDtcbiAgICB9XG4gICAgY29uc3QgdGV4dFJlcGxheSA9IHRleHRCdWlsZGVyR3JvdXAuZ2V0QnVpbGRlcihzdHlsZS5nZXRaSW5kZXgoKSwgJ1RleHQnKTtcbiAgICB0ZXh0UmVwbGF5LnNldFRleHRTdHlsZSh0ZXh0U3R5bGUsIGRlY2x1dHRlckltYWdlV2l0aFRleHQpO1xuICAgIHRleHRSZXBsYXkuZHJhd1RleHQoZ2VvbWV0cnksIGZlYXR1cmUpO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9yZW5kZXIvY2FudmFzL0J1aWxkZXJHcm91cC5qc1wiKS5kZWZhdWx0fSBidWlsZGVyR3JvdXAgUmVwbGF5IGdyb3VwLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9nZW9tL1BvbHlnb24uanNcIikuZGVmYXVsdHxpbXBvcnQoXCIuLi9yZW5kZXIvRmVhdHVyZS5qc1wiKS5kZWZhdWx0fSBnZW9tZXRyeSBHZW9tZXRyeS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vc3R5bGUvU3R5bGUuanNcIikuZGVmYXVsdH0gc3R5bGUgU3R5bGUuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuRmVhdHVyZUxpa2V9IGZlYXR1cmUgRmVhdHVyZS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcmVuZGVyL2NhbnZhcy9CdWlsZGVyR3JvdXAuanNcIikuZGVmYXVsdH0gW2RlY2x1dHRlckJ1aWxkZXJHcm91cF0gQnVpbGRlciBmb3IgZGVjbHV0dGVyaW5nLlxuICovXG5mdW5jdGlvbiByZW5kZXJQb2x5Z29uR2VvbWV0cnkoXG4gIGJ1aWxkZXJHcm91cCxcbiAgZ2VvbWV0cnksXG4gIHN0eWxlLFxuICBmZWF0dXJlLFxuICBkZWNsdXR0ZXJCdWlsZGVyR3JvdXBcbikge1xuICBjb25zdCBmaWxsU3R5bGUgPSBzdHlsZS5nZXRGaWxsKCk7XG4gIGNvbnN0IHN0cm9rZVN0eWxlID0gc3R5bGUuZ2V0U3Ryb2tlKCk7XG4gIGlmIChmaWxsU3R5bGUgfHwgc3Ryb2tlU3R5bGUpIHtcbiAgICBjb25zdCBwb2x5Z29uUmVwbGF5ID0gYnVpbGRlckdyb3VwLmdldEJ1aWxkZXIoc3R5bGUuZ2V0WkluZGV4KCksICdQb2x5Z29uJyk7XG4gICAgcG9seWdvblJlcGxheS5zZXRGaWxsU3Ryb2tlU3R5bGUoZmlsbFN0eWxlLCBzdHJva2VTdHlsZSk7XG4gICAgcG9seWdvblJlcGxheS5kcmF3UG9seWdvbihnZW9tZXRyeSwgZmVhdHVyZSk7XG4gIH1cbiAgY29uc3QgdGV4dFN0eWxlID0gc3R5bGUuZ2V0VGV4dCgpO1xuICBpZiAodGV4dFN0eWxlICYmIHRleHRTdHlsZS5nZXRUZXh0KCkpIHtcbiAgICBjb25zdCB0ZXh0UmVwbGF5ID0gKGRlY2x1dHRlckJ1aWxkZXJHcm91cCB8fCBidWlsZGVyR3JvdXApLmdldEJ1aWxkZXIoXG4gICAgICBzdHlsZS5nZXRaSW5kZXgoKSxcbiAgICAgICdUZXh0J1xuICAgICk7XG4gICAgdGV4dFJlcGxheS5zZXRUZXh0U3R5bGUodGV4dFN0eWxlKTtcbiAgICB0ZXh0UmVwbGF5LmRyYXdUZXh0KGdlb21ldHJ5LCBmZWF0dXJlKTtcbiAgfVxufVxuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3JlcHJvalxuICovXG5pbXBvcnQge1xuICBjb250YWluc0Nvb3JkaW5hdGUsXG4gIGNyZWF0ZUVtcHR5LFxuICBleHRlbmQsXG4gIGZvckVhY2hDb3JuZXIsXG4gIGdldENlbnRlcixcbiAgZ2V0SGVpZ2h0LFxuICBnZXRUb3BMZWZ0LFxuICBnZXRXaWR0aCxcbn0gZnJvbSAnLi9leHRlbnQuanMnO1xuaW1wb3J0IHtjcmVhdGVDYW52YXNDb250ZXh0MkQsIHJlbGVhc2VDYW52YXN9IGZyb20gJy4vZG9tLmpzJztcbmltcG9ydCB7Z2V0UG9pbnRSZXNvbHV0aW9uLCB0cmFuc2Zvcm19IGZyb20gJy4vcHJvai5qcyc7XG5pbXBvcnQge3NvbHZlTGluZWFyU3lzdGVtfSBmcm9tICcuL21hdGguanMnO1xuXG5sZXQgYnJva2VuRGlhZ29uYWxSZW5kZXJpbmdfO1xuXG4vKipcbiAqIEB0eXBlIHtBcnJheTxIVE1MQ2FudmFzRWxlbWVudD59XG4gKi9cbmV4cG9ydCBjb25zdCBjYW52YXNQb29sID0gW107XG5cbi8qKlxuICogVGhpcyBkcmF3cyBhIHNtYWxsIHRyaWFuZ2xlIGludG8gYSBjYW52YXMgYnkgc2V0dGluZyB0aGUgdHJpYW5nbGUgYXMgdGhlIGNsaXAgcmVnaW9uXG4gKiBhbmQgdGhlbiBkcmF3aW5nIGEgKHRvbyBsYXJnZSkgcmVjdGFuZ2xlXG4gKlxuICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBUaGUgY29udGV4dCBpbiB3aGljaCB0byBkcmF3IHRoZSB0cmlhbmdsZVxuICogQHBhcmFtIHtudW1iZXJ9IHUxIFRoZSB4LWNvb3JkaW5hdGUgb2YgdGhlIHNlY29uZCBwb2ludC4gVGhlIGZpcnN0IHBvaW50IGlzIDAsMC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB2MSBUaGUgeS1jb29yZGluYXRlIG9mIHRoZSBzZWNvbmQgcG9pbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gdTIgVGhlIHgtY29vcmRpbmF0ZSBvZiB0aGUgdGhpcmQgcG9pbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gdjIgVGhlIHktY29vcmRpbmF0ZSBvZiB0aGUgdGhpcmQgcG9pbnQuXG4gKi9cbmZ1bmN0aW9uIGRyYXdUZXN0VHJpYW5nbGUoY3R4LCB1MSwgdjEsIHUyLCB2Mikge1xuICBjdHguYmVnaW5QYXRoKCk7XG4gIGN0eC5tb3ZlVG8oMCwgMCk7XG4gIGN0eC5saW5lVG8odTEsIHYxKTtcbiAgY3R4LmxpbmVUbyh1MiwgdjIpO1xuICBjdHguY2xvc2VQYXRoKCk7XG4gIGN0eC5zYXZlKCk7XG4gIGN0eC5jbGlwKCk7XG4gIGN0eC5maWxsUmVjdCgwLCAwLCBNYXRoLm1heCh1MSwgdTIpICsgMSwgTWF0aC5tYXgodjEsIHYyKSk7XG4gIGN0eC5yZXN0b3JlKCk7XG59XG5cbi8qKlxuICogR2l2ZW4gdGhlIGRhdGEgZnJvbSBnZXRJbWFnZURhdGEsIHNlZSBpZiB0aGUgcmlnaHQgdmFsdWVzIGFwcGVhciBhdCB0aGUgcHJvdmlkZWQgb2Zmc2V0LlxuICogUmV0dXJucyB0cnVlIGlmIGVpdGhlciB0aGUgY29sb3Igb3IgdHJhbnNwYXJlbmN5IGlzIG9mZlxuICpcbiAqIEBwYXJhbSB7VWludDhDbGFtcGVkQXJyYXl9IGRhdGEgVGhlIGRhdGEgcmV0dXJuZWQgZnJvbSBnZXRJbWFnZURhdGFcbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgVGhlIHBpeGVsIG9mZnNldCBmcm9tIHRoZSBzdGFydCBvZiBkYXRhLlxuICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgZGlhZ29uYWwgcmVuZGVyaW5nIGlzIGJyb2tlblxuICovXG5mdW5jdGlvbiB2ZXJpZnlCcm9rZW5EaWFnb25hbFJlbmRlcmluZyhkYXRhLCBvZmZzZXQpIHtcbiAgLy8gdGhlIHZhbHVlcyBvdWdodCB0byBiZSBjbG9zZSB0byB0aGUgcmdiYSgyMTAsIDAsIDAsIDAuNzUpXG4gIHJldHVybiAoXG4gICAgTWF0aC5hYnMoZGF0YVtvZmZzZXQgKiA0XSAtIDIxMCkgPiAyIHx8XG4gICAgTWF0aC5hYnMoZGF0YVtvZmZzZXQgKiA0ICsgM10gLSAwLjc1ICogMjU1KSA+IDJcbiAgKTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIHRoZSBjdXJyZW50IGJyb3dzZXIgY29uZmlndXJhdGlvbiBjYW4gcmVuZGVyIHRyaWFuZ3VsYXIgY2xpcCByZWdpb25zIGNvcnJlY3RseS5cbiAqIFRoaXMgdmFsdWUgaXMgY2FjaGVkIHNvIHRoZSBmdW5jdGlvbiBpcyBvbmx5IGV4cGVuc2l2ZSB0aGUgZmlyc3QgdGltZSBjYWxsZWQuXG4gKiBGaXJlZm94IG9uIFdpbmRvd3MgKGFzIG9mIG5vdykgZG9lcyBub3QgaWYgSFdBIGlzIGVuYWJsZWQuIFNlZSBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xNjA2OTc2XG4gKiBDaHJvbWUgd29ya3MsIGFuZCBldmVyeXRoaW5nIHNlZW1zIHRvIHdvcmsgb24gT1NYIGFuZCBBbmRyb2lkLiBUaGlzIGZ1bmN0aW9uIGNhY2hlcyB0aGVcbiAqIHJlc3VsdC4gSSBzdXBwb3NlIHRoYXQgaXQgaXMgY29uY2VpdmFibHkgcG9zc2libGUgdGhhdCBhIGJyb3dzZXIgbWlnaHQgZmxpcCBtb2RlcyB3aGlsZSB0aGUgYXBwIGlzXG4gKiBydW5uaW5nLCBidXQgbGV0cyBob3BlIG5vdC5cbiAqXG4gKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIHRoZSBEaWFnb25hbCBSZW5kZXJpbmcgaXMgYnJva2VuLlxuICovXG5mdW5jdGlvbiBpc0Jyb2tlbkRpYWdvbmFsUmVuZGVyaW5nKCkge1xuICBpZiAoYnJva2VuRGlhZ29uYWxSZW5kZXJpbmdfID09PSB1bmRlZmluZWQpIHtcbiAgICBjb25zdCBjdHggPSBjcmVhdGVDYW52YXNDb250ZXh0MkQoNiwgNiwgY2FudmFzUG9vbCk7XG4gICAgY3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdsaWdodGVyJztcbiAgICBjdHguZmlsbFN0eWxlID0gJ3JnYmEoMjEwLCAwLCAwLCAwLjc1KSc7XG4gICAgZHJhd1Rlc3RUcmlhbmdsZShjdHgsIDQsIDUsIDQsIDApO1xuICAgIGRyYXdUZXN0VHJpYW5nbGUoY3R4LCA0LCA1LCAwLCA1KTtcbiAgICBjb25zdCBkYXRhID0gY3R4LmdldEltYWdlRGF0YSgwLCAwLCAzLCAzKS5kYXRhO1xuICAgIGJyb2tlbkRpYWdvbmFsUmVuZGVyaW5nXyA9XG4gICAgICB2ZXJpZnlCcm9rZW5EaWFnb25hbFJlbmRlcmluZyhkYXRhLCAwKSB8fFxuICAgICAgdmVyaWZ5QnJva2VuRGlhZ29uYWxSZW5kZXJpbmcoZGF0YSwgNCkgfHxcbiAgICAgIHZlcmlmeUJyb2tlbkRpYWdvbmFsUmVuZGVyaW5nKGRhdGEsIDgpO1xuICAgIHJlbGVhc2VDYW52YXMoY3R4KTtcbiAgICBjYW52YXNQb29sLnB1c2goY3R4LmNhbnZhcyk7XG4gIH1cblxuICByZXR1cm4gYnJva2VuRGlhZ29uYWxSZW5kZXJpbmdfO1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZXMgaWRlYWwgcmVzb2x1dGlvbiB0byB1c2UgZnJvbSB0aGUgc291cmNlIGluIG9yZGVyIHRvIGFjaGlldmVcbiAqIHBpeGVsIG1hcHBpbmcgYXMgY2xvc2UgYXMgcG9zc2libGUgdG8gMToxIGR1cmluZyByZXByb2plY3Rpb24uXG4gKiBUaGUgcmVzb2x1dGlvbiBpcyBjYWxjdWxhdGVkIHJlZ2FyZGxlc3Mgb2Ygd2hhdCByZXNvbHV0aW9uc1xuICogYXJlIGFjdHVhbGx5IGF2YWlsYWJsZSBpbiB0aGUgZGF0YXNldCAoVGlsZUdyaWQsIEltYWdlLCAuLi4pLlxuICpcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9wcm9qL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdH0gc291cmNlUHJvaiBTb3VyY2UgcHJvamVjdGlvbi5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9wcm9qL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdH0gdGFyZ2V0UHJvaiBUYXJnZXQgcHJvamVjdGlvbi5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IHRhcmdldENlbnRlciBUYXJnZXQgY2VudGVyLlxuICogQHBhcmFtIHtudW1iZXJ9IHRhcmdldFJlc29sdXRpb24gVGFyZ2V0IHJlc29sdXRpb24uXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBiZXN0IHJlc29sdXRpb24gdG8gdXNlLiBDYW4gYmUgKy1JbmZpbml0eSwgTmFOIG9yIDAuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjYWxjdWxhdGVTb3VyY2VSZXNvbHV0aW9uKFxuICBzb3VyY2VQcm9qLFxuICB0YXJnZXRQcm9qLFxuICB0YXJnZXRDZW50ZXIsXG4gIHRhcmdldFJlc29sdXRpb25cbikge1xuICBjb25zdCBzb3VyY2VDZW50ZXIgPSB0cmFuc2Zvcm0odGFyZ2V0Q2VudGVyLCB0YXJnZXRQcm9qLCBzb3VyY2VQcm9qKTtcblxuICAvLyBjYWxjdWxhdGUgdGhlIGlkZWFsIHJlc29sdXRpb24gb2YgdGhlIHNvdXJjZSBkYXRhXG4gIGxldCBzb3VyY2VSZXNvbHV0aW9uID0gZ2V0UG9pbnRSZXNvbHV0aW9uKFxuICAgIHRhcmdldFByb2osXG4gICAgdGFyZ2V0UmVzb2x1dGlvbixcbiAgICB0YXJnZXRDZW50ZXJcbiAgKTtcblxuICBjb25zdCB0YXJnZXRNZXRlcnNQZXJVbml0ID0gdGFyZ2V0UHJvai5nZXRNZXRlcnNQZXJVbml0KCk7XG4gIGlmICh0YXJnZXRNZXRlcnNQZXJVbml0ICE9PSB1bmRlZmluZWQpIHtcbiAgICBzb3VyY2VSZXNvbHV0aW9uICo9IHRhcmdldE1ldGVyc1BlclVuaXQ7XG4gIH1cbiAgY29uc3Qgc291cmNlTWV0ZXJzUGVyVW5pdCA9IHNvdXJjZVByb2ouZ2V0TWV0ZXJzUGVyVW5pdCgpO1xuICBpZiAoc291cmNlTWV0ZXJzUGVyVW5pdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgc291cmNlUmVzb2x1dGlvbiAvPSBzb3VyY2VNZXRlcnNQZXJVbml0O1xuICB9XG5cbiAgLy8gQmFzZWQgb24gdGhlIHByb2plY3Rpb24gcHJvcGVydGllcywgdGhlIHBvaW50IHJlc29sdXRpb24gYXQgdGhlIHNwZWNpZmllZFxuICAvLyBjb29yZGluYXRlcyBtYXkgYmUgc2xpZ2h0bHkgZGlmZmVyZW50LiBXZSBuZWVkIHRvIHJldmVyc2UtY29tcGVuc2F0ZSB0aGlzXG4gIC8vIGluIG9yZGVyIHRvIGFjaGlldmUgb3B0aW1hbCByZXN1bHRzLlxuXG4gIGNvbnN0IHNvdXJjZUV4dGVudCA9IHNvdXJjZVByb2ouZ2V0RXh0ZW50KCk7XG4gIGlmICghc291cmNlRXh0ZW50IHx8IGNvbnRhaW5zQ29vcmRpbmF0ZShzb3VyY2VFeHRlbnQsIHNvdXJjZUNlbnRlcikpIHtcbiAgICBjb25zdCBjb21wZW5zYXRpb25GYWN0b3IgPVxuICAgICAgZ2V0UG9pbnRSZXNvbHV0aW9uKHNvdXJjZVByb2osIHNvdXJjZVJlc29sdXRpb24sIHNvdXJjZUNlbnRlcikgL1xuICAgICAgc291cmNlUmVzb2x1dGlvbjtcbiAgICBpZiAoaXNGaW5pdGUoY29tcGVuc2F0aW9uRmFjdG9yKSAmJiBjb21wZW5zYXRpb25GYWN0b3IgPiAwKSB7XG4gICAgICBzb3VyY2VSZXNvbHV0aW9uIC89IGNvbXBlbnNhdGlvbkZhY3RvcjtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc291cmNlUmVzb2x1dGlvbjtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGVzIGlkZWFsIHJlc29sdXRpb24gdG8gdXNlIGZyb20gdGhlIHNvdXJjZSBpbiBvcmRlciB0byBhY2hpZXZlXG4gKiBwaXhlbCBtYXBwaW5nIGFzIGNsb3NlIGFzIHBvc3NpYmxlIHRvIDE6MSBkdXJpbmcgcmVwcm9qZWN0aW9uLlxuICogVGhlIHJlc29sdXRpb24gaXMgY2FsY3VsYXRlZCByZWdhcmRsZXNzIG9mIHdoYXQgcmVzb2x1dGlvbnNcbiAqIGFyZSBhY3R1YWxseSBhdmFpbGFibGUgaW4gdGhlIGRhdGFzZXQgKFRpbGVHcmlkLCBJbWFnZSwgLi4uKS5cbiAqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vcHJvai9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR9IHNvdXJjZVByb2ogU291cmNlIHByb2plY3Rpb24uXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vcHJvai9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR9IHRhcmdldFByb2ogVGFyZ2V0IHByb2plY3Rpb24uXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gdGFyZ2V0RXh0ZW50IFRhcmdldCBleHRlbnRcbiAqIEBwYXJhbSB7bnVtYmVyfSB0YXJnZXRSZXNvbHV0aW9uIFRhcmdldCByZXNvbHV0aW9uLlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgYmVzdCByZXNvbHV0aW9uIHRvIHVzZS4gQ2FuIGJlICstSW5maW5pdHksIE5hTiBvciAwLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlU291cmNlRXh0ZW50UmVzb2x1dGlvbihcbiAgc291cmNlUHJvaixcbiAgdGFyZ2V0UHJvaixcbiAgdGFyZ2V0RXh0ZW50LFxuICB0YXJnZXRSZXNvbHV0aW9uXG4pIHtcbiAgY29uc3QgdGFyZ2V0Q2VudGVyID0gZ2V0Q2VudGVyKHRhcmdldEV4dGVudCk7XG4gIGxldCBzb3VyY2VSZXNvbHV0aW9uID0gY2FsY3VsYXRlU291cmNlUmVzb2x1dGlvbihcbiAgICBzb3VyY2VQcm9qLFxuICAgIHRhcmdldFByb2osXG4gICAgdGFyZ2V0Q2VudGVyLFxuICAgIHRhcmdldFJlc29sdXRpb25cbiAgKTtcblxuICBpZiAoIWlzRmluaXRlKHNvdXJjZVJlc29sdXRpb24pIHx8IHNvdXJjZVJlc29sdXRpb24gPD0gMCkge1xuICAgIGZvckVhY2hDb3JuZXIodGFyZ2V0RXh0ZW50LCBmdW5jdGlvbiAoY29ybmVyKSB7XG4gICAgICBzb3VyY2VSZXNvbHV0aW9uID0gY2FsY3VsYXRlU291cmNlUmVzb2x1dGlvbihcbiAgICAgICAgc291cmNlUHJvaixcbiAgICAgICAgdGFyZ2V0UHJvaixcbiAgICAgICAgY29ybmVyLFxuICAgICAgICB0YXJnZXRSZXNvbHV0aW9uXG4gICAgICApO1xuICAgICAgcmV0dXJuIGlzRmluaXRlKHNvdXJjZVJlc29sdXRpb24pICYmIHNvdXJjZVJlc29sdXRpb24gPiAwO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHNvdXJjZVJlc29sdXRpb247XG59XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gSW1hZ2VFeHRlbnRcbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi9leHRlbnQuanNcIikuRXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICogQHByb3BlcnR5IHtpbXBvcnQoJy4vRGF0YVRpbGUuanMnKS5JbWFnZUxpa2V9IGltYWdlIEltYWdlLlxuICovXG5cbi8qKlxuICogUmVuZGVycyB0aGUgc291cmNlIGRhdGEgaW50byBuZXcgY2FudmFzIGJhc2VkIG9uIHRoZSB0cmlhbmd1bGF0aW9uLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCBXaWR0aCBvZiB0aGUgY2FudmFzLlxuICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCBIZWlnaHQgb2YgdGhlIGNhbnZhcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBwaXhlbFJhdGlvIFBpeGVsIHJhdGlvLlxuICogQHBhcmFtIHtudW1iZXJ9IHNvdXJjZVJlc29sdXRpb24gU291cmNlIHJlc29sdXRpb24uXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gc291cmNlRXh0ZW50IEV4dGVudCBvZiB0aGUgZGF0YSBzb3VyY2UuXG4gKiBAcGFyYW0ge251bWJlcn0gdGFyZ2V0UmVzb2x1dGlvbiBUYXJnZXQgcmVzb2x1dGlvbi5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9leHRlbnQuanNcIikuRXh0ZW50fSB0YXJnZXRFeHRlbnQgVGFyZ2V0IGV4dGVudC5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9yZXByb2ovVHJpYW5ndWxhdGlvbi5qc1wiKS5kZWZhdWx0fSB0cmlhbmd1bGF0aW9uIENhbGN1bGF0ZWQgdHJpYW5ndWxhdGlvbi5cbiAqIEBwYXJhbSB7QXJyYXk8SW1hZ2VFeHRlbnQ+fSBzb3VyY2VzIEFycmF5IG9mIHNvdXJjZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gZ3V0dGVyIEd1dHRlciBvZiB0aGUgc291cmNlcy5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JlbmRlckVkZ2VzXSBSZW5kZXIgcmVwcm9qZWN0aW9uIGVkZ2VzLlxuICogQHBhcmFtIHtib29sZWFufSBbaW50ZXJwb2xhdGVdIFVzZSBsaW5lYXIgaW50ZXJwb2xhdGlvbiB3aGVuIHJlc2FtcGxpbmcuXG4gKiBAcmV0dXJuIHtIVE1MQ2FudmFzRWxlbWVudH0gQ2FudmFzIHdpdGggcmVwcm9qZWN0ZWQgZGF0YS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbmRlcihcbiAgd2lkdGgsXG4gIGhlaWdodCxcbiAgcGl4ZWxSYXRpbyxcbiAgc291cmNlUmVzb2x1dGlvbixcbiAgc291cmNlRXh0ZW50LFxuICB0YXJnZXRSZXNvbHV0aW9uLFxuICB0YXJnZXRFeHRlbnQsXG4gIHRyaWFuZ3VsYXRpb24sXG4gIHNvdXJjZXMsXG4gIGd1dHRlcixcbiAgcmVuZGVyRWRnZXMsXG4gIGludGVycG9sYXRlXG4pIHtcbiAgY29uc3QgY29udGV4dCA9IGNyZWF0ZUNhbnZhc0NvbnRleHQyRChcbiAgICBNYXRoLnJvdW5kKHBpeGVsUmF0aW8gKiB3aWR0aCksXG4gICAgTWF0aC5yb3VuZChwaXhlbFJhdGlvICogaGVpZ2h0KSxcbiAgICBjYW52YXNQb29sXG4gICk7XG5cbiAgaWYgKCFpbnRlcnBvbGF0ZSkge1xuICAgIGNvbnRleHQuaW1hZ2VTbW9vdGhpbmdFbmFibGVkID0gZmFsc2U7XG4gIH1cblxuICBpZiAoc291cmNlcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gY29udGV4dC5jYW52YXM7XG4gIH1cblxuICBjb250ZXh0LnNjYWxlKHBpeGVsUmF0aW8sIHBpeGVsUmF0aW8pO1xuXG4gIGZ1bmN0aW9uIHBpeGVsUm91bmQodmFsdWUpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZCh2YWx1ZSAqIHBpeGVsUmF0aW8pIC8gcGl4ZWxSYXRpbztcbiAgfVxuXG4gIGNvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ2xpZ2h0ZXInO1xuXG4gIGNvbnN0IHNvdXJjZURhdGFFeHRlbnQgPSBjcmVhdGVFbXB0eSgpO1xuICBzb3VyY2VzLmZvckVhY2goZnVuY3Rpb24gKHNyYywgaSwgYXJyKSB7XG4gICAgZXh0ZW5kKHNvdXJjZURhdGFFeHRlbnQsIHNyYy5leHRlbnQpO1xuICB9KTtcblxuICBjb25zdCBjYW52YXNXaWR0aEluVW5pdHMgPSBnZXRXaWR0aChzb3VyY2VEYXRhRXh0ZW50KTtcbiAgY29uc3QgY2FudmFzSGVpZ2h0SW5Vbml0cyA9IGdldEhlaWdodChzb3VyY2VEYXRhRXh0ZW50KTtcbiAgY29uc3Qgc3RpdGNoQ29udGV4dCA9IGNyZWF0ZUNhbnZhc0NvbnRleHQyRChcbiAgICBNYXRoLnJvdW5kKChwaXhlbFJhdGlvICogY2FudmFzV2lkdGhJblVuaXRzKSAvIHNvdXJjZVJlc29sdXRpb24pLFxuICAgIE1hdGgucm91bmQoKHBpeGVsUmF0aW8gKiBjYW52YXNIZWlnaHRJblVuaXRzKSAvIHNvdXJjZVJlc29sdXRpb24pLFxuICAgIGNhbnZhc1Bvb2xcbiAgKTtcblxuICBpZiAoIWludGVycG9sYXRlKSB7XG4gICAgc3RpdGNoQ29udGV4dC5pbWFnZVNtb290aGluZ0VuYWJsZWQgPSBmYWxzZTtcbiAgfVxuXG4gIGNvbnN0IHN0aXRjaFNjYWxlID0gcGl4ZWxSYXRpbyAvIHNvdXJjZVJlc29sdXRpb247XG5cbiAgc291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChzcmMsIGksIGFycikge1xuICAgIGNvbnN0IHhQb3MgPSBzcmMuZXh0ZW50WzBdIC0gc291cmNlRGF0YUV4dGVudFswXTtcbiAgICBjb25zdCB5UG9zID0gLShzcmMuZXh0ZW50WzNdIC0gc291cmNlRGF0YUV4dGVudFszXSk7XG4gICAgY29uc3Qgc3JjV2lkdGggPSBnZXRXaWR0aChzcmMuZXh0ZW50KTtcbiAgICBjb25zdCBzcmNIZWlnaHQgPSBnZXRIZWlnaHQoc3JjLmV4dGVudCk7XG5cbiAgICAvLyBUaGlzIHRlc3Qgc2hvdWxkIG5ldmVyIGZhaWwgLS0gYnV0IGl0IGRvZXMuIE5lZWQgdG8gZmluZCBhIGZpeCB0aGUgdXBzdHJlYW0gY29uZGl0aW9uXG4gICAgaWYgKHNyYy5pbWFnZS53aWR0aCA+IDAgJiYgc3JjLmltYWdlLmhlaWdodCA+IDApIHtcbiAgICAgIHN0aXRjaENvbnRleHQuZHJhd0ltYWdlKFxuICAgICAgICBzcmMuaW1hZ2UsXG4gICAgICAgIGd1dHRlcixcbiAgICAgICAgZ3V0dGVyLFxuICAgICAgICBzcmMuaW1hZ2Uud2lkdGggLSAyICogZ3V0dGVyLFxuICAgICAgICBzcmMuaW1hZ2UuaGVpZ2h0IC0gMiAqIGd1dHRlcixcbiAgICAgICAgeFBvcyAqIHN0aXRjaFNjYWxlLFxuICAgICAgICB5UG9zICogc3RpdGNoU2NhbGUsXG4gICAgICAgIHNyY1dpZHRoICogc3RpdGNoU2NhbGUsXG4gICAgICAgIHNyY0hlaWdodCAqIHN0aXRjaFNjYWxlXG4gICAgICApO1xuICAgIH1cbiAgfSk7XG5cbiAgY29uc3QgdGFyZ2V0VG9wTGVmdCA9IGdldFRvcExlZnQodGFyZ2V0RXh0ZW50KTtcblxuICB0cmlhbmd1bGF0aW9uLmdldFRyaWFuZ2xlcygpLmZvckVhY2goZnVuY3Rpb24gKHRyaWFuZ2xlLCBpLCBhcnIpIHtcbiAgICAvKiBDYWxjdWxhdGUgYWZmaW5lIHRyYW5zZm9ybSAoc3JjIC0+IGRzdClcbiAgICAgKiBSZXN1bHRpbmcgbWF0cml4IGNhbiBiZSB1c2VkIHRvIHRyYW5zZm9ybSBjb29yZGluYXRlXG4gICAgICogZnJvbSBgc291cmNlUHJvamVjdGlvbmAgdG8gZGVzdGluYXRpb24gcGl4ZWxzLlxuICAgICAqXG4gICAgICogVG8gb3B0aW1pemUgbnVtYmVyIG9mIGNvbnRleHQgY2FsbHMgYW5kIGluY3JlYXNlIG51bWVyaWNhbCBzdGFiaWxpdHksXG4gICAgICogd2UgYWxzbyBkbyB0aGUgZm9sbG93aW5nIG9wZXJhdGlvbnM6XG4gICAgICogdHJhbnMoLXRvcExlZnRFeHRlbnRDb3JuZXIpLCBzY2FsZSgxIC8gdGFyZ2V0UmVzb2x1dGlvbiksIHNjYWxlKDEsIC0xKVxuICAgICAqIGhlcmUgYmVmb3JlIHNvbHZpbmcgdGhlIGxpbmVhciBzeXN0ZW0gc28gW3VpLCB2aV0gYXJlIHBpeGVsIGNvb3JkaW5hdGVzLlxuICAgICAqXG4gICAgICogU3JjIHBvaW50czogeGksIHlpXG4gICAgICogRHN0IHBvaW50czogdWksIHZpXG4gICAgICogQWZmaW5lIGNvZWZmaWNpZW50czogYWlqXG4gICAgICpcbiAgICAgKiB8IHgwIHkwIDEgIDAgIDAgMCB8ICAgfGEwMHwgICB8dTB8XG4gICAgICogfCB4MSB5MSAxICAwICAwIDAgfCAgIHxhMDF8ICAgfHUxfFxuICAgICAqIHwgeDIgeTIgMSAgMCAgMCAwIHwgeCB8YTAyfCA9IHx1MnxcbiAgICAgKiB8ICAwICAwIDAgeDAgeTAgMSB8ICAgfGExMHwgICB8djB8XG4gICAgICogfCAgMCAgMCAwIHgxIHkxIDEgfCAgIHxhMTF8ICAgfHYxfFxuICAgICAqIHwgIDAgIDAgMCB4MiB5MiAxIHwgICB8YTEyfCAgIHx2MnxcbiAgICAgKi9cbiAgICBjb25zdCBzb3VyY2UgPSB0cmlhbmdsZS5zb3VyY2U7XG4gICAgY29uc3QgdGFyZ2V0ID0gdHJpYW5nbGUudGFyZ2V0O1xuICAgIGxldCB4MCA9IHNvdXJjZVswXVswXSxcbiAgICAgIHkwID0gc291cmNlWzBdWzFdO1xuICAgIGxldCB4MSA9IHNvdXJjZVsxXVswXSxcbiAgICAgIHkxID0gc291cmNlWzFdWzFdO1xuICAgIGxldCB4MiA9IHNvdXJjZVsyXVswXSxcbiAgICAgIHkyID0gc291cmNlWzJdWzFdO1xuICAgIC8vIE1ha2Ugc3VyZSB0aGF0IGV2ZXJ5dGhpbmcgaXMgb24gcGl4ZWwgYm91bmRhcmllc1xuICAgIGNvbnN0IHUwID0gcGl4ZWxSb3VuZCgodGFyZ2V0WzBdWzBdIC0gdGFyZ2V0VG9wTGVmdFswXSkgLyB0YXJnZXRSZXNvbHV0aW9uKTtcbiAgICBjb25zdCB2MCA9IHBpeGVsUm91bmQoXG4gICAgICAtKHRhcmdldFswXVsxXSAtIHRhcmdldFRvcExlZnRbMV0pIC8gdGFyZ2V0UmVzb2x1dGlvblxuICAgICk7XG4gICAgY29uc3QgdTEgPSBwaXhlbFJvdW5kKCh0YXJnZXRbMV1bMF0gLSB0YXJnZXRUb3BMZWZ0WzBdKSAvIHRhcmdldFJlc29sdXRpb24pO1xuICAgIGNvbnN0IHYxID0gcGl4ZWxSb3VuZChcbiAgICAgIC0odGFyZ2V0WzFdWzFdIC0gdGFyZ2V0VG9wTGVmdFsxXSkgLyB0YXJnZXRSZXNvbHV0aW9uXG4gICAgKTtcbiAgICBjb25zdCB1MiA9IHBpeGVsUm91bmQoKHRhcmdldFsyXVswXSAtIHRhcmdldFRvcExlZnRbMF0pIC8gdGFyZ2V0UmVzb2x1dGlvbik7XG4gICAgY29uc3QgdjIgPSBwaXhlbFJvdW5kKFxuICAgICAgLSh0YXJnZXRbMl1bMV0gLSB0YXJnZXRUb3BMZWZ0WzFdKSAvIHRhcmdldFJlc29sdXRpb25cbiAgICApO1xuXG4gICAgLy8gU2hpZnQgYWxsIHRoZSBzb3VyY2UgcG9pbnRzIHRvIGltcHJvdmUgbnVtZXJpY2FsIHN0YWJpbGl0eVxuICAgIC8vIG9mIGFsbCB0aGUgc3Vic2VxdWVudCBjYWxjdWxhdGlvbnMuIFRoZSBbeDAsIHkwXSBpcyB1c2VkIGhlcmUuXG4gICAgLy8gVGhpcyBpcyBhbHNvIHVzZWQgdG8gc2ltcGxpZnkgdGhlIGxpbmVhciBzeXN0ZW0uXG4gICAgY29uc3Qgc291cmNlTnVtZXJpY2FsU2hpZnRYID0geDA7XG4gICAgY29uc3Qgc291cmNlTnVtZXJpY2FsU2hpZnRZID0geTA7XG4gICAgeDAgPSAwO1xuICAgIHkwID0gMDtcbiAgICB4MSAtPSBzb3VyY2VOdW1lcmljYWxTaGlmdFg7XG4gICAgeTEgLT0gc291cmNlTnVtZXJpY2FsU2hpZnRZO1xuICAgIHgyIC09IHNvdXJjZU51bWVyaWNhbFNoaWZ0WDtcbiAgICB5MiAtPSBzb3VyY2VOdW1lcmljYWxTaGlmdFk7XG5cbiAgICBjb25zdCBhdWdtZW50ZWRNYXRyaXggPSBbXG4gICAgICBbeDEsIHkxLCAwLCAwLCB1MSAtIHUwXSxcbiAgICAgIFt4MiwgeTIsIDAsIDAsIHUyIC0gdTBdLFxuICAgICAgWzAsIDAsIHgxLCB5MSwgdjEgLSB2MF0sXG4gICAgICBbMCwgMCwgeDIsIHkyLCB2MiAtIHYwXSxcbiAgICBdO1xuICAgIGNvbnN0IGFmZmluZUNvZWZzID0gc29sdmVMaW5lYXJTeXN0ZW0oYXVnbWVudGVkTWF0cml4KTtcbiAgICBpZiAoIWFmZmluZUNvZWZzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29udGV4dC5zYXZlKCk7XG4gICAgY29udGV4dC5iZWdpblBhdGgoKTtcblxuICAgIGlmIChpc0Jyb2tlbkRpYWdvbmFsUmVuZGVyaW5nKCkgfHwgIWludGVycG9sYXRlKSB7XG4gICAgICAvLyBNYWtlIHN1cmUgdGhhdCBhbGwgbGluZXMgYXJlIGhvcml6b250YWwgb3IgdmVydGljYWxcbiAgICAgIGNvbnRleHQubW92ZVRvKHUxLCB2MSk7XG4gICAgICAvLyBUaGlzIGlzIHRoZSBkaWFnb25hbCBsaW5lLiBEbyBpdCBpbiA0IHN0ZXBzXG4gICAgICBjb25zdCBzdGVwcyA9IDQ7XG4gICAgICBjb25zdCB1ZCA9IHUwIC0gdTE7XG4gICAgICBjb25zdCB2ZCA9IHYwIC0gdjE7XG4gICAgICBmb3IgKGxldCBzdGVwID0gMDsgc3RlcCA8IHN0ZXBzOyBzdGVwKyspIHtcbiAgICAgICAgLy8gR28gaG9yaXpvbnRhbGx5XG4gICAgICAgIGNvbnRleHQubGluZVRvKFxuICAgICAgICAgIHUxICsgcGl4ZWxSb3VuZCgoKHN0ZXAgKyAxKSAqIHVkKSAvIHN0ZXBzKSxcbiAgICAgICAgICB2MSArIHBpeGVsUm91bmQoKHN0ZXAgKiB2ZCkgLyAoc3RlcHMgLSAxKSlcbiAgICAgICAgKTtcbiAgICAgICAgLy8gR28gdmVydGljYWxseVxuICAgICAgICBpZiAoc3RlcCAhPSBzdGVwcyAtIDEpIHtcbiAgICAgICAgICBjb250ZXh0LmxpbmVUbyhcbiAgICAgICAgICAgIHUxICsgcGl4ZWxSb3VuZCgoKHN0ZXAgKyAxKSAqIHVkKSAvIHN0ZXBzKSxcbiAgICAgICAgICAgIHYxICsgcGl4ZWxSb3VuZCgoKHN0ZXAgKyAxKSAqIHZkKSAvIChzdGVwcyAtIDEpKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIFdlIGFyZSBhbG1vc3QgYXQgdTByLCB2MHJcbiAgICAgIGNvbnRleHQubGluZVRvKHUyLCB2Mik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRleHQubW92ZVRvKHUxLCB2MSk7XG4gICAgICBjb250ZXh0LmxpbmVUbyh1MCwgdjApO1xuICAgICAgY29udGV4dC5saW5lVG8odTIsIHYyKTtcbiAgICB9XG5cbiAgICBjb250ZXh0LmNsaXAoKTtcblxuICAgIGNvbnRleHQudHJhbnNmb3JtKFxuICAgICAgYWZmaW5lQ29lZnNbMF0sXG4gICAgICBhZmZpbmVDb2Vmc1syXSxcbiAgICAgIGFmZmluZUNvZWZzWzFdLFxuICAgICAgYWZmaW5lQ29lZnNbM10sXG4gICAgICB1MCxcbiAgICAgIHYwXG4gICAgKTtcblxuICAgIGNvbnRleHQudHJhbnNsYXRlKFxuICAgICAgc291cmNlRGF0YUV4dGVudFswXSAtIHNvdXJjZU51bWVyaWNhbFNoaWZ0WCxcbiAgICAgIHNvdXJjZURhdGFFeHRlbnRbM10gLSBzb3VyY2VOdW1lcmljYWxTaGlmdFlcbiAgICApO1xuXG4gICAgY29udGV4dC5zY2FsZShcbiAgICAgIHNvdXJjZVJlc29sdXRpb24gLyBwaXhlbFJhdGlvLFxuICAgICAgLXNvdXJjZVJlc29sdXRpb24gLyBwaXhlbFJhdGlvXG4gICAgKTtcblxuICAgIGNvbnRleHQuZHJhd0ltYWdlKHN0aXRjaENvbnRleHQuY2FudmFzLCAwLCAwKTtcbiAgICBjb250ZXh0LnJlc3RvcmUoKTtcbiAgfSk7XG5cbiAgcmVsZWFzZUNhbnZhcyhzdGl0Y2hDb250ZXh0KTtcbiAgY2FudmFzUG9vbC5wdXNoKHN0aXRjaENvbnRleHQuY2FudmFzKTtcblxuICBpZiAocmVuZGVyRWRnZXMpIHtcbiAgICBjb250ZXh0LnNhdmUoKTtcblxuICAgIGNvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ3NvdXJjZS1vdmVyJztcbiAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gJ2JsYWNrJztcbiAgICBjb250ZXh0LmxpbmVXaWR0aCA9IDE7XG5cbiAgICB0cmlhbmd1bGF0aW9uLmdldFRyaWFuZ2xlcygpLmZvckVhY2goZnVuY3Rpb24gKHRyaWFuZ2xlLCBpLCBhcnIpIHtcbiAgICAgIGNvbnN0IHRhcmdldCA9IHRyaWFuZ2xlLnRhcmdldDtcbiAgICAgIGNvbnN0IHUwID0gKHRhcmdldFswXVswXSAtIHRhcmdldFRvcExlZnRbMF0pIC8gdGFyZ2V0UmVzb2x1dGlvbjtcbiAgICAgIGNvbnN0IHYwID0gLSh0YXJnZXRbMF1bMV0gLSB0YXJnZXRUb3BMZWZ0WzFdKSAvIHRhcmdldFJlc29sdXRpb247XG4gICAgICBjb25zdCB1MSA9ICh0YXJnZXRbMV1bMF0gLSB0YXJnZXRUb3BMZWZ0WzBdKSAvIHRhcmdldFJlc29sdXRpb247XG4gICAgICBjb25zdCB2MSA9IC0odGFyZ2V0WzFdWzFdIC0gdGFyZ2V0VG9wTGVmdFsxXSkgLyB0YXJnZXRSZXNvbHV0aW9uO1xuICAgICAgY29uc3QgdTIgPSAodGFyZ2V0WzJdWzBdIC0gdGFyZ2V0VG9wTGVmdFswXSkgLyB0YXJnZXRSZXNvbHV0aW9uO1xuICAgICAgY29uc3QgdjIgPSAtKHRhcmdldFsyXVsxXSAtIHRhcmdldFRvcExlZnRbMV0pIC8gdGFyZ2V0UmVzb2x1dGlvbjtcblxuICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgIGNvbnRleHQubW92ZVRvKHUxLCB2MSk7XG4gICAgICBjb250ZXh0LmxpbmVUbyh1MCwgdjApO1xuICAgICAgY29udGV4dC5saW5lVG8odTIsIHYyKTtcbiAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICBjb250ZXh0LnN0cm9rZSgpO1xuICAgIH0pO1xuXG4gICAgY29udGV4dC5yZXN0b3JlKCk7XG4gIH1cbiAgcmV0dXJuIGNvbnRleHQuY2FudmFzO1xufVxuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3JlcHJvai9UaWxlXG4gKi9cbmltcG9ydCB7RVJST1JfVEhSRVNIT0xEfSBmcm9tICcuL2NvbW1vbi5qcyc7XG5cbmltcG9ydCBFdmVudFR5cGUgZnJvbSAnLi4vZXZlbnRzL0V2ZW50VHlwZS5qcyc7XG5pbXBvcnQgVGlsZSBmcm9tICcuLi9UaWxlLmpzJztcbmltcG9ydCBUaWxlU3RhdGUgZnJvbSAnLi4vVGlsZVN0YXRlLmpzJztcbmltcG9ydCBUcmlhbmd1bGF0aW9uIGZyb20gJy4vVHJpYW5ndWxhdGlvbi5qcyc7XG5pbXBvcnQge1xuICBjYWxjdWxhdGVTb3VyY2VFeHRlbnRSZXNvbHV0aW9uLFxuICBjYW52YXNQb29sLFxuICByZW5kZXIgYXMgcmVuZGVyUmVwcm9qZWN0ZWQsXG59IGZyb20gJy4uL3JlcHJvai5qcyc7XG5pbXBvcnQge2NsYW1wfSBmcm9tICcuLi9tYXRoLmpzJztcbmltcG9ydCB7Z2V0QXJlYSwgZ2V0SW50ZXJzZWN0aW9ufSBmcm9tICcuLi9leHRlbnQuanMnO1xuaW1wb3J0IHtsaXN0ZW4sIHVubGlzdGVuQnlLZXl9IGZyb20gJy4uL2V2ZW50cy5qcyc7XG5pbXBvcnQge3JlbGVhc2VDYW52YXN9IGZyb20gJy4uL2RvbS5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYge2Z1bmN0aW9uKG51bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlcikgOiAoaW1wb3J0KFwiLi4vSW1hZ2VUaWxlLmpzXCIpLmRlZmF1bHQpfSBGdW5jdGlvblR5cGVcbiAqL1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIENsYXNzIGVuY2Fwc3VsYXRpbmcgc2luZ2xlIHJlcHJvamVjdGVkIHRpbGUuXG4gKiBTZWUge0BsaW5rIG1vZHVsZTpvbC9zb3VyY2UvVGlsZUltYWdlflRpbGVJbWFnZX0uXG4gKlxuICovXG5jbGFzcyBSZXByb2pUaWxlIGV4dGVuZHMgVGlsZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3Byb2ovUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0fSBzb3VyY2VQcm9qIFNvdXJjZSBwcm9qZWN0aW9uLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3RpbGVncmlkL1RpbGVHcmlkLmpzXCIpLmRlZmF1bHR9IHNvdXJjZVRpbGVHcmlkIFNvdXJjZSB0aWxlIGdyaWQuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcHJvai9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR9IHRhcmdldFByb2ogVGFyZ2V0IHByb2plY3Rpb24uXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vdGlsZWdyaWQvVGlsZUdyaWQuanNcIikuZGVmYXVsdH0gdGFyZ2V0VGlsZUdyaWQgVGFyZ2V0IHRpbGUgZ3JpZC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi90aWxlY29vcmQuanNcIikuVGlsZUNvb3JkfSB0aWxlQ29vcmQgQ29vcmRpbmF0ZSBvZiB0aGUgdGlsZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi90aWxlY29vcmQuanNcIikuVGlsZUNvb3JkfSB3cmFwcGVkVGlsZUNvb3JkIENvb3JkaW5hdGUgb2YgdGhlIHRpbGUgd3JhcHBlZCBpbiBYLlxuICAgKiBAcGFyYW0ge251bWJlcn0gcGl4ZWxSYXRpbyBQaXhlbCByYXRpby5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGd1dHRlciBHdXR0ZXIgb2YgdGhlIHNvdXJjZSB0aWxlcy5cbiAgICogQHBhcmFtIHtGdW5jdGlvblR5cGV9IGdldFRpbGVGdW5jdGlvblxuICAgKiAgICAgRnVuY3Rpb24gcmV0dXJuaW5nIHNvdXJjZSB0aWxlcyAoeiwgeCwgeSwgcGl4ZWxSYXRpbykuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbZXJyb3JUaHJlc2hvbGRdIEFjY2VwdGFibGUgcmVwcm9qZWN0aW9uIGVycm9yIChpbiBweCkuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JlbmRlckVkZ2VzXSBSZW5kZXIgcmVwcm9qZWN0aW9uIGVkZ2VzLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpbnRlcnBvbGF0ZV0gVXNlIGxpbmVhciBpbnRlcnBvbGF0aW9uIHdoZW4gcmVzYW1wbGluZy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKFxuICAgIHNvdXJjZVByb2osXG4gICAgc291cmNlVGlsZUdyaWQsXG4gICAgdGFyZ2V0UHJvaixcbiAgICB0YXJnZXRUaWxlR3JpZCxcbiAgICB0aWxlQ29vcmQsXG4gICAgd3JhcHBlZFRpbGVDb29yZCxcbiAgICBwaXhlbFJhdGlvLFxuICAgIGd1dHRlcixcbiAgICBnZXRUaWxlRnVuY3Rpb24sXG4gICAgZXJyb3JUaHJlc2hvbGQsXG4gICAgcmVuZGVyRWRnZXMsXG4gICAgaW50ZXJwb2xhdGVcbiAgKSB7XG4gICAgc3VwZXIodGlsZUNvb3JkLCBUaWxlU3RhdGUuSURMRSwge2ludGVycG9sYXRlOiAhIWludGVycG9sYXRlfSk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMucmVuZGVyRWRnZXNfID0gcmVuZGVyRWRnZXMgIT09IHVuZGVmaW5lZCA/IHJlbmRlckVkZ2VzIDogZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5waXhlbFJhdGlvXyA9IHBpeGVsUmF0aW87XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5ndXR0ZXJfID0gZ3V0dGVyO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7SFRNTENhbnZhc0VsZW1lbnR9XG4gICAgICovXG4gICAgdGhpcy5jYW52YXNfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL3RpbGVncmlkL1RpbGVHcmlkLmpzXCIpLmRlZmF1bHR9XG4gICAgICovXG4gICAgdGhpcy5zb3VyY2VUaWxlR3JpZF8gPSBzb3VyY2VUaWxlR3JpZDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL3RpbGVncmlkL1RpbGVHcmlkLmpzXCIpLmRlZmF1bHR9XG4gICAgICovXG4gICAgdGhpcy50YXJnZXRUaWxlR3JpZF8gPSB0YXJnZXRUaWxlR3JpZDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL3RpbGVjb29yZC5qc1wiKS5UaWxlQ29vcmR9XG4gICAgICovXG4gICAgdGhpcy53cmFwcGVkVGlsZUNvb3JkXyA9IHdyYXBwZWRUaWxlQ29vcmQgPyB3cmFwcGVkVGlsZUNvb3JkIDogdGlsZUNvb3JkO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7IUFycmF5PGltcG9ydChcIi4uL0ltYWdlVGlsZS5qc1wiKS5kZWZhdWx0Pn1cbiAgICAgKi9cbiAgICB0aGlzLnNvdXJjZVRpbGVzXyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7P0FycmF5PGltcG9ydChcIi4uL2V2ZW50cy5qc1wiKS5FdmVudHNLZXk+fVxuICAgICAqL1xuICAgIHRoaXMuc291cmNlc0xpc3RlbmVyS2V5c18gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuc291cmNlWl8gPSAwO1xuXG4gICAgY29uc3QgdGFyZ2V0RXh0ZW50ID0gdGFyZ2V0VGlsZUdyaWQuZ2V0VGlsZUNvb3JkRXh0ZW50KFxuICAgICAgdGhpcy53cmFwcGVkVGlsZUNvb3JkX1xuICAgICk7XG4gICAgY29uc3QgbWF4VGFyZ2V0RXh0ZW50ID0gdGhpcy50YXJnZXRUaWxlR3JpZF8uZ2V0RXh0ZW50KCk7XG4gICAgbGV0IG1heFNvdXJjZUV4dGVudCA9IHRoaXMuc291cmNlVGlsZUdyaWRfLmdldEV4dGVudCgpO1xuXG4gICAgY29uc3QgbGltaXRlZFRhcmdldEV4dGVudCA9IG1heFRhcmdldEV4dGVudFxuICAgICAgPyBnZXRJbnRlcnNlY3Rpb24odGFyZ2V0RXh0ZW50LCBtYXhUYXJnZXRFeHRlbnQpXG4gICAgICA6IHRhcmdldEV4dGVudDtcblxuICAgIGlmIChnZXRBcmVhKGxpbWl0ZWRUYXJnZXRFeHRlbnQpID09PSAwKSB7XG4gICAgICAvLyBUaWxlIGlzIGNvbXBsZXRlbHkgb3V0c2lkZSByYW5nZSAtPiBFTVBUWVxuICAgICAgLy8gVE9ETzogaXMgaXQgYWN0dWFsbHkgY29ycmVjdCB0aGF0IHRoZSBzb3VyY2UgZXZlbiBjcmVhdGVzIHRoZSB0aWxlID9cbiAgICAgIHRoaXMuc3RhdGUgPSBUaWxlU3RhdGUuRU1QVFk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qgc291cmNlUHJvakV4dGVudCA9IHNvdXJjZVByb2ouZ2V0RXh0ZW50KCk7XG4gICAgaWYgKHNvdXJjZVByb2pFeHRlbnQpIHtcbiAgICAgIGlmICghbWF4U291cmNlRXh0ZW50KSB7XG4gICAgICAgIG1heFNvdXJjZUV4dGVudCA9IHNvdXJjZVByb2pFeHRlbnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtYXhTb3VyY2VFeHRlbnQgPSBnZXRJbnRlcnNlY3Rpb24obWF4U291cmNlRXh0ZW50LCBzb3VyY2VQcm9qRXh0ZW50KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCB0YXJnZXRSZXNvbHV0aW9uID0gdGFyZ2V0VGlsZUdyaWQuZ2V0UmVzb2x1dGlvbihcbiAgICAgIHRoaXMud3JhcHBlZFRpbGVDb29yZF9bMF1cbiAgICApO1xuXG4gICAgY29uc3Qgc291cmNlUmVzb2x1dGlvbiA9IGNhbGN1bGF0ZVNvdXJjZUV4dGVudFJlc29sdXRpb24oXG4gICAgICBzb3VyY2VQcm9qLFxuICAgICAgdGFyZ2V0UHJvaixcbiAgICAgIGxpbWl0ZWRUYXJnZXRFeHRlbnQsXG4gICAgICB0YXJnZXRSZXNvbHV0aW9uXG4gICAgKTtcblxuICAgIGlmICghaXNGaW5pdGUoc291cmNlUmVzb2x1dGlvbikgfHwgc291cmNlUmVzb2x1dGlvbiA8PSAwKSB7XG4gICAgICAvLyBpbnZhbGlkIHNvdXJjZVJlc29sdXRpb24gLT4gRU1QVFlcbiAgICAgIC8vIHByb2JhYmx5IGVkZ2VzIG9mIHRoZSBwcm9qZWN0aW9ucyB3aGVuIG5vIGV4dGVudCBpcyBkZWZpbmVkXG4gICAgICB0aGlzLnN0YXRlID0gVGlsZVN0YXRlLkVNUFRZO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGVycm9yVGhyZXNob2xkSW5QaXhlbHMgPVxuICAgICAgZXJyb3JUaHJlc2hvbGQgIT09IHVuZGVmaW5lZCA/IGVycm9yVGhyZXNob2xkIDogRVJST1JfVEhSRVNIT0xEO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7IWltcG9ydChcIi4vVHJpYW5ndWxhdGlvbi5qc1wiKS5kZWZhdWx0fVxuICAgICAqL1xuICAgIHRoaXMudHJpYW5ndWxhdGlvbl8gPSBuZXcgVHJpYW5ndWxhdGlvbihcbiAgICAgIHNvdXJjZVByb2osXG4gICAgICB0YXJnZXRQcm9qLFxuICAgICAgbGltaXRlZFRhcmdldEV4dGVudCxcbiAgICAgIG1heFNvdXJjZUV4dGVudCxcbiAgICAgIHNvdXJjZVJlc29sdXRpb24gKiBlcnJvclRocmVzaG9sZEluUGl4ZWxzLFxuICAgICAgdGFyZ2V0UmVzb2x1dGlvblxuICAgICk7XG5cbiAgICBpZiAodGhpcy50cmlhbmd1bGF0aW9uXy5nZXRUcmlhbmdsZXMoKS5sZW5ndGggPT09IDApIHtcbiAgICAgIC8vIG5vIHZhbGlkIHRyaWFuZ2xlcyAtPiBFTVBUWVxuICAgICAgdGhpcy5zdGF0ZSA9IFRpbGVTdGF0ZS5FTVBUWTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnNvdXJjZVpfID0gc291cmNlVGlsZUdyaWQuZ2V0WkZvclJlc29sdXRpb24oc291cmNlUmVzb2x1dGlvbik7XG4gICAgbGV0IHNvdXJjZUV4dGVudCA9IHRoaXMudHJpYW5ndWxhdGlvbl8uY2FsY3VsYXRlU291cmNlRXh0ZW50KCk7XG5cbiAgICBpZiAobWF4U291cmNlRXh0ZW50KSB7XG4gICAgICBpZiAoc291cmNlUHJvai5jYW5XcmFwWCgpKSB7XG4gICAgICAgIHNvdXJjZUV4dGVudFsxXSA9IGNsYW1wKFxuICAgICAgICAgIHNvdXJjZUV4dGVudFsxXSxcbiAgICAgICAgICBtYXhTb3VyY2VFeHRlbnRbMV0sXG4gICAgICAgICAgbWF4U291cmNlRXh0ZW50WzNdXG4gICAgICAgICk7XG4gICAgICAgIHNvdXJjZUV4dGVudFszXSA9IGNsYW1wKFxuICAgICAgICAgIHNvdXJjZUV4dGVudFszXSxcbiAgICAgICAgICBtYXhTb3VyY2VFeHRlbnRbMV0sXG4gICAgICAgICAgbWF4U291cmNlRXh0ZW50WzNdXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzb3VyY2VFeHRlbnQgPSBnZXRJbnRlcnNlY3Rpb24oc291cmNlRXh0ZW50LCBtYXhTb3VyY2VFeHRlbnQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghZ2V0QXJlYShzb3VyY2VFeHRlbnQpKSB7XG4gICAgICB0aGlzLnN0YXRlID0gVGlsZVN0YXRlLkVNUFRZO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBzb3VyY2VSYW5nZSA9IHNvdXJjZVRpbGVHcmlkLmdldFRpbGVSYW5nZUZvckV4dGVudEFuZFooXG4gICAgICAgIHNvdXJjZUV4dGVudCxcbiAgICAgICAgdGhpcy5zb3VyY2VaX1xuICAgICAgKTtcblxuICAgICAgZm9yIChsZXQgc3JjWCA9IHNvdXJjZVJhbmdlLm1pblg7IHNyY1ggPD0gc291cmNlUmFuZ2UubWF4WDsgc3JjWCsrKSB7XG4gICAgICAgIGZvciAobGV0IHNyY1kgPSBzb3VyY2VSYW5nZS5taW5ZOyBzcmNZIDw9IHNvdXJjZVJhbmdlLm1heFk7IHNyY1krKykge1xuICAgICAgICAgIGNvbnN0IHRpbGUgPSBnZXRUaWxlRnVuY3Rpb24odGhpcy5zb3VyY2VaXywgc3JjWCwgc3JjWSwgcGl4ZWxSYXRpbyk7XG4gICAgICAgICAgaWYgKHRpbGUpIHtcbiAgICAgICAgICAgIHRoaXMuc291cmNlVGlsZXNfLnB1c2godGlsZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnNvdXJjZVRpbGVzXy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFRpbGVTdGF0ZS5FTVBUWTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBIVE1MIENhbnZhcyBlbGVtZW50IGZvciB0aGlzIHRpbGUuXG4gICAqIEByZXR1cm4ge0hUTUxDYW52YXNFbGVtZW50fSBDYW52YXMuXG4gICAqL1xuICBnZXRJbWFnZSgpIHtcbiAgICByZXR1cm4gdGhpcy5jYW52YXNfO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICByZXByb2plY3RfKCkge1xuICAgIGNvbnN0IHNvdXJjZXMgPSBbXTtcbiAgICB0aGlzLnNvdXJjZVRpbGVzXy5mb3JFYWNoKCh0aWxlKSA9PiB7XG4gICAgICBpZiAodGlsZSAmJiB0aWxlLmdldFN0YXRlKCkgPT0gVGlsZVN0YXRlLkxPQURFRCkge1xuICAgICAgICBzb3VyY2VzLnB1c2goe1xuICAgICAgICAgIGV4dGVudDogdGhpcy5zb3VyY2VUaWxlR3JpZF8uZ2V0VGlsZUNvb3JkRXh0ZW50KHRpbGUudGlsZUNvb3JkKSxcbiAgICAgICAgICBpbWFnZTogdGlsZS5nZXRJbWFnZSgpLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLnNvdXJjZVRpbGVzXy5sZW5ndGggPSAwO1xuXG4gICAgaWYgKHNvdXJjZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aGlzLnN0YXRlID0gVGlsZVN0YXRlLkVSUk9SO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB6ID0gdGhpcy53cmFwcGVkVGlsZUNvb3JkX1swXTtcbiAgICAgIGNvbnN0IHNpemUgPSB0aGlzLnRhcmdldFRpbGVHcmlkXy5nZXRUaWxlU2l6ZSh6KTtcbiAgICAgIGNvbnN0IHdpZHRoID0gdHlwZW9mIHNpemUgPT09ICdudW1iZXInID8gc2l6ZSA6IHNpemVbMF07XG4gICAgICBjb25zdCBoZWlnaHQgPSB0eXBlb2Ygc2l6ZSA9PT0gJ251bWJlcicgPyBzaXplIDogc2l6ZVsxXTtcbiAgICAgIGNvbnN0IHRhcmdldFJlc29sdXRpb24gPSB0aGlzLnRhcmdldFRpbGVHcmlkXy5nZXRSZXNvbHV0aW9uKHopO1xuICAgICAgY29uc3Qgc291cmNlUmVzb2x1dGlvbiA9IHRoaXMuc291cmNlVGlsZUdyaWRfLmdldFJlc29sdXRpb24oXG4gICAgICAgIHRoaXMuc291cmNlWl9cbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IHRhcmdldEV4dGVudCA9IHRoaXMudGFyZ2V0VGlsZUdyaWRfLmdldFRpbGVDb29yZEV4dGVudChcbiAgICAgICAgdGhpcy53cmFwcGVkVGlsZUNvb3JkX1xuICAgICAgKTtcblxuICAgICAgdGhpcy5jYW52YXNfID0gcmVuZGVyUmVwcm9qZWN0ZWQoXG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHQsXG4gICAgICAgIHRoaXMucGl4ZWxSYXRpb18sXG4gICAgICAgIHNvdXJjZVJlc29sdXRpb24sXG4gICAgICAgIHRoaXMuc291cmNlVGlsZUdyaWRfLmdldEV4dGVudCgpLFxuICAgICAgICB0YXJnZXRSZXNvbHV0aW9uLFxuICAgICAgICB0YXJnZXRFeHRlbnQsXG4gICAgICAgIHRoaXMudHJpYW5ndWxhdGlvbl8sXG4gICAgICAgIHNvdXJjZXMsXG4gICAgICAgIHRoaXMuZ3V0dGVyXyxcbiAgICAgICAgdGhpcy5yZW5kZXJFZGdlc18sXG4gICAgICAgIHRoaXMuaW50ZXJwb2xhdGVcbiAgICAgICk7XG5cbiAgICAgIHRoaXMuc3RhdGUgPSBUaWxlU3RhdGUuTE9BREVEO1xuICAgIH1cbiAgICB0aGlzLmNoYW5nZWQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2FkIG5vdCB5ZXQgbG9hZGVkIFVSSS5cbiAgICovXG4gIGxvYWQoKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUgPT0gVGlsZVN0YXRlLklETEUpIHtcbiAgICAgIHRoaXMuc3RhdGUgPSBUaWxlU3RhdGUuTE9BRElORztcbiAgICAgIHRoaXMuY2hhbmdlZCgpO1xuXG4gICAgICBsZXQgbGVmdFRvTG9hZCA9IDA7XG5cbiAgICAgIHRoaXMuc291cmNlc0xpc3RlbmVyS2V5c18gPSBbXTtcbiAgICAgIHRoaXMuc291cmNlVGlsZXNfLmZvckVhY2goKHRpbGUpID0+IHtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSB0aWxlLmdldFN0YXRlKCk7XG4gICAgICAgIGlmIChzdGF0ZSA9PSBUaWxlU3RhdGUuSURMRSB8fCBzdGF0ZSA9PSBUaWxlU3RhdGUuTE9BRElORykge1xuICAgICAgICAgIGxlZnRUb0xvYWQrKztcblxuICAgICAgICAgIGNvbnN0IHNvdXJjZUxpc3RlbktleSA9IGxpc3RlbihcbiAgICAgICAgICAgIHRpbGUsXG4gICAgICAgICAgICBFdmVudFR5cGUuQ0hBTkdFLFxuICAgICAgICAgICAgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgY29uc3Qgc3RhdGUgPSB0aWxlLmdldFN0YXRlKCk7XG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBzdGF0ZSA9PSBUaWxlU3RhdGUuTE9BREVEIHx8XG4gICAgICAgICAgICAgICAgc3RhdGUgPT0gVGlsZVN0YXRlLkVSUk9SIHx8XG4gICAgICAgICAgICAgICAgc3RhdGUgPT0gVGlsZVN0YXRlLkVNUFRZXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHVubGlzdGVuQnlLZXkoc291cmNlTGlzdGVuS2V5KTtcbiAgICAgICAgICAgICAgICBsZWZ0VG9Mb2FkLS07XG4gICAgICAgICAgICAgICAgaWYgKGxlZnRUb0xvYWQgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMudW5saXN0ZW5Tb3VyY2VzXygpO1xuICAgICAgICAgICAgICAgICAgdGhpcy5yZXByb2plY3RfKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdGhpc1xuICAgICAgICAgICk7XG4gICAgICAgICAgdGhpcy5zb3VyY2VzTGlzdGVuZXJLZXlzXy5wdXNoKHNvdXJjZUxpc3RlbktleSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAobGVmdFRvTG9hZCA9PT0gMCkge1xuICAgICAgICBzZXRUaW1lb3V0KHRoaXMucmVwcm9qZWN0Xy5iaW5kKHRoaXMpLCAwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc291cmNlVGlsZXNfLmZvckVhY2goZnVuY3Rpb24gKHRpbGUsIGksIGFycikge1xuICAgICAgICAgIGNvbnN0IHN0YXRlID0gdGlsZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgIGlmIChzdGF0ZSA9PSBUaWxlU3RhdGUuSURMRSkge1xuICAgICAgICAgICAgdGlsZS5sb2FkKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHVubGlzdGVuU291cmNlc18oKSB7XG4gICAgdGhpcy5zb3VyY2VzTGlzdGVuZXJLZXlzXy5mb3JFYWNoKHVubGlzdGVuQnlLZXkpO1xuICAgIHRoaXMuc291cmNlc0xpc3RlbmVyS2V5c18gPSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBmcm9tIHRoZSBjYWNoZSBkdWUgdG8gZXhwaXJ5XG4gICAqL1xuICByZWxlYXNlKCkge1xuICAgIGlmICh0aGlzLmNhbnZhc18pIHtcbiAgICAgIHJlbGVhc2VDYW52YXModGhpcy5jYW52YXNfLmdldENvbnRleHQoJzJkJykpO1xuICAgICAgY2FudmFzUG9vbC5wdXNoKHRoaXMuY2FudmFzXyk7XG4gICAgICB0aGlzLmNhbnZhc18gPSBudWxsO1xuICAgIH1cbiAgICBzdXBlci5yZWxlYXNlKCk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgUmVwcm9qVGlsZTtcbiIsIi8qKlxuICogQG1vZHVsZSBvbC9yZXByb2ovVHJpYW5ndWxhdGlvblxuICovXG5pbXBvcnQge1xuICBib3VuZGluZ0V4dGVudCxcbiAgY3JlYXRlRW1wdHksXG4gIGV4dGVuZENvb3JkaW5hdGUsXG4gIGdldEFyZWEsXG4gIGdldEJvdHRvbUxlZnQsXG4gIGdldEJvdHRvbVJpZ2h0LFxuICBnZXRUb3BMZWZ0LFxuICBnZXRUb3BSaWdodCxcbiAgZ2V0V2lkdGgsXG4gIGludGVyc2VjdHMsXG59IGZyb20gJy4uL2V4dGVudC5qcyc7XG5pbXBvcnQge2dldFRyYW5zZm9ybX0gZnJvbSAnLi4vcHJvai5qcyc7XG5pbXBvcnQge21vZHVsb30gZnJvbSAnLi4vbWF0aC5qcyc7XG5cbi8qKlxuICogU2luZ2xlIHRyaWFuZ2xlOyBjb25zaXN0cyBvZiAzIHNvdXJjZSBwb2ludHMgYW5kIDMgdGFyZ2V0IHBvaW50cy5cbiAqIEB0eXBlZGVmIHtPYmplY3R9IFRyaWFuZ2xlXG4gKiBAcHJvcGVydHkge0FycmF5PGltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZT59IHNvdXJjZSBTb3VyY2UuXG4gKiBAcHJvcGVydHkge0FycmF5PGltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZT59IHRhcmdldCBUYXJnZXQuXG4gKi9cblxuLyoqXG4gKiBNYXhpbXVtIG51bWJlciBvZiBzdWJkaXZpc2lvbiBzdGVwcyBkdXJpbmcgcmFzdGVyIHJlcHJvamVjdGlvbiB0cmlhbmd1bGF0aW9uLlxuICogUHJldmVudHMgaGlnaCBtZW1vcnkgdXNhZ2UgYW5kIGxhcmdlIG51bWJlciBvZiBwcm9qNCBjYWxscyAoZm9yIGNlcnRhaW5cbiAqIHRyYW5zZm9ybWF0aW9ucyBhbmQgYXJlYXMpLiBBdCBtb3N0IGAyKigyXnRoaXMpYCB0cmlhbmdsZXMgYXJlIGNyZWF0ZWQgZm9yXG4gKiBlYWNoIHRyaWFuZ3VsYXRlZCBleHRlbnQgKHRpbGUvaW1hZ2UpLlxuICogQHR5cGUge251bWJlcn1cbiAqL1xuY29uc3QgTUFYX1NVQkRJVklTSU9OID0gMTA7XG5cbi8qKlxuICogTWF4aW11bSBhbGxvd2VkIHNpemUgb2YgdHJpYW5nbGUgcmVsYXRpdmUgdG8gd29ybGQgd2lkdGguIFdoZW4gdHJhbnNmb3JtaW5nXG4gKiBjb3JuZXJzIG9mIHdvcmxkIGV4dGVudCBiZXR3ZWVuIGNlcnRhaW4gcHJvamVjdGlvbnMsIHRoZSByZXN1bHRpbmdcbiAqIHRyaWFuZ3VsYXRpb24gc2VlbXMgdG8gaGF2ZSB6ZXJvIGVycm9yIGFuZCBubyBzdWJkaXZpc2lvbiBpcyBwZXJmb3JtZWQuIElmXG4gKiB0aGUgdHJpYW5nbGUgd2lkdGggaXMgbW9yZSB0aGFuIHRoaXMgKHJlbGF0aXZlIHRvIHdvcmxkIHdpZHRoOyAwLTEpLFxuICogc3ViZGl2aXNvbiBpcyBmb3JjZWQgKHVwIHRvIGBNQVhfU1VCRElWSVNJT05gKS4gRGVmYXVsdCBpcyBgMC4yNWAuXG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5jb25zdCBNQVhfVFJJQU5HTEVfV0lEVEggPSAwLjI1O1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIENsYXNzIGNvbnRhaW5pbmcgdHJpYW5ndWxhdGlvbiBvZiB0aGUgZ2l2ZW4gdGFyZ2V0IGV4dGVudC5cbiAqIFVzZWQgZm9yIGRldGVybWluaW5nIHNvdXJjZSBkYXRhIGFuZCB0aGUgcmVwcm9qZWN0aW9uIGl0c2VsZi5cbiAqL1xuY2xhc3MgVHJpYW5ndWxhdGlvbiB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3Byb2ovUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0fSBzb3VyY2VQcm9qIFNvdXJjZSBwcm9qZWN0aW9uLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3Byb2ovUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0fSB0YXJnZXRQcm9qIFRhcmdldCBwcm9qZWN0aW9uLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IHRhcmdldEV4dGVudCBUYXJnZXQgZXh0ZW50IHRvIHRyaWFuZ3VsYXRlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IG1heFNvdXJjZUV4dGVudCBNYXhpbWFsIHNvdXJjZSBleHRlbnQgdGhhdCBjYW4gYmUgdXNlZC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGVycm9yVGhyZXNob2xkIEFjY2VwdGFibGUgZXJyb3IgKGluIHNvdXJjZSB1bml0cykuXG4gICAqIEBwYXJhbSB7P251bWJlcn0gZGVzdGluYXRpb25SZXNvbHV0aW9uIFRoZSAob3B0aW9uYWwpIHJlc29sdXRpb24gb2YgdGhlIGRlc3RpbmF0aW9uLlxuICAgKi9cbiAgY29uc3RydWN0b3IoXG4gICAgc291cmNlUHJvaixcbiAgICB0YXJnZXRQcm9qLFxuICAgIHRhcmdldEV4dGVudCxcbiAgICBtYXhTb3VyY2VFeHRlbnQsXG4gICAgZXJyb3JUaHJlc2hvbGQsXG4gICAgZGVzdGluYXRpb25SZXNvbHV0aW9uXG4gICkge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9wcm9qL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuc291cmNlUHJval8gPSBzb3VyY2VQcm9qO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL3Byb2ovUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy50YXJnZXRQcm9qXyA9IHRhcmdldFByb2o7XG5cbiAgICAvKiogQHR5cGUgeyFPYmplY3Q8c3RyaW5nLCBpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGU+fSAqL1xuICAgIGxldCB0cmFuc2Zvcm1JbnZDYWNoZSA9IHt9O1xuICAgIGNvbnN0IHRyYW5zZm9ybUludiA9IGdldFRyYW5zZm9ybSh0aGlzLnRhcmdldFByb2pfLCB0aGlzLnNvdXJjZVByb2pfKTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBjIEEgY29vcmRpbmF0ZS5cbiAgICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IFRyYW5zZm9ybWVkIGNvb3JkaW5hdGUuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLnRyYW5zZm9ybUludl8gPSBmdW5jdGlvbiAoYykge1xuICAgICAgY29uc3Qga2V5ID0gY1swXSArICcvJyArIGNbMV07XG4gICAgICBpZiAoIXRyYW5zZm9ybUludkNhY2hlW2tleV0pIHtcbiAgICAgICAgdHJhbnNmb3JtSW52Q2FjaGVba2V5XSA9IHRyYW5zZm9ybUludihjKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cmFuc2Zvcm1JbnZDYWNoZVtrZXldO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMubWF4U291cmNlRXh0ZW50XyA9IG1heFNvdXJjZUV4dGVudDtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmVycm9yVGhyZXNob2xkU3F1YXJlZF8gPSBlcnJvclRocmVzaG9sZCAqIGVycm9yVGhyZXNob2xkO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge0FycmF5PFRyaWFuZ2xlPn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMudHJpYW5nbGVzXyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHRoYXQgdGhlIHRyaWFuZ3VsYXRpb24gY3Jvc3NlcyBlZGdlIG9mIHRoZSBzb3VyY2UgcHJvamVjdGlvbi5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMud3JhcHNYSW5Tb3VyY2VfID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuY2FuV3JhcFhJblNvdXJjZV8gPVxuICAgICAgdGhpcy5zb3VyY2VQcm9qXy5jYW5XcmFwWCgpICYmXG4gICAgICAhIW1heFNvdXJjZUV4dGVudCAmJlxuICAgICAgISF0aGlzLnNvdXJjZVByb2pfLmdldEV4dGVudCgpICYmXG4gICAgICBnZXRXaWR0aChtYXhTb3VyY2VFeHRlbnQpID49IGdldFdpZHRoKHRoaXMuc291cmNlUHJval8uZ2V0RXh0ZW50KCkpO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUgez9udW1iZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLnNvdXJjZVdvcmxkV2lkdGhfID0gdGhpcy5zb3VyY2VQcm9qXy5nZXRFeHRlbnQoKVxuICAgICAgPyBnZXRXaWR0aCh0aGlzLnNvdXJjZVByb2pfLmdldEV4dGVudCgpKVxuICAgICAgOiBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUgez9udW1iZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLnRhcmdldFdvcmxkV2lkdGhfID0gdGhpcy50YXJnZXRQcm9qXy5nZXRFeHRlbnQoKVxuICAgICAgPyBnZXRXaWR0aCh0aGlzLnRhcmdldFByb2pfLmdldEV4dGVudCgpKVxuICAgICAgOiBudWxsO1xuXG4gICAgY29uc3QgZGVzdGluYXRpb25Ub3BMZWZ0ID0gZ2V0VG9wTGVmdCh0YXJnZXRFeHRlbnQpO1xuICAgIGNvbnN0IGRlc3RpbmF0aW9uVG9wUmlnaHQgPSBnZXRUb3BSaWdodCh0YXJnZXRFeHRlbnQpO1xuICAgIGNvbnN0IGRlc3RpbmF0aW9uQm90dG9tUmlnaHQgPSBnZXRCb3R0b21SaWdodCh0YXJnZXRFeHRlbnQpO1xuICAgIGNvbnN0IGRlc3RpbmF0aW9uQm90dG9tTGVmdCA9IGdldEJvdHRvbUxlZnQodGFyZ2V0RXh0ZW50KTtcbiAgICBjb25zdCBzb3VyY2VUb3BMZWZ0ID0gdGhpcy50cmFuc2Zvcm1JbnZfKGRlc3RpbmF0aW9uVG9wTGVmdCk7XG4gICAgY29uc3Qgc291cmNlVG9wUmlnaHQgPSB0aGlzLnRyYW5zZm9ybUludl8oZGVzdGluYXRpb25Ub3BSaWdodCk7XG4gICAgY29uc3Qgc291cmNlQm90dG9tUmlnaHQgPSB0aGlzLnRyYW5zZm9ybUludl8oZGVzdGluYXRpb25Cb3R0b21SaWdodCk7XG4gICAgY29uc3Qgc291cmNlQm90dG9tTGVmdCA9IHRoaXMudHJhbnNmb3JtSW52XyhkZXN0aW5hdGlvbkJvdHRvbUxlZnQpO1xuXG4gICAgLypcbiAgICAgKiBUaGUgbWF4U3ViZGl2aXNpb24gY29udHJvbHMgaG93IG1hbnkgc3BsaXR0aW5ncyBvZiB0aGUgdGFyZ2V0IGFyZWEgY2FuXG4gICAgICogYmUgZG9uZS4gVGhlIGlkZWEgaGVyZSBpcyB0byBkbyBhIGxpbmVhciBtYXBwaW5nIG9mIHRoZSB0YXJnZXQgYXJlYXNcbiAgICAgKiBidXQgdGhlIGFjdHVhbCBvdmVyYWxsIHJlcHJvamVjdGlvbiAoY2FuIGJlKSBleHRyZW1lbHkgbm9uLWxpbmVhci4gVGhlXG4gICAgICogZGVmYXVsdCB2YWx1ZSBvZiBNQVhfU1VCRElWSVNJT04gd2FzIGNob3NlbiBiYXNlZCBvbiBtYXBwaW5nIGEgMjU2eDI1NlxuICAgICAqIHRpbGUgc2l6ZS4gSG93ZXZlciB0aGlzIGZ1bmN0aW9uIGlzIGFsc28gY2FsbGVkIHRvIHJlbWFwIGNhbnZhcyByZW5kZXJlZFxuICAgICAqIGxheWVycyB3aGljaCBjYW4gYmUgbXVjaCBsYXJnZXIuIFRoaXMgY2FsY3VsYXRpb24gaW5jcmVhc2VzIHRoZSBtYXhTdWJkaXZpc2lvblxuICAgICAqIHZhbHVlIGJ5IHRoZSByaWdodCBmYWN0b3Igc28gdGhhdCBlYWNoIDI1NngyNTYgcGl4ZWwgYXJlYSBoYXNcbiAgICAgKiBNQVhfU1VCRElWSVNJT04gZGl2aXNpb25zLlxuICAgICAqL1xuICAgIGNvbnN0IG1heFN1YmRpdmlzaW9uID1cbiAgICAgIE1BWF9TVUJESVZJU0lPTiArXG4gICAgICAoZGVzdGluYXRpb25SZXNvbHV0aW9uXG4gICAgICAgID8gTWF0aC5tYXgoXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgTWF0aC5jZWlsKFxuICAgICAgICAgICAgICBNYXRoLmxvZzIoXG4gICAgICAgICAgICAgICAgZ2V0QXJlYSh0YXJnZXRFeHRlbnQpIC9cbiAgICAgICAgICAgICAgICAgIChkZXN0aW5hdGlvblJlc29sdXRpb24gKiBkZXN0aW5hdGlvblJlc29sdXRpb24gKiAyNTYgKiAyNTYpXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIClcbiAgICAgICAgICApXG4gICAgICAgIDogMCk7XG5cbiAgICB0aGlzLmFkZFF1YWRfKFxuICAgICAgZGVzdGluYXRpb25Ub3BMZWZ0LFxuICAgICAgZGVzdGluYXRpb25Ub3BSaWdodCxcbiAgICAgIGRlc3RpbmF0aW9uQm90dG9tUmlnaHQsXG4gICAgICBkZXN0aW5hdGlvbkJvdHRvbUxlZnQsXG4gICAgICBzb3VyY2VUb3BMZWZ0LFxuICAgICAgc291cmNlVG9wUmlnaHQsXG4gICAgICBzb3VyY2VCb3R0b21SaWdodCxcbiAgICAgIHNvdXJjZUJvdHRvbUxlZnQsXG4gICAgICBtYXhTdWJkaXZpc2lvblxuICAgICk7XG5cbiAgICBpZiAodGhpcy53cmFwc1hJblNvdXJjZV8pIHtcbiAgICAgIGxldCBsZWZ0Qm91bmQgPSBJbmZpbml0eTtcbiAgICAgIHRoaXMudHJpYW5nbGVzXy5mb3JFYWNoKGZ1bmN0aW9uICh0cmlhbmdsZSwgaSwgYXJyKSB7XG4gICAgICAgIGxlZnRCb3VuZCA9IE1hdGgubWluKFxuICAgICAgICAgIGxlZnRCb3VuZCxcbiAgICAgICAgICB0cmlhbmdsZS5zb3VyY2VbMF1bMF0sXG4gICAgICAgICAgdHJpYW5nbGUuc291cmNlWzFdWzBdLFxuICAgICAgICAgIHRyaWFuZ2xlLnNvdXJjZVsyXVswXVxuICAgICAgICApO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIFNoaWZ0IHRyaWFuZ2xlcyB0byBiZSBhcyBjbG9zZSB0byBgbGVmdEJvdW5kYCBhcyBwb3NzaWJsZVxuICAgICAgLy8gKGlmIHRoZSBkaXN0YW5jZSBpcyBtb3JlIHRoYW4gYHdvcmxkV2lkdGggLyAyYCBpdCBjYW4gYmUgY2xvc2VyLlxuICAgICAgdGhpcy50cmlhbmdsZXNfLmZvckVhY2goKHRyaWFuZ2xlKSA9PiB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBNYXRoLm1heChcbiAgICAgICAgICAgIHRyaWFuZ2xlLnNvdXJjZVswXVswXSxcbiAgICAgICAgICAgIHRyaWFuZ2xlLnNvdXJjZVsxXVswXSxcbiAgICAgICAgICAgIHRyaWFuZ2xlLnNvdXJjZVsyXVswXVxuICAgICAgICAgICkgLVxuICAgICAgICAgICAgbGVmdEJvdW5kID5cbiAgICAgICAgICB0aGlzLnNvdXJjZVdvcmxkV2lkdGhfIC8gMlxuICAgICAgICApIHtcbiAgICAgICAgICBjb25zdCBuZXdUcmlhbmdsZSA9IFtcbiAgICAgICAgICAgIFt0cmlhbmdsZS5zb3VyY2VbMF1bMF0sIHRyaWFuZ2xlLnNvdXJjZVswXVsxXV0sXG4gICAgICAgICAgICBbdHJpYW5nbGUuc291cmNlWzFdWzBdLCB0cmlhbmdsZS5zb3VyY2VbMV1bMV1dLFxuICAgICAgICAgICAgW3RyaWFuZ2xlLnNvdXJjZVsyXVswXSwgdHJpYW5nbGUuc291cmNlWzJdWzFdXSxcbiAgICAgICAgICBdO1xuICAgICAgICAgIGlmIChuZXdUcmlhbmdsZVswXVswXSAtIGxlZnRCb3VuZCA+IHRoaXMuc291cmNlV29ybGRXaWR0aF8gLyAyKSB7XG4gICAgICAgICAgICBuZXdUcmlhbmdsZVswXVswXSAtPSB0aGlzLnNvdXJjZVdvcmxkV2lkdGhfO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobmV3VHJpYW5nbGVbMV1bMF0gLSBsZWZ0Qm91bmQgPiB0aGlzLnNvdXJjZVdvcmxkV2lkdGhfIC8gMikge1xuICAgICAgICAgICAgbmV3VHJpYW5nbGVbMV1bMF0gLT0gdGhpcy5zb3VyY2VXb3JsZFdpZHRoXztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG5ld1RyaWFuZ2xlWzJdWzBdIC0gbGVmdEJvdW5kID4gdGhpcy5zb3VyY2VXb3JsZFdpZHRoXyAvIDIpIHtcbiAgICAgICAgICAgIG5ld1RyaWFuZ2xlWzJdWzBdIC09IHRoaXMuc291cmNlV29ybGRXaWR0aF87XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gUmFyZWx5IChpZiB0aGUgZXh0ZW50IGNvbnRhaW5zIGJvdGggdGhlIGRhdGVsaW5lIGFuZCBwcmltZSBtZXJpZGlhbilcbiAgICAgICAgICAvLyB0aGUgc2hpZnQgY2FuIGluIHR1cm4gYnJlYWsgc29tZSB0cmlhbmdsZXMuXG4gICAgICAgICAgLy8gRGV0ZWN0IHRoaXMgaGVyZSBhbmQgZG9uJ3Qgc2hpZnQgaW4gc3VjaCBjYXNlcy5cbiAgICAgICAgICBjb25zdCBtaW5YID0gTWF0aC5taW4oXG4gICAgICAgICAgICBuZXdUcmlhbmdsZVswXVswXSxcbiAgICAgICAgICAgIG5ld1RyaWFuZ2xlWzFdWzBdLFxuICAgICAgICAgICAgbmV3VHJpYW5nbGVbMl1bMF1cbiAgICAgICAgICApO1xuICAgICAgICAgIGNvbnN0IG1heFggPSBNYXRoLm1heChcbiAgICAgICAgICAgIG5ld1RyaWFuZ2xlWzBdWzBdLFxuICAgICAgICAgICAgbmV3VHJpYW5nbGVbMV1bMF0sXG4gICAgICAgICAgICBuZXdUcmlhbmdsZVsyXVswXVxuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKG1heFggLSBtaW5YIDwgdGhpcy5zb3VyY2VXb3JsZFdpZHRoXyAvIDIpIHtcbiAgICAgICAgICAgIHRyaWFuZ2xlLnNvdXJjZSA9IG5ld1RyaWFuZ2xlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdHJhbnNmb3JtSW52Q2FjaGUgPSB7fTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIHRyaWFuZ2xlIHRvIHRoZSB0cmlhbmd1bGF0aW9uLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gYSBUaGUgdGFyZ2V0IGEgY29vcmRpbmF0ZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGIgVGhlIHRhcmdldCBiIGNvb3JkaW5hdGUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBjIFRoZSB0YXJnZXQgYyBjb29yZGluYXRlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gYVNyYyBUaGUgc291cmNlIGEgY29vcmRpbmF0ZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGJTcmMgVGhlIHNvdXJjZSBiIGNvb3JkaW5hdGUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBjU3JjIFRoZSBzb3VyY2UgYyBjb29yZGluYXRlLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYWRkVHJpYW5nbGVfKGEsIGIsIGMsIGFTcmMsIGJTcmMsIGNTcmMpIHtcbiAgICB0aGlzLnRyaWFuZ2xlc18ucHVzaCh7XG4gICAgICBzb3VyY2U6IFthU3JjLCBiU3JjLCBjU3JjXSxcbiAgICAgIHRhcmdldDogW2EsIGIsIGNdLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgcXVhZCAocG9pbnRzIGluIGNsb2NrLXdpc2Ugb3JkZXIpIHRvIHRoZSB0cmlhbmd1bGF0aW9uXG4gICAqIChhbmQgcmVwcm9qZWN0cyB0aGUgdmVydGljZXMpIGlmIHZhbGlkLlxuICAgKiBQZXJmb3JtcyBxdWFkIHN1YmRpdmlzaW9uIGlmIG5lZWRlZCB0byBpbmNyZWFzZSBwcmVjaXNpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBhIFRoZSB0YXJnZXQgYSBjb29yZGluYXRlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gYiBUaGUgdGFyZ2V0IGIgY29vcmRpbmF0ZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGMgVGhlIHRhcmdldCBjIGNvb3JkaW5hdGUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBkIFRoZSB0YXJnZXQgZCBjb29yZGluYXRlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gYVNyYyBUaGUgc291cmNlIGEgY29vcmRpbmF0ZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGJTcmMgVGhlIHNvdXJjZSBiIGNvb3JkaW5hdGUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBjU3JjIFRoZSBzb3VyY2UgYyBjb29yZGluYXRlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gZFNyYyBUaGUgc291cmNlIGQgY29vcmRpbmF0ZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG1heFN1YmRpdmlzaW9uIE1heGltYWwgYWxsb3dlZCBzdWJkaXZpc2lvbiBvZiB0aGUgcXVhZC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGFkZFF1YWRfKGEsIGIsIGMsIGQsIGFTcmMsIGJTcmMsIGNTcmMsIGRTcmMsIG1heFN1YmRpdmlzaW9uKSB7XG4gICAgY29uc3Qgc291cmNlUXVhZEV4dGVudCA9IGJvdW5kaW5nRXh0ZW50KFthU3JjLCBiU3JjLCBjU3JjLCBkU3JjXSk7XG4gICAgY29uc3Qgc291cmNlQ292ZXJhZ2VYID0gdGhpcy5zb3VyY2VXb3JsZFdpZHRoX1xuICAgICAgPyBnZXRXaWR0aChzb3VyY2VRdWFkRXh0ZW50KSAvIHRoaXMuc291cmNlV29ybGRXaWR0aF9cbiAgICAgIDogbnVsbDtcbiAgICBjb25zdCBzb3VyY2VXb3JsZFdpZHRoID0gLyoqIEB0eXBlIHtudW1iZXJ9ICovICh0aGlzLnNvdXJjZVdvcmxkV2lkdGhfKTtcblxuICAgIC8vIHdoZW4gdGhlIHF1YWQgaXMgd3JhcHBlZCBpbiB0aGUgc291cmNlIHByb2plY3Rpb25cbiAgICAvLyBpdCBjb3ZlcnMgbW9zdCBvZiB0aGUgcHJvamVjdGlvbiBleHRlbnQsIGJ1dCBub3QgZnVsbHlcbiAgICBjb25zdCB3cmFwc1ggPVxuICAgICAgdGhpcy5zb3VyY2VQcm9qXy5jYW5XcmFwWCgpICYmXG4gICAgICBzb3VyY2VDb3ZlcmFnZVggPiAwLjUgJiZcbiAgICAgIHNvdXJjZUNvdmVyYWdlWCA8IDE7XG5cbiAgICBsZXQgbmVlZHNTdWJkaXZpc2lvbiA9IGZhbHNlO1xuXG4gICAgaWYgKG1heFN1YmRpdmlzaW9uID4gMCkge1xuICAgICAgaWYgKHRoaXMudGFyZ2V0UHJval8uaXNHbG9iYWwoKSAmJiB0aGlzLnRhcmdldFdvcmxkV2lkdGhfKSB7XG4gICAgICAgIGNvbnN0IHRhcmdldFF1YWRFeHRlbnQgPSBib3VuZGluZ0V4dGVudChbYSwgYiwgYywgZF0pO1xuICAgICAgICBjb25zdCB0YXJnZXRDb3ZlcmFnZVggPVxuICAgICAgICAgIGdldFdpZHRoKHRhcmdldFF1YWRFeHRlbnQpIC8gdGhpcy50YXJnZXRXb3JsZFdpZHRoXztcbiAgICAgICAgbmVlZHNTdWJkaXZpc2lvbiA9XG4gICAgICAgICAgdGFyZ2V0Q292ZXJhZ2VYID4gTUFYX1RSSUFOR0xFX1dJRFRIIHx8IG5lZWRzU3ViZGl2aXNpb247XG4gICAgICB9XG4gICAgICBpZiAoIXdyYXBzWCAmJiB0aGlzLnNvdXJjZVByb2pfLmlzR2xvYmFsKCkgJiYgc291cmNlQ292ZXJhZ2VYKSB7XG4gICAgICAgIG5lZWRzU3ViZGl2aXNpb24gPVxuICAgICAgICAgIHNvdXJjZUNvdmVyYWdlWCA+IE1BWF9UUklBTkdMRV9XSURUSCB8fCBuZWVkc1N1YmRpdmlzaW9uO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghbmVlZHNTdWJkaXZpc2lvbiAmJiB0aGlzLm1heFNvdXJjZUV4dGVudF8pIHtcbiAgICAgIGlmIChcbiAgICAgICAgaXNGaW5pdGUoc291cmNlUXVhZEV4dGVudFswXSkgJiZcbiAgICAgICAgaXNGaW5pdGUoc291cmNlUXVhZEV4dGVudFsxXSkgJiZcbiAgICAgICAgaXNGaW5pdGUoc291cmNlUXVhZEV4dGVudFsyXSkgJiZcbiAgICAgICAgaXNGaW5pdGUoc291cmNlUXVhZEV4dGVudFszXSlcbiAgICAgICkge1xuICAgICAgICBpZiAoIWludGVyc2VjdHMoc291cmNlUXVhZEV4dGVudCwgdGhpcy5tYXhTb3VyY2VFeHRlbnRfKSkge1xuICAgICAgICAgIC8vIHdob2xlIHF1YWQgb3V0c2lkZSBzb3VyY2UgcHJvamVjdGlvbiBleHRlbnQgLT4gaWdub3JlXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IGlzTm90RmluaXRlID0gMDtcblxuICAgIGlmICghbmVlZHNTdWJkaXZpc2lvbikge1xuICAgICAgaWYgKFxuICAgICAgICAhaXNGaW5pdGUoYVNyY1swXSkgfHxcbiAgICAgICAgIWlzRmluaXRlKGFTcmNbMV0pIHx8XG4gICAgICAgICFpc0Zpbml0ZShiU3JjWzBdKSB8fFxuICAgICAgICAhaXNGaW5pdGUoYlNyY1sxXSkgfHxcbiAgICAgICAgIWlzRmluaXRlKGNTcmNbMF0pIHx8XG4gICAgICAgICFpc0Zpbml0ZShjU3JjWzFdKSB8fFxuICAgICAgICAhaXNGaW5pdGUoZFNyY1swXSkgfHxcbiAgICAgICAgIWlzRmluaXRlKGRTcmNbMV0pXG4gICAgICApIHtcbiAgICAgICAgaWYgKG1heFN1YmRpdmlzaW9uID4gMCkge1xuICAgICAgICAgIG5lZWRzU3ViZGl2aXNpb24gPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIEl0IG1pZ2h0IGJlIHRoZSBjYXNlIHRoYXQgb25seSAxIG9mIHRoZSBwb2ludHMgaXMgaW5maW5pdGUuIEluIHRoaXMgY2FzZVxuICAgICAgICAgIC8vIHdlIGNhbiBkcmF3IGEgc2luZ2xlIHRyaWFuZ2xlIHdpdGggdGhlIG90aGVyIHRocmVlIHBvaW50c1xuICAgICAgICAgIGlzTm90RmluaXRlID1cbiAgICAgICAgICAgICghaXNGaW5pdGUoYVNyY1swXSkgfHwgIWlzRmluaXRlKGFTcmNbMV0pID8gOCA6IDApICtcbiAgICAgICAgICAgICghaXNGaW5pdGUoYlNyY1swXSkgfHwgIWlzRmluaXRlKGJTcmNbMV0pID8gNCA6IDApICtcbiAgICAgICAgICAgICghaXNGaW5pdGUoY1NyY1swXSkgfHwgIWlzRmluaXRlKGNTcmNbMV0pID8gMiA6IDApICtcbiAgICAgICAgICAgICghaXNGaW5pdGUoZFNyY1swXSkgfHwgIWlzRmluaXRlKGRTcmNbMV0pID8gMSA6IDApO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIGlzTm90RmluaXRlICE9IDEgJiZcbiAgICAgICAgICAgIGlzTm90RmluaXRlICE9IDIgJiZcbiAgICAgICAgICAgIGlzTm90RmluaXRlICE9IDQgJiZcbiAgICAgICAgICAgIGlzTm90RmluaXRlICE9IDhcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobWF4U3ViZGl2aXNpb24gPiAwKSB7XG4gICAgICBpZiAoIW5lZWRzU3ViZGl2aXNpb24pIHtcbiAgICAgICAgY29uc3QgY2VudGVyID0gWyhhWzBdICsgY1swXSkgLyAyLCAoYVsxXSArIGNbMV0pIC8gMl07XG4gICAgICAgIGNvbnN0IGNlbnRlclNyYyA9IHRoaXMudHJhbnNmb3JtSW52XyhjZW50ZXIpO1xuXG4gICAgICAgIGxldCBkeDtcbiAgICAgICAgaWYgKHdyYXBzWCkge1xuICAgICAgICAgIGNvbnN0IGNlbnRlclNyY0VzdGltWCA9XG4gICAgICAgICAgICAobW9kdWxvKGFTcmNbMF0sIHNvdXJjZVdvcmxkV2lkdGgpICtcbiAgICAgICAgICAgICAgbW9kdWxvKGNTcmNbMF0sIHNvdXJjZVdvcmxkV2lkdGgpKSAvXG4gICAgICAgICAgICAyO1xuICAgICAgICAgIGR4ID0gY2VudGVyU3JjRXN0aW1YIC0gbW9kdWxvKGNlbnRlclNyY1swXSwgc291cmNlV29ybGRXaWR0aCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZHggPSAoYVNyY1swXSArIGNTcmNbMF0pIC8gMiAtIGNlbnRlclNyY1swXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkeSA9IChhU3JjWzFdICsgY1NyY1sxXSkgLyAyIC0gY2VudGVyU3JjWzFdO1xuICAgICAgICBjb25zdCBjZW50ZXJTcmNFcnJvclNxdWFyZWQgPSBkeCAqIGR4ICsgZHkgKiBkeTtcbiAgICAgICAgbmVlZHNTdWJkaXZpc2lvbiA9IGNlbnRlclNyY0Vycm9yU3F1YXJlZCA+IHRoaXMuZXJyb3JUaHJlc2hvbGRTcXVhcmVkXztcbiAgICAgIH1cbiAgICAgIGlmIChuZWVkc1N1YmRpdmlzaW9uKSB7XG4gICAgICAgIGlmIChNYXRoLmFicyhhWzBdIC0gY1swXSkgPD0gTWF0aC5hYnMoYVsxXSAtIGNbMV0pKSB7XG4gICAgICAgICAgLy8gc3BsaXQgaG9yaXpvbnRhbGx5ICh0b3AgJiBib3R0b20pXG4gICAgICAgICAgY29uc3QgYmMgPSBbKGJbMF0gKyBjWzBdKSAvIDIsIChiWzFdICsgY1sxXSkgLyAyXTtcbiAgICAgICAgICBjb25zdCBiY1NyYyA9IHRoaXMudHJhbnNmb3JtSW52XyhiYyk7XG4gICAgICAgICAgY29uc3QgZGEgPSBbKGRbMF0gKyBhWzBdKSAvIDIsIChkWzFdICsgYVsxXSkgLyAyXTtcbiAgICAgICAgICBjb25zdCBkYVNyYyA9IHRoaXMudHJhbnNmb3JtSW52XyhkYSk7XG5cbiAgICAgICAgICB0aGlzLmFkZFF1YWRfKFxuICAgICAgICAgICAgYSxcbiAgICAgICAgICAgIGIsXG4gICAgICAgICAgICBiYyxcbiAgICAgICAgICAgIGRhLFxuICAgICAgICAgICAgYVNyYyxcbiAgICAgICAgICAgIGJTcmMsXG4gICAgICAgICAgICBiY1NyYyxcbiAgICAgICAgICAgIGRhU3JjLFxuICAgICAgICAgICAgbWF4U3ViZGl2aXNpb24gLSAxXG4gICAgICAgICAgKTtcbiAgICAgICAgICB0aGlzLmFkZFF1YWRfKFxuICAgICAgICAgICAgZGEsXG4gICAgICAgICAgICBiYyxcbiAgICAgICAgICAgIGMsXG4gICAgICAgICAgICBkLFxuICAgICAgICAgICAgZGFTcmMsXG4gICAgICAgICAgICBiY1NyYyxcbiAgICAgICAgICAgIGNTcmMsXG4gICAgICAgICAgICBkU3JjLFxuICAgICAgICAgICAgbWF4U3ViZGl2aXNpb24gLSAxXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBzcGxpdCB2ZXJ0aWNhbGx5IChsZWZ0ICYgcmlnaHQpXG4gICAgICAgICAgY29uc3QgYWIgPSBbKGFbMF0gKyBiWzBdKSAvIDIsIChhWzFdICsgYlsxXSkgLyAyXTtcbiAgICAgICAgICBjb25zdCBhYlNyYyA9IHRoaXMudHJhbnNmb3JtSW52XyhhYik7XG4gICAgICAgICAgY29uc3QgY2QgPSBbKGNbMF0gKyBkWzBdKSAvIDIsIChjWzFdICsgZFsxXSkgLyAyXTtcbiAgICAgICAgICBjb25zdCBjZFNyYyA9IHRoaXMudHJhbnNmb3JtSW52XyhjZCk7XG5cbiAgICAgICAgICB0aGlzLmFkZFF1YWRfKFxuICAgICAgICAgICAgYSxcbiAgICAgICAgICAgIGFiLFxuICAgICAgICAgICAgY2QsXG4gICAgICAgICAgICBkLFxuICAgICAgICAgICAgYVNyYyxcbiAgICAgICAgICAgIGFiU3JjLFxuICAgICAgICAgICAgY2RTcmMsXG4gICAgICAgICAgICBkU3JjLFxuICAgICAgICAgICAgbWF4U3ViZGl2aXNpb24gLSAxXG4gICAgICAgICAgKTtcbiAgICAgICAgICB0aGlzLmFkZFF1YWRfKFxuICAgICAgICAgICAgYWIsXG4gICAgICAgICAgICBiLFxuICAgICAgICAgICAgYyxcbiAgICAgICAgICAgIGNkLFxuICAgICAgICAgICAgYWJTcmMsXG4gICAgICAgICAgICBiU3JjLFxuICAgICAgICAgICAgY1NyYyxcbiAgICAgICAgICAgIGNkU3JjLFxuICAgICAgICAgICAgbWF4U3ViZGl2aXNpb24gLSAxXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHdyYXBzWCkge1xuICAgICAgaWYgKCF0aGlzLmNhbldyYXBYSW5Tb3VyY2VfKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMud3JhcHNYSW5Tb3VyY2VfID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBFeGFjdGx5IHplcm8gb3Igb25lIG9mICpTcmMgaXMgbm90IGZpbml0ZVxuICAgIC8vIFRoZSB0cmlhbmdsZXMgbXVzdCBoYXZlIHRoZSBkaWFnb25hbCBsaW5lIGFzIHRoZSBmaXJzdCBzaWRlXG4gICAgLy8gVGhpcyBpcyB0byBhbGxvdyBlYXN5IGNvZGUgaW4gcmVwcm9qLnMgdG8gbWFrZSBpdCBzdHJhaWdodCBmb3IgYnJva2VuXG4gICAgLy8gYnJvd3NlcnMgdGhhdCBjYW4ndCBoYW5kbGUgZGlhZ29uYWwgY2xpcHBpbmdcbiAgICBpZiAoKGlzTm90RmluaXRlICYgMHhiKSA9PSAwKSB7XG4gICAgICB0aGlzLmFkZFRyaWFuZ2xlXyhhLCBjLCBkLCBhU3JjLCBjU3JjLCBkU3JjKTtcbiAgICB9XG4gICAgaWYgKChpc05vdEZpbml0ZSAmIDB4ZSkgPT0gMCkge1xuICAgICAgdGhpcy5hZGRUcmlhbmdsZV8oYSwgYywgYiwgYVNyYywgY1NyYywgYlNyYyk7XG4gICAgfVxuICAgIGlmIChpc05vdEZpbml0ZSkge1xuICAgICAgLy8gVHJ5IHRoZSBvdGhlciB0d28gdHJpYW5nbGVzXG4gICAgICBpZiAoKGlzTm90RmluaXRlICYgMHhkKSA9PSAwKSB7XG4gICAgICAgIHRoaXMuYWRkVHJpYW5nbGVfKGIsIGQsIGEsIGJTcmMsIGRTcmMsIGFTcmMpO1xuICAgICAgfVxuICAgICAgaWYgKChpc05vdEZpbml0ZSAmIDB4NykgPT0gMCkge1xuICAgICAgICB0aGlzLmFkZFRyaWFuZ2xlXyhiLCBkLCBjLCBiU3JjLCBkU3JjLCBjU3JjKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2FsY3VsYXRlcyBleHRlbnQgb2YgdGhlIGBzb3VyY2VgIGNvb3JkaW5hdGVzIGZyb20gYWxsIHRoZSB0cmlhbmdsZXMuXG4gICAqXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IENhbGN1bGF0ZWQgZXh0ZW50LlxuICAgKi9cbiAgY2FsY3VsYXRlU291cmNlRXh0ZW50KCkge1xuICAgIGNvbnN0IGV4dGVudCA9IGNyZWF0ZUVtcHR5KCk7XG5cbiAgICB0aGlzLnRyaWFuZ2xlc18uZm9yRWFjaChmdW5jdGlvbiAodHJpYW5nbGUsIGksIGFycikge1xuICAgICAgY29uc3Qgc3JjID0gdHJpYW5nbGUuc291cmNlO1xuICAgICAgZXh0ZW5kQ29vcmRpbmF0ZShleHRlbnQsIHNyY1swXSk7XG4gICAgICBleHRlbmRDb29yZGluYXRlKGV4dGVudCwgc3JjWzFdKTtcbiAgICAgIGV4dGVuZENvb3JkaW5hdGUoZXh0ZW50LCBzcmNbMl0pO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGV4dGVudDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtBcnJheTxUcmlhbmdsZT59IEFycmF5IG9mIHRoZSBjYWxjdWxhdGVkIHRyaWFuZ2xlcy5cbiAgICovXG4gIGdldFRyaWFuZ2xlcygpIHtcbiAgICByZXR1cm4gdGhpcy50cmlhbmdsZXNfO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFRyaWFuZ3VsYXRpb247XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvcmVwcm9qL2NvbW1vblxuICovXG5cbi8qKlxuICogRGVmYXVsdCBtYXhpbXVtIGFsbG93ZWQgdGhyZXNob2xkICAoaW4gcGl4ZWxzKSBmb3IgcmVwcm9qZWN0aW9uXG4gKiB0cmlhbmd1bGF0aW9uLlxuICogQHR5cGUge251bWJlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IEVSUk9SX1RIUkVTSE9MRCA9IDAuNTtcbiIsIi8qKlxuICogQG1vZHVsZSBvbC9yZXNvbHV0aW9uY29uc3RyYWludFxuICovXG5pbXBvcnQge2NsYW1wfSBmcm9tICcuL21hdGguanMnO1xuaW1wb3J0IHtnZXRIZWlnaHQsIGdldFdpZHRofSBmcm9tICcuL2V4dGVudC5qcyc7XG5pbXBvcnQge2xpbmVhckZpbmROZWFyZXN0fSBmcm9tICcuL2FycmF5LmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7ZnVuY3Rpb24oKG51bWJlcnx1bmRlZmluZWQpLCBudW1iZXIsIGltcG9ydChcIi4vc2l6ZS5qc1wiKS5TaXplLCBib29sZWFuPSk6IChudW1iZXJ8dW5kZWZpbmVkKX0gVHlwZVxuICovXG5cbi8qKlxuICogUmV0dXJucyBhIG1vZGlmaWVkIHJlc29sdXRpb24gdGFraW5nIGludG8gYWNjb3VudCB0aGUgdmlld3BvcnQgc2l6ZSBhbmQgbWF4aW11bVxuICogYWxsb3dlZCBleHRlbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gcmVzb2x1dGlvbiBSZXNvbHV0aW9uXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gbWF4RXh0ZW50IE1heGltdW0gYWxsb3dlZCBleHRlbnQuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vc2l6ZS5qc1wiKS5TaXplfSB2aWV3cG9ydFNpemUgVmlld3BvcnQgc2l6ZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gc2hvd0Z1bGxFeHRlbnQgV2hldGhlciB0byBzaG93IHRoZSBmdWxsIGV4dGVudC5cbiAqIEByZXR1cm4ge251bWJlcn0gQ2FwcGVkIHJlc29sdXRpb24uXG4gKi9cbmZ1bmN0aW9uIGdldFZpZXdwb3J0Q2xhbXBlZFJlc29sdXRpb24oXG4gIHJlc29sdXRpb24sXG4gIG1heEV4dGVudCxcbiAgdmlld3BvcnRTaXplLFxuICBzaG93RnVsbEV4dGVudFxuKSB7XG4gIGNvbnN0IHhSZXNvbHV0aW9uID0gZ2V0V2lkdGgobWF4RXh0ZW50KSAvIHZpZXdwb3J0U2l6ZVswXTtcbiAgY29uc3QgeVJlc29sdXRpb24gPSBnZXRIZWlnaHQobWF4RXh0ZW50KSAvIHZpZXdwb3J0U2l6ZVsxXTtcblxuICBpZiAoc2hvd0Z1bGxFeHRlbnQpIHtcbiAgICByZXR1cm4gTWF0aC5taW4ocmVzb2x1dGlvbiwgTWF0aC5tYXgoeFJlc29sdXRpb24sIHlSZXNvbHV0aW9uKSk7XG4gIH1cbiAgcmV0dXJuIE1hdGgubWluKHJlc29sdXRpb24sIE1hdGgubWluKHhSZXNvbHV0aW9uLCB5UmVzb2x1dGlvbikpO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBtb2RpZmllZCByZXNvbHV0aW9uIHRvIGJlIGJldHdlZW4gbWF4UmVzb2x1dGlvbiBhbmQgbWluUmVzb2x1dGlvbiB3aGlsZVxuICogc3RpbGwgYWxsb3dpbmcgdGhlIHZhbHVlIHRvIGJlIHNsaWdodGx5IG91dCBvZiBib3VuZHMuXG4gKiBOb3RlOiB0aGUgY29tcHV0YXRpb24gaXMgYmFzZWQgb24gdGhlIGxvZ2FyaXRobSBmdW5jdGlvbiAobG4pOlxuICogIC0gYXQgMSwgbG4oeCkgaXMgMFxuICogIC0gYWJvdmUgMSwgbG4oeCkga2VlcHMgaW5jcmVhc2luZyBidXQgYXQgYSBtdWNoIHNsb3dlciBwYWNlIHRoYW4geFxuICogVGhlIGZpbmFsIHJlc3VsdCBpcyBjbGFtcGVkIHRvIHByZXZlbnQgZ2V0dGluZyB0b28gZmFyIGF3YXkgZnJvbSBib3VuZHMuXG4gKiBAcGFyYW0ge251bWJlcn0gcmVzb2x1dGlvbiBSZXNvbHV0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IG1heFJlc29sdXRpb24gTWF4IHJlc29sdXRpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gbWluUmVzb2x1dGlvbiBNaW4gcmVzb2x1dGlvbi5cbiAqIEByZXR1cm4ge251bWJlcn0gU21vb3RoZWQgcmVzb2x1dGlvbi5cbiAqL1xuZnVuY3Rpb24gZ2V0U21vb3RoQ2xhbXBlZFJlc29sdXRpb24ocmVzb2x1dGlvbiwgbWF4UmVzb2x1dGlvbiwgbWluUmVzb2x1dGlvbikge1xuICBsZXQgcmVzdWx0ID0gTWF0aC5taW4ocmVzb2x1dGlvbiwgbWF4UmVzb2x1dGlvbik7XG4gIGNvbnN0IHJhdGlvID0gNTA7XG5cbiAgcmVzdWx0ICo9XG4gICAgTWF0aC5sb2coMSArIHJhdGlvICogTWF0aC5tYXgoMCwgcmVzb2x1dGlvbiAvIG1heFJlc29sdXRpb24gLSAxKSkgLyByYXRpbyArXG4gICAgMTtcbiAgaWYgKG1pblJlc29sdXRpb24pIHtcbiAgICByZXN1bHQgPSBNYXRoLm1heChyZXN1bHQsIG1pblJlc29sdXRpb24pO1xuICAgIHJlc3VsdCAvPVxuICAgICAgTWF0aC5sb2coMSArIHJhdGlvICogTWF0aC5tYXgoMCwgbWluUmVzb2x1dGlvbiAvIHJlc29sdXRpb24gLSAxKSkgL1xuICAgICAgICByYXRpbyArXG4gICAgICAxO1xuICB9XG4gIHJldHVybiBjbGFtcChyZXN1bHQsIG1pblJlc29sdXRpb24gLyAyLCBtYXhSZXNvbHV0aW9uICogMik7XG59XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSByZXNvbHV0aW9ucyBSZXNvbHV0aW9ucy5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3Ntb290aF0gSWYgdHJ1ZSwgdGhlIHZpZXcgd2lsbCBiZSBhYmxlIHRvIHNsaWdodGx5IGV4Y2VlZCByZXNvbHV0aW9uIGxpbWl0cy4gRGVmYXVsdDogdHJ1ZS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9leHRlbnQuanNcIikuRXh0ZW50fSBbbWF4RXh0ZW50XSBNYXhpbXVtIGFsbG93ZWQgZXh0ZW50LlxuICogQHBhcmFtIHtib29sZWFufSBbc2hvd0Z1bGxFeHRlbnRdIElmIHRydWUsIGFsbG93cyB1cyB0byBzaG93IHRoZSBmdWxsIGV4dGVudC4gRGVmYXVsdDogZmFsc2UuXG4gKiBAcmV0dXJuIHtUeXBlfSBab29tIGZ1bmN0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU25hcFRvUmVzb2x1dGlvbnMoXG4gIHJlc29sdXRpb25zLFxuICBzbW9vdGgsXG4gIG1heEV4dGVudCxcbiAgc2hvd0Z1bGxFeHRlbnRcbikge1xuICBzbW9vdGggPSBzbW9vdGggIT09IHVuZGVmaW5lZCA/IHNtb290aCA6IHRydWU7XG4gIHJldHVybiAoXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ8dW5kZWZpbmVkfSByZXNvbHV0aW9uIFJlc29sdXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRpcmVjdGlvbiBEaXJlY3Rpb24uXG4gICAgICogQHBhcmFtIHtpbXBvcnQoXCIuL3NpemUuanNcIikuU2l6ZX0gc2l6ZSBWaWV3cG9ydCBzaXplLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzTW92aW5nXSBUcnVlIGlmIGFuIGludGVyYWN0aW9uIG9yIGFuaW1hdGlvbiBpcyBpbiBwcm9ncmVzcy5cbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ8dW5kZWZpbmVkfSBSZXNvbHV0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChyZXNvbHV0aW9uLCBkaXJlY3Rpb24sIHNpemUsIGlzTW92aW5nKSB7XG4gICAgICBpZiAocmVzb2x1dGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IG1heFJlc29sdXRpb24gPSByZXNvbHV0aW9uc1swXTtcbiAgICAgICAgY29uc3QgbWluUmVzb2x1dGlvbiA9IHJlc29sdXRpb25zW3Jlc29sdXRpb25zLmxlbmd0aCAtIDFdO1xuICAgICAgICBjb25zdCBjYXBwZWRNYXhSZXMgPSBtYXhFeHRlbnRcbiAgICAgICAgICA/IGdldFZpZXdwb3J0Q2xhbXBlZFJlc29sdXRpb24oXG4gICAgICAgICAgICAgIG1heFJlc29sdXRpb24sXG4gICAgICAgICAgICAgIG1heEV4dGVudCxcbiAgICAgICAgICAgICAgc2l6ZSxcbiAgICAgICAgICAgICAgc2hvd0Z1bGxFeHRlbnRcbiAgICAgICAgICAgIClcbiAgICAgICAgICA6IG1heFJlc29sdXRpb247XG5cbiAgICAgICAgLy8gZHVyaW5nIGludGVyYWN0aW5nIG9yIGFuaW1hdGluZywgYWxsb3cgaW50ZXJtZWRpYXJ5IHZhbHVlc1xuICAgICAgICBpZiAoaXNNb3ZpbmcpIHtcbiAgICAgICAgICBpZiAoIXNtb290aCkge1xuICAgICAgICAgICAgcmV0dXJuIGNsYW1wKHJlc29sdXRpb24sIG1pblJlc29sdXRpb24sIGNhcHBlZE1heFJlcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBnZXRTbW9vdGhDbGFtcGVkUmVzb2x1dGlvbihcbiAgICAgICAgICAgIHJlc29sdXRpb24sXG4gICAgICAgICAgICBjYXBwZWRNYXhSZXMsXG4gICAgICAgICAgICBtaW5SZXNvbHV0aW9uXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNhcHBlZCA9IE1hdGgubWluKGNhcHBlZE1heFJlcywgcmVzb2x1dGlvbik7XG4gICAgICAgIGNvbnN0IHogPSBNYXRoLmZsb29yKGxpbmVhckZpbmROZWFyZXN0KHJlc29sdXRpb25zLCBjYXBwZWQsIGRpcmVjdGlvbikpO1xuICAgICAgICBpZiAocmVzb2x1dGlvbnNbel0gPiBjYXBwZWRNYXhSZXMgJiYgeiA8IHJlc29sdXRpb25zLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICByZXR1cm4gcmVzb2x1dGlvbnNbeiArIDFdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNvbHV0aW9uc1t6XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICApO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBwb3dlciBQb3dlci5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXhSZXNvbHV0aW9uIE1heGltdW0gcmVzb2x1dGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbbWluUmVzb2x1dGlvbl0gTWluaW11bSByZXNvbHV0aW9uLlxuICogQHBhcmFtIHtib29sZWFufSBbc21vb3RoXSBJZiB0cnVlLCB0aGUgdmlldyB3aWxsIGJlIGFibGUgdG8gc2xpZ2h0bHkgZXhjZWVkIHJlc29sdXRpb24gbGltaXRzLiBEZWZhdWx0OiB0cnVlLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL2V4dGVudC5qc1wiKS5FeHRlbnR9IFttYXhFeHRlbnRdIE1heGltdW0gYWxsb3dlZCBleHRlbnQuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtzaG93RnVsbEV4dGVudF0gSWYgdHJ1ZSwgYWxsb3dzIHVzIHRvIHNob3cgdGhlIGZ1bGwgZXh0ZW50LiBEZWZhdWx0OiBmYWxzZS5cbiAqIEByZXR1cm4ge1R5cGV9IFpvb20gZnVuY3Rpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVTbmFwVG9Qb3dlcihcbiAgcG93ZXIsXG4gIG1heFJlc29sdXRpb24sXG4gIG1pblJlc29sdXRpb24sXG4gIHNtb290aCxcbiAgbWF4RXh0ZW50LFxuICBzaG93RnVsbEV4dGVudFxuKSB7XG4gIHNtb290aCA9IHNtb290aCAhPT0gdW5kZWZpbmVkID8gc21vb3RoIDogdHJ1ZTtcbiAgbWluUmVzb2x1dGlvbiA9IG1pblJlc29sdXRpb24gIT09IHVuZGVmaW5lZCA/IG1pblJlc29sdXRpb24gOiAwO1xuXG4gIHJldHVybiAoXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ8dW5kZWZpbmVkfSByZXNvbHV0aW9uIFJlc29sdXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRpcmVjdGlvbiBEaXJlY3Rpb24uXG4gICAgICogQHBhcmFtIHtpbXBvcnQoXCIuL3NpemUuanNcIikuU2l6ZX0gc2l6ZSBWaWV3cG9ydCBzaXplLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzTW92aW5nXSBUcnVlIGlmIGFuIGludGVyYWN0aW9uIG9yIGFuaW1hdGlvbiBpcyBpbiBwcm9ncmVzcy5cbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ8dW5kZWZpbmVkfSBSZXNvbHV0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChyZXNvbHV0aW9uLCBkaXJlY3Rpb24sIHNpemUsIGlzTW92aW5nKSB7XG4gICAgICBpZiAocmVzb2x1dGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IGNhcHBlZE1heFJlcyA9IG1heEV4dGVudFxuICAgICAgICAgID8gZ2V0Vmlld3BvcnRDbGFtcGVkUmVzb2x1dGlvbihcbiAgICAgICAgICAgICAgbWF4UmVzb2x1dGlvbixcbiAgICAgICAgICAgICAgbWF4RXh0ZW50LFxuICAgICAgICAgICAgICBzaXplLFxuICAgICAgICAgICAgICBzaG93RnVsbEV4dGVudFxuICAgICAgICAgICAgKVxuICAgICAgICAgIDogbWF4UmVzb2x1dGlvbjtcblxuICAgICAgICAvLyBkdXJpbmcgaW50ZXJhY3Rpbmcgb3IgYW5pbWF0aW5nLCBhbGxvdyBpbnRlcm1lZGlhcnkgdmFsdWVzXG4gICAgICAgIGlmIChpc01vdmluZykge1xuICAgICAgICAgIGlmICghc21vb3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gY2xhbXAocmVzb2x1dGlvbiwgbWluUmVzb2x1dGlvbiwgY2FwcGVkTWF4UmVzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGdldFNtb290aENsYW1wZWRSZXNvbHV0aW9uKFxuICAgICAgICAgICAgcmVzb2x1dGlvbixcbiAgICAgICAgICAgIGNhcHBlZE1heFJlcyxcbiAgICAgICAgICAgIG1pblJlc29sdXRpb25cbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdG9sZXJhbmNlID0gMWUtOTtcbiAgICAgICAgY29uc3QgbWluWm9vbUxldmVsID0gTWF0aC5jZWlsKFxuICAgICAgICAgIE1hdGgubG9nKG1heFJlc29sdXRpb24gLyBjYXBwZWRNYXhSZXMpIC8gTWF0aC5sb2cocG93ZXIpIC0gdG9sZXJhbmNlXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IC1kaXJlY3Rpb24gKiAoMC41IC0gdG9sZXJhbmNlKSArIDAuNTtcbiAgICAgICAgY29uc3QgY2FwcGVkID0gTWF0aC5taW4oY2FwcGVkTWF4UmVzLCByZXNvbHV0aW9uKTtcbiAgICAgICAgY29uc3QgY2FwcGVkWm9vbUxldmVsID0gTWF0aC5mbG9vcihcbiAgICAgICAgICBNYXRoLmxvZyhtYXhSZXNvbHV0aW9uIC8gY2FwcGVkKSAvIE1hdGgubG9nKHBvd2VyKSArIG9mZnNldFxuICAgICAgICApO1xuICAgICAgICBjb25zdCB6b29tTGV2ZWwgPSBNYXRoLm1heChtaW5ab29tTGV2ZWwsIGNhcHBlZFpvb21MZXZlbCk7XG4gICAgICAgIGNvbnN0IG5ld1Jlc29sdXRpb24gPSBtYXhSZXNvbHV0aW9uIC8gTWF0aC5wb3cocG93ZXIsIHpvb21MZXZlbCk7XG4gICAgICAgIHJldHVybiBjbGFtcChuZXdSZXNvbHV0aW9uLCBtaW5SZXNvbHV0aW9uLCBjYXBwZWRNYXhSZXMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IG1heFJlc29sdXRpb24gTWF4IHJlc29sdXRpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gbWluUmVzb2x1dGlvbiBNaW4gcmVzb2x1dGlvbi5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3Ntb290aF0gSWYgdHJ1ZSwgdGhlIHZpZXcgd2lsbCBiZSBhYmxlIHRvIHNsaWdodGx5IGV4Y2VlZCByZXNvbHV0aW9uIGxpbWl0cy4gRGVmYXVsdDogdHJ1ZS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9leHRlbnQuanNcIikuRXh0ZW50fSBbbWF4RXh0ZW50XSBNYXhpbXVtIGFsbG93ZWQgZXh0ZW50LlxuICogQHBhcmFtIHtib29sZWFufSBbc2hvd0Z1bGxFeHRlbnRdIElmIHRydWUsIGFsbG93cyB1cyB0byBzaG93IHRoZSBmdWxsIGV4dGVudC4gRGVmYXVsdDogZmFsc2UuXG4gKiBAcmV0dXJuIHtUeXBlfSBab29tIGZ1bmN0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlTWluTWF4UmVzb2x1dGlvbihcbiAgbWF4UmVzb2x1dGlvbixcbiAgbWluUmVzb2x1dGlvbixcbiAgc21vb3RoLFxuICBtYXhFeHRlbnQsXG4gIHNob3dGdWxsRXh0ZW50XG4pIHtcbiAgc21vb3RoID0gc21vb3RoICE9PSB1bmRlZmluZWQgPyBzbW9vdGggOiB0cnVlO1xuXG4gIHJldHVybiAoXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ8dW5kZWZpbmVkfSByZXNvbHV0aW9uIFJlc29sdXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRpcmVjdGlvbiBEaXJlY3Rpb24uXG4gICAgICogQHBhcmFtIHtpbXBvcnQoXCIuL3NpemUuanNcIikuU2l6ZX0gc2l6ZSBWaWV3cG9ydCBzaXplLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzTW92aW5nXSBUcnVlIGlmIGFuIGludGVyYWN0aW9uIG9yIGFuaW1hdGlvbiBpcyBpbiBwcm9ncmVzcy5cbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ8dW5kZWZpbmVkfSBSZXNvbHV0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChyZXNvbHV0aW9uLCBkaXJlY3Rpb24sIHNpemUsIGlzTW92aW5nKSB7XG4gICAgICBpZiAocmVzb2x1dGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IGNhcHBlZE1heFJlcyA9IG1heEV4dGVudFxuICAgICAgICAgID8gZ2V0Vmlld3BvcnRDbGFtcGVkUmVzb2x1dGlvbihcbiAgICAgICAgICAgICAgbWF4UmVzb2x1dGlvbixcbiAgICAgICAgICAgICAgbWF4RXh0ZW50LFxuICAgICAgICAgICAgICBzaXplLFxuICAgICAgICAgICAgICBzaG93RnVsbEV4dGVudFxuICAgICAgICAgICAgKVxuICAgICAgICAgIDogbWF4UmVzb2x1dGlvbjtcblxuICAgICAgICBpZiAoIXNtb290aCB8fCAhaXNNb3ZpbmcpIHtcbiAgICAgICAgICByZXR1cm4gY2xhbXAocmVzb2x1dGlvbiwgbWluUmVzb2x1dGlvbiwgY2FwcGVkTWF4UmVzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ2V0U21vb3RoQ2xhbXBlZFJlc29sdXRpb24oXG4gICAgICAgICAgcmVzb2x1dGlvbixcbiAgICAgICAgICBjYXBwZWRNYXhSZXMsXG4gICAgICAgICAgbWluUmVzb2x1dGlvblxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICk7XG59XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvcm90YXRpb25jb25zdHJhaW50XG4gKi9cbmltcG9ydCB7dG9SYWRpYW5zfSBmcm9tICcuL21hdGguanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtmdW5jdGlvbigobnVtYmVyfHVuZGVmaW5lZCksIGJvb2xlYW49KTogKG51bWJlcnx1bmRlZmluZWQpfSBUeXBlXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcnx1bmRlZmluZWR9IHJvdGF0aW9uIFJvdGF0aW9uLlxuICogQHJldHVybiB7bnVtYmVyfHVuZGVmaW5lZH0gUm90YXRpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkaXNhYmxlKHJvdGF0aW9uKSB7XG4gIGlmIChyb3RhdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcnx1bmRlZmluZWR9IHJvdGF0aW9uIFJvdGF0aW9uLlxuICogQHJldHVybiB7bnVtYmVyfHVuZGVmaW5lZH0gUm90YXRpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBub25lKHJvdGF0aW9uKSB7XG4gIGlmIChyb3RhdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHJvdGF0aW9uO1xuICB9XG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IG4gTi5cbiAqIEByZXR1cm4ge1R5cGV9IFJvdGF0aW9uIGNvbnN0cmFpbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVTbmFwVG9OKG4pIHtcbiAgY29uc3QgdGhldGEgPSAoMiAqIE1hdGguUEkpIC8gbjtcbiAgcmV0dXJuIChcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge251bWJlcnx1bmRlZmluZWR9IHJvdGF0aW9uIFJvdGF0aW9uLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzTW92aW5nXSBUcnVlIGlmIGFuIGludGVyYWN0aW9uIG9yIGFuaW1hdGlvbiBpcyBpbiBwcm9ncmVzcy5cbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ8dW5kZWZpbmVkfSBSb3RhdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAocm90YXRpb24sIGlzTW92aW5nKSB7XG4gICAgICBpZiAoaXNNb3ZpbmcpIHtcbiAgICAgICAgcmV0dXJuIHJvdGF0aW9uO1xuICAgICAgfVxuXG4gICAgICBpZiAocm90YXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByb3RhdGlvbiA9IE1hdGguZmxvb3Iocm90YXRpb24gLyB0aGV0YSArIDAuNSkgKiB0aGV0YTtcbiAgICAgICAgcmV0dXJuIHJvdGF0aW9uO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IFt0b2xlcmFuY2VdIFRvbGVyYW5jZS5cbiAqIEByZXR1cm4ge1R5cGV9IFJvdGF0aW9uIGNvbnN0cmFpbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVTbmFwVG9aZXJvKHRvbGVyYW5jZSkge1xuICB0b2xlcmFuY2UgPSB0b2xlcmFuY2UgfHwgdG9SYWRpYW5zKDUpO1xuICByZXR1cm4gKFxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfHVuZGVmaW5lZH0gcm90YXRpb24gUm90YXRpb24uXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNNb3ZpbmddIFRydWUgaWYgYW4gaW50ZXJhY3Rpb24gb3IgYW5pbWF0aW9uIGlzIGluIHByb2dyZXNzLlxuICAgICAqIEByZXR1cm4ge251bWJlcnx1bmRlZmluZWR9IFJvdGF0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChyb3RhdGlvbiwgaXNNb3ZpbmcpIHtcbiAgICAgIGlmIChpc01vdmluZykge1xuICAgICAgICByZXR1cm4gcm90YXRpb247XG4gICAgICB9XG5cbiAgICAgIGlmIChyb3RhdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChNYXRoLmFicyhyb3RhdGlvbikgPD0gdG9sZXJhbmNlKSB7XG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJvdGF0aW9uO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICk7XG59XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvc2l6ZVxuICovXG5cbi8qKlxuICogQW4gYXJyYXkgb2YgbnVtYmVycyByZXByZXNlbnRpbmcgYSBzaXplOiBgW3dpZHRoLCBoZWlnaHRdYC5cbiAqIEB0eXBlZGVmIHtBcnJheTxudW1iZXI+fSBTaXplXG4gKiBAYXBpXG4gKi9cblxuLyoqXG4gKiBSZXR1cm5zIGEgYnVmZmVyZWQgc2l6ZS5cbiAqIEBwYXJhbSB7U2l6ZX0gc2l6ZSBTaXplLlxuICogQHBhcmFtIHtudW1iZXJ9IG51bSBUaGUgYW1vdW50IGJ5IHdoaWNoIHRvIGJ1ZmZlci5cbiAqIEBwYXJhbSB7U2l6ZX0gW2Rlc3RdIE9wdGlvbmFsIHJldXNhYmxlIHNpemUgYXJyYXkuXG4gKiBAcmV0dXJuIHtTaXplfSBUaGUgYnVmZmVyZWQgc2l6ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ1ZmZlcihzaXplLCBudW0sIGRlc3QpIHtcbiAgaWYgKGRlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgIGRlc3QgPSBbMCwgMF07XG4gIH1cbiAgZGVzdFswXSA9IHNpemVbMF0gKyAyICogbnVtO1xuICBkZXN0WzFdID0gc2l6ZVsxXSArIDIgKiBudW07XG4gIHJldHVybiBkZXN0O1xufVxuXG4vKipcbiAqIERldGVybWluZXMgaWYgYSBzaXplIGhhcyBhIHBvc2l0aXZlIGFyZWEuXG4gKiBAcGFyYW0ge1NpemV9IHNpemUgVGhlIHNpemUgdG8gdGVzdC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSBzaXplIGhhcyBhIHBvc2l0aXZlIGFyZWEuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoYXNBcmVhKHNpemUpIHtcbiAgcmV0dXJuIHNpemVbMF0gPiAwICYmIHNpemVbMV0gPiAwO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBzaXplIHNjYWxlZCBieSBhIHJhdGlvLiBUaGUgcmVzdWx0IHdpbGwgYmUgYW4gYXJyYXkgb2YgaW50ZWdlcnMuXG4gKiBAcGFyYW0ge1NpemV9IHNpemUgU2l6ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSByYXRpbyBSYXRpby5cbiAqIEBwYXJhbSB7U2l6ZX0gW2Rlc3RdIE9wdGlvbmFsIHJldXNhYmxlIHNpemUgYXJyYXkuXG4gKiBAcmV0dXJuIHtTaXplfSBUaGUgc2NhbGVkIHNpemUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzY2FsZShzaXplLCByYXRpbywgZGVzdCkge1xuICBpZiAoZGVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZGVzdCA9IFswLCAwXTtcbiAgfVxuICBkZXN0WzBdID0gKHNpemVbMF0gKiByYXRpbyArIDAuNSkgfCAwO1xuICBkZXN0WzFdID0gKHNpemVbMV0gKiByYXRpbyArIDAuNSkgfCAwO1xuICByZXR1cm4gZGVzdDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGFuIGBTaXplYCBhcnJheSBmb3IgdGhlIHBhc3NlZCBpbiBudW1iZXIgKG1lYW5pbmc6IHNxdWFyZSkgb3JcbiAqIGBTaXplYCBhcnJheS5cbiAqIChtZWFuaW5nOiBub24tc3F1YXJlKSxcbiAqIEBwYXJhbSB7bnVtYmVyfFNpemV9IHNpemUgV2lkdGggYW5kIGhlaWdodC5cbiAqIEBwYXJhbSB7U2l6ZX0gW2Rlc3RdIE9wdGlvbmFsIHJldXNhYmxlIHNpemUgYXJyYXkuXG4gKiBAcmV0dXJuIHtTaXplfSBTaXplLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9TaXplKHNpemUsIGRlc3QpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoc2l6ZSkpIHtcbiAgICByZXR1cm4gc2l6ZTtcbiAgfVxuICBpZiAoZGVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZGVzdCA9IFtzaXplLCBzaXplXTtcbiAgfSBlbHNlIHtcbiAgICBkZXN0WzBdID0gc2l6ZTtcbiAgICBkZXN0WzFdID0gc2l6ZTtcbiAgfVxuICByZXR1cm4gZGVzdDtcbn1cbiIsIi8qKlxuICogQG1vZHVsZSBvbC9zb3VyY2UvT1NNXG4gKi9cblxuaW1wb3J0IFhZWiBmcm9tICcuL1hZWi5qcyc7XG5cbi8qKlxuICogVGhlIGF0dHJpYnV0aW9uIGNvbnRhaW5pbmcgYSBsaW5rIHRvIHRoZSBPcGVuU3RyZWV0TWFwIENvcHlyaWdodCBhbmQgTGljZW5zZVxuICogcGFnZS5cbiAqIEBjb25zdFxuICogQHR5cGUge3N0cmluZ31cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGNvbnN0IEFUVFJJQlVUSU9OID1cbiAgJyYjMTY5OyAnICtcbiAgJzxhIGhyZWY9XCJodHRwczovL3d3dy5vcGVuc3RyZWV0bWFwLm9yZy9jb3B5cmlnaHRcIiB0YXJnZXQ9XCJfYmxhbmtcIj5PcGVuU3RyZWV0TWFwPC9hPiAnICtcbiAgJ2NvbnRyaWJ1dG9ycy4nO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi9Tb3VyY2UuanNcIikuQXR0cmlidXRpb25MaWtlfSBbYXR0cmlidXRpb25zXSBBdHRyaWJ1dGlvbnMuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2NhY2hlU2l6ZV0gSW5pdGlhbCB0aWxlIGNhY2hlIHNpemUuIFdpbGwgYXV0by1ncm93IHRvIGhvbGQgYXQgbGVhc3QgdGhlIG51bWJlciBvZiB0aWxlcyBpbiB0aGUgdmlld3BvcnQuXG4gKiBAcHJvcGVydHkge251bGx8c3RyaW5nfSBbY3Jvc3NPcmlnaW49J2Fub255bW91cyddIFRoZSBgY3Jvc3NPcmlnaW5gIGF0dHJpYnV0ZSBmb3IgbG9hZGVkIGltYWdlcy4gIE5vdGUgdGhhdFxuICogeW91IG11c3QgcHJvdmlkZSBhIGBjcm9zc09yaWdpbmAgdmFsdWUgaWYgeW91IHdhbnQgdG8gYWNjZXNzIHBpeGVsIGRhdGEgd2l0aCB0aGUgQ2FudmFzIHJlbmRlcmVyLlxuICogU2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvQ09SU19lbmFibGVkX2ltYWdlIGZvciBtb3JlIGRldGFpbC5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2ludGVycG9sYXRlPXRydWVdIFVzZSBpbnRlcnBvbGF0ZWQgdmFsdWVzIHdoZW4gcmVzYW1wbGluZy4gIEJ5IGRlZmF1bHQsXG4gKiBsaW5lYXIgaW50ZXJwb2xhdGlvbiBpcyB1c2VkIHdoZW4gcmVzYW1wbGluZy4gIFNldCB0byBmYWxzZSB0byB1c2UgdGhlIG5lYXJlc3QgbmVpZ2hib3IgaW5zdGVhZC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbWF4Wm9vbT0xOV0gTWF4IHpvb20uXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtvcGFxdWU9dHJ1ZV0gV2hldGhlciB0aGUgbGF5ZXIgaXMgb3BhcXVlLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtyZXByb2plY3Rpb25FcnJvclRocmVzaG9sZD0wLjVdIE1heGltdW0gYWxsb3dlZCByZXByb2plY3Rpb24gZXJyb3IgKGluIHBpeGVscykuXG4gKiBIaWdoZXIgdmFsdWVzIGNhbiBpbmNyZWFzZSByZXByb2plY3Rpb24gcGVyZm9ybWFuY2UsIGJ1dCBkZWNyZWFzZSBwcmVjaXNpb24uXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL1RpbGUuanNcIikuTG9hZEZ1bmN0aW9ufSBbdGlsZUxvYWRGdW5jdGlvbl0gT3B0aW9uYWwgZnVuY3Rpb24gdG8gbG9hZCBhIHRpbGUgZ2l2ZW4gYSBVUkwuIFRoZSBkZWZhdWx0IGlzXG4gKiBgYGBqc1xuICogZnVuY3Rpb24oaW1hZ2VUaWxlLCBzcmMpIHtcbiAqICAgaW1hZ2VUaWxlLmdldEltYWdlKCkuc3JjID0gc3JjO1xuICogfTtcbiAqIGBgYFxuICogQHByb3BlcnR5IHtudW1iZXJ9IFt0cmFuc2l0aW9uPTI1MF0gRHVyYXRpb24gb2YgdGhlIG9wYWNpdHkgdHJhbnNpdGlvbiBmb3IgcmVuZGVyaW5nLlxuICogVG8gZGlzYWJsZSB0aGUgb3BhY2l0eSB0cmFuc2l0aW9uLCBwYXNzIGB0cmFuc2l0aW9uOiAwYC5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbdXJsPSdodHRwczovL3RpbGUub3BlbnN0cmVldG1hcC5vcmcve3p9L3t4fS97eX0ucG5nJ10gVVJMIHRlbXBsYXRlLlxuICogTXVzdCBpbmNsdWRlIGB7eH1gLCBge3l9YCBvciBgey15fWAsIGFuZCBge3p9YCBwbGFjZWhvbGRlcnMuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFt3cmFwWD10cnVlXSBXaGV0aGVyIHRvIHdyYXAgdGhlIHdvcmxkIGhvcml6b250YWxseS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfGltcG9ydChcIi4uL2FycmF5LmpzXCIpLk5lYXJlc3REaXJlY3Rpb25GdW5jdGlvbn0gW3pEaXJlY3Rpb249MF1cbiAqIENob29zZSB3aGV0aGVyIHRvIHVzZSB0aWxlcyB3aXRoIGEgaGlnaGVyIG9yIGxvd2VyIHpvb20gbGV2ZWwgd2hlbiBiZXR3ZWVuIGludGVnZXJcbiAqIHpvb20gbGV2ZWxzLiBTZWUge0BsaW5rIG1vZHVsZTpvbC90aWxlZ3JpZC9UaWxlR3JpZH5UaWxlR3JpZCNnZXRaRm9yUmVzb2x1dGlvbn0uXG4gKi9cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBMYXllciBzb3VyY2UgZm9yIHRoZSBPcGVuU3RyZWV0TWFwIHRpbGUgc2VydmVyLlxuICogQGFwaVxuICovXG5jbGFzcyBPU00gZXh0ZW5kcyBYWVoge1xuICAvKipcbiAgICogQHBhcmFtIHtPcHRpb25zfSBbb3B0aW9uc10gT3BlbiBTdHJlZXQgTWFwIG9wdGlvbnMuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICBsZXQgYXR0cmlidXRpb25zO1xuICAgIGlmIChvcHRpb25zLmF0dHJpYnV0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBhdHRyaWJ1dGlvbnMgPSBvcHRpb25zLmF0dHJpYnV0aW9ucztcbiAgICB9IGVsc2Uge1xuICAgICAgYXR0cmlidXRpb25zID0gW0FUVFJJQlVUSU9OXTtcbiAgICB9XG5cbiAgICBjb25zdCBjcm9zc09yaWdpbiA9XG4gICAgICBvcHRpb25zLmNyb3NzT3JpZ2luICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmNyb3NzT3JpZ2luIDogJ2Fub255bW91cyc7XG5cbiAgICBjb25zdCB1cmwgPVxuICAgICAgb3B0aW9ucy51cmwgIT09IHVuZGVmaW5lZFxuICAgICAgICA/IG9wdGlvbnMudXJsXG4gICAgICAgIDogJ2h0dHBzOi8vdGlsZS5vcGVuc3RyZWV0bWFwLm9yZy97en0ve3h9L3t5fS5wbmcnO1xuXG4gICAgc3VwZXIoe1xuICAgICAgYXR0cmlidXRpb25zOiBhdHRyaWJ1dGlvbnMsXG4gICAgICBhdHRyaWJ1dGlvbnNDb2xsYXBzaWJsZTogZmFsc2UsXG4gICAgICBjYWNoZVNpemU6IG9wdGlvbnMuY2FjaGVTaXplLFxuICAgICAgY3Jvc3NPcmlnaW46IGNyb3NzT3JpZ2luLFxuICAgICAgaW50ZXJwb2xhdGU6IG9wdGlvbnMuaW50ZXJwb2xhdGUsXG4gICAgICBtYXhab29tOiBvcHRpb25zLm1heFpvb20gIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMubWF4Wm9vbSA6IDE5LFxuICAgICAgb3BhcXVlOiBvcHRpb25zLm9wYXF1ZSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5vcGFxdWUgOiB0cnVlLFxuICAgICAgcmVwcm9qZWN0aW9uRXJyb3JUaHJlc2hvbGQ6IG9wdGlvbnMucmVwcm9qZWN0aW9uRXJyb3JUaHJlc2hvbGQsXG4gICAgICB0aWxlTG9hZEZ1bmN0aW9uOiBvcHRpb25zLnRpbGVMb2FkRnVuY3Rpb24sXG4gICAgICB0cmFuc2l0aW9uOiBvcHRpb25zLnRyYW5zaXRpb24sXG4gICAgICB1cmw6IHVybCxcbiAgICAgIHdyYXBYOiBvcHRpb25zLndyYXBYLFxuICAgICAgekRpcmVjdGlvbjogb3B0aW9ucy56RGlyZWN0aW9uLFxuICAgIH0pO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE9TTTtcbiIsIi8qKlxuICogQG1vZHVsZSBvbC9zb3VyY2UvU291cmNlXG4gKi9cbmltcG9ydCBCYXNlT2JqZWN0IGZyb20gJy4uL09iamVjdC5qcyc7XG5pbXBvcnQge2dldCBhcyBnZXRQcm9qZWN0aW9ufSBmcm9tICcuLi9wcm9qLmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7J3VuZGVmaW5lZCcgfCAnbG9hZGluZycgfCAncmVhZHknIHwgJ2Vycm9yJ30gU3RhdGVcbiAqIFN0YXRlIG9mIHRoZSBzb3VyY2UsIG9uZSBvZiAndW5kZWZpbmVkJywgJ2xvYWRpbmcnLCAncmVhZHknIG9yICdlcnJvcicuXG4gKi9cblxuLyoqXG4gKiBBIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYSB7QGxpbmsgaW1wb3J0KFwiLi4vVmlldy5qc1wiKS5WaWV3U3RhdGVMYXllclN0YXRlRXh0ZW50fSBhbmQgcmV0dXJucyBhIHN0cmluZyBvclxuICogYW4gYXJyYXkgb2Ygc3RyaW5ncyByZXByZXNlbnRpbmcgc291cmNlIGF0dHJpYnV0aW9ucy5cbiAqXG4gKiBAdHlwZWRlZiB7ZnVuY3Rpb24oaW1wb3J0KFwiLi4vVmlldy5qc1wiKS5WaWV3U3RhdGVMYXllclN0YXRlRXh0ZW50KTogKHN0cmluZ3xBcnJheTxzdHJpbmc+KX0gQXR0cmlidXRpb25cbiAqL1xuXG4vKipcbiAqIEEgdHlwZSB0aGF0IGNhbiBiZSB1c2VkIHRvIHByb3ZpZGUgYXR0cmlidXRpb24gaW5mb3JtYXRpb24gZm9yIGRhdGEgc291cmNlcy5cbiAqXG4gKiBJdCByZXByZXNlbnRzIGVpdGhlclxuICogKiBhIHNpbXBsZSBzdHJpbmcgKGUuZy4gYCfCqSBBY21lIEluYy4nYClcbiAqICogYW4gYXJyYXkgb2Ygc2ltcGxlIHN0cmluZ3MgKGUuZy4gYFsnwqkgQWNtZSBJbmMuJywgJ8KpIEJhY21lIEluYy4nXWApXG4gKiAqIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgc3RyaW5nIG9yIGFycmF5IG9mIHN0cmluZ3MgKHtAbGluayBtb2R1bGU6b2wvc291cmNlL1NvdXJjZX5BdHRyaWJ1dGlvbn0pXG4gKlxuICogQHR5cGVkZWYge3N0cmluZ3xBcnJheTxzdHJpbmc+fEF0dHJpYnV0aW9ufSBBdHRyaWJ1dGlvbkxpa2VcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7QXR0cmlidXRpb25MaWtlfSBbYXR0cmlidXRpb25zXSBBdHRyaWJ1dGlvbnMuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFthdHRyaWJ1dGlvbnNDb2xsYXBzaWJsZT10cnVlXSBBdHRyaWJ1dGlvbnMgYXJlIGNvbGxhcHNpYmxlLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9wcm9qLmpzXCIpLlByb2plY3Rpb25MaWtlfSBbcHJvamVjdGlvbl0gUHJvamVjdGlvbi4gRGVmYXVsdCBpcyB0aGUgdmlldyBwcm9qZWN0aW9uLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL1NvdXJjZS5qc1wiKS5TdGF0ZX0gW3N0YXRlPSdyZWFkeSddIFN0YXRlLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbd3JhcFg9ZmFsc2VdIFdyYXBYLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbaW50ZXJwb2xhdGU9ZmFsc2VdIFVzZSBpbnRlcnBvbGF0ZWQgdmFsdWVzIHdoZW4gcmVzYW1wbGluZy4gIEJ5IGRlZmF1bHQsXG4gKiB0aGUgbmVhcmVzdCBuZWlnaGJvciBpcyB1c2VkIHdoZW4gcmVzYW1wbGluZy5cbiAqL1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEFic3RyYWN0IGJhc2UgY2xhc3M7IG5vcm1hbGx5IG9ubHkgdXNlZCBmb3IgY3JlYXRpbmcgc3ViY2xhc3NlcyBhbmQgbm90XG4gKiBpbnN0YW50aWF0ZWQgaW4gYXBwcy5cbiAqIEJhc2UgY2xhc3MgZm9yIHtAbGluayBtb2R1bGU6b2wvbGF5ZXIvTGF5ZXJ+TGF5ZXJ9IHNvdXJjZXMuXG4gKlxuICogQSBnZW5lcmljIGBjaGFuZ2VgIGV2ZW50IGlzIHRyaWdnZXJlZCB3aGVuIHRoZSBzdGF0ZSBvZiB0aGUgc291cmNlIGNoYW5nZXMuXG4gKiBAYWJzdHJhY3RcbiAqIEBhcGlcbiAqL1xuY2xhc3MgU291cmNlIGV4dGVuZHMgQmFzZU9iamVjdCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge09wdGlvbnN9IG9wdGlvbnMgU291cmNlIG9wdGlvbnMuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vcHJvai9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR8bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLnByb2plY3Rpb24gPSBnZXRQcm9qZWN0aW9uKG9wdGlvbnMucHJvamVjdGlvbik7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHs/QXR0cmlidXRpb259XG4gICAgICovXG4gICAgdGhpcy5hdHRyaWJ1dGlvbnNfID0gYWRhcHRBdHRyaWJ1dGlvbnMob3B0aW9ucy5hdHRyaWJ1dGlvbnMpO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmF0dHJpYnV0aW9uc0NvbGxhcHNpYmxlXyA9XG4gICAgICBvcHRpb25zLmF0dHJpYnV0aW9uc0NvbGxhcHNpYmxlICE9PSB1bmRlZmluZWRcbiAgICAgICAgPyBvcHRpb25zLmF0dHJpYnV0aW9uc0NvbGxhcHNpYmxlXG4gICAgICAgIDogdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgc291cmNlIGlzIGN1cnJlbnRseSBsb2FkaW5nIGRhdGEuIFNvdXJjZXMgdGhhdCBkZWZlciBsb2FkaW5nIHRvIHRoZVxuICAgICAqIG1hcCdzIHRpbGUgcXVldWUgbmV2ZXIgc2V0IHRoaXMgdG8gYHRydWVgLlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMubG9hZGluZyA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi9Tb3VyY2UuanNcIikuU3RhdGV9XG4gICAgICovXG4gICAgdGhpcy5zdGF0ZV8gPSBvcHRpb25zLnN0YXRlICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnN0YXRlIDogJ3JlYWR5JztcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy53cmFwWF8gPSBvcHRpb25zLndyYXBYICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLndyYXBYIDogZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuaW50ZXJwb2xhdGVfID0gISFvcHRpb25zLmludGVycG9sYXRlO1xuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEB0eXBlIHtmdW5jdGlvbihpbXBvcnQoXCIuLi9WaWV3LmpzXCIpLlZpZXdPcHRpb25zKTp2b2lkfVxuICAgICAqL1xuICAgIHRoaXMudmlld1Jlc29sdmVyID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAdHlwZSB7ZnVuY3Rpb24oRXJyb3IpOnZvaWR9XG4gICAgICovXG4gICAgdGhpcy52aWV3UmVqZWN0b3IgPSBudWxsO1xuXG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7UHJvbWlzZTxpbXBvcnQoXCIuLi9WaWV3LmpzXCIpLlZpZXdPcHRpb25zPn1cbiAgICAgKi9cbiAgICB0aGlzLnZpZXdQcm9taXNlXyA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHNlbGYudmlld1Jlc29sdmVyID0gcmVzb2x2ZTtcbiAgICAgIHNlbGYudmlld1JlamVjdG9yID0gcmVqZWN0O1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgYXR0cmlidXRpb24gZnVuY3Rpb24gZm9yIHRoZSBzb3VyY2UuXG4gICAqIEByZXR1cm4gez9BdHRyaWJ1dGlvbn0gQXR0cmlidXRpb24gZnVuY3Rpb24uXG4gICAqIEBhcGlcbiAgICovXG4gIGdldEF0dHJpYnV0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5hdHRyaWJ1dGlvbnNfO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IEF0dHJpYnV0aW9ucyBhcmUgY29sbGFwc2libGUuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldEF0dHJpYnV0aW9uc0NvbGxhcHNpYmxlKCkge1xuICAgIHJldHVybiB0aGlzLmF0dHJpYnV0aW9uc0NvbGxhcHNpYmxlXztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHByb2plY3Rpb24gb2YgdGhlIHNvdXJjZS5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vcHJvai9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR8bnVsbH0gUHJvamVjdGlvbi5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0UHJvamVjdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9qZWN0aW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcHJvai9Qcm9qZWN0aW9uXCIpLmRlZmF1bHR9IFtwcm9qZWN0aW9uXSBQcm9qZWN0aW9uLlxuICAgKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fG51bGx9IFJlc29sdXRpb25zLlxuICAgKi9cbiAgZ2V0UmVzb2x1dGlvbnMocHJvamVjdGlvbikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge1Byb21pc2U8aW1wb3J0KFwiLi4vVmlldy5qc1wiKS5WaWV3T3B0aW9ucz59IEEgcHJvbWlzZSBmb3Igdmlldy1yZWxhdGVkIHByb3BlcnRpZXMuXG4gICAqL1xuICBnZXRWaWV3KCkge1xuICAgIHJldHVybiB0aGlzLnZpZXdQcm9taXNlXztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHN0YXRlIG9mIHRoZSBzb3VyY2UsIHNlZSB7QGxpbmsgaW1wb3J0KFwiLi9Tb3VyY2UuanNcIikuU3RhdGV9IGZvciBwb3NzaWJsZSBzdGF0ZXMuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4vU291cmNlLmpzXCIpLlN0YXRlfSBTdGF0ZS5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0U3RhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGVfO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW58dW5kZWZpbmVkfSBXcmFwIFguXG4gICAqL1xuICBnZXRXcmFwWCgpIHtcbiAgICByZXR1cm4gdGhpcy53cmFwWF87XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVXNlIGxpbmVhciBpbnRlcnBvbGF0aW9uIHdoZW4gcmVzYW1wbGluZy5cbiAgICovXG4gIGdldEludGVycG9sYXRlKCkge1xuICAgIHJldHVybiB0aGlzLmludGVycG9sYXRlXztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWZyZXNoZXMgdGhlIHNvdXJjZS4gVGhlIHNvdXJjZSB3aWxsIGJlIGNsZWFyZWQsIGFuZCBkYXRhIGZyb20gdGhlIHNlcnZlciB3aWxsIGJlIHJlbG9hZGVkLlxuICAgKiBAYXBpXG4gICAqL1xuICByZWZyZXNoKCkge1xuICAgIHRoaXMuY2hhbmdlZCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgYXR0cmlidXRpb25zIG9mIHRoZSBzb3VyY2UuXG4gICAqIEBwYXJhbSB7QXR0cmlidXRpb25MaWtlfHVuZGVmaW5lZH0gYXR0cmlidXRpb25zIEF0dHJpYnV0aW9ucy5cbiAgICogICAgIENhbiBiZSBwYXNzZWQgYXMgYHN0cmluZ2AsIGBBcnJheTxzdHJpbmc+YCwge0BsaW5rIG1vZHVsZTpvbC9zb3VyY2UvU291cmNlfkF0dHJpYnV0aW9ufSxcbiAgICogICAgIG9yIGB1bmRlZmluZWRgLlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRBdHRyaWJ1dGlvbnMoYXR0cmlidXRpb25zKSB7XG4gICAgdGhpcy5hdHRyaWJ1dGlvbnNfID0gYWRhcHRBdHRyaWJ1dGlvbnMoYXR0cmlidXRpb25zKTtcbiAgICB0aGlzLmNoYW5nZWQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHN0YXRlIG9mIHRoZSBzb3VyY2UuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9Tb3VyY2UuanNcIikuU3RhdGV9IHN0YXRlIFN0YXRlLlxuICAgKi9cbiAgc2V0U3RhdGUoc3RhdGUpIHtcbiAgICB0aGlzLnN0YXRlXyA9IHN0YXRlO1xuICAgIHRoaXMuY2hhbmdlZCgpO1xuICB9XG59XG5cbi8qKlxuICogVHVybnMgdGhlIGF0dHJpYnV0aW9ucyBvcHRpb24gaW50byBhbiBhdHRyaWJ1dGlvbnMgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge0F0dHJpYnV0aW9uTGlrZXx1bmRlZmluZWR9IGF0dHJpYnV0aW9uTGlrZSBUaGUgYXR0cmlidXRpb24gb3B0aW9uLlxuICogQHJldHVybiB7QXR0cmlidXRpb258bnVsbH0gQW4gYXR0cmlidXRpb24gZnVuY3Rpb24gKG9yIG51bGwpLlxuICovXG5mdW5jdGlvbiBhZGFwdEF0dHJpYnV0aW9ucyhhdHRyaWJ1dGlvbkxpa2UpIHtcbiAgaWYgKCFhdHRyaWJ1dGlvbkxpa2UpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShhdHRyaWJ1dGlvbkxpa2UpKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChmcmFtZVN0YXRlKSB7XG4gICAgICByZXR1cm4gYXR0cmlidXRpb25MaWtlO1xuICAgIH07XG4gIH1cblxuICBpZiAodHlwZW9mIGF0dHJpYnV0aW9uTGlrZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBhdHRyaWJ1dGlvbkxpa2U7XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKGZyYW1lU3RhdGUpIHtcbiAgICByZXR1cm4gW2F0dHJpYnV0aW9uTGlrZV07XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IFNvdXJjZTtcbiIsIi8qKlxuICogQG1vZHVsZSBvbC9zb3VyY2UvVGlsZVxuICovXG5pbXBvcnQgRXZlbnQgZnJvbSAnLi4vZXZlbnRzL0V2ZW50LmpzJztcbmltcG9ydCBTb3VyY2UgZnJvbSAnLi9Tb3VyY2UuanMnO1xuaW1wb3J0IFRpbGVDYWNoZSBmcm9tICcuLi9UaWxlQ2FjaGUuanMnO1xuaW1wb3J0IFRpbGVTdGF0ZSBmcm9tICcuLi9UaWxlU3RhdGUuanMnO1xuaW1wb3J0IHthYnN0cmFjdH0gZnJvbSAnLi4vdXRpbC5qcyc7XG5pbXBvcnQge2Fzc2VydH0gZnJvbSAnLi4vYXNzZXJ0cy5qcyc7XG5pbXBvcnQge2VxdWl2YWxlbnR9IGZyb20gJy4uL3Byb2ouanMnO1xuaW1wb3J0IHtnZXRLZXlaWFksIHdpdGhpbkV4dGVudEFuZFp9IGZyb20gJy4uL3RpbGVjb29yZC5qcyc7XG5pbXBvcnQge1xuICBnZXRGb3JQcm9qZWN0aW9uIGFzIGdldFRpbGVHcmlkRm9yUHJvamVjdGlvbixcbiAgd3JhcFgsXG59IGZyb20gJy4uL3RpbGVncmlkLmpzJztcbmltcG9ydCB7c2NhbGUgYXMgc2NhbGVTaXplLCB0b1NpemV9IGZyb20gJy4uL3NpemUuanMnO1xuXG4vKioqXG4gKiBAdGVtcGxhdGUgUmV0dXJuXG4gKiBAdHlwZWRlZiB7aW1wb3J0KFwiLi4vT2JzZXJ2YWJsZVwiKS5PblNpZ25hdHVyZTxpbXBvcnQoXCIuLi9PYnNlcnZhYmxlXCIpLkV2ZW50VHlwZXMsIGltcG9ydChcIi4uL2V2ZW50cy9FdmVudC5qc1wiKS5kZWZhdWx0LCBSZXR1cm4+ICZcbiAqICAgaW1wb3J0KFwiLi4vT2JzZXJ2YWJsZVwiKS5PblNpZ25hdHVyZTxpbXBvcnQoXCIuLi9PYmplY3RFdmVudFR5cGVcIikuVHlwZXMsIGltcG9ydChcIi4uL09iamVjdFwiKS5PYmplY3RFdmVudCwgUmV0dXJuPiAmXG4gKiAgIGltcG9ydChcIi4uL09ic2VydmFibGVcIikuT25TaWduYXR1cmU8aW1wb3J0KFwiLi9UaWxlRXZlbnRUeXBlXCIpLlRpbGVTb3VyY2VFdmVudFR5cGVzLCBUaWxlU291cmNlRXZlbnQsIFJldHVybj4gJlxuICogICBpbXBvcnQoXCIuLi9PYnNlcnZhYmxlXCIpLkNvbWJpbmVkT25TaWduYXR1cmU8aW1wb3J0KFwiLi4vT2JzZXJ2YWJsZVwiKS5FdmVudFR5cGVzfGltcG9ydChcIi4uL09iamVjdEV2ZW50VHlwZVwiKS5UeXBlc3xcbiAqICAgICBpbXBvcnQoXCIuL1RpbGVFdmVudFR5cGVcIikuVGlsZVNvdXJjZUV2ZW50VHlwZXMsIFJldHVybj59IFRpbGVTb3VyY2VPblNpZ25hdHVyZVxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL1NvdXJjZS5qc1wiKS5BdHRyaWJ1dGlvbkxpa2V9IFthdHRyaWJ1dGlvbnNdIEF0dHJpYnV0aW9ucy5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2F0dHJpYnV0aW9uc0NvbGxhcHNpYmxlPXRydWVdIEF0dHJpYnV0aW9ucyBhcmUgY29sbGFwc2libGUuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2NhY2hlU2l6ZV0gQ2FjaGVTaXplLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbb3BhcXVlPWZhbHNlXSBXaGV0aGVyIHRoZSBsYXllciBpcyBvcGFxdWUuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3RpbGVQaXhlbFJhdGlvXSBUaWxlUGl4ZWxSYXRpby5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vcHJvai5qc1wiKS5Qcm9qZWN0aW9uTGlrZX0gW3Byb2plY3Rpb25dIFByb2plY3Rpb24uXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4vU291cmNlLmpzXCIpLlN0YXRlfSBbc3RhdGVdIFN0YXRlLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi90aWxlZ3JpZC9UaWxlR3JpZC5qc1wiKS5kZWZhdWx0fSBbdGlsZUdyaWRdIFRpbGVHcmlkLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbd3JhcFg9ZmFsc2VdIFdyYXBYLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFt0cmFuc2l0aW9uXSBUcmFuc2l0aW9uLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtrZXldIEtleS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfGltcG9ydChcIi4uL2FycmF5LmpzXCIpLk5lYXJlc3REaXJlY3Rpb25GdW5jdGlvbn0gW3pEaXJlY3Rpb249MF0gWkRpcmVjdGlvbi5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2ludGVycG9sYXRlPWZhbHNlXSBVc2UgaW50ZXJwb2xhdGVkIHZhbHVlcyB3aGVuIHJlc2FtcGxpbmcuICBCeSBkZWZhdWx0LFxuICogdGhlIG5lYXJlc3QgbmVpZ2hib3IgaXMgdXNlZCB3aGVuIHJlc2FtcGxpbmcuXG4gKi9cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBBYnN0cmFjdCBiYXNlIGNsYXNzOyBub3JtYWxseSBvbmx5IHVzZWQgZm9yIGNyZWF0aW5nIHN1YmNsYXNzZXMgYW5kIG5vdFxuICogaW5zdGFudGlhdGVkIGluIGFwcHMuXG4gKiBCYXNlIGNsYXNzIGZvciBzb3VyY2VzIHByb3ZpZGluZyBpbWFnZXMgZGl2aWRlZCBpbnRvIGEgdGlsZSBncmlkLlxuICogQGFic3RyYWN0XG4gKiBAYXBpXG4gKi9cbmNsYXNzIFRpbGVTb3VyY2UgZXh0ZW5kcyBTb3VyY2Uge1xuICAvKipcbiAgICogQHBhcmFtIHtPcHRpb25zfSBvcHRpb25zIFNvdXJjZVRpbGUgc291cmNlIG9wdGlvbnMuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgc3VwZXIoe1xuICAgICAgYXR0cmlidXRpb25zOiBvcHRpb25zLmF0dHJpYnV0aW9ucyxcbiAgICAgIGF0dHJpYnV0aW9uc0NvbGxhcHNpYmxlOiBvcHRpb25zLmF0dHJpYnV0aW9uc0NvbGxhcHNpYmxlLFxuICAgICAgcHJvamVjdGlvbjogb3B0aW9ucy5wcm9qZWN0aW9uLFxuICAgICAgc3RhdGU6IG9wdGlvbnMuc3RhdGUsXG4gICAgICB3cmFwWDogb3B0aW9ucy53cmFwWCxcbiAgICAgIGludGVycG9sYXRlOiBvcHRpb25zLmludGVycG9sYXRlLFxuICAgIH0pO1xuXG4gICAgLyoqKlxuICAgICAqIEB0eXBlIHtUaWxlU291cmNlT25TaWduYXR1cmU8aW1wb3J0KFwiLi4vZXZlbnRzXCIpLkV2ZW50c0tleT59XG4gICAgICovXG4gICAgdGhpcy5vbjtcblxuICAgIC8qKipcbiAgICAgKiBAdHlwZSB7VGlsZVNvdXJjZU9uU2lnbmF0dXJlPGltcG9ydChcIi4uL2V2ZW50c1wiKS5FdmVudHNLZXk+fVxuICAgICAqL1xuICAgIHRoaXMub25jZTtcblxuICAgIC8qKipcbiAgICAgKiBAdHlwZSB7VGlsZVNvdXJjZU9uU2lnbmF0dXJlPHZvaWQ+fVxuICAgICAqL1xuICAgIHRoaXMudW47XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMub3BhcXVlXyA9IG9wdGlvbnMub3BhcXVlICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm9wYXF1ZSA6IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMudGlsZVBpeGVsUmF0aW9fID1cbiAgICAgIG9wdGlvbnMudGlsZVBpeGVsUmF0aW8gIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMudGlsZVBpeGVsUmF0aW8gOiAxO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL3RpbGVncmlkL1RpbGVHcmlkLmpzXCIpLmRlZmF1bHR8bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLnRpbGVHcmlkID0gb3B0aW9ucy50aWxlR3JpZCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy50aWxlR3JpZCA6IG51bGw7XG5cbiAgICBjb25zdCB0aWxlU2l6ZSA9IFsyNTYsIDI1Nl07XG4gICAgaWYgKHRoaXMudGlsZUdyaWQpIHtcbiAgICAgIHRvU2l6ZSh0aGlzLnRpbGVHcmlkLmdldFRpbGVTaXplKHRoaXMudGlsZUdyaWQuZ2V0TWluWm9vbSgpKSwgdGlsZVNpemUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vVGlsZUNhY2hlLmpzXCIpLmRlZmF1bHR9XG4gICAgICovXG4gICAgdGhpcy50aWxlQ2FjaGUgPSBuZXcgVGlsZUNhY2hlKG9wdGlvbnMuY2FjaGVTaXplIHx8IDApO1xuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9zaXplLmpzXCIpLlNpemV9XG4gICAgICovXG4gICAgdGhpcy50bXBTaXplID0gWzAsIDBdO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMua2V5XyA9IG9wdGlvbnMua2V5IHx8ICcnO1xuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9UaWxlLmpzXCIpLk9wdGlvbnN9XG4gICAgICovXG4gICAgdGhpcy50aWxlT3B0aW9ucyA9IHtcbiAgICAgIHRyYW5zaXRpb246IG9wdGlvbnMudHJhbnNpdGlvbixcbiAgICAgIGludGVycG9sYXRlOiBvcHRpb25zLmludGVycG9sYXRlLFxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiB6RGlyZWN0aW9uIGhpbnQsIHJlYWQgYnkgdGhlIHJlbmRlcmVyLiBJbmRpY2F0ZXMgd2hpY2ggcmVzb2x1dGlvbiBzaG91bGQgYmUgdXNlZFxuICAgICAqIGJ5IGEgcmVuZGVyZXIgaWYgdGhlIHZpZXdzIHJlc29sdXRpb24gZG9lcyBub3QgbWF0Y2ggYW55IHJlc29sdXRpb24gb2YgdGhlIHRpbGUgc291cmNlLlxuICAgICAqIElmIDAsIHRoZSBuZWFyZXN0IHJlc29sdXRpb24gd2lsbCBiZSB1c2VkLiBJZiAxLCB0aGUgbmVhcmVzdCBsb3dlciByZXNvbHV0aW9uXG4gICAgICogd2lsbCBiZSB1c2VkLiBJZiAtMSwgdGhlIG5lYXJlc3QgaGlnaGVyIHJlc29sdXRpb24gd2lsbCBiZSB1c2VkLlxuICAgICAqIEB0eXBlIHtudW1iZXJ8aW1wb3J0KFwiLi4vYXJyYXkuanNcIikuTmVhcmVzdERpcmVjdGlvbkZ1bmN0aW9ufVxuICAgICAqL1xuICAgIHRoaXMuekRpcmVjdGlvbiA9IG9wdGlvbnMuekRpcmVjdGlvbiA/IG9wdGlvbnMuekRpcmVjdGlvbiA6IDA7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gQ2FuIGV4cGlyZSBjYWNoZS5cbiAgICovXG4gIGNhbkV4cGlyZUNhY2hlKCkge1xuICAgIHJldHVybiB0aGlzLnRpbGVDYWNoZS5jYW5FeHBpcmVDYWNoZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcHJvai9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR9IHByb2plY3Rpb24gUHJvamVjdGlvbi5cbiAgICogQHBhcmFtIHshT2JqZWN0PHN0cmluZywgYm9vbGVhbj59IHVzZWRUaWxlcyBVc2VkIHRpbGVzLlxuICAgKi9cbiAgZXhwaXJlQ2FjaGUocHJvamVjdGlvbiwgdXNlZFRpbGVzKSB7XG4gICAgY29uc3QgdGlsZUNhY2hlID0gdGhpcy5nZXRUaWxlQ2FjaGVGb3JQcm9qZWN0aW9uKHByb2plY3Rpb24pO1xuICAgIGlmICh0aWxlQ2FjaGUpIHtcbiAgICAgIHRpbGVDYWNoZS5leHBpcmVDYWNoZSh1c2VkVGlsZXMpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3Byb2ovUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0fSBwcm9qZWN0aW9uIFByb2plY3Rpb24uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB6IFpvb20gbGV2ZWwuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vVGlsZVJhbmdlLmpzXCIpLmRlZmF1bHR9IHRpbGVSYW5nZSBUaWxlIHJhbmdlLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKGltcG9ydChcIi4uL1RpbGUuanNcIikuZGVmYXVsdCk6KGJvb2xlYW58dm9pZCl9IGNhbGxiYWNrIENhbGxlZCB3aXRoIGVhY2hcbiAgICogICAgIGxvYWRlZCB0aWxlLiAgSWYgdGhlIGNhbGxiYWNrIHJldHVybnMgYGZhbHNlYCwgdGhlIHRpbGUgd2lsbCBub3QgYmVcbiAgICogICAgIGNvbnNpZGVyZWQgbG9hZGVkLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUaGUgdGlsZSByYW5nZSBpcyBmdWxseSBjb3ZlcmVkIHdpdGggbG9hZGVkIHRpbGVzLlxuICAgKi9cbiAgZm9yRWFjaExvYWRlZFRpbGUocHJvamVjdGlvbiwgeiwgdGlsZVJhbmdlLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IHRpbGVDYWNoZSA9IHRoaXMuZ2V0VGlsZUNhY2hlRm9yUHJvamVjdGlvbihwcm9qZWN0aW9uKTtcbiAgICBpZiAoIXRpbGVDYWNoZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGxldCBjb3ZlcmVkID0gdHJ1ZTtcbiAgICBsZXQgdGlsZSwgdGlsZUNvb3JkS2V5LCBsb2FkZWQ7XG4gICAgZm9yIChsZXQgeCA9IHRpbGVSYW5nZS5taW5YOyB4IDw9IHRpbGVSYW5nZS5tYXhYOyArK3gpIHtcbiAgICAgIGZvciAobGV0IHkgPSB0aWxlUmFuZ2UubWluWTsgeSA8PSB0aWxlUmFuZ2UubWF4WTsgKyt5KSB7XG4gICAgICAgIHRpbGVDb29yZEtleSA9IGdldEtleVpYWSh6LCB4LCB5KTtcbiAgICAgICAgbG9hZGVkID0gZmFsc2U7XG4gICAgICAgIGlmICh0aWxlQ2FjaGUuY29udGFpbnNLZXkodGlsZUNvb3JkS2V5KSkge1xuICAgICAgICAgIHRpbGUgPSAvKiogQHR5cGUgeyFpbXBvcnQoXCIuLi9UaWxlLmpzXCIpLmRlZmF1bHR9ICovIChcbiAgICAgICAgICAgIHRpbGVDYWNoZS5nZXQodGlsZUNvb3JkS2V5KVxuICAgICAgICAgICk7XG4gICAgICAgICAgbG9hZGVkID0gdGlsZS5nZXRTdGF0ZSgpID09PSBUaWxlU3RhdGUuTE9BREVEO1xuICAgICAgICAgIGlmIChsb2FkZWQpIHtcbiAgICAgICAgICAgIGxvYWRlZCA9IGNhbGxiYWNrKHRpbGUpICE9PSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFsb2FkZWQpIHtcbiAgICAgICAgICBjb3ZlcmVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNvdmVyZWQ7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9wcm9qL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdH0gcHJvamVjdGlvbiBQcm9qZWN0aW9uLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IEd1dHRlci5cbiAgICovXG4gIGdldEd1dHRlckZvclByb2plY3Rpb24ocHJvamVjdGlvbikge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUga2V5IHRvIGJlIHVzZWQgZm9yIGFsbCB0aWxlcyBpbiB0aGUgc291cmNlLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBrZXkgZm9yIGFsbCB0aWxlcy5cbiAgICovXG4gIGdldEtleSgpIHtcbiAgICByZXR1cm4gdGhpcy5rZXlfO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgdmFsdWUgdG8gYmUgdXNlZCBhcyB0aGUga2V5IGZvciBhbGwgdGlsZXMgaW4gdGhlIHNvdXJjZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IGZvciB0aWxlcy5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgc2V0S2V5KGtleSkge1xuICAgIGlmICh0aGlzLmtleV8gIT09IGtleSkge1xuICAgICAgdGhpcy5rZXlfID0ga2V5O1xuICAgICAgdGhpcy5jaGFuZ2VkKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcHJvai9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR9IHByb2plY3Rpb24gUHJvamVjdGlvbi5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gT3BhcXVlLlxuICAgKi9cbiAgZ2V0T3BhcXVlKHByb2plY3Rpb24pIHtcbiAgICByZXR1cm4gdGhpcy5vcGFxdWVfO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcHJvai9Qcm9qZWN0aW9uXCIpLmRlZmF1bHR9IFtwcm9qZWN0aW9uXSBQcm9qZWN0aW9uLlxuICAgKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fG51bGx9IFJlc29sdXRpb25zLlxuICAgKi9cbiAgZ2V0UmVzb2x1dGlvbnMocHJvamVjdGlvbikge1xuICAgIGNvbnN0IHRpbGVHcmlkID0gcHJvamVjdGlvblxuICAgICAgPyB0aGlzLmdldFRpbGVHcmlkRm9yUHJvamVjdGlvbihwcm9qZWN0aW9uKVxuICAgICAgOiB0aGlzLnRpbGVHcmlkO1xuICAgIGlmICghdGlsZUdyaWQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gdGlsZUdyaWQuZ2V0UmVzb2x1dGlvbnMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHBhcmFtIHtudW1iZXJ9IHogVGlsZSBjb29yZGluYXRlIHouXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4IFRpbGUgY29vcmRpbmF0ZSB4LlxuICAgKiBAcGFyYW0ge251bWJlcn0geSBUaWxlIGNvb3JkaW5hdGUgeS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHBpeGVsUmF0aW8gUGl4ZWwgcmF0aW8uXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcHJvai9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR9IHByb2plY3Rpb24gUHJvamVjdGlvbi5cbiAgICogQHJldHVybiB7IWltcG9ydChcIi4uL1RpbGUuanNcIikuZGVmYXVsdH0gVGlsZS5cbiAgICovXG4gIGdldFRpbGUoeiwgeCwgeSwgcGl4ZWxSYXRpbywgcHJvamVjdGlvbikge1xuICAgIHJldHVybiBhYnN0cmFjdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgdGlsZSBncmlkIG9mIHRoZSB0aWxlIHNvdXJjZS5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vdGlsZWdyaWQvVGlsZUdyaWQuanNcIikuZGVmYXVsdHxudWxsfSBUaWxlIGdyaWQuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldFRpbGVHcmlkKCkge1xuICAgIHJldHVybiB0aGlzLnRpbGVHcmlkO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcHJvai9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR9IHByb2plY3Rpb24gUHJvamVjdGlvbi5cbiAgICogQHJldHVybiB7IWltcG9ydChcIi4uL3RpbGVncmlkL1RpbGVHcmlkLmpzXCIpLmRlZmF1bHR9IFRpbGUgZ3JpZC5cbiAgICovXG4gIGdldFRpbGVHcmlkRm9yUHJvamVjdGlvbihwcm9qZWN0aW9uKSB7XG4gICAgaWYgKCF0aGlzLnRpbGVHcmlkKSB7XG4gICAgICByZXR1cm4gZ2V0VGlsZUdyaWRGb3JQcm9qZWN0aW9uKHByb2plY3Rpb24pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy50aWxlR3JpZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3Byb2ovUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0fSBwcm9qZWN0aW9uIFByb2plY3Rpb24uXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL1RpbGVDYWNoZS5qc1wiKS5kZWZhdWx0fSBUaWxlIGNhY2hlLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBnZXRUaWxlQ2FjaGVGb3JQcm9qZWN0aW9uKHByb2plY3Rpb24pIHtcbiAgICBjb25zdCBzb3VyY2VQcm9qZWN0aW9uID0gdGhpcy5nZXRQcm9qZWN0aW9uKCk7XG4gICAgYXNzZXJ0KFxuICAgICAgc291cmNlUHJvamVjdGlvbiA9PT0gbnVsbCB8fCBlcXVpdmFsZW50KHNvdXJjZVByb2plY3Rpb24sIHByb2plY3Rpb24pLFxuICAgICAgJ0EgVmVjdG9yVGlsZSBzb3VyY2UgY2FuIG9ubHkgYmUgcmVuZGVyZWQgaWYgaXQgaGFzIGEgcHJvamVjdGlvbiBjb21wYXRpYmxlIHdpdGggdGhlIHZpZXcgcHJvamVjdGlvbi4nXG4gICAgKTtcbiAgICByZXR1cm4gdGhpcy50aWxlQ2FjaGU7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB0aWxlIHBpeGVsIHJhdGlvIGZvciB0aGlzIHNvdXJjZS4gU3ViY2xhc3NlcyBtYXkgb3ZlcnJpZGUgdGhpc1xuICAgKiBtZXRob2QsIHdoaWNoIGlzIG1lYW50IHRvIHJldHVybiBhIHN1cHBvcnRlZCBwaXhlbCByYXRpbyB0aGF0IG1hdGNoZXMgdGhlXG4gICAqIHByb3ZpZGVkIGBwaXhlbFJhdGlvYCBhcyBjbG9zZSBhcyBwb3NzaWJsZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHBpeGVsUmF0aW8gUGl4ZWwgcmF0aW8uXG4gICAqIEByZXR1cm4ge251bWJlcn0gVGlsZSBwaXhlbCByYXRpby5cbiAgICovXG4gIGdldFRpbGVQaXhlbFJhdGlvKHBpeGVsUmF0aW8pIHtcbiAgICByZXR1cm4gdGhpcy50aWxlUGl4ZWxSYXRpb187XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHogWi5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHBpeGVsUmF0aW8gUGl4ZWwgcmF0aW8uXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcHJvai9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR9IHByb2plY3Rpb24gUHJvamVjdGlvbi5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vc2l6ZS5qc1wiKS5TaXplfSBUaWxlIHNpemUuXG4gICAqL1xuICBnZXRUaWxlUGl4ZWxTaXplKHosIHBpeGVsUmF0aW8sIHByb2plY3Rpb24pIHtcbiAgICBjb25zdCB0aWxlR3JpZCA9IHRoaXMuZ2V0VGlsZUdyaWRGb3JQcm9qZWN0aW9uKHByb2plY3Rpb24pO1xuICAgIGNvbnN0IHRpbGVQaXhlbFJhdGlvID0gdGhpcy5nZXRUaWxlUGl4ZWxSYXRpbyhwaXhlbFJhdGlvKTtcbiAgICBjb25zdCB0aWxlU2l6ZSA9IHRvU2l6ZSh0aWxlR3JpZC5nZXRUaWxlU2l6ZSh6KSwgdGhpcy50bXBTaXplKTtcbiAgICBpZiAodGlsZVBpeGVsUmF0aW8gPT0gMSkge1xuICAgICAgcmV0dXJuIHRpbGVTaXplO1xuICAgIH1cbiAgICByZXR1cm4gc2NhbGVTaXplKHRpbGVTaXplLCB0aWxlUGl4ZWxSYXRpbywgdGhpcy50bXBTaXplKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgdGlsZSBjb29yZGluYXRlIHdyYXBwZWQgYXJvdW5kIHRoZSB4LWF4aXMuIFdoZW4gdGhlIHRpbGUgY29vcmRpbmF0ZVxuICAgKiBpcyBvdXRzaWRlIHRoZSByZXNvbHV0aW9uIGFuZCBleHRlbnQgcmFuZ2Ugb2YgdGhlIHRpbGUgZ3JpZCwgYG51bGxgIHdpbGwgYmVcbiAgICogcmV0dXJuZWQuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vdGlsZWNvb3JkLmpzXCIpLlRpbGVDb29yZH0gdGlsZUNvb3JkIFRpbGUgY29vcmRpbmF0ZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9wcm9qL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdH0gW3Byb2plY3Rpb25dIFByb2plY3Rpb24uXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL3RpbGVjb29yZC5qc1wiKS5UaWxlQ29vcmR9IFRpbGUgY29vcmRpbmF0ZSB0byBiZSBwYXNzZWQgdG8gdGhlIHRpbGVVcmxGdW5jdGlvbiBvclxuICAgKiAgICAgbnVsbCBpZiBubyB0aWxlIFVSTCBzaG91bGQgYmUgY3JlYXRlZCBmb3IgdGhlIHBhc3NlZCBgdGlsZUNvb3JkYC5cbiAgICovXG4gIGdldFRpbGVDb29yZEZvclRpbGVVcmxGdW5jdGlvbih0aWxlQ29vcmQsIHByb2plY3Rpb24pIHtcbiAgICBwcm9qZWN0aW9uID0gcHJvamVjdGlvbiAhPT0gdW5kZWZpbmVkID8gcHJvamVjdGlvbiA6IHRoaXMuZ2V0UHJvamVjdGlvbigpO1xuICAgIGNvbnN0IHRpbGVHcmlkID0gdGhpcy5nZXRUaWxlR3JpZEZvclByb2plY3Rpb24ocHJvamVjdGlvbik7XG4gICAgaWYgKHRoaXMuZ2V0V3JhcFgoKSAmJiBwcm9qZWN0aW9uLmlzR2xvYmFsKCkpIHtcbiAgICAgIHRpbGVDb29yZCA9IHdyYXBYKHRpbGVHcmlkLCB0aWxlQ29vcmQsIHByb2plY3Rpb24pO1xuICAgIH1cbiAgICByZXR1cm4gd2l0aGluRXh0ZW50QW5kWih0aWxlQ29vcmQsIHRpbGVHcmlkKSA/IHRpbGVDb29yZCA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGFsbCBjYWNoZWQgdGlsZXMgZnJvbSB0aGUgc291cmNlLiBUaGUgbmV4dCByZW5kZXIgY3ljbGUgd2lsbCBmZXRjaCBuZXcgdGlsZXMuXG4gICAqIEBhcGlcbiAgICovXG4gIGNsZWFyKCkge1xuICAgIHRoaXMudGlsZUNhY2hlLmNsZWFyKCk7XG4gIH1cblxuICByZWZyZXNoKCkge1xuICAgIHRoaXMuY2xlYXIoKTtcbiAgICBzdXBlci5yZWZyZXNoKCk7XG4gIH1cblxuICAvKipcbiAgICogSW5jcmVhc2VzIHRoZSBjYWNoZSBzaXplIGlmIG5lZWRlZFxuICAgKiBAcGFyYW0ge251bWJlcn0gdGlsZUNvdW50IE1pbmltdW0gbnVtYmVyIG9mIHRpbGVzIG5lZWRlZC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9wcm9qL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdH0gcHJvamVjdGlvbiBQcm9qZWN0aW9uLlxuICAgKi9cbiAgdXBkYXRlQ2FjaGVTaXplKHRpbGVDb3VudCwgcHJvamVjdGlvbikge1xuICAgIGNvbnN0IHRpbGVDYWNoZSA9IHRoaXMuZ2V0VGlsZUNhY2hlRm9yUHJvamVjdGlvbihwcm9qZWN0aW9uKTtcbiAgICBpZiAodGlsZUNvdW50ID4gdGlsZUNhY2hlLmhpZ2hXYXRlck1hcmspIHtcbiAgICAgIHRpbGVDYWNoZS5oaWdoV2F0ZXJNYXJrID0gdGlsZUNvdW50O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBNYXJrcyBhIHRpbGUgY29vcmQgYXMgYmVpbmcgdXNlZCwgd2l0aG91dCB0cmlnZ2VyaW5nIGEgbG9hZC5cbiAgICogQGFic3RyYWN0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSB6IFRpbGUgY29vcmRpbmF0ZSB6LlxuICAgKiBAcGFyYW0ge251bWJlcn0geCBUaWxlIGNvb3JkaW5hdGUgeC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHkgVGlsZSBjb29yZGluYXRlIHkuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcHJvai9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR9IHByb2plY3Rpb24gUHJvamVjdGlvbi5cbiAgICovXG4gIHVzZVRpbGUoeiwgeCwgeSwgcHJvamVjdGlvbikge31cbn1cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBFdmVudHMgZW1pdHRlZCBieSB7QGxpbmsgbW9kdWxlOm9sL3NvdXJjZS9UaWxlflRpbGVTb3VyY2V9IGluc3RhbmNlcyBhcmUgaW5zdGFuY2VzIG9mIHRoaXNcbiAqIHR5cGUuXG4gKi9cbmV4cG9ydCBjbGFzcyBUaWxlU291cmNlRXZlbnQgZXh0ZW5kcyBFdmVudCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBUeXBlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL1RpbGUuanNcIikuZGVmYXVsdH0gdGlsZSBUaGUgdGlsZS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHR5cGUsIHRpbGUpIHtcbiAgICBzdXBlcih0eXBlKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSB0aWxlIHJlbGF0ZWQgdG8gdGhlIGV2ZW50LlxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9UaWxlLmpzXCIpLmRlZmF1bHR9XG4gICAgICogQGFwaVxuICAgICAqL1xuICAgIHRoaXMudGlsZSA9IHRpbGU7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgVGlsZVNvdXJjZTtcbiIsIi8qKlxuICogQG1vZHVsZSBvbC9zb3VyY2UvVGlsZUV2ZW50VHlwZVxuICovXG5cbi8qKlxuICogQGVudW0ge3N0cmluZ31cbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICAvKipcbiAgICogVHJpZ2dlcmVkIHdoZW4gYSB0aWxlIHN0YXJ0cyBsb2FkaW5nLlxuICAgKiBAZXZlbnQgbW9kdWxlOm9sL3NvdXJjZS9UaWxlLlRpbGVTb3VyY2VFdmVudCN0aWxlbG9hZHN0YXJ0XG4gICAqIEBhcGlcbiAgICovXG4gIFRJTEVMT0FEU1RBUlQ6ICd0aWxlbG9hZHN0YXJ0JyxcblxuICAvKipcbiAgICogVHJpZ2dlcmVkIHdoZW4gYSB0aWxlIGZpbmlzaGVzIGxvYWRpbmcsIGVpdGhlciB3aGVuIGl0cyBkYXRhIGlzIGxvYWRlZCxcbiAgICogb3Igd2hlbiBsb2FkaW5nIHdhcyBhYm9ydGVkIGJlY2F1c2UgdGhlIHRpbGUgaXMgbm8gbG9uZ2VyIG5lZWRlZC5cbiAgICogQGV2ZW50IG1vZHVsZTpvbC9zb3VyY2UvVGlsZS5UaWxlU291cmNlRXZlbnQjdGlsZWxvYWRlbmRcbiAgICogQGFwaVxuICAgKi9cbiAgVElMRUxPQURFTkQ6ICd0aWxlbG9hZGVuZCcsXG5cbiAgLyoqXG4gICAqIFRyaWdnZXJlZCBpZiB0aWxlIGxvYWRpbmcgcmVzdWx0cyBpbiBhbiBlcnJvci4gTm90ZSB0aGF0IHRoaXMgaXMgbm90IHRoZVxuICAgKiByaWdodCBwbGFjZSB0byByZS1mZXRjaCB0aWxlcy4gU2VlIHtAbGluayBtb2R1bGU6b2wvSW1hZ2VUaWxlfkltYWdlVGlsZSNsb2FkfVxuICAgKiBmb3IgZGV0YWlscy5cbiAgICogQGV2ZW50IG1vZHVsZTpvbC9zb3VyY2UvVGlsZS5UaWxlU291cmNlRXZlbnQjdGlsZWxvYWRlcnJvclxuICAgKiBAYXBpXG4gICAqL1xuICBUSUxFTE9BREVSUk9SOiAndGlsZWxvYWRlcnJvcicsXG59O1xuXG4vKipcbiAqIEB0eXBlZGVmIHsndGlsZWxvYWRzdGFydCd8J3RpbGVsb2FkZW5kJ3wndGlsZWxvYWRlcnJvcid9IFRpbGVTb3VyY2VFdmVudFR5cGVzXG4gKi9cbiIsIi8qKlxuICogQG1vZHVsZSBvbC9zb3VyY2UvVGlsZUltYWdlXG4gKi9cbmltcG9ydCBFdmVudFR5cGUgZnJvbSAnLi4vZXZlbnRzL0V2ZW50VHlwZS5qcyc7XG5pbXBvcnQgSW1hZ2VUaWxlIGZyb20gJy4uL0ltYWdlVGlsZS5qcyc7XG5pbXBvcnQgUmVwcm9qVGlsZSBmcm9tICcuLi9yZXByb2ovVGlsZS5qcyc7XG5pbXBvcnQgVGlsZUNhY2hlIGZyb20gJy4uL1RpbGVDYWNoZS5qcyc7XG5pbXBvcnQgVGlsZVN0YXRlIGZyb20gJy4uL1RpbGVTdGF0ZS5qcyc7XG5pbXBvcnQgVXJsVGlsZSBmcm9tICcuL1VybFRpbGUuanMnO1xuaW1wb3J0IHtlcXVpdmFsZW50LCBnZXQgYXMgZ2V0UHJvamVjdGlvbn0gZnJvbSAnLi4vcHJvai5qcyc7XG5pbXBvcnQge2dldEtleSwgZ2V0S2V5WlhZfSBmcm9tICcuLi90aWxlY29vcmQuanMnO1xuaW1wb3J0IHtnZXRGb3JQcm9qZWN0aW9uIGFzIGdldFRpbGVHcmlkRm9yUHJvamVjdGlvbn0gZnJvbSAnLi4vdGlsZWdyaWQuanMnO1xuaW1wb3J0IHtnZXRVaWR9IGZyb20gJy4uL3V0aWwuanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi9Tb3VyY2UuanNcIikuQXR0cmlidXRpb25MaWtlfSBbYXR0cmlidXRpb25zXSBBdHRyaWJ1dGlvbnMuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFthdHRyaWJ1dGlvbnNDb2xsYXBzaWJsZT10cnVlXSBBdHRyaWJ1dGlvbnMgYXJlIGNvbGxhcHNpYmxlLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtjYWNoZVNpemVdIEluaXRpYWwgdGlsZSBjYWNoZSBzaXplLiBXaWxsIGF1dG8tZ3JvdyB0byBob2xkIGF0IGxlYXN0IHRoZSBudW1iZXIgb2YgdGlsZXMgaW4gdGhlIHZpZXdwb3J0LlxuICogQHByb3BlcnR5IHtudWxsfHN0cmluZ30gW2Nyb3NzT3JpZ2luXSBUaGUgYGNyb3NzT3JpZ2luYCBhdHRyaWJ1dGUgZm9yIGxvYWRlZCBpbWFnZXMuICBOb3RlIHRoYXRcbiAqIHlvdSBtdXN0IHByb3ZpZGUgYSBgY3Jvc3NPcmlnaW5gIHZhbHVlIGlmIHlvdSB3YW50IHRvIGFjY2VzcyBwaXhlbCBkYXRhIHdpdGggdGhlIENhbnZhcyByZW5kZXJlci5cbiAqIFNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVE1ML0NPUlNfZW5hYmxlZF9pbWFnZSBmb3IgbW9yZSBkZXRhaWwuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtpbnRlcnBvbGF0ZT10cnVlXSBVc2UgaW50ZXJwb2xhdGVkIHZhbHVlcyB3aGVuIHJlc2FtcGxpbmcuICBCeSBkZWZhdWx0LFxuICogbGluZWFyIGludGVycG9sYXRpb24gaXMgdXNlZCB3aGVuIHJlc2FtcGxpbmcuICBTZXQgdG8gZmFsc2UgdG8gdXNlIHRoZSBuZWFyZXN0IG5laWdoYm9yIGluc3RlYWQuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtvcGFxdWU9ZmFsc2VdIFdoZXRoZXIgdGhlIGxheWVyIGlzIG9wYXF1ZS5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vcHJvai5qc1wiKS5Qcm9qZWN0aW9uTGlrZX0gW3Byb2plY3Rpb25dIFByb2plY3Rpb24uIERlZmF1bHQgaXMgdGhlIHZpZXcgcHJvamVjdGlvbi5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbcmVwcm9qZWN0aW9uRXJyb3JUaHJlc2hvbGQ9MC41XSBNYXhpbXVtIGFsbG93ZWQgcmVwcm9qZWN0aW9uIGVycm9yIChpbiBwaXhlbHMpLlxuICogSGlnaGVyIHZhbHVlcyBjYW4gaW5jcmVhc2UgcmVwcm9qZWN0aW9uIHBlcmZvcm1hbmNlLCBidXQgZGVjcmVhc2UgcHJlY2lzaW9uLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL1NvdXJjZS5qc1wiKS5TdGF0ZX0gW3N0YXRlXSBTb3VyY2Ugc3RhdGUuXG4gKiBAcHJvcGVydHkge3R5cGVvZiBpbXBvcnQoXCIuLi9JbWFnZVRpbGUuanNcIikuZGVmYXVsdH0gW3RpbGVDbGFzc10gQ2xhc3MgdXNlZCB0byBpbnN0YW50aWF0ZSBpbWFnZSB0aWxlcy5cbiAqIERlZmF1bHQgaXMge0BsaW5rIG1vZHVsZTpvbC9JbWFnZVRpbGV+SW1hZ2VUaWxlfS5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vdGlsZWdyaWQvVGlsZUdyaWQuanNcIikuZGVmYXVsdH0gW3RpbGVHcmlkXSBUaWxlIGdyaWQuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL1RpbGUuanNcIikuTG9hZEZ1bmN0aW9ufSBbdGlsZUxvYWRGdW5jdGlvbl0gT3B0aW9uYWwgZnVuY3Rpb24gdG8gbG9hZCBhIHRpbGUgZ2l2ZW4gYSBVUkwuIFRoZSBkZWZhdWx0IGlzXG4gKiBgYGBqc1xuICogZnVuY3Rpb24oaW1hZ2VUaWxlLCBzcmMpIHtcbiAqICAgaW1hZ2VUaWxlLmdldEltYWdlKCkuc3JjID0gc3JjO1xuICogfTtcbiAqIGBgYFxuICogQHByb3BlcnR5IHtudW1iZXJ9IFt0aWxlUGl4ZWxSYXRpbz0xXSBUaGUgcGl4ZWwgcmF0aW8gdXNlZCBieSB0aGUgdGlsZSBzZXJ2aWNlLiBGb3IgZXhhbXBsZSwgaWYgdGhlIHRpbGVcbiAqIHNlcnZpY2UgYWR2ZXJ0aXplcyAyNTZweCBieSAyNTZweCB0aWxlcyBidXQgYWN0dWFsbHkgc2VuZHMgNTEycHhcbiAqIGJ5IDUxMnB4IGltYWdlcyAoZm9yIHJldGluYS9oaWRwaSBkZXZpY2VzKSB0aGVuIGB0aWxlUGl4ZWxSYXRpb2BcbiAqIHNob3VsZCBiZSBzZXQgdG8gYDJgLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9UaWxlLmpzXCIpLlVybEZ1bmN0aW9ufSBbdGlsZVVybEZ1bmN0aW9uXSBPcHRpb25hbCBmdW5jdGlvbiB0byBnZXQgdGlsZSBVUkwgZ2l2ZW4gYSB0aWxlIGNvb3JkaW5hdGUgYW5kIHRoZSBwcm9qZWN0aW9uLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFt1cmxdIFVSTCB0ZW1wbGF0ZS4gTXVzdCBpbmNsdWRlIGB7eH1gLCBge3l9YCBvciBgey15fWAsIGFuZCBge3p9YCBwbGFjZWhvbGRlcnMuXG4gKiBBIGB7Py0/fWAgdGVtcGxhdGUgcGF0dGVybiwgZm9yIGV4YW1wbGUgYHN1YmRvbWFpbnthLWZ9LmRvbWFpbi5jb21gLCBtYXkgYmVcbiAqIHVzZWQgaW5zdGVhZCBvZiBkZWZpbmluZyBlYWNoIG9uZSBzZXBhcmF0ZWx5IGluIHRoZSBgdXJsc2Agb3B0aW9uLlxuICogQHByb3BlcnR5IHtBcnJheTxzdHJpbmc+fSBbdXJsc10gQW4gYXJyYXkgb2YgVVJMIHRlbXBsYXRlcy5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3dyYXBYXSBXaGV0aGVyIHRvIHdyYXAgdGhlIHdvcmxkIGhvcml6b250YWxseS4gVGhlIGRlZmF1bHQsIGlzIHRvXG4gKiByZXF1ZXN0IG91dC1vZi1ib3VuZHMgdGlsZXMgZnJvbSB0aGUgc2VydmVyLiBXaGVuIHNldCB0byBgZmFsc2VgLCBvbmx5IG9uZVxuICogd29ybGQgd2lsbCBiZSByZW5kZXJlZC4gV2hlbiBzZXQgdG8gYHRydWVgLCB0aWxlcyB3aWxsIGJlIHJlcXVlc3RlZCBmb3Igb25lXG4gKiB3b3JsZCBvbmx5LCBidXQgdGhleSB3aWxsIGJlIHdyYXBwZWQgaG9yaXpvbnRhbGx5IHRvIHJlbmRlciBtdWx0aXBsZSB3b3JsZHMuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3RyYW5zaXRpb25dIER1cmF0aW9uIG9mIHRoZSBvcGFjaXR5IHRyYW5zaXRpb24gZm9yIHJlbmRlcmluZy5cbiAqIFRvIGRpc2FibGUgdGhlIG9wYWNpdHkgdHJhbnNpdGlvbiwgcGFzcyBgdHJhbnNpdGlvbjogMGAuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2tleV0gT3B0aW9uYWwgdGlsZSBrZXkgZm9yIHByb3BlciBjYWNoZSBmZXRjaGluZ1xuICogQHByb3BlcnR5IHtudW1iZXJ8aW1wb3J0KFwiLi4vYXJyYXkuanNcIikuTmVhcmVzdERpcmVjdGlvbkZ1bmN0aW9ufSBbekRpcmVjdGlvbj0wXVxuICogQ2hvb3NlIHdoZXRoZXIgdG8gdXNlIHRpbGVzIHdpdGggYSBoaWdoZXIgb3IgbG93ZXIgem9vbSBsZXZlbCB3aGVuIGJldHdlZW4gaW50ZWdlclxuICogem9vbSBsZXZlbHMuIFNlZSB7QGxpbmsgbW9kdWxlOm9sL3RpbGVncmlkL1RpbGVHcmlkflRpbGVHcmlkI2dldFpGb3JSZXNvbHV0aW9ufS5cbiAqL1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEJhc2UgY2xhc3MgZm9yIHNvdXJjZXMgcHJvdmlkaW5nIGltYWdlcyBkaXZpZGVkIGludG8gYSB0aWxlIGdyaWQuXG4gKlxuICogQGZpcmVzIGltcG9ydChcIi4vVGlsZS5qc1wiKS5UaWxlU291cmNlRXZlbnRcbiAqIEBhcGlcbiAqL1xuY2xhc3MgVGlsZUltYWdlIGV4dGVuZHMgVXJsVGlsZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0geyFPcHRpb25zfSBvcHRpb25zIEltYWdlIHRpbGUgb3B0aW9ucy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcih7XG4gICAgICBhdHRyaWJ1dGlvbnM6IG9wdGlvbnMuYXR0cmlidXRpb25zLFxuICAgICAgY2FjaGVTaXplOiBvcHRpb25zLmNhY2hlU2l6ZSxcbiAgICAgIG9wYXF1ZTogb3B0aW9ucy5vcGFxdWUsXG4gICAgICBwcm9qZWN0aW9uOiBvcHRpb25zLnByb2plY3Rpb24sXG4gICAgICBzdGF0ZTogb3B0aW9ucy5zdGF0ZSxcbiAgICAgIHRpbGVHcmlkOiBvcHRpb25zLnRpbGVHcmlkLFxuICAgICAgdGlsZUxvYWRGdW5jdGlvbjogb3B0aW9ucy50aWxlTG9hZEZ1bmN0aW9uXG4gICAgICAgID8gb3B0aW9ucy50aWxlTG9hZEZ1bmN0aW9uXG4gICAgICAgIDogZGVmYXVsdFRpbGVMb2FkRnVuY3Rpb24sXG4gICAgICB0aWxlUGl4ZWxSYXRpbzogb3B0aW9ucy50aWxlUGl4ZWxSYXRpbyxcbiAgICAgIHRpbGVVcmxGdW5jdGlvbjogb3B0aW9ucy50aWxlVXJsRnVuY3Rpb24sXG4gICAgICB1cmw6IG9wdGlvbnMudXJsLFxuICAgICAgdXJsczogb3B0aW9ucy51cmxzLFxuICAgICAgd3JhcFg6IG9wdGlvbnMud3JhcFgsXG4gICAgICB0cmFuc2l0aW9uOiBvcHRpb25zLnRyYW5zaXRpb24sXG4gICAgICBpbnRlcnBvbGF0ZTpcbiAgICAgICAgb3B0aW9ucy5pbnRlcnBvbGF0ZSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5pbnRlcnBvbGF0ZSA6IHRydWUsXG4gICAgICBrZXk6IG9wdGlvbnMua2V5LFxuICAgICAgYXR0cmlidXRpb25zQ29sbGFwc2libGU6IG9wdGlvbnMuYXR0cmlidXRpb25zQ29sbGFwc2libGUsXG4gICAgICB6RGlyZWN0aW9uOiBvcHRpb25zLnpEaXJlY3Rpb24sXG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHR5cGUgez9zdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5jcm9zc09yaWdpbiA9XG4gICAgICBvcHRpb25zLmNyb3NzT3JpZ2luICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmNyb3NzT3JpZ2luIDogbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAdHlwZSB7dHlwZW9mIEltYWdlVGlsZX1cbiAgICAgKi9cbiAgICB0aGlzLnRpbGVDbGFzcyA9XG4gICAgICBvcHRpb25zLnRpbGVDbGFzcyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy50aWxlQ2xhc3MgOiBJbWFnZVRpbGU7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHR5cGUgeyFPYmplY3Q8c3RyaW5nLCBUaWxlQ2FjaGU+fVxuICAgICAqL1xuICAgIHRoaXMudGlsZUNhY2hlRm9yUHJvamVjdGlvbiA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEB0eXBlIHshT2JqZWN0PHN0cmluZywgaW1wb3J0KFwiLi4vdGlsZWdyaWQvVGlsZUdyaWQuanNcIikuZGVmYXVsdD59XG4gICAgICovXG4gICAgdGhpcy50aWxlR3JpZEZvclByb2plY3Rpb24gPSB7fTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcnx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5yZXByb2plY3Rpb25FcnJvclRocmVzaG9sZF8gPSBvcHRpb25zLnJlcHJvamVjdGlvbkVycm9yVGhyZXNob2xkO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLnJlbmRlclJlcHJvamVjdGlvbkVkZ2VzXyA9IGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IENhbiBleHBpcmUgY2FjaGUuXG4gICAqL1xuICBjYW5FeHBpcmVDYWNoZSgpIHtcbiAgICBpZiAodGhpcy50aWxlQ2FjaGUuY2FuRXhwaXJlQ2FjaGUoKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGZvciAoY29uc3Qga2V5IGluIHRoaXMudGlsZUNhY2hlRm9yUHJvamVjdGlvbikge1xuICAgICAgaWYgKHRoaXMudGlsZUNhY2hlRm9yUHJvamVjdGlvbltrZXldLmNhbkV4cGlyZUNhY2hlKCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcHJvai9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR9IHByb2plY3Rpb24gUHJvamVjdGlvbi5cbiAgICogQHBhcmFtIHshT2JqZWN0PHN0cmluZywgYm9vbGVhbj59IHVzZWRUaWxlcyBVc2VkIHRpbGVzLlxuICAgKi9cbiAgZXhwaXJlQ2FjaGUocHJvamVjdGlvbiwgdXNlZFRpbGVzKSB7XG4gICAgY29uc3QgdXNlZFRpbGVDYWNoZSA9IHRoaXMuZ2V0VGlsZUNhY2hlRm9yUHJvamVjdGlvbihwcm9qZWN0aW9uKTtcblxuICAgIHRoaXMudGlsZUNhY2hlLmV4cGlyZUNhY2hlKFxuICAgICAgdGhpcy50aWxlQ2FjaGUgPT0gdXNlZFRpbGVDYWNoZSA/IHVzZWRUaWxlcyA6IHt9XG4gICAgKTtcbiAgICBmb3IgKGNvbnN0IGlkIGluIHRoaXMudGlsZUNhY2hlRm9yUHJvamVjdGlvbikge1xuICAgICAgY29uc3QgdGlsZUNhY2hlID0gdGhpcy50aWxlQ2FjaGVGb3JQcm9qZWN0aW9uW2lkXTtcbiAgICAgIHRpbGVDYWNoZS5leHBpcmVDYWNoZSh0aWxlQ2FjaGUgPT0gdXNlZFRpbGVDYWNoZSA/IHVzZWRUaWxlcyA6IHt9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9wcm9qL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdH0gcHJvamVjdGlvbiBQcm9qZWN0aW9uLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IEd1dHRlci5cbiAgICovXG4gIGdldEd1dHRlckZvclByb2plY3Rpb24ocHJvamVjdGlvbikge1xuICAgIGlmIChcbiAgICAgIHRoaXMuZ2V0UHJvamVjdGlvbigpICYmXG4gICAgICBwcm9qZWN0aW9uICYmXG4gICAgICAhZXF1aXZhbGVudCh0aGlzLmdldFByb2plY3Rpb24oKSwgcHJvamVjdGlvbilcbiAgICApIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5nZXRHdXR0ZXIoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IEd1dHRlci5cbiAgICovXG4gIGdldEd1dHRlcigpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGtleSB0byBiZSB1c2VkIGZvciBhbGwgdGlsZXMgaW4gdGhlIHNvdXJjZS5cbiAgICogQHJldHVybiB7c3RyaW5nfSBUaGUga2V5IGZvciBhbGwgdGlsZXMuXG4gICAqL1xuICBnZXRLZXkoKSB7XG4gICAgbGV0IGtleSA9IHN1cGVyLmdldEtleSgpO1xuICAgIGlmICghdGhpcy5nZXRJbnRlcnBvbGF0ZSgpKSB7XG4gICAgICBrZXkgKz0gJzpkaXNhYmxlLWludGVycG9sYXRpb24nO1xuICAgIH1cbiAgICByZXR1cm4ga2V5O1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcHJvai9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR9IHByb2plY3Rpb24gUHJvamVjdGlvbi5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gT3BhcXVlLlxuICAgKi9cbiAgZ2V0T3BhcXVlKHByb2plY3Rpb24pIHtcbiAgICBpZiAoXG4gICAgICB0aGlzLmdldFByb2plY3Rpb24oKSAmJlxuICAgICAgcHJvamVjdGlvbiAmJlxuICAgICAgIWVxdWl2YWxlbnQodGhpcy5nZXRQcm9qZWN0aW9uKCksIHByb2plY3Rpb24pXG4gICAgKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBzdXBlci5nZXRPcGFxdWUocHJvamVjdGlvbik7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9wcm9qL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdH0gcHJvamVjdGlvbiBQcm9qZWN0aW9uLlxuICAgKiBAcmV0dXJuIHshaW1wb3J0KFwiLi4vdGlsZWdyaWQvVGlsZUdyaWQuanNcIikuZGVmYXVsdH0gVGlsZSBncmlkLlxuICAgKi9cbiAgZ2V0VGlsZUdyaWRGb3JQcm9qZWN0aW9uKHByb2plY3Rpb24pIHtcbiAgICBjb25zdCB0aGlzUHJvaiA9IHRoaXMuZ2V0UHJvamVjdGlvbigpO1xuICAgIGlmICh0aGlzLnRpbGVHcmlkICYmICghdGhpc1Byb2ogfHwgZXF1aXZhbGVudCh0aGlzUHJvaiwgcHJvamVjdGlvbikpKSB7XG4gICAgICByZXR1cm4gdGhpcy50aWxlR3JpZDtcbiAgICB9XG4gICAgY29uc3QgcHJvaktleSA9IGdldFVpZChwcm9qZWN0aW9uKTtcbiAgICBpZiAoIShwcm9qS2V5IGluIHRoaXMudGlsZUdyaWRGb3JQcm9qZWN0aW9uKSkge1xuICAgICAgdGhpcy50aWxlR3JpZEZvclByb2plY3Rpb25bcHJvaktleV0gPVxuICAgICAgICBnZXRUaWxlR3JpZEZvclByb2plY3Rpb24ocHJvamVjdGlvbik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnRpbGVHcmlkRm9yUHJvamVjdGlvbltwcm9qS2V5XTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3Byb2ovUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0fSBwcm9qZWN0aW9uIFByb2plY3Rpb24uXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL1RpbGVDYWNoZS5qc1wiKS5kZWZhdWx0fSBUaWxlIGNhY2hlLlxuICAgKi9cbiAgZ2V0VGlsZUNhY2hlRm9yUHJvamVjdGlvbihwcm9qZWN0aW9uKSB7XG4gICAgY29uc3QgdGhpc1Byb2ogPSB0aGlzLmdldFByb2plY3Rpb24oKTtcbiAgICBpZiAoIXRoaXNQcm9qIHx8IGVxdWl2YWxlbnQodGhpc1Byb2osIHByb2plY3Rpb24pKSB7XG4gICAgICByZXR1cm4gdGhpcy50aWxlQ2FjaGU7XG4gICAgfVxuICAgIGNvbnN0IHByb2pLZXkgPSBnZXRVaWQocHJvamVjdGlvbik7XG4gICAgaWYgKCEocHJvaktleSBpbiB0aGlzLnRpbGVDYWNoZUZvclByb2plY3Rpb24pKSB7XG4gICAgICB0aGlzLnRpbGVDYWNoZUZvclByb2plY3Rpb25bcHJvaktleV0gPSBuZXcgVGlsZUNhY2hlKFxuICAgICAgICB0aGlzLnRpbGVDYWNoZS5oaWdoV2F0ZXJNYXJrXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy50aWxlQ2FjaGVGb3JQcm9qZWN0aW9uW3Byb2pLZXldO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB6IFRpbGUgY29vcmRpbmF0ZSB6LlxuICAgKiBAcGFyYW0ge251bWJlcn0geCBUaWxlIGNvb3JkaW5hdGUgeC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHkgVGlsZSBjb29yZGluYXRlIHkuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwaXhlbFJhdGlvIFBpeGVsIHJhdGlvLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3Byb2ovUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0fSBwcm9qZWN0aW9uIFByb2plY3Rpb24uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBzZXQgb24gdGhlIHRpbGUuXG4gICAqIEByZXR1cm4geyFJbWFnZVRpbGV9IFRpbGUuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjcmVhdGVUaWxlXyh6LCB4LCB5LCBwaXhlbFJhdGlvLCBwcm9qZWN0aW9uLCBrZXkpIHtcbiAgICBjb25zdCB0aWxlQ29vcmQgPSBbeiwgeCwgeV07XG4gICAgY29uc3QgdXJsVGlsZUNvb3JkID0gdGhpcy5nZXRUaWxlQ29vcmRGb3JUaWxlVXJsRnVuY3Rpb24oXG4gICAgICB0aWxlQ29vcmQsXG4gICAgICBwcm9qZWN0aW9uXG4gICAgKTtcbiAgICBjb25zdCB0aWxlVXJsID0gdXJsVGlsZUNvb3JkXG4gICAgICA/IHRoaXMudGlsZVVybEZ1bmN0aW9uKHVybFRpbGVDb29yZCwgcGl4ZWxSYXRpbywgcHJvamVjdGlvbilcbiAgICAgIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IHRpbGUgPSBuZXcgdGhpcy50aWxlQ2xhc3MoXG4gICAgICB0aWxlQ29vcmQsXG4gICAgICB0aWxlVXJsICE9PSB1bmRlZmluZWQgPyBUaWxlU3RhdGUuSURMRSA6IFRpbGVTdGF0ZS5FTVBUWSxcbiAgICAgIHRpbGVVcmwgIT09IHVuZGVmaW5lZCA/IHRpbGVVcmwgOiAnJyxcbiAgICAgIHRoaXMuY3Jvc3NPcmlnaW4sXG4gICAgICB0aGlzLnRpbGVMb2FkRnVuY3Rpb24sXG4gICAgICB0aGlzLnRpbGVPcHRpb25zXG4gICAgKTtcbiAgICB0aWxlLmtleSA9IGtleTtcbiAgICB0aWxlLmFkZEV2ZW50TGlzdGVuZXIoRXZlbnRUeXBlLkNIQU5HRSwgdGhpcy5oYW5kbGVUaWxlQ2hhbmdlLmJpbmQodGhpcykpO1xuICAgIHJldHVybiB0aWxlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB6IFRpbGUgY29vcmRpbmF0ZSB6LlxuICAgKiBAcGFyYW0ge251bWJlcn0geCBUaWxlIGNvb3JkaW5hdGUgeC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHkgVGlsZSBjb29yZGluYXRlIHkuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwaXhlbFJhdGlvIFBpeGVsIHJhdGlvLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3Byb2ovUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0fSBwcm9qZWN0aW9uIFByb2plY3Rpb24uXG4gICAqIEByZXR1cm4geyEoSW1hZ2VUaWxlfFJlcHJvalRpbGUpfSBUaWxlLlxuICAgKi9cbiAgZ2V0VGlsZSh6LCB4LCB5LCBwaXhlbFJhdGlvLCBwcm9qZWN0aW9uKSB7XG4gICAgY29uc3Qgc291cmNlUHJvamVjdGlvbiA9IHRoaXMuZ2V0UHJvamVjdGlvbigpO1xuICAgIGlmIChcbiAgICAgICFzb3VyY2VQcm9qZWN0aW9uIHx8XG4gICAgICAhcHJvamVjdGlvbiB8fFxuICAgICAgZXF1aXZhbGVudChzb3VyY2VQcm9qZWN0aW9uLCBwcm9qZWN0aW9uKVxuICAgICkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0VGlsZUludGVybmFsKFxuICAgICAgICB6LFxuICAgICAgICB4LFxuICAgICAgICB5LFxuICAgICAgICBwaXhlbFJhdGlvLFxuICAgICAgICBzb3VyY2VQcm9qZWN0aW9uIHx8IHByb2plY3Rpb25cbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IGNhY2hlID0gdGhpcy5nZXRUaWxlQ2FjaGVGb3JQcm9qZWN0aW9uKHByb2plY3Rpb24pO1xuICAgIGNvbnN0IHRpbGVDb29yZCA9IFt6LCB4LCB5XTtcbiAgICBsZXQgdGlsZTtcbiAgICBjb25zdCB0aWxlQ29vcmRLZXkgPSBnZXRLZXkodGlsZUNvb3JkKTtcbiAgICBpZiAoY2FjaGUuY29udGFpbnNLZXkodGlsZUNvb3JkS2V5KSkge1xuICAgICAgdGlsZSA9IGNhY2hlLmdldCh0aWxlQ29vcmRLZXkpO1xuICAgIH1cbiAgICBjb25zdCBrZXkgPSB0aGlzLmdldEtleSgpO1xuICAgIGlmICh0aWxlICYmIHRpbGUua2V5ID09IGtleSkge1xuICAgICAgcmV0dXJuIHRpbGU7XG4gICAgfVxuICAgIGNvbnN0IHNvdXJjZVRpbGVHcmlkID0gdGhpcy5nZXRUaWxlR3JpZEZvclByb2plY3Rpb24oc291cmNlUHJvamVjdGlvbik7XG4gICAgY29uc3QgdGFyZ2V0VGlsZUdyaWQgPSB0aGlzLmdldFRpbGVHcmlkRm9yUHJvamVjdGlvbihwcm9qZWN0aW9uKTtcbiAgICBjb25zdCB3cmFwcGVkVGlsZUNvb3JkID0gdGhpcy5nZXRUaWxlQ29vcmRGb3JUaWxlVXJsRnVuY3Rpb24oXG4gICAgICB0aWxlQ29vcmQsXG4gICAgICBwcm9qZWN0aW9uXG4gICAgKTtcbiAgICBjb25zdCBuZXdUaWxlID0gbmV3IFJlcHJvalRpbGUoXG4gICAgICBzb3VyY2VQcm9qZWN0aW9uLFxuICAgICAgc291cmNlVGlsZUdyaWQsXG4gICAgICBwcm9qZWN0aW9uLFxuICAgICAgdGFyZ2V0VGlsZUdyaWQsXG4gICAgICB0aWxlQ29vcmQsXG4gICAgICB3cmFwcGVkVGlsZUNvb3JkLFxuICAgICAgdGhpcy5nZXRUaWxlUGl4ZWxSYXRpbyhwaXhlbFJhdGlvKSxcbiAgICAgIHRoaXMuZ2V0R3V0dGVyKCksXG4gICAgICAoeiwgeCwgeSwgcGl4ZWxSYXRpbykgPT5cbiAgICAgICAgdGhpcy5nZXRUaWxlSW50ZXJuYWwoeiwgeCwgeSwgcGl4ZWxSYXRpbywgc291cmNlUHJvamVjdGlvbiksXG4gICAgICB0aGlzLnJlcHJvamVjdGlvbkVycm9yVGhyZXNob2xkXyxcbiAgICAgIHRoaXMucmVuZGVyUmVwcm9qZWN0aW9uRWRnZXNfLFxuICAgICAgdGhpcy5nZXRJbnRlcnBvbGF0ZSgpXG4gICAgKTtcbiAgICBuZXdUaWxlLmtleSA9IGtleTtcblxuICAgIGlmICh0aWxlKSB7XG4gICAgICBuZXdUaWxlLmludGVyaW1UaWxlID0gdGlsZTtcbiAgICAgIG5ld1RpbGUucmVmcmVzaEludGVyaW1DaGFpbigpO1xuICAgICAgY2FjaGUucmVwbGFjZSh0aWxlQ29vcmRLZXksIG5ld1RpbGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYWNoZS5zZXQodGlsZUNvb3JkS2V5LCBuZXdUaWxlKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld1RpbGU7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHogVGlsZSBjb29yZGluYXRlIHouXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4IFRpbGUgY29vcmRpbmF0ZSB4LlxuICAgKiBAcGFyYW0ge251bWJlcn0geSBUaWxlIGNvb3JkaW5hdGUgeS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHBpeGVsUmF0aW8gUGl4ZWwgcmF0aW8uXG4gICAqIEBwYXJhbSB7IWltcG9ydChcIi4uL3Byb2ovUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0fSBwcm9qZWN0aW9uIFByb2plY3Rpb24uXG4gICAqIEByZXR1cm4geyFJbWFnZVRpbGV9IFRpbGUuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIGdldFRpbGVJbnRlcm5hbCh6LCB4LCB5LCBwaXhlbFJhdGlvLCBwcm9qZWN0aW9uKSB7XG4gICAgbGV0IHRpbGUgPSBudWxsO1xuICAgIGNvbnN0IHRpbGVDb29yZEtleSA9IGdldEtleVpYWSh6LCB4LCB5KTtcbiAgICBjb25zdCBrZXkgPSB0aGlzLmdldEtleSgpO1xuICAgIGlmICghdGhpcy50aWxlQ2FjaGUuY29udGFpbnNLZXkodGlsZUNvb3JkS2V5KSkge1xuICAgICAgdGlsZSA9IHRoaXMuY3JlYXRlVGlsZV8oeiwgeCwgeSwgcGl4ZWxSYXRpbywgcHJvamVjdGlvbiwga2V5KTtcbiAgICAgIHRoaXMudGlsZUNhY2hlLnNldCh0aWxlQ29vcmRLZXksIHRpbGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aWxlID0gdGhpcy50aWxlQ2FjaGUuZ2V0KHRpbGVDb29yZEtleSk7XG4gICAgICBpZiAodGlsZS5rZXkgIT0ga2V5KSB7XG4gICAgICAgIC8vIFRoZSBzb3VyY2UncyBwYXJhbXMgY2hhbmdlZC4gSWYgdGhlIHRpbGUgaGFzIGFuIGludGVyaW0gdGlsZSBhbmQgaWYgd2VcbiAgICAgICAgLy8gY2FuIHVzZSBpdCB0aGVuIHdlIHVzZSBpdC4gT3RoZXJ3aXNlIHdlIGNyZWF0ZSBhIG5ldyB0aWxlLiAgSW4gYm90aFxuICAgICAgICAvLyBjYXNlcyB3ZSBhdHRlbXB0IHRvIGFzc2lnbiBhbiBpbnRlcmltIHRpbGUgdG8gdGhlIG5ldyB0aWxlLlxuICAgICAgICBjb25zdCBpbnRlcmltVGlsZSA9IHRpbGU7XG4gICAgICAgIHRpbGUgPSB0aGlzLmNyZWF0ZVRpbGVfKHosIHgsIHksIHBpeGVsUmF0aW8sIHByb2plY3Rpb24sIGtleSk7XG5cbiAgICAgICAgLy9tYWtlIHRoZSBuZXcgdGlsZSB0aGUgaGVhZCBvZiB0aGUgbGlzdCxcbiAgICAgICAgaWYgKGludGVyaW1UaWxlLmdldFN0YXRlKCkgPT0gVGlsZVN0YXRlLklETEUpIHtcbiAgICAgICAgICAvL3RoZSBvbGQgdGlsZSBoYXNuJ3QgYmVndW4gbG9hZGluZyB5ZXQsIGFuZCBpcyBub3cgb3V0ZGF0ZWQsIHNvIHdlIGNhbiBzaW1wbHkgZGlzY2FyZCBpdFxuICAgICAgICAgIHRpbGUuaW50ZXJpbVRpbGUgPSBpbnRlcmltVGlsZS5pbnRlcmltVGlsZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aWxlLmludGVyaW1UaWxlID0gaW50ZXJpbVRpbGU7XG4gICAgICAgIH1cbiAgICAgICAgdGlsZS5yZWZyZXNoSW50ZXJpbUNoYWluKCk7XG4gICAgICAgIHRoaXMudGlsZUNhY2hlLnJlcGxhY2UodGlsZUNvb3JkS2V5LCB0aWxlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRpbGU7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB3aGV0aGVyIHRvIHJlbmRlciByZXByb2plY3Rpb24gZWRnZXMgb3Igbm90ICh1c3VhbGx5IGZvciBkZWJ1Z2dpbmcpLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHJlbmRlciBSZW5kZXIgdGhlIGVkZ2VzLlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRSZW5kZXJSZXByb2plY3Rpb25FZGdlcyhyZW5kZXIpIHtcbiAgICBpZiAodGhpcy5yZW5kZXJSZXByb2plY3Rpb25FZGdlc18gPT0gcmVuZGVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMucmVuZGVyUmVwcm9qZWN0aW9uRWRnZXNfID0gcmVuZGVyO1xuICAgIGZvciAoY29uc3QgaWQgaW4gdGhpcy50aWxlQ2FjaGVGb3JQcm9qZWN0aW9uKSB7XG4gICAgICB0aGlzLnRpbGVDYWNoZUZvclByb2plY3Rpb25baWRdLmNsZWFyKCk7XG4gICAgfVxuICAgIHRoaXMuY2hhbmdlZCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHRpbGUgZ3JpZCB0byB1c2Ugd2hlbiByZXByb2plY3RpbmcgdGhlIHRpbGVzIHRvIHRoZSBnaXZlblxuICAgKiBwcm9qZWN0aW9uIGluc3RlYWQgb2YgdGhlIGRlZmF1bHQgdGlsZSBncmlkIGZvciB0aGUgcHJvamVjdGlvbi5cbiAgICpcbiAgICogVGhpcyBjYW4gYmUgdXNlZnVsIHdoZW4gdGhlIGRlZmF1bHQgdGlsZSBncmlkIGNhbm5vdCBiZSBjcmVhdGVkXG4gICAqIChlLmcuIHByb2plY3Rpb24gaGFzIG5vIGV4dGVudCBkZWZpbmVkKSBvclxuICAgKiBmb3Igb3B0aW1pemF0aW9uIHJlYXNvbnMgKGN1c3RvbSB0aWxlIHNpemUsIHJlc29sdXRpb25zLCAuLi4pLlxuICAgKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3Byb2ouanNcIikuUHJvamVjdGlvbkxpa2V9IHByb2plY3Rpb24gUHJvamVjdGlvbi5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi90aWxlZ3JpZC9UaWxlR3JpZC5qc1wiKS5kZWZhdWx0fSB0aWxlZ3JpZCBUaWxlIGdyaWQgdG8gdXNlIGZvciB0aGUgcHJvamVjdGlvbi5cbiAgICogQGFwaVxuICAgKi9cbiAgc2V0VGlsZUdyaWRGb3JQcm9qZWN0aW9uKHByb2plY3Rpb24sIHRpbGVncmlkKSB7XG4gICAgY29uc3QgcHJvaiA9IGdldFByb2plY3Rpb24ocHJvamVjdGlvbik7XG4gICAgaWYgKHByb2opIHtcbiAgICAgIGNvbnN0IHByb2pLZXkgPSBnZXRVaWQocHJvaik7XG4gICAgICBpZiAoIShwcm9qS2V5IGluIHRoaXMudGlsZUdyaWRGb3JQcm9qZWN0aW9uKSkge1xuICAgICAgICB0aGlzLnRpbGVHcmlkRm9yUHJvamVjdGlvbltwcm9qS2V5XSA9IHRpbGVncmlkO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGNsZWFyKCkge1xuICAgIHN1cGVyLmNsZWFyKCk7XG4gICAgZm9yIChjb25zdCBpZCBpbiB0aGlzLnRpbGVDYWNoZUZvclByb2plY3Rpb24pIHtcbiAgICAgIHRoaXMudGlsZUNhY2hlRm9yUHJvamVjdGlvbltpZF0uY2xlYXIoKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0ltYWdlVGlsZX0gaW1hZ2VUaWxlIEltYWdlIHRpbGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gc3JjIFNvdXJjZS5cbiAqL1xuZnVuY3Rpb24gZGVmYXVsdFRpbGVMb2FkRnVuY3Rpb24oaW1hZ2VUaWxlLCBzcmMpIHtcbiAgLyoqIEB0eXBlIHtIVE1MSW1hZ2VFbGVtZW50fEhUTUxWaWRlb0VsZW1lbnR9ICovIChpbWFnZVRpbGUuZ2V0SW1hZ2UoKSkuc3JjID1cbiAgICBzcmM7XG59XG5cbmV4cG9ydCBkZWZhdWx0IFRpbGVJbWFnZTtcbiIsIi8qKlxuICogQG1vZHVsZSBvbC9zb3VyY2UvVXJsVGlsZVxuICovXG5pbXBvcnQgVGlsZUV2ZW50VHlwZSBmcm9tICcuL1RpbGVFdmVudFR5cGUuanMnO1xuaW1wb3J0IFRpbGVTb3VyY2UsIHtUaWxlU291cmNlRXZlbnR9IGZyb20gJy4vVGlsZS5qcyc7XG5pbXBvcnQgVGlsZVN0YXRlIGZyb20gJy4uL1RpbGVTdGF0ZS5qcyc7XG5pbXBvcnQge2NyZWF0ZUZyb21UZW1wbGF0ZXMsIGV4cGFuZFVybH0gZnJvbSAnLi4vdGlsZXVybGZ1bmN0aW9uLmpzJztcbmltcG9ydCB7Z2V0S2V5WlhZfSBmcm9tICcuLi90aWxlY29vcmQuanMnO1xuaW1wb3J0IHtnZXRVaWR9IGZyb20gJy4uL3V0aWwuanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi9Tb3VyY2UuanNcIikuQXR0cmlidXRpb25MaWtlfSBbYXR0cmlidXRpb25zXSBBdHRyaWJ1dGlvbnMuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFthdHRyaWJ1dGlvbnNDb2xsYXBzaWJsZT10cnVlXSBBdHRyaWJ1dGlvbnMgYXJlIGNvbGxhcHNpYmxlLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtjYWNoZVNpemVdIENhY2hlIHNpemUuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtvcGFxdWU9ZmFsc2VdIFdoZXRoZXIgdGhlIGxheWVyIGlzIG9wYXF1ZS5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vcHJvai5qc1wiKS5Qcm9qZWN0aW9uTGlrZX0gW3Byb2plY3Rpb25dIFByb2plY3Rpb24uXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4vU291cmNlLmpzXCIpLlN0YXRlfSBbc3RhdGVdIFN0YXRlLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi90aWxlZ3JpZC9UaWxlR3JpZC5qc1wiKS5kZWZhdWx0fSBbdGlsZUdyaWRdIFRpbGVHcmlkLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9UaWxlLmpzXCIpLkxvYWRGdW5jdGlvbn0gdGlsZUxvYWRGdW5jdGlvbiBUaWxlTG9hZEZ1bmN0aW9uLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFt0aWxlUGl4ZWxSYXRpb10gVGlsZVBpeGVsUmF0aW8uXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL1RpbGUuanNcIikuVXJsRnVuY3Rpb259IFt0aWxlVXJsRnVuY3Rpb25dIFRpbGVVcmxGdW5jdGlvbi5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbdXJsXSBVcmwuXG4gKiBAcHJvcGVydHkge0FycmF5PHN0cmluZz59IFt1cmxzXSBVcmxzLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbd3JhcFg9dHJ1ZV0gV3JhcFguXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3RyYW5zaXRpb25dIFRyYW5zaXRpb24uXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2tleV0gS2V5LlxuICogQHByb3BlcnR5IHtudW1iZXJ8aW1wb3J0KFwiLi4vYXJyYXkuanNcIikuTmVhcmVzdERpcmVjdGlvbkZ1bmN0aW9ufSBbekRpcmVjdGlvbj0wXSBaRGlyZWN0aW9uLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbaW50ZXJwb2xhdGU9ZmFsc2VdIFVzZSBpbnRlcnBvbGF0ZWQgdmFsdWVzIHdoZW4gcmVzYW1wbGluZy4gIEJ5IGRlZmF1bHQsXG4gKiB0aGUgbmVhcmVzdCBuZWlnaGJvciBpcyB1c2VkIHdoZW4gcmVzYW1wbGluZy5cbiAqL1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEJhc2UgY2xhc3MgZm9yIHNvdXJjZXMgcHJvdmlkaW5nIHRpbGVzIGRpdmlkZWQgaW50byBhIHRpbGUgZ3JpZCBvdmVyIGh0dHAuXG4gKlxuICogQGZpcmVzIGltcG9ydChcIi4vVGlsZS5qc1wiKS5UaWxlU291cmNlRXZlbnRcbiAqL1xuY2xhc3MgVXJsVGlsZSBleHRlbmRzIFRpbGVTb3VyY2Uge1xuICAvKipcbiAgICogQHBhcmFtIHtPcHRpb25zfSBvcHRpb25zIEltYWdlIHRpbGUgb3B0aW9ucy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcih7XG4gICAgICBhdHRyaWJ1dGlvbnM6IG9wdGlvbnMuYXR0cmlidXRpb25zLFxuICAgICAgY2FjaGVTaXplOiBvcHRpb25zLmNhY2hlU2l6ZSxcbiAgICAgIG9wYXF1ZTogb3B0aW9ucy5vcGFxdWUsXG4gICAgICBwcm9qZWN0aW9uOiBvcHRpb25zLnByb2plY3Rpb24sXG4gICAgICBzdGF0ZTogb3B0aW9ucy5zdGF0ZSxcbiAgICAgIHRpbGVHcmlkOiBvcHRpb25zLnRpbGVHcmlkLFxuICAgICAgdGlsZVBpeGVsUmF0aW86IG9wdGlvbnMudGlsZVBpeGVsUmF0aW8sXG4gICAgICB3cmFwWDogb3B0aW9ucy53cmFwWCxcbiAgICAgIHRyYW5zaXRpb246IG9wdGlvbnMudHJhbnNpdGlvbixcbiAgICAgIGludGVycG9sYXRlOiBvcHRpb25zLmludGVycG9sYXRlLFxuICAgICAga2V5OiBvcHRpb25zLmtleSxcbiAgICAgIGF0dHJpYnV0aW9uc0NvbGxhcHNpYmxlOiBvcHRpb25zLmF0dHJpYnV0aW9uc0NvbGxhcHNpYmxlLFxuICAgICAgekRpcmVjdGlvbjogb3B0aW9ucy56RGlyZWN0aW9uLFxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmdlbmVyYXRlVGlsZVVybEZ1bmN0aW9uXyA9XG4gICAgICB0aGlzLnRpbGVVcmxGdW5jdGlvbiA9PT0gVXJsVGlsZS5wcm90b3R5cGUudGlsZVVybEZ1bmN0aW9uO1xuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9UaWxlLmpzXCIpLkxvYWRGdW5jdGlvbn1cbiAgICAgKi9cbiAgICB0aGlzLnRpbGVMb2FkRnVuY3Rpb24gPSBvcHRpb25zLnRpbGVMb2FkRnVuY3Rpb247XG5cbiAgICBpZiAob3B0aW9ucy50aWxlVXJsRnVuY3Rpb24pIHtcbiAgICAgIHRoaXMudGlsZVVybEZ1bmN0aW9uID0gb3B0aW9ucy50aWxlVXJsRnVuY3Rpb247XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEB0eXBlIHshQXJyYXk8c3RyaW5nPnxudWxsfVxuICAgICAqL1xuICAgIHRoaXMudXJscyA9IG51bGw7XG5cbiAgICBpZiAob3B0aW9ucy51cmxzKSB7XG4gICAgICB0aGlzLnNldFVybHMob3B0aW9ucy51cmxzKTtcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMudXJsKSB7XG4gICAgICB0aGlzLnNldFVybChvcHRpb25zLnVybCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7IU9iamVjdDxzdHJpbmcsIGJvb2xlYW4+fVxuICAgICAqL1xuICAgIHRoaXMudGlsZUxvYWRpbmdLZXlzXyA9IHt9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgdGlsZSBsb2FkIGZ1bmN0aW9uIG9mIHRoZSBzb3VyY2UuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL1RpbGUuanNcIikuTG9hZEZ1bmN0aW9ufSBUaWxlTG9hZEZ1bmN0aW9uXG4gICAqIEBhcGlcbiAgICovXG4gIGdldFRpbGVMb2FkRnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMudGlsZUxvYWRGdW5jdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIHRpbGUgVVJMIGZ1bmN0aW9uIG9mIHRoZSBzb3VyY2UuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL1RpbGUuanNcIikuVXJsRnVuY3Rpb259IFRpbGVVcmxGdW5jdGlvblxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRUaWxlVXJsRnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKS50aWxlVXJsRnVuY3Rpb24gPT09IHRoaXMudGlsZVVybEZ1bmN0aW9uXG4gICAgICA/IHRoaXMudGlsZVVybEZ1bmN0aW9uLmJpbmQodGhpcylcbiAgICAgIDogdGhpcy50aWxlVXJsRnVuY3Rpb247XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBVUkxzIHVzZWQgZm9yIHRoaXMgc291cmNlLlxuICAgKiBXaGVuIGEgdGlsZVVybEZ1bmN0aW9uIGlzIHVzZWQgaW5zdGVhZCBvZiB1cmwgb3IgdXJscyxcbiAgICogbnVsbCB3aWxsIGJlIHJldHVybmVkLlxuICAgKiBAcmV0dXJuIHshQXJyYXk8c3RyaW5nPnxudWxsfSBVUkxzLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRVcmxzKCkge1xuICAgIHJldHVybiB0aGlzLnVybHM7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlIHRpbGUgY2hhbmdlIGV2ZW50cy5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9ldmVudHMvRXZlbnQuanNcIikuZGVmYXVsdH0gZXZlbnQgRXZlbnQuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIGhhbmRsZVRpbGVDaGFuZ2UoZXZlbnQpIHtcbiAgICBjb25zdCB0aWxlID0gLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi9UaWxlLmpzXCIpLmRlZmF1bHR9ICovIChldmVudC50YXJnZXQpO1xuICAgIGNvbnN0IHVpZCA9IGdldFVpZCh0aWxlKTtcbiAgICBjb25zdCB0aWxlU3RhdGUgPSB0aWxlLmdldFN0YXRlKCk7XG4gICAgbGV0IHR5cGU7XG4gICAgaWYgKHRpbGVTdGF0ZSA9PSBUaWxlU3RhdGUuTE9BRElORykge1xuICAgICAgdGhpcy50aWxlTG9hZGluZ0tleXNfW3VpZF0gPSB0cnVlO1xuICAgICAgdHlwZSA9IFRpbGVFdmVudFR5cGUuVElMRUxPQURTVEFSVDtcbiAgICB9IGVsc2UgaWYgKHVpZCBpbiB0aGlzLnRpbGVMb2FkaW5nS2V5c18pIHtcbiAgICAgIGRlbGV0ZSB0aGlzLnRpbGVMb2FkaW5nS2V5c19bdWlkXTtcbiAgICAgIHR5cGUgPVxuICAgICAgICB0aWxlU3RhdGUgPT0gVGlsZVN0YXRlLkVSUk9SXG4gICAgICAgICAgPyBUaWxlRXZlbnRUeXBlLlRJTEVMT0FERVJST1JcbiAgICAgICAgICA6IHRpbGVTdGF0ZSA9PSBUaWxlU3RhdGUuTE9BREVEXG4gICAgICAgICAgPyBUaWxlRXZlbnRUeXBlLlRJTEVMT0FERU5EXG4gICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmICh0eXBlICE9IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBUaWxlU291cmNlRXZlbnQodHlwZSwgdGlsZSkpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHRpbGUgbG9hZCBmdW5jdGlvbiBvZiB0aGUgc291cmNlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL1RpbGUuanNcIikuTG9hZEZ1bmN0aW9ufSB0aWxlTG9hZEZ1bmN0aW9uIFRpbGUgbG9hZCBmdW5jdGlvbi5cbiAgICogQGFwaVxuICAgKi9cbiAgc2V0VGlsZUxvYWRGdW5jdGlvbih0aWxlTG9hZEZ1bmN0aW9uKSB7XG4gICAgdGhpcy50aWxlQ2FjaGUuY2xlYXIoKTtcbiAgICB0aGlzLnRpbGVMb2FkRnVuY3Rpb24gPSB0aWxlTG9hZEZ1bmN0aW9uO1xuICAgIHRoaXMuY2hhbmdlZCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgdGlsZSBVUkwgZnVuY3Rpb24gb2YgdGhlIHNvdXJjZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9UaWxlLmpzXCIpLlVybEZ1bmN0aW9ufSB0aWxlVXJsRnVuY3Rpb24gVGlsZSBVUkwgZnVuY3Rpb24uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBba2V5XSBPcHRpb25hbCBuZXcgdGlsZSBrZXkgZm9yIHRoZSBzb3VyY2UuXG4gICAqIEBhcGlcbiAgICovXG4gIHNldFRpbGVVcmxGdW5jdGlvbih0aWxlVXJsRnVuY3Rpb24sIGtleSkge1xuICAgIHRoaXMudGlsZVVybEZ1bmN0aW9uID0gdGlsZVVybEZ1bmN0aW9uO1xuICAgIHRoaXMudGlsZUNhY2hlLnBydW5lRXhjZXB0TmV3ZXN0WigpO1xuICAgIGlmICh0eXBlb2Yga2V5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpcy5zZXRLZXkoa2V5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jaGFuZ2VkKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgVVJMIHRvIHVzZSBmb3IgcmVxdWVzdHMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVVJMLlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRVcmwodXJsKSB7XG4gICAgY29uc3QgdXJscyA9IGV4cGFuZFVybCh1cmwpO1xuICAgIHRoaXMudXJscyA9IHVybHM7XG4gICAgdGhpcy5zZXRVcmxzKHVybHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgVVJMcyB0byB1c2UgZm9yIHJlcXVlc3RzLlxuICAgKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IHVybHMgVVJMcy5cbiAgICogQGFwaVxuICAgKi9cbiAgc2V0VXJscyh1cmxzKSB7XG4gICAgdGhpcy51cmxzID0gdXJscztcbiAgICBjb25zdCBrZXkgPSB1cmxzLmpvaW4oJ1xcbicpO1xuICAgIGlmICh0aGlzLmdlbmVyYXRlVGlsZVVybEZ1bmN0aW9uXykge1xuICAgICAgdGhpcy5zZXRUaWxlVXJsRnVuY3Rpb24oY3JlYXRlRnJvbVRlbXBsYXRlcyh1cmxzLCB0aGlzLnRpbGVHcmlkKSwga2V5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZXRLZXkoa2V5KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi90aWxlY29vcmQuanNcIikuVGlsZUNvb3JkfSB0aWxlQ29vcmQgVGlsZSBjb29yZGluYXRlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gcGl4ZWxSYXRpbyBQaXhlbCByYXRpby5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9wcm9qL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdH0gcHJvamVjdGlvbiBQcm9qZWN0aW9uLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd8dW5kZWZpbmVkfSBUaWxlIFVSTC5cbiAgICovXG4gIHRpbGVVcmxGdW5jdGlvbih0aWxlQ29vcmQsIHBpeGVsUmF0aW8sIHByb2plY3Rpb24pIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIE1hcmtzIGEgdGlsZSBjb29yZCBhcyBiZWluZyB1c2VkLCB3aXRob3V0IHRyaWdnZXJpbmcgYSBsb2FkLlxuICAgKiBAcGFyYW0ge251bWJlcn0geiBUaWxlIGNvb3JkaW5hdGUgei5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHggVGlsZSBjb29yZGluYXRlIHguXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5IFRpbGUgY29vcmRpbmF0ZSB5LlxuICAgKi9cbiAgdXNlVGlsZSh6LCB4LCB5KSB7XG4gICAgY29uc3QgdGlsZUNvb3JkS2V5ID0gZ2V0S2V5WlhZKHosIHgsIHkpO1xuICAgIGlmICh0aGlzLnRpbGVDYWNoZS5jb250YWluc0tleSh0aWxlQ29vcmRLZXkpKSB7XG4gICAgICB0aGlzLnRpbGVDYWNoZS5nZXQodGlsZUNvb3JkS2V5KTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgVXJsVGlsZTtcbiIsIi8qKlxuICogQG1vZHVsZSBvbC9zb3VyY2UvVmVjdG9yXG4gKi9cblxuaW1wb3J0IENvbGxlY3Rpb24gZnJvbSAnLi4vQ29sbGVjdGlvbi5qcyc7XG5pbXBvcnQgQ29sbGVjdGlvbkV2ZW50VHlwZSBmcm9tICcuLi9Db2xsZWN0aW9uRXZlbnRUeXBlLmpzJztcbmltcG9ydCBFdmVudCBmcm9tICcuLi9ldmVudHMvRXZlbnQuanMnO1xuaW1wb3J0IEV2ZW50VHlwZSBmcm9tICcuLi9ldmVudHMvRXZlbnRUeXBlLmpzJztcbmltcG9ydCBPYmplY3RFdmVudFR5cGUgZnJvbSAnLi4vT2JqZWN0RXZlbnRUeXBlLmpzJztcbmltcG9ydCBSQnVzaCBmcm9tICcuLi9zdHJ1Y3RzL1JCdXNoLmpzJztcbmltcG9ydCBTb3VyY2UgZnJvbSAnLi9Tb3VyY2UuanMnO1xuaW1wb3J0IFZlY3RvckV2ZW50VHlwZSBmcm9tICcuL1ZlY3RvckV2ZW50VHlwZS5qcyc7XG5pbXBvcnQge1RSVUUsIFZPSUR9IGZyb20gJy4uL2Z1bmN0aW9ucy5qcyc7XG5pbXBvcnQge2FsbCBhcyBhbGxTdHJhdGVneX0gZnJvbSAnLi4vbG9hZGluZ3N0cmF0ZWd5LmpzJztcbmltcG9ydCB7YXNzZXJ0fSBmcm9tICcuLi9hc3NlcnRzLmpzJztcbmltcG9ydCB7Y29udGFpbnNFeHRlbnQsIGVxdWFscywgd3JhcEFuZFNsaWNlWH0gZnJvbSAnLi4vZXh0ZW50LmpzJztcbmltcG9ydCB7ZXh0ZW5kfSBmcm9tICcuLi9hcnJheS5qcyc7XG5pbXBvcnQge2dldFVpZH0gZnJvbSAnLi4vdXRpbC5qcyc7XG5pbXBvcnQge2lzRW1wdHl9IGZyb20gJy4uL29iai5qcyc7XG5pbXBvcnQge2xpc3RlbiwgdW5saXN0ZW5CeUtleX0gZnJvbSAnLi4vZXZlbnRzLmpzJztcbmltcG9ydCB7eGhyfSBmcm9tICcuLi9mZWF0dXJlbG9hZGVyLmpzJztcblxuLyoqXG4gKiBBIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYW4ge0BsaW5rIG1vZHVsZTpvbC9leHRlbnR+RXh0ZW50fSBhbmQgYSByZXNvbHV0aW9uIGFzIGFyZ3VtZW50cywgYW5kXG4gKiByZXR1cm5zIGFuIGFycmF5IG9mIHtAbGluayBtb2R1bGU6b2wvZXh0ZW50fkV4dGVudH0gd2l0aCB0aGUgZXh0ZW50cyB0byBsb2FkLiBVc3VhbGx5IHRoaXNcbiAqIGlzIG9uZSBvZiB0aGUgc3RhbmRhcmQge0BsaW5rIG1vZHVsZTpvbC9sb2FkaW5nc3RyYXRlZ3l9IHN0cmF0ZWdpZXMuXG4gKlxuICogQHR5cGVkZWYge2Z1bmN0aW9uKGltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnQsIG51bWJlciwgaW1wb3J0KFwiLi4vcHJvai9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHQpOiBBcnJheTxpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50Pn0gTG9hZGluZ1N0cmF0ZWd5XG4gKiBAYXBpXG4gKi9cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBFdmVudHMgZW1pdHRlZCBieSB7QGxpbmsgbW9kdWxlOm9sL3NvdXJjZS9WZWN0b3J+VmVjdG9yU291cmNlfSBpbnN0YW5jZXMgYXJlIGluc3RhbmNlcyBvZiB0aGlzXG4gKiB0eXBlLlxuICogQHRlbXBsYXRlIHtpbXBvcnQoXCIuLi9nZW9tL0dlb21ldHJ5LmpzXCIpLmRlZmF1bHR9IFtHZW9tZXRyeT1pbXBvcnQoXCIuLi9nZW9tL0dlb21ldHJ5LmpzXCIpLmRlZmF1bHRdXG4gKi9cbmV4cG9ydCBjbGFzcyBWZWN0b3JTb3VyY2VFdmVudCBleHRlbmRzIEV2ZW50IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIFR5cGUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0PEdlb21ldHJ5Pn0gW2ZlYXR1cmVdIEZlYXR1cmUuXG4gICAqIEBwYXJhbSB7QXJyYXk8aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0PEdlb21ldHJ5Pj59IFtmZWF0dXJlc10gRmVhdHVyZXMuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih0eXBlLCBmZWF0dXJlLCBmZWF0dXJlcykge1xuICAgIHN1cGVyKHR5cGUpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGFkZGVkIG9yIHJlbW92ZWQgZmVhdHVyZSBmb3IgdGhlIGBBRERGRUFUVVJFYCBhbmQgYFJFTU9WRUZFQVRVUkVgIGV2ZW50cywgYHVuZGVmaW5lZGAgb3RoZXJ3aXNlLlxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHQ8R2VvbWV0cnk+fHVuZGVmaW5lZH1cbiAgICAgKiBAYXBpXG4gICAgICovXG4gICAgdGhpcy5mZWF0dXJlID0gZmVhdHVyZTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBsb2FkZWQgZmVhdHVyZXMgZm9yIHRoZSBgRkVBVFVSRVNMT0FERURgIGV2ZW50LCBgdW5kZWZpbmVkYCBvdGhlcndpc2UuXG4gICAgICogQHR5cGUge0FycmF5PGltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdDxHZW9tZXRyeT4+fHVuZGVmaW5lZH1cbiAgICAgKiBAYXBpXG4gICAgICovXG4gICAgdGhpcy5mZWF0dXJlcyA9IGZlYXR1cmVzO1xuICB9XG59XG5cbi8qKipcbiAqIEB0ZW1wbGF0ZSBSZXR1cm5cbiAqIEB0eXBlZGVmIHtpbXBvcnQoXCIuLi9PYnNlcnZhYmxlXCIpLk9uU2lnbmF0dXJlPGltcG9ydChcIi4uL09ic2VydmFibGVcIikuRXZlbnRUeXBlcywgaW1wb3J0KFwiLi4vZXZlbnRzL0V2ZW50LmpzXCIpLmRlZmF1bHQsIFJldHVybj4gJlxuICogICBpbXBvcnQoXCIuLi9PYnNlcnZhYmxlXCIpLk9uU2lnbmF0dXJlPGltcG9ydChcIi4uL09iamVjdEV2ZW50VHlwZVwiKS5UeXBlcywgaW1wb3J0KFwiLi4vT2JqZWN0XCIpLk9iamVjdEV2ZW50LCBSZXR1cm4+ICZcbiAqICAgaW1wb3J0KFwiLi4vT2JzZXJ2YWJsZVwiKS5PblNpZ25hdHVyZTxpbXBvcnQoXCIuL1ZlY3RvckV2ZW50VHlwZVwiKS5WZWN0b3JTb3VyY2VFdmVudFR5cGVzLCBWZWN0b3JTb3VyY2VFdmVudCwgUmV0dXJuPiAmXG4gKiAgIGltcG9ydChcIi4uL09ic2VydmFibGVcIikuQ29tYmluZWRPblNpZ25hdHVyZTxpbXBvcnQoXCIuLi9PYnNlcnZhYmxlXCIpLkV2ZW50VHlwZXN8aW1wb3J0KFwiLi4vT2JqZWN0RXZlbnRUeXBlXCIpLlR5cGVzfFxuICogICAgIGltcG9ydChcIi4vVmVjdG9yRXZlbnRUeXBlXCIpLlZlY3RvclNvdXJjZUV2ZW50VHlwZXMsIFJldHVybj59IFZlY3RvclNvdXJjZU9uU2lnbmF0dXJlXG4gKi9cblxuLyoqXG4gKiBAdGVtcGxhdGUge2ltcG9ydChcIi4uL2dlb20vR2VvbWV0cnkuanNcIikuZGVmYXVsdH0gW0dlb21ldHJ5PWltcG9ydChcIi4uL2dlb20vR2VvbWV0cnkuanNcIikuZGVmYXVsdF1cbiAqIEB0eXBlZGVmIHtPYmplY3R9IE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi9Tb3VyY2UuanNcIikuQXR0cmlidXRpb25MaWtlfSBbYXR0cmlidXRpb25zXSBBdHRyaWJ1dGlvbnMuXG4gKiBAcHJvcGVydHkge0FycmF5PGltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdDxHZW9tZXRyeT4+fENvbGxlY3Rpb248aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0PEdlb21ldHJ5Pj59IFtmZWF0dXJlc11cbiAqIEZlYXR1cmVzLiBJZiBwcm92aWRlZCBhcyB7QGxpbmsgbW9kdWxlOm9sL0NvbGxlY3Rpb25+Q29sbGVjdGlvbn0sIHRoZSBmZWF0dXJlcyBpbiB0aGUgc291cmNlXG4gKiBhbmQgdGhlIGNvbGxlY3Rpb24gd2lsbCBzdGF5IGluIHN5bmMuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL2Zvcm1hdC9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9IFtmb3JtYXRdIFRoZSBmZWF0dXJlIGZvcm1hdCB1c2VkIGJ5IHRoZSBYSFJcbiAqIGZlYXR1cmUgbG9hZGVyIHdoZW4gYHVybGAgaXMgc2V0LiBSZXF1aXJlZCBpZiBgdXJsYCBpcyBzZXQsIG90aGVyd2lzZSBpZ25vcmVkLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9mZWF0dXJlbG9hZGVyLmpzXCIpLkZlYXR1cmVMb2FkZXJ9IFtsb2FkZXJdXG4gKiBUaGUgbG9hZGVyIGZ1bmN0aW9uIHVzZWQgdG8gbG9hZCBmZWF0dXJlcywgZnJvbSBhIHJlbW90ZSBzb3VyY2UgZm9yIGV4YW1wbGUuXG4gKiBJZiB0aGlzIGlzIG5vdCBzZXQgYW5kIGB1cmxgIGlzIHNldCwgdGhlIHNvdXJjZSB3aWxsIGNyZWF0ZSBhbmQgdXNlIGFuIFhIUlxuICogZmVhdHVyZSBsb2FkZXIuIFRoZSBgJ2ZlYXR1cmVzbG9hZGVuZCdgIGFuZCBgJ2ZlYXR1cmVzbG9hZGVycm9yJ2AgZXZlbnRzXG4gKiB3aWxsIG9ubHkgZmlyZSBpZiB0aGUgYHN1Y2Nlc3NgIGFuZCBgZmFpbHVyZWAgY2FsbGJhY2tzIGFyZSB1c2VkLlxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogYGBganNcbiAqIGltcG9ydCBWZWN0b3IgZnJvbSAnb2wvc291cmNlL1ZlY3Rvci5qcyc7XG4gKiBpbXBvcnQgR2VvSlNPTiBmcm9tICdvbC9mb3JtYXQvR2VvSlNPTi5qcyc7XG4gKiBpbXBvcnQge2Jib3h9IGZyb20gJ29sL2xvYWRpbmdzdHJhdGVneS5qcyc7XG4gKlxuICogY29uc3QgdmVjdG9yU291cmNlID0gbmV3IFZlY3Rvcih7XG4gKiAgIGZvcm1hdDogbmV3IEdlb0pTT04oKSxcbiAqICAgbG9hZGVyOiBmdW5jdGlvbihleHRlbnQsIHJlc29sdXRpb24sIHByb2plY3Rpb24sIHN1Y2Nlc3MsIGZhaWx1cmUpIHtcbiAqICAgICAgY29uc3QgcHJvaiA9IHByb2plY3Rpb24uZ2V0Q29kZSgpO1xuICogICAgICBjb25zdCB1cmwgPSAnaHR0cHM6Ly9haG9jZXZhci5jb20vZ2Vvc2VydmVyL3dmcz9zZXJ2aWNlPVdGUyYnICtcbiAqICAgICAgICAgICd2ZXJzaW9uPTEuMS4wJnJlcXVlc3Q9R2V0RmVhdHVyZSZ0eXBlbmFtZT1vc206d2F0ZXJfYXJlYXMmJyArXG4gKiAgICAgICAgICAnb3V0cHV0Rm9ybWF0PWFwcGxpY2F0aW9uL2pzb24mc3JzbmFtZT0nICsgcHJvaiArICcmJyArXG4gKiAgICAgICAgICAnYmJveD0nICsgZXh0ZW50LmpvaW4oJywnKSArICcsJyArIHByb2o7XG4gKiAgICAgIGNvbnN0IHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICogICAgICB4aHIub3BlbignR0VUJywgdXJsKTtcbiAqICAgICAgY29uc3Qgb25FcnJvciA9IGZ1bmN0aW9uKCkge1xuICogICAgICAgIHZlY3RvclNvdXJjZS5yZW1vdmVMb2FkZWRFeHRlbnQoZXh0ZW50KTtcbiAqICAgICAgICBmYWlsdXJlKCk7XG4gKiAgICAgIH1cbiAqICAgICAgeGhyLm9uZXJyb3IgPSBvbkVycm9yO1xuICogICAgICB4aHIub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gKiAgICAgICAgaWYgKHhoci5zdGF0dXMgPT0gMjAwKSB7XG4gKiAgICAgICAgICBjb25zdCBmZWF0dXJlcyA9IHZlY3RvclNvdXJjZS5nZXRGb3JtYXQoKS5yZWFkRmVhdHVyZXMoeGhyLnJlc3BvbnNlVGV4dCk7XG4gKiAgICAgICAgICB2ZWN0b3JTb3VyY2UuYWRkRmVhdHVyZXMoZmVhdHVyZXMpO1xuICogICAgICAgICAgc3VjY2VzcyhmZWF0dXJlcyk7XG4gKiAgICAgICAgfSBlbHNlIHtcbiAqICAgICAgICAgIG9uRXJyb3IoKTtcbiAqICAgICAgICB9XG4gKiAgICAgIH1cbiAqICAgICAgeGhyLnNlbmQoKTtcbiAqICAgIH0sXG4gKiAgICBzdHJhdGVneTogYmJveCxcbiAqICB9KTtcbiAqIGBgYFxuICogQHByb3BlcnR5IHtib29sZWFufSBbb3ZlcmxhcHM9dHJ1ZV0gVGhpcyBzb3VyY2UgbWF5IGhhdmUgb3ZlcmxhcHBpbmcgZ2VvbWV0cmllcy5cbiAqIFNldHRpbmcgdGhpcyB0byBgZmFsc2VgIChlLmcuIGZvciBzb3VyY2VzIHdpdGggcG9seWdvbnMgdGhhdCByZXByZXNlbnQgYWRtaW5pc3RyYXRpdmVcbiAqIGJvdW5kYXJpZXMgb3IgVG9wb0pTT04gc291cmNlcykgYWxsb3dzIHRoZSByZW5kZXJlciB0byBvcHRpbWlzZSBmaWxsIGFuZFxuICogc3Ryb2tlIG9wZXJhdGlvbnMuXG4gKiBAcHJvcGVydHkge0xvYWRpbmdTdHJhdGVneX0gW3N0cmF0ZWd5XSBUaGUgbG9hZGluZyBzdHJhdGVneSB0byB1c2UuXG4gKiBCeSBkZWZhdWx0IGFuIHtAbGluayBtb2R1bGU6b2wvbG9hZGluZ3N0cmF0ZWd5LmFsbH1cbiAqIHN0cmF0ZWd5IGlzIHVzZWQsIGEgb25lLW9mZiBzdHJhdGVneSB3aGljaCBsb2FkcyBhbGwgZmVhdHVyZXMgYXQgb25jZS5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfGltcG9ydChcIi4uL2ZlYXR1cmVsb2FkZXIuanNcIikuRmVhdHVyZVVybEZ1bmN0aW9ufSBbdXJsXVxuICogU2V0dGluZyB0aGlzIG9wdGlvbiBpbnN0cnVjdHMgdGhlIHNvdXJjZSB0byBsb2FkIGZlYXR1cmVzIHVzaW5nIGFuIFhIUiBsb2FkZXJcbiAqIChzZWUge0BsaW5rIG1vZHVsZTpvbC9mZWF0dXJlbG9hZGVyLnhocn0pLiBVc2UgYSBgc3RyaW5nYCBhbmQgYW5cbiAqIHtAbGluayBtb2R1bGU6b2wvbG9hZGluZ3N0cmF0ZWd5LmFsbH0gZm9yIGEgb25lLW9mZiBkb3dubG9hZCBvZiBhbGwgZmVhdHVyZXMgZnJvbVxuICogdGhlIGdpdmVuIFVSTC4gVXNlIGEge0BsaW5rIG1vZHVsZTpvbC9mZWF0dXJlbG9hZGVyfkZlYXR1cmVVcmxGdW5jdGlvbn0gdG8gZ2VuZXJhdGUgdGhlIHVybCB3aXRoXG4gKiBvdGhlciBsb2FkaW5nIHN0cmF0ZWdpZXMuXG4gKiBSZXF1aXJlcyBgZm9ybWF0YCB0byBiZSBzZXQgYXMgd2VsbC5cbiAqIFdoZW4gZGVmYXVsdCBYSFIgZmVhdHVyZSBsb2FkZXIgaXMgcHJvdmlkZWQsIHRoZSBmZWF0dXJlcyB3aWxsXG4gKiBiZSB0cmFuc2Zvcm1lZCBmcm9tIHRoZSBkYXRhIHByb2plY3Rpb24gdG8gdGhlIHZpZXcgcHJvamVjdGlvblxuICogZHVyaW5nIHBhcnNpbmcuIElmIHlvdXIgcmVtb3RlIGRhdGEgc291cmNlIGRvZXMgbm90IGFkdmVydGlzZSBpdHMgcHJvamVjdGlvblxuICogcHJvcGVybHksIHRoaXMgdHJhbnNmb3JtYXRpb24gd2lsbCBiZSBpbmNvcnJlY3QuIEZvciBzb21lIGZvcm1hdHMsIHRoZVxuICogZGVmYXVsdCBwcm9qZWN0aW9uICh1c3VhbGx5IEVQU0c6NDMyNikgY2FuIGJlIG92ZXJyaWRkZW4gYnkgc2V0dGluZyB0aGVcbiAqIGRhdGFQcm9qZWN0aW9uIGNvbnN0cnVjdG9yIG9wdGlvbiBvbiB0aGUgZm9ybWF0LlxuICogTm90ZSB0aGF0IGlmIGEgc291cmNlIGNvbnRhaW5zIG5vbi1mZWF0dXJlIGRhdGEsIHN1Y2ggYXMgYSBHZW9KU09OIGdlb21ldHJ5XG4gKiBvciBhIEtNTCBOZXR3b3JrTGluaywgdGhlc2Ugd2lsbCBiZSBpZ25vcmVkLiBVc2UgYSBjdXN0b20gbG9hZGVyIHRvIGxvYWQgdGhlc2UuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFt1c2VTcGF0aWFsSW5kZXg9dHJ1ZV1cbiAqIEJ5IGRlZmF1bHQsIGFuIFJUcmVlIGlzIHVzZWQgYXMgc3BhdGlhbCBpbmRleC4gV2hlbiBmZWF0dXJlcyBhcmUgcmVtb3ZlZCBhbmRcbiAqIGFkZGVkIGZyZXF1ZW50bHksIGFuZCB0aGUgdG90YWwgbnVtYmVyIG9mIGZlYXR1cmVzIGlzIGxvdywgc2V0dGluZyB0aGlzIHRvXG4gKiBgZmFsc2VgIG1heSBpbXByb3ZlIHBlcmZvcm1hbmNlLlxuICpcbiAqIE5vdGUgdGhhdFxuICoge0BsaW5rIG1vZHVsZTpvbC9zb3VyY2UvVmVjdG9yflZlY3RvclNvdXJjZSNnZXRGZWF0dXJlc0luRXh0ZW50fSxcbiAqIHtAbGluayBtb2R1bGU6b2wvc291cmNlL1ZlY3Rvcn5WZWN0b3JTb3VyY2UjZ2V0Q2xvc2VzdEZlYXR1cmVUb0Nvb3JkaW5hdGV9IGFuZFxuICoge0BsaW5rIG1vZHVsZTpvbC9zb3VyY2UvVmVjdG9yflZlY3RvclNvdXJjZSNnZXRFeHRlbnR9IGNhbm5vdCBiZSB1c2VkIHdoZW4gYHVzZVNwYXRpYWxJbmRleGAgaXNcbiAqIHNldCB0byBgZmFsc2VgLCBhbmQge0BsaW5rIG1vZHVsZTpvbC9zb3VyY2UvVmVjdG9yflZlY3RvclNvdXJjZSNmb3JFYWNoRmVhdHVyZUluRXh0ZW50fSB3aWxsIGxvb3BcbiAqIHRocm91Z2ggYWxsIGZlYXR1cmVzLlxuICpcbiAqIFdoZW4gc2V0IHRvIGBmYWxzZWAsIHRoZSBmZWF0dXJlcyB3aWxsIGJlIG1haW50YWluZWQgaW4gYW5cbiAqIHtAbGluayBtb2R1bGU6b2wvQ29sbGVjdGlvbn5Db2xsZWN0aW9ufSwgd2hpY2ggY2FuIGJlIHJldHJpZXZlZCB0aHJvdWdoXG4gKiB7QGxpbmsgbW9kdWxlOm9sL3NvdXJjZS9WZWN0b3J+VmVjdG9yU291cmNlI2dldEZlYXR1cmVzQ29sbGVjdGlvbn0uXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFt3cmFwWD10cnVlXSBXcmFwIHRoZSB3b3JsZCBob3Jpem9udGFsbHkuIEZvciB2ZWN0b3IgZWRpdGluZyBhY3Jvc3MgdGhlXG4gKiAtMTgwwrAgYW5kIDE4MMKwIG1lcmlkaWFucyB0byB3b3JrIHByb3Blcmx5LCB0aGlzIHNob3VsZCBiZSBzZXQgdG8gYGZhbHNlYC4gVGhlXG4gKiByZXN1bHRpbmcgZ2VvbWV0cnkgY29vcmRpbmF0ZXMgd2lsbCB0aGVuIGV4Y2VlZCB0aGUgd29ybGQgYm91bmRzLlxuICovXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogUHJvdmlkZXMgYSBzb3VyY2Ugb2YgZmVhdHVyZXMgZm9yIHZlY3RvciBsYXllcnMuIFZlY3RvciBmZWF0dXJlcyBwcm92aWRlZFxuICogYnkgdGhpcyBzb3VyY2UgYXJlIHN1aXRhYmxlIGZvciBlZGl0aW5nLiBTZWUge0BsaW5rIG1vZHVsZTpvbC9zb3VyY2UvVmVjdG9yVGlsZX5WZWN0b3JUaWxlfSBmb3JcbiAqIHZlY3RvciBkYXRhIHRoYXQgaXMgb3B0aW1pemVkIGZvciByZW5kZXJpbmcuXG4gKlxuICogQGZpcmVzIFZlY3RvclNvdXJjZUV2ZW50XG4gKiBAYXBpXG4gKiBAdGVtcGxhdGUge2ltcG9ydChcIi4uL2dlb20vR2VvbWV0cnkuanNcIikuZGVmYXVsdH0gW0dlb21ldHJ5PWltcG9ydChcIi4uL2dlb20vR2VvbWV0cnkuanNcIikuZGVmYXVsdF1cbiAqL1xuY2xhc3MgVmVjdG9yU291cmNlIGV4dGVuZHMgU291cmNlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7T3B0aW9uczxHZW9tZXRyeT59IFtvcHRpb25zXSBWZWN0b3Igc291cmNlIG9wdGlvbnMuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICBzdXBlcih7XG4gICAgICBhdHRyaWJ1dGlvbnM6IG9wdGlvbnMuYXR0cmlidXRpb25zLFxuICAgICAgaW50ZXJwb2xhdGU6IHRydWUsXG4gICAgICBwcm9qZWN0aW9uOiB1bmRlZmluZWQsXG4gICAgICBzdGF0ZTogJ3JlYWR5JyxcbiAgICAgIHdyYXBYOiBvcHRpb25zLndyYXBYICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLndyYXBYIDogdHJ1ZSxcbiAgICB9KTtcblxuICAgIC8qKipcbiAgICAgKiBAdHlwZSB7VmVjdG9yU291cmNlT25TaWduYXR1cmU8aW1wb3J0KFwiLi4vZXZlbnRzXCIpLkV2ZW50c0tleT59XG4gICAgICovXG4gICAgdGhpcy5vbjtcblxuICAgIC8qKipcbiAgICAgKiBAdHlwZSB7VmVjdG9yU291cmNlT25TaWduYXR1cmU8aW1wb3J0KFwiLi4vZXZlbnRzXCIpLkV2ZW50c0tleT59XG4gICAgICovXG4gICAgdGhpcy5vbmNlO1xuXG4gICAgLyoqKlxuICAgICAqIEB0eXBlIHtWZWN0b3JTb3VyY2VPblNpZ25hdHVyZTx2b2lkPn1cbiAgICAgKi9cbiAgICB0aGlzLnVuO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vZmVhdHVyZWxvYWRlci5qc1wiKS5GZWF0dXJlTG9hZGVyfVxuICAgICAqL1xuICAgIHRoaXMubG9hZGVyXyA9IFZPSUQ7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9mb3JtYXQvRmVhdHVyZS5qc1wiKS5kZWZhdWx0fHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLmZvcm1hdF8gPSBvcHRpb25zLmZvcm1hdDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5vdmVybGFwc18gPSBvcHRpb25zLm92ZXJsYXBzID09PSB1bmRlZmluZWQgPyB0cnVlIDogb3B0aW9ucy5vdmVybGFwcztcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge3N0cmluZ3xpbXBvcnQoXCIuLi9mZWF0dXJlbG9hZGVyLmpzXCIpLkZlYXR1cmVVcmxGdW5jdGlvbnx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy51cmxfID0gb3B0aW9ucy51cmw7XG5cbiAgICBpZiAob3B0aW9ucy5sb2FkZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5sb2FkZXJfID0gb3B0aW9ucy5sb2FkZXI7XG4gICAgfSBlbHNlIGlmICh0aGlzLnVybF8gIT09IHVuZGVmaW5lZCkge1xuICAgICAgYXNzZXJ0KHRoaXMuZm9ybWF0XywgJ2Bmb3JtYXRgIG11c3QgYmUgc2V0IHdoZW4gYHVybGAgaXMgc2V0Jyk7XG4gICAgICAvLyBjcmVhdGUgYSBYSFIgZmVhdHVyZSBsb2FkZXIgZm9yIFwidXJsXCIgYW5kIFwiZm9ybWF0XCJcbiAgICAgIHRoaXMubG9hZGVyXyA9IHhocihcbiAgICAgICAgdGhpcy51cmxfLFxuICAgICAgICAvKiogQHR5cGUge2ltcG9ydChcIi4uL2Zvcm1hdC9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9ICovICh0aGlzLmZvcm1hdF8pXG4gICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0xvYWRpbmdTdHJhdGVneX1cbiAgICAgKi9cbiAgICB0aGlzLnN0cmF0ZWd5XyA9XG4gICAgICBvcHRpb25zLnN0cmF0ZWd5ICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnN0cmF0ZWd5IDogYWxsU3RyYXRlZ3k7XG5cbiAgICBjb25zdCB1c2VTcGF0aWFsSW5kZXggPVxuICAgICAgb3B0aW9ucy51c2VTcGF0aWFsSW5kZXggIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMudXNlU3BhdGlhbEluZGV4IDogdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge1JCdXNoPGltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdDxHZW9tZXRyeT4+fVxuICAgICAqL1xuICAgIHRoaXMuZmVhdHVyZXNSdHJlZV8gPSB1c2VTcGF0aWFsSW5kZXggPyBuZXcgUkJ1c2goKSA6IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtSQnVzaDx7ZXh0ZW50OiBpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fT59XG4gICAgICovXG4gICAgdGhpcy5sb2FkZWRFeHRlbnRzUnRyZWVfID0gbmV3IFJCdXNoKCk7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5sb2FkaW5nRXh0ZW50c0NvdW50XyA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHshT2JqZWN0PHN0cmluZywgaW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0PEdlb21ldHJ5Pj59XG4gICAgICovXG4gICAgdGhpcy5udWxsR2VvbWV0cnlGZWF0dXJlc18gPSB7fTtcblxuICAgIC8qKlxuICAgICAqIEEgbG9va3VwIG9mIGZlYXR1cmVzIGJ5IGlkICh0aGUgcmV0dXJuIGZyb20gZmVhdHVyZS5nZXRJZCgpKS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHshT2JqZWN0PHN0cmluZywgaW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0PEdlb21ldHJ5Pj59XG4gICAgICovXG4gICAgdGhpcy5pZEluZGV4XyA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogQSBsb29rdXAgb2YgZmVhdHVyZXMgYnkgdWlkICh1c2luZyBnZXRVaWQoZmVhdHVyZSkpLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgeyFPYmplY3Q8c3RyaW5nLCBpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHQ8R2VvbWV0cnk+Pn1cbiAgICAgKi9cbiAgICB0aGlzLnVpZEluZGV4XyA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgQXJyYXk8aW1wb3J0KFwiLi4vZXZlbnRzLmpzXCIpLkV2ZW50c0tleT4+fVxuICAgICAqL1xuICAgIHRoaXMuZmVhdHVyZUNoYW5nZUtleXNfID0ge307XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtDb2xsZWN0aW9uPGltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdDxHZW9tZXRyeT4+fG51bGx9XG4gICAgICovXG4gICAgdGhpcy5mZWF0dXJlc0NvbGxlY3Rpb25fID0gbnVsbDtcblxuICAgIC8qKiBAdHlwZSB7Q29sbGVjdGlvbjxpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHQ8R2VvbWV0cnk+Pn0gKi9cbiAgICBsZXQgY29sbGVjdGlvbjtcbiAgICAvKiogQHR5cGUge0FycmF5PGltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdDxHZW9tZXRyeT4+fSAqL1xuICAgIGxldCBmZWF0dXJlcztcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zLmZlYXR1cmVzKSkge1xuICAgICAgZmVhdHVyZXMgPSBvcHRpb25zLmZlYXR1cmVzO1xuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5mZWF0dXJlcykge1xuICAgICAgY29sbGVjdGlvbiA9IG9wdGlvbnMuZmVhdHVyZXM7XG4gICAgICBmZWF0dXJlcyA9IGNvbGxlY3Rpb24uZ2V0QXJyYXkoKTtcbiAgICB9XG4gICAgaWYgKCF1c2VTcGF0aWFsSW5kZXggJiYgY29sbGVjdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb2xsZWN0aW9uID0gbmV3IENvbGxlY3Rpb24oZmVhdHVyZXMpO1xuICAgIH1cbiAgICBpZiAoZmVhdHVyZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5hZGRGZWF0dXJlc0ludGVybmFsKGZlYXR1cmVzKTtcbiAgICB9XG4gICAgaWYgKGNvbGxlY3Rpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5iaW5kRmVhdHVyZXNDb2xsZWN0aW9uXyhjb2xsZWN0aW9uKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQWRkIGEgc2luZ2xlIGZlYXR1cmUgdG8gdGhlIHNvdXJjZS4gIElmIHlvdSB3YW50IHRvIGFkZCBhIGJhdGNoIG9mIGZlYXR1cmVzXG4gICAqIGF0IG9uY2UsIGNhbGwge0BsaW5rIG1vZHVsZTpvbC9zb3VyY2UvVmVjdG9yflZlY3RvclNvdXJjZSNhZGRGZWF0dXJlcyAjYWRkRmVhdHVyZXMoKX1cbiAgICogaW5zdGVhZC4gQSBmZWF0dXJlIHdpbGwgbm90IGJlIGFkZGVkIHRvIHRoZSBzb3VyY2UgaWYgZmVhdHVyZSB3aXRoXG4gICAqIHRoZSBzYW1lIGlkIGlzIGFscmVhZHkgdGhlcmUuIFRoZSByZWFzb24gZm9yIHRoaXMgYmVoYXZpb3IgaXMgdG8gYXZvaWRcbiAgICogZmVhdHVyZSBkdXBsaWNhdGlvbiB3aGVuIHVzaW5nIGJib3ggb3IgdGlsZSBsb2FkaW5nIHN0cmF0ZWdpZXMuXG4gICAqIE5vdGU6IHRoaXMgYWxzbyBhcHBsaWVzIGlmIGFuIHtAbGluayBtb2R1bGU6b2wvQ29sbGVjdGlvbn5Db2xsZWN0aW9ufSBpcyB1c2VkIGZvciBmZWF0dXJlcyxcbiAgICogbWVhbmluZyB0aGF0IGlmIGEgZmVhdHVyZSB3aXRoIGEgZHVwbGljYXRlIGlkIGlzIGFkZGVkIGluIHRoZSBjb2xsZWN0aW9uLCBpdCB3aWxsXG4gICAqIGJlIHJlbW92ZWQgZnJvbSBpdCByaWdodCBhd2F5LlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdDxHZW9tZXRyeT59IGZlYXR1cmUgRmVhdHVyZSB0byBhZGQuXG4gICAqIEBhcGlcbiAgICovXG4gIGFkZEZlYXR1cmUoZmVhdHVyZSkge1xuICAgIHRoaXMuYWRkRmVhdHVyZUludGVybmFsKGZlYXR1cmUpO1xuICAgIHRoaXMuY2hhbmdlZCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhIGZlYXR1cmUgd2l0aG91dCBmaXJpbmcgYSBgY2hhbmdlYCBldmVudC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHQ8R2VvbWV0cnk+fSBmZWF0dXJlIEZlYXR1cmUuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIGFkZEZlYXR1cmVJbnRlcm5hbChmZWF0dXJlKSB7XG4gICAgY29uc3QgZmVhdHVyZUtleSA9IGdldFVpZChmZWF0dXJlKTtcblxuICAgIGlmICghdGhpcy5hZGRUb0luZGV4XyhmZWF0dXJlS2V5LCBmZWF0dXJlKSkge1xuICAgICAgaWYgKHRoaXMuZmVhdHVyZXNDb2xsZWN0aW9uXykge1xuICAgICAgICB0aGlzLmZlYXR1cmVzQ29sbGVjdGlvbl8ucmVtb3ZlKGZlYXR1cmUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuc2V0dXBDaGFuZ2VFdmVudHNfKGZlYXR1cmVLZXksIGZlYXR1cmUpO1xuXG4gICAgY29uc3QgZ2VvbWV0cnkgPSBmZWF0dXJlLmdldEdlb21ldHJ5KCk7XG4gICAgaWYgKGdlb21ldHJ5KSB7XG4gICAgICBjb25zdCBleHRlbnQgPSBnZW9tZXRyeS5nZXRFeHRlbnQoKTtcbiAgICAgIGlmICh0aGlzLmZlYXR1cmVzUnRyZWVfKSB7XG4gICAgICAgIHRoaXMuZmVhdHVyZXNSdHJlZV8uaW5zZXJ0KGV4dGVudCwgZmVhdHVyZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubnVsbEdlb21ldHJ5RmVhdHVyZXNfW2ZlYXR1cmVLZXldID0gZmVhdHVyZTtcbiAgICB9XG5cbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoXG4gICAgICBuZXcgVmVjdG9yU291cmNlRXZlbnQoVmVjdG9yRXZlbnRUeXBlLkFEREZFQVRVUkUsIGZlYXR1cmUpXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZmVhdHVyZUtleSBVbmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIGZlYXR1cmUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0PEdlb21ldHJ5Pn0gZmVhdHVyZSBUaGUgZmVhdHVyZS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHNldHVwQ2hhbmdlRXZlbnRzXyhmZWF0dXJlS2V5LCBmZWF0dXJlKSB7XG4gICAgdGhpcy5mZWF0dXJlQ2hhbmdlS2V5c19bZmVhdHVyZUtleV0gPSBbXG4gICAgICBsaXN0ZW4oZmVhdHVyZSwgRXZlbnRUeXBlLkNIQU5HRSwgdGhpcy5oYW5kbGVGZWF0dXJlQ2hhbmdlXywgdGhpcyksXG4gICAgICBsaXN0ZW4oXG4gICAgICAgIGZlYXR1cmUsXG4gICAgICAgIE9iamVjdEV2ZW50VHlwZS5QUk9QRVJUWUNIQU5HRSxcbiAgICAgICAgdGhpcy5oYW5kbGVGZWF0dXJlQ2hhbmdlXyxcbiAgICAgICAgdGhpc1xuICAgICAgKSxcbiAgICBdO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmZWF0dXJlS2V5IFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgZmVhdHVyZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHQ8R2VvbWV0cnk+fSBmZWF0dXJlIFRoZSBmZWF0dXJlLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUaGUgZmVhdHVyZSBpcyBcInZhbGlkXCIsIGluIHRoZSBzZW5zZSB0aGF0IGl0IGlzIGFsc28gYVxuICAgKiAgICAgY2FuZGlkYXRlIGZvciBpbnNlcnRpb24gaW50byB0aGUgUnRyZWUuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBhZGRUb0luZGV4XyhmZWF0dXJlS2V5LCBmZWF0dXJlKSB7XG4gICAgbGV0IHZhbGlkID0gdHJ1ZTtcbiAgICBjb25zdCBpZCA9IGZlYXR1cmUuZ2V0SWQoKTtcbiAgICBpZiAoaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKCEoaWQudG9TdHJpbmcoKSBpbiB0aGlzLmlkSW5kZXhfKSkge1xuICAgICAgICB0aGlzLmlkSW5kZXhfW2lkLnRvU3RyaW5nKCldID0gZmVhdHVyZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbGlkID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh2YWxpZCkge1xuICAgICAgYXNzZXJ0KFxuICAgICAgICAhKGZlYXR1cmVLZXkgaW4gdGhpcy51aWRJbmRleF8pLFxuICAgICAgICAnVGhlIHBhc3NlZCBgZmVhdHVyZWAgd2FzIGFscmVhZHkgYWRkZWQgdG8gdGhlIHNvdXJjZSdcbiAgICAgICk7XG4gICAgICB0aGlzLnVpZEluZGV4X1tmZWF0dXJlS2V5XSA9IGZlYXR1cmU7XG4gICAgfVxuICAgIHJldHVybiB2YWxpZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYSBiYXRjaCBvZiBmZWF0dXJlcyB0byB0aGUgc291cmNlLlxuICAgKiBAcGFyYW0ge0FycmF5PGltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdDxHZW9tZXRyeT4+fSBmZWF0dXJlcyBGZWF0dXJlcyB0byBhZGQuXG4gICAqIEBhcGlcbiAgICovXG4gIGFkZEZlYXR1cmVzKGZlYXR1cmVzKSB7XG4gICAgdGhpcy5hZGRGZWF0dXJlc0ludGVybmFsKGZlYXR1cmVzKTtcbiAgICB0aGlzLmNoYW5nZWQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgZmVhdHVyZXMgd2l0aG91dCBmaXJpbmcgYSBgY2hhbmdlYCBldmVudC5cbiAgICogQHBhcmFtIHtBcnJheTxpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHQ8R2VvbWV0cnk+Pn0gZmVhdHVyZXMgRmVhdHVyZXMuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIGFkZEZlYXR1cmVzSW50ZXJuYWwoZmVhdHVyZXMpIHtcbiAgICBjb25zdCBleHRlbnRzID0gW107XG4gICAgY29uc3QgbmV3RmVhdHVyZXMgPSBbXTtcbiAgICBjb25zdCBnZW9tZXRyeUZlYXR1cmVzID0gW107XG5cbiAgICBmb3IgKGxldCBpID0gMCwgbGVuZ3RoID0gZmVhdHVyZXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGZlYXR1cmUgPSBmZWF0dXJlc1tpXTtcbiAgICAgIGNvbnN0IGZlYXR1cmVLZXkgPSBnZXRVaWQoZmVhdHVyZSk7XG4gICAgICBpZiAodGhpcy5hZGRUb0luZGV4XyhmZWF0dXJlS2V5LCBmZWF0dXJlKSkge1xuICAgICAgICBuZXdGZWF0dXJlcy5wdXNoKGZlYXR1cmUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSAwLCBsZW5ndGggPSBuZXdGZWF0dXJlcy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgZmVhdHVyZSA9IG5ld0ZlYXR1cmVzW2ldO1xuICAgICAgY29uc3QgZmVhdHVyZUtleSA9IGdldFVpZChmZWF0dXJlKTtcbiAgICAgIHRoaXMuc2V0dXBDaGFuZ2VFdmVudHNfKGZlYXR1cmVLZXksIGZlYXR1cmUpO1xuXG4gICAgICBjb25zdCBnZW9tZXRyeSA9IGZlYXR1cmUuZ2V0R2VvbWV0cnkoKTtcbiAgICAgIGlmIChnZW9tZXRyeSkge1xuICAgICAgICBjb25zdCBleHRlbnQgPSBnZW9tZXRyeS5nZXRFeHRlbnQoKTtcbiAgICAgICAgZXh0ZW50cy5wdXNoKGV4dGVudCk7XG4gICAgICAgIGdlb21ldHJ5RmVhdHVyZXMucHVzaChmZWF0dXJlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubnVsbEdlb21ldHJ5RmVhdHVyZXNfW2ZlYXR1cmVLZXldID0gZmVhdHVyZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMuZmVhdHVyZXNSdHJlZV8pIHtcbiAgICAgIHRoaXMuZmVhdHVyZXNSdHJlZV8ubG9hZChleHRlbnRzLCBnZW9tZXRyeUZlYXR1cmVzKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5oYXNMaXN0ZW5lcihWZWN0b3JFdmVudFR5cGUuQURERkVBVFVSRSkpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBsZW5ndGggPSBuZXdGZWF0dXJlcy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoXG4gICAgICAgICAgbmV3IFZlY3RvclNvdXJjZUV2ZW50KFZlY3RvckV2ZW50VHlwZS5BRERGRUFUVVJFLCBuZXdGZWF0dXJlc1tpXSlcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHshQ29sbGVjdGlvbjxpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHQ8R2VvbWV0cnk+Pn0gY29sbGVjdGlvbiBDb2xsZWN0aW9uLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYmluZEZlYXR1cmVzQ29sbGVjdGlvbl8oY29sbGVjdGlvbikge1xuICAgIGxldCBtb2RpZnlpbmdDb2xsZWN0aW9uID0gZmFsc2U7XG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgVmVjdG9yRXZlbnRUeXBlLkFEREZFQVRVUkUsXG4gICAgICAvKipcbiAgICAgICAqIEBwYXJhbSB7VmVjdG9yU291cmNlRXZlbnQ8R2VvbWV0cnk+fSBldnQgVGhlIHZlY3RvciBzb3VyY2UgZXZlbnRcbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICBpZiAoIW1vZGlmeWluZ0NvbGxlY3Rpb24pIHtcbiAgICAgICAgICBtb2RpZnlpbmdDb2xsZWN0aW9uID0gdHJ1ZTtcbiAgICAgICAgICBjb2xsZWN0aW9uLnB1c2goZXZ0LmZlYXR1cmUpO1xuICAgICAgICAgIG1vZGlmeWluZ0NvbGxlY3Rpb24gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICk7XG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgVmVjdG9yRXZlbnRUeXBlLlJFTU9WRUZFQVRVUkUsXG4gICAgICAvKipcbiAgICAgICAqIEBwYXJhbSB7VmVjdG9yU291cmNlRXZlbnQ8R2VvbWV0cnk+fSBldnQgVGhlIHZlY3RvciBzb3VyY2UgZXZlbnRcbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICBpZiAoIW1vZGlmeWluZ0NvbGxlY3Rpb24pIHtcbiAgICAgICAgICBtb2RpZnlpbmdDb2xsZWN0aW9uID0gdHJ1ZTtcbiAgICAgICAgICBjb2xsZWN0aW9uLnJlbW92ZShldnQuZmVhdHVyZSk7XG4gICAgICAgICAgbW9kaWZ5aW5nQ29sbGVjdGlvbiA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgKTtcbiAgICBjb2xsZWN0aW9uLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICBDb2xsZWN0aW9uRXZlbnRUeXBlLkFERCxcbiAgICAgIC8qKlxuICAgICAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9Db2xsZWN0aW9uLmpzXCIpLkNvbGxlY3Rpb25FdmVudDxpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHQ8R2VvbWV0cnk+Pn0gZXZ0IFRoZSBjb2xsZWN0aW9uIGV2ZW50XG4gICAgICAgKi9cbiAgICAgIChldnQpID0+IHtcbiAgICAgICAgaWYgKCFtb2RpZnlpbmdDb2xsZWN0aW9uKSB7XG4gICAgICAgICAgbW9kaWZ5aW5nQ29sbGVjdGlvbiA9IHRydWU7XG4gICAgICAgICAgdGhpcy5hZGRGZWF0dXJlKGV2dC5lbGVtZW50KTtcbiAgICAgICAgICBtb2RpZnlpbmdDb2xsZWN0aW9uID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICApO1xuICAgIGNvbGxlY3Rpb24uYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgIENvbGxlY3Rpb25FdmVudFR5cGUuUkVNT1ZFLFxuICAgICAgLyoqXG4gICAgICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL0NvbGxlY3Rpb24uanNcIikuQ29sbGVjdGlvbkV2ZW50PGltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdDxHZW9tZXRyeT4+fSBldnQgVGhlIGNvbGxlY3Rpb24gZXZlbnRcbiAgICAgICAqL1xuICAgICAgKGV2dCkgPT4ge1xuICAgICAgICBpZiAoIW1vZGlmeWluZ0NvbGxlY3Rpb24pIHtcbiAgICAgICAgICBtb2RpZnlpbmdDb2xsZWN0aW9uID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLnJlbW92ZUZlYXR1cmUoZXZ0LmVsZW1lbnQpO1xuICAgICAgICAgIG1vZGlmeWluZ0NvbGxlY3Rpb24gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICk7XG4gICAgdGhpcy5mZWF0dXJlc0NvbGxlY3Rpb25fID0gY29sbGVjdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYWxsIGZlYXR1cmVzIGZyb20gdGhlIHNvdXJjZS5cbiAgICogQHBhcmFtIHtib29sZWFufSBbZmFzdF0gU2tpcCBkaXNwYXRjaGluZyBvZiB7QGxpbmsgbW9kdWxlOm9sL3NvdXJjZS9WZWN0b3IuVmVjdG9yU291cmNlRXZlbnQjZXZlbnQ6cmVtb3ZlZmVhdHVyZX0gZXZlbnRzLlxuICAgKiBAYXBpXG4gICAqL1xuICBjbGVhcihmYXN0KSB7XG4gICAgaWYgKGZhc3QpIHtcbiAgICAgIGZvciAoY29uc3QgZmVhdHVyZUlkIGluIHRoaXMuZmVhdHVyZUNoYW5nZUtleXNfKSB7XG4gICAgICAgIGNvbnN0IGtleXMgPSB0aGlzLmZlYXR1cmVDaGFuZ2VLZXlzX1tmZWF0dXJlSWRdO1xuICAgICAgICBrZXlzLmZvckVhY2godW5saXN0ZW5CeUtleSk7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuZmVhdHVyZXNDb2xsZWN0aW9uXykge1xuICAgICAgICB0aGlzLmZlYXR1cmVDaGFuZ2VLZXlzXyA9IHt9O1xuICAgICAgICB0aGlzLmlkSW5kZXhfID0ge307XG4gICAgICAgIHRoaXMudWlkSW5kZXhfID0ge307XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0aGlzLmZlYXR1cmVzUnRyZWVfKSB7XG4gICAgICAgIGNvbnN0IHJlbW92ZUFuZElnbm9yZVJldHVybiA9IChmZWF0dXJlKSA9PiB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVGZWF0dXJlSW50ZXJuYWwoZmVhdHVyZSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZmVhdHVyZXNSdHJlZV8uZm9yRWFjaChyZW1vdmVBbmRJZ25vcmVSZXR1cm4pO1xuICAgICAgICBmb3IgKGNvbnN0IGlkIGluIHRoaXMubnVsbEdlb21ldHJ5RmVhdHVyZXNfKSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVGZWF0dXJlSW50ZXJuYWwodGhpcy5udWxsR2VvbWV0cnlGZWF0dXJlc19baWRdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5mZWF0dXJlc0NvbGxlY3Rpb25fKSB7XG4gICAgICB0aGlzLmZlYXR1cmVzQ29sbGVjdGlvbl8uY2xlYXIoKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5mZWF0dXJlc1J0cmVlXykge1xuICAgICAgdGhpcy5mZWF0dXJlc1J0cmVlXy5jbGVhcigpO1xuICAgIH1cbiAgICB0aGlzLm51bGxHZW9tZXRyeUZlYXR1cmVzXyA9IHt9O1xuXG4gICAgY29uc3QgY2xlYXJFdmVudCA9IG5ldyBWZWN0b3JTb3VyY2VFdmVudChWZWN0b3JFdmVudFR5cGUuQ0xFQVIpO1xuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChjbGVhckV2ZW50KTtcbiAgICB0aGlzLmNoYW5nZWQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJdGVyYXRlIHRocm91Z2ggYWxsIGZlYXR1cmVzIG9uIHRoZSBzb3VyY2UsIGNhbGxpbmcgdGhlIHByb3ZpZGVkIGNhbGxiYWNrXG4gICAqIHdpdGggZWFjaCBvbmUuICBJZiB0aGUgY2FsbGJhY2sgcmV0dXJucyBhbnkgXCJ0cnV0aHlcIiB2YWx1ZSwgaXRlcmF0aW9uIHdpbGxcbiAgICogc3RvcCBhbmQgdGhlIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIHRoZSBzYW1lIHZhbHVlLlxuICAgKiBOb3RlOiB0aGlzIGZ1bmN0aW9uIG9ubHkgaXRlcmF0ZSB0aHJvdWdoIHRoZSBmZWF0dXJlIHRoYXQgaGF2ZSBhIGRlZmluZWQgZ2VvbWV0cnkuXG4gICAqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oaW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0PEdlb21ldHJ5Pik6IFR9IGNhbGxiYWNrIENhbGxlZCB3aXRoIGVhY2ggZmVhdHVyZVxuICAgKiAgICAgb24gdGhlIHNvdXJjZS4gIFJldHVybiBhIHRydXRoeSB2YWx1ZSB0byBzdG9wIGl0ZXJhdGlvbi5cbiAgICogQHJldHVybiB7VHx1bmRlZmluZWR9IFRoZSByZXR1cm4gdmFsdWUgZnJvbSB0aGUgbGFzdCBjYWxsIHRvIHRoZSBjYWxsYmFjay5cbiAgICogQHRlbXBsYXRlIFRcbiAgICogQGFwaVxuICAgKi9cbiAgZm9yRWFjaEZlYXR1cmUoY2FsbGJhY2spIHtcbiAgICBpZiAodGhpcy5mZWF0dXJlc1J0cmVlXykge1xuICAgICAgcmV0dXJuIHRoaXMuZmVhdHVyZXNSdHJlZV8uZm9yRWFjaChjYWxsYmFjayk7XG4gICAgfVxuICAgIGlmICh0aGlzLmZlYXR1cmVzQ29sbGVjdGlvbl8pIHtcbiAgICAgIHRoaXMuZmVhdHVyZXNDb2xsZWN0aW9uXy5mb3JFYWNoKGNhbGxiYWNrKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSXRlcmF0ZSB0aHJvdWdoIGFsbCBmZWF0dXJlcyB3aG9zZSBnZW9tZXRyaWVzIGNvbnRhaW4gdGhlIHByb3ZpZGVkXG4gICAqIGNvb3JkaW5hdGUsIGNhbGxpbmcgdGhlIGNhbGxiYWNrIHdpdGggZWFjaCBmZWF0dXJlLiAgSWYgdGhlIGNhbGxiYWNrIHJldHVybnNcbiAgICogYSBcInRydXRoeVwiIHZhbHVlLCBpdGVyYXRpb24gd2lsbCBzdG9wIGFuZCB0aGUgZnVuY3Rpb24gd2lsbCByZXR1cm4gdGhlIHNhbWVcbiAgICogdmFsdWUuXG4gICAqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBjb29yZGluYXRlIENvb3JkaW5hdGUuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oaW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0PEdlb21ldHJ5Pik6IFR9IGNhbGxiYWNrIENhbGxlZCB3aXRoIGVhY2ggZmVhdHVyZVxuICAgKiAgICAgd2hvc2UgZ29lbWV0cnkgY29udGFpbnMgdGhlIHByb3ZpZGVkIGNvb3JkaW5hdGUuXG4gICAqIEByZXR1cm4ge1R8dW5kZWZpbmVkfSBUaGUgcmV0dXJuIHZhbHVlIGZyb20gdGhlIGxhc3QgY2FsbCB0byB0aGUgY2FsbGJhY2suXG4gICAqIEB0ZW1wbGF0ZSBUXG4gICAqL1xuICBmb3JFYWNoRmVhdHVyZUF0Q29vcmRpbmF0ZURpcmVjdChjb29yZGluYXRlLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IGV4dGVudCA9IFtjb29yZGluYXRlWzBdLCBjb29yZGluYXRlWzFdLCBjb29yZGluYXRlWzBdLCBjb29yZGluYXRlWzFdXTtcbiAgICByZXR1cm4gdGhpcy5mb3JFYWNoRmVhdHVyZUluRXh0ZW50KGV4dGVudCwgZnVuY3Rpb24gKGZlYXR1cmUpIHtcbiAgICAgIGNvbnN0IGdlb21ldHJ5ID0gZmVhdHVyZS5nZXRHZW9tZXRyeSgpO1xuICAgICAgaWYgKGdlb21ldHJ5LmludGVyc2VjdHNDb29yZGluYXRlKGNvb3JkaW5hdGUpKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhmZWF0dXJlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogSXRlcmF0ZSB0aHJvdWdoIGFsbCBmZWF0dXJlcyB3aG9zZSBib3VuZGluZyBib3ggaW50ZXJzZWN0cyB0aGUgcHJvdmlkZWRcbiAgICogZXh0ZW50IChub3RlIHRoYXQgdGhlIGZlYXR1cmUncyBnZW9tZXRyeSBtYXkgbm90IGludGVyc2VjdCB0aGUgZXh0ZW50KSxcbiAgICogY2FsbGluZyB0aGUgY2FsbGJhY2sgd2l0aCBlYWNoIGZlYXR1cmUuICBJZiB0aGUgY2FsbGJhY2sgcmV0dXJucyBhIFwidHJ1dGh5XCJcbiAgICogdmFsdWUsIGl0ZXJhdGlvbiB3aWxsIHN0b3AgYW5kIHRoZSBmdW5jdGlvbiB3aWxsIHJldHVybiB0aGUgc2FtZSB2YWx1ZS5cbiAgICpcbiAgICogSWYgeW91IGFyZSBpbnRlcmVzdGVkIGluIGZlYXR1cmVzIHdob3NlIGdlb21ldHJ5IGludGVyc2VjdHMgYW4gZXh0ZW50LCBjYWxsXG4gICAqIHRoZSB7QGxpbmsgbW9kdWxlOm9sL3NvdXJjZS9WZWN0b3J+VmVjdG9yU291cmNlI2ZvckVhY2hGZWF0dXJlSW50ZXJzZWN0aW5nRXh0ZW50ICNmb3JFYWNoRmVhdHVyZUludGVyc2VjdGluZ0V4dGVudCgpfSBtZXRob2QgaW5zdGVhZC5cbiAgICpcbiAgICogV2hlbiBgdXNlU3BhdGlhbEluZGV4YCBpcyBzZXQgdG8gZmFsc2UsIHRoaXMgbWV0aG9kIHdpbGwgbG9vcCB0aHJvdWdoIGFsbFxuICAgKiBmZWF0dXJlcywgZXF1aXZhbGVudCB0byB7QGxpbmsgbW9kdWxlOm9sL3NvdXJjZS9WZWN0b3J+VmVjdG9yU291cmNlI2ZvckVhY2hGZWF0dXJlICNmb3JFYWNoRmVhdHVyZSgpfS5cbiAgICpcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKGltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdDxHZW9tZXRyeT4pOiBUfSBjYWxsYmFjayBDYWxsZWQgd2l0aCBlYWNoIGZlYXR1cmVcbiAgICogICAgIHdob3NlIGJvdW5kaW5nIGJveCBpbnRlcnNlY3RzIHRoZSBwcm92aWRlZCBleHRlbnQuXG4gICAqIEByZXR1cm4ge1R8dW5kZWZpbmVkfSBUaGUgcmV0dXJuIHZhbHVlIGZyb20gdGhlIGxhc3QgY2FsbCB0byB0aGUgY2FsbGJhY2suXG4gICAqIEB0ZW1wbGF0ZSBUXG4gICAqIEBhcGlcbiAgICovXG4gIGZvckVhY2hGZWF0dXJlSW5FeHRlbnQoZXh0ZW50LCBjYWxsYmFjaykge1xuICAgIGlmICh0aGlzLmZlYXR1cmVzUnRyZWVfKSB7XG4gICAgICByZXR1cm4gdGhpcy5mZWF0dXJlc1J0cmVlXy5mb3JFYWNoSW5FeHRlbnQoZXh0ZW50LCBjYWxsYmFjayk7XG4gICAgfVxuICAgIGlmICh0aGlzLmZlYXR1cmVzQ29sbGVjdGlvbl8pIHtcbiAgICAgIHRoaXMuZmVhdHVyZXNDb2xsZWN0aW9uXy5mb3JFYWNoKGNhbGxiYWNrKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSXRlcmF0ZSB0aHJvdWdoIGFsbCBmZWF0dXJlcyB3aG9zZSBnZW9tZXRyeSBpbnRlcnNlY3RzIHRoZSBwcm92aWRlZCBleHRlbnQsXG4gICAqIGNhbGxpbmcgdGhlIGNhbGxiYWNrIHdpdGggZWFjaCBmZWF0dXJlLiAgSWYgdGhlIGNhbGxiYWNrIHJldHVybnMgYSBcInRydXRoeVwiXG4gICAqIHZhbHVlLCBpdGVyYXRpb24gd2lsbCBzdG9wIGFuZCB0aGUgZnVuY3Rpb24gd2lsbCByZXR1cm4gdGhlIHNhbWUgdmFsdWUuXG4gICAqXG4gICAqIElmIHlvdSBvbmx5IHdhbnQgdG8gdGVzdCBmb3IgYm91bmRpbmcgYm94IGludGVyc2VjdGlvbiwgY2FsbCB0aGVcbiAgICoge0BsaW5rIG1vZHVsZTpvbC9zb3VyY2UvVmVjdG9yflZlY3RvclNvdXJjZSNmb3JFYWNoRmVhdHVyZUluRXh0ZW50ICNmb3JFYWNoRmVhdHVyZUluRXh0ZW50KCl9IG1ldGhvZCBpbnN0ZWFkLlxuICAgKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oaW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0PEdlb21ldHJ5Pik6IFR9IGNhbGxiYWNrIENhbGxlZCB3aXRoIGVhY2ggZmVhdHVyZVxuICAgKiAgICAgd2hvc2UgZ2VvbWV0cnkgaW50ZXJzZWN0cyB0aGUgcHJvdmlkZWQgZXh0ZW50LlxuICAgKiBAcmV0dXJuIHtUfHVuZGVmaW5lZH0gVGhlIHJldHVybiB2YWx1ZSBmcm9tIHRoZSBsYXN0IGNhbGwgdG8gdGhlIGNhbGxiYWNrLlxuICAgKiBAdGVtcGxhdGUgVFxuICAgKiBAYXBpXG4gICAqL1xuICBmb3JFYWNoRmVhdHVyZUludGVyc2VjdGluZ0V4dGVudChleHRlbnQsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHRoaXMuZm9yRWFjaEZlYXR1cmVJbkV4dGVudChcbiAgICAgIGV4dGVudCxcbiAgICAgIC8qKlxuICAgICAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHQ8R2VvbWV0cnk+fSBmZWF0dXJlIEZlYXR1cmUuXG4gICAgICAgKiBAcmV0dXJuIHtUfHVuZGVmaW5lZH0gVGhlIHJldHVybiB2YWx1ZSBmcm9tIHRoZSBsYXN0IGNhbGwgdG8gdGhlIGNhbGxiYWNrLlxuICAgICAgICovXG4gICAgICBmdW5jdGlvbiAoZmVhdHVyZSkge1xuICAgICAgICBjb25zdCBnZW9tZXRyeSA9IGZlYXR1cmUuZ2V0R2VvbWV0cnkoKTtcbiAgICAgICAgaWYgKGdlb21ldHJ5LmludGVyc2VjdHNFeHRlbnQoZXh0ZW50KSkge1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGNhbGxiYWNrKGZlYXR1cmUpO1xuICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGZlYXR1cmVzIGNvbGxlY3Rpb24gYXNzb2NpYXRlZCB3aXRoIHRoaXMgc291cmNlLiBXaWxsIGJlIGBudWxsYFxuICAgKiB1bmxlc3MgdGhlIHNvdXJjZSB3YXMgY29uZmlndXJlZCB3aXRoIGB1c2VTcGF0aWFsSW5kZXhgIHNldCB0byBgZmFsc2VgLCBvclxuICAgKiB3aXRoIGFuIHtAbGluayBtb2R1bGU6b2wvQ29sbGVjdGlvbn5Db2xsZWN0aW9ufSBhcyBgZmVhdHVyZXNgLlxuICAgKiBAcmV0dXJuIHtDb2xsZWN0aW9uPGltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdDxHZW9tZXRyeT4+fG51bGx9IFRoZSBjb2xsZWN0aW9uIG9mIGZlYXR1cmVzLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRGZWF0dXJlc0NvbGxlY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZmVhdHVyZXNDb2xsZWN0aW9uXztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYSBzbmFwc2hvdCBvZiB0aGUgZmVhdHVyZXMgY3VycmVudGx5IG9uIHRoZSBzb3VyY2UgaW4gcmFuZG9tIG9yZGVyLiBUaGUgcmV0dXJuZWQgYXJyYXlcbiAgICogaXMgYSBjb3B5LCB0aGUgZmVhdHVyZXMgYXJlIHJlZmVyZW5jZXMgdG8gdGhlIGZlYXR1cmVzIGluIHRoZSBzb3VyY2UuXG4gICAqIEByZXR1cm4ge0FycmF5PGltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdDxHZW9tZXRyeT4+fSBGZWF0dXJlcy5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0RmVhdHVyZXMoKSB7XG4gICAgbGV0IGZlYXR1cmVzO1xuICAgIGlmICh0aGlzLmZlYXR1cmVzQ29sbGVjdGlvbl8pIHtcbiAgICAgIGZlYXR1cmVzID0gdGhpcy5mZWF0dXJlc0NvbGxlY3Rpb25fLmdldEFycmF5KCkuc2xpY2UoMCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmZlYXR1cmVzUnRyZWVfKSB7XG4gICAgICBmZWF0dXJlcyA9IHRoaXMuZmVhdHVyZXNSdHJlZV8uZ2V0QWxsKCk7XG4gICAgICBpZiAoIWlzRW1wdHkodGhpcy5udWxsR2VvbWV0cnlGZWF0dXJlc18pKSB7XG4gICAgICAgIGV4dGVuZChmZWF0dXJlcywgT2JqZWN0LnZhbHVlcyh0aGlzLm51bGxHZW9tZXRyeUZlYXR1cmVzXykpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLyoqIEB0eXBlIHtBcnJheTxpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHQ8R2VvbWV0cnk+Pn0gKi8gKFxuICAgICAgZmVhdHVyZXNcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhbGwgZmVhdHVyZXMgd2hvc2UgZ2VvbWV0cnkgaW50ZXJzZWN0cyB0aGUgcHJvdmlkZWQgY29vcmRpbmF0ZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGNvb3JkaW5hdGUgQ29vcmRpbmF0ZS5cbiAgICogQHJldHVybiB7QXJyYXk8aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0PEdlb21ldHJ5Pj59IEZlYXR1cmVzLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRGZWF0dXJlc0F0Q29vcmRpbmF0ZShjb29yZGluYXRlKSB7XG4gICAgY29uc3QgZmVhdHVyZXMgPSBbXTtcbiAgICB0aGlzLmZvckVhY2hGZWF0dXJlQXRDb29yZGluYXRlRGlyZWN0KGNvb3JkaW5hdGUsIGZ1bmN0aW9uIChmZWF0dXJlKSB7XG4gICAgICBmZWF0dXJlcy5wdXNoKGZlYXR1cmUpO1xuICAgIH0pO1xuICAgIHJldHVybiBmZWF0dXJlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYWxsIGZlYXR1cmVzIHdob3NlIGJvdW5kaW5nIGJveCBpbnRlcnNlY3RzIHRoZSBwcm92aWRlZCBleHRlbnQuICBOb3RlIHRoYXQgdGhpcyByZXR1cm5zIGFuIGFycmF5IG9mXG4gICAqIGFsbCBmZWF0dXJlcyBpbnRlcnNlY3RpbmcgdGhlIGdpdmVuIGV4dGVudCBpbiByYW5kb20gb3JkZXIgKHNvIGl0IG1heSBpbmNsdWRlXG4gICAqIGZlYXR1cmVzIHdob3NlIGdlb21ldHJpZXMgZG8gbm90IGludGVyc2VjdCB0aGUgZXh0ZW50KS5cbiAgICpcbiAgICogV2hlbiBgdXNlU3BhdGlhbEluZGV4YCBpcyBzZXQgdG8gZmFsc2UsIHRoaXMgbWV0aG9kIHdpbGwgcmV0dXJuIGFsbFxuICAgKiBmZWF0dXJlcy5cbiAgICpcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3Byb2ovUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0fSBbcHJvamVjdGlvbl0gSW5jbHVkZSBmZWF0dXJlc1xuICAgKiB3aGVyZSBgZXh0ZW50YCBleGNlZWRzIHRoZSB4LWF4aXMgYm91bmRzIG9mIGBwcm9qZWN0aW9uYCBhbmQgd3JhcHMgYXJvdW5kIHRoZSB3b3JsZC5cbiAgICogQHJldHVybiB7QXJyYXk8aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0PEdlb21ldHJ5Pj59IEZlYXR1cmVzLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRGZWF0dXJlc0luRXh0ZW50KGV4dGVudCwgcHJvamVjdGlvbikge1xuICAgIGlmICh0aGlzLmZlYXR1cmVzUnRyZWVfKSB7XG4gICAgICBjb25zdCBtdWx0aVdvcmxkID0gcHJvamVjdGlvbiAmJiBwcm9qZWN0aW9uLmNhbldyYXBYKCkgJiYgdGhpcy5nZXRXcmFwWCgpO1xuXG4gICAgICBpZiAoIW11bHRpV29ybGQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmVhdHVyZXNSdHJlZV8uZ2V0SW5FeHRlbnQoZXh0ZW50KTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZXh0ZW50cyA9IHdyYXBBbmRTbGljZVgoZXh0ZW50LCBwcm9qZWN0aW9uKTtcblxuICAgICAgcmV0dXJuIFtdLmNvbmNhdChcbiAgICAgICAgLi4uZXh0ZW50cy5tYXAoKGFuRXh0ZW50KSA9PiB0aGlzLmZlYXR1cmVzUnRyZWVfLmdldEluRXh0ZW50KGFuRXh0ZW50KSlcbiAgICAgICk7XG4gICAgfVxuICAgIGlmICh0aGlzLmZlYXR1cmVzQ29sbGVjdGlvbl8pIHtcbiAgICAgIHJldHVybiB0aGlzLmZlYXR1cmVzQ29sbGVjdGlvbl8uZ2V0QXJyYXkoKS5zbGljZSgwKTtcbiAgICB9XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgY2xvc2VzdCBmZWF0dXJlIHRvIHRoZSBwcm92aWRlZCBjb29yZGluYXRlLlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBpcyBub3QgYXZhaWxhYmxlIHdoZW4gdGhlIHNvdXJjZSBpcyBjb25maWd1cmVkIHdpdGhcbiAgICogYHVzZVNwYXRpYWxJbmRleGAgc2V0IHRvIGBmYWxzZWAuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBjb29yZGluYXRlIENvb3JkaW5hdGUuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oaW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0PEdlb21ldHJ5Pik6Ym9vbGVhbn0gW2ZpbHRlcl0gRmVhdHVyZSBmaWx0ZXIgZnVuY3Rpb24uXG4gICAqICAgICBUaGUgZmlsdGVyIGZ1bmN0aW9uIHdpbGwgcmVjZWl2ZSBvbmUgYXJndW1lbnQsIHRoZSB7QGxpbmsgbW9kdWxlOm9sL0ZlYXR1cmV+RmVhdHVyZSBmZWF0dXJlfVxuICAgKiAgICAgYW5kIGl0IHNob3VsZCByZXR1cm4gYSBib29sZWFuIHZhbHVlLiBCeSBkZWZhdWx0LCBubyBmaWx0ZXJpbmcgaXMgbWFkZS5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0PEdlb21ldHJ5Pn0gQ2xvc2VzdCBmZWF0dXJlLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRDbG9zZXN0RmVhdHVyZVRvQ29vcmRpbmF0ZShjb29yZGluYXRlLCBmaWx0ZXIpIHtcbiAgICAvLyBGaW5kIHRoZSBjbG9zZXN0IGZlYXR1cmUgdXNpbmcgYnJhbmNoIGFuZCBib3VuZC4gIFdlIHN0YXJ0IHNlYXJjaGluZyBhblxuICAgIC8vIGluZmluaXRlIGV4dGVudCwgYW5kIGZpbmQgdGhlIGRpc3RhbmNlIGZyb20gdGhlIGZpcnN0IGZlYXR1cmUgZm91bmQuICBUaGlzXG4gICAgLy8gYmVjb21lcyB0aGUgY2xvc2VzdCBmZWF0dXJlLiAgV2UgdGhlbiBjb21wdXRlIGEgc21hbGxlciBleHRlbnQgd2hpY2ggYW55XG4gICAgLy8gY2xvc2VyIGZlYXR1cmUgbXVzdCBpbnRlcnNlY3QuICBXZSBjb250aW51ZSBzZWFyY2hpbmcgd2l0aCB0aGlzIHNtYWxsZXJcbiAgICAvLyBleHRlbnQsIHRyeWluZyB0byBmaW5kIGEgY2xvc2VyIGZlYXR1cmUuICBFdmVyeSB0aW1lIHdlIGZpbmQgYSBjbG9zZXJcbiAgICAvLyBmZWF0dXJlLCB3ZSB1cGRhdGUgdGhlIGV4dGVudCBiZWluZyBzZWFyY2hlZCBzbyB0aGF0IGFueSBldmVuIGNsb3NlclxuICAgIC8vIGZlYXR1cmUgbXVzdCBpbnRlcnNlY3QgaXQuICBXZSBjb250aW51ZSB1bnRpbCB3ZSBydW4gb3V0IG9mIGZlYXR1cmVzLlxuICAgIGNvbnN0IHggPSBjb29yZGluYXRlWzBdO1xuICAgIGNvbnN0IHkgPSBjb29yZGluYXRlWzFdO1xuICAgIGxldCBjbG9zZXN0RmVhdHVyZSA9IG51bGw7XG4gICAgY29uc3QgY2xvc2VzdFBvaW50ID0gW05hTiwgTmFOXTtcbiAgICBsZXQgbWluU3F1YXJlZERpc3RhbmNlID0gSW5maW5pdHk7XG4gICAgY29uc3QgZXh0ZW50ID0gWy1JbmZpbml0eSwgLUluZmluaXR5LCBJbmZpbml0eSwgSW5maW5pdHldO1xuICAgIGZpbHRlciA9IGZpbHRlciA/IGZpbHRlciA6IFRSVUU7XG4gICAgdGhpcy5mZWF0dXJlc1J0cmVlXy5mb3JFYWNoSW5FeHRlbnQoXG4gICAgICBleHRlbnQsXG4gICAgICAvKipcbiAgICAgICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0PEdlb21ldHJ5Pn0gZmVhdHVyZSBGZWF0dXJlLlxuICAgICAgICovXG4gICAgICBmdW5jdGlvbiAoZmVhdHVyZSkge1xuICAgICAgICBpZiAoZmlsdGVyKGZlYXR1cmUpKSB7XG4gICAgICAgICAgY29uc3QgZ2VvbWV0cnkgPSBmZWF0dXJlLmdldEdlb21ldHJ5KCk7XG4gICAgICAgICAgY29uc3QgcHJldmlvdXNNaW5TcXVhcmVkRGlzdGFuY2UgPSBtaW5TcXVhcmVkRGlzdGFuY2U7XG4gICAgICAgICAgbWluU3F1YXJlZERpc3RhbmNlID0gZ2VvbWV0cnkuY2xvc2VzdFBvaW50WFkoXG4gICAgICAgICAgICB4LFxuICAgICAgICAgICAgeSxcbiAgICAgICAgICAgIGNsb3Nlc3RQb2ludCxcbiAgICAgICAgICAgIG1pblNxdWFyZWREaXN0YW5jZVxuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKG1pblNxdWFyZWREaXN0YW5jZSA8IHByZXZpb3VzTWluU3F1YXJlZERpc3RhbmNlKSB7XG4gICAgICAgICAgICBjbG9zZXN0RmVhdHVyZSA9IGZlYXR1cmU7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIHNuZWFreS4gIFJlZHVjZSB0aGUgZXh0ZW50IHRoYXQgaXQgaXMgY3VycmVudGx5IGJlaW5nXG4gICAgICAgICAgICAvLyBzZWFyY2hlZCB3aGlsZSB0aGUgUi1UcmVlIHRyYXZlcnNhbCB1c2luZyB0aGlzIHNhbWUgZXh0ZW50IG9iamVjdFxuICAgICAgICAgICAgLy8gaXMgc3RpbGwgaW4gcHJvZ3Jlc3MuICBUaGlzIGlzIHNhZmUgYmVjYXVzZSB0aGUgbmV3IGV4dGVudCBpc1xuICAgICAgICAgICAgLy8gc3RyaWN0bHkgY29udGFpbmVkIGJ5IHRoZSBvbGQgZXh0ZW50LlxuICAgICAgICAgICAgY29uc3QgbWluRGlzdGFuY2UgPSBNYXRoLnNxcnQobWluU3F1YXJlZERpc3RhbmNlKTtcbiAgICAgICAgICAgIGV4dGVudFswXSA9IHggLSBtaW5EaXN0YW5jZTtcbiAgICAgICAgICAgIGV4dGVudFsxXSA9IHkgLSBtaW5EaXN0YW5jZTtcbiAgICAgICAgICAgIGV4dGVudFsyXSA9IHggKyBtaW5EaXN0YW5jZTtcbiAgICAgICAgICAgIGV4dGVudFszXSA9IHkgKyBtaW5EaXN0YW5jZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICApO1xuICAgIHJldHVybiBjbG9zZXN0RmVhdHVyZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGV4dGVudCBvZiB0aGUgZmVhdHVyZXMgY3VycmVudGx5IGluIHRoZSBzb3VyY2UuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIGlzIG5vdCBhdmFpbGFibGUgd2hlbiB0aGUgc291cmNlIGlzIGNvbmZpZ3VyZWQgd2l0aFxuICAgKiBgdXNlU3BhdGlhbEluZGV4YCBzZXQgdG8gYGZhbHNlYC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fSBbZXh0ZW50XSBEZXN0aW5hdGlvbiBleHRlbnQuIElmIHByb3ZpZGVkLCBubyBuZXcgZXh0ZW50XG4gICAqICAgICB3aWxsIGJlIGNyZWF0ZWQuIEluc3RlYWQsIHRoYXQgZXh0ZW50J3MgY29vcmRpbmF0ZXMgd2lsbCBiZSBvdmVyd3JpdHRlbi5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gRXh0ZW50LlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRFeHRlbnQoZXh0ZW50KSB7XG4gICAgcmV0dXJuIHRoaXMuZmVhdHVyZXNSdHJlZV8uZ2V0RXh0ZW50KGV4dGVudCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGEgZmVhdHVyZSBieSBpdHMgaWRlbnRpZmllciAodGhlIHZhbHVlIHJldHVybmVkIGJ5IGZlYXR1cmUuZ2V0SWQoKSkuXG4gICAqIE5vdGUgdGhhdCB0aGUgaW5kZXggdHJlYXRzIHN0cmluZyBhbmQgbnVtZXJpYyBpZGVudGlmaWVycyBhcyB0aGUgc2FtZS4gIFNvXG4gICAqIGBzb3VyY2UuZ2V0RmVhdHVyZUJ5SWQoMilgIHdpbGwgcmV0dXJuIGEgZmVhdHVyZSB3aXRoIGlkIGAnMidgIG9yIGAyYC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBpZCBGZWF0dXJlIGlkZW50aWZpZXIuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdDxHZW9tZXRyeT58bnVsbH0gVGhlIGZlYXR1cmUgKG9yIGBudWxsYCBpZiBub3QgZm91bmQpLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRGZWF0dXJlQnlJZChpZCkge1xuICAgIGNvbnN0IGZlYXR1cmUgPSB0aGlzLmlkSW5kZXhfW2lkLnRvU3RyaW5nKCldO1xuICAgIHJldHVybiBmZWF0dXJlICE9PSB1bmRlZmluZWQgPyBmZWF0dXJlIDogbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYSBmZWF0dXJlIGJ5IGl0cyBpbnRlcm5hbCB1bmlxdWUgaWRlbnRpZmllciAodXNpbmcgYGdldFVpZGApLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdWlkIEZlYXR1cmUgaWRlbnRpZmllci5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0PEdlb21ldHJ5PnxudWxsfSBUaGUgZmVhdHVyZSAob3IgYG51bGxgIGlmIG5vdCBmb3VuZCkuXG4gICAqL1xuICBnZXRGZWF0dXJlQnlVaWQodWlkKSB7XG4gICAgY29uc3QgZmVhdHVyZSA9IHRoaXMudWlkSW5kZXhfW3VpZF07XG4gICAgcmV0dXJuIGZlYXR1cmUgIT09IHVuZGVmaW5lZCA/IGZlYXR1cmUgOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZm9ybWF0IGFzc29jaWF0ZWQgd2l0aCB0aGlzIHNvdXJjZS5cbiAgICpcbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vZm9ybWF0L0ZlYXR1cmUuanNcIikuZGVmYXVsdHx1bmRlZmluZWR9IFRoZSBmZWF0dXJlIGZvcm1hdC5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0Rm9ybWF0KCkge1xuICAgIHJldHVybiB0aGlzLmZvcm1hdF87XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVGhlIHNvdXJjZSBjYW4gaGF2ZSBvdmVybGFwcGluZyBnZW9tZXRyaWVzLlxuICAgKi9cbiAgZ2V0T3ZlcmxhcHMoKSB7XG4gICAgcmV0dXJuIHRoaXMub3ZlcmxhcHNfO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdXJsIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHNvdXJjZS5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfGltcG9ydChcIi4uL2ZlYXR1cmVsb2FkZXIuanNcIikuRmVhdHVyZVVybEZ1bmN0aW9ufHVuZGVmaW5lZH0gVGhlIHVybC5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0VXJsKCkge1xuICAgIHJldHVybiB0aGlzLnVybF87XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgRXZlbnQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBoYW5kbGVGZWF0dXJlQ2hhbmdlXyhldmVudCkge1xuICAgIGNvbnN0IGZlYXR1cmUgPSAvKiogQHR5cGUge2ltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdDxHZW9tZXRyeT59ICovIChcbiAgICAgIGV2ZW50LnRhcmdldFxuICAgICk7XG4gICAgY29uc3QgZmVhdHVyZUtleSA9IGdldFVpZChmZWF0dXJlKTtcbiAgICBjb25zdCBnZW9tZXRyeSA9IGZlYXR1cmUuZ2V0R2VvbWV0cnkoKTtcbiAgICBpZiAoIWdlb21ldHJ5KSB7XG4gICAgICBpZiAoIShmZWF0dXJlS2V5IGluIHRoaXMubnVsbEdlb21ldHJ5RmVhdHVyZXNfKSkge1xuICAgICAgICBpZiAodGhpcy5mZWF0dXJlc1J0cmVlXykge1xuICAgICAgICAgIHRoaXMuZmVhdHVyZXNSdHJlZV8ucmVtb3ZlKGZlYXR1cmUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubnVsbEdlb21ldHJ5RmVhdHVyZXNfW2ZlYXR1cmVLZXldID0gZmVhdHVyZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgZXh0ZW50ID0gZ2VvbWV0cnkuZ2V0RXh0ZW50KCk7XG4gICAgICBpZiAoZmVhdHVyZUtleSBpbiB0aGlzLm51bGxHZW9tZXRyeUZlYXR1cmVzXykge1xuICAgICAgICBkZWxldGUgdGhpcy5udWxsR2VvbWV0cnlGZWF0dXJlc19bZmVhdHVyZUtleV07XG4gICAgICAgIGlmICh0aGlzLmZlYXR1cmVzUnRyZWVfKSB7XG4gICAgICAgICAgdGhpcy5mZWF0dXJlc1J0cmVlXy5pbnNlcnQoZXh0ZW50LCBmZWF0dXJlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMuZmVhdHVyZXNSdHJlZV8pIHtcbiAgICAgICAgICB0aGlzLmZlYXR1cmVzUnRyZWVfLnVwZGF0ZShleHRlbnQsIGZlYXR1cmUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGlkID0gZmVhdHVyZS5nZXRJZCgpO1xuICAgIGlmIChpZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zdCBzaWQgPSBpZC50b1N0cmluZygpO1xuICAgICAgaWYgKHRoaXMuaWRJbmRleF9bc2lkXSAhPT0gZmVhdHVyZSkge1xuICAgICAgICB0aGlzLnJlbW92ZUZyb21JZEluZGV4XyhmZWF0dXJlKTtcbiAgICAgICAgdGhpcy5pZEluZGV4X1tzaWRdID0gZmVhdHVyZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZW1vdmVGcm9tSWRJbmRleF8oZmVhdHVyZSk7XG4gICAgICB0aGlzLnVpZEluZGV4X1tmZWF0dXJlS2V5XSA9IGZlYXR1cmU7XG4gICAgfVxuICAgIHRoaXMuY2hhbmdlZCgpO1xuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChcbiAgICAgIG5ldyBWZWN0b3JTb3VyY2VFdmVudChWZWN0b3JFdmVudFR5cGUuQ0hBTkdFRkVBVFVSRSwgZmVhdHVyZSlcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZmVhdHVyZSBpcyBjb250YWluZWQgd2l0aGluIHRoZSBzb3VyY2UuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0PEdlb21ldHJ5Pn0gZmVhdHVyZSBGZWF0dXJlLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBIYXMgZmVhdHVyZS5cbiAgICogQGFwaVxuICAgKi9cbiAgaGFzRmVhdHVyZShmZWF0dXJlKSB7XG4gICAgY29uc3QgaWQgPSBmZWF0dXJlLmdldElkKCk7XG4gICAgaWYgKGlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBpZCBpbiB0aGlzLmlkSW5kZXhfO1xuICAgIH1cbiAgICByZXR1cm4gZ2V0VWlkKGZlYXR1cmUpIGluIHRoaXMudWlkSW5kZXhfO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IElzIGVtcHR5LlxuICAgKi9cbiAgaXNFbXB0eSgpIHtcbiAgICBpZiAodGhpcy5mZWF0dXJlc1J0cmVlXykge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgdGhpcy5mZWF0dXJlc1J0cmVlXy5pc0VtcHR5KCkgJiYgaXNFbXB0eSh0aGlzLm51bGxHZW9tZXRyeUZlYXR1cmVzXylcbiAgICAgICk7XG4gICAgfVxuICAgIGlmICh0aGlzLmZlYXR1cmVzQ29sbGVjdGlvbl8pIHtcbiAgICAgIHJldHVybiB0aGlzLmZlYXR1cmVzQ29sbGVjdGlvbl8uZ2V0TGVuZ3RoKCkgPT09IDA7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHJlc29sdXRpb24gUmVzb2x1dGlvbi5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9wcm9qL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdH0gcHJvamVjdGlvbiBQcm9qZWN0aW9uLlxuICAgKi9cbiAgbG9hZEZlYXR1cmVzKGV4dGVudCwgcmVzb2x1dGlvbiwgcHJvamVjdGlvbikge1xuICAgIGNvbnN0IGxvYWRlZEV4dGVudHNSdHJlZSA9IHRoaXMubG9hZGVkRXh0ZW50c1J0cmVlXztcbiAgICBjb25zdCBleHRlbnRzVG9Mb2FkID0gdGhpcy5zdHJhdGVneV8oZXh0ZW50LCByZXNvbHV0aW9uLCBwcm9qZWN0aW9uKTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBleHRlbnRzVG9Mb2FkLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgIGNvbnN0IGV4dGVudFRvTG9hZCA9IGV4dGVudHNUb0xvYWRbaV07XG4gICAgICBjb25zdCBhbHJlYWR5TG9hZGVkID0gbG9hZGVkRXh0ZW50c1J0cmVlLmZvckVhY2hJbkV4dGVudChcbiAgICAgICAgZXh0ZW50VG9Mb2FkLFxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHt7ZXh0ZW50OiBpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fX0gb2JqZWN0IE9iamVjdC5cbiAgICAgICAgICogQHJldHVybiB7Ym9vbGVhbn0gQ29udGFpbnMuXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgICAgICAgcmV0dXJuIGNvbnRhaW5zRXh0ZW50KG9iamVjdC5leHRlbnQsIGV4dGVudFRvTG9hZCk7XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgICBpZiAoIWFscmVhZHlMb2FkZWQpIHtcbiAgICAgICAgKyt0aGlzLmxvYWRpbmdFeHRlbnRzQ291bnRfO1xuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoXG4gICAgICAgICAgbmV3IFZlY3RvclNvdXJjZUV2ZW50KFZlY3RvckV2ZW50VHlwZS5GRUFUVVJFU0xPQURTVEFSVClcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5sb2FkZXJfLmNhbGwoXG4gICAgICAgICAgdGhpcyxcbiAgICAgICAgICBleHRlbnRUb0xvYWQsXG4gICAgICAgICAgcmVzb2x1dGlvbixcbiAgICAgICAgICBwcm9qZWN0aW9uLFxuICAgICAgICAgIChmZWF0dXJlcykgPT4ge1xuICAgICAgICAgICAgLS10aGlzLmxvYWRpbmdFeHRlbnRzQ291bnRfO1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KFxuICAgICAgICAgICAgICBuZXcgVmVjdG9yU291cmNlRXZlbnQoXG4gICAgICAgICAgICAgICAgVmVjdG9yRXZlbnRUeXBlLkZFQVRVUkVTTE9BREVORCxcbiAgICAgICAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgZmVhdHVyZXNcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgICgpID0+IHtcbiAgICAgICAgICAgIC0tdGhpcy5sb2FkaW5nRXh0ZW50c0NvdW50XztcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChcbiAgICAgICAgICAgICAgbmV3IFZlY3RvclNvdXJjZUV2ZW50KFZlY3RvckV2ZW50VHlwZS5GRUFUVVJFU0xPQURFUlJPUilcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICApO1xuICAgICAgICBsb2FkZWRFeHRlbnRzUnRyZWUuaW5zZXJ0KGV4dGVudFRvTG9hZCwge2V4dGVudDogZXh0ZW50VG9Mb2FkLnNsaWNlKCl9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5sb2FkaW5nID1cbiAgICAgIHRoaXMubG9hZGVyXy5sZW5ndGggPCA0ID8gZmFsc2UgOiB0aGlzLmxvYWRpbmdFeHRlbnRzQ291bnRfID4gMDtcbiAgfVxuXG4gIHJlZnJlc2goKSB7XG4gICAgdGhpcy5jbGVhcih0cnVlKTtcbiAgICB0aGlzLmxvYWRlZEV4dGVudHNSdHJlZV8uY2xlYXIoKTtcbiAgICBzdXBlci5yZWZyZXNoKCk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGFuIGV4dGVudCBmcm9tIHRoZSBsaXN0IG9mIGxvYWRlZCBleHRlbnRzLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gICAqIEBhcGlcbiAgICovXG4gIHJlbW92ZUxvYWRlZEV4dGVudChleHRlbnQpIHtcbiAgICBjb25zdCBsb2FkZWRFeHRlbnRzUnRyZWUgPSB0aGlzLmxvYWRlZEV4dGVudHNSdHJlZV87XG4gICAgbGV0IG9iajtcbiAgICBsb2FkZWRFeHRlbnRzUnRyZWUuZm9yRWFjaEluRXh0ZW50KGV4dGVudCwgZnVuY3Rpb24gKG9iamVjdCkge1xuICAgICAgaWYgKGVxdWFscyhvYmplY3QuZXh0ZW50LCBleHRlbnQpKSB7XG4gICAgICAgIG9iaiA9IG9iamVjdDtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKG9iaikge1xuICAgICAgbG9hZGVkRXh0ZW50c1J0cmVlLnJlbW92ZShvYmopO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYSBzaW5nbGUgZmVhdHVyZSBmcm9tIHRoZSBzb3VyY2UuICBJZiB5b3Ugd2FudCB0byByZW1vdmUgYWxsIGZlYXR1cmVzXG4gICAqIGF0IG9uY2UsIHVzZSB0aGUge0BsaW5rIG1vZHVsZTpvbC9zb3VyY2UvVmVjdG9yflZlY3RvclNvdXJjZSNjbGVhciAjY2xlYXIoKX0gbWV0aG9kXG4gICAqIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0PEdlb21ldHJ5Pn0gZmVhdHVyZSBGZWF0dXJlIHRvIHJlbW92ZS5cbiAgICogQGFwaVxuICAgKi9cbiAgcmVtb3ZlRmVhdHVyZShmZWF0dXJlKSB7XG4gICAgaWYgKCFmZWF0dXJlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGZlYXR1cmVLZXkgPSBnZXRVaWQoZmVhdHVyZSk7XG4gICAgaWYgKGZlYXR1cmVLZXkgaW4gdGhpcy5udWxsR2VvbWV0cnlGZWF0dXJlc18pIHtcbiAgICAgIGRlbGV0ZSB0aGlzLm51bGxHZW9tZXRyeUZlYXR1cmVzX1tmZWF0dXJlS2V5XTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHRoaXMuZmVhdHVyZXNSdHJlZV8pIHtcbiAgICAgICAgdGhpcy5mZWF0dXJlc1J0cmVlXy5yZW1vdmUoZmVhdHVyZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMucmVtb3ZlRmVhdHVyZUludGVybmFsKGZlYXR1cmUpO1xuICAgIGlmIChyZXN1bHQpIHtcbiAgICAgIHRoaXMuY2hhbmdlZCgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgZmVhdHVyZSB3aXRob3V0IGZpcmluZyBhIGBjaGFuZ2VgIGV2ZW50LlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdDxHZW9tZXRyeT59IGZlYXR1cmUgRmVhdHVyZS5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0PEdlb21ldHJ5Pnx1bmRlZmluZWR9IFRoZSByZW1vdmVkIGZlYXR1cmVcbiAgICogICAgIChvciB1bmRlZmluZWQgaWYgdGhlIGZlYXR1cmUgd2FzIG5vdCBmb3VuZCkuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIHJlbW92ZUZlYXR1cmVJbnRlcm5hbChmZWF0dXJlKSB7XG4gICAgY29uc3QgZmVhdHVyZUtleSA9IGdldFVpZChmZWF0dXJlKTtcbiAgICBjb25zdCBmZWF0dXJlQ2hhbmdlS2V5cyA9IHRoaXMuZmVhdHVyZUNoYW5nZUtleXNfW2ZlYXR1cmVLZXldO1xuICAgIGlmICghZmVhdHVyZUNoYW5nZUtleXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZmVhdHVyZUNoYW5nZUtleXMuZm9yRWFjaCh1bmxpc3RlbkJ5S2V5KTtcbiAgICBkZWxldGUgdGhpcy5mZWF0dXJlQ2hhbmdlS2V5c19bZmVhdHVyZUtleV07XG4gICAgY29uc3QgaWQgPSBmZWF0dXJlLmdldElkKCk7XG4gICAgaWYgKGlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLmlkSW5kZXhfW2lkLnRvU3RyaW5nKCldO1xuICAgIH1cbiAgICBkZWxldGUgdGhpcy51aWRJbmRleF9bZmVhdHVyZUtleV07XG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KFxuICAgICAgbmV3IFZlY3RvclNvdXJjZUV2ZW50KFZlY3RvckV2ZW50VHlwZS5SRU1PVkVGRUFUVVJFLCBmZWF0dXJlKVxuICAgICk7XG4gICAgcmV0dXJuIGZlYXR1cmU7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGEgZmVhdHVyZSBmcm9tIHRoZSBpZCBpbmRleC4gIENhbGxlZCBpbnRlcm5hbGx5IHdoZW4gdGhlIGZlYXR1cmUgaWRcbiAgICogbWF5IGhhdmUgY2hhbmdlZC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHQ8R2VvbWV0cnk+fSBmZWF0dXJlIFRoZSBmZWF0dXJlLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBSZW1vdmVkIHRoZSBmZWF0dXJlIGZyb20gdGhlIGluZGV4LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcmVtb3ZlRnJvbUlkSW5kZXhfKGZlYXR1cmUpIHtcbiAgICBsZXQgcmVtb3ZlZCA9IGZhbHNlO1xuICAgIGZvciAoY29uc3QgaWQgaW4gdGhpcy5pZEluZGV4Xykge1xuICAgICAgaWYgKHRoaXMuaWRJbmRleF9baWRdID09PSBmZWF0dXJlKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmlkSW5kZXhfW2lkXTtcbiAgICAgICAgcmVtb3ZlZCA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVtb3ZlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIG5ldyBsb2FkZXIgb2YgdGhlIHNvdXJjZS4gVGhlIG5leHQgcmVuZGVyIGN5Y2xlIHdpbGwgdXNlIHRoZVxuICAgKiBuZXcgbG9hZGVyLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2ZlYXR1cmVsb2FkZXIuanNcIikuRmVhdHVyZUxvYWRlcn0gbG9hZGVyIFRoZSBsb2FkZXIgdG8gc2V0LlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRMb2FkZXIobG9hZGVyKSB7XG4gICAgdGhpcy5sb2FkZXJfID0gbG9hZGVyO1xuICB9XG5cbiAgLyoqXG4gICAqIFBvaW50cyB0aGUgc291cmNlIHRvIGEgbmV3IHVybC4gVGhlIG5leHQgcmVuZGVyIGN5Y2xlIHdpbGwgdXNlIHRoZSBuZXcgdXJsLlxuICAgKiBAcGFyYW0ge3N0cmluZ3xpbXBvcnQoXCIuLi9mZWF0dXJlbG9hZGVyLmpzXCIpLkZlYXR1cmVVcmxGdW5jdGlvbn0gdXJsIFVybC5cbiAgICogQGFwaVxuICAgKi9cbiAgc2V0VXJsKHVybCkge1xuICAgIGFzc2VydCh0aGlzLmZvcm1hdF8sICdgZm9ybWF0YCBtdXN0IGJlIHNldCB3aGVuIGB1cmxgIGlzIHNldCcpO1xuICAgIHRoaXMudXJsXyA9IHVybDtcbiAgICB0aGlzLnNldExvYWRlcih4aHIodXJsLCB0aGlzLmZvcm1hdF8pKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBWZWN0b3JTb3VyY2U7XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvc291cmNlL1ZlY3RvckV2ZW50VHlwZVxuICovXG5cbi8qKlxuICogQGVudW0ge3N0cmluZ31cbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICAvKipcbiAgICogVHJpZ2dlcmVkIHdoZW4gYSBmZWF0dXJlIGlzIGFkZGVkIHRvIHRoZSBzb3VyY2UuXG4gICAqIEBldmVudCBtb2R1bGU6b2wvc291cmNlL1ZlY3Rvci5WZWN0b3JTb3VyY2VFdmVudCNhZGRmZWF0dXJlXG4gICAqIEBhcGlcbiAgICovXG4gIEFEREZFQVRVUkU6ICdhZGRmZWF0dXJlJyxcblxuICAvKipcbiAgICogVHJpZ2dlcmVkIHdoZW4gYSBmZWF0dXJlIGlzIHVwZGF0ZWQuXG4gICAqIEBldmVudCBtb2R1bGU6b2wvc291cmNlL1ZlY3Rvci5WZWN0b3JTb3VyY2VFdmVudCNjaGFuZ2VmZWF0dXJlXG4gICAqIEBhcGlcbiAgICovXG4gIENIQU5HRUZFQVRVUkU6ICdjaGFuZ2VmZWF0dXJlJyxcblxuICAvKipcbiAgICogVHJpZ2dlcmVkIHdoZW4gdGhlIGNsZWFyIG1ldGhvZCBpcyBjYWxsZWQgb24gdGhlIHNvdXJjZS5cbiAgICogQGV2ZW50IG1vZHVsZTpvbC9zb3VyY2UvVmVjdG9yLlZlY3RvclNvdXJjZUV2ZW50I2NsZWFyXG4gICAqIEBhcGlcbiAgICovXG4gIENMRUFSOiAnY2xlYXInLFxuXG4gIC8qKlxuICAgKiBUcmlnZ2VyZWQgd2hlbiBhIGZlYXR1cmUgaXMgcmVtb3ZlZCBmcm9tIHRoZSBzb3VyY2UuXG4gICAqIFNlZSB7QGxpbmsgbW9kdWxlOm9sL3NvdXJjZS9WZWN0b3J+VmVjdG9yU291cmNlI2NsZWFyIHNvdXJjZS5jbGVhcigpfSBmb3IgZXhjZXB0aW9ucy5cbiAgICogQGV2ZW50IG1vZHVsZTpvbC9zb3VyY2UvVmVjdG9yLlZlY3RvclNvdXJjZUV2ZW50I3JlbW92ZWZlYXR1cmVcbiAgICogQGFwaVxuICAgKi9cbiAgUkVNT1ZFRkVBVFVSRTogJ3JlbW92ZWZlYXR1cmUnLFxuXG4gIC8qKlxuICAgKiBUcmlnZ2VyZWQgd2hlbiBmZWF0dXJlcyBzdGFydHMgbG9hZGluZy5cbiAgICogQGV2ZW50IG1vZHVsZTpvbC9zb3VyY2UvVmVjdG9yLlZlY3RvclNvdXJjZUV2ZW50I2ZlYXR1cmVzbG9hZHN0YXJ0XG4gICAqIEBhcGlcbiAgICovXG4gIEZFQVRVUkVTTE9BRFNUQVJUOiAnZmVhdHVyZXNsb2Fkc3RhcnQnLFxuXG4gIC8qKlxuICAgKiBUcmlnZ2VyZWQgd2hlbiBmZWF0dXJlcyBmaW5pc2hlcyBsb2FkaW5nLlxuICAgKiBAZXZlbnQgbW9kdWxlOm9sL3NvdXJjZS9WZWN0b3IuVmVjdG9yU291cmNlRXZlbnQjZmVhdHVyZXNsb2FkZW5kXG4gICAqIEBhcGlcbiAgICovXG4gIEZFQVRVUkVTTE9BREVORDogJ2ZlYXR1cmVzbG9hZGVuZCcsXG5cbiAgLyoqXG4gICAqIFRyaWdnZXJlZCBpZiBmZWF0dXJlIGxvYWRpbmcgcmVzdWx0cyBpbiBhbiBlcnJvci5cbiAgICogQGV2ZW50IG1vZHVsZTpvbC9zb3VyY2UvVmVjdG9yLlZlY3RvclNvdXJjZUV2ZW50I2ZlYXR1cmVzbG9hZGVycm9yXG4gICAqIEBhcGlcbiAgICovXG4gIEZFQVRVUkVTTE9BREVSUk9SOiAnZmVhdHVyZXNsb2FkZXJyb3InLFxufTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7J2FkZGZlYXR1cmUnfCdjaGFuZ2VmZWF0dXJlJ3wnY2xlYXInfCdyZW1vdmVmZWF0dXJlJ3wnZmVhdHVyZXNsb2Fkc3RhcnQnfCdmZWF0dXJlc2xvYWRlbmQnfCdmZWF0dXJlc2xvYWRlcnJvcid9IFZlY3RvclNvdXJjZUV2ZW50VHlwZXNcbiAqL1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3NvdXJjZS9YWVpcbiAqL1xuXG5pbXBvcnQgVGlsZUltYWdlIGZyb20gJy4vVGlsZUltYWdlLmpzJztcbmltcG9ydCB7Y3JlYXRlWFlaLCBleHRlbnRGcm9tUHJvamVjdGlvbn0gZnJvbSAnLi4vdGlsZWdyaWQuanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi9Tb3VyY2UuanNcIikuQXR0cmlidXRpb25MaWtlfSBbYXR0cmlidXRpb25zXSBBdHRyaWJ1dGlvbnMuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFthdHRyaWJ1dGlvbnNDb2xsYXBzaWJsZT10cnVlXSBBdHRyaWJ1dGlvbnMgYXJlIGNvbGxhcHNpYmxlLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtjYWNoZVNpemVdIEluaXRpYWwgdGlsZSBjYWNoZSBzaXplLiBXaWxsIGF1dG8tZ3JvdyB0byBob2xkIGF0IGxlYXN0IHRoZSBudW1iZXIgb2YgdGlsZXMgaW4gdGhlIHZpZXdwb3J0LlxuICogQHByb3BlcnR5IHtudWxsfHN0cmluZ30gW2Nyb3NzT3JpZ2luXSBUaGUgYGNyb3NzT3JpZ2luYCBhdHRyaWJ1dGUgZm9yIGxvYWRlZCBpbWFnZXMuICBOb3RlIHRoYXRcbiAqIHlvdSBtdXN0IHByb3ZpZGUgYSBgY3Jvc3NPcmlnaW5gIHZhbHVlIGlmIHlvdSB3YW50IHRvIGFjY2VzcyBwaXhlbCBkYXRhIHdpdGggdGhlIENhbnZhcyByZW5kZXJlci5cbiAqIFNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVE1ML0NPUlNfZW5hYmxlZF9pbWFnZSBmb3IgbW9yZSBkZXRhaWwuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtpbnRlcnBvbGF0ZT10cnVlXSBVc2UgaW50ZXJwb2xhdGVkIHZhbHVlcyB3aGVuIHJlc2FtcGxpbmcuICBCeSBkZWZhdWx0LFxuICogbGluZWFyIGludGVycG9sYXRpb24gaXMgdXNlZCB3aGVuIHJlc2FtcGxpbmcuICBTZXQgdG8gZmFsc2UgdG8gdXNlIHRoZSBuZWFyZXN0IG5laWdoYm9yIGluc3RlYWQuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtvcGFxdWU9ZmFsc2VdIFdoZXRoZXIgdGhlIGxheWVyIGlzIG9wYXF1ZS5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vcHJvai5qc1wiKS5Qcm9qZWN0aW9uTGlrZX0gW3Byb2plY3Rpb249J0VQU0c6Mzg1NyddIFByb2plY3Rpb24uXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3JlcHJvamVjdGlvbkVycm9yVGhyZXNob2xkPTAuNV0gTWF4aW11bSBhbGxvd2VkIHJlcHJvamVjdGlvbiBlcnJvciAoaW4gcGl4ZWxzKS5cbiAqIEhpZ2hlciB2YWx1ZXMgY2FuIGluY3JlYXNlIHJlcHJvamVjdGlvbiBwZXJmb3JtYW5jZSwgYnV0IGRlY3JlYXNlIHByZWNpc2lvbi5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbWF4Wm9vbT00Ml0gT3B0aW9uYWwgbWF4IHpvb20gbGV2ZWwuIE5vdCB1c2VkIGlmIGB0aWxlR3JpZGAgaXMgcHJvdmlkZWQuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW21pblpvb209MF0gT3B0aW9uYWwgbWluIHpvb20gbGV2ZWwuIE5vdCB1c2VkIGlmIGB0aWxlR3JpZGAgaXMgcHJvdmlkZWQuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW21heFJlc29sdXRpb25dIE9wdGlvbmFsIHRpbGUgZ3JpZCByZXNvbHV0aW9uIGF0IGxldmVsIHplcm8uIE5vdCB1c2VkIGlmIGB0aWxlR3JpZGAgaXMgcHJvdmlkZWQuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL3RpbGVncmlkL1RpbGVHcmlkLmpzXCIpLmRlZmF1bHR9IFt0aWxlR3JpZF0gVGlsZSBncmlkLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9UaWxlLmpzXCIpLkxvYWRGdW5jdGlvbn0gW3RpbGVMb2FkRnVuY3Rpb25dIE9wdGlvbmFsIGZ1bmN0aW9uIHRvIGxvYWQgYSB0aWxlIGdpdmVuIGEgVVJMLiBUaGUgZGVmYXVsdCBpc1xuICogYGBganNcbiAqIGZ1bmN0aW9uKGltYWdlVGlsZSwgc3JjKSB7XG4gKiAgIGltYWdlVGlsZS5nZXRJbWFnZSgpLnNyYyA9IHNyYztcbiAqIH07XG4gKiBgYGBcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbdGlsZVBpeGVsUmF0aW89MV0gVGhlIHBpeGVsIHJhdGlvIHVzZWQgYnkgdGhlIHRpbGUgc2VydmljZS5cbiAqIEZvciBleGFtcGxlLCBpZiB0aGUgdGlsZSBzZXJ2aWNlIGFkdmVydGl6ZXMgMjU2cHggYnkgMjU2cHggdGlsZXMgYnV0IGFjdHVhbGx5IHNlbmRzIDUxMnB4XG4gKiBieSA1MTJweCBpbWFnZXMgKGZvciByZXRpbmEvaGlkcGkgZGV2aWNlcykgdGhlbiBgdGlsZVBpeGVsUmF0aW9gXG4gKiBzaG91bGQgYmUgc2V0IHRvIGAyYC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfGltcG9ydChcIi4uL3NpemUuanNcIikuU2l6ZX0gW3RpbGVTaXplPVsyNTYsIDI1Nl1dIFRoZSB0aWxlIHNpemUgdXNlZCBieSB0aGUgdGlsZSBzZXJ2aWNlLlxuICogTm90IHVzZWQgaWYgYHRpbGVHcmlkYCBpcyBwcm92aWRlZC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbZ3V0dGVyPTBdIFRoZSBzaXplIGluIHBpeGVscyBvZiB0aGUgZ3V0dGVyIGFyb3VuZCBpbWFnZSB0aWxlcyB0byBpZ25vcmUuXG4gKiBUaGlzIGFsbG93cyBhcnRpZmFjdHMgb2YgcmVuZGVyaW5nIGF0IHRpbGUgZWRnZXMgdG8gYmUgaWdub3JlZC5cbiAqIFN1cHBvcnRlZCBpbWFnZXMgc2hvdWxkIGJlIHdpZGVyIGFuZCB0YWxsZXIgdGhhbiB0aGUgdGlsZSBzaXplIGJ5IGEgdmFsdWUgb2YgYDIgeCBndXR0ZXJgLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9UaWxlLmpzXCIpLlVybEZ1bmN0aW9ufSBbdGlsZVVybEZ1bmN0aW9uXSBPcHRpb25hbCBmdW5jdGlvbiB0byBnZXRcbiAqIHRpbGUgVVJMIGdpdmVuIGEgdGlsZSBjb29yZGluYXRlIGFuZCB0aGUgcHJvamVjdGlvbi5cbiAqIFJlcXVpcmVkIGlmIGB1cmxgIG9yIGB1cmxzYCBhcmUgbm90IHByb3ZpZGVkLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFt1cmxdIFVSTCB0ZW1wbGF0ZS4gTXVzdCBpbmNsdWRlIGB7eH1gLCBge3l9YCBvciBgey15fWAsXG4gKiBhbmQgYHt6fWAgcGxhY2Vob2xkZXJzLiBBIGB7Py0/fWAgdGVtcGxhdGUgcGF0dGVybiwgZm9yIGV4YW1wbGUgYHN1YmRvbWFpbnthLWZ9LmRvbWFpbi5jb21gLFxuICogbWF5IGJlIHVzZWQgaW5zdGVhZCBvZiBkZWZpbmluZyBlYWNoIG9uZSBzZXBhcmF0ZWx5IGluIHRoZSBgdXJsc2Agb3B0aW9uLlxuICogQHByb3BlcnR5IHtBcnJheTxzdHJpbmc+fSBbdXJsc10gQW4gYXJyYXkgb2YgVVJMIHRlbXBsYXRlcy5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3dyYXBYPXRydWVdIFdoZXRoZXIgdG8gd3JhcCB0aGUgd29ybGQgaG9yaXpvbnRhbGx5LlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFt0cmFuc2l0aW9uPTI1MF0gRHVyYXRpb24gb2YgdGhlIG9wYWNpdHkgdHJhbnNpdGlvbiBmb3IgcmVuZGVyaW5nLlxuICogVG8gZGlzYWJsZSB0aGUgb3BhY2l0eSB0cmFuc2l0aW9uLCBwYXNzIGB0cmFuc2l0aW9uOiAwYC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfGltcG9ydChcIi4uL2FycmF5LmpzXCIpLk5lYXJlc3REaXJlY3Rpb25GdW5jdGlvbn0gW3pEaXJlY3Rpb249MF1cbiAqIENob29zZSB3aGV0aGVyIHRvIHVzZSB0aWxlcyB3aXRoIGEgaGlnaGVyIG9yIGxvd2VyIHpvb20gbGV2ZWwgd2hlbiBiZXR3ZWVuIGludGVnZXJcbiAqIHpvb20gbGV2ZWxzLiBTZWUge0BsaW5rIG1vZHVsZTpvbC90aWxlZ3JpZC9UaWxlR3JpZH5UaWxlR3JpZCNnZXRaRm9yUmVzb2x1dGlvbn0uXG4gKi9cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBMYXllciBzb3VyY2UgZm9yIHRpbGUgZGF0YSB3aXRoIFVSTHMgaW4gYSBzZXQgWFlaIGZvcm1hdCB0aGF0IGFyZVxuICogZGVmaW5lZCBpbiBhIFVSTCB0ZW1wbGF0ZS4gQnkgZGVmYXVsdCwgdGhpcyBmb2xsb3dzIHRoZSB3aWRlbHktdXNlZFxuICogR29vZ2xlIGdyaWQgd2hlcmUgYHhgIDAgYW5kIGB5YCAwIGFyZSBpbiB0aGUgdG9wIGxlZnQuIEdyaWRzIGxpa2VcbiAqIFRNUyB3aGVyZSBgeGAgMCBhbmQgYHlgIDAgYXJlIGluIHRoZSBib3R0b20gbGVmdCBjYW4gYmUgdXNlZCBieVxuICogdXNpbmcgdGhlIGB7LXl9YCBwbGFjZWhvbGRlciBpbiB0aGUgVVJMIHRlbXBsYXRlLCBzbyBsb25nIGFzIHRoZVxuICogc291cmNlIGRvZXMgbm90IGhhdmUgYSBjdXN0b20gdGlsZSBncmlkLiBJbiB0aGlzIGNhc2VcbiAqIGEgYHRpbGVVcmxGdW5jdGlvbmAgY2FuIGJlIHVzZWQsIHN1Y2ggYXM6XG4gKiBgYGBqc1xuICogIHRpbGVVcmxGdW5jdGlvbjogZnVuY3Rpb24oY29vcmRpbmF0ZSkge1xuICogICAgcmV0dXJuICdodHRwOi8vbWFwc2VydmVyLmNvbS8nICsgY29vcmRpbmF0ZVswXSArICcvJyArXG4gKiAgICAgIGNvb3JkaW5hdGVbMV0gKyAnLycgKyAoLWNvb3JkaW5hdGVbMl0gLSAxKSArICcucG5nJztcbiAqICB9XG4gKiBgYGBcbiAqIEBhcGlcbiAqL1xuY2xhc3MgWFlaIGV4dGVuZHMgVGlsZUltYWdlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7T3B0aW9uc30gW29wdGlvbnNdIFhZWiBvcHRpb25zLlxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgY29uc3QgcHJvamVjdGlvbiA9XG4gICAgICBvcHRpb25zLnByb2plY3Rpb24gIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMucHJvamVjdGlvbiA6ICdFUFNHOjM4NTcnO1xuXG4gICAgY29uc3QgdGlsZUdyaWQgPVxuICAgICAgb3B0aW9ucy50aWxlR3JpZCAhPT0gdW5kZWZpbmVkXG4gICAgICAgID8gb3B0aW9ucy50aWxlR3JpZFxuICAgICAgICA6IGNyZWF0ZVhZWih7XG4gICAgICAgICAgICBleHRlbnQ6IGV4dGVudEZyb21Qcm9qZWN0aW9uKHByb2plY3Rpb24pLFxuICAgICAgICAgICAgbWF4UmVzb2x1dGlvbjogb3B0aW9ucy5tYXhSZXNvbHV0aW9uLFxuICAgICAgICAgICAgbWF4Wm9vbTogb3B0aW9ucy5tYXhab29tLFxuICAgICAgICAgICAgbWluWm9vbTogb3B0aW9ucy5taW5ab29tLFxuICAgICAgICAgICAgdGlsZVNpemU6IG9wdGlvbnMudGlsZVNpemUsXG4gICAgICAgICAgfSk7XG5cbiAgICBzdXBlcih7XG4gICAgICBhdHRyaWJ1dGlvbnM6IG9wdGlvbnMuYXR0cmlidXRpb25zLFxuICAgICAgY2FjaGVTaXplOiBvcHRpb25zLmNhY2hlU2l6ZSxcbiAgICAgIGNyb3NzT3JpZ2luOiBvcHRpb25zLmNyb3NzT3JpZ2luLFxuICAgICAgaW50ZXJwb2xhdGU6IG9wdGlvbnMuaW50ZXJwb2xhdGUsXG4gICAgICBvcGFxdWU6IG9wdGlvbnMub3BhcXVlLFxuICAgICAgcHJvamVjdGlvbjogcHJvamVjdGlvbixcbiAgICAgIHJlcHJvamVjdGlvbkVycm9yVGhyZXNob2xkOiBvcHRpb25zLnJlcHJvamVjdGlvbkVycm9yVGhyZXNob2xkLFxuICAgICAgdGlsZUdyaWQ6IHRpbGVHcmlkLFxuICAgICAgdGlsZUxvYWRGdW5jdGlvbjogb3B0aW9ucy50aWxlTG9hZEZ1bmN0aW9uLFxuICAgICAgdGlsZVBpeGVsUmF0aW86IG9wdGlvbnMudGlsZVBpeGVsUmF0aW8sXG4gICAgICB0aWxlVXJsRnVuY3Rpb246IG9wdGlvbnMudGlsZVVybEZ1bmN0aW9uLFxuICAgICAgdXJsOiBvcHRpb25zLnVybCxcbiAgICAgIHVybHM6IG9wdGlvbnMudXJscyxcbiAgICAgIHdyYXBYOiBvcHRpb25zLndyYXBYICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLndyYXBYIDogdHJ1ZSxcbiAgICAgIHRyYW5zaXRpb246IG9wdGlvbnMudHJhbnNpdGlvbixcbiAgICAgIGF0dHJpYnV0aW9uc0NvbGxhcHNpYmxlOiBvcHRpb25zLmF0dHJpYnV0aW9uc0NvbGxhcHNpYmxlLFxuICAgICAgekRpcmVjdGlvbjogb3B0aW9ucy56RGlyZWN0aW9uLFxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuZ3V0dGVyXyA9IG9wdGlvbnMuZ3V0dGVyICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmd1dHRlciA6IDA7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfSBHdXR0ZXIuXG4gICAqL1xuICBnZXRHdXR0ZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ3V0dGVyXztcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBYWVo7XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvc3BoZXJlXG4gKi9cbmltcG9ydCB7dG9EZWdyZWVzLCB0b1JhZGlhbnN9IGZyb20gJy4vbWF0aC5qcyc7XG5cbi8qKlxuICogT2JqZWN0IGxpdGVyYWwgd2l0aCBvcHRpb25zIGZvciB0aGUge0BsaW5rIGdldExlbmd0aH0gb3Ige0BsaW5rIGdldEFyZWF9XG4gKiBmdW5jdGlvbnMuXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBTcGhlcmVNZXRyaWNPcHRpb25zXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4vcHJvai5qc1wiKS5Qcm9qZWN0aW9uTGlrZX0gW3Byb2plY3Rpb249J0VQU0c6Mzg1NyddXG4gKiBQcm9qZWN0aW9uIG9mIHRoZSAgZ2VvbWV0cnkuICBCeSBkZWZhdWx0LCB0aGUgZ2VvbWV0cnkgaXMgYXNzdW1lZCB0byBiZSBpblxuICogV2ViIE1lcmNhdG9yLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtyYWRpdXM9NjM3MTAwOC44XSBTcGhlcmUgcmFkaXVzLiAgQnkgZGVmYXVsdCwgdGhlXG4gKiBbbWVhbiBFYXJ0aCByYWRpdXNdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0VhcnRoX3JhZGl1cyNNZWFuX3JhZGl1cylcbiAqIGZvciB0aGUgV0dTODQgZWxsaXBzb2lkIGlzIHVzZWQuXG4gKi9cblxuLyoqXG4gKiBUaGUgbWVhbiBFYXJ0aCByYWRpdXMgKDEvMyAqICgyYSArIGIpKSBmb3IgdGhlIFdHUzg0IGVsbGlwc29pZC5cbiAqIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0VhcnRoX3JhZGl1cyNNZWFuX3JhZGl1c1xuICogQHR5cGUge251bWJlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IERFRkFVTFRfUkFESVVTID0gNjM3MTAwOC44O1xuXG4vKipcbiAqIEdldCB0aGUgZ3JlYXQgY2lyY2xlIGRpc3RhbmNlIChpbiBtZXRlcnMpIGJldHdlZW4gdHdvIGdlb2dyYXBoaWMgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge0FycmF5fSBjMSBTdGFydGluZyBjb29yZGluYXRlLlxuICogQHBhcmFtIHtBcnJheX0gYzIgRW5kaW5nIGNvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge251bWJlcn0gW3JhZGl1c10gVGhlIHNwaGVyZSByYWRpdXMgdG8gdXNlLiAgRGVmYXVsdHMgdG8gdGhlIEVhcnRoJ3NcbiAqICAgICBtZWFuIHJhZGl1cyB1c2luZyB0aGUgV0dTODQgZWxsaXBzb2lkLlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgZ3JlYXQgY2lyY2xlIGRpc3RhbmNlIGJldHdlZW4gdGhlIHBvaW50cyAoaW4gbWV0ZXJzKS5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldERpc3RhbmNlKGMxLCBjMiwgcmFkaXVzKSB7XG4gIHJhZGl1cyA9IHJhZGl1cyB8fCBERUZBVUxUX1JBRElVUztcbiAgY29uc3QgbGF0MSA9IHRvUmFkaWFucyhjMVsxXSk7XG4gIGNvbnN0IGxhdDIgPSB0b1JhZGlhbnMoYzJbMV0pO1xuICBjb25zdCBkZWx0YUxhdEJ5MiA9IChsYXQyIC0gbGF0MSkgLyAyO1xuICBjb25zdCBkZWx0YUxvbkJ5MiA9IHRvUmFkaWFucyhjMlswXSAtIGMxWzBdKSAvIDI7XG4gIGNvbnN0IGEgPVxuICAgIE1hdGguc2luKGRlbHRhTGF0QnkyKSAqIE1hdGguc2luKGRlbHRhTGF0QnkyKSArXG4gICAgTWF0aC5zaW4oZGVsdGFMb25CeTIpICpcbiAgICAgIE1hdGguc2luKGRlbHRhTG9uQnkyKSAqXG4gICAgICBNYXRoLmNvcyhsYXQxKSAqXG4gICAgICBNYXRoLmNvcyhsYXQyKTtcbiAgcmV0dXJuIDIgKiByYWRpdXMgKiBNYXRoLmF0YW4yKE1hdGguc3FydChhKSwgTWF0aC5zcXJ0KDEgLSBhKSk7XG59XG5cbi8qKlxuICogR2V0IHRoZSBjdW11bGF0aXZlIGdyZWF0IGNpcmNsZSBsZW5ndGggb2YgbGluZXN0cmluZyBjb29yZGluYXRlcyAoZ2VvZ3JhcGhpYykuXG4gKiBAcGFyYW0ge0FycmF5fSBjb29yZGluYXRlcyBMaW5lc3RyaW5nIGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IHJhZGl1cyBUaGUgc3BoZXJlIHJhZGl1cyB0byB1c2UuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBsZW5ndGggKGluIG1ldGVycykuXG4gKi9cbmZ1bmN0aW9uIGdldExlbmd0aEludGVybmFsKGNvb3JkaW5hdGVzLCByYWRpdXMpIHtcbiAgbGV0IGxlbmd0aCA9IDA7XG4gIGZvciAobGV0IGkgPSAwLCBpaSA9IGNvb3JkaW5hdGVzLmxlbmd0aDsgaSA8IGlpIC0gMTsgKytpKSB7XG4gICAgbGVuZ3RoICs9IGdldERpc3RhbmNlKGNvb3JkaW5hdGVzW2ldLCBjb29yZGluYXRlc1tpICsgMV0sIHJhZGl1cyk7XG4gIH1cbiAgcmV0dXJuIGxlbmd0aDtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHNwaGVyaWNhbCBsZW5ndGggb2YgYSBnZW9tZXRyeS4gIFRoaXMgbGVuZ3RoIGlzIHRoZSBzdW0gb2YgdGhlXG4gKiBncmVhdCBjaXJjbGUgZGlzdGFuY2VzIGJldHdlZW4gY29vcmRpbmF0ZXMuICBGb3IgcG9seWdvbnMsIHRoZSBsZW5ndGggaXNcbiAqIHRoZSBzdW0gb2YgYWxsIHJpbmdzLiAgRm9yIHBvaW50cywgdGhlIGxlbmd0aCBpcyB6ZXJvLiAgRm9yIG11bHRpLXBhcnRcbiAqIGdlb21ldHJpZXMsIHRoZSBsZW5ndGggaXMgdGhlIHN1bSBvZiB0aGUgbGVuZ3RoIG9mIGVhY2ggcGFydC5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9nZW9tL0dlb21ldHJ5LmpzXCIpLmRlZmF1bHR9IGdlb21ldHJ5IEEgZ2VvbWV0cnkuXG4gKiBAcGFyYW0ge1NwaGVyZU1ldHJpY09wdGlvbnN9IFtvcHRpb25zXSBPcHRpb25zIGZvciB0aGVcbiAqIGxlbmd0aCBjYWxjdWxhdGlvbi4gIEJ5IGRlZmF1bHQsIGdlb21ldHJpZXMgYXJlIGFzc3VtZWQgdG8gYmUgaW4gJ0VQU0c6Mzg1NycuXG4gKiBZb3UgY2FuIGNoYW5nZSB0aGlzIGJ5IHByb3ZpZGluZyBhIGBwcm9qZWN0aW9uYCBvcHRpb24uXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBzcGhlcmljYWwgbGVuZ3RoIChpbiBtZXRlcnMpLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0TGVuZ3RoKGdlb21ldHJ5LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBjb25zdCByYWRpdXMgPSBvcHRpb25zLnJhZGl1cyB8fCBERUZBVUxUX1JBRElVUztcbiAgY29uc3QgcHJvamVjdGlvbiA9IG9wdGlvbnMucHJvamVjdGlvbiB8fCAnRVBTRzozODU3JztcbiAgY29uc3QgdHlwZSA9IGdlb21ldHJ5LmdldFR5cGUoKTtcbiAgaWYgKHR5cGUgIT09ICdHZW9tZXRyeUNvbGxlY3Rpb24nKSB7XG4gICAgZ2VvbWV0cnkgPSBnZW9tZXRyeS5jbG9uZSgpLnRyYW5zZm9ybShwcm9qZWN0aW9uLCAnRVBTRzo0MzI2Jyk7XG4gIH1cbiAgbGV0IGxlbmd0aCA9IDA7XG4gIGxldCBjb29yZGluYXRlcywgY29vcmRzLCBpLCBpaSwgaiwgamo7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ1BvaW50JzpcbiAgICBjYXNlICdNdWx0aVBvaW50Jzoge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgJ0xpbmVTdHJpbmcnOlxuICAgIGNhc2UgJ0xpbmVhclJpbmcnOiB7XG4gICAgICBjb29yZGluYXRlcyA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi9nZW9tL1NpbXBsZUdlb21ldHJ5LmpzXCIpLmRlZmF1bHR9ICovIChcbiAgICAgICAgZ2VvbWV0cnlcbiAgICAgICkuZ2V0Q29vcmRpbmF0ZXMoKTtcbiAgICAgIGxlbmd0aCA9IGdldExlbmd0aEludGVybmFsKGNvb3JkaW5hdGVzLCByYWRpdXMpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgJ011bHRpTGluZVN0cmluZyc6XG4gICAgY2FzZSAnUG9seWdvbic6IHtcbiAgICAgIGNvb3JkaW5hdGVzID0gLyoqIEB0eXBlIHtpbXBvcnQoXCIuL2dlb20vU2ltcGxlR2VvbWV0cnkuanNcIikuZGVmYXVsdH0gKi8gKFxuICAgICAgICBnZW9tZXRyeVxuICAgICAgKS5nZXRDb29yZGluYXRlcygpO1xuICAgICAgZm9yIChpID0gMCwgaWkgPSBjb29yZGluYXRlcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgIGxlbmd0aCArPSBnZXRMZW5ndGhJbnRlcm5hbChjb29yZGluYXRlc1tpXSwgcmFkaXVzKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlICdNdWx0aVBvbHlnb24nOiB7XG4gICAgICBjb29yZGluYXRlcyA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi9nZW9tL1NpbXBsZUdlb21ldHJ5LmpzXCIpLmRlZmF1bHR9ICovIChcbiAgICAgICAgZ2VvbWV0cnlcbiAgICAgICkuZ2V0Q29vcmRpbmF0ZXMoKTtcbiAgICAgIGZvciAoaSA9IDAsIGlpID0gY29vcmRpbmF0ZXMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICBjb29yZHMgPSBjb29yZGluYXRlc1tpXTtcbiAgICAgICAgZm9yIChqID0gMCwgamogPSBjb29yZHMubGVuZ3RoOyBqIDwgamo7ICsraikge1xuICAgICAgICAgIGxlbmd0aCArPSBnZXRMZW5ndGhJbnRlcm5hbChjb29yZHNbal0sIHJhZGl1cyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlICdHZW9tZXRyeUNvbGxlY3Rpb24nOiB7XG4gICAgICBjb25zdCBnZW9tZXRyaWVzID1cbiAgICAgICAgLyoqIEB0eXBlIHtpbXBvcnQoXCIuL2dlb20vR2VvbWV0cnlDb2xsZWN0aW9uLmpzXCIpLmRlZmF1bHR9ICovIChcbiAgICAgICAgICBnZW9tZXRyeVxuICAgICAgICApLmdldEdlb21ldHJpZXMoKTtcbiAgICAgIGZvciAoaSA9IDAsIGlpID0gZ2VvbWV0cmllcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgIGxlbmd0aCArPSBnZXRMZW5ndGgoZ2VvbWV0cmllc1tpXSwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgZGVmYXVsdDoge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBnZW9tZXRyeSB0eXBlOiAnICsgdHlwZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBsZW5ndGg7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgc3BoZXJpY2FsIGFyZWEgZm9yIGEgbGlzdCBvZiBjb29yZGluYXRlcy5cbiAqXG4gKiBbUmVmZXJlbmNlXShodHRwczovL3Rycy5qcGwubmFzYS5nb3YvaGFuZGxlLzIwMTQvNDA0MDkpXG4gKiBSb2JlcnQuIEcuIENoYW1iZXJsYWluIGFuZCBXaWxsaWFtIEguIER1cXVldHRlLCBcIlNvbWUgQWxnb3JpdGhtcyBmb3JcbiAqIFBvbHlnb25zIG9uIGEgU3BoZXJlXCIsIEpQTCBQdWJsaWNhdGlvbiAwNy0wMywgSmV0IFByb3B1bHNpb25cbiAqIExhYm9yYXRvcnksIFBhc2FkZW5hLCBDQSwgSnVuZSAyMDA3XG4gKlxuICogQHBhcmFtIHtBcnJheTxpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZT59IGNvb3JkaW5hdGVzIExpc3Qgb2YgY29vcmRpbmF0ZXMgb2YgYSBsaW5lYXJcbiAqIHJpbmcuIElmIHRoZSByaW5nIGlzIG9yaWVudGVkIGNsb2Nrd2lzZSwgdGhlIGFyZWEgd2lsbCBiZSBwb3NpdGl2ZSxcbiAqIG90aGVyd2lzZSBpdCB3aWxsIGJlIG5lZ2F0aXZlLlxuICogQHBhcmFtIHtudW1iZXJ9IHJhZGl1cyBUaGUgc3BoZXJlIHJhZGl1cy5cbiAqIEByZXR1cm4ge251bWJlcn0gQXJlYSAoaW4gc3F1YXJlIG1ldGVycykuXG4gKi9cbmZ1bmN0aW9uIGdldEFyZWFJbnRlcm5hbChjb29yZGluYXRlcywgcmFkaXVzKSB7XG4gIGxldCBhcmVhID0gMDtcbiAgY29uc3QgbGVuID0gY29vcmRpbmF0ZXMubGVuZ3RoO1xuICBsZXQgeDEgPSBjb29yZGluYXRlc1tsZW4gLSAxXVswXTtcbiAgbGV0IHkxID0gY29vcmRpbmF0ZXNbbGVuIC0gMV1bMV07XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBjb25zdCB4MiA9IGNvb3JkaW5hdGVzW2ldWzBdO1xuICAgIGNvbnN0IHkyID0gY29vcmRpbmF0ZXNbaV1bMV07XG4gICAgYXJlYSArPVxuICAgICAgdG9SYWRpYW5zKHgyIC0geDEpICpcbiAgICAgICgyICsgTWF0aC5zaW4odG9SYWRpYW5zKHkxKSkgKyBNYXRoLnNpbih0b1JhZGlhbnMoeTIpKSk7XG4gICAgeDEgPSB4MjtcbiAgICB5MSA9IHkyO1xuICB9XG4gIHJldHVybiAoYXJlYSAqIHJhZGl1cyAqIHJhZGl1cykgLyAyLjA7XG59XG5cbi8qKlxuICogR2V0IHRoZSBzcGhlcmljYWwgYXJlYSBvZiBhIGdlb21ldHJ5LiAgVGhpcyBpcyB0aGUgYXJlYSAoaW4gbWV0ZXJzKSBhc3N1bWluZ1xuICogdGhhdCBwb2x5Z29uIGVkZ2VzIGFyZSBzZWdtZW50cyBvZiBncmVhdCBjaXJjbGVzIG9uIGEgc3BoZXJlLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL2dlb20vR2VvbWV0cnkuanNcIikuZGVmYXVsdH0gZ2VvbWV0cnkgQSBnZW9tZXRyeS5cbiAqIEBwYXJhbSB7U3BoZXJlTWV0cmljT3B0aW9uc30gW29wdGlvbnNdIE9wdGlvbnMgZm9yIHRoZSBhcmVhXG4gKiAgICAgY2FsY3VsYXRpb24uICBCeSBkZWZhdWx0LCBnZW9tZXRyaWVzIGFyZSBhc3N1bWVkIHRvIGJlIGluICdFUFNHOjM4NTcnLlxuICogICAgIFlvdSBjYW4gY2hhbmdlIHRoaXMgYnkgcHJvdmlkaW5nIGEgYHByb2plY3Rpb25gIG9wdGlvbi5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIHNwaGVyaWNhbCBhcmVhIChpbiBzcXVhcmUgbWV0ZXJzKS5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEFyZWEoZ2VvbWV0cnksIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGNvbnN0IHJhZGl1cyA9IG9wdGlvbnMucmFkaXVzIHx8IERFRkFVTFRfUkFESVVTO1xuICBjb25zdCBwcm9qZWN0aW9uID0gb3B0aW9ucy5wcm9qZWN0aW9uIHx8ICdFUFNHOjM4NTcnO1xuICBjb25zdCB0eXBlID0gZ2VvbWV0cnkuZ2V0VHlwZSgpO1xuICBpZiAodHlwZSAhPT0gJ0dlb21ldHJ5Q29sbGVjdGlvbicpIHtcbiAgICBnZW9tZXRyeSA9IGdlb21ldHJ5LmNsb25lKCkudHJhbnNmb3JtKHByb2plY3Rpb24sICdFUFNHOjQzMjYnKTtcbiAgfVxuICBsZXQgYXJlYSA9IDA7XG4gIGxldCBjb29yZGluYXRlcywgY29vcmRzLCBpLCBpaSwgaiwgamo7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ1BvaW50JzpcbiAgICBjYXNlICdNdWx0aVBvaW50JzpcbiAgICBjYXNlICdMaW5lU3RyaW5nJzpcbiAgICBjYXNlICdNdWx0aUxpbmVTdHJpbmcnOlxuICAgIGNhc2UgJ0xpbmVhclJpbmcnOiB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSAnUG9seWdvbic6IHtcbiAgICAgIGNvb3JkaW5hdGVzID0gLyoqIEB0eXBlIHtpbXBvcnQoXCIuL2dlb20vUG9seWdvbi5qc1wiKS5kZWZhdWx0fSAqLyAoXG4gICAgICAgIGdlb21ldHJ5XG4gICAgICApLmdldENvb3JkaW5hdGVzKCk7XG4gICAgICBhcmVhID0gTWF0aC5hYnMoZ2V0QXJlYUludGVybmFsKGNvb3JkaW5hdGVzWzBdLCByYWRpdXMpKTtcbiAgICAgIGZvciAoaSA9IDEsIGlpID0gY29vcmRpbmF0ZXMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICBhcmVhIC09IE1hdGguYWJzKGdldEFyZWFJbnRlcm5hbChjb29yZGluYXRlc1tpXSwgcmFkaXVzKSk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSAnTXVsdGlQb2x5Z29uJzoge1xuICAgICAgY29vcmRpbmF0ZXMgPSAvKiogQHR5cGUge2ltcG9ydChcIi4vZ2VvbS9TaW1wbGVHZW9tZXRyeS5qc1wiKS5kZWZhdWx0fSAqLyAoXG4gICAgICAgIGdlb21ldHJ5XG4gICAgICApLmdldENvb3JkaW5hdGVzKCk7XG4gICAgICBmb3IgKGkgPSAwLCBpaSA9IGNvb3JkaW5hdGVzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgY29vcmRzID0gY29vcmRpbmF0ZXNbaV07XG4gICAgICAgIGFyZWEgKz0gTWF0aC5hYnMoZ2V0QXJlYUludGVybmFsKGNvb3Jkc1swXSwgcmFkaXVzKSk7XG4gICAgICAgIGZvciAoaiA9IDEsIGpqID0gY29vcmRzLmxlbmd0aDsgaiA8IGpqOyArK2opIHtcbiAgICAgICAgICBhcmVhIC09IE1hdGguYWJzKGdldEFyZWFJbnRlcm5hbChjb29yZHNbal0sIHJhZGl1cykpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSAnR2VvbWV0cnlDb2xsZWN0aW9uJzoge1xuICAgICAgY29uc3QgZ2VvbWV0cmllcyA9XG4gICAgICAgIC8qKiBAdHlwZSB7aW1wb3J0KFwiLi9nZW9tL0dlb21ldHJ5Q29sbGVjdGlvbi5qc1wiKS5kZWZhdWx0fSAqLyAoXG4gICAgICAgICAgZ2VvbWV0cnlcbiAgICAgICAgKS5nZXRHZW9tZXRyaWVzKCk7XG4gICAgICBmb3IgKGkgPSAwLCBpaSA9IGdlb21ldHJpZXMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICBhcmVhICs9IGdldEFyZWEoZ2VvbWV0cmllc1tpXSwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgZGVmYXVsdDoge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBnZW9tZXRyeSB0eXBlOiAnICsgdHlwZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBhcmVhO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGNvb3JkaW5hdGUgYXQgdGhlIGdpdmVuIGRpc3RhbmNlIGFuZCBiZWFyaW5nIGZyb20gYGMxYC5cbiAqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBjMSBUaGUgb3JpZ2luIHBvaW50IChgW2xvbiwgbGF0XWAgaW4gZGVncmVlcykuXG4gKiBAcGFyYW0ge251bWJlcn0gZGlzdGFuY2UgVGhlIGdyZWF0LWNpcmNsZSBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBvcmlnaW5cbiAqICAgICBwb2ludCBhbmQgdGhlIHRhcmdldCBwb2ludC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiZWFyaW5nIFRoZSBiZWFyaW5nIChpbiByYWRpYW5zKS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbcmFkaXVzXSBUaGUgc3BoZXJlIHJhZGl1cyB0byB1c2UuICBEZWZhdWx0cyB0byB0aGUgRWFydGgnc1xuICogICAgIG1lYW4gcmFkaXVzIHVzaW5nIHRoZSBXR1M4NCBlbGxpcHNvaWQuXG4gKiBAcmV0dXJuIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gVGhlIHRhcmdldCBwb2ludC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG9mZnNldChjMSwgZGlzdGFuY2UsIGJlYXJpbmcsIHJhZGl1cykge1xuICByYWRpdXMgPSByYWRpdXMgfHwgREVGQVVMVF9SQURJVVM7XG4gIGNvbnN0IGxhdDEgPSB0b1JhZGlhbnMoYzFbMV0pO1xuICBjb25zdCBsb24xID0gdG9SYWRpYW5zKGMxWzBdKTtcbiAgY29uc3QgZEJ5UiA9IGRpc3RhbmNlIC8gcmFkaXVzO1xuICBjb25zdCBsYXQgPSBNYXRoLmFzaW4oXG4gICAgTWF0aC5zaW4obGF0MSkgKiBNYXRoLmNvcyhkQnlSKSArXG4gICAgICBNYXRoLmNvcyhsYXQxKSAqIE1hdGguc2luKGRCeVIpICogTWF0aC5jb3MoYmVhcmluZylcbiAgKTtcbiAgY29uc3QgbG9uID1cbiAgICBsb24xICtcbiAgICBNYXRoLmF0YW4yKFxuICAgICAgTWF0aC5zaW4oYmVhcmluZykgKiBNYXRoLnNpbihkQnlSKSAqIE1hdGguY29zKGxhdDEpLFxuICAgICAgTWF0aC5jb3MoZEJ5UikgLSBNYXRoLnNpbihsYXQxKSAqIE1hdGguc2luKGxhdClcbiAgICApO1xuICByZXR1cm4gW3RvRGVncmVlcyhsb24pLCB0b0RlZ3JlZXMobGF0KV07XG59XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvc3RyaW5nXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gbnVtYmVyIE51bWJlciB0byBiZSBmb3JtYXR0ZWRcbiAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCBUaGUgZGVzaXJlZCB3aWR0aFxuICogQHBhcmFtIHtudW1iZXJ9IFtwcmVjaXNpb25dIFByZWNpc2lvbiBvZiB0aGUgb3V0cHV0IHN0cmluZyAoaS5lLiBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMpXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEZvcm1hdHRlZCBzdHJpbmdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhZE51bWJlcihudW1iZXIsIHdpZHRoLCBwcmVjaXNpb24pIHtcbiAgY29uc3QgbnVtYmVyU3RyaW5nID1cbiAgICBwcmVjaXNpb24gIT09IHVuZGVmaW5lZCA/IG51bWJlci50b0ZpeGVkKHByZWNpc2lvbikgOiAnJyArIG51bWJlcjtcbiAgbGV0IGRlY2ltYWwgPSBudW1iZXJTdHJpbmcuaW5kZXhPZignLicpO1xuICBkZWNpbWFsID0gZGVjaW1hbCA9PT0gLTEgPyBudW1iZXJTdHJpbmcubGVuZ3RoIDogZGVjaW1hbDtcbiAgcmV0dXJuIGRlY2ltYWwgPiB3aWR0aFxuICAgID8gbnVtYmVyU3RyaW5nXG4gICAgOiBuZXcgQXJyYXkoMSArIHdpZHRoIC0gZGVjaW1hbCkuam9pbignMCcpICsgbnVtYmVyU3RyaW5nO1xufVxuXG4vKipcbiAqIEFkYXB0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vb21pY2hlbHNlbi9jb21wYXJlLXZlcnNpb25zL2Jsb2IvbWFzdGVyL2luZGV4LmpzXG4gKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IHYxIEZpcnN0IHZlcnNpb25cbiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gdjIgU2Vjb25kIHZlcnNpb25cbiAqIEByZXR1cm4ge251bWJlcn0gVmFsdWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbXBhcmVWZXJzaW9ucyh2MSwgdjIpIHtcbiAgY29uc3QgczEgPSAoJycgKyB2MSkuc3BsaXQoJy4nKTtcbiAgY29uc3QgczIgPSAoJycgKyB2Mikuc3BsaXQoJy4nKTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IE1hdGgubWF4KHMxLmxlbmd0aCwgczIubGVuZ3RoKTsgaSsrKSB7XG4gICAgY29uc3QgbjEgPSBwYXJzZUludChzMVtpXSB8fCAnMCcsIDEwKTtcbiAgICBjb25zdCBuMiA9IHBhcnNlSW50KHMyW2ldIHx8ICcwJywgMTApO1xuXG4gICAgaWYgKG4xID4gbjIpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICBpZiAobjIgPiBuMSkge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAwO1xufVxuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3N0cnVjdHMvTFJVQ2FjaGVcbiAqL1xuXG5pbXBvcnQge2Fzc2VydH0gZnJvbSAnLi4vYXNzZXJ0cy5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gRW50cnlcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBrZXlfIEtleS5cbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBuZXdlciBOZXdlci5cbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBvbGRlciBPbGRlci5cbiAqIEBwcm9wZXJ0eSB7Kn0gdmFsdWVfIFZhbHVlLlxuICovXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogSW1wbGVtZW50cyBhIExlYXN0LVJlY2VudGx5LVVzZWQgY2FjaGUgd2hlcmUgdGhlIGtleXMgZG8gbm90IGNvbmZsaWN0IHdpdGhcbiAqIE9iamVjdCdzIHByb3BlcnRpZXMgKGUuZy4gJ2hhc093blByb3BlcnR5JyBpcyBub3QgYWxsb3dlZCBhcyBhIGtleSkuIEV4cGlyaW5nXG4gKiBpdGVtcyBmcm9tIHRoZSBjYWNoZSBpcyB0aGUgcmVzcG9uc2liaWxpdHkgb2YgdGhlIHVzZXIuXG4gKlxuICogQGZpcmVzIGltcG9ydChcIi4uL2V2ZW50cy9FdmVudC5qc1wiKS5kZWZhdWx0XG4gKiBAdGVtcGxhdGUgVFxuICovXG5jbGFzcyBMUlVDYWNoZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gW2hpZ2hXYXRlck1hcmtdIEhpZ2ggd2F0ZXIgbWFyay5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGhpZ2hXYXRlck1hcmspIHtcbiAgICAvKipcbiAgICAgKiBEZXNpcmVkIG1heCBjYWNoZSBzaXplIGFmdGVyIGV4cGlyZUNhY2hlKCkuIElmIHNldCB0byAwLCBubyBjYWNoZSBlbnRyaWVzXG4gICAgICogd2lsbCBiZSBwcnVuZWQgYXQgYWxsLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gaGlnaFdhdGVyTWFyayAhPT0gdW5kZWZpbmVkID8gaGlnaFdhdGVyTWFyayA6IDIwNDg7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5jb3VudF8gPSAwO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7IU9iamVjdDxzdHJpbmcsIEVudHJ5Pn1cbiAgICAgKi9cbiAgICB0aGlzLmVudHJpZXNfID0ge307XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHs/RW50cnl9XG4gICAgICovXG4gICAgdGhpcy5vbGRlc3RfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgez9FbnRyeX1cbiAgICAgKi9cbiAgICB0aGlzLm5ld2VzdF8gPSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IENhbiBleHBpcmUgY2FjaGUuXG4gICAqL1xuICBjYW5FeHBpcmVDYWNoZSgpIHtcbiAgICByZXR1cm4gdGhpcy5oaWdoV2F0ZXJNYXJrID4gMCAmJiB0aGlzLmdldENvdW50KCkgPiB0aGlzLmhpZ2hXYXRlck1hcms7XG4gIH1cblxuICAvKipcbiAgICogRXhwaXJlIHRoZSBjYWNoZS5cbiAgICogQHBhcmFtIHshT2JqZWN0PHN0cmluZywgYm9vbGVhbj59IFtrZWVwXSBLZXlzIHRvIGtlZXAuIFRvIGJlIGltcGxlbWVudGVkIGJ5IHN1YmNsYXNzZXMuXG4gICAqL1xuICBleHBpcmVDYWNoZShrZWVwKSB7XG4gICAgd2hpbGUgKHRoaXMuY2FuRXhwaXJlQ2FjaGUoKSkge1xuICAgICAgdGhpcy5wb3AoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRklYTUUgZW1wdHkgZGVzY3JpcHRpb24gZm9yIGpzZG9jXG4gICAqL1xuICBjbGVhcigpIHtcbiAgICB0aGlzLmNvdW50XyA9IDA7XG4gICAgdGhpcy5lbnRyaWVzXyA9IHt9O1xuICAgIHRoaXMub2xkZXN0XyA9IG51bGw7XG4gICAgdGhpcy5uZXdlc3RfID0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IEtleS5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gQ29udGFpbnMga2V5LlxuICAgKi9cbiAgY29udGFpbnNLZXkoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuZW50cmllc18uaGFzT3duUHJvcGVydHkoa2V5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKFQsIHN0cmluZywgTFJVQ2FjaGU8VD4pOiA/fSBmIFRoZSBmdW5jdGlvblxuICAgKiAgICAgdG8gY2FsbCBmb3IgZXZlcnkgZW50cnkgZnJvbSB0aGUgb2xkZXN0IHRvIHRoZSBuZXdlci4gVGhpcyBmdW5jdGlvbiB0YWtlc1xuICAgKiAgICAgMyBhcmd1bWVudHMgKHRoZSBlbnRyeSB2YWx1ZSwgdGhlIGVudHJ5IGtleSBhbmQgdGhlIExSVUNhY2hlIG9iamVjdCkuXG4gICAqICAgICBUaGUgcmV0dXJuIHZhbHVlIGlzIGlnbm9yZWQuXG4gICAqL1xuICBmb3JFYWNoKGYpIHtcbiAgICBsZXQgZW50cnkgPSB0aGlzLm9sZGVzdF87XG4gICAgd2hpbGUgKGVudHJ5KSB7XG4gICAgICBmKGVudHJ5LnZhbHVlXywgZW50cnkua2V5XywgdGhpcyk7XG4gICAgICBlbnRyeSA9IGVudHJ5Lm5ld2VyO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IEtleS5cbiAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3B0aW9ucyAocmVzZXJ2ZWQgZm9yIHN1YmNsYXNzZXMpLlxuICAgKiBAcmV0dXJuIHtUfSBWYWx1ZS5cbiAgICovXG4gIGdldChrZXksIG9wdGlvbnMpIHtcbiAgICBjb25zdCBlbnRyeSA9IHRoaXMuZW50cmllc19ba2V5XTtcbiAgICBhc3NlcnQoXG4gICAgICBlbnRyeSAhPT0gdW5kZWZpbmVkLFxuICAgICAgJ1RyaWVkIHRvIGdldCBhIHZhbHVlIGZvciBhIGtleSB0aGF0IGRvZXMgbm90IGV4aXN0IGluIHRoZSBjYWNoZSdcbiAgICApO1xuICAgIGlmIChlbnRyeSA9PT0gdGhpcy5uZXdlc3RfKSB7XG4gICAgICByZXR1cm4gZW50cnkudmFsdWVfO1xuICAgIH1cbiAgICBpZiAoZW50cnkgPT09IHRoaXMub2xkZXN0Xykge1xuICAgICAgdGhpcy5vbGRlc3RfID0gLyoqIEB0eXBlIHtFbnRyeX0gKi8gKHRoaXMub2xkZXN0Xy5uZXdlcik7XG4gICAgICB0aGlzLm9sZGVzdF8ub2xkZXIgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbnRyeS5uZXdlci5vbGRlciA9IGVudHJ5Lm9sZGVyO1xuICAgICAgZW50cnkub2xkZXIubmV3ZXIgPSBlbnRyeS5uZXdlcjtcbiAgICB9XG4gICAgZW50cnkubmV3ZXIgPSBudWxsO1xuICAgIGVudHJ5Lm9sZGVyID0gdGhpcy5uZXdlc3RfO1xuICAgIHRoaXMubmV3ZXN0Xy5uZXdlciA9IGVudHJ5O1xuICAgIHRoaXMubmV3ZXN0XyA9IGVudHJ5O1xuICAgIHJldHVybiBlbnRyeS52YWx1ZV87XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGFuIGVudHJ5IGZyb20gdGhlIGNhY2hlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBlbnRyeSBrZXkuXG4gICAqIEByZXR1cm4ge1R9IFRoZSByZW1vdmVkIGVudHJ5LlxuICAgKi9cbiAgcmVtb3ZlKGtleSkge1xuICAgIGNvbnN0IGVudHJ5ID0gdGhpcy5lbnRyaWVzX1trZXldO1xuICAgIGFzc2VydChcbiAgICAgIGVudHJ5ICE9PSB1bmRlZmluZWQsXG4gICAgICAnVHJpZWQgdG8gZ2V0IGEgdmFsdWUgZm9yIGEga2V5IHRoYXQgZG9lcyBub3QgZXhpc3QgaW4gdGhlIGNhY2hlJ1xuICAgICk7XG4gICAgaWYgKGVudHJ5ID09PSB0aGlzLm5ld2VzdF8pIHtcbiAgICAgIHRoaXMubmV3ZXN0XyA9IC8qKiBAdHlwZSB7RW50cnl9ICovIChlbnRyeS5vbGRlcik7XG4gICAgICBpZiAodGhpcy5uZXdlc3RfKSB7XG4gICAgICAgIHRoaXMubmV3ZXN0Xy5uZXdlciA9IG51bGw7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChlbnRyeSA9PT0gdGhpcy5vbGRlc3RfKSB7XG4gICAgICB0aGlzLm9sZGVzdF8gPSAvKiogQHR5cGUge0VudHJ5fSAqLyAoZW50cnkubmV3ZXIpO1xuICAgICAgaWYgKHRoaXMub2xkZXN0Xykge1xuICAgICAgICB0aGlzLm9sZGVzdF8ub2xkZXIgPSBudWxsO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlbnRyeS5uZXdlci5vbGRlciA9IGVudHJ5Lm9sZGVyO1xuICAgICAgZW50cnkub2xkZXIubmV3ZXIgPSBlbnRyeS5uZXdlcjtcbiAgICB9XG4gICAgZGVsZXRlIHRoaXMuZW50cmllc19ba2V5XTtcbiAgICAtLXRoaXMuY291bnRfO1xuICAgIHJldHVybiBlbnRyeS52YWx1ZV87XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfSBDb3VudC5cbiAgICovXG4gIGdldENvdW50KCkge1xuICAgIHJldHVybiB0aGlzLmNvdW50XztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtBcnJheTxzdHJpbmc+fSBLZXlzLlxuICAgKi9cbiAgZ2V0S2V5cygpIHtcbiAgICBjb25zdCBrZXlzID0gbmV3IEFycmF5KHRoaXMuY291bnRfKTtcbiAgICBsZXQgaSA9IDA7XG4gICAgbGV0IGVudHJ5O1xuICAgIGZvciAoZW50cnkgPSB0aGlzLm5ld2VzdF87IGVudHJ5OyBlbnRyeSA9IGVudHJ5Lm9sZGVyKSB7XG4gICAgICBrZXlzW2krK10gPSBlbnRyeS5rZXlfO1xuICAgIH1cbiAgICByZXR1cm4ga2V5cztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtBcnJheTxUPn0gVmFsdWVzLlxuICAgKi9cbiAgZ2V0VmFsdWVzKCkge1xuICAgIGNvbnN0IHZhbHVlcyA9IG5ldyBBcnJheSh0aGlzLmNvdW50Xyk7XG4gICAgbGV0IGkgPSAwO1xuICAgIGxldCBlbnRyeTtcbiAgICBmb3IgKGVudHJ5ID0gdGhpcy5uZXdlc3RfOyBlbnRyeTsgZW50cnkgPSBlbnRyeS5vbGRlcikge1xuICAgICAgdmFsdWVzW2krK10gPSBlbnRyeS52YWx1ZV87XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZXM7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7VH0gTGFzdCB2YWx1ZS5cbiAgICovXG4gIHBlZWtMYXN0KCkge1xuICAgIHJldHVybiB0aGlzLm9sZGVzdF8udmFsdWVfO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge3N0cmluZ30gTGFzdCBrZXkuXG4gICAqL1xuICBwZWVrTGFzdEtleSgpIHtcbiAgICByZXR1cm4gdGhpcy5vbGRlc3RfLmtleV87XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBrZXkgb2YgdGhlIG5ld2VzdCBpdGVtIGluIHRoZSBjYWNoZS4gIFRocm93cyBpZiB0aGUgY2FjaGUgaXMgZW1wdHkuXG4gICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIG5ld2VzdCBrZXkuXG4gICAqL1xuICBwZWVrRmlyc3RLZXkoKSB7XG4gICAgcmV0dXJuIHRoaXMubmV3ZXN0Xy5rZXlfO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhbiBlbnRyeSB3aXRob3V0IHVwZGF0aW5nIGxlYXN0IHJlY2VudGx5IHVzZWQgdGltZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBLZXkuXG4gICAqIEByZXR1cm4ge1R9IFZhbHVlLlxuICAgKi9cbiAgcGVlayhrZXkpIHtcbiAgICBpZiAoIXRoaXMuY29udGFpbnNLZXkoa2V5KSkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZW50cmllc19ba2V5XS52YWx1ZV87XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7VH0gdmFsdWUgVmFsdWUuXG4gICAqL1xuICBwb3AoKSB7XG4gICAgY29uc3QgZW50cnkgPSB0aGlzLm9sZGVzdF87XG4gICAgZGVsZXRlIHRoaXMuZW50cmllc19bZW50cnkua2V5X107XG4gICAgaWYgKGVudHJ5Lm5ld2VyKSB7XG4gICAgICBlbnRyeS5uZXdlci5vbGRlciA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMub2xkZXN0XyA9IC8qKiBAdHlwZSB7RW50cnl9ICovIChlbnRyeS5uZXdlcik7XG4gICAgaWYgKCF0aGlzLm9sZGVzdF8pIHtcbiAgICAgIHRoaXMubmV3ZXN0XyA9IG51bGw7XG4gICAgfVxuICAgIC0tdGhpcy5jb3VudF87XG4gICAgcmV0dXJuIGVudHJ5LnZhbHVlXztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IEtleS5cbiAgICogQHBhcmFtIHtUfSB2YWx1ZSBWYWx1ZS5cbiAgICovXG4gIHJlcGxhY2Uoa2V5LCB2YWx1ZSkge1xuICAgIHRoaXMuZ2V0KGtleSk7IC8vIHVwZGF0ZSBgbmV3ZXN0X2BcbiAgICB0aGlzLmVudHJpZXNfW2tleV0udmFsdWVfID0gdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBLZXkuXG4gICAqIEBwYXJhbSB7VH0gdmFsdWUgVmFsdWUuXG4gICAqL1xuICBzZXQoa2V5LCB2YWx1ZSkge1xuICAgIGFzc2VydChcbiAgICAgICEoa2V5IGluIHRoaXMuZW50cmllc18pLFxuICAgICAgJ1RyaWVkIHRvIHNldCBhIHZhbHVlIGZvciBhIGtleSB0aGF0IGlzIHVzZWQgYWxyZWFkeSdcbiAgICApO1xuICAgIGNvbnN0IGVudHJ5ID0ge1xuICAgICAga2V5Xzoga2V5LFxuICAgICAgbmV3ZXI6IG51bGwsXG4gICAgICBvbGRlcjogdGhpcy5uZXdlc3RfLFxuICAgICAgdmFsdWVfOiB2YWx1ZSxcbiAgICB9O1xuICAgIGlmICghdGhpcy5uZXdlc3RfKSB7XG4gICAgICB0aGlzLm9sZGVzdF8gPSBlbnRyeTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5uZXdlc3RfLm5ld2VyID0gZW50cnk7XG4gICAgfVxuICAgIHRoaXMubmV3ZXN0XyA9IGVudHJ5O1xuICAgIHRoaXMuZW50cmllc19ba2V5XSA9IGVudHJ5O1xuICAgICsrdGhpcy5jb3VudF87XG4gIH1cblxuICAvKipcbiAgICogU2V0IGEgbWF4aW11bSBudW1iZXIgb2YgZW50cmllcyBmb3IgdGhlIGNhY2hlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gc2l6ZSBDYWNoZSBzaXplLlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRTaXplKHNpemUpIHtcbiAgICB0aGlzLmhpZ2hXYXRlck1hcmsgPSBzaXplO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IExSVUNhY2hlO1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3N0cnVjdHMvUHJpb3JpdHlRdWV1ZVxuICovXG5pbXBvcnQge2Fzc2VydH0gZnJvbSAnLi4vYXNzZXJ0cy5qcyc7XG5pbXBvcnQge2NsZWFyfSBmcm9tICcuLi9vYmouanMnO1xuXG4vKipcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCBEUk9QID0gSW5maW5pdHk7XG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogUHJpb3JpdHkgcXVldWUuXG4gKlxuICogVGhlIGltcGxlbWVudGF0aW9uIGlzIGluc3BpcmVkIGZyb20gdGhlIENsb3N1cmUgTGlicmFyeSdzIEhlYXAgY2xhc3MgYW5kXG4gKiBQeXRob24ncyBoZWFwcSBtb2R1bGUuXG4gKlxuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9nb29nbGUvY2xvc3VyZS1saWJyYXJ5L2Jsb2IvbWFzdGVyL2Nsb3N1cmUvZ29vZy9zdHJ1Y3RzL2hlYXAuanNcbiAqIGFuZCBodHRwczovL2hnLnB5dGhvbi5vcmcvY3B5dGhvbi9maWxlLzIuNy9MaWIvaGVhcHEucHkuXG4gKlxuICogQHRlbXBsYXRlIFRcbiAqL1xuY2xhc3MgUHJpb3JpdHlRdWV1ZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKFQpOiBudW1iZXJ9IHByaW9yaXR5RnVuY3Rpb24gUHJpb3JpdHkgZnVuY3Rpb24uXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oVCk6IHN0cmluZ30ga2V5RnVuY3Rpb24gS2V5IGZ1bmN0aW9uLlxuICAgKi9cbiAgY29uc3RydWN0b3IocHJpb3JpdHlGdW5jdGlvbiwga2V5RnVuY3Rpb24pIHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7ZnVuY3Rpb24oVCk6IG51bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMucHJpb3JpdHlGdW5jdGlvbl8gPSBwcmlvcml0eUZ1bmN0aW9uO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge2Z1bmN0aW9uKFQpOiBzdHJpbmd9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmtleUZ1bmN0aW9uXyA9IGtleUZ1bmN0aW9uO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge0FycmF5PFQ+fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5lbGVtZW50c18gPSBbXTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtBcnJheTxudW1iZXI+fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5wcmlvcml0aWVzXyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUgeyFPYmplY3Q8c3RyaW5nLCBib29sZWFuPn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMucXVldWVkRWxlbWVudHNfID0ge307XG4gIH1cblxuICAvKipcbiAgICogRklYTUUgZW1wdHkgZGVzY3JpcHRpb24gZm9yIGpzZG9jXG4gICAqL1xuICBjbGVhcigpIHtcbiAgICB0aGlzLmVsZW1lbnRzXy5sZW5ndGggPSAwO1xuICAgIHRoaXMucHJpb3JpdGllc18ubGVuZ3RoID0gMDtcbiAgICBjbGVhcih0aGlzLnF1ZXVlZEVsZW1lbnRzXyk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGFuZCByZXR1cm4gdGhlIGhpZ2hlc3QtcHJpb3JpdHkgZWxlbWVudC4gTyhsb2cgTikuXG4gICAqIEByZXR1cm4ge1R9IEVsZW1lbnQuXG4gICAqL1xuICBkZXF1ZXVlKCkge1xuICAgIGNvbnN0IGVsZW1lbnRzID0gdGhpcy5lbGVtZW50c187XG4gICAgY29uc3QgcHJpb3JpdGllcyA9IHRoaXMucHJpb3JpdGllc187XG4gICAgY29uc3QgZWxlbWVudCA9IGVsZW1lbnRzWzBdO1xuICAgIGlmIChlbGVtZW50cy5sZW5ndGggPT0gMSkge1xuICAgICAgZWxlbWVudHMubGVuZ3RoID0gMDtcbiAgICAgIHByaW9yaXRpZXMubGVuZ3RoID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbWVudHNbMF0gPSBlbGVtZW50cy5wb3AoKTtcbiAgICAgIHByaW9yaXRpZXNbMF0gPSBwcmlvcml0aWVzLnBvcCgpO1xuICAgICAgdGhpcy5zaWZ0VXBfKDApO1xuICAgIH1cbiAgICBjb25zdCBlbGVtZW50S2V5ID0gdGhpcy5rZXlGdW5jdGlvbl8oZWxlbWVudCk7XG4gICAgZGVsZXRlIHRoaXMucXVldWVkRWxlbWVudHNfW2VsZW1lbnRLZXldO1xuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG5cbiAgLyoqXG4gICAqIEVucXVldWUgYW4gZWxlbWVudC4gTyhsb2cgTikuXG4gICAqIEBwYXJhbSB7VH0gZWxlbWVudCBFbGVtZW50LlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUaGUgZWxlbWVudCB3YXMgYWRkZWQgdG8gdGhlIHF1ZXVlLlxuICAgKi9cbiAgZW5xdWV1ZShlbGVtZW50KSB7XG4gICAgYXNzZXJ0KFxuICAgICAgISh0aGlzLmtleUZ1bmN0aW9uXyhlbGVtZW50KSBpbiB0aGlzLnF1ZXVlZEVsZW1lbnRzXyksXG4gICAgICAnVHJpZWQgdG8gZW5xdWV1ZSBhbiBgZWxlbWVudGAgdGhhdCB3YXMgYWxyZWFkeSBhZGRlZCB0byB0aGUgcXVldWUnXG4gICAgKTtcbiAgICBjb25zdCBwcmlvcml0eSA9IHRoaXMucHJpb3JpdHlGdW5jdGlvbl8oZWxlbWVudCk7XG4gICAgaWYgKHByaW9yaXR5ICE9IERST1ApIHtcbiAgICAgIHRoaXMuZWxlbWVudHNfLnB1c2goZWxlbWVudCk7XG4gICAgICB0aGlzLnByaW9yaXRpZXNfLnB1c2gocHJpb3JpdHkpO1xuICAgICAgdGhpcy5xdWV1ZWRFbGVtZW50c19bdGhpcy5rZXlGdW5jdGlvbl8oZWxlbWVudCldID0gdHJ1ZTtcbiAgICAgIHRoaXMuc2lmdERvd25fKDAsIHRoaXMuZWxlbWVudHNfLmxlbmd0aCAtIDEpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IENvdW50LlxuICAgKi9cbiAgZ2V0Q291bnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWxlbWVudHNfLmxlbmd0aDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBpbmRleCBvZiB0aGUgbGVmdCBjaGlsZCBvZiB0aGUgbm9kZSBhdCB0aGUgZ2l2ZW4gaW5kZXguXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBUaGUgaW5kZXggb2YgdGhlIG5vZGUgdG8gZ2V0IHRoZSBsZWZ0IGNoaWxkIGZvci5cbiAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgaW5kZXggb2YgdGhlIGxlZnQgY2hpbGQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXRMZWZ0Q2hpbGRJbmRleF8oaW5kZXgpIHtcbiAgICByZXR1cm4gaW5kZXggKiAyICsgMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBpbmRleCBvZiB0aGUgcmlnaHQgY2hpbGQgb2YgdGhlIG5vZGUgYXQgdGhlIGdpdmVuIGluZGV4LlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVGhlIGluZGV4IG9mIHRoZSBub2RlIHRvIGdldCB0aGUgcmlnaHQgY2hpbGQgZm9yLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBpbmRleCBvZiB0aGUgcmlnaHQgY2hpbGQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXRSaWdodENoaWxkSW5kZXhfKGluZGV4KSB7XG4gICAgcmV0dXJuIGluZGV4ICogMiArIDI7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgaW5kZXggb2YgdGhlIHBhcmVudCBvZiB0aGUgbm9kZSBhdCB0aGUgZ2l2ZW4gaW5kZXguXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBUaGUgaW5kZXggb2YgdGhlIG5vZGUgdG8gZ2V0IHRoZSBwYXJlbnQgZm9yLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBpbmRleCBvZiB0aGUgcGFyZW50LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0UGFyZW50SW5kZXhfKGluZGV4KSB7XG4gICAgcmV0dXJuIChpbmRleCAtIDEpID4+IDE7XG4gIH1cblxuICAvKipcbiAgICogTWFrZSB0aGlzIGEgaGVhcC4gTyhOKS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGhlYXBpZnlfKCkge1xuICAgIGxldCBpO1xuICAgIGZvciAoaSA9ICh0aGlzLmVsZW1lbnRzXy5sZW5ndGggPj4gMSkgLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgdGhpcy5zaWZ0VXBfKGkpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBJcyBlbXB0eS5cbiAgICovXG4gIGlzRW1wdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWxlbWVudHNfLmxlbmd0aCA9PT0gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IEtleS5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gSXMga2V5IHF1ZXVlZC5cbiAgICovXG4gIGlzS2V5UXVldWVkKGtleSkge1xuICAgIHJldHVybiBrZXkgaW4gdGhpcy5xdWV1ZWRFbGVtZW50c187XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtUfSBlbGVtZW50IEVsZW1lbnQuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IElzIHF1ZXVlZC5cbiAgICovXG4gIGlzUXVldWVkKGVsZW1lbnQpIHtcbiAgICByZXR1cm4gdGhpcy5pc0tleVF1ZXVlZCh0aGlzLmtleUZ1bmN0aW9uXyhlbGVtZW50KSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSBpbmRleCBvZiB0aGUgbm9kZSB0byBtb3ZlIGRvd24uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzaWZ0VXBfKGluZGV4KSB7XG4gICAgY29uc3QgZWxlbWVudHMgPSB0aGlzLmVsZW1lbnRzXztcbiAgICBjb25zdCBwcmlvcml0aWVzID0gdGhpcy5wcmlvcml0aWVzXztcbiAgICBjb25zdCBjb3VudCA9IGVsZW1lbnRzLmxlbmd0aDtcbiAgICBjb25zdCBlbGVtZW50ID0gZWxlbWVudHNbaW5kZXhdO1xuICAgIGNvbnN0IHByaW9yaXR5ID0gcHJpb3JpdGllc1tpbmRleF07XG4gICAgY29uc3Qgc3RhcnRJbmRleCA9IGluZGV4O1xuXG4gICAgd2hpbGUgKGluZGV4IDwgY291bnQgPj4gMSkge1xuICAgICAgY29uc3QgbEluZGV4ID0gdGhpcy5nZXRMZWZ0Q2hpbGRJbmRleF8oaW5kZXgpO1xuICAgICAgY29uc3QgckluZGV4ID0gdGhpcy5nZXRSaWdodENoaWxkSW5kZXhfKGluZGV4KTtcblxuICAgICAgY29uc3Qgc21hbGxlckNoaWxkSW5kZXggPVxuICAgICAgICBySW5kZXggPCBjb3VudCAmJiBwcmlvcml0aWVzW3JJbmRleF0gPCBwcmlvcml0aWVzW2xJbmRleF1cbiAgICAgICAgICA/IHJJbmRleFxuICAgICAgICAgIDogbEluZGV4O1xuXG4gICAgICBlbGVtZW50c1tpbmRleF0gPSBlbGVtZW50c1tzbWFsbGVyQ2hpbGRJbmRleF07XG4gICAgICBwcmlvcml0aWVzW2luZGV4XSA9IHByaW9yaXRpZXNbc21hbGxlckNoaWxkSW5kZXhdO1xuICAgICAgaW5kZXggPSBzbWFsbGVyQ2hpbGRJbmRleDtcbiAgICB9XG5cbiAgICBlbGVtZW50c1tpbmRleF0gPSBlbGVtZW50O1xuICAgIHByaW9yaXRpZXNbaW5kZXhdID0gcHJpb3JpdHk7XG4gICAgdGhpcy5zaWZ0RG93bl8oc3RhcnRJbmRleCwgaW5kZXgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydEluZGV4IFRoZSBpbmRleCBvZiB0aGUgcm9vdC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSBpbmRleCBvZiB0aGUgbm9kZSB0byBtb3ZlIHVwLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc2lmdERvd25fKHN0YXJ0SW5kZXgsIGluZGV4KSB7XG4gICAgY29uc3QgZWxlbWVudHMgPSB0aGlzLmVsZW1lbnRzXztcbiAgICBjb25zdCBwcmlvcml0aWVzID0gdGhpcy5wcmlvcml0aWVzXztcbiAgICBjb25zdCBlbGVtZW50ID0gZWxlbWVudHNbaW5kZXhdO1xuICAgIGNvbnN0IHByaW9yaXR5ID0gcHJpb3JpdGllc1tpbmRleF07XG5cbiAgICB3aGlsZSAoaW5kZXggPiBzdGFydEluZGV4KSB7XG4gICAgICBjb25zdCBwYXJlbnRJbmRleCA9IHRoaXMuZ2V0UGFyZW50SW5kZXhfKGluZGV4KTtcbiAgICAgIGlmIChwcmlvcml0aWVzW3BhcmVudEluZGV4XSA+IHByaW9yaXR5KSB7XG4gICAgICAgIGVsZW1lbnRzW2luZGV4XSA9IGVsZW1lbnRzW3BhcmVudEluZGV4XTtcbiAgICAgICAgcHJpb3JpdGllc1tpbmRleF0gPSBwcmlvcml0aWVzW3BhcmVudEluZGV4XTtcbiAgICAgICAgaW5kZXggPSBwYXJlbnRJbmRleDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBlbGVtZW50c1tpbmRleF0gPSBlbGVtZW50O1xuICAgIHByaW9yaXRpZXNbaW5kZXhdID0gcHJpb3JpdHk7XG4gIH1cblxuICAvKipcbiAgICogRklYTUUgZW1wdHkgZGVzY3JpcHRpb24gZm9yIGpzZG9jXG4gICAqL1xuICByZXByaW9yaXRpemUoKSB7XG4gICAgY29uc3QgcHJpb3JpdHlGdW5jdGlvbiA9IHRoaXMucHJpb3JpdHlGdW5jdGlvbl87XG4gICAgY29uc3QgZWxlbWVudHMgPSB0aGlzLmVsZW1lbnRzXztcbiAgICBjb25zdCBwcmlvcml0aWVzID0gdGhpcy5wcmlvcml0aWVzXztcbiAgICBsZXQgaW5kZXggPSAwO1xuICAgIGNvbnN0IG4gPSBlbGVtZW50cy5sZW5ndGg7XG4gICAgbGV0IGVsZW1lbnQsIGksIHByaW9yaXR5O1xuICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGVsZW1lbnQgPSBlbGVtZW50c1tpXTtcbiAgICAgIHByaW9yaXR5ID0gcHJpb3JpdHlGdW5jdGlvbihlbGVtZW50KTtcbiAgICAgIGlmIChwcmlvcml0eSA9PSBEUk9QKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnF1ZXVlZEVsZW1lbnRzX1t0aGlzLmtleUZ1bmN0aW9uXyhlbGVtZW50KV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcmlvcml0aWVzW2luZGV4XSA9IHByaW9yaXR5O1xuICAgICAgICBlbGVtZW50c1tpbmRleCsrXSA9IGVsZW1lbnQ7XG4gICAgICB9XG4gICAgfVxuICAgIGVsZW1lbnRzLmxlbmd0aCA9IGluZGV4O1xuICAgIHByaW9yaXRpZXMubGVuZ3RoID0gaW5kZXg7XG4gICAgdGhpcy5oZWFwaWZ5XygpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFByaW9yaXR5UXVldWU7XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvc3RydWN0cy9SQnVzaFxuICovXG5pbXBvcnQgUkJ1c2hfIGZyb20gJ3JidXNoJztcbmltcG9ydCB7Y3JlYXRlT3JVcGRhdGUsIGVxdWFsc30gZnJvbSAnLi4vZXh0ZW50LmpzJztcbmltcG9ydCB7Z2V0VWlkfSBmcm9tICcuLi91dGlsLmpzJztcbmltcG9ydCB7aXNFbXB0eX0gZnJvbSAnLi4vb2JqLmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBFbnRyeVxuICogQHByb3BlcnR5IHtudW1iZXJ9IG1pblggTWluWC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtaW5ZIE1pblkuXG4gKiBAcHJvcGVydHkge251bWJlcn0gbWF4WCBNYXhYLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IG1heFkgTWF4WS5cbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBbdmFsdWVdIFZhbHVlLlxuICovXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogV3JhcHBlciBhcm91bmQgdGhlIFJCdXNoIGJ5IFZsYWRpbWlyIEFnYWZvbmtpbi5cbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbW91cm5lci9yYnVzaC5cbiAqXG4gKiBAdGVtcGxhdGUgVFxuICovXG5jbGFzcyBSQnVzaCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gW21heEVudHJpZXNdIE1heCBlbnRyaWVzLlxuICAgKi9cbiAgY29uc3RydWN0b3IobWF4RW50cmllcykge1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5yYnVzaF8gPSBuZXcgUkJ1c2hfKG1heEVudHJpZXMpO1xuXG4gICAgLyoqXG4gICAgICogQSBtYXBwaW5nIGJldHdlZW4gdGhlIG9iamVjdHMgYWRkZWQgdG8gdGhpcyByYnVzaCB3cmFwcGVyXG4gICAgICogYW5kIHRoZSBvYmplY3RzIHRoYXQgYXJlIGFjdHVhbGx5IGFkZGVkIHRvIHRoZSBpbnRlcm5hbCByYnVzaC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBFbnRyeT59XG4gICAgICovXG4gICAgdGhpcy5pdGVtc18gPSB7fTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnNlcnQgYSB2YWx1ZSBpbnRvIHRoZSBSQnVzaC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICAgKiBAcGFyYW0ge1R9IHZhbHVlIFZhbHVlLlxuICAgKi9cbiAgaW5zZXJ0KGV4dGVudCwgdmFsdWUpIHtcbiAgICAvKiogQHR5cGUge0VudHJ5fSAqL1xuICAgIGNvbnN0IGl0ZW0gPSB7XG4gICAgICBtaW5YOiBleHRlbnRbMF0sXG4gICAgICBtaW5ZOiBleHRlbnRbMV0sXG4gICAgICBtYXhYOiBleHRlbnRbMl0sXG4gICAgICBtYXhZOiBleHRlbnRbM10sXG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgfTtcblxuICAgIHRoaXMucmJ1c2hfLmluc2VydChpdGVtKTtcbiAgICB0aGlzLml0ZW1zX1tnZXRVaWQodmFsdWUpXSA9IGl0ZW07XG4gIH1cblxuICAvKipcbiAgICogQnVsay1pbnNlcnQgdmFsdWVzIGludG8gdGhlIFJCdXNoLlxuICAgKiBAcGFyYW0ge0FycmF5PGltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnQ+fSBleHRlbnRzIEV4dGVudHMuXG4gICAqIEBwYXJhbSB7QXJyYXk8VD59IHZhbHVlcyBWYWx1ZXMuXG4gICAqL1xuICBsb2FkKGV4dGVudHMsIHZhbHVlcykge1xuICAgIGNvbnN0IGl0ZW1zID0gbmV3IEFycmF5KHZhbHVlcy5sZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwLCBsID0gdmFsdWVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgY29uc3QgZXh0ZW50ID0gZXh0ZW50c1tpXTtcbiAgICAgIGNvbnN0IHZhbHVlID0gdmFsdWVzW2ldO1xuXG4gICAgICAvKiogQHR5cGUge0VudHJ5fSAqL1xuICAgICAgY29uc3QgaXRlbSA9IHtcbiAgICAgICAgbWluWDogZXh0ZW50WzBdLFxuICAgICAgICBtaW5ZOiBleHRlbnRbMV0sXG4gICAgICAgIG1heFg6IGV4dGVudFsyXSxcbiAgICAgICAgbWF4WTogZXh0ZW50WzNdLFxuICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICB9O1xuICAgICAgaXRlbXNbaV0gPSBpdGVtO1xuICAgICAgdGhpcy5pdGVtc19bZ2V0VWlkKHZhbHVlKV0gPSBpdGVtO1xuICAgIH1cbiAgICB0aGlzLnJidXNoXy5sb2FkKGl0ZW1zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYSB2YWx1ZSBmcm9tIHRoZSBSQnVzaC5cbiAgICogQHBhcmFtIHtUfSB2YWx1ZSBWYWx1ZS5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gUmVtb3ZlZC5cbiAgICovXG4gIHJlbW92ZSh2YWx1ZSkge1xuICAgIGNvbnN0IHVpZCA9IGdldFVpZCh2YWx1ZSk7XG5cbiAgICAvLyBnZXQgdGhlIG9iamVjdCBpbiB3aGljaCB0aGUgdmFsdWUgd2FzIHdyYXBwZWQgd2hlbiBhZGRpbmcgdG8gdGhlXG4gICAgLy8gaW50ZXJuYWwgcmJ1c2guIHRoZW4gdXNlIHRoYXQgb2JqZWN0IHRvIGRvIHRoZSByZW1vdmFsLlxuICAgIGNvbnN0IGl0ZW0gPSB0aGlzLml0ZW1zX1t1aWRdO1xuICAgIGRlbGV0ZSB0aGlzLml0ZW1zX1t1aWRdO1xuICAgIHJldHVybiB0aGlzLnJidXNoXy5yZW1vdmUoaXRlbSkgIT09IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIHRoZSBleHRlbnQgb2YgYSB2YWx1ZSBpbiB0aGUgUkJ1c2guXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAgICogQHBhcmFtIHtUfSB2YWx1ZSBWYWx1ZS5cbiAgICovXG4gIHVwZGF0ZShleHRlbnQsIHZhbHVlKSB7XG4gICAgY29uc3QgaXRlbSA9IHRoaXMuaXRlbXNfW2dldFVpZCh2YWx1ZSldO1xuICAgIGNvbnN0IGJib3ggPSBbaXRlbS5taW5YLCBpdGVtLm1pblksIGl0ZW0ubWF4WCwgaXRlbS5tYXhZXTtcbiAgICBpZiAoIWVxdWFscyhiYm94LCBleHRlbnQpKSB7XG4gICAgICB0aGlzLnJlbW92ZSh2YWx1ZSk7XG4gICAgICB0aGlzLmluc2VydChleHRlbnQsIHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGFsbCB2YWx1ZXMgaW4gdGhlIFJCdXNoLlxuICAgKiBAcmV0dXJuIHtBcnJheTxUPn0gQWxsLlxuICAgKi9cbiAgZ2V0QWxsKCkge1xuICAgIGNvbnN0IGl0ZW1zID0gdGhpcy5yYnVzaF8uYWxsKCk7XG4gICAgcmV0dXJuIGl0ZW1zLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuIGl0ZW0udmFsdWU7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGFsbCB2YWx1ZXMgaW4gdGhlIGdpdmVuIGV4dGVudC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICAgKiBAcmV0dXJuIHtBcnJheTxUPn0gQWxsIGluIGV4dGVudC5cbiAgICovXG4gIGdldEluRXh0ZW50KGV4dGVudCkge1xuICAgIC8qKiBAdHlwZSB7RW50cnl9ICovXG4gICAgY29uc3QgYmJveCA9IHtcbiAgICAgIG1pblg6IGV4dGVudFswXSxcbiAgICAgIG1pblk6IGV4dGVudFsxXSxcbiAgICAgIG1heFg6IGV4dGVudFsyXSxcbiAgICAgIG1heFk6IGV4dGVudFszXSxcbiAgICB9O1xuICAgIGNvbnN0IGl0ZW1zID0gdGhpcy5yYnVzaF8uc2VhcmNoKGJib3gpO1xuICAgIHJldHVybiBpdGVtcy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiBpdGVtLnZhbHVlO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGxzIGEgY2FsbGJhY2sgZnVuY3Rpb24gd2l0aCBlYWNoIHZhbHVlIGluIHRoZSB0cmVlLlxuICAgKiBJZiB0aGUgY2FsbGJhY2sgcmV0dXJucyBhIHRydXRoeSB2YWx1ZSwgdGhpcyB2YWx1ZSBpcyByZXR1cm5lZCB3aXRob3V0XG4gICAqIGNoZWNraW5nIHRoZSByZXN0IG9mIHRoZSB0cmVlLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKFQpOiAqfSBjYWxsYmFjayBDYWxsYmFjay5cbiAgICogQHJldHVybiB7Kn0gQ2FsbGJhY2sgcmV0dXJuIHZhbHVlLlxuICAgKi9cbiAgZm9yRWFjaChjYWxsYmFjaykge1xuICAgIHJldHVybiB0aGlzLmZvckVhY2hfKHRoaXMuZ2V0QWxsKCksIGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxscyBhIGNhbGxiYWNrIGZ1bmN0aW9uIHdpdGggZWFjaCB2YWx1ZSBpbiB0aGUgcHJvdmlkZWQgZXh0ZW50LlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oVCk6ICp9IGNhbGxiYWNrIENhbGxiYWNrLlxuICAgKiBAcmV0dXJuIHsqfSBDYWxsYmFjayByZXR1cm4gdmFsdWUuXG4gICAqL1xuICBmb3JFYWNoSW5FeHRlbnQoZXh0ZW50LCBjYWxsYmFjaykge1xuICAgIHJldHVybiB0aGlzLmZvckVhY2hfKHRoaXMuZ2V0SW5FeHRlbnQoZXh0ZW50KSwgY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7QXJyYXk8VD59IHZhbHVlcyBWYWx1ZXMuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oVCk6ICp9IGNhbGxiYWNrIENhbGxiYWNrLlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcmV0dXJuIHsqfSBDYWxsYmFjayByZXR1cm4gdmFsdWUuXG4gICAqL1xuICBmb3JFYWNoXyh2YWx1ZXMsIGNhbGxiYWNrKSB7XG4gICAgbGV0IHJlc3VsdDtcbiAgICBmb3IgKGxldCBpID0gMCwgbCA9IHZhbHVlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHJlc3VsdCA9IGNhbGxiYWNrKHZhbHVlc1tpXSk7XG4gICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gSXMgZW1wdHkuXG4gICAqL1xuICBpc0VtcHR5KCkge1xuICAgIHJldHVybiBpc0VtcHR5KHRoaXMuaXRlbXNfKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYWxsIHZhbHVlcyBmcm9tIHRoZSBSQnVzaC5cbiAgICovXG4gIGNsZWFyKCkge1xuICAgIHRoaXMucmJ1c2hfLmNsZWFyKCk7XG4gICAgdGhpcy5pdGVtc18gPSB7fTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IFtleHRlbnRdIEV4dGVudC5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gRXh0ZW50LlxuICAgKi9cbiAgZ2V0RXh0ZW50KGV4dGVudCkge1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLnJidXNoXy50b0pTT04oKTtcbiAgICByZXR1cm4gY3JlYXRlT3JVcGRhdGUoZGF0YS5taW5YLCBkYXRhLm1pblksIGRhdGEubWF4WCwgZGF0YS5tYXhZLCBleHRlbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7UkJ1c2h9IHJidXNoIFItVHJlZS5cbiAgICovXG4gIGNvbmNhdChyYnVzaCkge1xuICAgIHRoaXMucmJ1c2hfLmxvYWQocmJ1c2gucmJ1c2hfLmFsbCgpKTtcbiAgICBmb3IgKGNvbnN0IGkgaW4gcmJ1c2guaXRlbXNfKSB7XG4gICAgICB0aGlzLml0ZW1zX1tpXSA9IHJidXNoLml0ZW1zX1tpXTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgUkJ1c2g7XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvc3R5bGUvQ2lyY2xlXG4gKi9cblxuaW1wb3J0IFJlZ3VsYXJTaGFwZSBmcm9tICcuL1JlZ3VsYXJTaGFwZS5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL0ZpbGwuanNcIikuZGVmYXVsdH0gW2ZpbGxdIEZpbGwgc3R5bGUuXG4gKiBAcHJvcGVydHkge251bWJlcn0gcmFkaXVzIENpcmNsZSByYWRpdXMuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4vU3Ryb2tlLmpzXCIpLmRlZmF1bHR9IFtzdHJva2VdIFN0cm9rZSBzdHlsZS5cbiAqIEBwcm9wZXJ0eSB7QXJyYXk8bnVtYmVyPn0gW2Rpc3BsYWNlbWVudD1bMCwwXV0gZGlzcGxhY2VtZW50XG4gKiBAcHJvcGVydHkge251bWJlcnxpbXBvcnQoXCIuLi9zaXplLmpzXCIpLlNpemV9IFtzY2FsZT0xXSBTY2FsZS4gQSB0d28gZGltZW5zaW9uYWwgc2NhbGUgd2lsbCBwcm9kdWNlIGFuIGVsbGlwc2UuXG4gKiBVbmxlc3MgdHdvIGRpbWVuc2lvbmFsIHNjYWxpbmcgaXMgcmVxdWlyZWQgYSBiZXR0ZXIgcmVzdWx0IG1heSBiZSBvYnRhaW5lZCB3aXRoIGFuIGFwcHJvcHJpYXRlIHNldHRpbmcgZm9yIGByYWRpdXNgLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtyb3RhdGlvbj0wXSBSb3RhdGlvbiBpbiByYWRpYW5zXG4gKiAocG9zaXRpdmUgcm90YXRpb24gY2xvY2t3aXNlLCBtZWFuaW5nZnVsIG9ubHkgd2hlbiB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggYSB0d28gZGltZW5zaW9uYWwgc2NhbGUpLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbcm90YXRlV2l0aFZpZXc9ZmFsc2VdIFdoZXRoZXIgdG8gcm90YXRlIHRoZSBzaGFwZSB3aXRoIHRoZSB2aWV3XG4gKiAobWVhbmluZ2Z1bCBvbmx5IHdoZW4gdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIGEgdHdvIGRpbWVuc2lvbmFsIHNjYWxlKS5cbiAqIEBwcm9wZXJ0eSB7XCJkZWNsdXR0ZXJcInxcIm9ic3RhY2xlXCJ8XCJub25lXCJ8dW5kZWZpbmVkfSBbZGVjbHV0dGVyTW9kZV0gRGVjbHV0dGVyIG1vZGVcbiAqL1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIFNldCBjaXJjbGUgc3R5bGUgZm9yIHZlY3RvciBmZWF0dXJlcy5cbiAqIEBhcGlcbiAqL1xuY2xhc3MgQ2lyY2xlU3R5bGUgZXh0ZW5kcyBSZWd1bGFyU2hhcGUge1xuICAvKipcbiAgICogQHBhcmFtIHtPcHRpb25zfSBbb3B0aW9uc10gT3B0aW9ucy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyA/IG9wdGlvbnMgOiB7cmFkaXVzOiA1fTtcblxuICAgIHN1cGVyKHtcbiAgICAgIHBvaW50czogSW5maW5pdHksXG4gICAgICBmaWxsOiBvcHRpb25zLmZpbGwsXG4gICAgICByYWRpdXM6IG9wdGlvbnMucmFkaXVzLFxuICAgICAgc3Ryb2tlOiBvcHRpb25zLnN0cm9rZSxcbiAgICAgIHNjYWxlOiBvcHRpb25zLnNjYWxlICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnNjYWxlIDogMSxcbiAgICAgIHJvdGF0aW9uOiBvcHRpb25zLnJvdGF0aW9uICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnJvdGF0aW9uIDogMCxcbiAgICAgIHJvdGF0ZVdpdGhWaWV3OlxuICAgICAgICBvcHRpb25zLnJvdGF0ZVdpdGhWaWV3ICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnJvdGF0ZVdpdGhWaWV3IDogZmFsc2UsXG4gICAgICBkaXNwbGFjZW1lbnQ6XG4gICAgICAgIG9wdGlvbnMuZGlzcGxhY2VtZW50ICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmRpc3BsYWNlbWVudCA6IFswLCAwXSxcbiAgICAgIGRlY2x1dHRlck1vZGU6IG9wdGlvbnMuZGVjbHV0dGVyTW9kZSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbG9uZXMgdGhlIHN0eWxlLlxuICAgKiBAcmV0dXJuIHtDaXJjbGVTdHlsZX0gVGhlIGNsb25lZCBzdHlsZS5cbiAgICogQGFwaVxuICAgKi9cbiAgY2xvbmUoKSB7XG4gICAgY29uc3Qgc2NhbGUgPSB0aGlzLmdldFNjYWxlKCk7XG4gICAgY29uc3Qgc3R5bGUgPSBuZXcgQ2lyY2xlU3R5bGUoe1xuICAgICAgZmlsbDogdGhpcy5nZXRGaWxsKCkgPyB0aGlzLmdldEZpbGwoKS5jbG9uZSgpIDogdW5kZWZpbmVkLFxuICAgICAgc3Ryb2tlOiB0aGlzLmdldFN0cm9rZSgpID8gdGhpcy5nZXRTdHJva2UoKS5jbG9uZSgpIDogdW5kZWZpbmVkLFxuICAgICAgcmFkaXVzOiB0aGlzLmdldFJhZGl1cygpLFxuICAgICAgc2NhbGU6IEFycmF5LmlzQXJyYXkoc2NhbGUpID8gc2NhbGUuc2xpY2UoKSA6IHNjYWxlLFxuICAgICAgcm90YXRpb246IHRoaXMuZ2V0Um90YXRpb24oKSxcbiAgICAgIHJvdGF0ZVdpdGhWaWV3OiB0aGlzLmdldFJvdGF0ZVdpdGhWaWV3KCksXG4gICAgICBkaXNwbGFjZW1lbnQ6IHRoaXMuZ2V0RGlzcGxhY2VtZW50KCkuc2xpY2UoKSxcbiAgICAgIGRlY2x1dHRlck1vZGU6IHRoaXMuZ2V0RGVjbHV0dGVyTW9kZSgpLFxuICAgIH0pO1xuICAgIHN0eWxlLnNldE9wYWNpdHkodGhpcy5nZXRPcGFjaXR5KCkpO1xuICAgIHJldHVybiBzdHlsZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGNpcmNsZSByYWRpdXMuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSByYWRpdXMgQ2lyY2xlIHJhZGl1cy5cbiAgICogQGFwaVxuICAgKi9cbiAgc2V0UmFkaXVzKHJhZGl1cykge1xuICAgIHRoaXMucmFkaXVzXyA9IHJhZGl1cztcbiAgICB0aGlzLnJlbmRlcigpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IENpcmNsZVN0eWxlO1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3N0eWxlL0ZpbGxcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vY29sb3IuanNcIikuQ29sb3J8aW1wb3J0KFwiLi4vY29sb3JsaWtlLmpzXCIpLkNvbG9yTGlrZXxudWxsfSBbY29sb3I9bnVsbF0gQSBjb2xvciwgZ3JhZGllbnQgb3IgcGF0dGVybi5cbiAqIFNlZSB7QGxpbmsgbW9kdWxlOm9sL2NvbG9yfkNvbG9yfSBhbmQge0BsaW5rIG1vZHVsZTpvbC9jb2xvcmxpa2V+Q29sb3JMaWtlfSBmb3IgcG9zc2libGUgZm9ybWF0cy5cbiAqIERlZmF1bHQgbnVsbDsgaWYgbnVsbCwgdGhlIENhbnZhcy9yZW5kZXJlciBkZWZhdWx0IGJsYWNrIHdpbGwgYmUgdXNlZC5cbiAqL1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIFNldCBmaWxsIHN0eWxlIGZvciB2ZWN0b3IgZmVhdHVyZXMuXG4gKiBAYXBpXG4gKi9cbmNsYXNzIEZpbGwge1xuICAvKipcbiAgICogQHBhcmFtIHtPcHRpb25zfSBbb3B0aW9uc10gT3B0aW9ucy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL2NvbG9yLmpzXCIpLkNvbG9yfGltcG9ydChcIi4uL2NvbG9ybGlrZS5qc1wiKS5Db2xvckxpa2V8bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLmNvbG9yXyA9IG9wdGlvbnMuY29sb3IgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuY29sb3IgOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIENsb25lcyB0aGUgc3R5bGUuIFRoZSBjb2xvciBpcyBub3QgY2xvbmVkIGlmIGl0IGlzIGFuIHtAbGluayBtb2R1bGU6b2wvY29sb3JsaWtlfkNvbG9yTGlrZX0uXG4gICAqIEByZXR1cm4ge0ZpbGx9IFRoZSBjbG9uZWQgc3R5bGUuXG4gICAqIEBhcGlcbiAgICovXG4gIGNsb25lKCkge1xuICAgIGNvbnN0IGNvbG9yID0gdGhpcy5nZXRDb2xvcigpO1xuICAgIHJldHVybiBuZXcgRmlsbCh7XG4gICAgICBjb2xvcjogQXJyYXkuaXNBcnJheShjb2xvcikgPyBjb2xvci5zbGljZSgpIDogY29sb3IgfHwgdW5kZWZpbmVkLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZmlsbCBjb2xvci5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vY29sb3IuanNcIikuQ29sb3J8aW1wb3J0KFwiLi4vY29sb3JsaWtlLmpzXCIpLkNvbG9yTGlrZXxudWxsfSBDb2xvci5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0Q29sb3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29sb3JfO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgY29sb3IuXG4gICAqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29sb3IuanNcIikuQ29sb3J8aW1wb3J0KFwiLi4vY29sb3JsaWtlLmpzXCIpLkNvbG9yTGlrZXxudWxsfSBjb2xvciBDb2xvci5cbiAgICogQGFwaVxuICAgKi9cbiAgc2V0Q29sb3IoY29sb3IpIHtcbiAgICB0aGlzLmNvbG9yXyA9IGNvbG9yO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEZpbGw7XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvc3R5bGUvSWNvblxuICovXG5pbXBvcnQgRXZlbnRUeXBlIGZyb20gJy4uL2V2ZW50cy9FdmVudFR5cGUuanMnO1xuaW1wb3J0IEltYWdlU3RhdGUgZnJvbSAnLi4vSW1hZ2VTdGF0ZS5qcyc7XG5pbXBvcnQgSW1hZ2VTdHlsZSBmcm9tICcuL0ltYWdlLmpzJztcbmltcG9ydCB7YXNBcnJheX0gZnJvbSAnLi4vY29sb3IuanMnO1xuaW1wb3J0IHthc3NlcnR9IGZyb20gJy4uL2Fzc2VydHMuanMnO1xuaW1wb3J0IHtnZXQgYXMgZ2V0SWNvbkltYWdlfSBmcm9tICcuL0ljb25JbWFnZS5qcyc7XG5pbXBvcnQge2dldFVpZH0gZnJvbSAnLi4vdXRpbC5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYgeydmcmFjdGlvbicgfCAncGl4ZWxzJ30gSWNvbkFuY2hvclVuaXRzXG4gKiBBbmNob3IgdW5pdCBjYW4gYmUgZWl0aGVyIGEgZnJhY3Rpb24gb2YgdGhlIGljb24gc2l6ZSBvciBpbiBwaXhlbHMuXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7J2JvdHRvbS1sZWZ0JyB8ICdib3R0b20tcmlnaHQnIHwgJ3RvcC1sZWZ0JyB8ICd0b3AtcmlnaHQnfSBJY29uT3JpZ2luXG4gKiBJY29uIG9yaWdpbi4gT25lIG9mICdib3R0b20tbGVmdCcsICdib3R0b20tcmlnaHQnLCAndG9wLWxlZnQnLCAndG9wLXJpZ2h0Jy5cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7QXJyYXk8bnVtYmVyPn0gW2FuY2hvcj1bMC41LCAwLjVdXSBBbmNob3IuIERlZmF1bHQgdmFsdWUgaXMgdGhlIGljb24gY2VudGVyLlxuICogQHByb3BlcnR5IHtJY29uT3JpZ2lufSBbYW5jaG9yT3JpZ2luPSd0b3AtbGVmdCddIE9yaWdpbiBvZiB0aGUgYW5jaG9yOiBgYm90dG9tLWxlZnRgLCBgYm90dG9tLXJpZ2h0YCxcbiAqIGB0b3AtbGVmdGAgb3IgYHRvcC1yaWdodGAuXG4gKiBAcHJvcGVydHkge0ljb25BbmNob3JVbml0c30gW2FuY2hvclhVbml0cz0nZnJhY3Rpb24nXSBVbml0cyBpbiB3aGljaCB0aGUgYW5jaG9yIHggdmFsdWUgaXNcbiAqIHNwZWNpZmllZC4gQSB2YWx1ZSBvZiBgJ2ZyYWN0aW9uJ2AgaW5kaWNhdGVzIHRoZSB4IHZhbHVlIGlzIGEgZnJhY3Rpb24gb2YgdGhlIGljb24uIEEgdmFsdWUgb2YgYCdwaXhlbHMnYCBpbmRpY2F0ZXNcbiAqIHRoZSB4IHZhbHVlIGluIHBpeGVscy5cbiAqIEBwcm9wZXJ0eSB7SWNvbkFuY2hvclVuaXRzfSBbYW5jaG9yWVVuaXRzPSdmcmFjdGlvbiddIFVuaXRzIGluIHdoaWNoIHRoZSBhbmNob3IgeSB2YWx1ZSBpc1xuICogc3BlY2lmaWVkLiBBIHZhbHVlIG9mIGAnZnJhY3Rpb24nYCBpbmRpY2F0ZXMgdGhlIHkgdmFsdWUgaXMgYSBmcmFjdGlvbiBvZiB0aGUgaWNvbi4gQSB2YWx1ZSBvZiBgJ3BpeGVscydgIGluZGljYXRlc1xuICogdGhlIHkgdmFsdWUgaW4gcGl4ZWxzLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9jb2xvci5qc1wiKS5Db2xvcnxzdHJpbmd9IFtjb2xvcl0gQ29sb3IgdG8gdGludCB0aGUgaWNvbi4gSWYgbm90IHNwZWNpZmllZCxcbiAqIHRoZSBpY29uIHdpbGwgYmUgbGVmdCBhcyBpcy5cbiAqIEBwcm9wZXJ0eSB7bnVsbHxzdHJpbmd9IFtjcm9zc09yaWdpbl0gVGhlIGBjcm9zc09yaWdpbmAgYXR0cmlidXRlIGZvciBsb2FkZWQgaW1hZ2VzLiBOb3RlIHRoYXQgeW91IG11c3QgcHJvdmlkZSBhXG4gKiBgY3Jvc3NPcmlnaW5gIHZhbHVlIGlmIHlvdSB3YW50IHRvIGFjY2VzcyBwaXhlbCBkYXRhIHdpdGggdGhlIENhbnZhcyByZW5kZXJlci5cbiAqIFNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVE1ML0NPUlNfZW5hYmxlZF9pbWFnZSBmb3IgbW9yZSBkZXRhaWwuXG4gKiBAcHJvcGVydHkge0hUTUxJbWFnZUVsZW1lbnR8SFRNTENhbnZhc0VsZW1lbnR8SW1hZ2VCaXRtYXB9IFtpbWddIEltYWdlIG9iamVjdCBmb3IgdGhlIGljb24uXG4gKiBAcHJvcGVydHkge0FycmF5PG51bWJlcj59IFtkaXNwbGFjZW1lbnQ9WzAsIDBdXSBEaXNwbGFjZW1lbnQgb2YgdGhlIGljb24gaW4gcGl4ZWxzLlxuICogUG9zaXRpdmUgdmFsdWVzIHdpbGwgc2hpZnQgdGhlIGljb24gcmlnaHQgYW5kIHVwLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtvcGFjaXR5PTFdIE9wYWNpdHkgb2YgdGhlIGljb24uXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3dpZHRoXSBUaGUgd2lkdGggb2YgdGhlIGljb24gaW4gcGl4ZWxzLiBUaGlzIGNhbid0IGJlIHVzZWQgdG9nZXRoZXIgd2l0aCBgc2NhbGVgLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtoZWlnaHRdIFRoZSBoZWlnaHQgb2YgdGhlIGljb24gaW4gcGl4ZWxzLiBUaGlzIGNhbid0IGJlIHVzZWQgdG9nZXRoZXIgd2l0aCBgc2NhbGVgLlxuICogQHByb3BlcnR5IHtudW1iZXJ8aW1wb3J0KFwiLi4vc2l6ZS5qc1wiKS5TaXplfSBbc2NhbGU9MV0gU2NhbGUuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtyb3RhdGVXaXRoVmlldz1mYWxzZV0gV2hldGhlciB0byByb3RhdGUgdGhlIGljb24gd2l0aCB0aGUgdmlldy5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbcm90YXRpb249MF0gUm90YXRpb24gaW4gcmFkaWFucyAocG9zaXRpdmUgcm90YXRpb24gY2xvY2t3aXNlKS5cbiAqIEBwcm9wZXJ0eSB7QXJyYXk8bnVtYmVyPn0gW29mZnNldD1bMCwgMF1dIE9mZnNldCB3aGljaCwgdG9nZXRoZXIgd2l0aCBgc2l6ZWAgYW5kIGBvZmZzZXRPcmlnaW5gLCBkZWZpbmVzIHRoZVxuICogc3ViLXJlY3RhbmdsZSB0byB1c2UgZnJvbSB0aGUgb3JpZ2luYWwgKHNwcml0ZSkgaW1hZ2UuXG4gKiBAcHJvcGVydHkge0ljb25PcmlnaW59IFtvZmZzZXRPcmlnaW49J3RvcC1sZWZ0J10gT3JpZ2luIG9mIHRoZSBvZmZzZXQ6IGBib3R0b20tbGVmdGAsIGBib3R0b20tcmlnaHRgLFxuICogYHRvcC1sZWZ0YCBvciBgdG9wLXJpZ2h0YC5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vc2l6ZS5qc1wiKS5TaXplfSBbc2l6ZV0gSWNvbiBzaXplIGluIHBpeGVscy4gVXNlZCB0b2dldGhlciB3aXRoIGBvZmZzZXRgIHRvIGRlZmluZSB0aGVcbiAqIHN1Yi1yZWN0YW5nbGUgdG8gdXNlIGZyb20gdGhlIG9yaWdpbmFsIChzcHJpdGUpIGltYWdlLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtzcmNdIEltYWdlIHNvdXJjZSBVUkkuXG4gKiBAcHJvcGVydHkge1wiZGVjbHV0dGVyXCJ8XCJvYnN0YWNsZVwifFwibm9uZVwifHVuZGVmaW5lZH0gW2RlY2x1dHRlck1vZGVdIERlY2x1dHRlciBtb2RlLlxuICovXG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIFRoZSB3aWR0aC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgVGhlIGhlaWdodC5cbiAqIEBwYXJhbSB7bnVtYmVyfHVuZGVmaW5lZH0gd2FudGVkV2lkdGggVGhlIHdhbnRlZCB3aWR0aC5cbiAqIEBwYXJhbSB7bnVtYmVyfHVuZGVmaW5lZH0gd2FudGVkSGVpZ2h0IFRoZSB3YW50ZWQgaGVpZ2h0LlxuICogQHJldHVybiB7bnVtYmVyfEFycmF5PG51bWJlcj59IFRoZSBzY2FsZS5cbiAqL1xuZnVuY3Rpb24gY2FsY3VsYXRlU2NhbGUod2lkdGgsIGhlaWdodCwgd2FudGVkV2lkdGgsIHdhbnRlZEhlaWdodCkge1xuICBpZiAod2FudGVkV2lkdGggIT09IHVuZGVmaW5lZCAmJiB3YW50ZWRIZWlnaHQgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBbd2FudGVkV2lkdGggLyB3aWR0aCwgd2FudGVkSGVpZ2h0IC8gaGVpZ2h0XTtcbiAgfVxuICBpZiAod2FudGVkV2lkdGggIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB3YW50ZWRXaWR0aCAvIHdpZHRoO1xuICB9XG4gIGlmICh3YW50ZWRIZWlnaHQgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB3YW50ZWRIZWlnaHQgLyBoZWlnaHQ7XG4gIH1cbiAgcmV0dXJuIDE7XG59XG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogU2V0IGljb24gc3R5bGUgZm9yIHZlY3RvciBmZWF0dXJlcy5cbiAqIEBhcGlcbiAqL1xuY2xhc3MgSWNvbiBleHRlbmRzIEltYWdlU3R5bGUge1xuICAvKipcbiAgICogQHBhcmFtIHtPcHRpb25zfSBbb3B0aW9uc10gT3B0aW9ucy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgY29uc3Qgb3BhY2l0eSA9IG9wdGlvbnMub3BhY2l0eSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5vcGFjaXR5IDogMTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgY29uc3Qgcm90YXRpb24gPSBvcHRpb25zLnJvdGF0aW9uICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnJvdGF0aW9uIDogMDtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ8aW1wb3J0KFwiLi4vc2l6ZS5qc1wiKS5TaXplfVxuICAgICAqL1xuICAgIGNvbnN0IHNjYWxlID0gb3B0aW9ucy5zY2FsZSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5zY2FsZSA6IDE7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBjb25zdCByb3RhdGVXaXRoVmlldyA9XG4gICAgICBvcHRpb25zLnJvdGF0ZVdpdGhWaWV3ICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnJvdGF0ZVdpdGhWaWV3IDogZmFsc2U7XG5cbiAgICBzdXBlcih7XG4gICAgICBvcGFjaXR5OiBvcGFjaXR5LFxuICAgICAgcm90YXRpb246IHJvdGF0aW9uLFxuICAgICAgc2NhbGU6IHNjYWxlLFxuICAgICAgZGlzcGxhY2VtZW50OlxuICAgICAgICBvcHRpb25zLmRpc3BsYWNlbWVudCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5kaXNwbGFjZW1lbnQgOiBbMCwgMF0sXG4gICAgICByb3RhdGVXaXRoVmlldzogcm90YXRlV2l0aFZpZXcsXG4gICAgICBkZWNsdXR0ZXJNb2RlOiBvcHRpb25zLmRlY2x1dHRlck1vZGUsXG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtBcnJheTxudW1iZXI+fVxuICAgICAqL1xuICAgIHRoaXMuYW5jaG9yXyA9IG9wdGlvbnMuYW5jaG9yICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmFuY2hvciA6IFswLjUsIDAuNV07XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtBcnJheTxudW1iZXI+fVxuICAgICAqL1xuICAgIHRoaXMubm9ybWFsaXplZEFuY2hvcl8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7SWNvbk9yaWdpbn1cbiAgICAgKi9cbiAgICB0aGlzLmFuY2hvck9yaWdpbl8gPVxuICAgICAgb3B0aW9ucy5hbmNob3JPcmlnaW4gIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuYW5jaG9yT3JpZ2luIDogJ3RvcC1sZWZ0JztcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0ljb25BbmNob3JVbml0c31cbiAgICAgKi9cbiAgICB0aGlzLmFuY2hvclhVbml0c18gPVxuICAgICAgb3B0aW9ucy5hbmNob3JYVW5pdHMgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuYW5jaG9yWFVuaXRzIDogJ2ZyYWN0aW9uJztcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0ljb25BbmNob3JVbml0c31cbiAgICAgKi9cbiAgICB0aGlzLmFuY2hvcllVbml0c18gPVxuICAgICAgb3B0aW9ucy5hbmNob3JZVW5pdHMgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuYW5jaG9yWVVuaXRzIDogJ2ZyYWN0aW9uJztcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgez9zdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5jcm9zc09yaWdpbl8gPVxuICAgICAgb3B0aW9ucy5jcm9zc09yaWdpbiAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5jcm9zc09yaWdpbiA6IG51bGw7XG5cbiAgICBjb25zdCBpbWFnZSA9IG9wdGlvbnMuaW1nICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmltZyA6IG51bGw7XG5cbiAgICBsZXQgY2FjaGVLZXkgPSBvcHRpb25zLnNyYztcblxuICAgIGFzc2VydChcbiAgICAgICEoY2FjaGVLZXkgIT09IHVuZGVmaW5lZCAmJiBpbWFnZSksXG4gICAgICAnYGltYWdlYCBhbmQgYHNyY2AgY2Fubm90IGJlIHByb3ZpZGVkIGF0IHRoZSBzYW1lIHRpbWUnXG4gICAgKTtcblxuICAgIGlmICgoY2FjaGVLZXkgPT09IHVuZGVmaW5lZCB8fCBjYWNoZUtleS5sZW5ndGggPT09IDApICYmIGltYWdlKSB7XG4gICAgICBjYWNoZUtleSA9IC8qKiBAdHlwZSB7SFRNTEltYWdlRWxlbWVudH0gKi8gKGltYWdlKS5zcmMgfHwgZ2V0VWlkKGltYWdlKTtcbiAgICB9XG4gICAgYXNzZXJ0KFxuICAgICAgY2FjaGVLZXkgIT09IHVuZGVmaW5lZCAmJiBjYWNoZUtleS5sZW5ndGggPiAwLFxuICAgICAgJ0EgZGVmaW5lZCBhbmQgbm9uLWVtcHR5IGBzcmNgIG9yIGBpbWFnZWAgbXVzdCBiZSBwcm92aWRlZCdcbiAgICApO1xuXG4gICAgYXNzZXJ0KFxuICAgICAgIShcbiAgICAgICAgKG9wdGlvbnMud2lkdGggIT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLmhlaWdodCAhPT0gdW5kZWZpbmVkKSAmJlxuICAgICAgICBvcHRpb25zLnNjYWxlICE9PSB1bmRlZmluZWRcbiAgICAgICksXG4gICAgICAnYHdpZHRoYCBvciBgaGVpZ2h0YCBjYW5ub3QgYmUgcHJvdmlkZWQgdG9nZXRoZXIgd2l0aCBgc2NhbGVgJ1xuICAgICk7XG5cbiAgICBsZXQgaW1hZ2VTdGF0ZTtcbiAgICBpZiAob3B0aW9ucy5zcmMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaW1hZ2VTdGF0ZSA9IEltYWdlU3RhdGUuSURMRTtcbiAgICB9IGVsc2UgaWYgKGltYWdlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChpbWFnZSBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQpIHtcbiAgICAgICAgaWYgKGltYWdlLmNvbXBsZXRlKSB7XG4gICAgICAgICAgaW1hZ2VTdGF0ZSA9IGltYWdlLnNyYyA/IEltYWdlU3RhdGUuTE9BREVEIDogSW1hZ2VTdGF0ZS5JRExFO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGltYWdlU3RhdGUgPSBJbWFnZVN0YXRlLkxPQURJTkc7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGltYWdlU3RhdGUgPSBJbWFnZVN0YXRlLkxPQURFRDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9jb2xvci5qc1wiKS5Db2xvcn1cbiAgICAgKi9cbiAgICB0aGlzLmNvbG9yXyA9IG9wdGlvbnMuY29sb3IgIT09IHVuZGVmaW5lZCA/IGFzQXJyYXkob3B0aW9ucy5jb2xvcikgOiBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi9JY29uSW1hZ2UuanNcIikuZGVmYXVsdH1cbiAgICAgKi9cbiAgICB0aGlzLmljb25JbWFnZV8gPSBnZXRJY29uSW1hZ2UoXG4gICAgICBpbWFnZSxcbiAgICAgIC8qKiBAdHlwZSB7c3RyaW5nfSAqLyAoY2FjaGVLZXkpLFxuICAgICAgdGhpcy5jcm9zc09yaWdpbl8sXG4gICAgICBpbWFnZVN0YXRlLFxuICAgICAgdGhpcy5jb2xvcl9cbiAgICApO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7QXJyYXk8bnVtYmVyPn1cbiAgICAgKi9cbiAgICB0aGlzLm9mZnNldF8gPSBvcHRpb25zLm9mZnNldCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5vZmZzZXQgOiBbMCwgMF07XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7SWNvbk9yaWdpbn1cbiAgICAgKi9cbiAgICB0aGlzLm9mZnNldE9yaWdpbl8gPVxuICAgICAgb3B0aW9ucy5vZmZzZXRPcmlnaW4gIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMub2Zmc2V0T3JpZ2luIDogJ3RvcC1sZWZ0JztcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0FycmF5PG51bWJlcj59XG4gICAgICovXG4gICAgdGhpcy5vcmlnaW5fID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL3NpemUuanNcIikuU2l6ZX1cbiAgICAgKi9cbiAgICB0aGlzLnNpemVfID0gb3B0aW9ucy5zaXplICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnNpemUgOiBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHRoZSBzY2FsZSBpZiB3aWR0aCBvciBoZWlnaHQgd2VyZSBnaXZlbi5cbiAgICAgKi9cbiAgICBpZiAob3B0aW9ucy53aWR0aCAhPT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMuaGVpZ2h0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGxldCB3aWR0aCwgaGVpZ2h0O1xuICAgICAgaWYgKG9wdGlvbnMuc2l6ZSkge1xuICAgICAgICBbd2lkdGgsIGhlaWdodF0gPSBvcHRpb25zLnNpemU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBpbWFnZSA9IHRoaXMuZ2V0SW1hZ2UoMSk7XG4gICAgICAgIGlmIChpbWFnZS53aWR0aCAmJiBpbWFnZS5oZWlnaHQpIHtcbiAgICAgICAgICB3aWR0aCA9IGltYWdlLndpZHRoO1xuICAgICAgICAgIGhlaWdodCA9IGltYWdlLmhlaWdodDtcbiAgICAgICAgfSBlbHNlIGlmIChpbWFnZSBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQpIHtcbiAgICAgICAgICB0aGlzLmluaXRpYWxPcHRpb25zXyA9IG9wdGlvbnM7XG4gICAgICAgICAgY29uc3Qgb25sb2FkID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy51bmxpc3RlbkltYWdlQ2hhbmdlKG9ubG9hZCk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaW5pdGlhbE9wdGlvbnNfKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGltYWdlU2l6ZSA9IHRoaXMuaWNvbkltYWdlXy5nZXRTaXplKCk7XG4gICAgICAgICAgICB0aGlzLnNldFNjYWxlKFxuICAgICAgICAgICAgICBjYWxjdWxhdGVTY2FsZShcbiAgICAgICAgICAgICAgICBpbWFnZVNpemVbMF0sXG4gICAgICAgICAgICAgICAgaW1hZ2VTaXplWzFdLFxuICAgICAgICAgICAgICAgIG9wdGlvbnMud2lkdGgsXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5oZWlnaHRcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIHRoaXMubGlzdGVuSW1hZ2VDaGFuZ2Uob25sb2FkKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh3aWR0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuc2V0U2NhbGUoXG4gICAgICAgICAgY2FsY3VsYXRlU2NhbGUod2lkdGgsIGhlaWdodCwgb3B0aW9ucy53aWR0aCwgb3B0aW9ucy5oZWlnaHQpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENsb25lcyB0aGUgc3R5bGUuIFRoZSB1bmRlcmx5aW5nIEltYWdlL0hUTUxDYW52YXNFbGVtZW50IGlzIG5vdCBjbG9uZWQuXG4gICAqIEByZXR1cm4ge0ljb259IFRoZSBjbG9uZWQgc3R5bGUuXG4gICAqIEBhcGlcbiAgICovXG4gIGNsb25lKCkge1xuICAgIGxldCBzY2FsZSwgd2lkdGgsIGhlaWdodDtcbiAgICBpZiAodGhpcy5pbml0aWFsT3B0aW9uc18pIHtcbiAgICAgIHdpZHRoID0gdGhpcy5pbml0aWFsT3B0aW9uc18ud2lkdGg7XG4gICAgICBoZWlnaHQgPSB0aGlzLmluaXRpYWxPcHRpb25zXy5oZWlnaHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNjYWxlID0gdGhpcy5nZXRTY2FsZSgpO1xuICAgICAgc2NhbGUgPSBBcnJheS5pc0FycmF5KHNjYWxlKSA/IHNjYWxlLnNsaWNlKCkgOiBzY2FsZTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBJY29uKHtcbiAgICAgIGFuY2hvcjogdGhpcy5hbmNob3JfLnNsaWNlKCksXG4gICAgICBhbmNob3JPcmlnaW46IHRoaXMuYW5jaG9yT3JpZ2luXyxcbiAgICAgIGFuY2hvclhVbml0czogdGhpcy5hbmNob3JYVW5pdHNfLFxuICAgICAgYW5jaG9yWVVuaXRzOiB0aGlzLmFuY2hvcllVbml0c18sXG4gICAgICBjb2xvcjpcbiAgICAgICAgdGhpcy5jb2xvcl8gJiYgdGhpcy5jb2xvcl8uc2xpY2VcbiAgICAgICAgICA/IHRoaXMuY29sb3JfLnNsaWNlKClcbiAgICAgICAgICA6IHRoaXMuY29sb3JfIHx8IHVuZGVmaW5lZCxcbiAgICAgIGNyb3NzT3JpZ2luOiB0aGlzLmNyb3NzT3JpZ2luXyxcbiAgICAgIG9mZnNldDogdGhpcy5vZmZzZXRfLnNsaWNlKCksXG4gICAgICBvZmZzZXRPcmlnaW46IHRoaXMub2Zmc2V0T3JpZ2luXyxcbiAgICAgIG9wYWNpdHk6IHRoaXMuZ2V0T3BhY2l0eSgpLFxuICAgICAgcm90YXRlV2l0aFZpZXc6IHRoaXMuZ2V0Um90YXRlV2l0aFZpZXcoKSxcbiAgICAgIHJvdGF0aW9uOiB0aGlzLmdldFJvdGF0aW9uKCksXG4gICAgICBzY2FsZSxcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0LFxuICAgICAgc2l6ZTogdGhpcy5zaXplXyAhPT0gbnVsbCA/IHRoaXMuc2l6ZV8uc2xpY2UoKSA6IHVuZGVmaW5lZCxcbiAgICAgIHNyYzogdGhpcy5nZXRTcmMoKSxcbiAgICAgIGRpc3BsYWNlbWVudDogdGhpcy5nZXREaXNwbGFjZW1lbnQoKS5zbGljZSgpLFxuICAgICAgZGVjbHV0dGVyTW9kZTogdGhpcy5nZXREZWNsdXR0ZXJNb2RlKCksXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBhbmNob3IgcG9pbnQgaW4gcGl4ZWxzLiBUaGUgYW5jaG9yIGRldGVybWluZXMgdGhlIGNlbnRlciBwb2ludCBmb3IgdGhlXG4gICAqIHN5bWJvbGl6ZXIuXG4gICAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IEFuY2hvci5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0QW5jaG9yKCkge1xuICAgIGxldCBhbmNob3IgPSB0aGlzLm5vcm1hbGl6ZWRBbmNob3JfO1xuICAgIGlmICghYW5jaG9yKSB7XG4gICAgICBhbmNob3IgPSB0aGlzLmFuY2hvcl87XG4gICAgICBjb25zdCBzaXplID0gdGhpcy5nZXRTaXplKCk7XG4gICAgICBpZiAoXG4gICAgICAgIHRoaXMuYW5jaG9yWFVuaXRzXyA9PSAnZnJhY3Rpb24nIHx8XG4gICAgICAgIHRoaXMuYW5jaG9yWVVuaXRzXyA9PSAnZnJhY3Rpb24nXG4gICAgICApIHtcbiAgICAgICAgaWYgKCFzaXplKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgYW5jaG9yID0gdGhpcy5hbmNob3JfLnNsaWNlKCk7XG4gICAgICAgIGlmICh0aGlzLmFuY2hvclhVbml0c18gPT0gJ2ZyYWN0aW9uJykge1xuICAgICAgICAgIGFuY2hvclswXSAqPSBzaXplWzBdO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmFuY2hvcllVbml0c18gPT0gJ2ZyYWN0aW9uJykge1xuICAgICAgICAgIGFuY2hvclsxXSAqPSBzaXplWzFdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmFuY2hvck9yaWdpbl8gIT0gJ3RvcC1sZWZ0Jykge1xuICAgICAgICBpZiAoIXNpemUpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYW5jaG9yID09PSB0aGlzLmFuY2hvcl8pIHtcbiAgICAgICAgICBhbmNob3IgPSB0aGlzLmFuY2hvcl8uc2xpY2UoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoXG4gICAgICAgICAgdGhpcy5hbmNob3JPcmlnaW5fID09ICd0b3AtcmlnaHQnIHx8XG4gICAgICAgICAgdGhpcy5hbmNob3JPcmlnaW5fID09ICdib3R0b20tcmlnaHQnXG4gICAgICAgICkge1xuICAgICAgICAgIGFuY2hvclswXSA9IC1hbmNob3JbMF0gKyBzaXplWzBdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChcbiAgICAgICAgICB0aGlzLmFuY2hvck9yaWdpbl8gPT0gJ2JvdHRvbS1sZWZ0JyB8fFxuICAgICAgICAgIHRoaXMuYW5jaG9yT3JpZ2luXyA9PSAnYm90dG9tLXJpZ2h0J1xuICAgICAgICApIHtcbiAgICAgICAgICBhbmNob3JbMV0gPSAtYW5jaG9yWzFdICsgc2l6ZVsxXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5ub3JtYWxpemVkQW5jaG9yXyA9IGFuY2hvcjtcbiAgICB9XG4gICAgY29uc3QgZGlzcGxhY2VtZW50ID0gdGhpcy5nZXREaXNwbGFjZW1lbnQoKTtcbiAgICBjb25zdCBzY2FsZSA9IHRoaXMuZ2V0U2NhbGVBcnJheSgpO1xuICAgIC8vIGFuY2hvciBpcyBzY2FsZWQgYnkgcmVuZGVyZXIgYnV0IGRpc3BsYWNlbWVudCBzaG91bGQgbm90IGJlIHNjYWxlZFxuICAgIC8vIHNvIGRpdmlkZSBieSBzY2FsZSBoZXJlXG4gICAgcmV0dXJuIFtcbiAgICAgIGFuY2hvclswXSAtIGRpc3BsYWNlbWVudFswXSAvIHNjYWxlWzBdLFxuICAgICAgYW5jaG9yWzFdICsgZGlzcGxhY2VtZW50WzFdIC8gc2NhbGVbMV0sXG4gICAgXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGFuY2hvciBwb2ludC4gVGhlIGFuY2hvciBkZXRlcm1pbmVzIHRoZSBjZW50ZXIgcG9pbnQgZm9yIHRoZVxuICAgKiBzeW1ib2xpemVyLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGFuY2hvciBBbmNob3IuXG4gICAqIEBhcGlcbiAgICovXG4gIHNldEFuY2hvcihhbmNob3IpIHtcbiAgICB0aGlzLmFuY2hvcl8gPSBhbmNob3I7XG4gICAgdGhpcy5ub3JtYWxpemVkQW5jaG9yXyA9IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBpY29uIGNvbG9yLlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9jb2xvci5qc1wiKS5Db2xvcn0gQ29sb3IuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldENvbG9yKCkge1xuICAgIHJldHVybiB0aGlzLmNvbG9yXztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGltYWdlIGljb24uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwaXhlbFJhdGlvIFBpeGVsIHJhdGlvLlxuICAgKiBAcmV0dXJuIHtIVE1MSW1hZ2VFbGVtZW50fEhUTUxDYW52YXNFbGVtZW50fEltYWdlQml0bWFwfSBJbWFnZSBvciBDYW52YXMgZWxlbWVudC4gSWYgdGhlIEljb25cbiAgICogc3R5bGUgd2FzIGNvbmZpZ3VyZWQgd2l0aCBgc3JjYCBvciB3aXRoIGEgbm90IGxldCBsb2FkZWQgYGltZ2AsIGFuIGBJbWFnZUJpdG1hcGAgd2lsbCBiZSByZXR1cm5lZC5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0SW1hZ2UocGl4ZWxSYXRpbykge1xuICAgIHJldHVybiB0aGlzLmljb25JbWFnZV8uZ2V0SW1hZ2UocGl4ZWxSYXRpbyk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBwaXhlbCByYXRpby5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHBpeGVsUmF0aW8gUGl4ZWwgcmF0aW8uXG4gICAqIEByZXR1cm4ge251bWJlcn0gVGhlIHBpeGVsIHJhdGlvIG9mIHRoZSBpbWFnZS5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0UGl4ZWxSYXRpbyhwaXhlbFJhdGlvKSB7XG4gICAgcmV0dXJuIHRoaXMuaWNvbkltYWdlXy5nZXRQaXhlbFJhdGlvKHBpeGVsUmF0aW8pO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL3NpemUuanNcIikuU2l6ZX0gSW1hZ2Ugc2l6ZS5cbiAgICovXG4gIGdldEltYWdlU2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5pY29uSW1hZ2VfLmdldFNpemUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9JbWFnZVN0YXRlLmpzXCIpLmRlZmF1bHR9IEltYWdlIHN0YXRlLlxuICAgKi9cbiAgZ2V0SW1hZ2VTdGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5pY29uSW1hZ2VfLmdldEltYWdlU3RhdGUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtIVE1MSW1hZ2VFbGVtZW50fEhUTUxDYW52YXNFbGVtZW50fEltYWdlQml0bWFwfSBJbWFnZSBlbGVtZW50LlxuICAgKi9cbiAgZ2V0SGl0RGV0ZWN0aW9uSW1hZ2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuaWNvbkltYWdlXy5nZXRIaXREZXRlY3Rpb25JbWFnZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgb3JpZ2luIG9mIHRoZSBzeW1ib2xpemVyLlxuICAgKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBPcmlnaW4uXG4gICAqIEBhcGlcbiAgICovXG4gIGdldE9yaWdpbigpIHtcbiAgICBpZiAodGhpcy5vcmlnaW5fKSB7XG4gICAgICByZXR1cm4gdGhpcy5vcmlnaW5fO1xuICAgIH1cbiAgICBsZXQgb2Zmc2V0ID0gdGhpcy5vZmZzZXRfO1xuXG4gICAgaWYgKHRoaXMub2Zmc2V0T3JpZ2luXyAhPSAndG9wLWxlZnQnKSB7XG4gICAgICBjb25zdCBzaXplID0gdGhpcy5nZXRTaXplKCk7XG4gICAgICBjb25zdCBpY29uSW1hZ2VTaXplID0gdGhpcy5pY29uSW1hZ2VfLmdldFNpemUoKTtcbiAgICAgIGlmICghc2l6ZSB8fCAhaWNvbkltYWdlU2l6ZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIG9mZnNldCA9IG9mZnNldC5zbGljZSgpO1xuICAgICAgaWYgKFxuICAgICAgICB0aGlzLm9mZnNldE9yaWdpbl8gPT0gJ3RvcC1yaWdodCcgfHxcbiAgICAgICAgdGhpcy5vZmZzZXRPcmlnaW5fID09ICdib3R0b20tcmlnaHQnXG4gICAgICApIHtcbiAgICAgICAgb2Zmc2V0WzBdID0gaWNvbkltYWdlU2l6ZVswXSAtIHNpemVbMF0gLSBvZmZzZXRbMF07XG4gICAgICB9XG4gICAgICBpZiAoXG4gICAgICAgIHRoaXMub2Zmc2V0T3JpZ2luXyA9PSAnYm90dG9tLWxlZnQnIHx8XG4gICAgICAgIHRoaXMub2Zmc2V0T3JpZ2luXyA9PSAnYm90dG9tLXJpZ2h0J1xuICAgICAgKSB7XG4gICAgICAgIG9mZnNldFsxXSA9IGljb25JbWFnZVNpemVbMV0gLSBzaXplWzFdIC0gb2Zmc2V0WzFdO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLm9yaWdpbl8gPSBvZmZzZXQ7XG4gICAgcmV0dXJuIHRoaXMub3JpZ2luXztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGltYWdlIFVSTC5cbiAgICogQHJldHVybiB7c3RyaW5nfHVuZGVmaW5lZH0gSW1hZ2Ugc3JjLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRTcmMoKSB7XG4gICAgcmV0dXJuIHRoaXMuaWNvbkltYWdlXy5nZXRTcmMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHNpemUgb2YgdGhlIGljb24gKGluIHBpeGVscykuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL3NpemUuanNcIikuU2l6ZX0gSW1hZ2Ugc2l6ZS5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0U2l6ZSgpIHtcbiAgICByZXR1cm4gIXRoaXMuc2l6ZV8gPyB0aGlzLmljb25JbWFnZV8uZ2V0U2l6ZSgpIDogdGhpcy5zaXplXztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHdpZHRoIG9mIHRoZSBpY29uIChpbiBwaXhlbHMpLiBXaWxsIHJldHVybiB1bmRlZmluZWQgd2hlbiB0aGUgaWNvbiBpbWFnZSBpcyBub3QgeWV0IGxvYWRlZC5cbiAgICogQHJldHVybiB7bnVtYmVyfSBJY29uIHdpZHRoIChpbiBwaXhlbHMpLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRXaWR0aCgpIHtcbiAgICBjb25zdCBzY2FsZSA9IHRoaXMuZ2V0U2NhbGVBcnJheSgpO1xuICAgIGlmICh0aGlzLnNpemVfKSB7XG4gICAgICByZXR1cm4gdGhpcy5zaXplX1swXSAqIHNjYWxlWzBdO1xuICAgIH1cbiAgICBpZiAodGhpcy5pY29uSW1hZ2VfLmdldEltYWdlU3RhdGUoKSA9PSBJbWFnZVN0YXRlLkxPQURFRCkge1xuICAgICAgcmV0dXJuIHRoaXMuaWNvbkltYWdlXy5nZXRTaXplKClbMF0gKiBzY2FsZVswXTtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGhlaWdodCBvZiB0aGUgaWNvbiAoaW4gcGl4ZWxzKS4gV2lsbCByZXR1cm4gdW5kZWZpbmVkIHdoZW4gdGhlIGljb24gaW1hZ2UgaXMgbm90IHlldCBsb2FkZWQuXG4gICAqIEByZXR1cm4ge251bWJlcn0gSWNvbiBoZWlnaHQgKGluIHBpeGVscykuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldEhlaWdodCgpIHtcbiAgICBjb25zdCBzY2FsZSA9IHRoaXMuZ2V0U2NhbGVBcnJheSgpO1xuICAgIGlmICh0aGlzLnNpemVfKSB7XG4gICAgICByZXR1cm4gdGhpcy5zaXplX1sxXSAqIHNjYWxlWzFdO1xuICAgIH1cbiAgICBpZiAodGhpcy5pY29uSW1hZ2VfLmdldEltYWdlU3RhdGUoKSA9PSBJbWFnZVN0YXRlLkxPQURFRCkge1xuICAgICAgcmV0dXJuIHRoaXMuaWNvbkltYWdlXy5nZXRTaXplKClbMV0gKiBzY2FsZVsxXTtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHNjYWxlLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcnxpbXBvcnQoXCIuLi9zaXplLmpzXCIpLlNpemV9IHNjYWxlIFNjYWxlLlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRTY2FsZShzY2FsZSkge1xuICAgIGRlbGV0ZSB0aGlzLmluaXRpYWxPcHRpb25zXztcbiAgICBzdXBlci5zZXRTY2FsZShzY2FsZSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtmdW5jdGlvbihpbXBvcnQoXCIuLi9ldmVudHMvRXZlbnQuanNcIikuZGVmYXVsdCk6IHZvaWR9IGxpc3RlbmVyIExpc3RlbmVyIGZ1bmN0aW9uLlxuICAgKi9cbiAgbGlzdGVuSW1hZ2VDaGFuZ2UobGlzdGVuZXIpIHtcbiAgICB0aGlzLmljb25JbWFnZV8uYWRkRXZlbnRMaXN0ZW5lcihFdmVudFR5cGUuQ0hBTkdFLCBsaXN0ZW5lcik7XG4gIH1cblxuICAvKipcbiAgICogTG9hZCBub3QgeWV0IGxvYWRlZCBVUkkuXG4gICAqIFdoZW4gcmVuZGVyaW5nIGEgZmVhdHVyZSB3aXRoIGFuIGljb24gc3R5bGUsIHRoZSB2ZWN0b3IgcmVuZGVyZXIgd2lsbFxuICAgKiBhdXRvbWF0aWNhbGx5IGNhbGwgdGhpcyBtZXRob2QuIEhvd2V2ZXIsIHlvdSBtaWdodCB3YW50IHRvIGNhbGwgdGhpc1xuICAgKiBtZXRob2QgeW91cnNlbGYgZm9yIHByZWxvYWRpbmcgb3Igb3RoZXIgcHVycG9zZXMuXG4gICAqIEBhcGlcbiAgICovXG4gIGxvYWQoKSB7XG4gICAgdGhpcy5pY29uSW1hZ2VfLmxvYWQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKGltcG9ydChcIi4uL2V2ZW50cy9FdmVudC5qc1wiKS5kZWZhdWx0KTogdm9pZH0gbGlzdGVuZXIgTGlzdGVuZXIgZnVuY3Rpb24uXG4gICAqL1xuICB1bmxpc3RlbkltYWdlQ2hhbmdlKGxpc3RlbmVyKSB7XG4gICAgdGhpcy5pY29uSW1hZ2VfLnJlbW92ZUV2ZW50TGlzdGVuZXIoRXZlbnRUeXBlLkNIQU5HRSwgbGlzdGVuZXIpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEljb247XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvc3R5bGUvSWNvbkltYWdlXG4gKi9cblxuaW1wb3J0IEV2ZW50VGFyZ2V0IGZyb20gJy4uL2V2ZW50cy9UYXJnZXQuanMnO1xuaW1wb3J0IEV2ZW50VHlwZSBmcm9tICcuLi9ldmVudHMvRXZlbnRUeXBlLmpzJztcbmltcG9ydCBJbWFnZVN0YXRlIGZyb20gJy4uL0ltYWdlU3RhdGUuanMnO1xuaW1wb3J0IHthc1N0cmluZ30gZnJvbSAnLi4vY29sb3IuanMnO1xuaW1wb3J0IHtjcmVhdGVDYW52YXNDb250ZXh0MkR9IGZyb20gJy4uL2RvbS5qcyc7XG5pbXBvcnQge2RlY29kZUZhbGxiYWNrfSBmcm9tICcuLi9JbWFnZS5qcyc7XG5pbXBvcnQge3NoYXJlZCBhcyBpY29uSW1hZ2VDYWNoZX0gZnJvbSAnLi9JY29uSW1hZ2VDYWNoZS5qcyc7XG5cbi8qKlxuICogQHR5cGUge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH1cbiAqL1xubGV0IHRhaW50ZWRUZXN0Q29udGV4dCA9IG51bGw7XG5cbmNsYXNzIEljb25JbWFnZSBleHRlbmRzIEV2ZW50VGFyZ2V0IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7SFRNTEltYWdlRWxlbWVudHxIVE1MQ2FudmFzRWxlbWVudHxJbWFnZUJpdG1hcH0gaW1hZ2UgSW1hZ2UuXG4gICAqIEBwYXJhbSB7c3RyaW5nfHVuZGVmaW5lZH0gc3JjIFNyYy5cbiAgICogQHBhcmFtIHs/c3RyaW5nfSBjcm9zc09yaWdpbiBDcm9zcyBvcmlnaW4uXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vSW1hZ2VTdGF0ZS5qc1wiKS5kZWZhdWx0fSBpbWFnZVN0YXRlIEltYWdlIHN0YXRlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2NvbG9yLmpzXCIpLkNvbG9yfSBjb2xvciBDb2xvci5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGltYWdlLCBzcmMsIGNyb3NzT3JpZ2luLCBpbWFnZVN0YXRlLCBjb2xvcikge1xuICAgIHN1cGVyKCk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtIVE1MSW1hZ2VFbGVtZW50fEhUTUxDYW52YXNFbGVtZW50fEltYWdlQml0bWFwfVxuICAgICAqL1xuICAgIHRoaXMuaGl0RGV0ZWN0aW9uSW1hZ2VfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0hUTUxJbWFnZUVsZW1lbnR8SFRNTENhbnZhc0VsZW1lbnR8SW1hZ2VCaXRtYXB9XG4gICAgICovXG4gICAgdGhpcy5pbWFnZV8gPSBpbWFnZTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge3N0cmluZ3xudWxsfVxuICAgICAqL1xuICAgIHRoaXMuY3Jvc3NPcmlnaW5fID0gY3Jvc3NPcmlnaW47XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtPYmplY3Q8bnVtYmVyLCBIVE1MQ2FudmFzRWxlbWVudD59XG4gICAgICovXG4gICAgdGhpcy5jYW52YXNfID0ge307XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9jb2xvci5qc1wiKS5Db2xvcn1cbiAgICAgKi9cbiAgICB0aGlzLmNvbG9yXyA9IGNvbG9yO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vSW1hZ2VTdGF0ZS5qc1wiKS5kZWZhdWx0fVxuICAgICAqL1xuICAgIHRoaXMuaW1hZ2VTdGF0ZV8gPSBpbWFnZVN0YXRlID09PSB1bmRlZmluZWQgPyBJbWFnZVN0YXRlLklETEUgOiBpbWFnZVN0YXRlO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vc2l6ZS5qc1wiKS5TaXplfG51bGx9XG4gICAgICovXG4gICAgdGhpcy5zaXplXyA9XG4gICAgICBpbWFnZSAmJiBpbWFnZS53aWR0aCAmJiBpbWFnZS5oZWlnaHQgPyBbaW1hZ2Uud2lkdGgsIGltYWdlLmhlaWdodF0gOiBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7c3RyaW5nfHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLnNyY18gPSBzcmM7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMudGFpbnRlZF87XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGluaXRpYWxpemVJbWFnZV8oKSB7XG4gICAgdGhpcy5pbWFnZV8gPSBuZXcgSW1hZ2UoKTtcbiAgICBpZiAodGhpcy5jcm9zc09yaWdpbl8gIT09IG51bGwpIHtcbiAgICAgIHRoaXMuaW1hZ2VfLmNyb3NzT3JpZ2luID0gdGhpcy5jcm9zc09yaWdpbl87XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSBpbWFnZSBjYW52YXMgaXMgdGFpbnRlZC5cbiAgICovXG4gIGlzVGFpbnRlZF8oKSB7XG4gICAgaWYgKHRoaXMudGFpbnRlZF8gPT09IHVuZGVmaW5lZCAmJiB0aGlzLmltYWdlU3RhdGVfID09PSBJbWFnZVN0YXRlLkxPQURFRCkge1xuICAgICAgaWYgKCF0YWludGVkVGVzdENvbnRleHQpIHtcbiAgICAgICAgdGFpbnRlZFRlc3RDb250ZXh0ID0gY3JlYXRlQ2FudmFzQ29udGV4dDJEKDEsIDEsIHVuZGVmaW5lZCwge1xuICAgICAgICAgIHdpbGxSZWFkRnJlcXVlbnRseTogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICB0YWludGVkVGVzdENvbnRleHQuZHJhd0ltYWdlKHRoaXMuaW1hZ2VfLCAwLCAwKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRhaW50ZWRUZXN0Q29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgMSwgMSk7XG4gICAgICAgIHRoaXMudGFpbnRlZF8gPSBmYWxzZTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdGFpbnRlZFRlc3RDb250ZXh0ID0gbnVsbDtcbiAgICAgICAgdGhpcy50YWludGVkXyA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnRhaW50ZWRfID09PSB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBkaXNwYXRjaENoYW5nZUV2ZW50XygpIHtcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoRXZlbnRUeXBlLkNIQU5HRSk7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGhhbmRsZUltYWdlRXJyb3JfKCkge1xuICAgIHRoaXMuaW1hZ2VTdGF0ZV8gPSBJbWFnZVN0YXRlLkVSUk9SO1xuICAgIHRoaXMuZGlzcGF0Y2hDaGFuZ2VFdmVudF8oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaGFuZGxlSW1hZ2VMb2FkXygpIHtcbiAgICB0aGlzLmltYWdlU3RhdGVfID0gSW1hZ2VTdGF0ZS5MT0FERUQ7XG4gICAgdGhpcy5zaXplXyA9IFt0aGlzLmltYWdlXy53aWR0aCwgdGhpcy5pbWFnZV8uaGVpZ2h0XTtcbiAgICB0aGlzLmRpc3BhdGNoQ2hhbmdlRXZlbnRfKCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHBpeGVsUmF0aW8gUGl4ZWwgcmF0aW8uXG4gICAqIEByZXR1cm4ge0hUTUxJbWFnZUVsZW1lbnR8SFRNTENhbnZhc0VsZW1lbnR8SW1hZ2VCaXRtYXB9IEltYWdlIG9yIENhbnZhcyBlbGVtZW50IG9yIGltYWdlIGJpdG1hcC5cbiAgICovXG4gIGdldEltYWdlKHBpeGVsUmF0aW8pIHtcbiAgICBpZiAoIXRoaXMuaW1hZ2VfKSB7XG4gICAgICB0aGlzLmluaXRpYWxpemVJbWFnZV8oKTtcbiAgICB9XG4gICAgdGhpcy5yZXBsYWNlQ29sb3JfKHBpeGVsUmF0aW8pO1xuICAgIHJldHVybiB0aGlzLmNhbnZhc19bcGl4ZWxSYXRpb10gPyB0aGlzLmNhbnZhc19bcGl4ZWxSYXRpb10gOiB0aGlzLmltYWdlXztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gcGl4ZWxSYXRpbyBQaXhlbCByYXRpby5cbiAgICogQHJldHVybiB7bnVtYmVyfSBJbWFnZSBvciBDYW52YXMgZWxlbWVudC5cbiAgICovXG4gIGdldFBpeGVsUmF0aW8ocGl4ZWxSYXRpbykge1xuICAgIHRoaXMucmVwbGFjZUNvbG9yXyhwaXhlbFJhdGlvKTtcbiAgICByZXR1cm4gdGhpcy5jYW52YXNfW3BpeGVsUmF0aW9dID8gcGl4ZWxSYXRpbyA6IDE7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vSW1hZ2VTdGF0ZS5qc1wiKS5kZWZhdWx0fSBJbWFnZSBzdGF0ZS5cbiAgICovXG4gIGdldEltYWdlU3RhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW1hZ2VTdGF0ZV87XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7SFRNTEltYWdlRWxlbWVudHxIVE1MQ2FudmFzRWxlbWVudHxJbWFnZUJpdG1hcH0gSW1hZ2UgZWxlbWVudC5cbiAgICovXG4gIGdldEhpdERldGVjdGlvbkltYWdlKCkge1xuICAgIGlmICghdGhpcy5pbWFnZV8pIHtcbiAgICAgIHRoaXMuaW5pdGlhbGl6ZUltYWdlXygpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuaGl0RGV0ZWN0aW9uSW1hZ2VfKSB7XG4gICAgICBpZiAodGhpcy5pc1RhaW50ZWRfKCkpIHtcbiAgICAgICAgY29uc3Qgd2lkdGggPSB0aGlzLnNpemVfWzBdO1xuICAgICAgICBjb25zdCBoZWlnaHQgPSB0aGlzLnNpemVfWzFdO1xuICAgICAgICBjb25zdCBjb250ZXh0ID0gY3JlYXRlQ2FudmFzQ29udGV4dDJEKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICBjb250ZXh0LmZpbGxSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICB0aGlzLmhpdERldGVjdGlvbkltYWdlXyA9IGNvbnRleHQuY2FudmFzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5oaXREZXRlY3Rpb25JbWFnZV8gPSB0aGlzLmltYWdlXztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuaGl0RGV0ZWN0aW9uSW1hZ2VfO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgc2l6ZSBvZiB0aGUgaWNvbiAoaW4gcGl4ZWxzKS5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vc2l6ZS5qc1wiKS5TaXplfSBJbWFnZSBzaXplLlxuICAgKi9cbiAgZ2V0U2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zaXplXztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd8dW5kZWZpbmVkfSBJbWFnZSBzcmMuXG4gICAqL1xuICBnZXRTcmMoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3JjXztcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2FkIG5vdCB5ZXQgbG9hZGVkIFVSSS5cbiAgICovXG4gIGxvYWQoKSB7XG4gICAgaWYgKHRoaXMuaW1hZ2VTdGF0ZV8gIT09IEltYWdlU3RhdGUuSURMRSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuaW1hZ2VfKSB7XG4gICAgICB0aGlzLmluaXRpYWxpemVJbWFnZV8oKTtcbiAgICB9XG5cbiAgICB0aGlzLmltYWdlU3RhdGVfID0gSW1hZ2VTdGF0ZS5MT0FESU5HO1xuICAgIHRyeSB7XG4gICAgICBpZiAodGhpcy5zcmNfICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLyoqIEB0eXBlIHtIVE1MSW1hZ2VFbGVtZW50fSAqLyAodGhpcy5pbWFnZV8pLnNyYyA9IHRoaXMuc3JjXztcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aGlzLmhhbmRsZUltYWdlRXJyb3JfKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLmltYWdlXyBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQpIHtcbiAgICAgIGRlY29kZUZhbGxiYWNrKHRoaXMuaW1hZ2VfLCB0aGlzLnNyY18pXG4gICAgICAgIC50aGVuKChpbWFnZSkgPT4ge1xuICAgICAgICAgIHRoaXMuaW1hZ2VfID0gaW1hZ2U7XG4gICAgICAgICAgdGhpcy5oYW5kbGVJbWFnZUxvYWRfKCk7XG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaCh0aGlzLmhhbmRsZUltYWdlRXJyb3JfLmJpbmQodGhpcykpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gcGl4ZWxSYXRpbyBQaXhlbCByYXRpby5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHJlcGxhY2VDb2xvcl8ocGl4ZWxSYXRpbykge1xuICAgIGlmIChcbiAgICAgICF0aGlzLmNvbG9yXyB8fFxuICAgICAgdGhpcy5jYW52YXNfW3BpeGVsUmF0aW9dIHx8XG4gICAgICB0aGlzLmltYWdlU3RhdGVfICE9PSBJbWFnZVN0YXRlLkxPQURFRFxuICAgICkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGltYWdlID0gdGhpcy5pbWFnZV87XG4gICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgY2FudmFzLndpZHRoID0gTWF0aC5jZWlsKGltYWdlLndpZHRoICogcGl4ZWxSYXRpbyk7XG4gICAgY2FudmFzLmhlaWdodCA9IE1hdGguY2VpbChpbWFnZS5oZWlnaHQgKiBwaXhlbFJhdGlvKTtcblxuICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIGN0eC5zY2FsZShwaXhlbFJhdGlvLCBwaXhlbFJhdGlvKTtcbiAgICBjdHguZHJhd0ltYWdlKGltYWdlLCAwLCAwKTtcblxuICAgIGN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnbXVsdGlwbHknO1xuICAgIGN0eC5maWxsU3R5bGUgPSBhc1N0cmluZyh0aGlzLmNvbG9yXyk7XG4gICAgY3R4LmZpbGxSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCAvIHBpeGVsUmF0aW8sIGNhbnZhcy5oZWlnaHQgLyBwaXhlbFJhdGlvKTtcblxuICAgIGN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnZGVzdGluYXRpb24taW4nO1xuICAgIGN0eC5kcmF3SW1hZ2UoaW1hZ2UsIDAsIDApO1xuXG4gICAgdGhpcy5jYW52YXNfW3BpeGVsUmF0aW9dID0gY2FudmFzO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MSW1hZ2VFbGVtZW50fEhUTUxDYW52YXNFbGVtZW50fEltYWdlQml0bWFwfSBpbWFnZSBJbWFnZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBjYWNoZUtleSBTcmMuXG4gKiBAcGFyYW0gez9zdHJpbmd9IGNyb3NzT3JpZ2luIENyb3NzIG9yaWdpbi5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vSW1hZ2VTdGF0ZS5qc1wiKS5kZWZhdWx0fSBpbWFnZVN0YXRlIEltYWdlIHN0YXRlLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb2xvci5qc1wiKS5Db2xvcn0gY29sb3IgQ29sb3IuXG4gKiBAcmV0dXJuIHtJY29uSW1hZ2V9IEljb24gaW1hZ2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXQoaW1hZ2UsIGNhY2hlS2V5LCBjcm9zc09yaWdpbiwgaW1hZ2VTdGF0ZSwgY29sb3IpIHtcbiAgbGV0IGljb25JbWFnZSA9XG4gICAgY2FjaGVLZXkgPT09IHVuZGVmaW5lZFxuICAgICAgPyB1bmRlZmluZWRcbiAgICAgIDogaWNvbkltYWdlQ2FjaGUuZ2V0KGNhY2hlS2V5LCBjcm9zc09yaWdpbiwgY29sb3IpO1xuICBpZiAoIWljb25JbWFnZSkge1xuICAgIGljb25JbWFnZSA9IG5ldyBJY29uSW1hZ2UoXG4gICAgICBpbWFnZSxcbiAgICAgIGltYWdlIGluc3RhbmNlb2YgSFRNTEltYWdlRWxlbWVudCA/IGltYWdlLnNyYyB8fCB1bmRlZmluZWQgOiBjYWNoZUtleSxcbiAgICAgIGNyb3NzT3JpZ2luLFxuICAgICAgaW1hZ2VTdGF0ZSxcbiAgICAgIGNvbG9yXG4gICAgKTtcbiAgICBpY29uSW1hZ2VDYWNoZS5zZXQoY2FjaGVLZXksIGNyb3NzT3JpZ2luLCBjb2xvciwgaWNvbkltYWdlKTtcbiAgfVxuICByZXR1cm4gaWNvbkltYWdlO1xufVxuXG5leHBvcnQgZGVmYXVsdCBJY29uSW1hZ2U7XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvc3R5bGUvSWNvbkltYWdlQ2FjaGVcbiAqL1xuaW1wb3J0IHthc1N0cmluZ30gZnJvbSAnLi4vY29sb3IuanMnO1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIFNpbmdsZXRvbiBjbGFzcy4gQXZhaWxhYmxlIHRocm91Z2gge0BsaW5rIG1vZHVsZTpvbC9zdHlsZS9JY29uSW1hZ2VDYWNoZS5zaGFyZWR9LlxuICovXG5jbGFzcyBJY29uSW1hZ2VDYWNoZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHshT2JqZWN0PHN0cmluZywgaW1wb3J0KFwiLi9JY29uSW1hZ2UuanNcIikuZGVmYXVsdD59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmNhY2hlXyA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuY2FjaGVTaXplXyA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5tYXhDYWNoZVNpemVfID0gMzI7XG4gIH1cblxuICAvKipcbiAgICogRklYTUUgZW1wdHkgZGVzY3JpcHRpb24gZm9yIGpzZG9jXG4gICAqL1xuICBjbGVhcigpIHtcbiAgICB0aGlzLmNhY2hlXyA9IHt9O1xuICAgIHRoaXMuY2FjaGVTaXplXyA9IDA7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gQ2FuIGV4cGlyZSBjYWNoZS5cbiAgICovXG4gIGNhbkV4cGlyZUNhY2hlKCkge1xuICAgIHJldHVybiB0aGlzLmNhY2hlU2l6ZV8gPiB0aGlzLm1heENhY2hlU2l6ZV87XG4gIH1cblxuICAvKipcbiAgICogRklYTUUgZW1wdHkgZGVzY3JpcHRpb24gZm9yIGpzZG9jXG4gICAqL1xuICBleHBpcmUoKSB7XG4gICAgaWYgKHRoaXMuY2FuRXhwaXJlQ2FjaGUoKSkge1xuICAgICAgbGV0IGkgPSAwO1xuICAgICAgZm9yIChjb25zdCBrZXkgaW4gdGhpcy5jYWNoZV8pIHtcbiAgICAgICAgY29uc3QgaWNvbkltYWdlID0gdGhpcy5jYWNoZV9ba2V5XTtcbiAgICAgICAgaWYgKChpKysgJiAzKSA9PT0gMCAmJiAhaWNvbkltYWdlLmhhc0xpc3RlbmVyKCkpIHtcbiAgICAgICAgICBkZWxldGUgdGhpcy5jYWNoZV9ba2V5XTtcbiAgICAgICAgICAtLXRoaXMuY2FjaGVTaXplXztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3JjIFNyYy5cbiAgICogQHBhcmFtIHs/c3RyaW5nfSBjcm9zc09yaWdpbiBDcm9zcyBvcmlnaW4uXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29sb3IuanNcIikuQ29sb3J9IGNvbG9yIENvbG9yLlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuL0ljb25JbWFnZS5qc1wiKS5kZWZhdWx0fSBJY29uIGltYWdlLlxuICAgKi9cbiAgZ2V0KHNyYywgY3Jvc3NPcmlnaW4sIGNvbG9yKSB7XG4gICAgY29uc3Qga2V5ID0gZ2V0S2V5KHNyYywgY3Jvc3NPcmlnaW4sIGNvbG9yKTtcbiAgICByZXR1cm4ga2V5IGluIHRoaXMuY2FjaGVfID8gdGhpcy5jYWNoZV9ba2V5XSA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHNyYyBTcmMuXG4gICAqIEBwYXJhbSB7P3N0cmluZ30gY3Jvc3NPcmlnaW4gQ3Jvc3Mgb3JpZ2luLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2NvbG9yLmpzXCIpLkNvbG9yfSBjb2xvciBDb2xvci5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL0ljb25JbWFnZS5qc1wiKS5kZWZhdWx0fSBpY29uSW1hZ2UgSWNvbiBpbWFnZS5cbiAgICovXG4gIHNldChzcmMsIGNyb3NzT3JpZ2luLCBjb2xvciwgaWNvbkltYWdlKSB7XG4gICAgY29uc3Qga2V5ID0gZ2V0S2V5KHNyYywgY3Jvc3NPcmlnaW4sIGNvbG9yKTtcbiAgICB0aGlzLmNhY2hlX1trZXldID0gaWNvbkltYWdlO1xuICAgICsrdGhpcy5jYWNoZVNpemVfO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgY2FjaGUgc2l6ZSBvZiB0aGUgaWNvbiBjYWNoZS4gRGVmYXVsdCBpcyBgMzJgLiBDaGFuZ2UgdGhpcyB2YWx1ZSB3aGVuXG4gICAqIHlvdXIgbWFwIHVzZXMgbW9yZSB0aGFuIDMyIGRpZmZlcmVudCBpY29uIGltYWdlcyBhbmQgeW91IGFyZSBub3QgY2FjaGluZyBpY29uXG4gICAqIHN0eWxlcyBvbiB0aGUgYXBwbGljYXRpb24gbGV2ZWwuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtYXhDYWNoZVNpemUgQ2FjaGUgbWF4IHNpemUuXG4gICAqIEBhcGlcbiAgICovXG4gIHNldFNpemUobWF4Q2FjaGVTaXplKSB7XG4gICAgdGhpcy5tYXhDYWNoZVNpemVfID0gbWF4Q2FjaGVTaXplO1xuICAgIHRoaXMuZXhwaXJlKCk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3JjIFNyYy5cbiAqIEBwYXJhbSB7P3N0cmluZ30gY3Jvc3NPcmlnaW4gQ3Jvc3Mgb3JpZ2luLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb2xvci5qc1wiKS5Db2xvcn0gY29sb3IgQ29sb3IuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IENhY2hlIGtleS5cbiAqL1xuZnVuY3Rpb24gZ2V0S2V5KHNyYywgY3Jvc3NPcmlnaW4sIGNvbG9yKSB7XG4gIGNvbnN0IGNvbG9yU3RyaW5nID0gY29sb3IgPyBhc1N0cmluZyhjb2xvcikgOiAnbnVsbCc7XG4gIHJldHVybiBjcm9zc09yaWdpbiArICc6JyArIHNyYyArICc6JyArIGNvbG9yU3RyaW5nO1xufVxuXG5leHBvcnQgZGVmYXVsdCBJY29uSW1hZ2VDYWNoZTtcblxuLyoqXG4gKiBUaGUge0BsaW5rIG1vZHVsZTpvbC9zdHlsZS9JY29uSW1hZ2VDYWNoZX5JY29uSW1hZ2VDYWNoZX0gZm9yXG4gKiB7QGxpbmsgbW9kdWxlOm9sL3N0eWxlL0ljb25+SWNvbn0gaW1hZ2VzLlxuICogQGFwaVxuICovXG5leHBvcnQgY29uc3Qgc2hhcmVkID0gbmV3IEljb25JbWFnZUNhY2hlKCk7XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvc3R5bGUvSW1hZ2VcbiAqL1xuaW1wb3J0IHthYnN0cmFjdH0gZnJvbSAnLi4vdXRpbC5qcyc7XG5pbXBvcnQge3RvU2l6ZX0gZnJvbSAnLi4vc2l6ZS5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHtudW1iZXJ9IG9wYWNpdHkgT3BhY2l0eS5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gcm90YXRlV2l0aFZpZXcgSWYgdGhlIGltYWdlIHNob3VsZCBnZXQgcm90YXRlZCB3aXRoIHRoZSB2aWV3LlxuICogQHByb3BlcnR5IHtudW1iZXJ9IHJvdGF0aW9uIFJvdGF0aW9uLlxuICogQHByb3BlcnR5IHtudW1iZXJ8aW1wb3J0KFwiLi4vc2l6ZS5qc1wiKS5TaXplfSBzY2FsZSBTY2FsZS5cbiAqIEBwcm9wZXJ0eSB7QXJyYXk8bnVtYmVyPn0gZGlzcGxhY2VtZW50IERpc3BsYWNlbWVudC5cbiAqIEBwcm9wZXJ0eSB7XCJkZWNsdXR0ZXJcInxcIm9ic3RhY2xlXCJ8XCJub25lXCJ8dW5kZWZpbmVkfSBkZWNsdXR0ZXJNb2RlIERlY2x1dHRlciBtb2RlOiBgZGVjbHV0dGVyYCwgYG9ic3RhY2xlYCwgJ25vbmUgKi9cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBBIGJhc2UgY2xhc3MgdXNlZCBmb3IgY3JlYXRpbmcgc3ViY2xhc3NlcyBhbmQgbm90IGluc3RhbnRpYXRlZCBpblxuICogYXBwcy4gQmFzZSBjbGFzcyBmb3Ige0BsaW5rIG1vZHVsZTpvbC9zdHlsZS9JY29ufkljb259LCB7QGxpbmsgbW9kdWxlOm9sL3N0eWxlL0NpcmNsZX5DaXJjbGVTdHlsZX0gYW5kXG4gKiB7QGxpbmsgbW9kdWxlOm9sL3N0eWxlL1JlZ3VsYXJTaGFwZX5SZWd1bGFyU2hhcGV9LlxuICogQGFic3RyYWN0XG4gKiBAYXBpXG4gKi9cbmNsYXNzIEltYWdlU3R5bGUge1xuICAvKipcbiAgICogQHBhcmFtIHtPcHRpb25zfSBvcHRpb25zIE9wdGlvbnMuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMub3BhY2l0eV8gPSBvcHRpb25zLm9wYWNpdHk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMucm90YXRlV2l0aFZpZXdfID0gb3B0aW9ucy5yb3RhdGVXaXRoVmlldztcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnJvdGF0aW9uXyA9IG9wdGlvbnMucm90YXRpb247XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ8aW1wb3J0KFwiLi4vc2l6ZS5qc1wiKS5TaXplfVxuICAgICAqL1xuICAgIHRoaXMuc2NhbGVfID0gb3B0aW9ucy5zY2FsZTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL3NpemUuanNcIikuU2l6ZX1cbiAgICAgKi9cbiAgICB0aGlzLnNjYWxlQXJyYXlfID0gdG9TaXplKG9wdGlvbnMuc2NhbGUpO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7QXJyYXk8bnVtYmVyPn1cbiAgICAgKi9cbiAgICB0aGlzLmRpc3BsYWNlbWVudF8gPSBvcHRpb25zLmRpc3BsYWNlbWVudDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge1wiZGVjbHV0dGVyXCJ8XCJvYnN0YWNsZVwifFwibm9uZVwifHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLmRlY2x1dHRlck1vZGVfID0gb3B0aW9ucy5kZWNsdXR0ZXJNb2RlO1xuICB9XG5cbiAgLyoqXG4gICAqIENsb25lcyB0aGUgc3R5bGUuXG4gICAqIEByZXR1cm4ge0ltYWdlU3R5bGV9IFRoZSBjbG9uZWQgc3R5bGUuXG4gICAqIEBhcGlcbiAgICovXG4gIGNsb25lKCkge1xuICAgIGNvbnN0IHNjYWxlID0gdGhpcy5nZXRTY2FsZSgpO1xuICAgIHJldHVybiBuZXcgSW1hZ2VTdHlsZSh7XG4gICAgICBvcGFjaXR5OiB0aGlzLmdldE9wYWNpdHkoKSxcbiAgICAgIHNjYWxlOiBBcnJheS5pc0FycmF5KHNjYWxlKSA/IHNjYWxlLnNsaWNlKCkgOiBzY2FsZSxcbiAgICAgIHJvdGF0aW9uOiB0aGlzLmdldFJvdGF0aW9uKCksXG4gICAgICByb3RhdGVXaXRoVmlldzogdGhpcy5nZXRSb3RhdGVXaXRoVmlldygpLFxuICAgICAgZGlzcGxhY2VtZW50OiB0aGlzLmdldERpc3BsYWNlbWVudCgpLnNsaWNlKCksXG4gICAgICBkZWNsdXR0ZXJNb2RlOiB0aGlzLmdldERlY2x1dHRlck1vZGUoKSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHN5bWJvbGl6ZXIgb3BhY2l0eS5cbiAgICogQHJldHVybiB7bnVtYmVyfSBPcGFjaXR5LlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRPcGFjaXR5KCkge1xuICAgIHJldHVybiB0aGlzLm9wYWNpdHlfO1xuICB9XG5cbiAgLyoqXG4gICAqIERldGVybWluZSB3aGV0aGVyIHRoZSBzeW1ib2xpemVyIHJvdGF0ZXMgd2l0aCB0aGUgbWFwLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBSb3RhdGUgd2l0aCBtYXAuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldFJvdGF0ZVdpdGhWaWV3KCkge1xuICAgIHJldHVybiB0aGlzLnJvdGF0ZVdpdGhWaWV3XztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHN5bW9ibGl6ZXIgcm90YXRpb24uXG4gICAqIEByZXR1cm4ge251bWJlcn0gUm90YXRpb24uXG4gICAqIEBhcGlcbiAgICovXG4gIGdldFJvdGF0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnJvdGF0aW9uXztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHN5bWJvbGl6ZXIgc2NhbGUuXG4gICAqIEByZXR1cm4ge251bWJlcnxpbXBvcnQoXCIuLi9zaXplLmpzXCIpLlNpemV9IFNjYWxlLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRTY2FsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zY2FsZV87XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBzeW1ib2xpemVyIHNjYWxlIGFycmF5LlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9zaXplLmpzXCIpLlNpemV9IFNjYWxlIGFycmF5LlxuICAgKi9cbiAgZ2V0U2NhbGVBcnJheSgpIHtcbiAgICByZXR1cm4gdGhpcy5zY2FsZUFycmF5XztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGRpc3BsYWNlbWVudCBvZiB0aGUgc2hhcGVcbiAgICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gU2hhcGUncyBjZW50ZXIgZGlzcGxhY2VtZW50XG4gICAqIEBhcGlcbiAgICovXG4gIGdldERpc3BsYWNlbWVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5kaXNwbGFjZW1lbnRfO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZGVjbHV0dGVyIG1vZGUgb2YgdGhlIHNoYXBlXG4gICAqIEByZXR1cm4ge1wiZGVjbHV0dGVyXCJ8XCJvYnN0YWNsZVwifFwibm9uZVwifHVuZGVmaW5lZH0gU2hhcGUncyBkZWNsdXR0ZXIgbW9kZVxuICAgKiBAYXBpXG4gICAqL1xuICBnZXREZWNsdXR0ZXJNb2RlKCkge1xuICAgIHJldHVybiB0aGlzLmRlY2x1dHRlck1vZGVfO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgYW5jaG9yIHBvaW50IGluIHBpeGVscy4gVGhlIGFuY2hvciBkZXRlcm1pbmVzIHRoZSBjZW50ZXIgcG9pbnQgZm9yIHRoZVxuICAgKiBzeW1ib2xpemVyLlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gQW5jaG9yLlxuICAgKi9cbiAgZ2V0QW5jaG9yKCkge1xuICAgIHJldHVybiBhYnN0cmFjdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgaW1hZ2UgZWxlbWVudCBmb3IgdGhlIHN5bWJvbGl6ZXIuXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcGFyYW0ge251bWJlcn0gcGl4ZWxSYXRpbyBQaXhlbCByYXRpby5cbiAgICogQHJldHVybiB7aW1wb3J0KCcuLi9EYXRhVGlsZS5qcycpLkltYWdlTGlrZX0gSW1hZ2UgZWxlbWVudC5cbiAgICovXG4gIGdldEltYWdlKHBpeGVsUmF0aW8pIHtcbiAgICByZXR1cm4gYWJzdHJhY3QoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHJldHVybiB7aW1wb3J0KCcuLi9EYXRhVGlsZS5qcycpLkltYWdlTGlrZX0gSW1hZ2UgZWxlbWVudC5cbiAgICovXG4gIGdldEhpdERldGVjdGlvbkltYWdlKCkge1xuICAgIHJldHVybiBhYnN0cmFjdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgaW1hZ2UgcGl4ZWwgcmF0aW8uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwaXhlbFJhdGlvIFBpeGVsIHJhdGlvLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IFBpeGVsIHJhdGlvLlxuICAgKi9cbiAgZ2V0UGl4ZWxSYXRpbyhwaXhlbFJhdGlvKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cblxuICAvKipcbiAgICogQGFic3RyYWN0XG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL0ltYWdlU3RhdGUuanNcIikuZGVmYXVsdH0gSW1hZ2Ugc3RhdGUuXG4gICAqL1xuICBnZXRJbWFnZVN0YXRlKCkge1xuICAgIHJldHVybiBhYnN0cmFjdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9zaXplLmpzXCIpLlNpemV9IEltYWdlIHNpemUuXG4gICAqL1xuICBnZXRJbWFnZVNpemUoKSB7XG4gICAgcmV0dXJuIGFic3RyYWN0KCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBvcmlnaW4gb2YgdGhlIHN5bWJvbGl6ZXIuXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBPcmlnaW4uXG4gICAqL1xuICBnZXRPcmlnaW4oKSB7XG4gICAgcmV0dXJuIGFic3RyYWN0KCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBzaXplIG9mIHRoZSBzeW1ib2xpemVyIChpbiBwaXhlbHMpLlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vc2l6ZS5qc1wiKS5TaXplfSBTaXplLlxuICAgKi9cbiAgZ2V0U2l6ZSgpIHtcbiAgICByZXR1cm4gYWJzdHJhY3QoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGRpc3BsYWNlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBkaXNwbGFjZW1lbnQgRGlzcGxhY2VtZW50LlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXREaXNwbGFjZW1lbnQoZGlzcGxhY2VtZW50KSB7XG4gICAgdGhpcy5kaXNwbGFjZW1lbnRfID0gZGlzcGxhY2VtZW50O1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgb3BhY2l0eS5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9wYWNpdHkgT3BhY2l0eS5cbiAgICogQGFwaVxuICAgKi9cbiAgc2V0T3BhY2l0eShvcGFjaXR5KSB7XG4gICAgdGhpcy5vcGFjaXR5XyA9IG9wYWNpdHk7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHdoZXRoZXIgdG8gcm90YXRlIHRoZSBzdHlsZSB3aXRoIHRoZSB2aWV3LlxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHJvdGF0ZVdpdGhWaWV3IFJvdGF0ZSB3aXRoIG1hcC5cbiAgICogQGFwaVxuICAgKi9cbiAgc2V0Um90YXRlV2l0aFZpZXcocm90YXRlV2l0aFZpZXcpIHtcbiAgICB0aGlzLnJvdGF0ZVdpdGhWaWV3XyA9IHJvdGF0ZVdpdGhWaWV3O1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgcm90YXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSByb3RhdGlvbiBSb3RhdGlvbi5cbiAgICogQGFwaVxuICAgKi9cbiAgc2V0Um90YXRpb24ocm90YXRpb24pIHtcbiAgICB0aGlzLnJvdGF0aW9uXyA9IHJvdGF0aW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgc2NhbGUuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfGltcG9ydChcIi4uL3NpemUuanNcIikuU2l6ZX0gc2NhbGUgU2NhbGUuXG4gICAqIEBhcGlcbiAgICovXG4gIHNldFNjYWxlKHNjYWxlKSB7XG4gICAgdGhpcy5zY2FsZV8gPSBzY2FsZTtcbiAgICB0aGlzLnNjYWxlQXJyYXlfID0gdG9TaXplKHNjYWxlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHBhcmFtIHtmdW5jdGlvbihpbXBvcnQoXCIuLi9ldmVudHMvRXZlbnQuanNcIikuZGVmYXVsdCk6IHZvaWR9IGxpc3RlbmVyIExpc3RlbmVyIGZ1bmN0aW9uLlxuICAgKi9cbiAgbGlzdGVuSW1hZ2VDaGFuZ2UobGlzdGVuZXIpIHtcbiAgICBhYnN0cmFjdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIExvYWQgbm90IHlldCBsb2FkZWQgVVJJLlxuICAgKiBAYWJzdHJhY3RcbiAgICovXG4gIGxvYWQoKSB7XG4gICAgYWJzdHJhY3QoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHBhcmFtIHtmdW5jdGlvbihpbXBvcnQoXCIuLi9ldmVudHMvRXZlbnQuanNcIikuZGVmYXVsdCk6IHZvaWR9IGxpc3RlbmVyIExpc3RlbmVyIGZ1bmN0aW9uLlxuICAgKi9cbiAgdW5saXN0ZW5JbWFnZUNoYW5nZShsaXN0ZW5lcikge1xuICAgIGFic3RyYWN0KCk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgSW1hZ2VTdHlsZTtcbiIsIi8qKlxuICogQG1vZHVsZSBvbC9zdHlsZS9SZWd1bGFyU2hhcGVcbiAqL1xuXG5pbXBvcnQgSW1hZ2VTdGF0ZSBmcm9tICcuLi9JbWFnZVN0YXRlLmpzJztcbmltcG9ydCBJbWFnZVN0eWxlIGZyb20gJy4vSW1hZ2UuanMnO1xuaW1wb3J0IHthc0FycmF5fSBmcm9tICcuLi9jb2xvci5qcyc7XG5pbXBvcnQge2FzQ29sb3JMaWtlfSBmcm9tICcuLi9jb2xvcmxpa2UuanMnO1xuaW1wb3J0IHtjcmVhdGVDYW52YXNDb250ZXh0MkR9IGZyb20gJy4uL2RvbS5qcyc7XG5pbXBvcnQge1xuICBkZWZhdWx0RmlsbFN0eWxlLFxuICBkZWZhdWx0TGluZUNhcCxcbiAgZGVmYXVsdExpbmVKb2luLFxuICBkZWZhdWx0TGluZVdpZHRoLFxuICBkZWZhdWx0TWl0ZXJMaW1pdCxcbiAgZGVmYXVsdFN0cm9rZVN0eWxlLFxufSBmcm9tICcuLi9yZW5kZXIvY2FudmFzLmpzJztcblxuLyoqXG4gKiBTcGVjaWZ5IHJhZGl1cyBmb3IgcmVndWxhciBwb2x5Z29ucywgb3IgcmFkaXVzMSBhbmQgcmFkaXVzMiBmb3Igc3RhcnMuXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4vRmlsbC5qc1wiKS5kZWZhdWx0fSBbZmlsbF0gRmlsbCBzdHlsZS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBwb2ludHMgTnVtYmVyIG9mIHBvaW50cyBmb3Igc3RhcnMgYW5kIHJlZ3VsYXIgcG9seWdvbnMuIEluIGNhc2Ugb2YgYSBwb2x5Z29uLCB0aGUgbnVtYmVyIG9mIHBvaW50c1xuICogaXMgdGhlIG51bWJlciBvZiBzaWRlcy5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbcmFkaXVzXSBSYWRpdXMgb2YgYSByZWd1bGFyIHBvbHlnb24uXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3JhZGl1czFdIEZpcnN0IHJhZGl1cyBvZiBhIHN0YXIuIElnbm9yZWQgaWYgcmFkaXVzIGlzIHNldC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbcmFkaXVzMl0gU2Vjb25kIHJhZGl1cyBvZiBhIHN0YXIuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2FuZ2xlPTBdIFNoYXBlJ3MgYW5nbGUgaW4gcmFkaWFucy4gQSB2YWx1ZSBvZiAwIHdpbGwgaGF2ZSBvbmUgb2YgdGhlIHNoYXBlJ3MgcG9pbnRzIGZhY2luZyB1cC5cbiAqIEBwcm9wZXJ0eSB7QXJyYXk8bnVtYmVyPn0gW2Rpc3BsYWNlbWVudD1bMCwgMF1dIERpc3BsYWNlbWVudCBvZiB0aGUgc2hhcGUgaW4gcGl4ZWxzLlxuICogUG9zaXRpdmUgdmFsdWVzIHdpbGwgc2hpZnQgdGhlIHNoYXBlIHJpZ2h0IGFuZCB1cC5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi9TdHJva2UuanNcIikuZGVmYXVsdH0gW3N0cm9rZV0gU3Ryb2tlIHN0eWxlLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtyb3RhdGlvbj0wXSBSb3RhdGlvbiBpbiByYWRpYW5zIChwb3NpdGl2ZSByb3RhdGlvbiBjbG9ja3dpc2UpLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbcm90YXRlV2l0aFZpZXc9ZmFsc2VdIFdoZXRoZXIgdG8gcm90YXRlIHRoZSBzaGFwZSB3aXRoIHRoZSB2aWV3LlxuICogQHByb3BlcnR5IHtudW1iZXJ8aW1wb3J0KFwiLi4vc2l6ZS5qc1wiKS5TaXplfSBbc2NhbGU9MV0gU2NhbGUuIFVubGVzcyB0d28gZGltZW5zaW9uYWwgc2NhbGluZyBpcyByZXF1aXJlZCBhIGJldHRlclxuICogcmVzdWx0IG1heSBiZSBvYnRhaW5lZCB3aXRoIGFwcHJvcHJpYXRlIHNldHRpbmdzIGZvciBgcmFkaXVzYCwgYHJhZGl1czFgIGFuZCBgcmFkaXVzMmAuXG4gKiBAcHJvcGVydHkge1wiZGVjbHV0dGVyXCJ8XCJvYnN0YWNsZVwifFwibm9uZVwifHVuZGVmaW5lZH0gW2RlY2x1dHRlck1vZGVdIERlY2x1dHRlciBtb2RlLlxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gUmVuZGVyT3B0aW9uc1xuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9jb2xvcmxpa2UuanNcIikuQ29sb3JMaWtlfSBbc3Ryb2tlU3R5bGVdIFN0cm9rZVN0eWxlLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IHN0cm9rZVdpZHRoIFN0cm9rZVdpZHRoLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IHNpemUgU2l6ZS5cbiAqIEBwcm9wZXJ0eSB7Q2FudmFzTGluZUNhcH0gbGluZUNhcCBMaW5lQ2FwLlxuICogQHByb3BlcnR5IHtBcnJheTxudW1iZXI+fG51bGx9IGxpbmVEYXNoIExpbmVEYXNoLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IGxpbmVEYXNoT2Zmc2V0IExpbmVEYXNoT2Zmc2V0LlxuICogQHByb3BlcnR5IHtDYW52YXNMaW5lSm9pbn0gbGluZUpvaW4gTGluZUpvaW4uXG4gKiBAcHJvcGVydHkge251bWJlcn0gbWl0ZXJMaW1pdCBNaXRlckxpbWl0LlxuICovXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogU2V0IHJlZ3VsYXIgc2hhcGUgc3R5bGUgZm9yIHZlY3RvciBmZWF0dXJlcy4gVGhlIHJlc3VsdGluZyBzaGFwZSB3aWxsIGJlXG4gKiBhIHJlZ3VsYXIgcG9seWdvbiB3aGVuIGByYWRpdXNgIGlzIHByb3ZpZGVkLCBvciBhIHN0YXIgd2hlbiBgcmFkaXVzMWAgYW5kXG4gKiBgcmFkaXVzMmAgYXJlIHByb3ZpZGVkLlxuICogQGFwaVxuICovXG5jbGFzcyBSZWd1bGFyU2hhcGUgZXh0ZW5kcyBJbWFnZVN0eWxlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7T3B0aW9uc30gb3B0aW9ucyBPcHRpb25zLlxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIGNvbnN0IHJvdGF0ZVdpdGhWaWV3ID1cbiAgICAgIG9wdGlvbnMucm90YXRlV2l0aFZpZXcgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMucm90YXRlV2l0aFZpZXcgOiBmYWxzZTtcblxuICAgIHN1cGVyKHtcbiAgICAgIG9wYWNpdHk6IDEsXG4gICAgICByb3RhdGVXaXRoVmlldzogcm90YXRlV2l0aFZpZXcsXG4gICAgICByb3RhdGlvbjogb3B0aW9ucy5yb3RhdGlvbiAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5yb3RhdGlvbiA6IDAsXG4gICAgICBzY2FsZTogb3B0aW9ucy5zY2FsZSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5zY2FsZSA6IDEsXG4gICAgICBkaXNwbGFjZW1lbnQ6XG4gICAgICAgIG9wdGlvbnMuZGlzcGxhY2VtZW50ICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmRpc3BsYWNlbWVudCA6IFswLCAwXSxcbiAgICAgIGRlY2x1dHRlck1vZGU6IG9wdGlvbnMuZGVjbHV0dGVyTW9kZSxcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge09iamVjdDxudW1iZXIsIEhUTUxDYW52YXNFbGVtZW50Pn1cbiAgICAgKi9cbiAgICB0aGlzLmNhbnZhc18gPSB1bmRlZmluZWQ7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtIVE1MQ2FudmFzRWxlbWVudH1cbiAgICAgKi9cbiAgICB0aGlzLmhpdERldGVjdGlvbkNhbnZhc18gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi9GaWxsLmpzXCIpLmRlZmF1bHR9XG4gICAgICovXG4gICAgdGhpcy5maWxsXyA9IG9wdGlvbnMuZmlsbCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5maWxsIDogbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0FycmF5PG51bWJlcj59XG4gICAgICovXG4gICAgdGhpcy5vcmlnaW5fID0gWzAsIDBdO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucG9pbnRzXyA9IG9wdGlvbnMucG9pbnRzO1xuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5yYWRpdXNfID1cbiAgICAgIG9wdGlvbnMucmFkaXVzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnJhZGl1cyA6IG9wdGlvbnMucmFkaXVzMTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcnx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5yYWRpdXMyXyA9IG9wdGlvbnMucmFkaXVzMjtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmFuZ2xlXyA9IG9wdGlvbnMuYW5nbGUgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuYW5nbGUgOiAwO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi9TdHJva2UuanNcIikuZGVmYXVsdH1cbiAgICAgKi9cbiAgICB0aGlzLnN0cm9rZV8gPSBvcHRpb25zLnN0cm9rZSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5zdHJva2UgOiBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vc2l6ZS5qc1wiKS5TaXplfVxuICAgICAqL1xuICAgIHRoaXMuc2l6ZV8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7UmVuZGVyT3B0aW9uc31cbiAgICAgKi9cbiAgICB0aGlzLnJlbmRlck9wdGlvbnNfID0gbnVsbDtcblxuICAgIHRoaXMucmVuZGVyKCk7XG4gIH1cblxuICAvKipcbiAgICogQ2xvbmVzIHRoZSBzdHlsZS5cbiAgICogQHJldHVybiB7UmVndWxhclNoYXBlfSBUaGUgY2xvbmVkIHN0eWxlLlxuICAgKiBAYXBpXG4gICAqL1xuICBjbG9uZSgpIHtcbiAgICBjb25zdCBzY2FsZSA9IHRoaXMuZ2V0U2NhbGUoKTtcbiAgICBjb25zdCBzdHlsZSA9IG5ldyBSZWd1bGFyU2hhcGUoe1xuICAgICAgZmlsbDogdGhpcy5nZXRGaWxsKCkgPyB0aGlzLmdldEZpbGwoKS5jbG9uZSgpIDogdW5kZWZpbmVkLFxuICAgICAgcG9pbnRzOiB0aGlzLmdldFBvaW50cygpLFxuICAgICAgcmFkaXVzOiB0aGlzLmdldFJhZGl1cygpLFxuICAgICAgcmFkaXVzMjogdGhpcy5nZXRSYWRpdXMyKCksXG4gICAgICBhbmdsZTogdGhpcy5nZXRBbmdsZSgpLFxuICAgICAgc3Ryb2tlOiB0aGlzLmdldFN0cm9rZSgpID8gdGhpcy5nZXRTdHJva2UoKS5jbG9uZSgpIDogdW5kZWZpbmVkLFxuICAgICAgcm90YXRpb246IHRoaXMuZ2V0Um90YXRpb24oKSxcbiAgICAgIHJvdGF0ZVdpdGhWaWV3OiB0aGlzLmdldFJvdGF0ZVdpdGhWaWV3KCksXG4gICAgICBzY2FsZTogQXJyYXkuaXNBcnJheShzY2FsZSkgPyBzY2FsZS5zbGljZSgpIDogc2NhbGUsXG4gICAgICBkaXNwbGFjZW1lbnQ6IHRoaXMuZ2V0RGlzcGxhY2VtZW50KCkuc2xpY2UoKSxcbiAgICAgIGRlY2x1dHRlck1vZGU6IHRoaXMuZ2V0RGVjbHV0dGVyTW9kZSgpLFxuICAgIH0pO1xuICAgIHN0eWxlLnNldE9wYWNpdHkodGhpcy5nZXRPcGFjaXR5KCkpO1xuICAgIHJldHVybiBzdHlsZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGFuY2hvciBwb2ludCBpbiBwaXhlbHMuIFRoZSBhbmNob3IgZGV0ZXJtaW5lcyB0aGUgY2VudGVyIHBvaW50IGZvciB0aGVcbiAgICogc3ltYm9saXplci5cbiAgICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gQW5jaG9yLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRBbmNob3IoKSB7XG4gICAgY29uc3Qgc2l6ZSA9IHRoaXMuc2l6ZV87XG4gICAgaWYgKCFzaXplKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgZGlzcGxhY2VtZW50ID0gdGhpcy5nZXREaXNwbGFjZW1lbnQoKTtcbiAgICBjb25zdCBzY2FsZSA9IHRoaXMuZ2V0U2NhbGVBcnJheSgpO1xuICAgIC8vIGFuY2hvciBpcyBzY2FsZWQgYnkgcmVuZGVyZXIgYnV0IGRpc3BsYWNlbWVudCBzaG91bGQgbm90IGJlIHNjYWxlZFxuICAgIC8vIHNvIGRpdmlkZSBieSBzY2FsZSBoZXJlXG4gICAgcmV0dXJuIFtcbiAgICAgIHNpemVbMF0gLyAyIC0gZGlzcGxhY2VtZW50WzBdIC8gc2NhbGVbMF0sXG4gICAgICBzaXplWzFdIC8gMiArIGRpc3BsYWNlbWVudFsxXSAvIHNjYWxlWzFdLFxuICAgIF07XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBhbmdsZSB1c2VkIGluIGdlbmVyYXRpbmcgdGhlIHNoYXBlLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IFNoYXBlJ3Mgcm90YXRpb24gaW4gcmFkaWFucy5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0QW5nbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuYW5nbGVfO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZmlsbCBzdHlsZSBmb3IgdGhlIHNoYXBlLlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuL0ZpbGwuanNcIikuZGVmYXVsdH0gRmlsbCBzdHlsZS5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0RmlsbCgpIHtcbiAgICByZXR1cm4gdGhpcy5maWxsXztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGZpbGwgc3R5bGUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9GaWxsLmpzXCIpLmRlZmF1bHR9IGZpbGwgRmlsbCBzdHlsZS5cbiAgICogQGFwaVxuICAgKi9cbiAgc2V0RmlsbChmaWxsKSB7XG4gICAgdGhpcy5maWxsXyA9IGZpbGw7XG4gICAgdGhpcy5yZW5kZXIoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtIVE1MQ2FudmFzRWxlbWVudH0gSW1hZ2UgZWxlbWVudC5cbiAgICovXG4gIGdldEhpdERldGVjdGlvbkltYWdlKCkge1xuICAgIGlmICghdGhpcy5oaXREZXRlY3Rpb25DYW52YXNfKSB7XG4gICAgICB0aGlzLmNyZWF0ZUhpdERldGVjdGlvbkNhbnZhc18odGhpcy5yZW5kZXJPcHRpb25zXyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmhpdERldGVjdGlvbkNhbnZhc187XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBpbWFnZSBpY29uLlxuICAgKiBAcGFyYW0ge251bWJlcn0gcGl4ZWxSYXRpbyBQaXhlbCByYXRpby5cbiAgICogQHJldHVybiB7SFRNTENhbnZhc0VsZW1lbnR9IEltYWdlIG9yIENhbnZhcyBlbGVtZW50LlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRJbWFnZShwaXhlbFJhdGlvKSB7XG4gICAgbGV0IGltYWdlID0gdGhpcy5jYW52YXNfW3BpeGVsUmF0aW9dO1xuICAgIGlmICghaW1hZ2UpIHtcbiAgICAgIGNvbnN0IHJlbmRlck9wdGlvbnMgPSB0aGlzLnJlbmRlck9wdGlvbnNfO1xuICAgICAgY29uc3QgY29udGV4dCA9IGNyZWF0ZUNhbnZhc0NvbnRleHQyRChcbiAgICAgICAgcmVuZGVyT3B0aW9ucy5zaXplICogcGl4ZWxSYXRpbyxcbiAgICAgICAgcmVuZGVyT3B0aW9ucy5zaXplICogcGl4ZWxSYXRpb1xuICAgICAgKTtcbiAgICAgIHRoaXMuZHJhd18ocmVuZGVyT3B0aW9ucywgY29udGV4dCwgcGl4ZWxSYXRpbyk7XG5cbiAgICAgIGltYWdlID0gY29udGV4dC5jYW52YXM7XG4gICAgICB0aGlzLmNhbnZhc19bcGl4ZWxSYXRpb10gPSBpbWFnZTtcbiAgICB9XG4gICAgcmV0dXJuIGltYWdlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgaW1hZ2UgcGl4ZWwgcmF0aW8uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwaXhlbFJhdGlvIFBpeGVsIHJhdGlvLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IFBpeGVsIHJhdGlvLlxuICAgKi9cbiAgZ2V0UGl4ZWxSYXRpbyhwaXhlbFJhdGlvKSB7XG4gICAgcmV0dXJuIHBpeGVsUmF0aW87XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vc2l6ZS5qc1wiKS5TaXplfSBJbWFnZSBzaXplLlxuICAgKi9cbiAgZ2V0SW1hZ2VTaXplKCkge1xuICAgIHJldHVybiB0aGlzLnNpemVfO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL0ltYWdlU3RhdGUuanNcIikuZGVmYXVsdH0gSW1hZ2Ugc3RhdGUuXG4gICAqL1xuICBnZXRJbWFnZVN0YXRlKCkge1xuICAgIHJldHVybiBJbWFnZVN0YXRlLkxPQURFRDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG9yaWdpbiBvZiB0aGUgc3ltYm9saXplci5cbiAgICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gT3JpZ2luLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRPcmlnaW4oKSB7XG4gICAgcmV0dXJuIHRoaXMub3JpZ2luXztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG51bWJlciBvZiBwb2ludHMgZm9yIGdlbmVyYXRpbmcgdGhlIHNoYXBlLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IE51bWJlciBvZiBwb2ludHMgZm9yIHN0YXJzIGFuZCByZWd1bGFyIHBvbHlnb25zLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRQb2ludHMoKSB7XG4gICAgcmV0dXJuIHRoaXMucG9pbnRzXztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIChwcmltYXJ5KSByYWRpdXMgZm9yIHRoZSBzaGFwZS5cbiAgICogQHJldHVybiB7bnVtYmVyfSBSYWRpdXMuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldFJhZGl1cygpIHtcbiAgICByZXR1cm4gdGhpcy5yYWRpdXNfO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgc2Vjb25kYXJ5IHJhZGl1cyBmb3IgdGhlIHNoYXBlLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ8dW5kZWZpbmVkfSBSYWRpdXMyLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRSYWRpdXMyKCkge1xuICAgIHJldHVybiB0aGlzLnJhZGl1czJfO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgc2l6ZSBvZiB0aGUgc3ltYm9saXplciAoaW4gcGl4ZWxzKS5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vc2l6ZS5qc1wiKS5TaXplfSBTaXplLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRTaXplKCkge1xuICAgIHJldHVybiB0aGlzLnNpemVfO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgc3Ryb2tlIHN0eWxlIGZvciB0aGUgc2hhcGUuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4vU3Ryb2tlLmpzXCIpLmRlZmF1bHR9IFN0cm9rZSBzdHlsZS5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0U3Ryb2tlKCkge1xuICAgIHJldHVybiB0aGlzLnN0cm9rZV87XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBzdHJva2Ugc3R5bGUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9TdHJva2UuanNcIikuZGVmYXVsdH0gc3Ryb2tlIFN0cm9rZSBzdHlsZS5cbiAgICogQGFwaVxuICAgKi9cbiAgc2V0U3Ryb2tlKHN0cm9rZSkge1xuICAgIHRoaXMuc3Ryb2tlXyA9IHN0cm9rZTtcbiAgICB0aGlzLnJlbmRlcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oaW1wb3J0KFwiLi4vZXZlbnRzL0V2ZW50LmpzXCIpLmRlZmF1bHQpOiB2b2lkfSBsaXN0ZW5lciBMaXN0ZW5lciBmdW5jdGlvbi5cbiAgICovXG4gIGxpc3RlbkltYWdlQ2hhbmdlKGxpc3RlbmVyKSB7fVxuXG4gIC8qKlxuICAgKiBMb2FkIG5vdCB5ZXQgbG9hZGVkIFVSSS5cbiAgICovXG4gIGxvYWQoKSB7fVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKGltcG9ydChcIi4uL2V2ZW50cy9FdmVudC5qc1wiKS5kZWZhdWx0KTogdm9pZH0gbGlzdGVuZXIgTGlzdGVuZXIgZnVuY3Rpb24uXG4gICAqL1xuICB1bmxpc3RlbkltYWdlQ2hhbmdlKGxpc3RlbmVyKSB7fVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgYWRkaXRpb25hbCBjYW52YXMgc2l6ZSBuZWVkZWQgZm9yIHRoZSBtaXRlci5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGxpbmVKb2luIExpbmUgam9pblxuICAgKiBAcGFyYW0ge251bWJlcn0gc3Ryb2tlV2lkdGggU3Ryb2tlIHdpZHRoXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtaXRlckxpbWl0IE1pdGVyIGxpbWl0XG4gICAqIEByZXR1cm4ge251bWJlcn0gQWRkaXRpb25hbCBjYW52YXMgc2l6ZSBuZWVkZWRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNhbGN1bGF0ZUxpbmVKb2luU2l6ZV8obGluZUpvaW4sIHN0cm9rZVdpZHRoLCBtaXRlckxpbWl0KSB7XG4gICAgaWYgKFxuICAgICAgc3Ryb2tlV2lkdGggPT09IDAgfHxcbiAgICAgIHRoaXMucG9pbnRzXyA9PT0gSW5maW5pdHkgfHxcbiAgICAgIChsaW5lSm9pbiAhPT0gJ2JldmVsJyAmJiBsaW5lSm9pbiAhPT0gJ21pdGVyJylcbiAgICApIHtcbiAgICAgIHJldHVybiBzdHJva2VXaWR0aDtcbiAgICB9XG4gICAgLy8gbSAgfCBeXG4gICAgLy8gaSAgfCB8XFwgICAgICAgICAgICAgICAgICAuXG4gICAgLy8gdCA+fCAgI1xcXG4gICAgLy8gZSAgfCB8XFwgXFwgICAgICAgICAgICAgIC5cbiAgICAvLyByICAgICAgXFxzXFxcbiAgICAvLyAgICAgIHwgIFxcdFxcICAgICAgICAgIC4gICAgICAgICAgICAgICAgIC5cbiAgICAvLyAgICAgICAgICBcXHJcXCAgICAgICAgICAgICAgICAgICAgICAuICAgLlxuICAgIC8vICAgICAgfCAgICBcXG9cXCAgICAgIC4gICAgICAgICAgLiAgLiAuIC5cbiAgICAvLyAgICAgICAgICBlIFxca1xcICAgICAgICAgICAgLiAgLiAgICAuIC5cbiAgICAvLyAgICAgIHwgICAgICBcXGVcXCAgLiAgICAuICAuICAgICAgIC4gLlxuICAgIC8vICAgICAgIGQgICAgICBcXCBcXCAgLiAgLiAgICAgICAgICAuIC5cbiAgICAvLyAgICAgIHwgXyBfYV8gX1xcIyAgLiAgICAgICAgICAgIC4gLlxuICAgIC8vICAgcjEgICAgICAgICAgLyBgICAgICAgICAgICAgIC4gLlxuICAgIC8vICAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgLiAuXG4gICAgLy8gICAgICAgYiAgICAgLyAgICAgICAgICAgICAgIC4gLlxuICAgIC8vICAgICAgfCAgICAgICAgICAgICAgICAgICAgIC4gLlxuICAgIC8vICAgICAgICAgICAvIHIyICAgICAgICAgICAgLiAuXG4gICAgLy8gICAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgLiAgIC5cbiAgICAvLyAgICAgICAgIC8gICAgICAgICAgICAgICAgICAgICAgICAgICAuICAgLlxuICAgIC8vICAgICAgfM6xICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuICAgLlxuICAgIC8vICAgICAgIC8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4gICAuXG4gICAgLy8gICAgICDCsCBjZW50ZXJcbiAgICBsZXQgcjEgPSB0aGlzLnJhZGl1c187XG4gICAgbGV0IHIyID0gdGhpcy5yYWRpdXMyXyA9PT0gdW5kZWZpbmVkID8gcjEgOiB0aGlzLnJhZGl1czJfO1xuICAgIGlmIChyMSA8IHIyKSB7XG4gICAgICBjb25zdCB0bXAgPSByMTtcbiAgICAgIHIxID0gcjI7XG4gICAgICByMiA9IHRtcDtcbiAgICB9XG4gICAgY29uc3QgcG9pbnRzID1cbiAgICAgIHRoaXMucmFkaXVzMl8gPT09IHVuZGVmaW5lZCA/IHRoaXMucG9pbnRzXyA6IHRoaXMucG9pbnRzXyAqIDI7XG4gICAgY29uc3QgYWxwaGEgPSAoMiAqIE1hdGguUEkpIC8gcG9pbnRzO1xuICAgIGNvbnN0IGEgPSByMiAqIE1hdGguc2luKGFscGhhKTtcbiAgICBjb25zdCBiID0gTWF0aC5zcXJ0KHIyICogcjIgLSBhICogYSk7XG4gICAgY29uc3QgZCA9IHIxIC0gYjtcbiAgICBjb25zdCBlID0gTWF0aC5zcXJ0KGEgKiBhICsgZCAqIGQpO1xuICAgIGNvbnN0IG1pdGVyUmF0aW8gPSBlIC8gYTtcbiAgICBpZiAobGluZUpvaW4gPT09ICdtaXRlcicgJiYgbWl0ZXJSYXRpbyA8PSBtaXRlckxpbWl0KSB7XG4gICAgICByZXR1cm4gbWl0ZXJSYXRpbyAqIHN0cm9rZVdpZHRoO1xuICAgIH1cbiAgICAvLyBDYWxjdWxhdGUgdGhlIGRpc3RhbmNlIGZyb20gY2VudGVyIHRvIHRoZSBzdHJva2UgY29ybmVyIHdoZXJlXG4gICAgLy8gaXQgd2FzIGN1dCBzaG9ydCBiZWNhdXNlIG9mIHRoZSBtaXRlciBsaW1pdC5cbiAgICAvLyAgICAgICAgICAgICAgbFxuICAgIC8vICAgICAgICAtLS0tKy0tLS0gPD0gZGlzdGFuY2UgZnJvbSBjZW50ZXIgdG8gaGVyZSBpcyBtYXhyXG4gICAgLy8gICAgICAgLyMjIyN8ayAjI1xcXG4gICAgLy8gICAgICAvIyMjIyNeIyMjIyNcXFxuICAgIC8vICAgICAvIyMjIyAvK1xcIyBzICNcXFxuICAgIC8vICAgIC8jIyMgaC8rKytcXCMgdCAjXFxcbiAgICAvLyAgIC8jIyMgdC8rKysrK1xcIyByICNcXFxuICAgIC8vICAvIyMjIGEvKysrKysrK1xcIyBvICNcXFxuICAgIC8vIC8jIyMgcC8rKyBmaWxsICtcXCMgayAjXFxcbiAgICAvLy8jIyMjIC8rKysrK14rKysrK1xcIyBlICNcXFxuICAgIC8vIyMjIyMvKysrKysvK1xcKysrKytcXCMjIyMjXFxcbiAgICBjb25zdCBrID0gc3Ryb2tlV2lkdGggLyAyIC8gbWl0ZXJSYXRpbztcbiAgICBjb25zdCBsID0gKHN0cm9rZVdpZHRoIC8gMikgKiAoZCAvIGUpO1xuICAgIGNvbnN0IG1heHIgPSBNYXRoLnNxcnQoKHIxICsgaykgKiAocjEgKyBrKSArIGwgKiBsKTtcbiAgICBjb25zdCBiZXZlbEFkZCA9IG1heHIgLSByMTtcbiAgICBpZiAodGhpcy5yYWRpdXMyXyA9PT0gdW5kZWZpbmVkIHx8IGxpbmVKb2luID09PSAnYmV2ZWwnKSB7XG4gICAgICByZXR1cm4gYmV2ZWxBZGQgKiAyO1xuICAgIH1cbiAgICAvLyBJZiBvdXRlciBtaXRlciBpcyBvdmVyIHRoZSBtaXRlciBsaW1pdCB0aGUgaW5uZXIgbWl0ZXIgbWF5IHJlYWNoIHRocm91Z2ggdGhlXG4gICAgLy8gY2VudGVyIGFuZCBiZSBsb25nZXIgdGhhbiB0aGUgYmV2ZWwsIHNhbWUgY2FsY3VsYXRpb24gYXMgYWJvdmUgYnV0IHN3YXAgcjEgLyByMi5cbiAgICBjb25zdCBhYSA9IHIxICogTWF0aC5zaW4oYWxwaGEpO1xuICAgIGNvbnN0IGJiID0gTWF0aC5zcXJ0KHIxICogcjEgLSBhYSAqIGFhKTtcbiAgICBjb25zdCBkZCA9IHIyIC0gYmI7XG4gICAgY29uc3QgZWUgPSBNYXRoLnNxcnQoYWEgKiBhYSArIGRkICogZGQpO1xuICAgIGNvbnN0IGlubmVyTWl0ZXJSYXRpbyA9IGVlIC8gYWE7XG4gICAgaWYgKGlubmVyTWl0ZXJSYXRpbyA8PSBtaXRlckxpbWl0KSB7XG4gICAgICBjb25zdCBpbm5lckxlbmd0aCA9IChpbm5lck1pdGVyUmF0aW8gKiBzdHJva2VXaWR0aCkgLyAyIC0gcjIgLSByMTtcbiAgICAgIHJldHVybiAyICogTWF0aC5tYXgoYmV2ZWxBZGQsIGlubmVyTGVuZ3RoKTtcbiAgICB9XG4gICAgcmV0dXJuIGJldmVsQWRkICogMjtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtSZW5kZXJPcHRpb25zfSAgVGhlIHJlbmRlciBvcHRpb25zXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIGNyZWF0ZVJlbmRlck9wdGlvbnMoKSB7XG4gICAgbGV0IGxpbmVDYXAgPSBkZWZhdWx0TGluZUNhcDtcbiAgICBsZXQgbGluZUpvaW4gPSBkZWZhdWx0TGluZUpvaW47XG4gICAgbGV0IG1pdGVyTGltaXQgPSAwO1xuICAgIGxldCBsaW5lRGFzaCA9IG51bGw7XG4gICAgbGV0IGxpbmVEYXNoT2Zmc2V0ID0gMDtcbiAgICBsZXQgc3Ryb2tlU3R5bGU7XG4gICAgbGV0IHN0cm9rZVdpZHRoID0gMDtcblxuICAgIGlmICh0aGlzLnN0cm9rZV8pIHtcbiAgICAgIHN0cm9rZVN0eWxlID0gdGhpcy5zdHJva2VfLmdldENvbG9yKCk7XG4gICAgICBpZiAoc3Ryb2tlU3R5bGUgPT09IG51bGwpIHtcbiAgICAgICAgc3Ryb2tlU3R5bGUgPSBkZWZhdWx0U3Ryb2tlU3R5bGU7XG4gICAgICB9XG4gICAgICBzdHJva2VTdHlsZSA9IGFzQ29sb3JMaWtlKHN0cm9rZVN0eWxlKTtcbiAgICAgIHN0cm9rZVdpZHRoID0gdGhpcy5zdHJva2VfLmdldFdpZHRoKCk7XG4gICAgICBpZiAoc3Ryb2tlV2lkdGggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBzdHJva2VXaWR0aCA9IGRlZmF1bHRMaW5lV2lkdGg7XG4gICAgICB9XG4gICAgICBsaW5lRGFzaCA9IHRoaXMuc3Ryb2tlXy5nZXRMaW5lRGFzaCgpO1xuICAgICAgbGluZURhc2hPZmZzZXQgPSB0aGlzLnN0cm9rZV8uZ2V0TGluZURhc2hPZmZzZXQoKTtcbiAgICAgIGxpbmVKb2luID0gdGhpcy5zdHJva2VfLmdldExpbmVKb2luKCk7XG4gICAgICBpZiAobGluZUpvaW4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBsaW5lSm9pbiA9IGRlZmF1bHRMaW5lSm9pbjtcbiAgICAgIH1cbiAgICAgIGxpbmVDYXAgPSB0aGlzLnN0cm9rZV8uZ2V0TGluZUNhcCgpO1xuICAgICAgaWYgKGxpbmVDYXAgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBsaW5lQ2FwID0gZGVmYXVsdExpbmVDYXA7XG4gICAgICB9XG4gICAgICBtaXRlckxpbWl0ID0gdGhpcy5zdHJva2VfLmdldE1pdGVyTGltaXQoKTtcbiAgICAgIGlmIChtaXRlckxpbWl0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbWl0ZXJMaW1pdCA9IGRlZmF1bHRNaXRlckxpbWl0O1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGFkZCA9IHRoaXMuY2FsY3VsYXRlTGluZUpvaW5TaXplXyhsaW5lSm9pbiwgc3Ryb2tlV2lkdGgsIG1pdGVyTGltaXQpO1xuICAgIGNvbnN0IG1heFJhZGl1cyA9IE1hdGgubWF4KHRoaXMucmFkaXVzXywgdGhpcy5yYWRpdXMyXyB8fCAwKTtcbiAgICBjb25zdCBzaXplID0gTWF0aC5jZWlsKDIgKiBtYXhSYWRpdXMgKyBhZGQpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHN0cm9rZVN0eWxlOiBzdHJva2VTdHlsZSxcbiAgICAgIHN0cm9rZVdpZHRoOiBzdHJva2VXaWR0aCxcbiAgICAgIHNpemU6IHNpemUsXG4gICAgICBsaW5lQ2FwOiBsaW5lQ2FwLFxuICAgICAgbGluZURhc2g6IGxpbmVEYXNoLFxuICAgICAgbGluZURhc2hPZmZzZXQ6IGxpbmVEYXNoT2Zmc2V0LFxuICAgICAgbGluZUpvaW46IGxpbmVKb2luLFxuICAgICAgbWl0ZXJMaW1pdDogbWl0ZXJMaW1pdCxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIHJlbmRlcigpIHtcbiAgICB0aGlzLnJlbmRlck9wdGlvbnNfID0gdGhpcy5jcmVhdGVSZW5kZXJPcHRpb25zKCk7XG4gICAgY29uc3Qgc2l6ZSA9IHRoaXMucmVuZGVyT3B0aW9uc18uc2l6ZTtcbiAgICB0aGlzLmNhbnZhc18gPSB7fTtcbiAgICB0aGlzLnNpemVfID0gW3NpemUsIHNpemVdO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7UmVuZGVyT3B0aW9uc30gcmVuZGVyT3B0aW9ucyBSZW5kZXIgb3B0aW9ucy5cbiAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHQgVGhlIHJlbmRlcmluZyBjb250ZXh0LlxuICAgKiBAcGFyYW0ge251bWJlcn0gcGl4ZWxSYXRpbyBUaGUgcGl4ZWwgcmF0aW8uXG4gICAqL1xuICBkcmF3XyhyZW5kZXJPcHRpb25zLCBjb250ZXh0LCBwaXhlbFJhdGlvKSB7XG4gICAgY29udGV4dC5zY2FsZShwaXhlbFJhdGlvLCBwaXhlbFJhdGlvKTtcbiAgICAvLyBzZXQgb3JpZ2luIHRvIGNhbnZhcyBjZW50ZXJcbiAgICBjb250ZXh0LnRyYW5zbGF0ZShyZW5kZXJPcHRpb25zLnNpemUgLyAyLCByZW5kZXJPcHRpb25zLnNpemUgLyAyKTtcblxuICAgIHRoaXMuY3JlYXRlUGF0aF8oY29udGV4dCk7XG5cbiAgICBpZiAodGhpcy5maWxsXykge1xuICAgICAgbGV0IGNvbG9yID0gdGhpcy5maWxsXy5nZXRDb2xvcigpO1xuICAgICAgaWYgKGNvbG9yID09PSBudWxsKSB7XG4gICAgICAgIGNvbG9yID0gZGVmYXVsdEZpbGxTdHlsZTtcbiAgICAgIH1cbiAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gYXNDb2xvckxpa2UoY29sb3IpO1xuICAgICAgY29udGV4dC5maWxsKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLnN0cm9rZV8pIHtcbiAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSByZW5kZXJPcHRpb25zLnN0cm9rZVN0eWxlO1xuICAgICAgY29udGV4dC5saW5lV2lkdGggPSByZW5kZXJPcHRpb25zLnN0cm9rZVdpZHRoO1xuICAgICAgaWYgKHJlbmRlck9wdGlvbnMubGluZURhc2gpIHtcbiAgICAgICAgY29udGV4dC5zZXRMaW5lRGFzaChyZW5kZXJPcHRpb25zLmxpbmVEYXNoKTtcbiAgICAgICAgY29udGV4dC5saW5lRGFzaE9mZnNldCA9IHJlbmRlck9wdGlvbnMubGluZURhc2hPZmZzZXQ7XG4gICAgICB9XG4gICAgICBjb250ZXh0LmxpbmVDYXAgPSByZW5kZXJPcHRpb25zLmxpbmVDYXA7XG4gICAgICBjb250ZXh0LmxpbmVKb2luID0gcmVuZGVyT3B0aW9ucy5saW5lSm9pbjtcbiAgICAgIGNvbnRleHQubWl0ZXJMaW1pdCA9IHJlbmRlck9wdGlvbnMubWl0ZXJMaW1pdDtcbiAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7UmVuZGVyT3B0aW9uc30gcmVuZGVyT3B0aW9ucyBSZW5kZXIgb3B0aW9ucy5cbiAgICovXG4gIGNyZWF0ZUhpdERldGVjdGlvbkNhbnZhc18ocmVuZGVyT3B0aW9ucykge1xuICAgIGlmICh0aGlzLmZpbGxfKSB7XG4gICAgICBsZXQgY29sb3IgPSB0aGlzLmZpbGxfLmdldENvbG9yKCk7XG5cbiAgICAgIC8vIGRldGVybWluZSBpZiBmaWxsIGlzIHRyYW5zcGFyZW50IChvciBwYXR0ZXJuIG9yIGdyYWRpZW50KVxuICAgICAgbGV0IG9wYWNpdHkgPSAwO1xuICAgICAgaWYgKHR5cGVvZiBjb2xvciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgY29sb3IgPSBhc0FycmF5KGNvbG9yKTtcbiAgICAgIH1cbiAgICAgIGlmIChjb2xvciA9PT0gbnVsbCkge1xuICAgICAgICBvcGFjaXR5ID0gMTtcbiAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShjb2xvcikpIHtcbiAgICAgICAgb3BhY2l0eSA9IGNvbG9yLmxlbmd0aCA9PT0gNCA/IGNvbG9yWzNdIDogMTtcbiAgICAgIH1cbiAgICAgIGlmIChvcGFjaXR5ID09PSAwKSB7XG4gICAgICAgIC8vIGlmIGEgdHJhbnNwYXJlbnQgZmlsbCBzdHlsZSBpcyBzZXQsIGNyZWF0ZSBhbiBleHRyYSBoaXQtZGV0ZWN0aW9uIGltYWdlXG4gICAgICAgIC8vIHdpdGggYSBkZWZhdWx0IGZpbGwgc3R5bGVcbiAgICAgICAgY29uc3QgY29udGV4dCA9IGNyZWF0ZUNhbnZhc0NvbnRleHQyRChcbiAgICAgICAgICByZW5kZXJPcHRpb25zLnNpemUsXG4gICAgICAgICAgcmVuZGVyT3B0aW9ucy5zaXplXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuaGl0RGV0ZWN0aW9uQ2FudmFzXyA9IGNvbnRleHQuY2FudmFzO1xuXG4gICAgICAgIHRoaXMuZHJhd0hpdERldGVjdGlvbkNhbnZhc18ocmVuZGVyT3B0aW9ucywgY29udGV4dCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghdGhpcy5oaXREZXRlY3Rpb25DYW52YXNfKSB7XG4gICAgICB0aGlzLmhpdERldGVjdGlvbkNhbnZhc18gPSB0aGlzLmdldEltYWdlKDEpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY29udGV4dCBUaGUgY29udGV4dCB0byBkcmF3IGluLlxuICAgKi9cbiAgY3JlYXRlUGF0aF8oY29udGV4dCkge1xuICAgIGxldCBwb2ludHMgPSB0aGlzLnBvaW50c187XG4gICAgY29uc3QgcmFkaXVzID0gdGhpcy5yYWRpdXNfO1xuICAgIGlmIChwb2ludHMgPT09IEluZmluaXR5KSB7XG4gICAgICBjb250ZXh0LmFyYygwLCAwLCByYWRpdXMsIDAsIDIgKiBNYXRoLlBJKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgcmFkaXVzMiA9IHRoaXMucmFkaXVzMl8gPT09IHVuZGVmaW5lZCA/IHJhZGl1cyA6IHRoaXMucmFkaXVzMl87XG4gICAgICBpZiAodGhpcy5yYWRpdXMyXyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHBvaW50cyAqPSAyO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3RhcnRBbmdsZSA9IHRoaXMuYW5nbGVfIC0gTWF0aC5QSSAvIDI7XG4gICAgICBjb25zdCBzdGVwID0gKDIgKiBNYXRoLlBJKSAvIHBvaW50cztcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9pbnRzOyBpKyspIHtcbiAgICAgICAgY29uc3QgYW5nbGUwID0gc3RhcnRBbmdsZSArIGkgKiBzdGVwO1xuICAgICAgICBjb25zdCByYWRpdXNDID0gaSAlIDIgPT09IDAgPyByYWRpdXMgOiByYWRpdXMyO1xuICAgICAgICBjb250ZXh0LmxpbmVUbyhyYWRpdXNDICogTWF0aC5jb3MoYW5nbGUwKSwgcmFkaXVzQyAqIE1hdGguc2luKGFuZ2xlMCkpO1xuICAgICAgfVxuICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtSZW5kZXJPcHRpb25zfSByZW5kZXJPcHRpb25zIFJlbmRlciBvcHRpb25zLlxuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY29udGV4dCBUaGUgY29udGV4dC5cbiAgICovXG4gIGRyYXdIaXREZXRlY3Rpb25DYW52YXNfKHJlbmRlck9wdGlvbnMsIGNvbnRleHQpIHtcbiAgICAvLyBzZXQgb3JpZ2luIHRvIGNhbnZhcyBjZW50ZXJcbiAgICBjb250ZXh0LnRyYW5zbGF0ZShyZW5kZXJPcHRpb25zLnNpemUgLyAyLCByZW5kZXJPcHRpb25zLnNpemUgLyAyKTtcblxuICAgIHRoaXMuY3JlYXRlUGF0aF8oY29udGV4dCk7XG5cbiAgICBjb250ZXh0LmZpbGxTdHlsZSA9IGRlZmF1bHRGaWxsU3R5bGU7XG4gICAgY29udGV4dC5maWxsKCk7XG4gICAgaWYgKHRoaXMuc3Ryb2tlXykge1xuICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9IHJlbmRlck9wdGlvbnMuc3Ryb2tlU3R5bGU7XG4gICAgICBjb250ZXh0LmxpbmVXaWR0aCA9IHJlbmRlck9wdGlvbnMuc3Ryb2tlV2lkdGg7XG4gICAgICBpZiAocmVuZGVyT3B0aW9ucy5saW5lRGFzaCkge1xuICAgICAgICBjb250ZXh0LnNldExpbmVEYXNoKHJlbmRlck9wdGlvbnMubGluZURhc2gpO1xuICAgICAgICBjb250ZXh0LmxpbmVEYXNoT2Zmc2V0ID0gcmVuZGVyT3B0aW9ucy5saW5lRGFzaE9mZnNldDtcbiAgICAgIH1cbiAgICAgIGNvbnRleHQubGluZUpvaW4gPSByZW5kZXJPcHRpb25zLmxpbmVKb2luO1xuICAgICAgY29udGV4dC5taXRlckxpbWl0ID0gcmVuZGVyT3B0aW9ucy5taXRlckxpbWl0O1xuICAgICAgY29udGV4dC5zdHJva2UoKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgUmVndWxhclNoYXBlO1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3N0eWxlL1N0cm9rZVxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9jb2xvci5qc1wiKS5Db2xvcnxpbXBvcnQoXCIuLi9jb2xvcmxpa2UuanNcIikuQ29sb3JMaWtlfSBbY29sb3JdIEEgY29sb3IsIGdyYWRpZW50IG9yIHBhdHRlcm4uXG4gKiBTZWUge0BsaW5rIG1vZHVsZTpvbC9jb2xvcn5Db2xvcn0gYW5kIHtAbGluayBtb2R1bGU6b2wvY29sb3JsaWtlfkNvbG9yTGlrZX0gZm9yIHBvc3NpYmxlIGZvcm1hdHMuXG4gKiBEZWZhdWx0IG51bGw7IGlmIG51bGwsIHRoZSBDYW52YXMvcmVuZGVyZXIgZGVmYXVsdCBibGFjayB3aWxsIGJlIHVzZWQuXG4gKiBAcHJvcGVydHkge0NhbnZhc0xpbmVDYXB9IFtsaW5lQ2FwPSdyb3VuZCddIExpbmUgY2FwIHN0eWxlOiBgYnV0dGAsIGByb3VuZGAsIG9yIGBzcXVhcmVgLlxuICogQHByb3BlcnR5IHtDYW52YXNMaW5lSm9pbn0gW2xpbmVKb2luPSdyb3VuZCddIExpbmUgam9pbiBzdHlsZTogYGJldmVsYCwgYHJvdW5kYCwgb3IgYG1pdGVyYC5cbiAqIEBwcm9wZXJ0eSB7QXJyYXk8bnVtYmVyPn0gW2xpbmVEYXNoXSBMaW5lIGRhc2ggcGF0dGVybi4gRGVmYXVsdCBpcyBgbnVsbGAgKG5vIGRhc2gpLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtsaW5lRGFzaE9mZnNldD0wXSBMaW5lIGRhc2ggb2Zmc2V0LlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFttaXRlckxpbWl0PTEwXSBNaXRlciBsaW1pdC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbd2lkdGhdIFdpZHRoLlxuICovXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogU2V0IHN0cm9rZSBzdHlsZSBmb3IgdmVjdG9yIGZlYXR1cmVzLlxuICogTm90ZSB0aGF0IHRoZSBkZWZhdWx0cyBnaXZlbiBhcmUgdGhlIENhbnZhcyBkZWZhdWx0cywgd2hpY2ggd2lsbCBiZSB1c2VkIGlmXG4gKiBvcHRpb24gaXMgbm90IGRlZmluZWQuIFRoZSBgZ2V0YCBmdW5jdGlvbnMgcmV0dXJuIHdoYXRldmVyIHdhcyBlbnRlcmVkIGluXG4gKiB0aGUgb3B0aW9uczsgdGhleSB3aWxsIG5vdCByZXR1cm4gdGhlIGRlZmF1bHQuXG4gKiBAYXBpXG4gKi9cbmNsYXNzIFN0cm9rZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge09wdGlvbnN9IFtvcHRpb25zXSBPcHRpb25zLlxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vY29sb3IuanNcIikuQ29sb3J8aW1wb3J0KFwiLi4vY29sb3JsaWtlLmpzXCIpLkNvbG9yTGlrZX1cbiAgICAgKi9cbiAgICB0aGlzLmNvbG9yXyA9IG9wdGlvbnMuY29sb3IgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuY29sb3IgOiBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7Q2FudmFzTGluZUNhcHx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5saW5lQ2FwXyA9IG9wdGlvbnMubGluZUNhcDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0FycmF5PG51bWJlcj58bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLmxpbmVEYXNoXyA9IG9wdGlvbnMubGluZURhc2ggIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMubGluZURhc2ggOiBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLmxpbmVEYXNoT2Zmc2V0XyA9IG9wdGlvbnMubGluZURhc2hPZmZzZXQ7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtDYW52YXNMaW5lSm9pbnx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5saW5lSm9pbl8gPSBvcHRpb25zLmxpbmVKb2luO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLm1pdGVyTGltaXRfID0gb3B0aW9ucy5taXRlckxpbWl0O1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLndpZHRoXyA9IG9wdGlvbnMud2lkdGg7XG4gIH1cblxuICAvKipcbiAgICogQ2xvbmVzIHRoZSBzdHlsZS5cbiAgICogQHJldHVybiB7U3Ryb2tlfSBUaGUgY2xvbmVkIHN0eWxlLlxuICAgKiBAYXBpXG4gICAqL1xuICBjbG9uZSgpIHtcbiAgICBjb25zdCBjb2xvciA9IHRoaXMuZ2V0Q29sb3IoKTtcbiAgICByZXR1cm4gbmV3IFN0cm9rZSh7XG4gICAgICBjb2xvcjogQXJyYXkuaXNBcnJheShjb2xvcikgPyBjb2xvci5zbGljZSgpIDogY29sb3IgfHwgdW5kZWZpbmVkLFxuICAgICAgbGluZUNhcDogdGhpcy5nZXRMaW5lQ2FwKCksXG4gICAgICBsaW5lRGFzaDogdGhpcy5nZXRMaW5lRGFzaCgpID8gdGhpcy5nZXRMaW5lRGFzaCgpLnNsaWNlKCkgOiB1bmRlZmluZWQsXG4gICAgICBsaW5lRGFzaE9mZnNldDogdGhpcy5nZXRMaW5lRGFzaE9mZnNldCgpLFxuICAgICAgbGluZUpvaW46IHRoaXMuZ2V0TGluZUpvaW4oKSxcbiAgICAgIG1pdGVyTGltaXQ6IHRoaXMuZ2V0TWl0ZXJMaW1pdCgpLFxuICAgICAgd2lkdGg6IHRoaXMuZ2V0V2lkdGgoKSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHN0cm9rZSBjb2xvci5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vY29sb3IuanNcIikuQ29sb3J8aW1wb3J0KFwiLi4vY29sb3JsaWtlLmpzXCIpLkNvbG9yTGlrZX0gQ29sb3IuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldENvbG9yKCkge1xuICAgIHJldHVybiB0aGlzLmNvbG9yXztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGxpbmUgY2FwIHR5cGUgZm9yIHRoZSBzdHJva2UuXG4gICAqIEByZXR1cm4ge0NhbnZhc0xpbmVDYXB8dW5kZWZpbmVkfSBMaW5lIGNhcC5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0TGluZUNhcCgpIHtcbiAgICByZXR1cm4gdGhpcy5saW5lQ2FwXztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGxpbmUgZGFzaCBzdHlsZSBmb3IgdGhlIHN0cm9rZS5cbiAgICogQHJldHVybiB7QXJyYXk8bnVtYmVyPnxudWxsfSBMaW5lIGRhc2guXG4gICAqIEBhcGlcbiAgICovXG4gIGdldExpbmVEYXNoKCkge1xuICAgIHJldHVybiB0aGlzLmxpbmVEYXNoXztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGxpbmUgZGFzaCBvZmZzZXQgZm9yIHRoZSBzdHJva2UuXG4gICAqIEByZXR1cm4ge251bWJlcnx1bmRlZmluZWR9IExpbmUgZGFzaCBvZmZzZXQuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldExpbmVEYXNoT2Zmc2V0KCkge1xuICAgIHJldHVybiB0aGlzLmxpbmVEYXNoT2Zmc2V0XztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGxpbmUgam9pbiB0eXBlIGZvciB0aGUgc3Ryb2tlLlxuICAgKiBAcmV0dXJuIHtDYW52YXNMaW5lSm9pbnx1bmRlZmluZWR9IExpbmUgam9pbi5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0TGluZUpvaW4oKSB7XG4gICAgcmV0dXJuIHRoaXMubGluZUpvaW5fO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbWl0ZXIgbGltaXQgZm9yIHRoZSBzdHJva2UuXG4gICAqIEByZXR1cm4ge251bWJlcnx1bmRlZmluZWR9IE1pdGVyIGxpbWl0LlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRNaXRlckxpbWl0KCkge1xuICAgIHJldHVybiB0aGlzLm1pdGVyTGltaXRfO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgc3Ryb2tlIHdpZHRoLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ8dW5kZWZpbmVkfSBXaWR0aC5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0V2lkdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMud2lkdGhfO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgY29sb3IuXG4gICAqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29sb3IuanNcIikuQ29sb3J8aW1wb3J0KFwiLi4vY29sb3JsaWtlLmpzXCIpLkNvbG9yTGlrZX0gY29sb3IgQ29sb3IuXG4gICAqIEBhcGlcbiAgICovXG4gIHNldENvbG9yKGNvbG9yKSB7XG4gICAgdGhpcy5jb2xvcl8gPSBjb2xvcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGxpbmUgY2FwLlxuICAgKlxuICAgKiBAcGFyYW0ge0NhbnZhc0xpbmVDYXB8dW5kZWZpbmVkfSBsaW5lQ2FwIExpbmUgY2FwLlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRMaW5lQ2FwKGxpbmVDYXApIHtcbiAgICB0aGlzLmxpbmVDYXBfID0gbGluZUNhcDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGxpbmUgZGFzaC5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheTxudW1iZXI+fG51bGx9IGxpbmVEYXNoIExpbmUgZGFzaC5cbiAgICogQGFwaVxuICAgKi9cbiAgc2V0TGluZURhc2gobGluZURhc2gpIHtcbiAgICB0aGlzLmxpbmVEYXNoXyA9IGxpbmVEYXNoO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgbGluZSBkYXNoIG9mZnNldC5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ8dW5kZWZpbmVkfSBsaW5lRGFzaE9mZnNldCBMaW5lIGRhc2ggb2Zmc2V0LlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRMaW5lRGFzaE9mZnNldChsaW5lRGFzaE9mZnNldCkge1xuICAgIHRoaXMubGluZURhc2hPZmZzZXRfID0gbGluZURhc2hPZmZzZXQ7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBsaW5lIGpvaW4uXG4gICAqXG4gICAqIEBwYXJhbSB7Q2FudmFzTGluZUpvaW58dW5kZWZpbmVkfSBsaW5lSm9pbiBMaW5lIGpvaW4uXG4gICAqIEBhcGlcbiAgICovXG4gIHNldExpbmVKb2luKGxpbmVKb2luKSB7XG4gICAgdGhpcy5saW5lSm9pbl8gPSBsaW5lSm9pbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIG1pdGVyIGxpbWl0LlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcnx1bmRlZmluZWR9IG1pdGVyTGltaXQgTWl0ZXIgbGltaXQuXG4gICAqIEBhcGlcbiAgICovXG4gIHNldE1pdGVyTGltaXQobWl0ZXJMaW1pdCkge1xuICAgIHRoaXMubWl0ZXJMaW1pdF8gPSBtaXRlckxpbWl0O1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgd2lkdGguXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfHVuZGVmaW5lZH0gd2lkdGggV2lkdGguXG4gICAqIEBhcGlcbiAgICovXG4gIHNldFdpZHRoKHdpZHRoKSB7XG4gICAgdGhpcy53aWR0aF8gPSB3aWR0aDtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBTdHJva2U7XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvc3R5bGUvU3R5bGVcbiAqL1xuXG5pbXBvcnQgQ2lyY2xlU3R5bGUgZnJvbSAnLi9DaXJjbGUuanMnO1xuaW1wb3J0IEZpbGwgZnJvbSAnLi9GaWxsLmpzJztcbmltcG9ydCBTdHJva2UgZnJvbSAnLi9TdHJva2UuanMnO1xuaW1wb3J0IHthc3NlcnR9IGZyb20gJy4uL2Fzc2VydHMuanMnO1xuXG4vKipcbiAqIEEgZnVuY3Rpb24gdGhhdCB0YWtlcyBhbiB7QGxpbmsgbW9kdWxlOm9sL0ZlYXR1cmV+RmVhdHVyZX0gYW5kIGEgYHtudW1iZXJ9YFxuICogcmVwcmVzZW50aW5nIHRoZSB2aWV3J3MgcmVzb2x1dGlvbi4gVGhlIGZ1bmN0aW9uIHNob3VsZCByZXR1cm4gYVxuICoge0BsaW5rIG1vZHVsZTpvbC9zdHlsZS9TdHlsZX5TdHlsZX0gb3IgYW4gYXJyYXkgb2YgdGhlbS4gVGhpcyB3YXkgZS5nLiBhXG4gKiB2ZWN0b3IgbGF5ZXIgY2FuIGJlIHN0eWxlZC4gSWYgdGhlIGZ1bmN0aW9uIHJldHVybnMgYHVuZGVmaW5lZGAsIHRoZVxuICogZmVhdHVyZSB3aWxsIG5vdCBiZSByZW5kZXJlZC5cbiAqXG4gKiBAdHlwZWRlZiB7ZnVuY3Rpb24oaW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5GZWF0dXJlTGlrZSwgbnVtYmVyKTooU3R5bGV8QXJyYXk8U3R5bGU+fHZvaWQpfSBTdHlsZUZ1bmN0aW9uXG4gKi9cblxuLyoqXG4gKiBBIHtAbGluayBTdHlsZX0sIGFuIGFycmF5IG9mIHtAbGluayBTdHlsZX0sIG9yIGEge0BsaW5rIFN0eWxlRnVuY3Rpb259LlxuICogQHR5cGVkZWYge1N0eWxlfEFycmF5PFN0eWxlPnxTdHlsZUZ1bmN0aW9ufSBTdHlsZUxpa2VcbiAqL1xuXG4vKipcbiAqIEEgZnVuY3Rpb24gdGhhdCB0YWtlcyBhbiB7QGxpbmsgbW9kdWxlOm9sL0ZlYXR1cmV+RmVhdHVyZX0gYXMgYXJndW1lbnQgYW5kIHJldHVybnMgYW5cbiAqIHtAbGluayBtb2R1bGU6b2wvZ2VvbS9HZW9tZXRyeX5HZW9tZXRyeX0gdGhhdCB3aWxsIGJlIHJlbmRlcmVkIGFuZCBzdHlsZWQgZm9yIHRoZSBmZWF0dXJlLlxuICpcbiAqIEB0eXBlZGVmIHtmdW5jdGlvbihpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLkZlYXR1cmVMaWtlKTpcbiAqICAgICAoaW1wb3J0KFwiLi4vZ2VvbS9HZW9tZXRyeS5qc1wiKS5kZWZhdWx0fGltcG9ydChcIi4uL3JlbmRlci9GZWF0dXJlLmpzXCIpLmRlZmF1bHR8dW5kZWZpbmVkKX0gR2VvbWV0cnlGdW5jdGlvblxuICovXG5cbi8qKlxuICogQ3VzdG9tIHJlbmRlcmVyIGZ1bmN0aW9uLiBUYWtlcyB0d28gYXJndW1lbnRzOlxuICpcbiAqIDEuIFRoZSBwaXhlbCBjb29yZGluYXRlcyBvZiB0aGUgZ2VvbWV0cnkgaW4gR2VvSlNPTiBub3RhdGlvbi5cbiAqIDIuIFRoZSB7QGxpbmsgbW9kdWxlOm9sL3JlbmRlcn5TdGF0ZX0gb2YgdGhlIGxheWVyIHJlbmRlcmVyLlxuICpcbiAqIEB0eXBlZGVmIHtmdW5jdGlvbigoaW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfEFycmF5PGltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZT58QXJyYXk8QXJyYXk8aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlPj58QXJyYXk8QXJyYXk8QXJyYXk8aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlPj4+KSxpbXBvcnQoXCIuLi9yZW5kZXIuanNcIikuU3RhdGUpOiB2b2lkfSBSZW5kZXJGdW5jdGlvblxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHtzdHJpbmd8aW1wb3J0KFwiLi4vZ2VvbS9HZW9tZXRyeS5qc1wiKS5kZWZhdWx0fEdlb21ldHJ5RnVuY3Rpb259IFtnZW9tZXRyeV0gRmVhdHVyZSBwcm9wZXJ0eSBvciBnZW9tZXRyeVxuICogb3IgZnVuY3Rpb24gcmV0dXJuaW5nIGEgZ2VvbWV0cnkgdG8gcmVuZGVyIGZvciB0aGlzIHN0eWxlLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL0ZpbGwuanNcIikuZGVmYXVsdH0gW2ZpbGxdIEZpbGwgc3R5bGUuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4vSW1hZ2UuanNcIikuZGVmYXVsdH0gW2ltYWdlXSBJbWFnZSBzdHlsZS5cbiAqIEBwcm9wZXJ0eSB7UmVuZGVyRnVuY3Rpb259IFtyZW5kZXJlcl0gQ3VzdG9tIHJlbmRlcmVyLiBXaGVuIGNvbmZpZ3VyZWQsIGBmaWxsYCwgYHN0cm9rZWAgYW5kIGBpbWFnZWAgd2lsbCBiZVxuICogaWdub3JlZCwgYW5kIHRoZSBwcm92aWRlZCBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCB3aXRoIGVhY2ggcmVuZGVyIGZyYW1lIGZvciBlYWNoIGdlb21ldHJ5LlxuICogQHByb3BlcnR5IHtSZW5kZXJGdW5jdGlvbn0gW2hpdERldGVjdGlvblJlbmRlcmVyXSBDdXN0b20gcmVuZGVyZXIgZm9yIGhpdCBkZXRlY3Rpb24uIElmIHByb3ZpZGVkIHdpbGwgYmUgdXNlZFxuICogaW4gaGl0IGRldGVjdGlvbiByZW5kZXJpbmcuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4vU3Ryb2tlLmpzXCIpLmRlZmF1bHR9IFtzdHJva2VdIFN0cm9rZSBzdHlsZS5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi9UZXh0LmpzXCIpLmRlZmF1bHR9IFt0ZXh0XSBUZXh0IHN0eWxlLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFt6SW5kZXhdIFogaW5kZXguXG4gKi9cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBDb250YWluZXIgZm9yIHZlY3RvciBmZWF0dXJlIHJlbmRlcmluZyBzdHlsZXMuIEFueSBjaGFuZ2VzIG1hZGUgdG8gdGhlIHN0eWxlXG4gKiBvciBpdHMgY2hpbGRyZW4gdGhyb3VnaCBgc2V0KigpYCBtZXRob2RzIHdpbGwgbm90IHRha2UgZWZmZWN0IHVudGlsIHRoZVxuICogZmVhdHVyZSBvciBsYXllciB0aGF0IHVzZXMgdGhlIHN0eWxlIGlzIHJlLXJlbmRlcmVkLlxuICpcbiAqICMjIEZlYXR1cmUgc3R5bGVzXG4gKlxuICogSWYgbm8gc3R5bGUgaXMgZGVmaW5lZCwgdGhlIGZvbGxvd2luZyBkZWZhdWx0IHN0eWxlIGlzIHVzZWQ6XG4gKiBgYGBqc1xuICogIGltcG9ydCB7Q2lyY2xlLCBGaWxsLCBTdHJva2UsIFN0eWxlfSBmcm9tICdvbC9zdHlsZS5qcyc7XG4gKlxuICogIGNvbnN0IGZpbGwgPSBuZXcgRmlsbCh7XG4gKiAgICBjb2xvcjogJ3JnYmEoMjU1LDI1NSwyNTUsMC40KScsXG4gKiAgfSk7XG4gKiAgY29uc3Qgc3Ryb2tlID0gbmV3IFN0cm9rZSh7XG4gKiAgICBjb2xvcjogJyMzMzk5Q0MnLFxuICogICAgd2lkdGg6IDEuMjUsXG4gKiAgfSk7XG4gKiAgY29uc3Qgc3R5bGVzID0gW1xuICogICAgbmV3IFN0eWxlKHtcbiAqICAgICAgaW1hZ2U6IG5ldyBDaXJjbGUoe1xuICogICAgICAgIGZpbGw6IGZpbGwsXG4gKiAgICAgICAgc3Ryb2tlOiBzdHJva2UsXG4gKiAgICAgICAgcmFkaXVzOiA1LFxuICogICAgICB9KSxcbiAqICAgICAgZmlsbDogZmlsbCxcbiAqICAgICAgc3Ryb2tlOiBzdHJva2UsXG4gKiAgICB9KSxcbiAqICBdO1xuICogYGBgXG4gKlxuICogQSBzZXBhcmF0ZSBlZGl0aW5nIHN0eWxlIGhhcyB0aGUgZm9sbG93aW5nIGRlZmF1bHRzOlxuICogYGBganNcbiAqICBpbXBvcnQge0NpcmNsZSwgRmlsbCwgU3Ryb2tlLCBTdHlsZX0gZnJvbSAnb2wvc3R5bGUuanMnO1xuICpcbiAqICBjb25zdCBzdHlsZXMgPSB7fTtcbiAqICBjb25zdCB3aGl0ZSA9IFsyNTUsIDI1NSwgMjU1LCAxXTtcbiAqICBjb25zdCBibHVlID0gWzAsIDE1MywgMjU1LCAxXTtcbiAqICBjb25zdCB3aWR0aCA9IDM7XG4gKiAgc3R5bGVzWydQb2x5Z29uJ10gPSBbXG4gKiAgICBuZXcgU3R5bGUoe1xuICogICAgICBmaWxsOiBuZXcgRmlsbCh7XG4gKiAgICAgICAgY29sb3I6IFsyNTUsIDI1NSwgMjU1LCAwLjVdLFxuICogICAgICB9KSxcbiAqICAgIH0pLFxuICogIF07XG4gKiAgc3R5bGVzWydNdWx0aVBvbHlnb24nXSA9XG4gKiAgICAgIHN0eWxlc1snUG9seWdvbiddO1xuICogIHN0eWxlc1snTGluZVN0cmluZyddID0gW1xuICogICAgbmV3IFN0eWxlKHtcbiAqICAgICAgc3Ryb2tlOiBuZXcgU3Ryb2tlKHtcbiAqICAgICAgICBjb2xvcjogd2hpdGUsXG4gKiAgICAgICAgd2lkdGg6IHdpZHRoICsgMixcbiAqICAgICAgfSksXG4gKiAgICB9KSxcbiAqICAgIG5ldyBTdHlsZSh7XG4gKiAgICAgIHN0cm9rZTogbmV3IFN0cm9rZSh7XG4gKiAgICAgICAgY29sb3I6IGJsdWUsXG4gKiAgICAgICAgd2lkdGg6IHdpZHRoLFxuICogICAgICB9KSxcbiAqICAgIH0pLFxuICogIF07XG4gKiAgc3R5bGVzWydNdWx0aUxpbmVTdHJpbmcnXSA9IHN0eWxlc1snTGluZVN0cmluZyddO1xuICpcbiAqICBzdHlsZXNbJ0NpcmNsZSddID0gc3R5bGVzWydQb2x5Z29uJ10uY29uY2F0KFxuICogICAgc3R5bGVzWydMaW5lU3RyaW5nJ11cbiAqICApO1xuICpcbiAqICBzdHlsZXNbJ1BvaW50J10gPSBbXG4gKiAgICBuZXcgU3R5bGUoe1xuICogICAgICBpbWFnZTogbmV3IENpcmNsZSh7XG4gKiAgICAgICAgcmFkaXVzOiB3aWR0aCAqIDIsXG4gKiAgICAgICAgZmlsbDogbmV3IEZpbGwoe1xuICogICAgICAgICAgY29sb3I6IGJsdWUsXG4gKiAgICAgICAgfSksXG4gKiAgICAgICAgc3Ryb2tlOiBuZXcgU3Ryb2tlKHtcbiAqICAgICAgICAgIGNvbG9yOiB3aGl0ZSxcbiAqICAgICAgICAgIHdpZHRoOiB3aWR0aCAvIDIsXG4gKiAgICAgICAgfSksXG4gKiAgICAgIH0pLFxuICogICAgICB6SW5kZXg6IEluZmluaXR5LFxuICogICAgfSksXG4gKiAgXTtcbiAqICBzdHlsZXNbJ011bHRpUG9pbnQnXSA9XG4gKiAgICAgIHN0eWxlc1snUG9pbnQnXTtcbiAqICBzdHlsZXNbJ0dlb21ldHJ5Q29sbGVjdGlvbiddID1cbiAqICAgICAgc3R5bGVzWydQb2x5Z29uJ10uY29uY2F0KFxuICogICAgICAgICAgc3R5bGVzWydMaW5lU3RyaW5nJ10sXG4gKiAgICAgICAgICBzdHlsZXNbJ1BvaW50J11cbiAqICAgICAgKTtcbiAqIGBgYFxuICpcbiAqIEBhcGlcbiAqL1xuY2xhc3MgU3R5bGUge1xuICAvKipcbiAgICogQHBhcmFtIHtPcHRpb25zfSBbb3B0aW9uc10gU3R5bGUgb3B0aW9ucy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge3N0cmluZ3xpbXBvcnQoXCIuLi9nZW9tL0dlb21ldHJ5LmpzXCIpLmRlZmF1bHR8R2VvbWV0cnlGdW5jdGlvbn1cbiAgICAgKi9cbiAgICB0aGlzLmdlb21ldHJ5XyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHshR2VvbWV0cnlGdW5jdGlvbn1cbiAgICAgKi9cbiAgICB0aGlzLmdlb21ldHJ5RnVuY3Rpb25fID0gZGVmYXVsdEdlb21ldHJ5RnVuY3Rpb247XG5cbiAgICBpZiAob3B0aW9ucy5nZW9tZXRyeSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLnNldEdlb21ldHJ5KG9wdGlvbnMuZ2VvbWV0cnkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4vRmlsbC5qc1wiKS5kZWZhdWx0fVxuICAgICAqL1xuICAgIHRoaXMuZmlsbF8gPSBvcHRpb25zLmZpbGwgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZmlsbCA6IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuL0ltYWdlLmpzXCIpLmRlZmF1bHR9XG4gICAgICovXG4gICAgdGhpcy5pbWFnZV8gPSBvcHRpb25zLmltYWdlICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmltYWdlIDogbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge1JlbmRlckZ1bmN0aW9ufG51bGx9XG4gICAgICovXG4gICAgdGhpcy5yZW5kZXJlcl8gPSBvcHRpb25zLnJlbmRlcmVyICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnJlbmRlcmVyIDogbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge1JlbmRlckZ1bmN0aW9ufG51bGx9XG4gICAgICovXG4gICAgdGhpcy5oaXREZXRlY3Rpb25SZW5kZXJlcl8gPVxuICAgICAgb3B0aW9ucy5oaXREZXRlY3Rpb25SZW5kZXJlciAhPT0gdW5kZWZpbmVkXG4gICAgICAgID8gb3B0aW9ucy5oaXREZXRlY3Rpb25SZW5kZXJlclxuICAgICAgICA6IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuL1N0cm9rZS5qc1wiKS5kZWZhdWx0fVxuICAgICAqL1xuICAgIHRoaXMuc3Ryb2tlXyA9IG9wdGlvbnMuc3Ryb2tlICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnN0cm9rZSA6IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuL1RleHQuanNcIikuZGVmYXVsdH1cbiAgICAgKi9cbiAgICB0aGlzLnRleHRfID0gb3B0aW9ucy50ZXh0ICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnRleHQgOiBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLnpJbmRleF8gPSBvcHRpb25zLnpJbmRleDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbG9uZXMgdGhlIHN0eWxlLlxuICAgKiBAcmV0dXJuIHtTdHlsZX0gVGhlIGNsb25lZCBzdHlsZS5cbiAgICogQGFwaVxuICAgKi9cbiAgY2xvbmUoKSB7XG4gICAgbGV0IGdlb21ldHJ5ID0gdGhpcy5nZXRHZW9tZXRyeSgpO1xuICAgIGlmIChnZW9tZXRyeSAmJiB0eXBlb2YgZ2VvbWV0cnkgPT09ICdvYmplY3QnKSB7XG4gICAgICBnZW9tZXRyeSA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vZ2VvbS9HZW9tZXRyeS5qc1wiKS5kZWZhdWx0fSAqLyAoXG4gICAgICAgIGdlb21ldHJ5XG4gICAgICApLmNsb25lKCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgU3R5bGUoe1xuICAgICAgZ2VvbWV0cnk6IGdlb21ldHJ5LFxuICAgICAgZmlsbDogdGhpcy5nZXRGaWxsKCkgPyB0aGlzLmdldEZpbGwoKS5jbG9uZSgpIDogdW5kZWZpbmVkLFxuICAgICAgaW1hZ2U6IHRoaXMuZ2V0SW1hZ2UoKSA/IHRoaXMuZ2V0SW1hZ2UoKS5jbG9uZSgpIDogdW5kZWZpbmVkLFxuICAgICAgcmVuZGVyZXI6IHRoaXMuZ2V0UmVuZGVyZXIoKSxcbiAgICAgIHN0cm9rZTogdGhpcy5nZXRTdHJva2UoKSA/IHRoaXMuZ2V0U3Ryb2tlKCkuY2xvbmUoKSA6IHVuZGVmaW5lZCxcbiAgICAgIHRleHQ6IHRoaXMuZ2V0VGV4dCgpID8gdGhpcy5nZXRUZXh0KCkuY2xvbmUoKSA6IHVuZGVmaW5lZCxcbiAgICAgIHpJbmRleDogdGhpcy5nZXRaSW5kZXgoKSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGN1c3RvbSByZW5kZXJlciBmdW5jdGlvbiB0aGF0IHdhcyBjb25maWd1cmVkIHdpdGhcbiAgICoge0BsaW5rICNzZXRSZW5kZXJlcn0gb3IgdGhlIGByZW5kZXJlcmAgY29uc3RydWN0b3Igb3B0aW9uLlxuICAgKiBAcmV0dXJuIHtSZW5kZXJGdW5jdGlvbnxudWxsfSBDdXN0b20gcmVuZGVyZXIgZnVuY3Rpb24uXG4gICAqIEBhcGlcbiAgICovXG4gIGdldFJlbmRlcmVyKCkge1xuICAgIHJldHVybiB0aGlzLnJlbmRlcmVyXztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIGEgY3VzdG9tIHJlbmRlcmVyIGZ1bmN0aW9uIGZvciB0aGlzIHN0eWxlLiBXaGVuIHNldCwgYGZpbGxgLCBgc3Ryb2tlYFxuICAgKiBhbmQgYGltYWdlYCBvcHRpb25zIG9mIHRoZSBzdHlsZSB3aWxsIGJlIGlnbm9yZWQuXG4gICAqIEBwYXJhbSB7UmVuZGVyRnVuY3Rpb258bnVsbH0gcmVuZGVyZXIgQ3VzdG9tIHJlbmRlcmVyIGZ1bmN0aW9uLlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRSZW5kZXJlcihyZW5kZXJlcikge1xuICAgIHRoaXMucmVuZGVyZXJfID0gcmVuZGVyZXI7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyBhIGN1c3RvbSByZW5kZXJlciBmdW5jdGlvbiBmb3IgdGhpcyBzdHlsZSB1c2VkXG4gICAqIGluIGhpdCBkZXRlY3Rpb24uXG4gICAqIEBwYXJhbSB7UmVuZGVyRnVuY3Rpb258bnVsbH0gcmVuZGVyZXIgQ3VzdG9tIHJlbmRlcmVyIGZ1bmN0aW9uLlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRIaXREZXRlY3Rpb25SZW5kZXJlcihyZW5kZXJlcikge1xuICAgIHRoaXMuaGl0RGV0ZWN0aW9uUmVuZGVyZXJfID0gcmVuZGVyZXI7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBjdXN0b20gcmVuZGVyZXIgZnVuY3Rpb24gdGhhdCB3YXMgY29uZmlndXJlZCB3aXRoXG4gICAqIHtAbGluayAjc2V0SGl0RGV0ZWN0aW9uUmVuZGVyZXJ9IG9yIHRoZSBgaGl0RGV0ZWN0aW9uUmVuZGVyZXJgIGNvbnN0cnVjdG9yIG9wdGlvbi5cbiAgICogQHJldHVybiB7UmVuZGVyRnVuY3Rpb258bnVsbH0gQ3VzdG9tIHJlbmRlcmVyIGZ1bmN0aW9uLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRIaXREZXRlY3Rpb25SZW5kZXJlcigpIHtcbiAgICByZXR1cm4gdGhpcy5oaXREZXRlY3Rpb25SZW5kZXJlcl87XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBnZW9tZXRyeSB0byBiZSByZW5kZXJlZC5cbiAgICogQHJldHVybiB7c3RyaW5nfGltcG9ydChcIi4uL2dlb20vR2VvbWV0cnkuanNcIikuZGVmYXVsdHxHZW9tZXRyeUZ1bmN0aW9ufVxuICAgKiBGZWF0dXJlIHByb3BlcnR5IG9yIGdlb21ldHJ5IG9yIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgZ2VvbWV0cnkgdGhhdCB3aWxsXG4gICAqIGJlIHJlbmRlcmVkIHdpdGggdGhpcyBzdHlsZS5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0R2VvbWV0cnkoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2VvbWV0cnlfO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZnVuY3Rpb24gdXNlZCB0byBnZW5lcmF0ZSBhIGdlb21ldHJ5IGZvciByZW5kZXJpbmcuXG4gICAqIEByZXR1cm4geyFHZW9tZXRyeUZ1bmN0aW9ufSBGdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aXRoIGEgZmVhdHVyZVxuICAgKiBhbmQgcmV0dXJucyB0aGUgZ2VvbWV0cnkgdG8gcmVuZGVyIGluc3RlYWQgb2YgdGhlIGZlYXR1cmUncyBnZW9tZXRyeS5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0R2VvbWV0cnlGdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5nZW9tZXRyeUZ1bmN0aW9uXztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGZpbGwgc3R5bGUuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4vRmlsbC5qc1wiKS5kZWZhdWx0fSBGaWxsIHN0eWxlLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRGaWxsKCkge1xuICAgIHJldHVybiB0aGlzLmZpbGxfO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgZmlsbCBzdHlsZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL0ZpbGwuanNcIikuZGVmYXVsdH0gZmlsbCBGaWxsIHN0eWxlLlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRGaWxsKGZpbGwpIHtcbiAgICB0aGlzLmZpbGxfID0gZmlsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGltYWdlIHN0eWxlLlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuL0ltYWdlLmpzXCIpLmRlZmF1bHR9IEltYWdlIHN0eWxlLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRJbWFnZSgpIHtcbiAgICByZXR1cm4gdGhpcy5pbWFnZV87XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBpbWFnZSBzdHlsZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL0ltYWdlLmpzXCIpLmRlZmF1bHR9IGltYWdlIEltYWdlIHN0eWxlLlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRJbWFnZShpbWFnZSkge1xuICAgIHRoaXMuaW1hZ2VfID0gaW1hZ2U7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBzdHJva2Ugc3R5bGUuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4vU3Ryb2tlLmpzXCIpLmRlZmF1bHR9IFN0cm9rZSBzdHlsZS5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0U3Ryb2tlKCkge1xuICAgIHJldHVybiB0aGlzLnN0cm9rZV87XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBzdHJva2Ugc3R5bGUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9TdHJva2UuanNcIikuZGVmYXVsdH0gc3Ryb2tlIFN0cm9rZSBzdHlsZS5cbiAgICogQGFwaVxuICAgKi9cbiAgc2V0U3Ryb2tlKHN0cm9rZSkge1xuICAgIHRoaXMuc3Ryb2tlXyA9IHN0cm9rZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHRleHQgc3R5bGUuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4vVGV4dC5qc1wiKS5kZWZhdWx0fSBUZXh0IHN0eWxlLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRUZXh0KCkge1xuICAgIHJldHVybiB0aGlzLnRleHRfO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgdGV4dCBzdHlsZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL1RleHQuanNcIikuZGVmYXVsdH0gdGV4dCBUZXh0IHN0eWxlLlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRUZXh0KHRleHQpIHtcbiAgICB0aGlzLnRleHRfID0gdGV4dDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHotaW5kZXggZm9yIHRoZSBzdHlsZS5cbiAgICogQHJldHVybiB7bnVtYmVyfHVuZGVmaW5lZH0gWkluZGV4LlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRaSW5kZXgoKSB7XG4gICAgcmV0dXJuIHRoaXMuekluZGV4XztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgYSBnZW9tZXRyeSB0aGF0IGlzIHJlbmRlcmVkIGluc3RlYWQgb2YgdGhlIGZlYXR1cmUncyBnZW9tZXRyeS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd8aW1wb3J0KFwiLi4vZ2VvbS9HZW9tZXRyeS5qc1wiKS5kZWZhdWx0fEdlb21ldHJ5RnVuY3Rpb259IGdlb21ldHJ5XG4gICAqICAgICBGZWF0dXJlIHByb3BlcnR5IG9yIGdlb21ldHJ5IG9yIGZ1bmN0aW9uIHJldHVybmluZyBhIGdlb21ldHJ5IHRvIHJlbmRlclxuICAgKiAgICAgZm9yIHRoaXMgc3R5bGUuXG4gICAqIEBhcGlcbiAgICovXG4gIHNldEdlb21ldHJ5KGdlb21ldHJ5KSB7XG4gICAgaWYgKHR5cGVvZiBnZW9tZXRyeSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy5nZW9tZXRyeUZ1bmN0aW9uXyA9IGdlb21ldHJ5O1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGdlb21ldHJ5ID09PSAnc3RyaW5nJykge1xuICAgICAgdGhpcy5nZW9tZXRyeUZ1bmN0aW9uXyA9IGZ1bmN0aW9uIChmZWF0dXJlKSB7XG4gICAgICAgIHJldHVybiAvKiogQHR5cGUge2ltcG9ydChcIi4uL2dlb20vR2VvbWV0cnkuanNcIikuZGVmYXVsdH0gKi8gKFxuICAgICAgICAgIGZlYXR1cmUuZ2V0KGdlb21ldHJ5KVxuICAgICAgICApO1xuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKCFnZW9tZXRyeSkge1xuICAgICAgdGhpcy5nZW9tZXRyeUZ1bmN0aW9uXyA9IGRlZmF1bHRHZW9tZXRyeUZ1bmN0aW9uO1xuICAgIH0gZWxzZSBpZiAoZ2VvbWV0cnkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5nZW9tZXRyeUZ1bmN0aW9uXyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vZ2VvbS9HZW9tZXRyeS5qc1wiKS5kZWZhdWx0fSAqLyAoZ2VvbWV0cnkpO1xuICAgICAgfTtcbiAgICB9XG4gICAgdGhpcy5nZW9tZXRyeV8gPSBnZW9tZXRyeTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHotaW5kZXguXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfHVuZGVmaW5lZH0gekluZGV4IFpJbmRleC5cbiAgICogQGFwaVxuICAgKi9cbiAgc2V0WkluZGV4KHpJbmRleCkge1xuICAgIHRoaXMuekluZGV4XyA9IHpJbmRleDtcbiAgfVxufVxuXG4vKipcbiAqIENvbnZlcnQgdGhlIHByb3ZpZGVkIG9iamVjdCBpbnRvIGEgc3R5bGUgZnVuY3Rpb24uICBGdW5jdGlvbnMgcGFzc2VkIHRocm91Z2hcbiAqIHVuY2hhbmdlZC4gIEFycmF5cyBvZiBTdHlsZSBvciBzaW5nbGUgc3R5bGUgb2JqZWN0cyB3cmFwcGVkIGluIGFcbiAqIG5ldyBzdHlsZSBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7U3R5bGVGdW5jdGlvbnxBcnJheTxTdHlsZT58U3R5bGV9IG9ialxuICogICAgIEEgc3R5bGUgZnVuY3Rpb24sIGEgc2luZ2xlIHN0eWxlLCBvciBhbiBhcnJheSBvZiBzdHlsZXMuXG4gKiBAcmV0dXJuIHtTdHlsZUZ1bmN0aW9ufSBBIHN0eWxlIGZ1bmN0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9GdW5jdGlvbihvYmopIHtcbiAgbGV0IHN0eWxlRnVuY3Rpb247XG5cbiAgaWYgKHR5cGVvZiBvYmogPT09ICdmdW5jdGlvbicpIHtcbiAgICBzdHlsZUZ1bmN0aW9uID0gb2JqO1xuICB9IGVsc2Uge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtBcnJheTxTdHlsZT59XG4gICAgICovXG4gICAgbGV0IHN0eWxlcztcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgICBzdHlsZXMgPSBvYmo7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFzc2VydChcbiAgICAgICAgdHlwZW9mICgvKiogQHR5cGUgez99ICovIChvYmopLmdldFpJbmRleCkgPT09ICdmdW5jdGlvbicsXG4gICAgICAgICdFeHBlY3RlZCBhbiBgU3R5bGVgIG9yIGFuIGFycmF5IG9mIGBTdHlsZWAnXG4gICAgICApO1xuICAgICAgY29uc3Qgc3R5bGUgPSAvKiogQHR5cGUge1N0eWxlfSAqLyAob2JqKTtcbiAgICAgIHN0eWxlcyA9IFtzdHlsZV07XG4gICAgfVxuICAgIHN0eWxlRnVuY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gc3R5bGVzO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIHN0eWxlRnVuY3Rpb247XG59XG5cbi8qKlxuICogQHR5cGUge0FycmF5PFN0eWxlPnxudWxsfVxuICovXG5sZXQgZGVmYXVsdFN0eWxlcyA9IG51bGw7XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLkZlYXR1cmVMaWtlfSBmZWF0dXJlIEZlYXR1cmUuXG4gKiBAcGFyYW0ge251bWJlcn0gcmVzb2x1dGlvbiBSZXNvbHV0aW9uLlxuICogQHJldHVybiB7QXJyYXk8U3R5bGU+fSBTdHlsZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZURlZmF1bHRTdHlsZShmZWF0dXJlLCByZXNvbHV0aW9uKSB7XG4gIC8vIFdlIGRvbid0IHVzZSBhbiBpbW1lZGlhdGVseS1pbnZva2VkIGZ1bmN0aW9uXG4gIC8vIGFuZCBhIGNsb3N1cmUgc28gd2UgZG9uJ3QgZ2V0IGFuIGVycm9yIGF0IHNjcmlwdCBldmFsdWF0aW9uIHRpbWUgaW5cbiAgLy8gYnJvd3NlcnMgdGhhdCBkbyBub3Qgc3VwcG9ydCBDYW52YXMuIChpbXBvcnQoXCIuL0NpcmNsZS5qc1wiKS5DaXJjbGVTdHlsZSBkb2VzXG4gIC8vIGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpIGF0IGNvbnN0cnVjdGlvbiB0aW1lLCB3aGljaCB3aWxsIGNhdXNlIGFuLmVycm9yXG4gIC8vIGluIHN1Y2ggYnJvd3NlcnMuKVxuICBpZiAoIWRlZmF1bHRTdHlsZXMpIHtcbiAgICBjb25zdCBmaWxsID0gbmV3IEZpbGwoe1xuICAgICAgY29sb3I6ICdyZ2JhKDI1NSwyNTUsMjU1LDAuNCknLFxuICAgIH0pO1xuICAgIGNvbnN0IHN0cm9rZSA9IG5ldyBTdHJva2Uoe1xuICAgICAgY29sb3I6ICcjMzM5OUNDJyxcbiAgICAgIHdpZHRoOiAxLjI1LFxuICAgIH0pO1xuICAgIGRlZmF1bHRTdHlsZXMgPSBbXG4gICAgICBuZXcgU3R5bGUoe1xuICAgICAgICBpbWFnZTogbmV3IENpcmNsZVN0eWxlKHtcbiAgICAgICAgICBmaWxsOiBmaWxsLFxuICAgICAgICAgIHN0cm9rZTogc3Ryb2tlLFxuICAgICAgICAgIHJhZGl1czogNSxcbiAgICAgICAgfSksXG4gICAgICAgIGZpbGw6IGZpbGwsXG4gICAgICAgIHN0cm9rZTogc3Ryb2tlLFxuICAgICAgfSksXG4gICAgXTtcbiAgfVxuICByZXR1cm4gZGVmYXVsdFN0eWxlcztcbn1cblxuLyoqXG4gKiBEZWZhdWx0IHN0eWxlcyBmb3IgZWRpdGluZyBmZWF0dXJlcy5cbiAqIEByZXR1cm4ge09iamVjdDxpbXBvcnQoXCIuLi9nZW9tL0dlb21ldHJ5LmpzXCIpLlR5cGUsIEFycmF5PFN0eWxlPj59IFN0eWxlc1xuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRWRpdGluZ1N0eWxlKCkge1xuICAvKiogQHR5cGUge09iamVjdDxpbXBvcnQoXCIuLi9nZW9tL0dlb21ldHJ5LmpzXCIpLlR5cGUsIEFycmF5PFN0eWxlPj59ICovXG4gIGNvbnN0IHN0eWxlcyA9IHt9O1xuICBjb25zdCB3aGl0ZSA9IFsyNTUsIDI1NSwgMjU1LCAxXTtcbiAgY29uc3QgYmx1ZSA9IFswLCAxNTMsIDI1NSwgMV07XG4gIGNvbnN0IHdpZHRoID0gMztcbiAgc3R5bGVzWydQb2x5Z29uJ10gPSBbXG4gICAgbmV3IFN0eWxlKHtcbiAgICAgIGZpbGw6IG5ldyBGaWxsKHtcbiAgICAgICAgY29sb3I6IFsyNTUsIDI1NSwgMjU1LCAwLjVdLFxuICAgICAgfSksXG4gICAgfSksXG4gIF07XG4gIHN0eWxlc1snTXVsdGlQb2x5Z29uJ10gPSBzdHlsZXNbJ1BvbHlnb24nXTtcblxuICBzdHlsZXNbJ0xpbmVTdHJpbmcnXSA9IFtcbiAgICBuZXcgU3R5bGUoe1xuICAgICAgc3Ryb2tlOiBuZXcgU3Ryb2tlKHtcbiAgICAgICAgY29sb3I6IHdoaXRlLFxuICAgICAgICB3aWR0aDogd2lkdGggKyAyLFxuICAgICAgfSksXG4gICAgfSksXG4gICAgbmV3IFN0eWxlKHtcbiAgICAgIHN0cm9rZTogbmV3IFN0cm9rZSh7XG4gICAgICAgIGNvbG9yOiBibHVlLFxuICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICB9KSxcbiAgICB9KSxcbiAgXTtcbiAgc3R5bGVzWydNdWx0aUxpbmVTdHJpbmcnXSA9IHN0eWxlc1snTGluZVN0cmluZyddO1xuXG4gIHN0eWxlc1snQ2lyY2xlJ10gPSBzdHlsZXNbJ1BvbHlnb24nXS5jb25jYXQoc3R5bGVzWydMaW5lU3RyaW5nJ10pO1xuXG4gIHN0eWxlc1snUG9pbnQnXSA9IFtcbiAgICBuZXcgU3R5bGUoe1xuICAgICAgaW1hZ2U6IG5ldyBDaXJjbGVTdHlsZSh7XG4gICAgICAgIHJhZGl1czogd2lkdGggKiAyLFxuICAgICAgICBmaWxsOiBuZXcgRmlsbCh7XG4gICAgICAgICAgY29sb3I6IGJsdWUsXG4gICAgICAgIH0pLFxuICAgICAgICBzdHJva2U6IG5ldyBTdHJva2Uoe1xuICAgICAgICAgIGNvbG9yOiB3aGl0ZSxcbiAgICAgICAgICB3aWR0aDogd2lkdGggLyAyLFxuICAgICAgICB9KSxcbiAgICAgIH0pLFxuICAgICAgekluZGV4OiBJbmZpbml0eSxcbiAgICB9KSxcbiAgXTtcbiAgc3R5bGVzWydNdWx0aVBvaW50J10gPSBzdHlsZXNbJ1BvaW50J107XG5cbiAgc3R5bGVzWydHZW9tZXRyeUNvbGxlY3Rpb24nXSA9IHN0eWxlc1snUG9seWdvbiddLmNvbmNhdChcbiAgICBzdHlsZXNbJ0xpbmVTdHJpbmcnXSxcbiAgICBzdHlsZXNbJ1BvaW50J11cbiAgKTtcblxuICByZXR1cm4gc3R5bGVzO1xufVxuXG4vKipcbiAqIEZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdpdGggYSBmZWF0dXJlIGFuZCByZXR1cm5zIGl0cyBkZWZhdWx0IGdlb21ldHJ5LlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLkZlYXR1cmVMaWtlfSBmZWF0dXJlIEZlYXR1cmUgdG8gZ2V0IHRoZSBnZW9tZXRyeSBmb3IuXG4gKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9nZW9tL0dlb21ldHJ5LmpzXCIpLmRlZmF1bHR8aW1wb3J0KFwiLi4vcmVuZGVyL0ZlYXR1cmUuanNcIikuZGVmYXVsdHx1bmRlZmluZWR9IEdlb21ldHJ5IHRvIHJlbmRlci5cbiAqL1xuZnVuY3Rpb24gZGVmYXVsdEdlb21ldHJ5RnVuY3Rpb24oZmVhdHVyZSkge1xuICByZXR1cm4gZmVhdHVyZS5nZXRHZW9tZXRyeSgpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBTdHlsZTtcbiIsIi8qKlxuICogQG1vZHVsZSBvbC9zdHlsZS9UZXh0XG4gKi9cbmltcG9ydCBGaWxsIGZyb20gJy4vRmlsbC5qcyc7XG5pbXBvcnQge3RvU2l6ZX0gZnJvbSAnLi4vc2l6ZS5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYgeydwb2ludCcgfCAnbGluZSd9IFRleHRQbGFjZW1lbnRcbiAqIERlZmF1bHQgdGV4dCBwbGFjZW1lbnQgaXMgYCdwb2ludCdgLiBOb3RlIHRoYXRcbiAqIGAnbGluZSdgIHJlcXVpcmVzIHRoZSB1bmRlcmx5aW5nIGdlb21ldHJ5IHRvIGJlIGEge0BsaW5rIG1vZHVsZTpvbC9nZW9tL0xpbmVTdHJpbmd+TGluZVN0cmluZ30sXG4gKiB7QGxpbmsgbW9kdWxlOm9sL2dlb20vUG9seWdvbn5Qb2x5Z29ufSwge0BsaW5rIG1vZHVsZTpvbC9nZW9tL011bHRpTGluZVN0cmluZ35NdWx0aUxpbmVTdHJpbmd9IG9yXG4gKiB7QGxpbmsgbW9kdWxlOm9sL2dlb20vTXVsdGlQb2x5Z29ufk11bHRpUG9seWdvbn0uXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7J2xlZnQnIHwgJ2NlbnRlcicgfCAncmlnaHQnfSBUZXh0SnVzdGlmeVxuICovXG5cbi8qKlxuICogVGhlIGRlZmF1bHQgZmlsbCBjb2xvciB0byB1c2UgaWYgbm8gZmlsbCB3YXMgc2V0IGF0IGNvbnN0cnVjdGlvbiB0aW1lOyBhXG4gKiBibGFja2lzaCBgIzMzM2AuXG4gKlxuICogQGNvbnN0IHtzdHJpbmd9XG4gKi9cbmNvbnN0IERFRkFVTFRfRklMTF9DT0xPUiA9ICcjMzMzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2ZvbnRdIEZvbnQgc3R5bGUgYXMgQ1NTIGBmb250YCB2YWx1ZSwgc2VlOlxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC9mb250LiBEZWZhdWx0IGlzIGAnMTBweCBzYW5zLXNlcmlmJ2BcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbWF4QW5nbGU9TWF0aC5QSS80XSBXaGVuIGBwbGFjZW1lbnRgIGlzIHNldCB0byBgJ2xpbmUnYCwgYWxsb3cgYSBtYXhpbXVtIGFuZ2xlIGJldHdlZW4gYWRqYWNlbnQgY2hhcmFjdGVycy5cbiAqIFRoZSBleHBlY3RlZCB2YWx1ZSBpcyBpbiByYWRpYW5zLCBhbmQgdGhlIGRlZmF1bHQgaXMgNDXCsCAoYE1hdGguUEkgLyA0YCkuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW29mZnNldFg9MF0gSG9yaXpvbnRhbCB0ZXh0IG9mZnNldCBpbiBwaXhlbHMuIEEgcG9zaXRpdmUgd2lsbCBzaGlmdCB0aGUgdGV4dCByaWdodC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbb2Zmc2V0WT0wXSBWZXJ0aWNhbCB0ZXh0IG9mZnNldCBpbiBwaXhlbHMuIEEgcG9zaXRpdmUgd2lsbCBzaGlmdCB0aGUgdGV4dCBkb3duLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbb3ZlcmZsb3c9ZmFsc2VdIEZvciBwb2x5Z29uIGxhYmVscyBvciB3aGVuIGBwbGFjZW1lbnRgIGlzIHNldCB0byBgJ2xpbmUnYCwgYWxsb3cgdGV4dCB0byBleGNlZWRcbiAqIHRoZSB3aWR0aCBvZiB0aGUgcG9seWdvbiBhdCB0aGUgbGFiZWwgcG9zaXRpb24gb3IgdGhlIGxlbmd0aCBvZiB0aGUgcGF0aCB0aGF0IGl0IGZvbGxvd3MuXG4gKiBAcHJvcGVydHkge1RleHRQbGFjZW1lbnR9IFtwbGFjZW1lbnQ9J3BvaW50J10gVGV4dCBwbGFjZW1lbnQuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3JlcGVhdF0gUmVwZWF0IGludGVydmFsLiBXaGVuIHNldCwgdGhlIHRleHQgd2lsbCBiZSByZXBlYXRlZCBhdCB0aGlzIGludGVydmFsLCB3aGljaCBzcGVjaWZpZXNcbiAqIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHR3byB0ZXh0IGFuY2hvcnMgaW4gcGl4ZWxzLiBPbmx5IGF2YWlsYWJsZSB3aGVuIGBwbGFjZW1lbnRgIGlzIHNldCB0byBgJ2xpbmUnYC4gT3ZlcnJpZGVzICd0ZXh0QWxpZ24nLlxuICogQHByb3BlcnR5IHtudW1iZXJ8aW1wb3J0KFwiLi4vc2l6ZS5qc1wiKS5TaXplfSBbc2NhbGVdIFNjYWxlLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbcm90YXRlV2l0aFZpZXc9ZmFsc2VdIFdoZXRoZXIgdG8gcm90YXRlIHRoZSB0ZXh0IHdpdGggdGhlIHZpZXcuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3JvdGF0aW9uPTBdIFJvdGF0aW9uIGluIHJhZGlhbnMgKHBvc2l0aXZlIHJvdGF0aW9uIGNsb2Nrd2lzZSkuXG4gKiBAcHJvcGVydHkge3N0cmluZ3xBcnJheTxzdHJpbmc+fSBbdGV4dF0gVGV4dCBjb250ZW50IG9yIHJpY2ggdGV4dCBjb250ZW50LiBGb3IgcGxhaW4gdGV4dCBwcm92aWRlIGEgc3RyaW5nLCB3aGljaCBjYW5cbiAqIGNvbnRhaW4gbGluZSBicmVha3MgKGBcXG5gKS4gRm9yIHJpY2ggdGV4dCBwcm92aWRlIGFuIGFycmF5IG9mIHRleHQvZm9udCB0dXBsZXMuIEEgdHVwbGUgY29uc2lzdHMgb2YgdGhlIHRleHQgdG9cbiAqIHJlbmRlciBhbmQgdGhlIGZvbnQgdG8gdXNlIChvciBgJydgIHRvIHVzZSB0aGUgdGV4dCBzdHlsZSdzIGZvbnQpLiBBIGxpbmUgYnJlYWsgaGFzIHRvIGJlIGEgc2VwYXJhdGUgdHVwbGUgKGkuZS4gYCdcXG4nLCAnJ2ApLlxuICogKipFeGFtcGxlOioqIGBbJ2ZvbycsICdib2xkIDEwcHggc2Fucy1zZXJpZicsICcgYmFyJywgJ2l0YWxpYyAxMHB4IHNhbnMtc2VyaWYnLCAnIGJheicsICcnXWAgd2lsbCB5aWVsZCBcIioqZm9vKiogKmJhciogYmF6XCIuXG4gKiAqKk5vdGU6KiogUmljaCB0ZXh0IGlzIG5vdCBzdXBwb3J0ZWQgZm9yIGBwbGFjZW1lbnQ6ICdsaW5lJ2Agb3IgdGhlIGltbWVkaWF0ZSByZW5kZXJpbmcgQVBJLlxuICogQHByb3BlcnR5IHtDYW52YXNUZXh0QWxpZ259IFt0ZXh0QWxpZ25dIFRleHQgYWxpZ25tZW50LiBQb3NzaWJsZSB2YWx1ZXM6IGAnbGVmdCdgLCBgJ3JpZ2h0J2AsIGAnY2VudGVyJ2AsIGAnZW5kJ2Agb3IgYCdzdGFydCdgLlxuICogRGVmYXVsdCBpcyBgJ2NlbnRlcidgIGZvciBgcGxhY2VtZW50OiAncG9pbnQnYC4gRm9yIGBwbGFjZW1lbnQ6ICdsaW5lJ2AsIHRoZSBkZWZhdWx0IGlzIHRvIGxldCB0aGUgcmVuZGVyZXIgY2hvb3NlIGFcbiAqIHBsYWNlbWVudCB3aGVyZSBgbWF4QW5nbGVgIGlzIG5vdCBleGNlZWRlZC5cbiAqIEBwcm9wZXJ0eSB7VGV4dEp1c3RpZnl9IFtqdXN0aWZ5XSBUZXh0IGp1c3RpZmljYXRpb24gd2l0aGluIHRoZSB0ZXh0IGJveC5cbiAqIElmIG5vdCBzZXQsIHRleHQgaXMganVzdGlmaWVkIHRvd2FyZHMgdGhlIGB0ZXh0QWxpZ25gIGFuY2hvci5cbiAqIE90aGVyd2lzZSwgdXNlIG9wdGlvbnMgYCdsZWZ0J2AsIGAnY2VudGVyJ2AsIG9yIGAncmlnaHQnYCB0byBqdXN0aWZ5IHRoZSB0ZXh0IHdpdGhpbiB0aGUgdGV4dCBib3guXG4gKiAqKk5vdGU6KiogYGp1c3RpZnlgIGlzIGlnbm9yZWQgZm9yIGltbWVkaWF0ZSByZW5kZXJpbmcgYW5kIGFsc28gZm9yIGBwbGFjZW1lbnQ6ICdsaW5lJ2AuXG4gKiBAcHJvcGVydHkge0NhbnZhc1RleHRCYXNlbGluZX0gW3RleHRCYXNlbGluZT0nbWlkZGxlJ10gVGV4dCBiYXNlIGxpbmUuIFBvc3NpYmxlIHZhbHVlczogYCdib3R0b20nYCwgYCd0b3AnYCwgYCdtaWRkbGUnYCwgYCdhbHBoYWJldGljJ2AsXG4gKiBgJ2hhbmdpbmcnYCwgYCdpZGVvZ3JhcGhpYydgLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL0ZpbGwuanNcIikuZGVmYXVsdHxudWxsfSBbZmlsbF0gRmlsbCBzdHlsZS4gSWYgbm9uZSBpcyBwcm92aWRlZCwgd2UnbGwgdXNlIGEgZGFyayBmaWxsLXN0eWxlICgjMzMzKS4gU3BlY2lmeSBgbnVsbGAgZm9yIG5vIGZpbGwuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4vU3Ryb2tlLmpzXCIpLmRlZmF1bHR9IFtzdHJva2VdIFN0cm9rZSBzdHlsZS5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi9GaWxsLmpzXCIpLmRlZmF1bHR9IFtiYWNrZ3JvdW5kRmlsbF0gRmlsbCBzdHlsZSBmb3IgdGhlIHRleHQgYmFja2dyb3VuZCB3aGVuIGBwbGFjZW1lbnRgIGlzXG4gKiBgJ3BvaW50J2AuIERlZmF1bHQgaXMgbm8gZmlsbC5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi9TdHJva2UuanNcIikuZGVmYXVsdH0gW2JhY2tncm91bmRTdHJva2VdIFN0cm9rZSBzdHlsZSBmb3IgdGhlIHRleHQgYmFja2dyb3VuZCAgd2hlbiBgcGxhY2VtZW50YFxuICogaXMgYCdwb2ludCdgLiBEZWZhdWx0IGlzIG5vIHN0cm9rZS5cbiAqIEBwcm9wZXJ0eSB7QXJyYXk8bnVtYmVyPn0gW3BhZGRpbmc9WzAsIDAsIDAsIDBdXSBQYWRkaW5nIGluIHBpeGVscyBhcm91bmQgdGhlIHRleHQgZm9yIGRlY2x1dHRlcmluZyBhbmQgYmFja2dyb3VuZC4gVGhlIG9yZGVyIG9mXG4gKiB2YWx1ZXMgaW4gdGhlIGFycmF5IGlzIGBbdG9wLCByaWdodCwgYm90dG9tLCBsZWZ0XWAuXG4gKi9cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBTZXQgdGV4dCBzdHlsZSBmb3IgdmVjdG9yIGZlYXR1cmVzLlxuICogQGFwaVxuICovXG5jbGFzcyBUZXh0IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7T3B0aW9uc30gW29wdGlvbnNdIE9wdGlvbnMuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtzdHJpbmd8dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMuZm9udF8gPSBvcHRpb25zLmZvbnQ7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ8dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMucm90YXRpb25fID0gb3B0aW9ucy5yb3RhdGlvbjtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2Jvb2xlYW58dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMucm90YXRlV2l0aFZpZXdfID0gb3B0aW9ucy5yb3RhdGVXaXRoVmlldztcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcnxpbXBvcnQoXCIuLi9zaXplLmpzXCIpLlNpemV8dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMuc2NhbGVfID0gb3B0aW9ucy5zY2FsZTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL3NpemUuanNcIikuU2l6ZX1cbiAgICAgKi9cbiAgICB0aGlzLnNjYWxlQXJyYXlfID0gdG9TaXplKG9wdGlvbnMuc2NhbGUgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuc2NhbGUgOiAxKTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge3N0cmluZ3xBcnJheTxzdHJpbmc+fHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLnRleHRfID0gb3B0aW9ucy50ZXh0O1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7Q2FudmFzVGV4dEFsaWdufHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLnRleHRBbGlnbl8gPSBvcHRpb25zLnRleHRBbGlnbjtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge1RleHRKdXN0aWZ5fHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLmp1c3RpZnlfID0gb3B0aW9ucy5qdXN0aWZ5O1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLnJlcGVhdF8gPSBvcHRpb25zLnJlcGVhdDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0NhbnZhc1RleHRCYXNlbGluZXx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy50ZXh0QmFzZWxpbmVfID0gb3B0aW9ucy50ZXh0QmFzZWxpbmU7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuL0ZpbGwuanNcIikuZGVmYXVsdH1cbiAgICAgKi9cbiAgICB0aGlzLmZpbGxfID1cbiAgICAgIG9wdGlvbnMuZmlsbCAhPT0gdW5kZWZpbmVkXG4gICAgICAgID8gb3B0aW9ucy5maWxsXG4gICAgICAgIDogbmV3IEZpbGwoe2NvbG9yOiBERUZBVUxUX0ZJTExfQ09MT1J9KTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLm1heEFuZ2xlXyA9XG4gICAgICBvcHRpb25zLm1heEFuZ2xlICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm1heEFuZ2xlIDogTWF0aC5QSSAvIDQ7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtUZXh0UGxhY2VtZW50fVxuICAgICAqL1xuICAgIHRoaXMucGxhY2VtZW50XyA9XG4gICAgICBvcHRpb25zLnBsYWNlbWVudCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5wbGFjZW1lbnQgOiAncG9pbnQnO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLm92ZXJmbG93XyA9ICEhb3B0aW9ucy5vdmVyZmxvdztcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4vU3Ryb2tlLmpzXCIpLmRlZmF1bHR9XG4gICAgICovXG4gICAgdGhpcy5zdHJva2VfID0gb3B0aW9ucy5zdHJva2UgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuc3Ryb2tlIDogbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLm9mZnNldFhfID0gb3B0aW9ucy5vZmZzZXRYICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm9mZnNldFggOiAwO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMub2Zmc2V0WV8gPSBvcHRpb25zLm9mZnNldFkgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMub2Zmc2V0WSA6IDA7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuL0ZpbGwuanNcIikuZGVmYXVsdH1cbiAgICAgKi9cbiAgICB0aGlzLmJhY2tncm91bmRGaWxsXyA9IG9wdGlvbnMuYmFja2dyb3VuZEZpbGxcbiAgICAgID8gb3B0aW9ucy5iYWNrZ3JvdW5kRmlsbFxuICAgICAgOiBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi9TdHJva2UuanNcIikuZGVmYXVsdH1cbiAgICAgKi9cbiAgICB0aGlzLmJhY2tncm91bmRTdHJva2VfID0gb3B0aW9ucy5iYWNrZ3JvdW5kU3Ryb2tlXG4gICAgICA/IG9wdGlvbnMuYmFja2dyb3VuZFN0cm9rZVxuICAgICAgOiBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7QXJyYXk8bnVtYmVyPnxudWxsfVxuICAgICAqL1xuICAgIHRoaXMucGFkZGluZ18gPSBvcHRpb25zLnBhZGRpbmcgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBvcHRpb25zLnBhZGRpbmc7XG4gIH1cblxuICAvKipcbiAgICogQ2xvbmVzIHRoZSBzdHlsZS5cbiAgICogQHJldHVybiB7VGV4dH0gVGhlIGNsb25lZCBzdHlsZS5cbiAgICogQGFwaVxuICAgKi9cbiAgY2xvbmUoKSB7XG4gICAgY29uc3Qgc2NhbGUgPSB0aGlzLmdldFNjYWxlKCk7XG4gICAgcmV0dXJuIG5ldyBUZXh0KHtcbiAgICAgIGZvbnQ6IHRoaXMuZ2V0Rm9udCgpLFxuICAgICAgcGxhY2VtZW50OiB0aGlzLmdldFBsYWNlbWVudCgpLFxuICAgICAgcmVwZWF0OiB0aGlzLmdldFJlcGVhdCgpLFxuICAgICAgbWF4QW5nbGU6IHRoaXMuZ2V0TWF4QW5nbGUoKSxcbiAgICAgIG92ZXJmbG93OiB0aGlzLmdldE92ZXJmbG93KCksXG4gICAgICByb3RhdGlvbjogdGhpcy5nZXRSb3RhdGlvbigpLFxuICAgICAgcm90YXRlV2l0aFZpZXc6IHRoaXMuZ2V0Um90YXRlV2l0aFZpZXcoKSxcbiAgICAgIHNjYWxlOiBBcnJheS5pc0FycmF5KHNjYWxlKSA/IHNjYWxlLnNsaWNlKCkgOiBzY2FsZSxcbiAgICAgIHRleHQ6IHRoaXMuZ2V0VGV4dCgpLFxuICAgICAgdGV4dEFsaWduOiB0aGlzLmdldFRleHRBbGlnbigpLFxuICAgICAganVzdGlmeTogdGhpcy5nZXRKdXN0aWZ5KCksXG4gICAgICB0ZXh0QmFzZWxpbmU6IHRoaXMuZ2V0VGV4dEJhc2VsaW5lKCksXG4gICAgICBmaWxsOiB0aGlzLmdldEZpbGwoKSA/IHRoaXMuZ2V0RmlsbCgpLmNsb25lKCkgOiB1bmRlZmluZWQsXG4gICAgICBzdHJva2U6IHRoaXMuZ2V0U3Ryb2tlKCkgPyB0aGlzLmdldFN0cm9rZSgpLmNsb25lKCkgOiB1bmRlZmluZWQsXG4gICAgICBvZmZzZXRYOiB0aGlzLmdldE9mZnNldFgoKSxcbiAgICAgIG9mZnNldFk6IHRoaXMuZ2V0T2Zmc2V0WSgpLFxuICAgICAgYmFja2dyb3VuZEZpbGw6IHRoaXMuZ2V0QmFja2dyb3VuZEZpbGwoKVxuICAgICAgICA/IHRoaXMuZ2V0QmFja2dyb3VuZEZpbGwoKS5jbG9uZSgpXG4gICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgYmFja2dyb3VuZFN0cm9rZTogdGhpcy5nZXRCYWNrZ3JvdW5kU3Ryb2tlKClcbiAgICAgICAgPyB0aGlzLmdldEJhY2tncm91bmRTdHJva2UoKS5jbG9uZSgpXG4gICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgcGFkZGluZzogdGhpcy5nZXRQYWRkaW5nKCkgfHwgdW5kZWZpbmVkLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgYG92ZXJmbG93YCBjb25maWd1cmF0aW9uLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBMZXQgdGV4dCBvdmVyZmxvdyB0aGUgbGVuZ3RoIG9mIHRoZSBwYXRoIHRoZXkgZm9sbG93LlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRPdmVyZmxvdygpIHtcbiAgICByZXR1cm4gdGhpcy5vdmVyZmxvd187XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBmb250IG5hbWUuXG4gICAqIEByZXR1cm4ge3N0cmluZ3x1bmRlZmluZWR9IEZvbnQuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldEZvbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZm9udF87XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBtYXhpbXVtIGFuZ2xlIGJldHdlZW4gYWRqYWNlbnQgY2hhcmFjdGVycy5cbiAgICogQHJldHVybiB7bnVtYmVyfSBBbmdsZSBpbiByYWRpYW5zLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRNYXhBbmdsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5tYXhBbmdsZV87XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBsYWJlbCBwbGFjZW1lbnQuXG4gICAqIEByZXR1cm4ge1RleHRQbGFjZW1lbnR9IFRleHQgcGxhY2VtZW50LlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRQbGFjZW1lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMucGxhY2VtZW50XztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHJlcGVhdCBpbnRlcnZhbCBvZiB0aGUgdGV4dC5cbiAgICogQHJldHVybiB7bnVtYmVyfHVuZGVmaW5lZH0gUmVwZWF0IGludGVydmFsIGluIHBpeGVscy5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0UmVwZWF0KCkge1xuICAgIHJldHVybiB0aGlzLnJlcGVhdF87XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB4LW9mZnNldCBmb3IgdGhlIHRleHQuXG4gICAqIEByZXR1cm4ge251bWJlcn0gSG9yaXpvbnRhbCB0ZXh0IG9mZnNldC5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0T2Zmc2V0WCgpIHtcbiAgICByZXR1cm4gdGhpcy5vZmZzZXRYXztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHktb2Zmc2V0IGZvciB0aGUgdGV4dC5cbiAgICogQHJldHVybiB7bnVtYmVyfSBWZXJ0aWNhbCB0ZXh0IG9mZnNldC5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0T2Zmc2V0WSgpIHtcbiAgICByZXR1cm4gdGhpcy5vZmZzZXRZXztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGZpbGwgc3R5bGUgZm9yIHRoZSB0ZXh0LlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuL0ZpbGwuanNcIikuZGVmYXVsdH0gRmlsbCBzdHlsZS5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0RmlsbCgpIHtcbiAgICByZXR1cm4gdGhpcy5maWxsXztcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmUgd2hldGhlciB0aGUgdGV4dCByb3RhdGVzIHdpdGggdGhlIG1hcC5cbiAgICogQHJldHVybiB7Ym9vbGVhbnx1bmRlZmluZWR9IFJvdGF0ZSB3aXRoIG1hcC5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0Um90YXRlV2l0aFZpZXcoKSB7XG4gICAgcmV0dXJuIHRoaXMucm90YXRlV2l0aFZpZXdfO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdGV4dCByb3RhdGlvbi5cbiAgICogQHJldHVybiB7bnVtYmVyfHVuZGVmaW5lZH0gUm90YXRpb24uXG4gICAqIEBhcGlcbiAgICovXG4gIGdldFJvdGF0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnJvdGF0aW9uXztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHRleHQgc2NhbGUuXG4gICAqIEByZXR1cm4ge251bWJlcnxpbXBvcnQoXCIuLi9zaXplLmpzXCIpLlNpemV8dW5kZWZpbmVkfSBTY2FsZS5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0U2NhbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2NhbGVfO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgc3ltYm9saXplciBzY2FsZSBhcnJheS5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vc2l6ZS5qc1wiKS5TaXplfSBTY2FsZSBhcnJheS5cbiAgICovXG4gIGdldFNjYWxlQXJyYXkoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2NhbGVBcnJheV87XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBzdHJva2Ugc3R5bGUgZm9yIHRoZSB0ZXh0LlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuL1N0cm9rZS5qc1wiKS5kZWZhdWx0fSBTdHJva2Ugc3R5bGUuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldFN0cm9rZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zdHJva2VfO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdGV4dCB0byBiZSByZW5kZXJlZC5cbiAgICogQHJldHVybiB7c3RyaW5nfEFycmF5PHN0cmluZz58dW5kZWZpbmVkfSBUZXh0LlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRUZXh0KCkge1xuICAgIHJldHVybiB0aGlzLnRleHRfO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdGV4dCBhbGlnbm1lbnQuXG4gICAqIEByZXR1cm4ge0NhbnZhc1RleHRBbGlnbnx1bmRlZmluZWR9IFRleHQgYWxpZ24uXG4gICAqIEBhcGlcbiAgICovXG4gIGdldFRleHRBbGlnbigpIHtcbiAgICByZXR1cm4gdGhpcy50ZXh0QWxpZ25fO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUganVzdGlmaWNhdGlvbi5cbiAgICogQHJldHVybiB7VGV4dEp1c3RpZnl8dW5kZWZpbmVkfSBKdXN0aWZpY2F0aW9uLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRKdXN0aWZ5KCkge1xuICAgIHJldHVybiB0aGlzLmp1c3RpZnlfO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdGV4dCBiYXNlbGluZS5cbiAgICogQHJldHVybiB7Q2FudmFzVGV4dEJhc2VsaW5lfHVuZGVmaW5lZH0gVGV4dCBiYXNlbGluZS5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0VGV4dEJhc2VsaW5lKCkge1xuICAgIHJldHVybiB0aGlzLnRleHRCYXNlbGluZV87XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBiYWNrZ3JvdW5kIGZpbGwgc3R5bGUgZm9yIHRoZSB0ZXh0LlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuL0ZpbGwuanNcIikuZGVmYXVsdH0gRmlsbCBzdHlsZS5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0QmFja2dyb3VuZEZpbGwoKSB7XG4gICAgcmV0dXJuIHRoaXMuYmFja2dyb3VuZEZpbGxfO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgYmFja2dyb3VuZCBzdHJva2Ugc3R5bGUgZm9yIHRoZSB0ZXh0LlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuL1N0cm9rZS5qc1wiKS5kZWZhdWx0fSBTdHJva2Ugc3R5bGUuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldEJhY2tncm91bmRTdHJva2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuYmFja2dyb3VuZFN0cm9rZV87XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBwYWRkaW5nIGZvciB0aGUgdGV4dC5cbiAgICogQHJldHVybiB7QXJyYXk8bnVtYmVyPnxudWxsfSBQYWRkaW5nLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRQYWRkaW5nKCkge1xuICAgIHJldHVybiB0aGlzLnBhZGRpbmdfO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgYG92ZXJmbG93YCBwcm9wZXJ0eS5cbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSBvdmVyZmxvdyBMZXQgdGV4dCBvdmVyZmxvdyB0aGUgcGF0aCB0aGF0IGl0IGZvbGxvd3MuXG4gICAqIEBhcGlcbiAgICovXG4gIHNldE92ZXJmbG93KG92ZXJmbG93KSB7XG4gICAgdGhpcy5vdmVyZmxvd18gPSBvdmVyZmxvdztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGZvbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfHVuZGVmaW5lZH0gZm9udCBGb250LlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRGb250KGZvbnQpIHtcbiAgICB0aGlzLmZvbnRfID0gZm9udDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIG1heGltdW0gYW5nbGUgYmV0d2VlbiBhZGphY2VudCBjaGFyYWN0ZXJzLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gbWF4QW5nbGUgQW5nbGUgaW4gcmFkaWFucy5cbiAgICogQGFwaVxuICAgKi9cbiAgc2V0TWF4QW5nbGUobWF4QW5nbGUpIHtcbiAgICB0aGlzLm1heEFuZ2xlXyA9IG1heEFuZ2xlO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgeCBvZmZzZXQuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRYIEhvcml6b250YWwgdGV4dCBvZmZzZXQuXG4gICAqIEBhcGlcbiAgICovXG4gIHNldE9mZnNldFgob2Zmc2V0WCkge1xuICAgIHRoaXMub2Zmc2V0WF8gPSBvZmZzZXRYO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgeSBvZmZzZXQuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRZIFZlcnRpY2FsIHRleHQgb2Zmc2V0LlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRPZmZzZXRZKG9mZnNldFkpIHtcbiAgICB0aGlzLm9mZnNldFlfID0gb2Zmc2V0WTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHRleHQgcGxhY2VtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1RleHRQbGFjZW1lbnR9IHBsYWNlbWVudCBQbGFjZW1lbnQuXG4gICAqIEBhcGlcbiAgICovXG4gIHNldFBsYWNlbWVudChwbGFjZW1lbnQpIHtcbiAgICB0aGlzLnBsYWNlbWVudF8gPSBwbGFjZW1lbnQ7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSByZXBlYXQgaW50ZXJ2YWwgb2YgdGhlIHRleHQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfHVuZGVmaW5lZH0gW3JlcGVhdF0gUmVwZWF0IGludGVydmFsIGluIHBpeGVscy5cbiAgICogQGFwaVxuICAgKi9cbiAgc2V0UmVwZWF0KHJlcGVhdCkge1xuICAgIHRoaXMucmVwZWF0XyA9IHJlcGVhdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgd2hldGhlciB0byByb3RhdGUgdGhlIHRleHQgd2l0aCB0aGUgdmlldy5cbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSByb3RhdGVXaXRoVmlldyBSb3RhdGUgd2l0aCBtYXAuXG4gICAqIEBhcGlcbiAgICovXG4gIHNldFJvdGF0ZVdpdGhWaWV3KHJvdGF0ZVdpdGhWaWV3KSB7XG4gICAgdGhpcy5yb3RhdGVXaXRoVmlld18gPSByb3RhdGVXaXRoVmlldztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGZpbGwuXG4gICAqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9GaWxsLmpzXCIpLmRlZmF1bHR9IGZpbGwgRmlsbCBzdHlsZS5cbiAgICogQGFwaVxuICAgKi9cbiAgc2V0RmlsbChmaWxsKSB7XG4gICAgdGhpcy5maWxsXyA9IGZpbGw7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSByb3RhdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ8dW5kZWZpbmVkfSByb3RhdGlvbiBSb3RhdGlvbi5cbiAgICogQGFwaVxuICAgKi9cbiAgc2V0Um90YXRpb24ocm90YXRpb24pIHtcbiAgICB0aGlzLnJvdGF0aW9uXyA9IHJvdGF0aW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgc2NhbGUuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfGltcG9ydChcIi4uL3NpemUuanNcIikuU2l6ZXx1bmRlZmluZWR9IHNjYWxlIFNjYWxlLlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRTY2FsZShzY2FsZSkge1xuICAgIHRoaXMuc2NhbGVfID0gc2NhbGU7XG4gICAgdGhpcy5zY2FsZUFycmF5XyA9IHRvU2l6ZShzY2FsZSAhPT0gdW5kZWZpbmVkID8gc2NhbGUgOiAxKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHN0cm9rZS5cbiAgICpcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL1N0cm9rZS5qc1wiKS5kZWZhdWx0fSBzdHJva2UgU3Ryb2tlIHN0eWxlLlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRTdHJva2Uoc3Ryb2tlKSB7XG4gICAgdGhpcy5zdHJva2VfID0gc3Ryb2tlO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgdGV4dC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd8QXJyYXk8c3RyaW5nPnx1bmRlZmluZWR9IHRleHQgVGV4dC5cbiAgICogQGFwaVxuICAgKi9cbiAgc2V0VGV4dCh0ZXh0KSB7XG4gICAgdGhpcy50ZXh0XyA9IHRleHQ7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSB0ZXh0IGFsaWdubWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtDYW52YXNUZXh0QWxpZ258dW5kZWZpbmVkfSB0ZXh0QWxpZ24gVGV4dCBhbGlnbi5cbiAgICogQGFwaVxuICAgKi9cbiAgc2V0VGV4dEFsaWduKHRleHRBbGlnbikge1xuICAgIHRoaXMudGV4dEFsaWduXyA9IHRleHRBbGlnbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGp1c3RpZmljYXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7VGV4dEp1c3RpZnl8dW5kZWZpbmVkfSBqdXN0aWZ5IEp1c3RpZmljYXRpb24uXG4gICAqIEBhcGlcbiAgICovXG4gIHNldEp1c3RpZnkoanVzdGlmeSkge1xuICAgIHRoaXMuanVzdGlmeV8gPSBqdXN0aWZ5O1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgdGV4dCBiYXNlbGluZS5cbiAgICpcbiAgICogQHBhcmFtIHtDYW52YXNUZXh0QmFzZWxpbmV8dW5kZWZpbmVkfSB0ZXh0QmFzZWxpbmUgVGV4dCBiYXNlbGluZS5cbiAgICogQGFwaVxuICAgKi9cbiAgc2V0VGV4dEJhc2VsaW5lKHRleHRCYXNlbGluZSkge1xuICAgIHRoaXMudGV4dEJhc2VsaW5lXyA9IHRleHRCYXNlbGluZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGJhY2tncm91bmQgZmlsbC5cbiAgICpcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL0ZpbGwuanNcIikuZGVmYXVsdH0gZmlsbCBGaWxsIHN0eWxlLlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRCYWNrZ3JvdW5kRmlsbChmaWxsKSB7XG4gICAgdGhpcy5iYWNrZ3JvdW5kRmlsbF8gPSBmaWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgYmFja2dyb3VuZCBzdHJva2UuXG4gICAqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9TdHJva2UuanNcIikuZGVmYXVsdH0gc3Ryb2tlIFN0cm9rZSBzdHlsZS5cbiAgICogQGFwaVxuICAgKi9cbiAgc2V0QmFja2dyb3VuZFN0cm9rZShzdHJva2UpIHtcbiAgICB0aGlzLmJhY2tncm91bmRTdHJva2VfID0gc3Ryb2tlO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgcGFkZGluZyAoYFt0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnRdYCkuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPnxudWxsfSBwYWRkaW5nIFBhZGRpbmcuXG4gICAqIEBhcGlcbiAgICovXG4gIHNldFBhZGRpbmcocGFkZGluZykge1xuICAgIHRoaXMucGFkZGluZ18gPSBwYWRkaW5nO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFRleHQ7XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvdGlsZWNvb3JkXG4gKi9cblxuLyoqXG4gKiBBbiBhcnJheSBvZiB0aHJlZSBudW1iZXJzIHJlcHJlc2VudGluZyB0aGUgbG9jYXRpb24gb2YgYSB0aWxlIGluIGEgdGlsZVxuICogZ3JpZC4gVGhlIG9yZGVyIGlzIGB6YCAoem9vbSBsZXZlbCksIGB4YCAoY29sdW1uKSwgYW5kIGB5YCAocm93KS5cbiAqIEB0eXBlZGVmIHtBcnJheTxudW1iZXI+fSBUaWxlQ29vcmRcbiAqIEBhcGlcbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSB6IFouXG4gKiBAcGFyYW0ge251bWJlcn0geCBYLlxuICogQHBhcmFtIHtudW1iZXJ9IHkgWS5cbiAqIEBwYXJhbSB7VGlsZUNvb3JkfSBbdGlsZUNvb3JkXSBUaWxlIGNvb3JkaW5hdGUuXG4gKiBAcmV0dXJuIHtUaWxlQ29vcmR9IFRpbGUgY29vcmRpbmF0ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZU9yVXBkYXRlKHosIHgsIHksIHRpbGVDb29yZCkge1xuICBpZiAodGlsZUNvb3JkICE9PSB1bmRlZmluZWQpIHtcbiAgICB0aWxlQ29vcmRbMF0gPSB6O1xuICAgIHRpbGVDb29yZFsxXSA9IHg7XG4gICAgdGlsZUNvb3JkWzJdID0geTtcbiAgICByZXR1cm4gdGlsZUNvb3JkO1xuICB9XG4gIHJldHVybiBbeiwgeCwgeV07XG59XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IHogWi5cbiAqIEBwYXJhbSB7bnVtYmVyfSB4IFguXG4gKiBAcGFyYW0ge251bWJlcn0geSBZLlxuICogQHJldHVybiB7c3RyaW5nfSBLZXkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRLZXlaWFkoeiwgeCwgeSkge1xuICByZXR1cm4geiArICcvJyArIHggKyAnLycgKyB5O1xufVxuXG4vKipcbiAqIEdldCB0aGUga2V5IGZvciBhIHRpbGUgY29vcmQuXG4gKiBAcGFyYW0ge1RpbGVDb29yZH0gdGlsZUNvb3JkIFRoZSB0aWxlIGNvb3JkLlxuICogQHJldHVybiB7c3RyaW5nfSBLZXkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRLZXkodGlsZUNvb3JkKSB7XG4gIHJldHVybiBnZXRLZXlaWFkodGlsZUNvb3JkWzBdLCB0aWxlQ29vcmRbMV0sIHRpbGVDb29yZFsyXSk7XG59XG5cbi8qKlxuICogR2V0IHRoZSB0aWxlIGNhY2hlIGtleSBmb3IgYSB0aWxlIGtleSBvYnRhaW5lZCB0aHJvdWdoIGB0aWxlLmdldEtleSgpYC5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0aWxlS2V5IFRoZSB0aWxlIGtleS5cbiAqIEByZXR1cm4ge3N0cmluZ30gVGhlIGNhY2hlIGtleS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldENhY2hlS2V5Rm9yVGlsZUtleSh0aWxlS2V5KSB7XG4gIGNvbnN0IFt6LCB4LCB5XSA9IHRpbGVLZXlcbiAgICAuc3Vic3RyaW5nKHRpbGVLZXkubGFzdEluZGV4T2YoJy8nKSArIDEsIHRpbGVLZXkubGVuZ3RoKVxuICAgIC5zcGxpdCgnLCcpXG4gICAgLm1hcChOdW1iZXIpO1xuICByZXR1cm4gZ2V0S2V5WlhZKHosIHgsIHkpO1xufVxuXG4vKipcbiAqIEdldCBhIHRpbGUgY29vcmQgZ2l2ZW4gYSBrZXkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSB0aWxlIGNvb3JkIGtleS5cbiAqIEByZXR1cm4ge1RpbGVDb29yZH0gVGhlIHRpbGUgY29vcmQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tS2V5KGtleSkge1xuICByZXR1cm4ga2V5LnNwbGl0KCcvJykubWFwKE51bWJlcik7XG59XG5cbi8qKlxuICogQHBhcmFtIHtUaWxlQ29vcmR9IHRpbGVDb29yZCBUaWxlIGNvb3JkLlxuICogQHJldHVybiB7bnVtYmVyfSBIYXNoLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaGFzaCh0aWxlQ29vcmQpIHtcbiAgcmV0dXJuICh0aWxlQ29vcmRbMV0gPDwgdGlsZUNvb3JkWzBdKSArIHRpbGVDb29yZFsyXTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1RpbGVDb29yZH0gdGlsZUNvb3JkIFRpbGUgY29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7IWltcG9ydChcIi4vdGlsZWdyaWQvVGlsZUdyaWQuanNcIikuZGVmYXVsdH0gdGlsZUdyaWQgVGlsZSBncmlkLlxuICogQHJldHVybiB7Ym9vbGVhbn0gVGlsZSBjb29yZGluYXRlIGlzIHdpdGhpbiBleHRlbnQgYW5kIHpvb20gbGV2ZWwgcmFuZ2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB3aXRoaW5FeHRlbnRBbmRaKHRpbGVDb29yZCwgdGlsZUdyaWQpIHtcbiAgY29uc3QgeiA9IHRpbGVDb29yZFswXTtcbiAgY29uc3QgeCA9IHRpbGVDb29yZFsxXTtcbiAgY29uc3QgeSA9IHRpbGVDb29yZFsyXTtcblxuICBpZiAodGlsZUdyaWQuZ2V0TWluWm9vbSgpID4geiB8fCB6ID4gdGlsZUdyaWQuZ2V0TWF4Wm9vbSgpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IHRpbGVSYW5nZSA9IHRpbGVHcmlkLmdldEZ1bGxUaWxlUmFuZ2Uoeik7XG4gIGlmICghdGlsZVJhbmdlKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIHRpbGVSYW5nZS5jb250YWluc1hZKHgsIHkpO1xufVxuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3RpbGVncmlkXG4gKi9cbmltcG9ydCBUaWxlR3JpZCBmcm9tICcuL3RpbGVncmlkL1RpbGVHcmlkLmpzJztcbmltcG9ydCB7REVGQVVMVF9NQVhfWk9PTSwgREVGQVVMVF9USUxFX1NJWkV9IGZyb20gJy4vdGlsZWdyaWQvY29tbW9uLmpzJztcbmltcG9ydCB7TUVURVJTX1BFUl9VTklULCBnZXQgYXMgZ2V0UHJvamVjdGlvbn0gZnJvbSAnLi9wcm9qLmpzJztcbmltcG9ydCB7XG4gIGNvbnRhaW5zQ29vcmRpbmF0ZSxcbiAgY3JlYXRlT3JVcGRhdGUsXG4gIGdldENvcm5lcixcbiAgZ2V0SGVpZ2h0LFxuICBnZXRXaWR0aCxcbn0gZnJvbSAnLi9leHRlbnQuanMnO1xuaW1wb3J0IHt0b1NpemV9IGZyb20gJy4vc2l6ZS5qcyc7XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL3Byb2ovUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0fSBwcm9qZWN0aW9uIFByb2plY3Rpb24uXG4gKiBAcmV0dXJuIHshVGlsZUdyaWR9IERlZmF1bHQgdGlsZSBncmlkIGZvciB0aGVcbiAqIHBhc3NlZCBwcm9qZWN0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Rm9yUHJvamVjdGlvbihwcm9qZWN0aW9uKSB7XG4gIGxldCB0aWxlR3JpZCA9IHByb2plY3Rpb24uZ2V0RGVmYXVsdFRpbGVHcmlkKCk7XG4gIGlmICghdGlsZUdyaWQpIHtcbiAgICB0aWxlR3JpZCA9IGNyZWF0ZUZvclByb2plY3Rpb24ocHJvamVjdGlvbik7XG4gICAgcHJvamVjdGlvbi5zZXREZWZhdWx0VGlsZUdyaWQodGlsZUdyaWQpO1xuICB9XG4gIHJldHVybiB0aWxlR3JpZDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1RpbGVHcmlkfSB0aWxlR3JpZCBUaWxlIGdyaWQuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vdGlsZWNvb3JkLmpzXCIpLlRpbGVDb29yZH0gdGlsZUNvb3JkIFRpbGUgY29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9wcm9qL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdH0gcHJvamVjdGlvbiBQcm9qZWN0aW9uLlxuICogQHJldHVybiB7aW1wb3J0KFwiLi90aWxlY29vcmQuanNcIikuVGlsZUNvb3JkfSBUaWxlIGNvb3JkaW5hdGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB3cmFwWCh0aWxlR3JpZCwgdGlsZUNvb3JkLCBwcm9qZWN0aW9uKSB7XG4gIGNvbnN0IHogPSB0aWxlQ29vcmRbMF07XG4gIGNvbnN0IGNlbnRlciA9IHRpbGVHcmlkLmdldFRpbGVDb29yZENlbnRlcih0aWxlQ29vcmQpO1xuICBjb25zdCBwcm9qZWN0aW9uRXh0ZW50ID0gZXh0ZW50RnJvbVByb2plY3Rpb24ocHJvamVjdGlvbik7XG4gIGlmICghY29udGFpbnNDb29yZGluYXRlKHByb2plY3Rpb25FeHRlbnQsIGNlbnRlcikpIHtcbiAgICBjb25zdCB3b3JsZFdpZHRoID0gZ2V0V2lkdGgocHJvamVjdGlvbkV4dGVudCk7XG4gICAgY29uc3Qgd29ybGRzQXdheSA9IE1hdGguY2VpbChcbiAgICAgIChwcm9qZWN0aW9uRXh0ZW50WzBdIC0gY2VudGVyWzBdKSAvIHdvcmxkV2lkdGhcbiAgICApO1xuICAgIGNlbnRlclswXSArPSB3b3JsZFdpZHRoICogd29ybGRzQXdheTtcbiAgICByZXR1cm4gdGlsZUdyaWQuZ2V0VGlsZUNvb3JkRm9yQ29vcmRBbmRaKGNlbnRlciwgeik7XG4gIH1cbiAgcmV0dXJuIHRpbGVDb29yZDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbbWF4Wm9vbV0gTWF4aW11bSB6b29tIGxldmVsIChkZWZhdWx0IGlzXG4gKiAgICAgREVGQVVMVF9NQVhfWk9PTSkuXG4gKiBAcGFyYW0ge251bWJlcnxpbXBvcnQoXCIuL3NpemUuanNcIikuU2l6ZX0gW3RpbGVTaXplXSBUaWxlIHNpemUgKGRlZmF1bHQgdXNlc1xuICogICAgIERFRkFVTFRfVElMRV9TSVpFKS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9leHRlbnQuanNcIikuQ29ybmVyfSBbY29ybmVyXSBFeHRlbnQgY29ybmVyIChkZWZhdWx0IGlzIGAndG9wLWxlZnQnYCkuXG4gKiBAcmV0dXJuIHshVGlsZUdyaWR9IFRpbGVHcmlkIGluc3RhbmNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRm9yRXh0ZW50KGV4dGVudCwgbWF4Wm9vbSwgdGlsZVNpemUsIGNvcm5lcikge1xuICBjb3JuZXIgPSBjb3JuZXIgIT09IHVuZGVmaW5lZCA/IGNvcm5lciA6ICd0b3AtbGVmdCc7XG5cbiAgY29uc3QgcmVzb2x1dGlvbnMgPSByZXNvbHV0aW9uc0Zyb21FeHRlbnQoZXh0ZW50LCBtYXhab29tLCB0aWxlU2l6ZSk7XG5cbiAgcmV0dXJuIG5ldyBUaWxlR3JpZCh7XG4gICAgZXh0ZW50OiBleHRlbnQsXG4gICAgb3JpZ2luOiBnZXRDb3JuZXIoZXh0ZW50LCBjb3JuZXIpLFxuICAgIHJlc29sdXRpb25zOiByZXNvbHV0aW9ucyxcbiAgICB0aWxlU2l6ZTogdGlsZVNpemUsXG4gIH0pO1xufVxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFhZWk9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi9leHRlbnQuanNcIikuRXh0ZW50fSBbZXh0ZW50XSBFeHRlbnQgZm9yIHRoZSB0aWxlIGdyaWQuIFRoZSBvcmlnaW4gZm9yIGFuIFhZWiB0aWxlIGdyaWQgaXMgdGhlXG4gKiB0b3AtbGVmdCBjb3JuZXIgb2YgdGhlIGV4dGVudC4gSWYgYG1heFJlc29sdXRpb25gIGlzIG5vdCBwcm92aWRlZCB0aGUgemVybyBsZXZlbCBvZiB0aGUgZ3JpZCBpcyBkZWZpbmVkIGJ5IHRoZSByZXNvbHV0aW9uXG4gKiBhdCB3aGljaCBvbmUgdGlsZSBmaXRzIGluIHRoZSBwcm92aWRlZCBleHRlbnQuIElmIG5vdCBwcm92aWRlZCwgdGhlIGV4dGVudCBvZiB0aGUgRVBTRzozODU3IHByb2plY3Rpb24gaXMgdXNlZC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbWF4UmVzb2x1dGlvbl0gUmVzb2x1dGlvbiBhdCBsZXZlbCB6ZXJvLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFttYXhab29tXSBNYXhpbXVtIHpvb20uIFRoZSBkZWZhdWx0IGlzIGA0MmAuIFRoaXMgZGV0ZXJtaW5lcyB0aGUgbnVtYmVyIG9mIGxldmVsc1xuICogaW4gdGhlIGdyaWQgc2V0LiBGb3IgZXhhbXBsZSwgYSBgbWF4Wm9vbWAgb2YgMjEgbWVhbnMgdGhlcmUgYXJlIDIyIGxldmVscyBpbiB0aGUgZ3JpZCBzZXQuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW21pblpvb209MF0gTWluaW11bSB6b29tLlxuICogQHByb3BlcnR5IHtudW1iZXJ8aW1wb3J0KFwiLi9zaXplLmpzXCIpLlNpemV9IFt0aWxlU2l6ZT1bMjU2LCAyNTZdXSBUaWxlIHNpemUgaW4gcGl4ZWxzLlxuICovXG5cbi8qKlxuICogQ3JlYXRlcyBhIHRpbGUgZ3JpZCB3aXRoIGEgc3RhbmRhcmQgWFlaIHRpbGluZyBzY2hlbWUuXG4gKiBAcGFyYW0ge1hZWk9wdGlvbnN9IFtvcHRpb25zXSBUaWxlIGdyaWQgb3B0aW9ucy5cbiAqIEByZXR1cm4geyFUaWxlR3JpZH0gVGlsZSBncmlkIGluc3RhbmNlLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlWFlaKG9wdGlvbnMpIHtcbiAgY29uc3QgeHl6T3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgY29uc3QgZXh0ZW50ID0geHl6T3B0aW9ucy5leHRlbnQgfHwgZ2V0UHJvamVjdGlvbignRVBTRzozODU3JykuZ2V0RXh0ZW50KCk7XG5cbiAgY29uc3QgZ3JpZE9wdGlvbnMgPSB7XG4gICAgZXh0ZW50OiBleHRlbnQsXG4gICAgbWluWm9vbTogeHl6T3B0aW9ucy5taW5ab29tLFxuICAgIHRpbGVTaXplOiB4eXpPcHRpb25zLnRpbGVTaXplLFxuICAgIHJlc29sdXRpb25zOiByZXNvbHV0aW9uc0Zyb21FeHRlbnQoXG4gICAgICBleHRlbnQsXG4gICAgICB4eXpPcHRpb25zLm1heFpvb20sXG4gICAgICB4eXpPcHRpb25zLnRpbGVTaXplLFxuICAgICAgeHl6T3B0aW9ucy5tYXhSZXNvbHV0aW9uXG4gICAgKSxcbiAgfTtcbiAgcmV0dXJuIG5ldyBUaWxlR3JpZChncmlkT3B0aW9ucyk7XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgcmVzb2x1dGlvbnMgYXJyYXkgZnJvbSBhbiBleHRlbnQuICBBIHpvb20gZmFjdG9yIG9mIDIgaXMgYXNzdW1lZC5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9leHRlbnQuanNcIikuRXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICogQHBhcmFtIHtudW1iZXJ9IFttYXhab29tXSBNYXhpbXVtIHpvb20gbGV2ZWwgKGRlZmF1bHQgaXNcbiAqICAgICBERUZBVUxUX01BWF9aT09NKS5cbiAqIEBwYXJhbSB7bnVtYmVyfGltcG9ydChcIi4vc2l6ZS5qc1wiKS5TaXplfSBbdGlsZVNpemVdIFRpbGUgc2l6ZSAoZGVmYXVsdCB1c2VzXG4gKiAgICAgREVGQVVMVF9USUxFX1NJWkUpLlxuICogQHBhcmFtIHtudW1iZXJ9IFttYXhSZXNvbHV0aW9uXSBSZXNvbHV0aW9uIGF0IGxldmVsIHplcm8uXG4gKiBAcmV0dXJuIHshQXJyYXk8bnVtYmVyPn0gUmVzb2x1dGlvbnMgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIHJlc29sdXRpb25zRnJvbUV4dGVudChleHRlbnQsIG1heFpvb20sIHRpbGVTaXplLCBtYXhSZXNvbHV0aW9uKSB7XG4gIG1heFpvb20gPSBtYXhab29tICE9PSB1bmRlZmluZWQgPyBtYXhab29tIDogREVGQVVMVF9NQVhfWk9PTTtcbiAgdGlsZVNpemUgPSB0b1NpemUodGlsZVNpemUgIT09IHVuZGVmaW5lZCA/IHRpbGVTaXplIDogREVGQVVMVF9USUxFX1NJWkUpO1xuXG4gIGNvbnN0IGhlaWdodCA9IGdldEhlaWdodChleHRlbnQpO1xuICBjb25zdCB3aWR0aCA9IGdldFdpZHRoKGV4dGVudCk7XG5cbiAgbWF4UmVzb2x1dGlvbiA9XG4gICAgbWF4UmVzb2x1dGlvbiA+IDBcbiAgICAgID8gbWF4UmVzb2x1dGlvblxuICAgICAgOiBNYXRoLm1heCh3aWR0aCAvIHRpbGVTaXplWzBdLCBoZWlnaHQgLyB0aWxlU2l6ZVsxXSk7XG5cbiAgY29uc3QgbGVuZ3RoID0gbWF4Wm9vbSArIDE7XG4gIGNvbnN0IHJlc29sdXRpb25zID0gbmV3IEFycmF5KGxlbmd0aCk7XG4gIGZvciAobGV0IHogPSAwOyB6IDwgbGVuZ3RoOyArK3opIHtcbiAgICByZXNvbHV0aW9uc1t6XSA9IG1heFJlc29sdXRpb24gLyBNYXRoLnBvdygyLCB6KTtcbiAgfVxuICByZXR1cm4gcmVzb2x1dGlvbnM7XG59XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL3Byb2ouanNcIikuUHJvamVjdGlvbkxpa2V9IHByb2plY3Rpb24gUHJvamVjdGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbbWF4Wm9vbV0gTWF4aW11bSB6b29tIGxldmVsIChkZWZhdWx0IGlzXG4gKiAgICAgREVGQVVMVF9NQVhfWk9PTSkuXG4gKiBAcGFyYW0ge251bWJlcnxpbXBvcnQoXCIuL3NpemUuanNcIikuU2l6ZX0gW3RpbGVTaXplXSBUaWxlIHNpemUgKGRlZmF1bHQgdXNlc1xuICogICAgIERFRkFVTFRfVElMRV9TSVpFKS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9leHRlbnQuanNcIikuQ29ybmVyfSBbY29ybmVyXSBFeHRlbnQgY29ybmVyIChkZWZhdWx0IGlzIGAndG9wLWxlZnQnYCkuXG4gKiBAcmV0dXJuIHshVGlsZUdyaWR9IFRpbGVHcmlkIGluc3RhbmNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRm9yUHJvamVjdGlvbihwcm9qZWN0aW9uLCBtYXhab29tLCB0aWxlU2l6ZSwgY29ybmVyKSB7XG4gIGNvbnN0IGV4dGVudCA9IGV4dGVudEZyb21Qcm9qZWN0aW9uKHByb2plY3Rpb24pO1xuICByZXR1cm4gY3JlYXRlRm9yRXh0ZW50KGV4dGVudCwgbWF4Wm9vbSwgdGlsZVNpemUsIGNvcm5lcik7XG59XG5cbi8qKlxuICogR2VuZXJhdGUgYSB0aWxlIGdyaWQgZXh0ZW50IGZyb20gYSBwcm9qZWN0aW9uLiAgSWYgdGhlIHByb2plY3Rpb24gaGFzIGFuXG4gKiBleHRlbnQsIGl0IGlzIHVzZWQuICBJZiBub3QsIGEgZ2xvYmFsIGV4dGVudCBpcyBhc3N1bWVkLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL3Byb2ouanNcIikuUHJvamVjdGlvbkxpa2V9IHByb2plY3Rpb24gUHJvamVjdGlvbi5cbiAqIEByZXR1cm4ge2ltcG9ydChcIi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gRXh0ZW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZXh0ZW50RnJvbVByb2plY3Rpb24ocHJvamVjdGlvbikge1xuICBwcm9qZWN0aW9uID0gZ2V0UHJvamVjdGlvbihwcm9qZWN0aW9uKTtcbiAgbGV0IGV4dGVudCA9IHByb2plY3Rpb24uZ2V0RXh0ZW50KCk7XG4gIGlmICghZXh0ZW50KSB7XG4gICAgY29uc3QgaGFsZiA9XG4gICAgICAoMTgwICogTUVURVJTX1BFUl9VTklULmRlZ3JlZXMpIC8gcHJvamVjdGlvbi5nZXRNZXRlcnNQZXJVbml0KCk7XG4gICAgZXh0ZW50ID0gY3JlYXRlT3JVcGRhdGUoLWhhbGYsIC1oYWxmLCBoYWxmLCBoYWxmKTtcbiAgfVxuICByZXR1cm4gZXh0ZW50O1xufVxuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3RpbGVncmlkL1RpbGVHcmlkXG4gKi9cbmltcG9ydCBUaWxlUmFuZ2UsIHtcbiAgY3JlYXRlT3JVcGRhdGUgYXMgY3JlYXRlT3JVcGRhdGVUaWxlUmFuZ2UsXG59IGZyb20gJy4uL1RpbGVSYW5nZS5qcyc7XG5pbXBvcnQge0RFRkFVTFRfVElMRV9TSVpFfSBmcm9tICcuL2NvbW1vbi5qcyc7XG5pbXBvcnQge2Fzc2VydH0gZnJvbSAnLi4vYXNzZXJ0cy5qcyc7XG5pbXBvcnQge2NlaWwsIGNsYW1wLCBmbG9vcn0gZnJvbSAnLi4vbWF0aC5qcyc7XG5pbXBvcnQge2NyZWF0ZU9yVXBkYXRlLCBnZXRUb3BMZWZ0fSBmcm9tICcuLi9leHRlbnQuanMnO1xuaW1wb3J0IHtjcmVhdGVPclVwZGF0ZSBhcyBjcmVhdGVPclVwZGF0ZVRpbGVDb29yZH0gZnJvbSAnLi4vdGlsZWNvb3JkLmpzJztcbmltcG9ydCB7aW50ZXJzZWN0c0xpbmVhclJpbmd9IGZyb20gJy4uL2dlb20vZmxhdC9pbnRlcnNlY3RzZXh0ZW50LmpzJztcbmltcG9ydCB7aXNTb3J0ZWQsIGxpbmVhckZpbmROZWFyZXN0fSBmcm9tICcuLi9hcnJheS5qcyc7XG5pbXBvcnQge3RvU2l6ZX0gZnJvbSAnLi4vc2l6ZS5qcyc7XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEB0eXBlIHtpbXBvcnQoXCIuLi90aWxlY29vcmQuanNcIikuVGlsZUNvb3JkfVxuICovXG5jb25zdCB0bXBUaWxlQ29vcmQgPSBbMCwgMCwgMF07XG5cbi8qKlxuICogTnVtYmVyIG9mIGRlY2ltYWwgZGlnaXRzIHRvIGNvbnNpZGVyIGluIGludGVnZXIgdmFsdWVzIHdoZW4gcm91bmRpbmcuXG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5jb25zdCBERUNJTUFMUyA9IDU7XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fSBbZXh0ZW50XSBFeHRlbnQgZm9yIHRoZSB0aWxlIGdyaWQuIE5vIHRpbGVzIG91dHNpZGUgdGhpc1xuICogZXh0ZW50IHdpbGwgYmUgcmVxdWVzdGVkIGJ5IHtAbGluayBtb2R1bGU6b2wvc291cmNlL1RpbGV+VGlsZVNvdXJjZX0gc291cmNlcy4gV2hlbiBubyBgb3JpZ2luYCBvclxuICogYG9yaWdpbnNgIGFyZSBjb25maWd1cmVkLCB0aGUgYG9yaWdpbmAgd2lsbCBiZSBzZXQgdG8gdGhlIHRvcC1sZWZ0IGNvcm5lciBvZiB0aGUgZXh0ZW50LlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFttaW5ab29tPTBdIE1pbmltdW0gem9vbS5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBbb3JpZ2luXSBUaGUgdGlsZSBncmlkIG9yaWdpbiwgaS5lLiB3aGVyZSB0aGUgYHhgXG4gKiBhbmQgYHlgIGF4ZXMgbWVldCAoYFt6LCAwLCAwXWApLiBUaWxlIGNvb3JkaW5hdGVzIGluY3JlYXNlIGxlZnQgdG8gcmlnaHQgYW5kIGRvd253YXJkcy4gSWYgbm90XG4gKiBzcGVjaWZpZWQsIGBleHRlbnRgIG9yIGBvcmlnaW5zYCBtdXN0IGJlIHByb3ZpZGVkLlxuICogQHByb3BlcnR5IHtBcnJheTxpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGU+fSBbb3JpZ2luc10gVGlsZSBncmlkIG9yaWdpbnMsIGkuZS4gd2hlcmVcbiAqIHRoZSBgeGAgYW5kIGB5YCBheGVzIG1lZXQgKGBbeiwgMCwgMF1gKSwgZm9yIGVhY2ggem9vbSBsZXZlbC4gSWYgZ2l2ZW4sIHRoZSBhcnJheSBsZW5ndGhcbiAqIHNob3VsZCBtYXRjaCB0aGUgbGVuZ3RoIG9mIHRoZSBgcmVzb2x1dGlvbnNgIGFycmF5LCBpLmUuIGVhY2ggcmVzb2x1dGlvbiBjYW4gaGF2ZSBhIGRpZmZlcmVudFxuICogb3JpZ2luLiBUaWxlIGNvb3JkaW5hdGVzIGluY3JlYXNlIGxlZnQgdG8gcmlnaHQgYW5kIGRvd253YXJkcy4gSWYgbm90IHNwZWNpZmllZCwgYGV4dGVudGAgb3JcbiAqIGBvcmlnaW5gIG11c3QgYmUgcHJvdmlkZWQuXG4gKiBAcHJvcGVydHkgeyFBcnJheTxudW1iZXI+fSByZXNvbHV0aW9ucyBSZXNvbHV0aW9ucy4gVGhlIGFycmF5IGluZGV4IG9mIGVhY2ggcmVzb2x1dGlvbiBuZWVkc1xuICogdG8gbWF0Y2ggdGhlIHpvb20gbGV2ZWwuIFRoaXMgbWVhbnMgdGhhdCBldmVuIGlmIGEgYG1pblpvb21gIGlzIGNvbmZpZ3VyZWQsIHRoZSByZXNvbHV0aW9uc1xuICogYXJyYXkgd2lsbCBoYXZlIGEgbGVuZ3RoIG9mIGBtYXhab29tICsgMWAuXG4gKiBAcHJvcGVydHkge0FycmF5PGltcG9ydChcIi4uL3NpemUuanNcIikuU2l6ZT59IFtzaXplc10gTnVtYmVyIG9mIHRpbGUgcm93cyBhbmQgY29sdW1uc1xuICogb2YgdGhlIGdyaWQgZm9yIGVhY2ggem9vbSBsZXZlbC4gSWYgc3BlY2lmaWVkIHRoZSB2YWx1ZXNcbiAqIGRlZmluZSBlYWNoIHpvb20gbGV2ZWwncyBleHRlbnQgdG9nZXRoZXIgd2l0aCB0aGUgYG9yaWdpbmAgb3IgYG9yaWdpbnNgLlxuICogQSBncmlkIGBleHRlbnRgIGNhbiBiZSBjb25maWd1cmVkIGluIGFkZGl0aW9uLCBhbmQgd2lsbCBmdXJ0aGVyIGxpbWl0IHRoZSBleHRlbnRcbiAqIGZvciB3aGljaCB0aWxlIHJlcXVlc3RzIGFyZSBtYWRlIGJ5IHNvdXJjZXMuIElmIHRoZSBib3R0b20tbGVmdCBjb3JuZXIgb2ZcbiAqIGFuIGV4dGVudCBpcyB1c2VkIGFzIGBvcmlnaW5gIG9yIGBvcmlnaW5zYCwgdGhlbiB0aGUgYHlgIHZhbHVlIG11c3QgYmVcbiAqIG5lZ2F0aXZlIGJlY2F1c2UgT3BlbkxheWVycyB0aWxlIGNvb3JkaW5hdGVzIHVzZSB0aGUgdG9wIGxlZnQgYXMgdGhlIG9yaWdpbi5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfGltcG9ydChcIi4uL3NpemUuanNcIikuU2l6ZX0gW3RpbGVTaXplXSBUaWxlIHNpemUuXG4gKiBEZWZhdWx0IGlzIGBbMjU2LCAyNTZdYC5cbiAqIEBwcm9wZXJ0eSB7QXJyYXk8bnVtYmVyfGltcG9ydChcIi4uL3NpemUuanNcIikuU2l6ZT59IFt0aWxlU2l6ZXNdIFRpbGUgc2l6ZXMuIElmIGdpdmVuLCB0aGUgYXJyYXkgbGVuZ3RoXG4gKiBzaG91bGQgbWF0Y2ggdGhlIGxlbmd0aCBvZiB0aGUgYHJlc29sdXRpb25zYCBhcnJheSwgaS5lLiBlYWNoIHJlc29sdXRpb24gY2FuIGhhdmUgYSBkaWZmZXJlbnRcbiAqIHRpbGUgc2l6ZS5cbiAqL1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEJhc2UgY2xhc3MgZm9yIHNldHRpbmcgdGhlIGdyaWQgcGF0dGVybiBmb3Igc291cmNlcyBhY2Nlc3NpbmcgdGlsZWQtaW1hZ2VcbiAqIHNlcnZlcnMuXG4gKiBAYXBpXG4gKi9cbmNsYXNzIFRpbGVHcmlkIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7T3B0aW9uc30gb3B0aW9ucyBUaWxlIGdyaWQgb3B0aW9ucy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLm1pblpvb20gPSBvcHRpb25zLm1pblpvb20gIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMubWluWm9vbSA6IDA7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHshQXJyYXk8bnVtYmVyPn1cbiAgICAgKi9cbiAgICB0aGlzLnJlc29sdXRpb25zXyA9IG9wdGlvbnMucmVzb2x1dGlvbnM7XG4gICAgYXNzZXJ0KFxuICAgICAgaXNTb3J0ZWQoXG4gICAgICAgIHRoaXMucmVzb2x1dGlvbnNfLFxuICAgICAgICBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgIHJldHVybiBiIC0gYTtcbiAgICAgICAgfSxcbiAgICAgICAgdHJ1ZVxuICAgICAgKSxcbiAgICAgICdgcmVzb2x1dGlvbnNgIG11c3QgYmUgc29ydGVkIGluIGRlc2NlbmRpbmcgb3JkZXInXG4gICAgKTtcblxuICAgIC8vIGNoZWNrIGlmIHdlJ3ZlIGdvdCBhIGNvbnNpc3RlbnQgem9vbSBmYWN0b3IgYW5kIG9yaWdpblxuICAgIGxldCB6b29tRmFjdG9yO1xuICAgIGlmICghb3B0aW9ucy5vcmlnaW5zKSB7XG4gICAgICBmb3IgKGxldCBpID0gMCwgaWkgPSB0aGlzLnJlc29sdXRpb25zXy5sZW5ndGggLSAxOyBpIDwgaWk7ICsraSkge1xuICAgICAgICBpZiAoIXpvb21GYWN0b3IpIHtcbiAgICAgICAgICB6b29tRmFjdG9yID0gdGhpcy5yZXNvbHV0aW9uc19baV0gLyB0aGlzLnJlc29sdXRpb25zX1tpICsgMV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHRoaXMucmVzb2x1dGlvbnNfW2ldIC8gdGhpcy5yZXNvbHV0aW9uc19baSArIDFdICE9PSB6b29tRmFjdG9yKSB7XG4gICAgICAgICAgICB6b29tRmFjdG9yID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLnpvb21GYWN0b3JfID0gem9vbUZhY3RvcjtcblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubWF4Wm9vbSA9IHRoaXMucmVzb2x1dGlvbnNfLmxlbmd0aCAtIDE7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV8bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLm9yaWdpbl8gPSBvcHRpb25zLm9yaWdpbiAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5vcmlnaW4gOiBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7QXJyYXk8aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlPn1cbiAgICAgKi9cbiAgICB0aGlzLm9yaWdpbnNfID0gbnVsbDtcbiAgICBpZiAob3B0aW9ucy5vcmlnaW5zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMub3JpZ2luc18gPSBvcHRpb25zLm9yaWdpbnM7XG4gICAgICBhc3NlcnQoXG4gICAgICAgIHRoaXMub3JpZ2luc18ubGVuZ3RoID09IHRoaXMucmVzb2x1dGlvbnNfLmxlbmd0aCxcbiAgICAgICAgJ051bWJlciBvZiBgb3JpZ2luc2AgYW5kIGByZXNvbHV0aW9uc2AgbXVzdCBiZSBlcXVhbCdcbiAgICAgICk7XG4gICAgfVxuXG4gICAgY29uc3QgZXh0ZW50ID0gb3B0aW9ucy5leHRlbnQ7XG5cbiAgICBpZiAoZXh0ZW50ICE9PSB1bmRlZmluZWQgJiYgIXRoaXMub3JpZ2luXyAmJiAhdGhpcy5vcmlnaW5zXykge1xuICAgICAgdGhpcy5vcmlnaW5fID0gZ2V0VG9wTGVmdChleHRlbnQpO1xuICAgIH1cblxuICAgIGFzc2VydChcbiAgICAgICghdGhpcy5vcmlnaW5fICYmIHRoaXMub3JpZ2luc18pIHx8ICh0aGlzLm9yaWdpbl8gJiYgIXRoaXMub3JpZ2luc18pLFxuICAgICAgJ0VpdGhlciBgb3JpZ2luYCBvciBgb3JpZ2luc2AgbXVzdCBiZSBjb25maWd1cmVkLCBuZXZlciBib3RoJ1xuICAgICk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtBcnJheTxudW1iZXJ8aW1wb3J0KFwiLi4vc2l6ZS5qc1wiKS5TaXplPn1cbiAgICAgKi9cbiAgICB0aGlzLnRpbGVTaXplc18gPSBudWxsO1xuICAgIGlmIChvcHRpb25zLnRpbGVTaXplcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLnRpbGVTaXplc18gPSBvcHRpb25zLnRpbGVTaXplcztcbiAgICAgIGFzc2VydChcbiAgICAgICAgdGhpcy50aWxlU2l6ZXNfLmxlbmd0aCA9PSB0aGlzLnJlc29sdXRpb25zXy5sZW5ndGgsXG4gICAgICAgICdOdW1iZXIgb2YgYHRpbGVTaXplc2AgYW5kIGByZXNvbHV0aW9uc2AgbXVzdCBiZSBlcXVhbCdcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfGltcG9ydChcIi4uL3NpemUuanNcIikuU2l6ZX1cbiAgICAgKi9cbiAgICB0aGlzLnRpbGVTaXplXyA9XG4gICAgICBvcHRpb25zLnRpbGVTaXplICE9PSB1bmRlZmluZWRcbiAgICAgICAgPyBvcHRpb25zLnRpbGVTaXplXG4gICAgICAgIDogIXRoaXMudGlsZVNpemVzX1xuICAgICAgICA/IERFRkFVTFRfVElMRV9TSVpFXG4gICAgICAgIDogbnVsbDtcbiAgICBhc3NlcnQoXG4gICAgICAoIXRoaXMudGlsZVNpemVfICYmIHRoaXMudGlsZVNpemVzXykgfHxcbiAgICAgICAgKHRoaXMudGlsZVNpemVfICYmICF0aGlzLnRpbGVTaXplc18pLFxuICAgICAgJ0VpdGhlciBgdGlsZVNpemVgIG9yIGB0aWxlU2l6ZXNgIG11c3QgYmUgY29uZmlndXJlZCwgbmV2ZXIgYm90aCdcbiAgICApO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH1cbiAgICAgKi9cbiAgICB0aGlzLmV4dGVudF8gPSBleHRlbnQgIT09IHVuZGVmaW5lZCA/IGV4dGVudCA6IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtBcnJheTxpbXBvcnQoXCIuLi9UaWxlUmFuZ2UuanNcIikuZGVmYXVsdD59XG4gICAgICovXG4gICAgdGhpcy5mdWxsVGlsZVJhbmdlc18gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vc2l6ZS5qc1wiKS5TaXplfVxuICAgICAqL1xuICAgIHRoaXMudG1wU2l6ZV8gPSBbMCwgMF07XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fVxuICAgICAqL1xuICAgIHRoaXMudG1wRXh0ZW50XyA9IFswLCAwLCAwLCAwXTtcblxuICAgIGlmIChvcHRpb25zLnNpemVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuZnVsbFRpbGVSYW5nZXNfID0gb3B0aW9ucy5zaXplcy5tYXAoZnVuY3Rpb24gKHNpemUsIHopIHtcbiAgICAgICAgY29uc3QgdGlsZVJhbmdlID0gbmV3IFRpbGVSYW5nZShcbiAgICAgICAgICBNYXRoLm1pbigwLCBzaXplWzBdKSxcbiAgICAgICAgICBNYXRoLm1heChzaXplWzBdIC0gMSwgLTEpLFxuICAgICAgICAgIE1hdGgubWluKDAsIHNpemVbMV0pLFxuICAgICAgICAgIE1hdGgubWF4KHNpemVbMV0gLSAxLCAtMSlcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKGV4dGVudCkge1xuICAgICAgICAgIGNvbnN0IHJlc3RyaWN0ZWRUaWxlUmFuZ2UgPSB0aGlzLmdldFRpbGVSYW5nZUZvckV4dGVudEFuZFooZXh0ZW50LCB6KTtcbiAgICAgICAgICB0aWxlUmFuZ2UubWluWCA9IE1hdGgubWF4KHJlc3RyaWN0ZWRUaWxlUmFuZ2UubWluWCwgdGlsZVJhbmdlLm1pblgpO1xuICAgICAgICAgIHRpbGVSYW5nZS5tYXhYID0gTWF0aC5taW4ocmVzdHJpY3RlZFRpbGVSYW5nZS5tYXhYLCB0aWxlUmFuZ2UubWF4WCk7XG4gICAgICAgICAgdGlsZVJhbmdlLm1pblkgPSBNYXRoLm1heChyZXN0cmljdGVkVGlsZVJhbmdlLm1pblksIHRpbGVSYW5nZS5taW5ZKTtcbiAgICAgICAgICB0aWxlUmFuZ2UubWF4WSA9IE1hdGgubWluKHJlc3RyaWN0ZWRUaWxlUmFuZ2UubWF4WSwgdGlsZVJhbmdlLm1heFkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aWxlUmFuZ2U7XG4gICAgICB9LCB0aGlzKTtcbiAgICB9IGVsc2UgaWYgKGV4dGVudCkge1xuICAgICAgdGhpcy5jYWxjdWxhdGVUaWxlUmFuZ2VzXyhleHRlbnQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsIGEgZnVuY3Rpb24gd2l0aCBlYWNoIHRpbGUgY29vcmRpbmF0ZSBmb3IgYSBnaXZlbiBleHRlbnQgYW5kIHpvb20gbGV2ZWwuXG4gICAqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHpvb20gSW50ZWdlciB6b29tIGxldmVsLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKGltcG9ydChcIi4uL3RpbGVjb29yZC5qc1wiKS5UaWxlQ29vcmQpOiB2b2lkfSBjYWxsYmFjayBGdW5jdGlvbiBjYWxsZWQgd2l0aCBlYWNoIHRpbGUgY29vcmRpbmF0ZS5cbiAgICogQGFwaVxuICAgKi9cbiAgZm9yRWFjaFRpbGVDb29yZChleHRlbnQsIHpvb20sIGNhbGxiYWNrKSB7XG4gICAgY29uc3QgdGlsZVJhbmdlID0gdGhpcy5nZXRUaWxlUmFuZ2VGb3JFeHRlbnRBbmRaKGV4dGVudCwgem9vbSk7XG4gICAgZm9yIChsZXQgaSA9IHRpbGVSYW5nZS5taW5YLCBpaSA9IHRpbGVSYW5nZS5tYXhYOyBpIDw9IGlpOyArK2kpIHtcbiAgICAgIGZvciAobGV0IGogPSB0aWxlUmFuZ2UubWluWSwgamogPSB0aWxlUmFuZ2UubWF4WTsgaiA8PSBqajsgKytqKSB7XG4gICAgICAgIGNhbGxiYWNrKFt6b29tLCBpLCBqXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vdGlsZWNvb3JkLmpzXCIpLlRpbGVDb29yZH0gdGlsZUNvb3JkIFRpbGUgY29vcmRpbmF0ZS5cbiAgICogQHBhcmFtIHtmdW5jdGlvbihudW1iZXIsIGltcG9ydChcIi4uL1RpbGVSYW5nZS5qc1wiKS5kZWZhdWx0KTogYm9vbGVhbn0gY2FsbGJhY2sgQ2FsbGJhY2suXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vVGlsZVJhbmdlLmpzXCIpLmRlZmF1bHR9IFt0ZW1wVGlsZVJhbmdlXSBUZW1wb3JhcnkgaW1wb3J0KFwiLi4vVGlsZVJhbmdlLmpzXCIpLmRlZmF1bHQgb2JqZWN0LlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IFt0ZW1wRXh0ZW50XSBUZW1wb3JhcnkgaW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudCBvYmplY3QuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IENhbGxiYWNrIHN1Y2NlZWRlZC5cbiAgICovXG4gIGZvckVhY2hUaWxlQ29vcmRQYXJlbnRUaWxlUmFuZ2UoXG4gICAgdGlsZUNvb3JkLFxuICAgIGNhbGxiYWNrLFxuICAgIHRlbXBUaWxlUmFuZ2UsXG4gICAgdGVtcEV4dGVudFxuICApIHtcbiAgICBsZXQgdGlsZVJhbmdlLCB4LCB5O1xuICAgIGxldCB0aWxlQ29vcmRFeHRlbnQgPSBudWxsO1xuICAgIGxldCB6ID0gdGlsZUNvb3JkWzBdIC0gMTtcbiAgICBpZiAodGhpcy56b29tRmFjdG9yXyA9PT0gMikge1xuICAgICAgeCA9IHRpbGVDb29yZFsxXTtcbiAgICAgIHkgPSB0aWxlQ29vcmRbMl07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRpbGVDb29yZEV4dGVudCA9IHRoaXMuZ2V0VGlsZUNvb3JkRXh0ZW50KHRpbGVDb29yZCwgdGVtcEV4dGVudCk7XG4gICAgfVxuICAgIHdoaWxlICh6ID49IHRoaXMubWluWm9vbSkge1xuICAgICAgaWYgKHRoaXMuem9vbUZhY3Rvcl8gPT09IDIpIHtcbiAgICAgICAgeCA9IE1hdGguZmxvb3IoeCAvIDIpO1xuICAgICAgICB5ID0gTWF0aC5mbG9vcih5IC8gMik7XG4gICAgICAgIHRpbGVSYW5nZSA9IGNyZWF0ZU9yVXBkYXRlVGlsZVJhbmdlKHgsIHgsIHksIHksIHRlbXBUaWxlUmFuZ2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGlsZVJhbmdlID0gdGhpcy5nZXRUaWxlUmFuZ2VGb3JFeHRlbnRBbmRaKFxuICAgICAgICAgIHRpbGVDb29yZEV4dGVudCxcbiAgICAgICAgICB6LFxuICAgICAgICAgIHRlbXBUaWxlUmFuZ2VcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChjYWxsYmFjayh6LCB0aWxlUmFuZ2UpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgLS16O1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBleHRlbnQgZm9yIHRoaXMgdGlsZSBncmlkLCBpZiBpdCB3YXMgY29uZmlndXJlZC5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gRXh0ZW50LlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRFeHRlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZXh0ZW50XztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG1heGltdW0gem9vbSBsZXZlbCBmb3IgdGhlIGdyaWQuXG4gICAqIEByZXR1cm4ge251bWJlcn0gTWF4IHpvb20uXG4gICAqIEBhcGlcbiAgICovXG4gIGdldE1heFpvb20oKSB7XG4gICAgcmV0dXJuIHRoaXMubWF4Wm9vbTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG1pbmltdW0gem9vbSBsZXZlbCBmb3IgdGhlIGdyaWQuXG4gICAqIEByZXR1cm4ge251bWJlcn0gTWluIHpvb20uXG4gICAqIEBhcGlcbiAgICovXG4gIGdldE1pblpvb20oKSB7XG4gICAgcmV0dXJuIHRoaXMubWluWm9vbTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG9yaWdpbiBmb3IgdGhlIGdyaWQgYXQgdGhlIGdpdmVuIHpvb20gbGV2ZWwuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB6IEludGVnZXIgem9vbSBsZXZlbC5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBPcmlnaW4uXG4gICAqIEBhcGlcbiAgICovXG4gIGdldE9yaWdpbih6KSB7XG4gICAgaWYgKHRoaXMub3JpZ2luXykge1xuICAgICAgcmV0dXJuIHRoaXMub3JpZ2luXztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMub3JpZ2luc19bel07XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSByZXNvbHV0aW9uIGZvciB0aGUgZ2l2ZW4gem9vbSBsZXZlbC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHogSW50ZWdlciB6b29tIGxldmVsLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IFJlc29sdXRpb24uXG4gICAqIEBhcGlcbiAgICovXG4gIGdldFJlc29sdXRpb24oeikge1xuICAgIHJldHVybiB0aGlzLnJlc29sdXRpb25zX1t6XTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGxpc3Qgb2YgcmVzb2x1dGlvbnMgZm9yIHRoZSB0aWxlIGdyaWQuXG4gICAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IFJlc29sdXRpb25zLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRSZXNvbHV0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5yZXNvbHV0aW9uc187XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi90aWxlY29vcmQuanNcIikuVGlsZUNvb3JkfSB0aWxlQ29vcmQgVGlsZSBjb29yZGluYXRlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL1RpbGVSYW5nZS5qc1wiKS5kZWZhdWx0fSBbdGVtcFRpbGVSYW5nZV0gVGVtcG9yYXJ5IGltcG9ydChcIi4uL1RpbGVSYW5nZS5qc1wiKS5kZWZhdWx0IG9iamVjdC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fSBbdGVtcEV4dGVudF0gVGVtcG9yYXJ5IGltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnQgb2JqZWN0LlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9UaWxlUmFuZ2UuanNcIikuZGVmYXVsdHxudWxsfSBUaWxlIHJhbmdlLlxuICAgKi9cbiAgZ2V0VGlsZUNvb3JkQ2hpbGRUaWxlUmFuZ2UodGlsZUNvb3JkLCB0ZW1wVGlsZVJhbmdlLCB0ZW1wRXh0ZW50KSB7XG4gICAgaWYgKHRpbGVDb29yZFswXSA8IHRoaXMubWF4Wm9vbSkge1xuICAgICAgaWYgKHRoaXMuem9vbUZhY3Rvcl8gPT09IDIpIHtcbiAgICAgICAgY29uc3QgbWluWCA9IHRpbGVDb29yZFsxXSAqIDI7XG4gICAgICAgIGNvbnN0IG1pblkgPSB0aWxlQ29vcmRbMl0gKiAyO1xuICAgICAgICByZXR1cm4gY3JlYXRlT3JVcGRhdGVUaWxlUmFuZ2UoXG4gICAgICAgICAgbWluWCxcbiAgICAgICAgICBtaW5YICsgMSxcbiAgICAgICAgICBtaW5ZLFxuICAgICAgICAgIG1pblkgKyAxLFxuICAgICAgICAgIHRlbXBUaWxlUmFuZ2VcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRpbGVDb29yZEV4dGVudCA9IHRoaXMuZ2V0VGlsZUNvb3JkRXh0ZW50KFxuICAgICAgICB0aWxlQ29vcmQsXG4gICAgICAgIHRlbXBFeHRlbnQgfHwgdGhpcy50bXBFeHRlbnRfXG4gICAgICApO1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0VGlsZVJhbmdlRm9yRXh0ZW50QW5kWihcbiAgICAgICAgdGlsZUNvb3JkRXh0ZW50LFxuICAgICAgICB0aWxlQ29vcmRbMF0gKyAxLFxuICAgICAgICB0ZW1wVGlsZVJhbmdlXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3RpbGVjb29yZC5qc1wiKS5UaWxlQ29vcmR9IHRpbGVDb29yZCBUaWxlIGNvb3JkaW5hdGUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB6IEludGVnZXIgem9vbSBsZXZlbC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9UaWxlUmFuZ2UuanNcIikuZGVmYXVsdH0gW3RlbXBUaWxlUmFuZ2VdIFRlbXBvcmFyeSBpbXBvcnQoXCIuLi9UaWxlUmFuZ2UuanNcIikuZGVmYXVsdCBvYmplY3QuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL1RpbGVSYW5nZS5qc1wiKS5kZWZhdWx0fG51bGx9IFRpbGUgcmFuZ2UuXG4gICAqL1xuICBnZXRUaWxlUmFuZ2VGb3JUaWxlQ29vcmRBbmRaKHRpbGVDb29yZCwgeiwgdGVtcFRpbGVSYW5nZSkge1xuICAgIGlmICh6ID4gdGhpcy5tYXhab29tIHx8IHogPCB0aGlzLm1pblpvb20pIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGNvbnN0IHRpbGVDb29yZFogPSB0aWxlQ29vcmRbMF07XG4gICAgY29uc3QgdGlsZUNvb3JkWCA9IHRpbGVDb29yZFsxXTtcbiAgICBjb25zdCB0aWxlQ29vcmRZID0gdGlsZUNvb3JkWzJdO1xuXG4gICAgaWYgKHogPT09IHRpbGVDb29yZFopIHtcbiAgICAgIHJldHVybiBjcmVhdGVPclVwZGF0ZVRpbGVSYW5nZShcbiAgICAgICAgdGlsZUNvb3JkWCxcbiAgICAgICAgdGlsZUNvb3JkWSxcbiAgICAgICAgdGlsZUNvb3JkWCxcbiAgICAgICAgdGlsZUNvb3JkWSxcbiAgICAgICAgdGVtcFRpbGVSYW5nZVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy56b29tRmFjdG9yXykge1xuICAgICAgY29uc3QgZmFjdG9yID0gTWF0aC5wb3codGhpcy56b29tRmFjdG9yXywgeiAtIHRpbGVDb29yZFopO1xuICAgICAgY29uc3QgbWluWCA9IE1hdGguZmxvb3IodGlsZUNvb3JkWCAqIGZhY3Rvcik7XG4gICAgICBjb25zdCBtaW5ZID0gTWF0aC5mbG9vcih0aWxlQ29vcmRZICogZmFjdG9yKTtcbiAgICAgIGlmICh6IDwgdGlsZUNvb3JkWikge1xuICAgICAgICByZXR1cm4gY3JlYXRlT3JVcGRhdGVUaWxlUmFuZ2UobWluWCwgbWluWCwgbWluWSwgbWluWSwgdGVtcFRpbGVSYW5nZSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG1heFggPSBNYXRoLmZsb29yKGZhY3RvciAqICh0aWxlQ29vcmRYICsgMSkpIC0gMTtcbiAgICAgIGNvbnN0IG1heFkgPSBNYXRoLmZsb29yKGZhY3RvciAqICh0aWxlQ29vcmRZICsgMSkpIC0gMTtcbiAgICAgIHJldHVybiBjcmVhdGVPclVwZGF0ZVRpbGVSYW5nZShtaW5YLCBtYXhYLCBtaW5ZLCBtYXhZLCB0ZW1wVGlsZVJhbmdlKTtcbiAgICB9XG5cbiAgICBjb25zdCB0aWxlQ29vcmRFeHRlbnQgPSB0aGlzLmdldFRpbGVDb29yZEV4dGVudCh0aWxlQ29vcmQsIHRoaXMudG1wRXh0ZW50Xyk7XG4gICAgcmV0dXJuIHRoaXMuZ2V0VGlsZVJhbmdlRm9yRXh0ZW50QW5kWih0aWxlQ29vcmRFeHRlbnQsIHosIHRlbXBUaWxlUmFuZ2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhIHRpbGUgcmFuZ2UgZm9yIHRoZSBnaXZlbiBleHRlbnQgYW5kIGludGVnZXIgem9vbSBsZXZlbC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICAgKiBAcGFyYW0ge251bWJlcn0geiBJbnRlZ2VyIHpvb20gbGV2ZWwuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vVGlsZVJhbmdlLmpzXCIpLmRlZmF1bHR9IFt0ZW1wVGlsZVJhbmdlXSBUZW1wb3JhcnkgdGlsZSByYW5nZSBvYmplY3QuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL1RpbGVSYW5nZS5qc1wiKS5kZWZhdWx0fSBUaWxlIHJhbmdlLlxuICAgKi9cbiAgZ2V0VGlsZVJhbmdlRm9yRXh0ZW50QW5kWihleHRlbnQsIHosIHRlbXBUaWxlUmFuZ2UpIHtcbiAgICB0aGlzLmdldFRpbGVDb29yZEZvclhZQW5kWl8oZXh0ZW50WzBdLCBleHRlbnRbM10sIHosIGZhbHNlLCB0bXBUaWxlQ29vcmQpO1xuICAgIGNvbnN0IG1pblggPSB0bXBUaWxlQ29vcmRbMV07XG4gICAgY29uc3QgbWluWSA9IHRtcFRpbGVDb29yZFsyXTtcbiAgICB0aGlzLmdldFRpbGVDb29yZEZvclhZQW5kWl8oZXh0ZW50WzJdLCBleHRlbnRbMV0sIHosIHRydWUsIHRtcFRpbGVDb29yZCk7XG4gICAgY29uc3QgbWF4WCA9IHRtcFRpbGVDb29yZFsxXTtcbiAgICBjb25zdCBtYXhZID0gdG1wVGlsZUNvb3JkWzJdO1xuICAgIHJldHVybiBjcmVhdGVPclVwZGF0ZVRpbGVSYW5nZShtaW5YLCBtYXhYLCBtaW5ZLCBtYXhZLCB0ZW1wVGlsZVJhbmdlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3RpbGVjb29yZC5qc1wiKS5UaWxlQ29vcmR9IHRpbGVDb29yZCBUaWxlIGNvb3JkaW5hdGUuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gVGlsZSBjZW50ZXIuXG4gICAqL1xuICBnZXRUaWxlQ29vcmRDZW50ZXIodGlsZUNvb3JkKSB7XG4gICAgY29uc3Qgb3JpZ2luID0gdGhpcy5nZXRPcmlnaW4odGlsZUNvb3JkWzBdKTtcbiAgICBjb25zdCByZXNvbHV0aW9uID0gdGhpcy5nZXRSZXNvbHV0aW9uKHRpbGVDb29yZFswXSk7XG4gICAgY29uc3QgdGlsZVNpemUgPSB0b1NpemUodGhpcy5nZXRUaWxlU2l6ZSh0aWxlQ29vcmRbMF0pLCB0aGlzLnRtcFNpemVfKTtcbiAgICByZXR1cm4gW1xuICAgICAgb3JpZ2luWzBdICsgKHRpbGVDb29yZFsxXSArIDAuNSkgKiB0aWxlU2l6ZVswXSAqIHJlc29sdXRpb24sXG4gICAgICBvcmlnaW5bMV0gLSAodGlsZUNvb3JkWzJdICsgMC41KSAqIHRpbGVTaXplWzFdICogcmVzb2x1dGlvbixcbiAgICBdO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZXh0ZW50IG9mIGEgdGlsZSBjb29yZGluYXRlLlxuICAgKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3RpbGVjb29yZC5qc1wiKS5UaWxlQ29vcmR9IHRpbGVDb29yZCBUaWxlIGNvb3JkaW5hdGUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gW3RlbXBFeHRlbnRdIFRlbXBvcmFyeSBleHRlbnQgb2JqZWN0LlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fSBFeHRlbnQuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldFRpbGVDb29yZEV4dGVudCh0aWxlQ29vcmQsIHRlbXBFeHRlbnQpIHtcbiAgICBjb25zdCBvcmlnaW4gPSB0aGlzLmdldE9yaWdpbih0aWxlQ29vcmRbMF0pO1xuICAgIGNvbnN0IHJlc29sdXRpb24gPSB0aGlzLmdldFJlc29sdXRpb24odGlsZUNvb3JkWzBdKTtcbiAgICBjb25zdCB0aWxlU2l6ZSA9IHRvU2l6ZSh0aGlzLmdldFRpbGVTaXplKHRpbGVDb29yZFswXSksIHRoaXMudG1wU2l6ZV8pO1xuICAgIGNvbnN0IG1pblggPSBvcmlnaW5bMF0gKyB0aWxlQ29vcmRbMV0gKiB0aWxlU2l6ZVswXSAqIHJlc29sdXRpb247XG4gICAgY29uc3QgbWluWSA9IG9yaWdpblsxXSAtICh0aWxlQ29vcmRbMl0gKyAxKSAqIHRpbGVTaXplWzFdICogcmVzb2x1dGlvbjtcbiAgICBjb25zdCBtYXhYID0gbWluWCArIHRpbGVTaXplWzBdICogcmVzb2x1dGlvbjtcbiAgICBjb25zdCBtYXhZID0gbWluWSArIHRpbGVTaXplWzFdICogcmVzb2x1dGlvbjtcbiAgICByZXR1cm4gY3JlYXRlT3JVcGRhdGUobWluWCwgbWluWSwgbWF4WCwgbWF4WSwgdGVtcEV4dGVudCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB0aWxlIGNvb3JkaW5hdGUgZm9yIHRoZSBnaXZlbiBtYXAgY29vcmRpbmF0ZSBhbmQgcmVzb2x1dGlvbi4gIFRoaXNcbiAgICogbWV0aG9kIGNvbnNpZGVycyB0aGF0IGNvb3JkaW5hdGVzIHRoYXQgaW50ZXJzZWN0IHRpbGUgYm91bmRhcmllcyBzaG91bGQgYmVcbiAgICogYXNzaWduZWQgdGhlIGhpZ2hlciB0aWxlIGNvb3JkaW5hdGUuXG4gICAqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBjb29yZGluYXRlIENvb3JkaW5hdGUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSByZXNvbHV0aW9uIFJlc29sdXRpb24uXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vdGlsZWNvb3JkLmpzXCIpLlRpbGVDb29yZH0gW29wdF90aWxlQ29vcmRdIERlc3RpbmF0aW9uIGltcG9ydChcIi4uL3RpbGVjb29yZC5qc1wiKS5UaWxlQ29vcmQgb2JqZWN0LlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi90aWxlY29vcmQuanNcIikuVGlsZUNvb3JkfSBUaWxlIGNvb3JkaW5hdGUuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldFRpbGVDb29yZEZvckNvb3JkQW5kUmVzb2x1dGlvbihjb29yZGluYXRlLCByZXNvbHV0aW9uLCBvcHRfdGlsZUNvb3JkKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0VGlsZUNvb3JkRm9yWFlBbmRSZXNvbHV0aW9uXyhcbiAgICAgIGNvb3JkaW5hdGVbMF0sXG4gICAgICBjb29yZGluYXRlWzFdLFxuICAgICAgcmVzb2x1dGlvbixcbiAgICAgIGZhbHNlLFxuICAgICAgb3B0X3RpbGVDb29yZFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogTm90ZSB0aGF0IHRoaXMgbWV0aG9kIHNob3VsZCBub3QgYmUgY2FsbGVkIGZvciByZXNvbHV0aW9ucyB0aGF0IGNvcnJlc3BvbmRcbiAgICogdG8gYW4gaW50ZWdlciB6b29tIGxldmVsLiAgSW5zdGVhZCBjYWxsIHRoZSBgZ2V0VGlsZUNvb3JkRm9yWFlBbmRaX2AgbWV0aG9kLlxuICAgKiBAcGFyYW0ge251bWJlcn0geCBYLlxuICAgKiBAcGFyYW0ge251bWJlcn0geSBZLlxuICAgKiBAcGFyYW0ge251bWJlcn0gcmVzb2x1dGlvbiBSZXNvbHV0aW9uIChmb3IgYSBub24taW50ZWdlciB6b29tIGxldmVsKS5cbiAgICogQHBhcmFtIHtib29sZWFufSByZXZlcnNlSW50ZXJzZWN0aW9uUG9saWN5IEluc3RlYWQgb2YgbGV0dGluZyBlZGdlXG4gICAqICAgICBpbnRlcnNlY3Rpb25zIGdvIHRvIHRoZSBoaWdoZXIgdGlsZSBjb29yZGluYXRlLCBsZXQgZWRnZSBpbnRlcnNlY3Rpb25zXG4gICAqICAgICBnbyB0byB0aGUgbG93ZXIgdGlsZSBjb29yZGluYXRlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3RpbGVjb29yZC5qc1wiKS5UaWxlQ29vcmR9IFtvcHRfdGlsZUNvb3JkXSBUZW1wb3JhcnkgaW1wb3J0KFwiLi4vdGlsZWNvb3JkLmpzXCIpLlRpbGVDb29yZCBvYmplY3QuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL3RpbGVjb29yZC5qc1wiKS5UaWxlQ29vcmR9IFRpbGUgY29vcmRpbmF0ZS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldFRpbGVDb29yZEZvclhZQW5kUmVzb2x1dGlvbl8oXG4gICAgeCxcbiAgICB5LFxuICAgIHJlc29sdXRpb24sXG4gICAgcmV2ZXJzZUludGVyc2VjdGlvblBvbGljeSxcbiAgICBvcHRfdGlsZUNvb3JkXG4gICkge1xuICAgIGNvbnN0IHogPSB0aGlzLmdldFpGb3JSZXNvbHV0aW9uKHJlc29sdXRpb24pO1xuICAgIGNvbnN0IHNjYWxlID0gcmVzb2x1dGlvbiAvIHRoaXMuZ2V0UmVzb2x1dGlvbih6KTtcbiAgICBjb25zdCBvcmlnaW4gPSB0aGlzLmdldE9yaWdpbih6KTtcbiAgICBjb25zdCB0aWxlU2l6ZSA9IHRvU2l6ZSh0aGlzLmdldFRpbGVTaXplKHopLCB0aGlzLnRtcFNpemVfKTtcblxuICAgIGxldCB0aWxlQ29vcmRYID0gKHNjYWxlICogKHggLSBvcmlnaW5bMF0pKSAvIHJlc29sdXRpb24gLyB0aWxlU2l6ZVswXTtcbiAgICBsZXQgdGlsZUNvb3JkWSA9IChzY2FsZSAqIChvcmlnaW5bMV0gLSB5KSkgLyByZXNvbHV0aW9uIC8gdGlsZVNpemVbMV07XG5cbiAgICBpZiAocmV2ZXJzZUludGVyc2VjdGlvblBvbGljeSkge1xuICAgICAgdGlsZUNvb3JkWCA9IGNlaWwodGlsZUNvb3JkWCwgREVDSU1BTFMpIC0gMTtcbiAgICAgIHRpbGVDb29yZFkgPSBjZWlsKHRpbGVDb29yZFksIERFQ0lNQUxTKSAtIDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRpbGVDb29yZFggPSBmbG9vcih0aWxlQ29vcmRYLCBERUNJTUFMUyk7XG4gICAgICB0aWxlQ29vcmRZID0gZmxvb3IodGlsZUNvb3JkWSwgREVDSU1BTFMpO1xuICAgIH1cblxuICAgIHJldHVybiBjcmVhdGVPclVwZGF0ZVRpbGVDb29yZCh6LCB0aWxlQ29vcmRYLCB0aWxlQ29vcmRZLCBvcHRfdGlsZUNvb3JkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBbHRob3VnaCB0aGVyZSBpcyByZXBldGl0aW9uIGJldHdlZW4gdGhpcyBtZXRob2QgYW5kIGBnZXRUaWxlQ29vcmRGb3JYWUFuZFJlc29sdXRpb25fYCxcbiAgICogdGhleSBzaG91bGQgaGF2ZSBzZXBhcmF0ZSBpbXBsZW1lbnRhdGlvbnMuICBUaGlzIG1ldGhvZCBpcyBmb3IgaW50ZWdlciB6b29tXG4gICAqIGxldmVscy4gIFRoZSBvdGhlciBtZXRob2Qgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIGZvciByZXNvbHV0aW9ucyBjb3JyZXNwb25kaW5nXG4gICAqIHRvIG5vbi1pbnRlZ2VyIHpvb20gbGV2ZWxzLlxuICAgKiBAcGFyYW0ge251bWJlcn0geCBNYXAgeCBjb29yZGluYXRlLlxuICAgKiBAcGFyYW0ge251bWJlcn0geSBNYXAgeSBjb29yZGluYXRlLlxuICAgKiBAcGFyYW0ge251bWJlcn0geiBJbnRlZ2VyIHpvb20gbGV2ZWwuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gcmV2ZXJzZUludGVyc2VjdGlvblBvbGljeSBJbnN0ZWFkIG9mIGxldHRpbmcgZWRnZVxuICAgKiAgICAgaW50ZXJzZWN0aW9ucyBnbyB0byB0aGUgaGlnaGVyIHRpbGUgY29vcmRpbmF0ZSwgbGV0IGVkZ2UgaW50ZXJzZWN0aW9uc1xuICAgKiAgICAgZ28gdG8gdGhlIGxvd2VyIHRpbGUgY29vcmRpbmF0ZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi90aWxlY29vcmQuanNcIikuVGlsZUNvb3JkfSBbb3B0X3RpbGVDb29yZF0gVGVtcG9yYXJ5IGltcG9ydChcIi4uL3RpbGVjb29yZC5qc1wiKS5UaWxlQ29vcmQgb2JqZWN0LlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi90aWxlY29vcmQuanNcIikuVGlsZUNvb3JkfSBUaWxlIGNvb3JkaW5hdGUuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXRUaWxlQ29vcmRGb3JYWUFuZFpfKHgsIHksIHosIHJldmVyc2VJbnRlcnNlY3Rpb25Qb2xpY3ksIG9wdF90aWxlQ29vcmQpIHtcbiAgICBjb25zdCBvcmlnaW4gPSB0aGlzLmdldE9yaWdpbih6KTtcbiAgICBjb25zdCByZXNvbHV0aW9uID0gdGhpcy5nZXRSZXNvbHV0aW9uKHopO1xuICAgIGNvbnN0IHRpbGVTaXplID0gdG9TaXplKHRoaXMuZ2V0VGlsZVNpemUoeiksIHRoaXMudG1wU2l6ZV8pO1xuXG4gICAgbGV0IHRpbGVDb29yZFggPSAoeCAtIG9yaWdpblswXSkgLyByZXNvbHV0aW9uIC8gdGlsZVNpemVbMF07XG4gICAgbGV0IHRpbGVDb29yZFkgPSAob3JpZ2luWzFdIC0geSkgLyByZXNvbHV0aW9uIC8gdGlsZVNpemVbMV07XG5cbiAgICBpZiAocmV2ZXJzZUludGVyc2VjdGlvblBvbGljeSkge1xuICAgICAgdGlsZUNvb3JkWCA9IGNlaWwodGlsZUNvb3JkWCwgREVDSU1BTFMpIC0gMTtcbiAgICAgIHRpbGVDb29yZFkgPSBjZWlsKHRpbGVDb29yZFksIERFQ0lNQUxTKSAtIDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRpbGVDb29yZFggPSBmbG9vcih0aWxlQ29vcmRYLCBERUNJTUFMUyk7XG4gICAgICB0aWxlQ29vcmRZID0gZmxvb3IodGlsZUNvb3JkWSwgREVDSU1BTFMpO1xuICAgIH1cblxuICAgIHJldHVybiBjcmVhdGVPclVwZGF0ZVRpbGVDb29yZCh6LCB0aWxlQ29vcmRYLCB0aWxlQ29vcmRZLCBvcHRfdGlsZUNvb3JkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYSB0aWxlIGNvb3JkaW5hdGUgZ2l2ZW4gYSBtYXAgY29vcmRpbmF0ZSBhbmQgem9vbSBsZXZlbC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGNvb3JkaW5hdGUgQ29vcmRpbmF0ZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHogWm9vbSBsZXZlbC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi90aWxlY29vcmQuanNcIikuVGlsZUNvb3JkfSBbb3B0X3RpbGVDb29yZF0gRGVzdGluYXRpb24gaW1wb3J0KFwiLi4vdGlsZWNvb3JkLmpzXCIpLlRpbGVDb29yZCBvYmplY3QuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL3RpbGVjb29yZC5qc1wiKS5UaWxlQ29vcmR9IFRpbGUgY29vcmRpbmF0ZS5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0VGlsZUNvb3JkRm9yQ29vcmRBbmRaKGNvb3JkaW5hdGUsIHosIG9wdF90aWxlQ29vcmQpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRUaWxlQ29vcmRGb3JYWUFuZFpfKFxuICAgICAgY29vcmRpbmF0ZVswXSxcbiAgICAgIGNvb3JkaW5hdGVbMV0sXG4gICAgICB6LFxuICAgICAgZmFsc2UsXG4gICAgICBvcHRfdGlsZUNvb3JkXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3RpbGVjb29yZC5qc1wiKS5UaWxlQ29vcmR9IHRpbGVDb29yZCBUaWxlIGNvb3JkaW5hdGUuXG4gICAqIEByZXR1cm4ge251bWJlcn0gVGlsZSByZXNvbHV0aW9uLlxuICAgKi9cbiAgZ2V0VGlsZUNvb3JkUmVzb2x1dGlvbih0aWxlQ29vcmQpIHtcbiAgICByZXR1cm4gdGhpcy5yZXNvbHV0aW9uc19bdGlsZUNvb3JkWzBdXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHRpbGUgc2l6ZSBmb3IgYSB6b29tIGxldmVsLiBUaGUgdHlwZSBvZiB0aGUgcmV0dXJuIHZhbHVlIG1hdGNoZXMgdGhlXG4gICAqIGB0aWxlU2l6ZWAgb3IgYHRpbGVTaXplc2AgdGhhdCB0aGUgdGlsZSBncmlkIHdhcyBjb25maWd1cmVkIHdpdGguIFRvIGFsd2F5c1xuICAgKiBnZXQgYW4ge0BsaW5rIGltcG9ydChcIi4uL3NpemUuanNcIikuU2l6ZX0sIHJ1biB0aGUgcmVzdWx0IHRocm91Z2gge0BsaW5rIG1vZHVsZTpvbC9zaXplLnRvU2l6ZX0uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB6IFouXG4gICAqIEByZXR1cm4ge251bWJlcnxpbXBvcnQoXCIuLi9zaXplLmpzXCIpLlNpemV9IFRpbGUgc2l6ZS5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0VGlsZVNpemUoeikge1xuICAgIGlmICh0aGlzLnRpbGVTaXplXykge1xuICAgICAgcmV0dXJuIHRoaXMudGlsZVNpemVfO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy50aWxlU2l6ZXNfW3pdO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB6IFpvb20gbGV2ZWwuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL1RpbGVSYW5nZS5qc1wiKS5kZWZhdWx0fSBFeHRlbnQgdGlsZSByYW5nZSBmb3IgdGhlIHNwZWNpZmllZCB6b29tIGxldmVsLlxuICAgKi9cbiAgZ2V0RnVsbFRpbGVSYW5nZSh6KSB7XG4gICAgaWYgKCF0aGlzLmZ1bGxUaWxlUmFuZ2VzXykge1xuICAgICAgcmV0dXJuIHRoaXMuZXh0ZW50X1xuICAgICAgICA/IHRoaXMuZ2V0VGlsZVJhbmdlRm9yRXh0ZW50QW5kWih0aGlzLmV4dGVudF8sIHopXG4gICAgICAgIDogbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZnVsbFRpbGVSYW5nZXNfW3pdO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSByZXNvbHV0aW9uIFJlc29sdXRpb24uXG4gICAqIEBwYXJhbSB7bnVtYmVyfGltcG9ydChcIi4uL2FycmF5LmpzXCIpLk5lYXJlc3REaXJlY3Rpb25GdW5jdGlvbn0gW29wdF9kaXJlY3Rpb25dXG4gICAqICAgICBJZiAwLCB0aGUgbmVhcmVzdCByZXNvbHV0aW9uIHdpbGwgYmUgdXNlZC5cbiAgICogICAgIElmIDEsIHRoZSBuZWFyZXN0IGhpZ2hlciByZXNvbHV0aW9uIChsb3dlciBaKSB3aWxsIGJlIHVzZWQuIElmIC0xLCB0aGVcbiAgICogICAgIG5lYXJlc3QgbG93ZXIgcmVzb2x1dGlvbiAoaGlnaGVyIFopIHdpbGwgYmUgdXNlZC4gRGVmYXVsdCBpcyAwLlxuICAgKiAgICAgVXNlIGEge0BsaW5rIG1vZHVsZTpvbC9hcnJheX5OZWFyZXN0RGlyZWN0aW9uRnVuY3Rpb259IGZvciBtb3JlIHByZWNpc2UgY29udHJvbC5cbiAgICpcbiAgICogRm9yIGV4YW1wbGUgdG8gY2hhbmdlIHRpbGUgWiBhdCB0aGUgbWlkcG9pbnQgb2Ygem9vbSBsZXZlbHNcbiAgICogYGBganNcbiAgICogZnVuY3Rpb24odmFsdWUsIGhpZ2gsIGxvdykge1xuICAgKiAgIHJldHVybiB2YWx1ZSAtIGxvdyAqIE1hdGguc3FydChoaWdoIC8gbG93KTtcbiAgICogfVxuICAgKiBgYGBcbiAgICogQHJldHVybiB7bnVtYmVyfSBaLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRaRm9yUmVzb2x1dGlvbihyZXNvbHV0aW9uLCBvcHRfZGlyZWN0aW9uKSB7XG4gICAgY29uc3QgeiA9IGxpbmVhckZpbmROZWFyZXN0KFxuICAgICAgdGhpcy5yZXNvbHV0aW9uc18sXG4gICAgICByZXNvbHV0aW9uLFxuICAgICAgb3B0X2RpcmVjdGlvbiB8fCAwXG4gICAgKTtcbiAgICByZXR1cm4gY2xhbXAoeiwgdGhpcy5taW5ab29tLCB0aGlzLm1heFpvb20pO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSB0aWxlIHdpdGggdGhlIHByb3ZpZGVkIHRpbGUgY29vcmRpbmF0ZSBpbnRlcnNlY3RzIHRoZSBnaXZlbiB2aWV3cG9ydC5cbiAgICogQHBhcmFtIHtpbXBvcnQoJy4uL3RpbGVjb29yZC5qcycpLlRpbGVDb29yZH0gdGlsZUNvb3JkIFRpbGUgY29vcmRpbmF0ZS5cbiAgICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSB2aWV3cG9ydCBWaWV3cG9ydCBhcyByZXR1cm5lZCBmcm9tIHtAbGluayBtb2R1bGU6b2wvZXh0ZW50LmdldFJvdGF0ZWRWaWV3cG9ydH0uXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSB0aWxlIHdpdGggdGhlIHByb3ZpZGVkIHRpbGUgY29vcmRpbmF0ZSBpbnRlcnNlY3RzIHRoZSBnaXZlbiB2aWV3cG9ydC5cbiAgICovXG4gIHRpbGVDb29yZEludGVyc2VjdHNWaWV3cG9ydCh0aWxlQ29vcmQsIHZpZXdwb3J0KSB7XG4gICAgcmV0dXJuIGludGVyc2VjdHNMaW5lYXJSaW5nKFxuICAgICAgdmlld3BvcnQsXG4gICAgICAwLFxuICAgICAgdmlld3BvcnQubGVuZ3RoLFxuICAgICAgMixcbiAgICAgIHRoaXMuZ2V0VGlsZUNvb3JkRXh0ZW50KHRpbGVDb29yZClcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IWltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IGV4dGVudCBFeHRlbnQgZm9yIHRoaXMgdGlsZSBncmlkLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY2FsY3VsYXRlVGlsZVJhbmdlc18oZXh0ZW50KSB7XG4gICAgY29uc3QgbGVuZ3RoID0gdGhpcy5yZXNvbHV0aW9uc18ubGVuZ3RoO1xuICAgIGNvbnN0IGZ1bGxUaWxlUmFuZ2VzID0gbmV3IEFycmF5KGxlbmd0aCk7XG4gICAgZm9yIChsZXQgeiA9IHRoaXMubWluWm9vbTsgeiA8IGxlbmd0aDsgKyt6KSB7XG4gICAgICBmdWxsVGlsZVJhbmdlc1t6XSA9IHRoaXMuZ2V0VGlsZVJhbmdlRm9yRXh0ZW50QW5kWihleHRlbnQsIHopO1xuICAgIH1cbiAgICB0aGlzLmZ1bGxUaWxlUmFuZ2VzXyA9IGZ1bGxUaWxlUmFuZ2VzO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFRpbGVHcmlkO1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3RpbGVncmlkL2NvbW1vblxuICovXG5cbi8qKlxuICogRGVmYXVsdCBtYXhpbXVtIHpvb20gZm9yIGRlZmF1bHQgdGlsZSBncmlkcy5cbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCBERUZBVUxUX01BWF9aT09NID0gNDI7XG5cbi8qKlxuICogRGVmYXVsdCB0aWxlIHNpemUuXG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5leHBvcnQgY29uc3QgREVGQVVMVF9USUxFX1NJWkUgPSAyNTY7XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvdGlsZXVybGZ1bmN0aW9uXG4gKi9cbmltcG9ydCB7YXNzZXJ0fSBmcm9tICcuL2Fzc2VydHMuanMnO1xuaW1wb3J0IHttb2R1bG99IGZyb20gJy4vbWF0aC5qcyc7XG5pbXBvcnQge2hhc2ggYXMgdGlsZUNvb3JkSGFzaH0gZnJvbSAnLi90aWxlY29vcmQuanMnO1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZW1wbGF0ZSBUZW1wbGF0ZS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi90aWxlZ3JpZC9UaWxlR3JpZC5qc1wiKS5kZWZhdWx0fSB0aWxlR3JpZCBUaWxlIGdyaWQuXG4gKiBAcmV0dXJuIHtpbXBvcnQoXCIuL1RpbGUuanNcIikuVXJsRnVuY3Rpb259IFRpbGUgVVJMIGZ1bmN0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRnJvbVRlbXBsYXRlKHRlbXBsYXRlLCB0aWxlR3JpZCkge1xuICBjb25zdCB6UmVnRXggPSAvXFx7elxcfS9nO1xuICBjb25zdCB4UmVnRXggPSAvXFx7eFxcfS9nO1xuICBjb25zdCB5UmVnRXggPSAvXFx7eVxcfS9nO1xuICBjb25zdCBkYXNoWVJlZ0V4ID0gL1xcey15XFx9L2c7XG4gIHJldHVybiAoXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtpbXBvcnQoXCIuL3RpbGVjb29yZC5qc1wiKS5UaWxlQ29vcmR9IHRpbGVDb29yZCBUaWxlIENvb3JkaW5hdGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBpeGVsUmF0aW8gUGl4ZWwgcmF0aW8uXG4gICAgICogQHBhcmFtIHtpbXBvcnQoXCIuL3Byb2ovUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0fSBwcm9qZWN0aW9uIFByb2plY3Rpb24uXG4gICAgICogQHJldHVybiB7c3RyaW5nfHVuZGVmaW5lZH0gVGlsZSBVUkwuXG4gICAgICovXG4gICAgZnVuY3Rpb24gKHRpbGVDb29yZCwgcGl4ZWxSYXRpbywgcHJvamVjdGlvbikge1xuICAgICAgaWYgKCF0aWxlQ29vcmQpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0ZW1wbGF0ZVxuICAgICAgICAucmVwbGFjZSh6UmVnRXgsIHRpbGVDb29yZFswXS50b1N0cmluZygpKVxuICAgICAgICAucmVwbGFjZSh4UmVnRXgsIHRpbGVDb29yZFsxXS50b1N0cmluZygpKVxuICAgICAgICAucmVwbGFjZSh5UmVnRXgsIHRpbGVDb29yZFsyXS50b1N0cmluZygpKVxuICAgICAgICAucmVwbGFjZShkYXNoWVJlZ0V4LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgY29uc3QgeiA9IHRpbGVDb29yZFswXTtcbiAgICAgICAgICBjb25zdCByYW5nZSA9IHRpbGVHcmlkLmdldEZ1bGxUaWxlUmFuZ2Uoeik7XG4gICAgICAgICAgYXNzZXJ0KFxuICAgICAgICAgICAgcmFuZ2UsXG4gICAgICAgICAgICAnVGhlIHsteX0gcGxhY2Vob2xkZXIgcmVxdWlyZXMgYSB0aWxlIGdyaWQgd2l0aCBleHRlbnQnXG4gICAgICAgICAgKTtcbiAgICAgICAgICBjb25zdCB5ID0gcmFuZ2UuZ2V0SGVpZ2h0KCkgLSB0aWxlQ29vcmRbMl0gLSAxO1xuICAgICAgICAgIHJldHVybiB5LnRvU3RyaW5nKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IHRlbXBsYXRlcyBUZW1wbGF0ZXMuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vdGlsZWdyaWQvVGlsZUdyaWQuanNcIikuZGVmYXVsdH0gdGlsZUdyaWQgVGlsZSBncmlkLlxuICogQHJldHVybiB7aW1wb3J0KFwiLi9UaWxlLmpzXCIpLlVybEZ1bmN0aW9ufSBUaWxlIFVSTCBmdW5jdGlvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUZyb21UZW1wbGF0ZXModGVtcGxhdGVzLCB0aWxlR3JpZCkge1xuICBjb25zdCBsZW4gPSB0ZW1wbGF0ZXMubGVuZ3RoO1xuICBjb25zdCB0aWxlVXJsRnVuY3Rpb25zID0gbmV3IEFycmF5KGxlbik7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICB0aWxlVXJsRnVuY3Rpb25zW2ldID0gY3JlYXRlRnJvbVRlbXBsYXRlKHRlbXBsYXRlc1tpXSwgdGlsZUdyaWQpO1xuICB9XG4gIHJldHVybiBjcmVhdGVGcm9tVGlsZVVybEZ1bmN0aW9ucyh0aWxlVXJsRnVuY3Rpb25zKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PGltcG9ydChcIi4vVGlsZS5qc1wiKS5VcmxGdW5jdGlvbj59IHRpbGVVcmxGdW5jdGlvbnMgVGlsZSBVUkwgRnVuY3Rpb25zLlxuICogQHJldHVybiB7aW1wb3J0KFwiLi9UaWxlLmpzXCIpLlVybEZ1bmN0aW9ufSBUaWxlIFVSTCBmdW5jdGlvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUZyb21UaWxlVXJsRnVuY3Rpb25zKHRpbGVVcmxGdW5jdGlvbnMpIHtcbiAgaWYgKHRpbGVVcmxGdW5jdGlvbnMubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIHRpbGVVcmxGdW5jdGlvbnNbMF07XG4gIH1cbiAgcmV0dXJuIChcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vdGlsZWNvb3JkLmpzXCIpLlRpbGVDb29yZH0gdGlsZUNvb3JkIFRpbGUgQ29vcmRpbmF0ZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcGl4ZWxSYXRpbyBQaXhlbCByYXRpby5cbiAgICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vcHJvai9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR9IHByb2plY3Rpb24gUHJvamVjdGlvbi5cbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd8dW5kZWZpbmVkfSBUaWxlIFVSTC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAodGlsZUNvb3JkLCBwaXhlbFJhdGlvLCBwcm9qZWN0aW9uKSB7XG4gICAgICBpZiAoIXRpbGVDb29yZCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgY29uc3QgaCA9IHRpbGVDb29yZEhhc2godGlsZUNvb3JkKTtcbiAgICAgIGNvbnN0IGluZGV4ID0gbW9kdWxvKGgsIHRpbGVVcmxGdW5jdGlvbnMubGVuZ3RoKTtcbiAgICAgIHJldHVybiB0aWxlVXJsRnVuY3Rpb25zW2luZGV4XSh0aWxlQ29vcmQsIHBpeGVsUmF0aW8sIHByb2plY3Rpb24pO1xuICAgIH1cbiAgKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vdGlsZWNvb3JkLmpzXCIpLlRpbGVDb29yZH0gdGlsZUNvb3JkIFRpbGUgY29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBwaXhlbFJhdGlvIFBpeGVsIHJhdGlvLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL3Byb2ovUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0fSBwcm9qZWN0aW9uIFByb2plY3Rpb24uXG4gKiBAcmV0dXJuIHtzdHJpbmd8dW5kZWZpbmVkfSBUaWxlIFVSTC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG51bGxUaWxlVXJsRnVuY3Rpb24odGlsZUNvb3JkLCBwaXhlbFJhdGlvLCBwcm9qZWN0aW9uKSB7XG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHVybCBVUkwuXG4gKiBAcmV0dXJuIHtBcnJheTxzdHJpbmc+fSBBcnJheSBvZiB1cmxzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZXhwYW5kVXJsKHVybCkge1xuICBjb25zdCB1cmxzID0gW107XG4gIGxldCBtYXRjaCA9IC9cXHsoW2Etel0pLShbYS16XSlcXH0vLmV4ZWModXJsKTtcbiAgaWYgKG1hdGNoKSB7XG4gICAgLy8gY2hhciByYW5nZVxuICAgIGNvbnN0IHN0YXJ0Q2hhckNvZGUgPSBtYXRjaFsxXS5jaGFyQ29kZUF0KDApO1xuICAgIGNvbnN0IHN0b3BDaGFyQ29kZSA9IG1hdGNoWzJdLmNoYXJDb2RlQXQoMCk7XG4gICAgbGV0IGNoYXJDb2RlO1xuICAgIGZvciAoY2hhckNvZGUgPSBzdGFydENoYXJDb2RlOyBjaGFyQ29kZSA8PSBzdG9wQ2hhckNvZGU7ICsrY2hhckNvZGUpIHtcbiAgICAgIHVybHMucHVzaCh1cmwucmVwbGFjZShtYXRjaFswXSwgU3RyaW5nLmZyb21DaGFyQ29kZShjaGFyQ29kZSkpKTtcbiAgICB9XG4gICAgcmV0dXJuIHVybHM7XG4gIH1cbiAgbWF0Y2ggPSAvXFx7KFxcZCspLShcXGQrKVxcfS8uZXhlYyh1cmwpO1xuICBpZiAobWF0Y2gpIHtcbiAgICAvLyBudW1iZXIgcmFuZ2VcbiAgICBjb25zdCBzdG9wID0gcGFyc2VJbnQobWF0Y2hbMl0sIDEwKTtcbiAgICBmb3IgKGxldCBpID0gcGFyc2VJbnQobWF0Y2hbMV0sIDEwKTsgaSA8PSBzdG9wOyBpKyspIHtcbiAgICAgIHVybHMucHVzaCh1cmwucmVwbGFjZShtYXRjaFswXSwgaS50b1N0cmluZygpKSk7XG4gICAgfVxuICAgIHJldHVybiB1cmxzO1xuICB9XG4gIHVybHMucHVzaCh1cmwpO1xuICByZXR1cm4gdXJscztcbn1cbiIsIi8qKlxuICogQG1vZHVsZSBvbC90cmFuc2Zvcm1cbiAqL1xuaW1wb3J0IHtXT1JLRVJfT0ZGU0NSRUVOX0NBTlZBU30gZnJvbSAnLi9oYXMuanMnO1xuaW1wb3J0IHthc3NlcnR9IGZyb20gJy4vYXNzZXJ0cy5qcyc7XG5cbi8qKlxuICogQW4gYXJyYXkgcmVwcmVzZW50aW5nIGFuIGFmZmluZSAyZCB0cmFuc2Zvcm1hdGlvbiBmb3IgdXNlIHdpdGhcbiAqIHtAbGluayBtb2R1bGU6b2wvdHJhbnNmb3JtfSBmdW5jdGlvbnMuIFRoZSBhcnJheSBoYXMgNiBlbGVtZW50cy5cbiAqIEB0eXBlZGVmIHshQXJyYXk8bnVtYmVyPn0gVHJhbnNmb3JtXG4gKiBAYXBpXG4gKi9cblxuLyoqXG4gKiBDb2xsZWN0aW9uIG9mIGFmZmluZSAyZCB0cmFuc2Zvcm1hdGlvbiBmdW5jdGlvbnMuIFRoZSBmdW5jdGlvbnMgd29yayBvbiBhblxuICogYXJyYXkgb2YgNiBlbGVtZW50cy4gVGhlIGVsZW1lbnQgb3JkZXIgaXMgY29tcGF0aWJsZSB3aXRoIHRoZSBbU1ZHTWF0cml4XG4gKiBpbnRlcmZhY2VdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9TVkdNYXRyaXgpIGFuZCBpc1xuICogYSBzdWJzZXQgKGVsZW1lbnRzIGEgdG8gZikgb2YgYSAzw5czIG1hdHJpeDpcbiAqIGBgYFxuICogWyBhIGMgZSBdXG4gKiBbIGIgZCBmIF1cbiAqIFsgMCAwIDEgXVxuICogYGBgXG4gKi9cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQHR5cGUge1RyYW5zZm9ybX1cbiAqL1xuY29uc3QgdG1wXyA9IG5ldyBBcnJheSg2KTtcblxuLyoqXG4gKiBDcmVhdGUgYW4gaWRlbnRpdHkgdHJhbnNmb3JtLlxuICogQHJldHVybiB7IVRyYW5zZm9ybX0gSWRlbnRpdHkgdHJhbnNmb3JtLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlKCkge1xuICByZXR1cm4gWzEsIDAsIDAsIDEsIDAsIDBdO1xufVxuXG4vKipcbiAqIFJlc2V0cyB0aGUgZ2l2ZW4gdHJhbnNmb3JtIHRvIGFuIGlkZW50aXR5IHRyYW5zZm9ybS5cbiAqIEBwYXJhbSB7IVRyYW5zZm9ybX0gdHJhbnNmb3JtIFRyYW5zZm9ybS5cbiAqIEByZXR1cm4geyFUcmFuc2Zvcm19IFRyYW5zZm9ybS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlc2V0KHRyYW5zZm9ybSkge1xuICByZXR1cm4gc2V0KHRyYW5zZm9ybSwgMSwgMCwgMCwgMSwgMCwgMCk7XG59XG5cbi8qKlxuICogTXVsdGlwbHkgdGhlIHVuZGVybHlpbmcgbWF0cmljZXMgb2YgdHdvIHRyYW5zZm9ybXMgYW5kIHJldHVybiB0aGUgcmVzdWx0IGluXG4gKiB0aGUgZmlyc3QgdHJhbnNmb3JtLlxuICogQHBhcmFtIHshVHJhbnNmb3JtfSB0cmFuc2Zvcm0xIFRyYW5zZm9ybSBwYXJhbWV0ZXJzIG9mIG1hdHJpeCAxLlxuICogQHBhcmFtIHshVHJhbnNmb3JtfSB0cmFuc2Zvcm0yIFRyYW5zZm9ybSBwYXJhbWV0ZXJzIG9mIG1hdHJpeCAyLlxuICogQHJldHVybiB7IVRyYW5zZm9ybX0gdHJhbnNmb3JtMSBtdWx0aXBsaWVkIHdpdGggdHJhbnNmb3JtMi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG11bHRpcGx5KHRyYW5zZm9ybTEsIHRyYW5zZm9ybTIpIHtcbiAgY29uc3QgYTEgPSB0cmFuc2Zvcm0xWzBdO1xuICBjb25zdCBiMSA9IHRyYW5zZm9ybTFbMV07XG4gIGNvbnN0IGMxID0gdHJhbnNmb3JtMVsyXTtcbiAgY29uc3QgZDEgPSB0cmFuc2Zvcm0xWzNdO1xuICBjb25zdCBlMSA9IHRyYW5zZm9ybTFbNF07XG4gIGNvbnN0IGYxID0gdHJhbnNmb3JtMVs1XTtcbiAgY29uc3QgYTIgPSB0cmFuc2Zvcm0yWzBdO1xuICBjb25zdCBiMiA9IHRyYW5zZm9ybTJbMV07XG4gIGNvbnN0IGMyID0gdHJhbnNmb3JtMlsyXTtcbiAgY29uc3QgZDIgPSB0cmFuc2Zvcm0yWzNdO1xuICBjb25zdCBlMiA9IHRyYW5zZm9ybTJbNF07XG4gIGNvbnN0IGYyID0gdHJhbnNmb3JtMls1XTtcblxuICB0cmFuc2Zvcm0xWzBdID0gYTEgKiBhMiArIGMxICogYjI7XG4gIHRyYW5zZm9ybTFbMV0gPSBiMSAqIGEyICsgZDEgKiBiMjtcbiAgdHJhbnNmb3JtMVsyXSA9IGExICogYzIgKyBjMSAqIGQyO1xuICB0cmFuc2Zvcm0xWzNdID0gYjEgKiBjMiArIGQxICogZDI7XG4gIHRyYW5zZm9ybTFbNF0gPSBhMSAqIGUyICsgYzEgKiBmMiArIGUxO1xuICB0cmFuc2Zvcm0xWzVdID0gYjEgKiBlMiArIGQxICogZjIgKyBmMTtcblxuICByZXR1cm4gdHJhbnNmb3JtMTtcbn1cblxuLyoqXG4gKiBTZXQgdGhlIHRyYW5zZm9ybSBjb21wb25lbnRzIGEtZiBvbiBhIGdpdmVuIHRyYW5zZm9ybS5cbiAqIEBwYXJhbSB7IVRyYW5zZm9ybX0gdHJhbnNmb3JtIFRyYW5zZm9ybS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBhIFRoZSBhIGNvbXBvbmVudCBvZiB0aGUgdHJhbnNmb3JtLlxuICogQHBhcmFtIHtudW1iZXJ9IGIgVGhlIGIgY29tcG9uZW50IG9mIHRoZSB0cmFuc2Zvcm0uXG4gKiBAcGFyYW0ge251bWJlcn0gYyBUaGUgYyBjb21wb25lbnQgb2YgdGhlIHRyYW5zZm9ybS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBkIFRoZSBkIGNvbXBvbmVudCBvZiB0aGUgdHJhbnNmb3JtLlxuICogQHBhcmFtIHtudW1iZXJ9IGUgVGhlIGUgY29tcG9uZW50IG9mIHRoZSB0cmFuc2Zvcm0uXG4gKiBAcGFyYW0ge251bWJlcn0gZiBUaGUgZiBjb21wb25lbnQgb2YgdGhlIHRyYW5zZm9ybS5cbiAqIEByZXR1cm4geyFUcmFuc2Zvcm19IE1hdHJpeCB3aXRoIHRyYW5zZm9ybSBhcHBsaWVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0KHRyYW5zZm9ybSwgYSwgYiwgYywgZCwgZSwgZikge1xuICB0cmFuc2Zvcm1bMF0gPSBhO1xuICB0cmFuc2Zvcm1bMV0gPSBiO1xuICB0cmFuc2Zvcm1bMl0gPSBjO1xuICB0cmFuc2Zvcm1bM10gPSBkO1xuICB0cmFuc2Zvcm1bNF0gPSBlO1xuICB0cmFuc2Zvcm1bNV0gPSBmO1xuICByZXR1cm4gdHJhbnNmb3JtO1xufVxuXG4vKipcbiAqIFNldCB0cmFuc2Zvcm0gb24gb25lIG1hdHJpeCBmcm9tIGFub3RoZXIgbWF0cml4LlxuICogQHBhcmFtIHshVHJhbnNmb3JtfSB0cmFuc2Zvcm0xIE1hdHJpeCB0byBzZXQgdHJhbnNmb3JtIHRvLlxuICogQHBhcmFtIHshVHJhbnNmb3JtfSB0cmFuc2Zvcm0yIE1hdHJpeCB0byBzZXQgdHJhbnNmb3JtIGZyb20uXG4gKiBAcmV0dXJuIHshVHJhbnNmb3JtfSB0cmFuc2Zvcm0xIHdpdGggdHJhbnNmb3JtIGZyb20gdHJhbnNmb3JtMiBhcHBsaWVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0RnJvbUFycmF5KHRyYW5zZm9ybTEsIHRyYW5zZm9ybTIpIHtcbiAgdHJhbnNmb3JtMVswXSA9IHRyYW5zZm9ybTJbMF07XG4gIHRyYW5zZm9ybTFbMV0gPSB0cmFuc2Zvcm0yWzFdO1xuICB0cmFuc2Zvcm0xWzJdID0gdHJhbnNmb3JtMlsyXTtcbiAgdHJhbnNmb3JtMVszXSA9IHRyYW5zZm9ybTJbM107XG4gIHRyYW5zZm9ybTFbNF0gPSB0cmFuc2Zvcm0yWzRdO1xuICB0cmFuc2Zvcm0xWzVdID0gdHJhbnNmb3JtMls1XTtcbiAgcmV0dXJuIHRyYW5zZm9ybTE7XG59XG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgZ2l2ZW4gY29vcmRpbmF0ZSB3aXRoIHRoZSBnaXZlbiB0cmFuc2Zvcm0gcmV0dXJuaW5nIHRoZVxuICogcmVzdWx0aW5nLCB0cmFuc2Zvcm1lZCBjb29yZGluYXRlLiBUaGUgY29vcmRpbmF0ZSB3aWxsIGJlIG1vZGlmaWVkIGluLXBsYWNlLlxuICpcbiAqIEBwYXJhbSB7VHJhbnNmb3JtfSB0cmFuc2Zvcm0gVGhlIHRyYW5zZm9ybWF0aW9uLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZXxpbXBvcnQoXCIuL3BpeGVsLmpzXCIpLlBpeGVsfSBjb29yZGluYXRlIFRoZSBjb29yZGluYXRlIHRvIHRyYW5zZm9ybS5cbiAqIEByZXR1cm4ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfGltcG9ydChcIi4vcGl4ZWwuanNcIikuUGl4ZWx9IHJldHVybiBjb29yZGluYXRlIHNvIHRoYXQgb3BlcmF0aW9ucyBjYW4gYmVcbiAqICAgICBjaGFpbmVkIHRvZ2V0aGVyLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYXBwbHkodHJhbnNmb3JtLCBjb29yZGluYXRlKSB7XG4gIGNvbnN0IHggPSBjb29yZGluYXRlWzBdO1xuICBjb25zdCB5ID0gY29vcmRpbmF0ZVsxXTtcbiAgY29vcmRpbmF0ZVswXSA9IHRyYW5zZm9ybVswXSAqIHggKyB0cmFuc2Zvcm1bMl0gKiB5ICsgdHJhbnNmb3JtWzRdO1xuICBjb29yZGluYXRlWzFdID0gdHJhbnNmb3JtWzFdICogeCArIHRyYW5zZm9ybVszXSAqIHkgKyB0cmFuc2Zvcm1bNV07XG4gIHJldHVybiBjb29yZGluYXRlO1xufVxuXG4vKipcbiAqIEFwcGxpZXMgcm90YXRpb24gdG8gdGhlIGdpdmVuIHRyYW5zZm9ybS5cbiAqIEBwYXJhbSB7IVRyYW5zZm9ybX0gdHJhbnNmb3JtIFRyYW5zZm9ybS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZSBBbmdsZSBpbiByYWRpYW5zLlxuICogQHJldHVybiB7IVRyYW5zZm9ybX0gVGhlIHJvdGF0ZWQgdHJhbnNmb3JtLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcm90YXRlKHRyYW5zZm9ybSwgYW5nbGUpIHtcbiAgY29uc3QgY29zID0gTWF0aC5jb3MoYW5nbGUpO1xuICBjb25zdCBzaW4gPSBNYXRoLnNpbihhbmdsZSk7XG4gIHJldHVybiBtdWx0aXBseSh0cmFuc2Zvcm0sIHNldCh0bXBfLCBjb3MsIHNpbiwgLXNpbiwgY29zLCAwLCAwKSk7XG59XG5cbi8qKlxuICogQXBwbGllcyBzY2FsZSB0byBhIGdpdmVuIHRyYW5zZm9ybS5cbiAqIEBwYXJhbSB7IVRyYW5zZm9ybX0gdHJhbnNmb3JtIFRyYW5zZm9ybS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB4IFNjYWxlIGZhY3RvciB4LlxuICogQHBhcmFtIHtudW1iZXJ9IHkgU2NhbGUgZmFjdG9yIHkuXG4gKiBAcmV0dXJuIHshVHJhbnNmb3JtfSBUaGUgc2NhbGVkIHRyYW5zZm9ybS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNjYWxlKHRyYW5zZm9ybSwgeCwgeSkge1xuICByZXR1cm4gbXVsdGlwbHkodHJhbnNmb3JtLCBzZXQodG1wXywgeCwgMCwgMCwgeSwgMCwgMCkpO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBzY2FsZSB0cmFuc2Zvcm0uXG4gKiBAcGFyYW0geyFUcmFuc2Zvcm19IHRhcmdldCBUcmFuc2Zvcm0gdG8gb3ZlcndyaXRlLlxuICogQHBhcmFtIHtudW1iZXJ9IHggU2NhbGUgZmFjdG9yIHguXG4gKiBAcGFyYW0ge251bWJlcn0geSBTY2FsZSBmYWN0b3IgeS5cbiAqIEByZXR1cm4geyFUcmFuc2Zvcm19IFRoZSBzY2FsZSB0cmFuc2Zvcm0uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYWtlU2NhbGUodGFyZ2V0LCB4LCB5KSB7XG4gIHJldHVybiBzZXQodGFyZ2V0LCB4LCAwLCAwLCB5LCAwLCAwKTtcbn1cblxuLyoqXG4gKiBBcHBsaWVzIHRyYW5zbGF0aW9uIHRvIHRoZSBnaXZlbiB0cmFuc2Zvcm0uXG4gKiBAcGFyYW0geyFUcmFuc2Zvcm19IHRyYW5zZm9ybSBUcmFuc2Zvcm0uXG4gKiBAcGFyYW0ge251bWJlcn0gZHggVHJhbnNsYXRpb24geC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBkeSBUcmFuc2xhdGlvbiB5LlxuICogQHJldHVybiB7IVRyYW5zZm9ybX0gVGhlIHRyYW5zbGF0ZWQgdHJhbnNmb3JtLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNsYXRlKHRyYW5zZm9ybSwgZHgsIGR5KSB7XG4gIHJldHVybiBtdWx0aXBseSh0cmFuc2Zvcm0sIHNldCh0bXBfLCAxLCAwLCAwLCAxLCBkeCwgZHkpKTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgY29tcG9zaXRlIHRyYW5zZm9ybSBnaXZlbiBhbiBpbml0aWFsIHRyYW5zbGF0aW9uLCBzY2FsZSwgcm90YXRpb24sIGFuZFxuICogZmluYWwgdHJhbnNsYXRpb24gKGluIHRoYXQgb3JkZXIgb25seSwgbm90IGNvbW11dGF0aXZlKS5cbiAqIEBwYXJhbSB7IVRyYW5zZm9ybX0gdHJhbnNmb3JtIFRoZSB0cmFuc2Zvcm0gKHdpbGwgYmUgbW9kaWZpZWQgaW4gcGxhY2UpLlxuICogQHBhcmFtIHtudW1iZXJ9IGR4MSBJbml0aWFsIHRyYW5zbGF0aW9uIHguXG4gKiBAcGFyYW0ge251bWJlcn0gZHkxIEluaXRpYWwgdHJhbnNsYXRpb24geS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzeCBTY2FsZSBmYWN0b3IgeC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzeSBTY2FsZSBmYWN0b3IgeS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZSBSb3RhdGlvbiAoaW4gY291bnRlci1jbG9ja3dpc2UgcmFkaWFucykuXG4gKiBAcGFyYW0ge251bWJlcn0gZHgyIEZpbmFsIHRyYW5zbGF0aW9uIHguXG4gKiBAcGFyYW0ge251bWJlcn0gZHkyIEZpbmFsIHRyYW5zbGF0aW9uIHkuXG4gKiBAcmV0dXJuIHshVHJhbnNmb3JtfSBUaGUgY29tcG9zaXRlIHRyYW5zZm9ybS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbXBvc2UodHJhbnNmb3JtLCBkeDEsIGR5MSwgc3gsIHN5LCBhbmdsZSwgZHgyLCBkeTIpIHtcbiAgY29uc3Qgc2luID0gTWF0aC5zaW4oYW5nbGUpO1xuICBjb25zdCBjb3MgPSBNYXRoLmNvcyhhbmdsZSk7XG4gIHRyYW5zZm9ybVswXSA9IHN4ICogY29zO1xuICB0cmFuc2Zvcm1bMV0gPSBzeSAqIHNpbjtcbiAgdHJhbnNmb3JtWzJdID0gLXN4ICogc2luO1xuICB0cmFuc2Zvcm1bM10gPSBzeSAqIGNvcztcbiAgdHJhbnNmb3JtWzRdID0gZHgyICogc3ggKiBjb3MgLSBkeTIgKiBzeCAqIHNpbiArIGR4MTtcbiAgdHJhbnNmb3JtWzVdID0gZHgyICogc3kgKiBzaW4gKyBkeTIgKiBzeSAqIGNvcyArIGR5MTtcbiAgcmV0dXJuIHRyYW5zZm9ybTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgY29tcG9zaXRlIHRyYW5zZm9ybSBnaXZlbiBhbiBpbml0aWFsIHRyYW5zbGF0aW9uLCBzY2FsZSwgcm90YXRpb24sIGFuZFxuICogZmluYWwgdHJhbnNsYXRpb24gKGluIHRoYXQgb3JkZXIgb25seSwgbm90IGNvbW11dGF0aXZlKS4gVGhlIHJlc3VsdGluZyB0cmFuc2Zvcm1cbiAqIHN0cmluZyBjYW4gYmUgYXBwbGllZCBhcyBgdHJhbnNmb3JtYCBwcm9wZXJ0eSBvZiBhbiBIVE1MRWxlbWVudCdzIHN0eWxlLlxuICogQHBhcmFtIHtudW1iZXJ9IGR4MSBJbml0aWFsIHRyYW5zbGF0aW9uIHguXG4gKiBAcGFyYW0ge251bWJlcn0gZHkxIEluaXRpYWwgdHJhbnNsYXRpb24geS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzeCBTY2FsZSBmYWN0b3IgeC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzeSBTY2FsZSBmYWN0b3IgeS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZSBSb3RhdGlvbiAoaW4gY291bnRlci1jbG9ja3dpc2UgcmFkaWFucykuXG4gKiBAcGFyYW0ge251bWJlcn0gZHgyIEZpbmFsIHRyYW5zbGF0aW9uIHguXG4gKiBAcGFyYW0ge251bWJlcn0gZHkyIEZpbmFsIHRyYW5zbGF0aW9uIHkuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBjb21wb3NpdGUgY3NzIHRyYW5zZm9ybS5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbXBvc2VDc3NUcmFuc2Zvcm0oZHgxLCBkeTEsIHN4LCBzeSwgYW5nbGUsIGR4MiwgZHkyKSB7XG4gIHJldHVybiB0b1N0cmluZyhjb21wb3NlKGNyZWF0ZSgpLCBkeDEsIGR5MSwgc3gsIHN5LCBhbmdsZSwgZHgyLCBkeTIpKTtcbn1cblxuLyoqXG4gKiBJbnZlcnQgdGhlIGdpdmVuIHRyYW5zZm9ybS5cbiAqIEBwYXJhbSB7IVRyYW5zZm9ybX0gc291cmNlIFRoZSBzb3VyY2UgdHJhbnNmb3JtIHRvIGludmVydC5cbiAqIEByZXR1cm4geyFUcmFuc2Zvcm19IFRoZSBpbnZlcnRlZCAoc291cmNlKSB0cmFuc2Zvcm0uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnZlcnQoc291cmNlKSB7XG4gIHJldHVybiBtYWtlSW52ZXJzZShzb3VyY2UsIHNvdXJjZSk7XG59XG5cbi8qKlxuICogSW52ZXJ0IHRoZSBnaXZlbiB0cmFuc2Zvcm0uXG4gKiBAcGFyYW0geyFUcmFuc2Zvcm19IHRhcmdldCBUcmFuc2Zvcm0gdG8gYmUgc2V0IGFzIHRoZSBpbnZlcnNlIG9mXG4gKiAgICAgdGhlIHNvdXJjZSB0cmFuc2Zvcm0uXG4gKiBAcGFyYW0geyFUcmFuc2Zvcm19IHNvdXJjZSBUaGUgc291cmNlIHRyYW5zZm9ybSB0byBpbnZlcnQuXG4gKiBAcmV0dXJuIHshVHJhbnNmb3JtfSBUaGUgaW52ZXJ0ZWQgKHRhcmdldCkgdHJhbnNmb3JtLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbWFrZUludmVyc2UodGFyZ2V0LCBzb3VyY2UpIHtcbiAgY29uc3QgZGV0ID0gZGV0ZXJtaW5hbnQoc291cmNlKTtcbiAgYXNzZXJ0KGRldCAhPT0gMCwgJ1RyYW5zZm9ybWF0aW9uIG1hdHJpeCBjYW5ub3QgYmUgaW52ZXJ0ZWQnKTtcblxuICBjb25zdCBhID0gc291cmNlWzBdO1xuICBjb25zdCBiID0gc291cmNlWzFdO1xuICBjb25zdCBjID0gc291cmNlWzJdO1xuICBjb25zdCBkID0gc291cmNlWzNdO1xuICBjb25zdCBlID0gc291cmNlWzRdO1xuICBjb25zdCBmID0gc291cmNlWzVdO1xuXG4gIHRhcmdldFswXSA9IGQgLyBkZXQ7XG4gIHRhcmdldFsxXSA9IC1iIC8gZGV0O1xuICB0YXJnZXRbMl0gPSAtYyAvIGRldDtcbiAgdGFyZ2V0WzNdID0gYSAvIGRldDtcbiAgdGFyZ2V0WzRdID0gKGMgKiBmIC0gZCAqIGUpIC8gZGV0O1xuICB0YXJnZXRbNV0gPSAtKGEgKiBmIC0gYiAqIGUpIC8gZGV0O1xuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZGV0ZXJtaW5hbnQgb2YgdGhlIGdpdmVuIG1hdHJpeC5cbiAqIEBwYXJhbSB7IVRyYW5zZm9ybX0gbWF0IE1hdHJpeC5cbiAqIEByZXR1cm4ge251bWJlcn0gRGV0ZXJtaW5hbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZXRlcm1pbmFudChtYXQpIHtcbiAgcmV0dXJuIG1hdFswXSAqIG1hdFszXSAtIG1hdFsxXSAqIG1hdFsyXTtcbn1cblxuLyoqXG4gKiBAdHlwZSB7SFRNTEVsZW1lbnR9XG4gKiBAcHJpdmF0ZVxuICovXG5sZXQgdHJhbnNmb3JtU3RyaW5nRGl2O1xuXG4vKipcbiAqIEEgcm91bmRlZCBzdHJpbmcgdmVyc2lvbiBvZiB0aGUgdHJhbnNmb3JtLiAgVGhpcyBjYW4gYmUgdXNlZFxuICogZm9yIENTUyB0cmFuc2Zvcm1zLlxuICogQHBhcmFtIHshVHJhbnNmb3JtfSBtYXQgTWF0cml4LlxuICogQHJldHVybiB7c3RyaW5nfSBUaGUgdHJhbnNmb3JtIGFzIGEgc3RyaW5nLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9TdHJpbmcobWF0KSB7XG4gIGNvbnN0IHRyYW5zZm9ybVN0cmluZyA9ICdtYXRyaXgoJyArIG1hdC5qb2luKCcsICcpICsgJyknO1xuICBpZiAoV09SS0VSX09GRlNDUkVFTl9DQU5WQVMpIHtcbiAgICByZXR1cm4gdHJhbnNmb3JtU3RyaW5nO1xuICB9XG4gIGNvbnN0IG5vZGUgPVxuICAgIHRyYW5zZm9ybVN0cmluZ0RpdiB8fCAodHJhbnNmb3JtU3RyaW5nRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JykpO1xuICBub2RlLnN0eWxlLnRyYW5zZm9ybSA9IHRyYW5zZm9ybVN0cmluZztcbiAgcmV0dXJuIG5vZGUuc3R5bGUudHJhbnNmb3JtO1xufVxuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3V0aWxcbiAqL1xuXG4vKipcbiAqIEByZXR1cm4ge25ldmVyfSBBbnkgcmV0dXJuLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYWJzdHJhY3QoKSB7XG4gIHRocm93IG5ldyBFcnJvcignVW5pbXBsZW1lbnRlZCBhYnN0cmFjdCBtZXRob2QuJyk7XG59XG5cbi8qKlxuICogQ291bnRlciBmb3IgZ2V0VWlkLlxuICogQHR5cGUge251bWJlcn1cbiAqIEBwcml2YXRlXG4gKi9cbmxldCB1aWRDb3VudGVyXyA9IDA7XG5cbi8qKlxuICogR2V0cyBhIHVuaXF1ZSBJRCBmb3IgYW4gb2JqZWN0LiBUaGlzIG11dGF0ZXMgdGhlIG9iamVjdCBzbyB0aGF0IGZ1cnRoZXIgY2FsbHNcbiAqIHdpdGggdGhlIHNhbWUgb2JqZWN0IGFzIGEgcGFyYW1ldGVyIHJldHVybnMgdGhlIHNhbWUgdmFsdWUuIFVuaXF1ZSBJRHMgYXJlIGdlbmVyYXRlZFxuICogYXMgYSBzdHJpY3RseSBpbmNyZWFzaW5nIHNlcXVlbmNlLiBBZGFwdGVkIGZyb20gZ29vZy5nZXRVaWQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIGdldCB0aGUgdW5pcXVlIElEIGZvci5cbiAqIEByZXR1cm4ge3N0cmluZ30gVGhlIHVuaXF1ZSBJRCBmb3IgdGhlIG9iamVjdC5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFVpZChvYmopIHtcbiAgcmV0dXJuIG9iai5vbF91aWQgfHwgKG9iai5vbF91aWQgPSBTdHJpbmcoKyt1aWRDb3VudGVyXykpO1xufVxuXG4vKipcbiAqIE9wZW5MYXllcnMgdmVyc2lvbi5cbiAqIEB0eXBlIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBjb25zdCBWRVJTSU9OID0gJzguMC4wJztcbiIsIi8vIFRoZSBtb2R1bGUgY2FjaGVcbnZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcblxuLy8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbmZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG5cdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuXHRpZiAoY2FjaGVkTW9kdWxlICE9PSB1bmRlZmluZWQpIHtcblx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG5cdH1cblx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcblx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG5cdFx0Ly8gbm8gbW9kdWxlLmlkIG5lZWRlZFxuXHRcdC8vIG5vIG1vZHVsZS5sb2FkZWQgbmVlZGVkXG5cdFx0ZXhwb3J0czoge31cblx0fTtcblxuXHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cblx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cblx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcblx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xufVxuXG4iLCIvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9ucyBmb3IgaGFybW9ueSBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSAoZXhwb3J0cywgZGVmaW5pdGlvbikgPT4ge1xuXHRmb3IodmFyIGtleSBpbiBkZWZpbml0aW9uKSB7XG5cdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGRlZmluaXRpb24sIGtleSkgJiYgIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBrZXkpKSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZGVmaW5pdGlvbltrZXldIH0pO1xuXHRcdH1cblx0fVxufTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSAob2JqLCBwcm9wKSA9PiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCkpIiwiLy8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yID0gKGV4cG9ydHMpID0+IHtcblx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG5cdH1cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbn07IiwiaW1wb3J0IEdlb0pTT04gZnJvbSAnb2wvZm9ybWF0L0dlb0pTT04uanMnO1xyXG5pbXBvcnQgTWFwIGZyb20gJ29sL01hcC5qcyc7XHJcbmltcG9ydCBWaWV3IGZyb20gJ29sL1ZpZXcuanMnO1xyXG5pbXBvcnQge1xyXG4gIENpcmNsZSBhcyBDaXJjbGVTdHlsZSxcclxuICBGaWxsLFxyXG4gIFN0cm9rZSxcclxuICBTdHlsZSxcclxuICBUZXh0LFxyXG59IGZyb20gJ29sL3N0eWxlLmpzJztcclxuaW1wb3J0IHtPU00sIFZlY3RvciBhcyBWZWN0b3JTb3VyY2V9IGZyb20gJ29sL3NvdXJjZS5qcyc7XHJcbmltcG9ydCB7VGlsZSBhcyBUaWxlTGF5ZXIsIFZlY3RvciBhcyBWZWN0b3JMYXllcn0gZnJvbSAnb2wvbGF5ZXIuanMnO1xyXG5pbXBvcnQgRmVhdHVyZSBmcm9tICdvbC9GZWF0dXJlLmpzJztcclxuaW1wb3J0IHsgZnJvbUxvbkxhdCB9IGZyb20gJ29sL3Byb2onO1xyXG5pbXBvcnQgeyBDaXJjbGUgfSBmcm9tICdvbC9nZW9tJztcclxuLy9pbXBvcnQgeyBUb29sdGlwIH0gZnJvbSAnYm9vdHN0cmFwJztcclxuXHJcbmltcG9ydCBnZW9qc29uT2JqZWN0IGZyb20gJy4vZGF0YS5qcyc7XHJcblxyXG5jb25zdCBnZXRUZXh0ID0gZnVuY3Rpb24oZmVhdHVyZSkge1xyXG4gIHJldHVybiBmZWF0dXJlLmdldCgnbmFtZScpO1xyXG59O1xyXG5cclxuY29uc3QgY3JlYXRlVGV4dFN0eWxlID0gZnVuY3Rpb24oZmVhdHVyZSkge1xyXG5cclxuICByZXR1cm4gbmV3IFRleHQoeyAgICAgIFxyXG4gICAgdGV4dDogZ2V0VGV4dChmZWF0dXJlKSxcclxuICAgIGZvbnQgOiBcImJvbGQgMTBweC8xIFZlcmRhbmFcIiAsXHJcbiAgICBvdmVyZmxvdyA6IHRydWUgICAgICBcclxuICB9KTtcclxufVxyXG5cclxuY29uc3Qgc3R5bGVGdW5jdGlvbiA9IGZ1bmN0aW9uKGZlYXR1cmUpIHtcclxuICBjb25zb2xlLmxvZyhmZWF0dXJlLmdldEdlb21ldHJ5KCkuZ2V0VHlwZSgpKTtcclxuICAgIHJldHVybiBuZXcgU3R5bGUoe1xyXG4gICAgICAgIHN0cm9rZTogbmV3IFN0cm9rZSh7XHJcbiAgICAgICAgICBjb2xvcjogJ2JsdWUnLFxyXG4gICAgICAgICAgbGluZURhc2g6IFtdLFxyXG4gICAgICAgICAgd2lkdGg6IDEsXHJcbiAgICAgICAgfSksXHJcbiAgICAgICAgZmlsbDogbmV3IEZpbGwoe1xyXG4gICAgICAgICAgY29sb3I6ICdyZ2JhKDAsIDAsIDI1NSwgMC4xKScsXHJcbiAgICAgICAgfSksXHJcbiAgICAgICAgdGV4dCA6IGNyZWF0ZVRleHRTdHlsZShmZWF0dXJlKVxyXG4gICAgICB9KTtcclxuXHJcbn07XHJcblxyXG5jb25zdCBmZWF0dXJlcyA9IG5ldyBHZW9KU09OKHtcclxuICBkYXRhUHJvamVjdGlvbjogJ0VQU0c6NDMyNicsXHJcbiAgZmVhdHVyZVByb2plY3Rpb246ICdFUFNHOjM4NTcnXHJcbn0pLnJlYWRGZWF0dXJlcyhnZW9qc29uT2JqZWN0KTtcclxuXHJcbmNvbnN0IHZlY3RvclNvdXJjZSA9IG5ldyBWZWN0b3JTb3VyY2Uoe1xyXG4gICAgZmVhdHVyZXM6IGZlYXR1cmVzLFxyXG4gIH0pO1xyXG4gIFxyXG5cclxuXHJcbnZlY3RvclNvdXJjZS5hZGRGZWF0dXJlKG5ldyBGZWF0dXJlKG5ldyBDaXJjbGUoWzVlNiwgN2U2XSwgMWU2KSkpOyAgICAgIFxyXG4gIFxyXG5jb25zdCB2ZWN0b3JMYXllciA9IG5ldyBWZWN0b3JMYXllcih7XHJcbiAgICBzb3VyY2U6IHZlY3RvclNvdXJjZSxcclxuICAgIHN0eWxlOiBzdHlsZUZ1bmN0aW9uXHJcbiAgfSk7XHJcblxyXG52YXIgcmFzdGVyID0gbmV3IFRpbGVMYXllcih7XHJcbiAgICBzb3VyY2U6IG5ldyBPU00oKVxyXG4gICAgfSk7XHJcblxyXG5cclxuY29uc3QgZmlsbFRhYmxlID0gZnVuY3Rpb24oKSB7XHJcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnaGVhZGVyJyk7XHJcblxyXG59XHJcblxyXG53aW5kb3cub25sb2FkID0gZnVuY3Rpb24oZSl7IFxyXG5cclxuICBjb25zdCBpbmZvID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2luZm8nKTtcclxuaW5mby5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ25vbmUnO1xyXG4vKlxyXG5jb25zdCB0b29sdGlwID0gbmV3IGJvb3RzdHJhcC5Ub29sdGlwKGluZm8sIHtcclxuICBhbmltYXRpb246IGZhbHNlLFxyXG4gIGN1c3RvbUNsYXNzOiAncGUtbm9uZScsXHJcbiAgb2Zmc2V0OiBbMCwgMF0sXHJcbiAgdGl0bGU6ICctJyxcclxuICB0cmlnZ2VyOiAnbWFudWFsJyxcclxufSk7XHJcbiovXHJcblxyXG52YXIgbWFwID0gbmV3IE1hcCh7XHJcbiAgbGF5ZXJzOiBbcmFzdGVyLHZlY3RvckxheWVyXSxcclxuICB0YXJnZXQ6IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdtYXAnKSxcclxuICB2aWV3OiBuZXcgVmlldyh7XHJcbiAgY2VudGVyOiBmcm9tTG9uTGF0KFswLjEwODY3MDksIDUyLjI1MDc1ODVdKSxcclxuICB6b29tOiAxM1xyXG4gIH0pXHJcbn0pO1xyXG5cclxuICBsZXQgY3VycmVudEZlYXR1cmU7XHJcbiAgY29uc3QgZGlzcGxheUZlYXR1cmVJbmZvID0gZnVuY3Rpb24gKHBpeGVsLCB0YXJnZXQpIHtcclxuICAgIGNvbnN0IGZlYXR1cmUgPSB0YXJnZXQuY2xvc2VzdCgnLm9sLWNvbnRyb2wnKVxyXG4gICAgICA/IHVuZGVmaW5lZFxyXG4gICAgICA6IG1hcC5mb3JFYWNoRmVhdHVyZUF0UGl4ZWwocGl4ZWwsIGZ1bmN0aW9uIChmZWF0dXJlKSB7XHJcbiAgICAgICAgICByZXR1cm4gZmVhdHVyZTtcclxuICAgICAgICB9KTtcclxuICAgIGlmIChmZWF0dXJlKSB7XHJcbiAgICAgIGluZm8uc3R5bGUubGVmdCA9IHBpeGVsWzBdICsgJ3B4JztcclxuICAgICAgaW5mby5zdHlsZS50b3AgPSBwaXhlbFsxXSArICdweCc7XHJcbiAgICAgIGlmIChmZWF0dXJlICE9PSBjdXJyZW50RmVhdHVyZSkge1xyXG4gICAgICAgIHRvb2x0aXAuc2V0Q29udGVudCh7Jy50b29sdGlwLWlubmVyJzogZmVhdHVyZS5nZXQoJ25hbWUnKX0pO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChjdXJyZW50RmVhdHVyZSkge1xyXG4gICAgICAgIHRvb2x0aXAudXBkYXRlKCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdG9vbHRpcC5zaG93KCk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRvb2x0aXAuaGlkZSgpO1xyXG4gICAgfVxyXG4gICAgY3VycmVudEZlYXR1cmUgPSBmZWF0dXJlO1xyXG4gIH07XHJcblxyXG4gIG1hcC5vbigncG9pbnRlcm1vdmUnLCBmdW5jdGlvbiAoZXZ0KSB7XHJcbiAgICBpZiAoZXZ0LmRyYWdnaW5nKSB7XHJcbiAgICAgIHRvb2x0aXAuaGlkZSgpO1xyXG4gICAgICBjdXJyZW50RmVhdHVyZSA9IHVuZGVmaW5lZDtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgY29uc3QgcGl4ZWwgPSBtYXAuZ2V0RXZlbnRQaXhlbChldnQub3JpZ2luYWxFdmVudCk7XHJcbiAgICAvL2NvbnNvbGUubG9nKCdwaXhlbCcsIHBpeGVsWzBdLCAnICcsIHBpeGVsWzFdKTtcclxuICAgIC8vZGlzcGxheUZlYXR1cmVJbmZvKHBpeGVsLCBldnQub3JpZ2luYWxFdmVudC50YXJnZXQpO1xyXG4gIH0pO1xyXG5cclxuICBtYXAub24oJ2NsaWNrJywgZnVuY3Rpb24gKGV2dCkge1xyXG4gICAgLy9kaXNwbGF5RmVhdHVyZUluZm8oZXZ0LnBpeGVsLCBldnQub3JpZ2luYWxFdmVudC50YXJnZXQpO1xyXG4gIH0pO1xyXG5cclxuICBtYXAuZ2V0VGFyZ2V0RWxlbWVudCgpLmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJsZWF2ZScsIGZ1bmN0aW9uICgpIHtcclxuICAgIC8vdG9vbHRpcC5oaWRlKCk7XHJcbiAgICBjdXJyZW50RmVhdHVyZSA9IHVuZGVmaW5lZDtcclxuICB9KTtcclxuXHJcbiAgZmlsbFRhYmxlKCk7XHJcbn1cclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9